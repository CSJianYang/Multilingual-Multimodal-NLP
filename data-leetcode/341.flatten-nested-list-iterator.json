[
    {
        "title": "First Missing Positive",
        "question_content": "Given an unsorted integer array nums, return the smallest missing positive integer.\nYou must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,0]\nOutput: 3\nExplanation: The numbers in the range [1,2] are all in the array.\n\nExample 2:\n\nInput: nums = [3,4,-1,1]\nOutput: 2\nExplanation: 1 is in the array but 2 is missing.\n\nExample 3:\n\nInput: nums = [7,8,9,11,12]\nOutput: 1\nExplanation: The smallest positive integer 1 is missing.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t-231 <= nums[i] <= 231 - 1",
        "solutions": [
            {
                "id": 17071,
                "title": "my-short-c-solution-o-1-space-and-o-n-time",
                "content": "\\nPut each number in its right place.\\n\\nFor example:\\n\\nWhen we find 5, then swap it with A[4].\\n\\nAt last, the first place where its number is not right, return the place + 1.\\n\\n    class Solution\\n    {\\n    public:\\n        int firstMissingPositive(int A[], int n)\\n        {\\n            for(int i = 0; i < n; ++ i)\\n                while(A[i] > 0 && A[i] <= n && A[A[i] - 1] != A[i])\\n                    swap(A[i], A[A[i] - 1]);\\n            \\n            for(int i = 0; i < n; ++ i)\\n                if(A[i] != i + 1)\\n                    return i + 1;\\n            \\n            return n + 1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n    public:\\n        int firstMissingPositive(int A[], int n)\\n        {\\n            for(int i = 0; i < n; ++ i)\\n                while(A[i] > 0 && A[i] <= n && A[A[i] - 1] != A[i])\\n                    swap(A[i], A[A[i] - 1]);\\n            \\n            for(int i = 0; i < n; ++ i)\\n                if(A[i] != i + 1)\\n                    return i + 1;\\n            \\n            return n + 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 17080,
                "title": "python-o-1-space-o-n-time-solution-with-explanation",
                "content": "     def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n         Basic idea:\\n        1. for any array whose length is l, the first missing positive must be in range [1,...,l+1], \\n            so we only have to care about those elements in this range and remove the rest.\\n        2. we can use the array index as the hash to restore the frequency of each number within \\n             the range [1,...,l+1] \\n        \"\"\"\\n        nums.append(0)\\n        n = len(nums)\\n        for i in range(len(nums)): #delete those useless elements\\n            if nums[i]<0 or nums[i]>=n:\\n                nums[i]=0\\n        for i in range(len(nums)): #use the index as the hash to record the frequency of each number\\n            nums[nums[i]%n]+=n\\n        for i in range(1,len(nums)):\\n            if nums[i]/n==0:\\n                return i\\n        return n",
                "solutionTags": [],
                "code": "     def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n         Basic idea:\\n        1. for any array whose length is l, the first missing positive must be in range [1,...,l+1], \\n            so we only have to care about those elements in this range and remove the rest.\\n        2. we can use the array index as the hash to restore the frequency of each number within \\n             the range [1,...,l+1] \\n        \"\"\"\\n        nums.append(0)\\n        n = len(nums)\\n        for i in range(len(nums)): #delete those useless elements\\n            if nums[i]<0 or nums[i]>=n:\\n                nums[i]=0\\n        for i in range(len(nums)): #use the index as the hash to record the frequency of each number\\n            nums[nums[i]%n]+=n\\n        for i in range(1,len(nums)):\\n            if nums[i]/n==0:\\n                return i\\n        return n",
                "codeTag": "Python3"
            },
            {
                "id": 17214,
                "title": "java-simple-solution-with-documentation",
                "content": "This code takes advantage of two insights: \\n\\n 1. Numbers greater then n can be ignored because the missing integer must be in the range 1..n+1\\n 2. If each cell in the array were to contain positive integers only, we can use the negative of the stored number as a flag to mark something (in this case the flag indicates this index was found in some cell of the array)\\n\\n        public class Solution {\\n        public int firstMissingPositive(int[] nums) {\\n            int n = nums.length;\\n            \\n            // 1. mark numbers (num < 0) and (num > n) with a special marker number (n+1) \\n            // (we can ignore those because if all number are > n then we'll simply return 1)\\n            for (int i = 0; i < n; i++) {\\n                if (nums[i] <= 0 || nums[i] > n) {\\n                    nums[i] = n + 1;\\n                }\\n            }\\n            // note: all number in the array are now positive, and on the range 1..n+1\\n            \\n            // 2. mark each cell appearing in the array, by converting the index for that number to negative\\n            for (int i = 0; i < n; i++) {\\n                int num = Math.abs(nums[i]);\\n                if (num > n) {\\n                    continue;\\n                }\\n                num--; // -1 for zero index based array (so the number 1 will be at pos 0)\\n                if (nums[num] > 0) { // prevents double negative operations\\n                    nums[num] = -1 * nums[num];\\n                }\\n            }\\n            \\n            // 3. find the first cell which isn't negative (doesn't appear in the array)\\n            for (int i = 0; i < n; i++) {\\n                if (nums[i] >= 0) {\\n                    return i + 1;\\n                }\\n            }\\n            \\n            // 4. no positive numbers were found, which means the array contains all numbers 1..n\\n            return n + 1;\\n        }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int firstMissingPositive(int[] nums) {\\n            int n = nums.length;\\n            \\n            // 1. mark numbers (num < 0) and (num > n) with a special marker number (n+1) \\n            // (we can ignore those because if all number are > n then we'll simply return 1)\\n            for (int i = 0; i < n; i++) {\\n                if (nums[i] <= 0 || nums[i] > n) {\\n                    nums[i] = n + 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 17083,
                "title": "o-1-space-java-solution",
                "content": "The key here is to use swapping to keep constant space and also make use of the length of the array, which means there can be at most n positive integers. So each time we encounter an valid integer, find its correct position and swap. Otherwise we continue.\\n\\n    public class Solution {\\n        public int firstMissingPositive(int[] A) {\\n            int i = 0;\\n            while(i < A.length){\\n                if(A[i] == i+1 || A[i] <= 0 || A[i] > A.length) i++;\\n                else if(A[A[i]-1] != A[i]) swap(A, i, A[i]-1);\\n                else i++;\\n            }\\n            i = 0;\\n            while(i < A.length && A[i] == i+1) i++;\\n            return i+1;\\n        }\\n        \\n        private void swap(int[] A, int i, int j){\\n            int temp = A[i];\\n            A[i] = A[j];\\n            A[j] = temp;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int firstMissingPositive(int[] A) {\\n            int i = 0;\\n            while(i < A.length){\\n                if(A[i] == i+1 || A[i] <= 0 || A[i] > A.length) i++;\\n                else if(A[A[i]-1] != A[i]) swap(A, i, A[i]-1);\\n                else i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 17073,
                "title": "share-my-o-n-time-o-1-space-solution",
                "content": "## Share my O(n)/O(1) solution ##\\n\\n----------\\nThe basic idea is ***for any k positive numbers (duplicates allowed), the first missing positive number must be within [1,k+1]***. The reason is like you put k balls into k+1 bins, there must be a bin empty, the empty bin can be viewed as the missing number. \\n\\n----------\\n\\n 1. Unfortunately, there are 0 and negative numbers in the array, so firstly I think of using partition technique (used in quick sort) to put all positive numbers together in one side. This can be finished in O(n) time, O(1) space. \\n 2. After partition step, you get all the positive numbers lying within A[0,k-1]. Now, According to the basic idea, I infer the first missing number must be within [1,k+1]. I decide to use A[i] (0<=i<=k-1) to indicate whether the number (i+1) exists. But here I still have to main the original information A[i] holds. Fortunately, A[i] are all positive numbers, so I can set them to negative to indicate the existence of (i+1) and I can still use abs(A[i]) to get the original information A[i] holds.\\n 3. After step 2, I can again scan all elements between A[0,k-1] to find the first positive element A[i], that means (i+1) doesn't exist, which is what I want.\\n\\n----------\\n\\n     public int firstMissingPositive(int[] A) {\\n        int n=A.length;\\n        if(n==0)\\n            return 1;\\n        int k=partition(A)+1;\\n        int temp=0;\\n        int first_missing_Index=k;\\n        for(int i=0;i<k;i++){\\n            temp=Math.abs(A[i]);\\n            if(temp<=k)\\n                A[temp-1]=(A[temp-1]<0)?A[temp-1]:-A[temp-1];\\n        }\\n        for(int i=0;i<k;i++){\\n            if(A[i]>0){\\n                first_missing_Index=i;\\n                break;\\n            }\\n        }\\n        return first_missing_Index+1;\\n    }\\n    \\n    public int partition(int[] A){\\n        int n=A.length;\\n        int q=-1;\\n        for(int i=0;i<n;i++){\\n            if(A[i]>0){\\n                q++;\\n                swap(A,q,i);\\n            }\\n        }\\n        return q;\\n    }\\n    \\n    public void swap(int[] A, int i, int j){\\n        if(i!=j){\\n            A[i]^=A[j];\\n            A[j]^=A[i];\\n            A[i]^=A[j];\\n        }\\n    }",
                "solutionTags": [],
                "code": "## Share my O(n)/O(1) solution ##\\n\\n----------\\nThe basic idea is ***for any k positive numbers (duplicates allowed), the first missing positive number must be within [1,k+1]***. The reason is like you put k balls into k+1 bins, there must be a bin empty, the empty bin can be viewed as the missing number. \\n\\n----------\\n\\n 1. Unfortunately, there are 0 and negative numbers in the array, so firstly I think of using partition technique (used in quick sort) to put all positive numbers together in one side. This can be finished in O(n) time, O(1) space. \\n 2. After partition step, you get all the positive numbers lying within A[0,k-1]. Now, According to the basic idea, I infer the first missing number must be within [1,k+1]. I decide to use A[i] (0<=i<=k-1) to indicate whether the number (i+1) exists. But here I still have to main the original information A[i] holds. Fortunately, A[i] are all positive numbers, so I can set them to negative to indicate the existence of (i+1) and I can still use abs(A[i]) to get the original information A[i] holds.\\n 3. After step 2, I can again scan all elements between A[0,k-1] to find the first positive element A[i], that means (i+1) doesn't exist, which is what I want.\\n\\n----------\\n\\n     public int firstMissingPositive(int[] A) {\\n        int n=A.length;\\n        if(n==0)\\n            return 1;\\n        int k=partition(A)+1;\\n        int temp=0;\\n        int first_missing_Index=k;\\n        for(int i=0;i<k;i++){\\n            temp=Math.abs(A[i]);\\n            if(temp<=k)\\n                A[temp-1]=(A[temp-1]<0)?A[temp-1]:-A[temp-1];\\n        }\\n        for(int i=0;i<k;i++){\\n            if(A[i]>0){\\n                first_missing_Index=i;\\n                break;\\n            }\\n        }\\n        return first_missing_Index+1;\\n    }\\n    \\n    public int partition(int[] A){\\n        int n=A.length;\\n        int q=-1;\\n        for(int i=0;i<n;i++){\\n            if(A[i]>0){\\n                q++;\\n                swap(A,q,i);\\n            }\\n        }\\n        return q;\\n    }\\n    \\n    public void swap(int[] A, int i, int j){\\n        if(i!=j){\\n            A[i]^=A[j];\\n            A[j]^=A[i];\\n            A[i]^=A[j];\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 781724,
                "title": "c-simple-5-line-solution-o-n-time-and-o-1-space",
                "content": "We only need to keep track of which ones of the first n positive integers occur in the array. To do this with no extra space, we can treat the array like a boolean array, where sign(arr[i]) indicates whether the i-th positive integer is present or not. First, we replace all non-positive values with n + 1, since we\\'ll only use these indices as storage space. Then, for every one of the first n positive numbers in the array, we turn the value at their corresponding index negative. Finally, all we need to do is check for the first positive value, which will give us the first missing positive. If we find no such index, then all natural numbers up to n are present, so we return n + 1.\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) if (nums[i] <= 0) nums[i] = n + 1;\\n        for (int i = 0; i < n; i++) if (abs(nums[i]) <= n && nums[abs(nums[i]) - 1] > 0) nums[abs(nums[i]) - 1] *= -1;\\n        for (int i = 0; i < n; i++) if (nums[i] > 0) return i + 1;\\n        return n + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) if (nums[i] <= 0) nums[i] = n + 1;\\n        for (int i = 0; i < n; i++) if (abs(nums[i]) <= n && nums[abs(nums[i]) - 1] > 0) nums[abs(nums[i]) - 1] *= -1;\\n        for (int i = 0; i < n; i++) if (nums[i] > 0) return i + 1;\\n        return n + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767105,
                "title": "short-c-o-n-time-o-1-space-steps-explained",
                "content": "**Approach :** \\nIt is evident that the answer lies between ```[1,n+1]```. So bring all the elements to their respective position\\ni.e if the element is 3 bring it to 3rd position or 2nd index.\\nfor example if the array is ```[3,1,-4,7]``` let\\'s say it is nums.\\niterate through the array and **neglect the element if it is greater than n or leass than equal to 0**.\\notherwise bring it to its position by swapping using condition ```while(nums[i]!=nums[nums[i]-1])```.\\n1. at index 0 ```3 != nums[3-1]``` hence swap and the array becomes ```[-4,1,3,7]```\\n2. now at index 0 value is negative hence neglect and move forward.\\n3. at index 1 ```1!=nums[1-1]``` hence swap now the array becomes ```[1,-4,3,7]```\\n4. now at index 1 value is negative hence neglect and move forward.\\n5. at index 2 ```3==nums[3-1]``` the condition is true and 3 is at right position hence neglect and move forward.\\n6. at index 3 value is 7 which is greater than n hence neglect\\n\\nSo the final array is ```[1,-4,3,7]```\\nnow iterate through this array and find the first index for which ```nums[i]!=i+1``` or the element which is not at correct position.\\nthis is the answer so in ```[1,-4,3,7]``` ans is 2.\\n\\n**so you have to swap if** ```nums[i]!=nums[nums[i]-1]``` along with the condition  ```0<nums[i]<=n``` **for all the index.**\\n\\npls Upvote if you like it...\\n\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            while(nums[i]>0 and nums[i]<=n and nums[i]!=nums[nums[i]-1])\\n                swap(nums[i],nums[nums[i]-1]);\\n        }\\n        for(int i=0 ; i<n ; i++) if(nums[i] != i+1) return i+1;\\n        return n+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```[1,n+1]```\n```[3,1,-4,7]```\n```while(nums[i]!=nums[nums[i]-1])```\n```3 != nums[3-1]```\n```[-4,1,3,7]```\n```1!=nums[1-1]```\n```[1,-4,3,7]```\n```3==nums[3-1]```\n```[1,-4,3,7]```\n```nums[i]!=i+1```\n```[1,-4,3,7]```\n```nums[i]!=nums[nums[i]-1]```\n```0<nums[i]<=n```\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            while(nums[i]>0 and nums[i]<=n and nums[i]!=nums[nums[i]-1])\\n                swap(nums[i],nums[nums[i]-1]);\\n        }\\n        for(int i=0 ; i<n ; i++) if(nums[i] != i+1) return i+1;\\n        return n+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872448,
                "title": "python-o-n-solution-with-constant-space-explained-with-clear-train-of-thoughts",
                "content": "\\u2014\\u2014Jump to the final code if you\\'re easly bored, down below!\\n\\nOk, you\\'re still here eh. Here are the train of thoughts to arrive to the final solution:\\n\\n* The answer is always between `1` to `length of nums + 1`. Why? Because the biggest positive integer we can put as answer for the input of length n, is when the input is `[1, 2, 3, ..., n]`, in that case the answer is `n+1`. Otherwise, if the input is not exactly as mentioned (in any order), then the answer must be a positive integer that is less than `n+1`. \\n\\n* Given that the answer is limited to said range, then we can simply solve this with linear time and linear space. We can create a `flag` booleans that indicate whether an `index` is appearing in the `nums` or not. See simple code below!\\n```Python\\nflags = [False] * len(nums)\\n\\nfor num in nums:\\n\\tif num > 0:\\n\\t\\tflags[num-1] = True // notice that we -1, so that the answer set 1..n becomes 0-indexed 0..n-1\\n\\t\\t\\nfor index in range(len(flags)):\\n\\tif flags[index] == False:\\n\\t\\treturn index + 1\\n\\t\\t\\nreturn len(nums) + 1 // happens when all flags are true\\n```\\n\\n* Now, how do we improve this to be a better solution with constant additional space? In other words, how to get rid of the additional booleans? You can probably guess it already. Yes by using the original `nums` array as flags. \\n\\n* Let say we flag it by changing the value in `index` to `None` if it\\'s appearing in `nums`. Problem? Yes, we still need to retain the original values in `nums`, because as we loop over the `nums` to flag the `index`, we will definitely get in trouble if the `index` we\\'re flagging hasn\\'t been evaluated yet. Take an example of `[3,1,2]` (which supposed to have the answer `4`), here is how the `nums` array is being evaluated, in each loop-step:\\n** Before loop: `[3,1,2]`\\n** Loop at index 0: `[3, 1, None]`. The `index` that `3` points to is index `2`, therefore the value becomes `None`.  This is the part where we change index `2`, while index `2` itself hasn\\'t been evaluated yet.\\n** Loop at index 1: `[None, 1, None]`. The `index` that `1` points to is index `0`, therefore the value becomes `None`.\\n** Loop at index 2: `[None, 1, None]`. At this step, it\\'s doing nothing because the original value of `2` has already been changed to `None`, and we have no way to flag index `1` as `None`.\\n\\n*  So how do we flag elements in `nums` while also retaining original `value` **that matters**? Notice I mentioned \\'that matters\\', because we only care about positive integers. We can simply discard anything that is not positive integers. And because of that, we can use positive and negative value as flag\\u2014multiply the value with `-1` to flag it so it becomes negative. So positive means hasn\\'t been flagged, negative means has been flagged. Whether it\\'s positive or negative, we can get the original value with `abs`. So for above example, the correct steps would be:\\n** Before loop: `[3, 1, 2]`\\n** Loop at index 0: `[3, 1, -2]`\\n** Loop at index 1: `[-3, 1, -2]`\\n** Loop at index 2: `[-3, -1, -2]`\\nAnd finally when we\\'re looking for the answer, we find that all the values are negative (flagged), therefore the answer is `4`.\\n\\n* Final thoughts: what about those zeros and negative nums??? Simply change them to 0 before entering the main algorithm explained above. We just need to be careful not to multiply those zeros to `-1` when flagging, instead change it to something like `-inf` (as long as it\\'s a negative value, then it\\'s flagged) \\n\\nHere is the final full code:\\n```python\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n\\tfor i,num in enumerate(nums):\\n\\t\\tif num <= 0:\\n\\t\\t\\tnums[i] = 0\\n\\n\\tfor i,num in enumerate(nums):\\n\\t\\tindex = abs(num)-1\\n\\t\\tif index >= 0 and index < len(nums):\\n\\t\\t\\tif nums[index] == 0:\\n\\t\\t\\t\\tnums[index] = -inf\\n\\t\\t\\telif nums[index] > 0: // we dont want to make negative to be positive again, when its duplicated num\\n\\t\\t\\t\\tnums[index] *= -1\\n\\n\\tfor index,num in enumerate(nums):\\n\\t\\tif num >= 0:\\n\\t\\t\\treturn index + 1\\n\\n\\treturn len(nums) + 1\\n```\\n\\nTime Complexity: O(N)\\nSpace Complexity: O(1)\\n\\nPlease upvote if you find this useful, comment if you find any improvement points!\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Python\\nflags = [False] * len(nums)\\n\\nfor num in nums:\\n\\tif num > 0:\\n\\t\\tflags[num-1] = True // notice that we -1, so that the answer set 1..n becomes 0-indexed 0..n-1\\n\\t\\t\\nfor index in range(len(flags)):\\n\\tif flags[index] == False:\\n\\t\\treturn index + 1\\n\\t\\t\\nreturn len(nums) + 1 // happens when all flags are true\\n```\n```python\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n\\tfor i,num in enumerate(nums):\\n\\t\\tif num <= 0:\\n\\t\\t\\tnums[i] = 0\\n\\n\\tfor i,num in enumerate(nums):\\n\\t\\tindex = abs(num)-1\\n\\t\\tif index >= 0 and index < len(nums):\\n\\t\\t\\tif nums[index] == 0:\\n\\t\\t\\t\\tnums[index] = -inf\\n\\t\\t\\telif nums[index] > 0: // we dont want to make negative to be positive again, when its duplicated num\\n\\t\\t\\t\\tnums[index] *= -1\\n\\n\\tfor index,num in enumerate(nums):\\n\\t\\tif num >= 0:\\n\\t\\t\\treturn index + 1\\n\\n\\treturn len(nums) + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 17161,
                "title": "python-o-n-and-o-nlgn-solutions",
                "content": "        \\n    # O(n) time\\n    def firstMissingPositive(self, nums):\\n        for i in xrange(len(nums)):\\n            while 0 <= nums[i]-1 < len(nums) and nums[nums[i]-1] != nums[i]:\\n                tmp = nums[i]-1\\n                nums[i], nums[tmp] = nums[tmp], nums[i]\\n        for i in xrange(len(nums)):\\n            if nums[i] != i+1:\\n                return i+1\\n        return len(nums)+1\\n        \\n    # O(nlgn) time\\n    def firstMissingPositive(self, nums):\\n        nums.sort()\\n        res = 1\\n        for num in nums:\\n            if num == res:\\n                res += 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    # O(n) time\\n    def firstMissingPositive(self, nums):\\n        for i in xrange(len(nums)):\\n            while 0 <= nums[i]-1 < len(nums) and nums[nums[i]-1] != nums[i]:\\n                tmp = nums[i]-1\\n                nums[i], nums[tmp] = nums[tmp], nums[i]\\n        for i in xrange(len(nums)):\\n            if nums[i] != i+1:\\n                return i+1\\n        return len(nums)+1\\n        \\n    # O(nlgn) time\\n    def firstMissingPositive(self, nums):\\n        nums.sort()\\n        res = 1\\n        for num in nums:\\n            if num == res:\\n                res += 1\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 858526,
                "title": "cyclic-sort-explained",
                "content": "All the questions where we need to find the repeating numbers, or missing numbers can easily be solved with the help of a pattern that is cyclic sort. In this pattern we simply place the elements of the array on their positions( or at least try to ), like 1 should be at 1st position and 2 at the second position, and then we iterate again and check if for any index we have an element whose value is not equal to index + 1, then that is the missing number.\\n\\nYou can follow this link to learn [more](https://emre.me/coding-patterns/cyclic-sort/)\\n\\nIn this question we can simply ignore the -ve elements as we only need to find the smallest positive element, so we ignore elements that are less than 0 and greater than arrays length and swap only if the element is not at its correct posiition. Then we iterate again and find the missing number and return it.\\n\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int i = 0;\\n        while( i < nums.length){\\n            if(nums[i] > 0 && nums[i] <= nums.length && nums[i] != nums[nums[i] - 1]){\\n                swap(nums,i,nums[i] - 1);\\n            }else{\\n                i++;\\n            }\\n        }\\n        for(i = 0;i<nums.length;i++){\\n            if(nums[i] != i + 1){\\n                return i + 1;\\n            }\\n        }\\n        return nums.length + 1;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int i = 0;\\n        while( i < nums.length){\\n            if(nums[i] > 0 && nums[i] <= nums.length && nums[i] != nums[nums[i] - 1]){\\n                swap(nums,i,nums[i] - 1);\\n            }else{\\n                i++;\\n            }\\n        }\\n        for(i = 0;i<nums.length;i++){\\n            if(nums[i] != i + 1){\\n                return i + 1;\\n            }\\n        }\\n        return nums.length + 1;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17126,
                "title": "beat-100-fast-elegant-java-index-based-solution-with-explanation",
                "content": "The basic idea is to traversal and try to move the current value to position whose index is exactly the value (swap them). Then travelsal again to find the first unusal value, which can not be corresponding to its index.\\n\\n    public int firstMissingPositive(int[] nums) {\\n\\n\\t\\tint i = 0, n = nums.length;\\n\\t\\twhile (i < n) {\\n            // If the current value is in the range of (0,length) and it's not at its correct position, \\n            // swap it to its correct position.\\n            // Else just continue;\\n\\t\\t\\tif (nums[i] >= 0 && nums[i] < n && nums[nums[i]] != nums[i])\\n\\t\\t\\t\\tswap(nums, i, nums[i]);\\n\\t\\t\\telse\\n\\t\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tint k = 1;\\n\\n        // Check from k=1 to see whether each index and value can be corresponding.\\n\\t\\twhile (k < n && nums[k] == k)\\n\\t\\t\\tk++;\\n\\n        // If it breaks because of empty array or reaching the end. K must be the first missing number.\\n\\t\\tif (n == 0 || k < n)\\n\\t\\t\\treturn k;\\n\\t\\telse   // If k is hiding at position 0, K+1 is the number. \\n\\t\\t\\treturn nums[0] == k ? k + 1 : k;\\n\\n\\t}\\n\\n\\tprivate void swap(int[] nums, int i, int j) {\\n\\t\\tint temp = nums[i];\\n\\t\\tnums[i] = nums[j];\\n\\t\\tnums[j] = temp;\\n\\t}",
                "solutionTags": [],
                "code": "The basic idea is to traversal and try to move the current value to position whose index is exactly the value (swap them). Then travelsal again to find the first unusal value, which can not be corresponding to its index.\\n\\n    public int firstMissingPositive(int[] nums) {\\n\\n\\t\\tint i = 0, n = nums.length;\\n\\t\\twhile (i < n) {\\n            // If the current value is in the range of (0,length) and it's not at its correct position, \\n            // swap it to its correct position.\\n            // Else just continue;\\n\\t\\t\\tif (nums[i] >= 0 && nums[i] < n && nums[nums[i]] != nums[i])\\n\\t\\t\\t\\tswap(nums, i, nums[i]);\\n\\t\\t\\telse\\n\\t\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tint k = 1;\\n\\n        // Check from k=1 to see whether each index and value can be corresponding.\\n\\t\\twhile (k < n && nums[k] == k)\\n\\t\\t\\tk++;\\n\\n        // If it breaks because of empty array or reaching the end. K must be the first missing number.\\n\\t\\tif (n == 0 || k < n)\\n\\t\\t\\treturn k;\\n\\t\\telse   // If k is hiding at position 0, K+1 is the number. \\n\\t\\t\\treturn nums[0] == k ? k + 1 : k;\\n\\n\\t}\\n\\n\\tprivate void swap(int[] nums, int i, int j) {\\n\\t\\tint temp = nums[i];\\n\\t\\tnums[i] = nums[j];\\n\\t\\tnums[j] = temp;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 17168,
                "title": "a-very-nice-solution-from-ants-aasma-stackoverflow",
                "content": "time complexity is O(N) and space complexity is O(1). <br>\\nLink: http://stackoverflow.com/questions/1586858/find-the-smallest-integer-not-in-a-list <br>\\nPosted by Ants Aasma on Oct 20 '09.\\n\\nThe code is pasted here: <br>\\n\\n    #Pass 1, move every value to the position of its value\\n    for cursor in range(N): \\n        target = array[cursor]\\n        while target < N and target != array[target]:\\n            new_target = array[target]\\n            array[target] = target\\n            target = new_target\\n    \\n    #Pass 2, find first location where the index doesn't match the value\\n    for cursor in range(N):\\n        if array[cursor] != cursor:\\n            return cursor\\n    return N",
                "solutionTags": [],
                "code": "time complexity is O(N) and space complexity is O(1). <br>\\nLink: http://stackoverflow.com/questions/1586858/find-the-smallest-integer-not-in-a-list <br>\\nPosted by Ants Aasma on Oct 20 '09.\\n\\nThe code is pasted here: <br>\\n\\n    #Pass 1, move every value to the position of its value\\n    for cursor in range(N): \\n        target = array[cursor]\\n        while target < N and target != array[target]:\\n            new_target = array[target]\\n            array[target] = target\\n            target = new_target\\n    \\n    #Pass 2, find first location where the index doesn't match the value\\n    for cursor in range(N):\\n        if array[cursor] != cursor:\\n            return cursor\\n    return N",
                "codeTag": "Unknown"
            },
            {
                "id": 3765193,
                "title": "cycle-sort-o-n-o-1-easy-java-solution-detailed-explanation-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a hard question, because it is hidden in the question, that cycle sort will be used in solving this. Once, you can see why cycle sort will be used and how it will be used, this becomes easy. :)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, basically we are gonna apply cycle sort, but we will ignore negative elements, because positive element is asked in the question. Also, we will ignore all those elements who values are greater than the size of the array. In this way, the first element in the array which is not present in its correct position (index), will be the answer.\\nWhat I mean by correct position is that, in cycle sort, in this question, if we follow the above approach, then index 0 will have element whose value is 1, index 1 will have 2, index 2 will have 3 and so on, and the first element to break this rule, that index, plus 1 will be our answer, because at that index the correct element which was to exist there was an element whose value is index + 1, but if there is some incorrect element present, then index + 1 element is the first missing positive and hence it is the answer.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n    \\n        //the first two conditions in the if statement take care \\n        //that negatives and elements greater than the size of \\n        //the array are ignored, while applying cycle sort, and \\n        //rest is the similar code of cycle sort\\n\\n        int i = 0;\\n        while(i < nums.length) {\\n            int correct = nums[i] - 1;\\n            if(nums[i] <= nums.length && nums[i] > 0 && nums[i] != nums[correct]) {\\n\\n                int temp = nums[i];\\n                nums[i] = nums[correct];\\n                nums[correct] = temp;\\n            }\\n            else {\\n                i++;\\n            }\\n        }\\n\\n        int count = 0;\\n\\n    //after cycle sort has been applied, we will find the first element\\n    //which is not at the correct index, and return that index + 1\\n\\n        for(int j = 0; j < nums.length; j++) {\\n\\n            if(nums[j] != j + 1) {\\n                return j + 1;\\n            }\\n        }\\n\\n    //if every element is at its correct index, then obviously the first\\n    //missing positive integer is nums.length + 1\\n\\n        return nums.length + 1;\\n    }\\n}\\n```\\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/534c581c-ce0e-4b09-8c2e-40e316fe3417_1689353156.4622288.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n    \\n        //the first two conditions in the if statement take care \\n        //that negatives and elements greater than the size of \\n        //the array are ignored, while applying cycle sort, and \\n        //rest is the similar code of cycle sort\\n\\n        int i = 0;\\n        while(i < nums.length) {\\n            int correct = nums[i] - 1;\\n            if(nums[i] <= nums.length && nums[i] > 0 && nums[i] != nums[correct]) {\\n\\n                int temp = nums[i];\\n                nums[i] = nums[correct];\\n                nums[correct] = temp;\\n            }\\n            else {\\n                i++;\\n            }\\n        }\\n\\n        int count = 0;\\n\\n    //after cycle sort has been applied, we will find the first element\\n    //which is not at the correct index, and return that index + 1\\n\\n        for(int j = 0; j < nums.length; j++) {\\n\\n            if(nums[j] != j + 1) {\\n                return j + 1;\\n            }\\n        }\\n\\n    //if every element is at its correct index, then obviously the first\\n    //missing positive integer is nums.length + 1\\n\\n        return nums.length + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17135,
                "title": "java-solution-with-integers-encode-trick-explained",
                "content": "This is not the most concise solution but it has one trick that may be useful for many beginners that allows to encode two integers into one with possibility to decode it to both integers back. Once you know it you will always use it as it allows to avoid tuples of integers (as java lacks such structure in its libraries) and use just one integer to represent two.\\n\\nSo, if we have two integers `k` and `m` and `m` is always less than some `n` - we can encode both into one integer using formula:\\n\\n    r = k * n + m\\n    (m < n)\\n\\nand now to retrieve them use the following:\\n\\n    k = r / n\\n    m = r % n\\n\\nAnd just to repeat: this trick is possible only if `m` is strictly less than `n`\\n\\nUsing this trick we can solve many interview tasks that require constant space and have some array which contains integers less than size or array `n`. If this array requires some extra information for every item, but we cannot loose the initial item value - this can be solved either creating new array (simple) or just encoding initial value and new value directly in the array.\\n\\n**Turning back to the task:** \\n\\nWe want to \"seriallize\" all values to their indices. So \"1\" will come to `nums[0]`, \"2\" - `nums[1]` etc. After this we can easily find the \"gap\". This is an easy task if we could use extra memory for another array. But we cannot. So we can use the \"encoding\" scheme offered above:\\n\\n1.clean every non-relevant item from the array to match the restriction `m < n`:\\n \\n\\n    int n = nums.length;\\n    for (int i = 0; i < n; i++) {\\n         if (nums[i] <= 0 || nums[i] > n) nums[i] = 0;\\n    }\\n2.Encode all items to their matching positions:\\n\\n    int m = n + 1;\\n    for (int i = 0; i < n; i++) {\\n        // retrieve the value that initially was at index i (it could be overwritten by encoding)\\n        int prev = nums[i] % m;\\n        if (prev > 0) \\n            // encode it using formula k * n + m, where for 'm' we also use decoding schema\\n            nums[prev - 1] = (prev * m) + nums[prev - 1] % m;\\n    }\\n\\n3.Find the gap:\\n\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] / m != i + 1) return i + 1;\\n    }\\n\\nAll in one:\\n\\n    public int firstMissingPositive(int[] nums) {\\n        int n = nums.length;\\n        int m = n + 1;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] <= 0 || nums[i] > n) nums[i] = 0;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int prev = nums[i] % m;\\n            if (prev > 0) \\n                nums[prev - 1] = (prev * m) + nums[prev - 1] % m;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] / m != i + 1) return i + 1;\\n        }\\n        return m;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "This is not the most concise solution but it has one trick that may be useful for many beginners that allows to encode two integers into one with possibility to decode it to both integers back. Once you know it you will always use it as it allows to avoid tuples of integers (as java lacks such structure in its libraries) and use just one integer to represent two.\\n\\nSo, if we have two integers `k` and `m` and `m` is always less than some `n` - we can encode both into one integer using formula:\\n\\n    r = k * n + m\\n    (m < n)\\n\\nand now to retrieve them use the following:\\n\\n    k = r / n\\n    m = r % n\\n\\nAnd just to repeat: this trick is possible only if `m` is strictly less than `n`\\n\\nUsing this trick we can solve many interview tasks that require constant space and have some array which contains integers less than size or array `n`. If this array requires some extra information for every item, but we cannot loose the initial item value - this can be solved either creating new array (simple) or just encoding initial value and new value directly in the array.\\n\\n**Turning back to the task:** \\n\\nWe want to \"seriallize\" all values to their indices. So \"1\" will come to `nums[0]`, \"2\" - `nums[1]` etc. After this we can easily find the \"gap\". This is an easy task if we could use extra memory for another array. But we cannot. So we can use the \"encoding\" scheme offered above:\\n\\n1.clean every non-relevant item from the array to match the restriction `m < n`:\\n \\n\\n    int n = nums.length;\\n    for (int i = 0; i < n; i++) {\\n         if (nums[i] <= 0 || nums[i] > n) nums[i] = 0;\\n    }\\n2.Encode all items to their matching positions:\\n\\n    int m = n + 1;\\n    for (int i = 0; i < n; i++) {\\n        // retrieve the value that initially was at index i (it could be overwritten by encoding)\\n        int prev = nums[i] % m;\\n        if (prev > 0) \\n            // encode it using formula k * n + m, where for 'm' we also use decoding schema\\n            nums[prev - 1] = (prev * m) + nums[prev - 1] % m;\\n    }\\n\\n3.Find the gap:\\n\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] / m != i + 1) return i + 1;\\n    }\\n\\nAll in one:\\n\\n    public int firstMissingPositive(int[] nums) {\\n        int n = nums.length;\\n        int m = n + 1;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] <= 0 || nums[i] > n) nums[i] = 0;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int prev = nums[i] % m;\\n            if (prev > 0) \\n                nums[prev - 1] = (prev * m) + nums[prev - 1] % m;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] / m != i + 1) return i + 1;\\n        }\\n        return m;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17286,
                "title": "my-c-solution-4-ms",
                "content": "    class Solution {\\n    public:\\n        int firstMissingPositive(vector<int>& nums) {\\n            for(int i=0; i<nums.size(); i++){\\n                if(i+1==nums[i]) continue;\\n                int x = nums[i];\\n                while(x>=1 && x<=nums.size() && x!=nums[x-1]){\\n                    swap(x, nums[x-1]);\\n                }\\n            }\\n            for(int i=0; i<nums.size(); i++){\\n                if(i+1!=nums[i])    return i+1;\\n            }\\n            return nums.size()+1;\\n        }\\n    };\\n\\nSince we can not use extra space, so thinking about using the nums vector itself to record a positive number occurred.",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int firstMissingPositive(vector<int>& nums) {\\n            for(int i=0; i<nums.size(); i++){\\n                if(i+1==nums[i]) continue;\\n                int x = nums[i];\\n                while(x>=1 && x<=nums.size() && x!=nums[x-1]){\\n                    swap(x, nums[x-1]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 17204,
                "title": "o-n-time-o-1-space-c",
                "content": "Idea is to swap each positive integer you encounter to its \"rightful\" place at index (x-1) where x is the integer. It's O(n) because you visit each integer in at most 2 unique loop iterations. \\n\\n    class Solution {\\n    public:\\n        int firstMissingPositive(int A[], int n) {\\n            int i,j;\\n            for(i=0;i<n;i++){\\n                int cur=A[i];\\n                // if in place or non-pos or out of bounds, skip.\\n                if(cur==i+1||cur<=0||cur>n)continue;\\n                swap(A[i],A[cur-1]);\\n                // if not the same, then reprocess it.\\n                if(A[i]!=A[cur-1])\\n                    i--;\\n            }\\n            \\n            for(i=0;i<n;i++)\\n                if(A[i]!=i+1) \\n                    return i+1;\\n            return n+1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int firstMissingPositive(int A[], int n) {\\n            int i,j;\\n            for(i=0;i<n;i++){\\n                int cur=A[i];\\n                // if in place or non-pos or out of bounds, skip.\\n                if(cur==i+1||cur<=0||cur>n)continue;\\n                swap(A[i],A[cur-1]);\\n                // if not the same, then reprocess it.\\n                if(A[i]!=A[cur-1])\\n                    i--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 871665,
                "title": "python-o-n-solution-without-additional-memory-explained",
                "content": "Notice, that first missinig positive will always be in range `1,2,...n,n+1`, where `n` is length of `nums`. Let us rearrange numbers, putting each number on its place: number `i` on place `i-1` (because indexes start with `0`): let us iterate over our numbers and change two numbers if one of them not on its place: we break if number not in range `1,...,n` or if we are trying to put number on the place, which is already occupied with this place (because we have infinite loop in this case)\\n\\nWhen we iterate all numbers we find for number which is not on its place, using `i == nums[i] - 1`. It can happen that all numbers between `1` and `n` are here, so I add `[0]` to the end. Finally, I found index of `False` in this array: it will be our number.\\n\\n**Complexity**: even though we have `while` loop inside `for` loop, complexity will be `O(n)`: on each step we put at least one number to its proper place. Additional space complexity is `O(1)`, however we modify our `nums`.\\n\\nThis solution is very similar to problem **442. Find All Duplicates in an Array**, see my detailed solution here https://leetcode.com/problems/find-all-duplicates-in-an-array/discuss/775738/Python-2-solutions-with-O(n)-timeO(1)-space-explained\\n\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums):\\n        n = len(nums)\\n        for i in range(n):\\n            while nums[i]-1 in range(n) and nums[i] != nums[nums[i]-1]:\\n                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\\n                \\n        return next((i + 1 for i, num in enumerate(nums) if num != i + 1), n + 1)   \\n```\\n\\nThanks to **QwerMike** for pointing out that my last line were using `O(n)` memory and he kindly suggested to use iterators instead, code is corrected now.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums):\\n        n = len(nums)\\n        for i in range(n):\\n            while nums[i]-1 in range(n) and nums[i] != nums[nums[i]-1]:\\n                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\\n                \\n        return next((i + 1 for i, num in enumerate(nums) if num != i + 1), n + 1)   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340607,
                "title": "look-at-this-solution-you-will-not-say-this-was-hard-one-uses-extra-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/6575114b-a664-4c5b-8acb-b74de3f0ff4e_1679763882.7132435.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        int ans[] = new int[nums.length + 1];\\n\\n        // mark the presence of each positive integer in the input array\\n        for(int i = 0; i < nums.length; i++){\\n            int val = nums[i];\\n            if(val > 0 && val <= nums.length) { // check to avoid index out of bounds\\n                ans[val] = 1;\\n            }\\n        }\\n\\n        // find the smallest missing positive integer by checking the array of marked integers\\n        for(int i = 1; i < ans.length; i++){\\n            if(ans[i] == 0){\\n                return i;\\n            }\\n        }\\n\\n        // if no missing positive integer is found, return the length of the array\\n    return ans.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        int ans[] = new int[nums.length + 1];\\n\\n        // mark the presence of each positive integer in the input array\\n        for(int i = 0; i < nums.length; i++){\\n            int val = nums[i];\\n            if(val > 0 && val <= nums.length) { // check to avoid index out of bounds\\n                ans[val] = 1;\\n            }\\n        }\\n\\n        // find the smallest missing positive integer by checking the array of marked integers\\n        for(int i = 1; i < ans.length; i++){\\n            if(ans[i] == 0){\\n                return i;\\n            }\\n        }\\n\\n        // if no missing positive integer is found, return the length of the array\\n    return ans.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927112,
                "title": "three-js-solutions",
                "content": "```\\nvar firstMissingPositive = function(nums) {\\n    nums = Array.from(new Set(nums));\\n    nums.sort((a,b) => a-b).filter(num => num > 0);\\n    let j = 1;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (j == nums[i]) j++;\\n        else return j;\\n    }\\n    return j;\\n    // Time Complexity: O(nlog(n))\\n    // Space Complexity: O(n)\\n};\\n```\\n\\n```\\nvar firstMissingPositive = function(nums) {    \\n    let m = new Map();\\n    for (let i = 0; i < nums.length; i++) {\\n        m.set(nums[i], 1);\\n    }\\n    for (let i = 1; i <= nums.length; i++) {\\n        if (!m.has(i)) return i;\\n    }\\n    return nums.length + 1; // the array is [1,2,...,n]\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n    /*\\n    The worst case (the first missing positive being the greatest) is\\n    when the array is [1,2..,n]. Therefore, in all other cases except this case, \\n    the first missing positive number is less than or equal to n (nums.length).\\n    */\\n}\\n```\\n\\n```\\nvar firstMissingPositive = function(nums) {\\n    // First, we need to understand that the first missing positive number is less than or equal to n (length of array) except for one case. The explanation is in the above.\\n    // We will position every positive integer in the array at its corresponding index\\n    // ex) 1 at index 0, 2 at index 1, 3 at index 2\\n    // In this way, the array can position all integers that are less than or equal to n at their corresponding indices without changing the size of given array.\\n    // Therefore, we can find the first missing positive integer by scanning through the array.\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        let idx = nums[i]-1;\\n        if (i == idx || nums[i] == nums[idx]) continue; // already positioned or nums[i] is a duplicate\\n        if (idx >= 0 && idx <= nums.length - 1) {\\n            [nums[i], nums[idx]] = [nums[idx], nums[i]];\\n            i--; // check the swapped number\\n        }\\n    }\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (i+1 == nums[i]) continue;\\n        else return i+1; // the next positive number which is i+1 doesn\\'t exist in the array\\n    }\\n    \\n    return nums.length + 1; // the array is [1,2,...,n]\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar firstMissingPositive = function(nums) {\\n    nums = Array.from(new Set(nums));\\n    nums.sort((a,b) => a-b).filter(num => num > 0);\\n    let j = 1;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (j == nums[i]) j++;\\n        else return j;\\n    }\\n    return j;\\n    // Time Complexity: O(nlog(n))\\n    // Space Complexity: O(n)\\n};\\n```\n```\\nvar firstMissingPositive = function(nums) {    \\n    let m = new Map();\\n    for (let i = 0; i < nums.length; i++) {\\n        m.set(nums[i], 1);\\n    }\\n    for (let i = 1; i <= nums.length; i++) {\\n        if (!m.has(i)) return i;\\n    }\\n    return nums.length + 1; // the array is [1,2,...,n]\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n    /*\\n    The worst case (the first missing positive being the greatest) is\\n    when the array is [1,2..,n]. Therefore, in all other cases except this case, \\n    the first missing positive number is less than or equal to n (nums.length).\\n    */\\n}\\n```\n```\\nvar firstMissingPositive = function(nums) {\\n    // First, we need to understand that the first missing positive number is less than or equal to n (length of array) except for one case. The explanation is in the above.\\n    // We will position every positive integer in the array at its corresponding index\\n    // ex) 1 at index 0, 2 at index 1, 3 at index 2\\n    // In this way, the array can position all integers that are less than or equal to n at their corresponding indices without changing the size of given array.\\n    // Therefore, we can find the first missing positive integer by scanning through the array.\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        let idx = nums[i]-1;\\n        if (i == idx || nums[i] == nums[idx]) continue; // already positioned or nums[i] is a duplicate\\n        if (idx >= 0 && idx <= nums.length - 1) {\\n            [nums[i], nums[idx]] = [nums[idx], nums[i]];\\n            i--; // check the swapped number\\n        }\\n    }\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (i+1 == nums[i]) continue;\\n        else return i+1; // the next positive number which is i+1 doesn\\'t exist in the array\\n    }\\n    \\n    return nums.length + 1; // the array is [1,2,...,n]\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1351917,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func firstMissingPositive(_ n: [Int]) -> Int {\\n        let set = Set(n)\\n        for i in 0..<n.count where !set.contains(i + 1) { return i + 1 }\\n        return n.count + 1\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.firstMissingPositive([1,2,0])\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test1() {\\n        let value = solution.firstMissingPositive([3,4,-1,1])\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test2() {\\n        let value = solution.firstMissingPositive([7,8,9,11,12])\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func firstMissingPositive(_ n: [Int]) -> Int {\\n        let set = Set(n)\\n        for i in 0..<n.count where !set.contains(i + 1) { return i + 1 }\\n        return n.count + 1\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.firstMissingPositive([1,2,0])\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test1() {\\n        let value = solution.firstMissingPositive([3,4,-1,1])\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test2() {\\n        let value = solution.firstMissingPositive([7,8,9,11,12])\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872224,
                "title": "java-python-supper-clean-concise-time-o-n-space-o-1",
                "content": "**Idea:**\\n1. Marks `zero or negative numbers` as `positive numbers`.\\n2. Mark number `x` as visited by marking `nums[x]` as negative, by using `(x-1)` we can use index 0 of `nums` array.\\n3. Interate from `0..n-1`, if `nums[i] > 0` then it means the number `i+1` is the smallest positive number which is missing.\\n\\n**Java**\\n```java\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n = nums.length, INF = n + 1;\\n        \\n        for (int i = 0; i < n; i++)\\n            if (nums[i] <= 0)\\n                nums[i] = INF; // marks zero or negative numbers as infinitive positive numbers\\n                \\n        for (int i = 0; i < n; i++) {\\n            int x = Math.abs(nums[i]) - 1; // use index start with zero\\n            if (x < n)\\n                nums[x] = -Math.abs(nums[x]); // mark `x` as visited by marking `nums[x]` as negative\\n        }\\n               \\n        for (int i = 0; i < n; i++)\\n            if (nums[i] > 0) // if nums[i] is positive -> number (i+1) is not visited.\\n                return i + 1;\\n        return n + 1;\\n    }\\n}\\n```\\n\\n**Python**\\n```python\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        n = len(nums)\\n        INF = n + 1\\n    \\n        for i in range(n):\\n            if nums[i] <= 0:\\n                nums[i] = INF # marks zero or negative numbers as infinitive positive numbers\\n                \\n        for i in range(n):\\n            x = abs(nums[i]) - 1 # use index start with zero\\n            if x < n:\\n                nums[x] = -abs(nums[x]) # mark `x` as visited by marking `nums[x]` as negative\\n                    \\n        for i in range(n):\\n            if nums[i] > 0: # if nums[i] is positive -> number (i+1) is not visited.\\n                return i + 1\\n        return n + 1\\n```\\n\\nPlease give a vote if this post is useful to you.\\nHappy Coding!",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n = nums.length, INF = n + 1;\\n        \\n        for (int i = 0; i < n; i++)\\n            if (nums[i] <= 0)\\n                nums[i] = INF; // marks zero or negative numbers as infinitive positive numbers\\n                \\n        for (int i = 0; i < n; i++) {\\n            int x = Math.abs(nums[i]) - 1; // use index start with zero\\n            if (x < n)\\n                nums[x] = -Math.abs(nums[x]); // mark `x` as visited by marking `nums[x]` as negative\\n        }\\n               \\n        for (int i = 0; i < n; i++)\\n            if (nums[i] > 0) // if nums[i] is positive -> number (i+1) is not visited.\\n                return i + 1;\\n        return n + 1;\\n    }\\n}\\n```\n```python\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        n = len(nums)\\n        INF = n + 1\\n    \\n        for i in range(n):\\n            if nums[i] <= 0:\\n                nums[i] = INF # marks zero or negative numbers as infinitive positive numbers\\n                \\n        for i in range(n):\\n            x = abs(nums[i]) - 1 # use index start with zero\\n            if x < n:\\n                nums[x] = -abs(nums[x]) # mark `x` as visited by marking `nums[x]` as negative\\n                    \\n        for i in range(n):\\n            if nums[i] > 0: # if nums[i] is positive -> number (i+1) is not visited.\\n                return i + 1\\n        return n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871646,
                "title": "first-missing-positive-c-two-solutions-o-n-time-100",
                "content": "<b>The problem</b>\\nHonestly, it was surpising to me to find out that this problem is marked as hard.\\nWhen I saw the problem, I thought it was probably easy or medium difficulty.\\nI had done some similar problems previously, that required me to use the original array and negate numbers at indices according to some other values.\\nI guess it can appear hard to solve it in linear time, if you miss the clue.\\n\\n<b>Approach</b>\\nThe main thing here is to really understand the question. They are looking for the first positive integer, of <b>ALL</b> positive integers, that does not exist in the given array.\\nThis implies that the first missing number can be in range from ```1``` to ```N``` (size of the input).\\nNow we only have to figure out which one is the first in the sequence that is not present in the array.\\n\\n<b>Solution 1</b>\\nCreate a new array of input size, with all values set to ```-1```.\\nFor each value in the original array, set ```newArray[value - 1]``` to ```1```, if the value is within the ```1``` - ```N``` range.\\nNow we go through the new array and look for the first ```-1``` value. The missing number is ```index + 1```, since we are looking only for positive numbers and we start count from 1, while index is zero based.\\n```\\nclass Solution { // Time and Space: O(N)\\npublic:\\n\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\tint size = nums.size();\\n\\t\\tvector<int> sequence(size, -1); // Init array with same size to all -1s\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tif (nums[i] > 0 && nums[i] <= size)\\n\\t\\t\\t\\tsequence[nums[i] - 1] = 1; // Set numbers at indices to positive\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < size; i++) { // First that has value -1 is the missing one\\n\\t\\t\\tif (sequence[i] == -1)\\n\\t\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\n\\t\\treturn size + 1;\\n\\t}\\n};\\n```\\n\\n<b>Solution 2</b>\\nVery similar to first solution, but we use the original array instead of creating a new one. So the space complexity is constant.\\nSince we don\\'t need to look at the negative values in the array, we set them to ```0```. Then we use the original array to negate all the numbers at indices for which the value exists in the array.\\nIt is a little tricky, and my solution might require some polishing, but overall, it isn\\'t difficult.\\n```\\nclass Solution { // Time: O(N), Space: O(1)\\npublic:\\n\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\tint size = nums.size();\\n\\t\\tbool hasOne = false;\\n\\n\\t\\tfor (int& n : nums) { // Set all negatives to 0\\n\\t\\t\\tif (n < 0)\\n\\t\\t\\t\\tn = 0;\\n\\t\\t\\telse if (n == 1)\\n\\t\\t\\t\\thasOne = true;\\n\\t\\t}\\n\\n\\t\\tif (!hasOne) // One is the first missing\\n\\t\\t\\treturn 1;\\n\\n\\t\\tfor (int i = 0; i < size; i++) { // Negate all numbers at indices by found values\\n            int currNum = abs(nums[i]);\\n\\t\\t\\tif (currNum > 0 && currNum <= size)\\n\\t\\t\\t\\tif (nums[currNum - 1] == 0)\\n\\t\\t\\t\\t\\tnums[currNum - 1] = -1;\\n\\t\\t\\t\\telse if (nums[currNum - 1] > 0)\\n\\t\\t\\t\\t\\tnums[currNum - 1] *= -1; // Negate it\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < size; i++) // Find first non negative number\\n\\t\\t\\tif (nums[i] > -1)\\n\\t\\t\\t\\treturn i + 1;\\n\\n\\t\\treturn size + 1;\\n\\t}\\n};\\n```\\n\\nAny suggestions or advice on how to improve the solutions are always welcome. Thank you!\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```1```\n```N```\n```-1```\n```newArray[value - 1]```\n```1```\n```1```\n```N```\n```-1```\n```index + 1```\n```\\nclass Solution { // Time and Space: O(N)\\npublic:\\n\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\tint size = nums.size();\\n\\t\\tvector<int> sequence(size, -1); // Init array with same size to all -1s\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tif (nums[i] > 0 && nums[i] <= size)\\n\\t\\t\\t\\tsequence[nums[i] - 1] = 1; // Set numbers at indices to positive\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < size; i++) { // First that has value -1 is the missing one\\n\\t\\t\\tif (sequence[i] == -1)\\n\\t\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\n\\t\\treturn size + 1;\\n\\t}\\n};\\n```\n```0```\n```\\nclass Solution { // Time: O(N), Space: O(1)\\npublic:\\n\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\tint size = nums.size();\\n\\t\\tbool hasOne = false;\\n\\n\\t\\tfor (int& n : nums) { // Set all negatives to 0\\n\\t\\t\\tif (n < 0)\\n\\t\\t\\t\\tn = 0;\\n\\t\\t\\telse if (n == 1)\\n\\t\\t\\t\\thasOne = true;\\n\\t\\t}\\n\\n\\t\\tif (!hasOne) // One is the first missing\\n\\t\\t\\treturn 1;\\n\\n\\t\\tfor (int i = 0; i < size; i++) { // Negate all numbers at indices by found values\\n            int currNum = abs(nums[i]);\\n\\t\\t\\tif (currNum > 0 && currNum <= size)\\n\\t\\t\\t\\tif (nums[currNum - 1] == 0)\\n\\t\\t\\t\\t\\tnums[currNum - 1] = -1;\\n\\t\\t\\t\\telse if (nums[currNum - 1] > 0)\\n\\t\\t\\t\\t\\tnums[currNum - 1] *= -1; // Negate it\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < size; i++) // Find first non negative number\\n\\t\\t\\tif (nums[i] > -1)\\n\\t\\t\\t\\treturn i + 1;\\n\\n\\t\\treturn size + 1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17298,
                "title": "sharing-my-2ms-c-solution",
                "content": "In the worst case, this will take 2N iterations.  Satisfies O(N) runtime and O(1) space requirements. \\n\\nI got the idea from doing this in JavaScript, first, by popping off any out-of-bounds or duplicate values after moving them to the end of the array.  In the end I got rid of the pop operation and used a partition index, instead.  The neat thing is that it doesn't require a second loop to find the answer. \\n\\n\\n    void swap(int* nums, int j, int k) {\\n        int tmp = nums[k];\\n        nums[k] = nums[j];\\n        nums[j] = tmp;\\n    }\\n    \\n    int firstMissingPositive(int* nums, int numsSize) {\\n        int i = 0;\\n        int p = numsSize;\\n\\n        while (i < p) {\\n            if (nums[i] == i+1)  ++i; // already in the right place,\\n            else if (nums[i] <= 0 || nums[i] > p || nums[i] == nums[nums[i]-1]) {\\n                swap(nums, i, --p); // out of range or duplicate, put it at the end\\n            } else {\\n                swap(nums, i, nums[i]-1); // within range; put it in the right place.\\n            }\\n        }\\n\\n        return p + 1;\\n    }",
                "solutionTags": [],
                "code": "In the worst case, this will take 2N iterations.  Satisfies O(N) runtime and O(1) space requirements. \\n\\nI got the idea from doing this in JavaScript, first, by popping off any out-of-bounds or duplicate values after moving them to the end of the array.  In the end I got rid of the pop operation and used a partition index, instead.  The neat thing is that it doesn't require a second loop to find the answer. \\n\\n\\n    void swap(int* nums, int j, int k) {\\n        int tmp = nums[k];\\n        nums[k] = nums[j];\\n        nums[j] = tmp;\\n    }\\n    \\n    int firstMissingPositive(int* nums, int numsSize) {\\n        int i = 0;\\n        int p = numsSize;\\n\\n        while (i < p) {\\n            if (nums[i] == i+1)  ++i; // already in the right place,\\n            else if (nums[i] <= 0 || nums[i] > p || nums[i] == nums[nums[i]-1]) {\\n                swap(nums, i, --p); // out of range or duplicate, put it at the end\\n            } else {\\n                swap(nums, i, nums[i]-1); // within range; put it in the right place.\\n            }\\n        }\\n\\n        return p + 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1206111,
                "title": "python-o-n-time-and-constant-space-solution",
                "content": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\t\\t\\n        for i in range(n):\\n            if nums[i] <= 0 or nums[i] > n:\\n                nums[i] = n + 1\\n        for i in range(n):\\n            if abs(nums[i]) > n:\\n                continue\\n            nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1])\\n        for i in range(n):\\n            if nums[i] > 0:\\n                return i + 1\\n        return n + 1\\n```\\n**PS: Please upvote if you liked the solution.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\t\\t\\n        for i in range(n):\\n            if nums[i] <= 0 or nums[i] > n:\\n                nums[i] = n + 1\\n        for i in range(n):\\n            if abs(nums[i]) > n:\\n                continue\\n            nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1])\\n        for i in range(n):\\n            if nums[i] > 0:\\n                return i + 1\\n        return n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17133,
                "title": "simple-javascript-o-n-time-and-o-1-space",
                "content": "```\\nvar firstMissingPositive = function(nums) {\\n    let i = 0;\\n    while (i < nums.length) {\\n        if (nums[i] > 0 && nums[i] <= nums.length && nums[nums[i] - 1] !== nums[i]) {\\n            [nums[nums[i] - 1], nums[i]] = [nums[i], nums[nums[i] - 1]];\\n        } else {\\n            i++;\\n        }\\n    }\\n    for (i = 0; i < nums.length; i++) {\\n        if (nums[i] !== i + 1) return i + 1;\\n    }\\n    return i + 1;\\n};\\n```\\n1. Go through and place each number at the index of its value (minus one since `0` isn't positive). All the negative and out-of-bounds elements should now be in the missing gap or on the right side of the array.\\n2. Walk through and take the first index (plus one) which does not match its associated value.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar firstMissingPositive = function(nums) {\\n    let i = 0;\\n    while (i < nums.length) {\\n        if (nums[i] > 0 && nums[i] <= nums.length && nums[nums[i] - 1] !== nums[i]) {\\n            [nums[nums[i] - 1], nums[i]] = [nums[i], nums[nums[i] - 1]];\\n        } else {\\n            i++;\\n        }\\n    }\\n    for (i = 0; i < nums.length; i++) {\\n        if (nums[i] !== i + 1) return i + 1;\\n    }\\n    return i + 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17157,
                "title": "golang-concise-solution-with-some-explanation",
                "content": "Let's say the array is `[3, 4, -1, 1, 3]`.\\nIf the array doesn't have missing positive integer within its range, the array should be `[1, 2, 3, 4, 5]`.\\n\\nSo, the idea is, we iterate through the array and if we find an integer within `1` to `5`, then put it to the ideal position.  \\nFor example, if we find `1`, then swap it with a value on index `0`. If we find `3`, then swap it with a value on index `2`.\\n\\nAfter we swap the value, we need to examine the swapped new value again, so we should not move to the next position. But we need to be careful about the case when the value is set at the ideal index by default, or we put it already. In this case we need to skip that index, otherwise we'll see the infinite loop :-\\\\\\n\\nwalkthrough:\\n```\\n[3, 4, -1, 1, 3]\\n \\u2191 3, swap with array[2]\\n[-1, 4, 3, 1, 3]\\n \\u2191 -1, this is out of range, so proceed to the next index\\n[-1, 4, 3, 1, 3]\\n     \\u2191 4, swap with array[3]\\n[-1, 1, 3, 4, 3]\\n     \\u2191 1, swap with array[0]\\n[1, -1, 3, 4, 3]\\n     \\u2191 -1, out of range, so proceed to the next index\\n[1, -1, 3, 4, 3]\\n        \\u2191 3, but already on array[2], so proceed to the next index\\n[1, -1, 3, 4, 3]\\n           \\u2191 4, but already on array[3], so proceed to the next index\\n[1, -1, 3, 4, 3]\\n              \\u2191 3, but array[2] already occupied with 3, so proceed to the next index\\nend\\n```\\n\\nAfter this iteration, you will notice that the value who is in  range `1 \\u301c n` will sit on the right index. So what you need to do is iterate this modified array again and find the first integer that doesn't have a value of `i+1`. This case, that is `2` because there is `-1` at index `1`. If there is no such integer, then the first missing integer should be `n+1`.\\n\\n```\\nfunc firstMissingPositive(nums []int) int {\\n\\tnlen := len(nums)\\n\\tfor i := 0; i < nlen; i++ {\\n\\t\\tif nums[i] >= 1 && nums[i] <= nlen && nums[i] != nums[nums[i]-1] {\\n\\t\\t\\tnums[i], nums[nums[i]-1] = nums[nums[i]-1], nums[i]\\n\\t\\t\\ti-- // keep the same index\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < nlen; i++ {\\n\\t\\tif nums[i] != i+1 {\\n\\t\\t\\treturn i + 1\\n\\t\\t}\\n\\t}\\n\\treturn nlen + 1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n[3, 4, -1, 1, 3]\\n \\u2191 3, swap with array[2]\\n[-1, 4, 3, 1, 3]\\n \\u2191 -1, this is out of range, so proceed to the next index\\n[-1, 4, 3, 1, 3]\\n     \\u2191 4, swap with array[3]\\n[-1, 1, 3, 4, 3]\\n     \\u2191 1, swap with array[0]\\n[1, -1, 3, 4, 3]\\n     \\u2191 -1, out of range, so proceed to the next index\\n[1, -1, 3, 4, 3]\\n        \\u2191 3, but already on array[2], so proceed to the next index\\n[1, -1, 3, 4, 3]\\n           \\u2191 4, but already on array[3], so proceed to the next index\\n[1, -1, 3, 4, 3]\\n              \\u2191 3, but array[2] already occupied with 3, so proceed to the next index\\nend\\n```\n```\\nfunc firstMissingPositive(nums []int) int {\\n\\tnlen := len(nums)\\n\\tfor i := 0; i < nlen; i++ {\\n\\t\\tif nums[i] >= 1 && nums[i] <= nlen && nums[i] != nums[nums[i]-1] {\\n\\t\\t\\tnums[i], nums[nums[i]-1] = nums[nums[i]-1], nums[i]\\n\\t\\t\\ti-- // keep the same index\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < nlen; i++ {\\n\\t\\tif nums[i] != i+1 {\\n\\t\\t\\treturn i + 1\\n\\t\\t}\\n\\t}\\n\\treturn nlen + 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17260,
                "title": "clear-java-solution",
                "content": "    public int firstMissingPositive(int[] nums) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while (start <= end) {\\n            int index = nums[start] - 1;\\n            if (index == start)\\n                start++;\\n            else if (index < 0 || index > end || nums[start] == nums[index])\\n                nums[start] = nums[end--];\\n            else {\\n                nums[start] = nums[index];\\n                nums[index] = index + 1;\\n            }\\n        }\\n        return start + 1;\\n    }",
                "solutionTags": [],
                "code": "    public int firstMissingPositive(int[] nums) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while (start <= end) {\\n            int index = nums[start] - 1;\\n            if (index == start)\\n                start++;\\n            else if (index < 0 || index > end || nums[start] == nums[index])\\n                nums[start] = nums[end--];\\n            else {\\n                nums[start] = nums[index];\\n                nums[index] = index + 1;\\n            }\\n        }\\n        return start + 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2083286,
                "title": "python-o-n-time-o-1-space-step-by-step-explanation",
                "content": "Plzz **UPVOTE** if you like it.\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        \\'\\'\\'Step 1 -> The main idea behind it is that the minimum number to be found will always be in the range [1....n]\\n\\t\\t             where \\'n\\' is the length of list. So keep numbers in this range and mark others\\n\\t\\t\\t\\t\\t (here we are marking them with (n+1) value) in the list provided.\\'\\'\\'\\n        \\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] < 1 or nums[i] > n:\\n                nums[i] = n + 1\\n        \\n        \\'\\'\\'Step 2 -> Ignoring the values greater than \\'n\\', mark the indexes of the numbers in the range [1...n]\\n\\t\\t\\t\\t\\t so as to ensure that this values are present. To mark the indexes, \\n\\t\\t\\t\\t\\t I am negating the value present at that index.\\'\\'\\'\\n        \\n        for i in range(n):\\n            val = abs(nums[i])\\n            if val > n:\\n                continue\\n            val -= 1  #since the list is zero indexed,so every value will be at position val - 1\\n            \\n            if nums[val] > 0: \\n                # For similar numbers, it will keep on fluctuating between negative and positive \\n\\t\\t\\t\\t# which is not our motive here.\\n                \\n                nums[val] = -1 * nums[val]\\n        \\n        \\'\\'\\'Step 3 -> Return the first occurence of the non-negative numbers from the list\\'\\'\\'\\n        \\n        for i in range(n):\\n            if nums[i] >=0:\\n                return (i + 1) # bcoz list is zero indexed\\n        \\n        \\'\\'\\'Step 4 -> We will encounter this if no positives were found. This means that all the \\n\\t\\t\\t         numbers are in the range [1....n]. So the missing positive number will be n+1\\'\\'\\'\\n        \\n        return (n + 1)\\n```\\n\\nFor detailed explaination,  do visit \\uD83D\\uDC47\\uD83D\\uDC47\\nhttps://leetcode.com/problems/first-missing-positive/discuss/319270/Explanation-of-crucial-observation-needed-to-deduce-algorithm",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        \\'\\'\\'Step 1 -> The main idea behind it is that the minimum number to be found will always be in the range [1....n]\\n\\t\\t             where \\'n\\' is the length of list. So keep numbers in this range and mark others\\n\\t\\t\\t\\t\\t (here we are marking them with (n+1) value) in the list provided.\\'\\'\\'\\n        \\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] < 1 or nums[i] > n:\\n                nums[i] = n + 1\\n        \\n        \\'\\'\\'Step 2 -> Ignoring the values greater than \\'n\\', mark the indexes of the numbers in the range [1...n]\\n\\t\\t\\t\\t\\t so as to ensure that this values are present. To mark the indexes, \\n\\t\\t\\t\\t\\t I am negating the value present at that index.\\'\\'\\'\\n        \\n        for i in range(n):\\n            val = abs(nums[i])\\n            if val > n:\\n                continue\\n            val -= 1  #since the list is zero indexed,so every value will be at position val - 1\\n            \\n            if nums[val] > 0: \\n                # For similar numbers, it will keep on fluctuating between negative and positive \\n\\t\\t\\t\\t# which is not our motive here.\\n                \\n                nums[val] = -1 * nums[val]\\n        \\n        \\'\\'\\'Step 3 -> Return the first occurence of the non-negative numbers from the list\\'\\'\\'\\n        \\n        for i in range(n):\\n            if nums[i] >=0:\\n                return (i + 1) # bcoz list is zero indexed\\n        \\n        \\'\\'\\'Step 4 -> We will encounter this if no positives were found. This means that all the \\n\\t\\t\\t         numbers are in the range [1....n]. So the missing positive number will be n+1\\'\\'\\'\\n        \\n        return (n + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778385,
                "title": "o-n-time-o-1-space-using-number-as-index-of-hash",
                "content": "Let us understand the whole problem in three steps of progression, with an example nums array, say : 3, -1, 4, 2, 1, 7\\n\\nOne observation that we can make is: *we can always ignore the negative values and 0\\'s present in the array* as they contribute to nothing. We have to find the first missing positive number.\\n\\n**Naive approach:  (extra space)**\\n\\n1. In one pass, we find the largest positive number present in array. (If no positive no., return 1).\\n2. We create an array till the size of the largest positive number present + 1 (+ 1 if following 1 based indexing). We put 0 in every index initially.\\n3. In second pass, we take each positive no. from the array and mark that corresponding index in our array with 1. (we ignore negative numbers and 0)\\n4. We iterate our array and the first index which has not been visited / marked true, is our first missing positive number.\\n\\nDry run:\\nnums array -----> 3               -1               4                  2                1                7\\n\\nfor 3, we mark index 3 of array as true/1. We ignore -1. And continue like this:\\n```\\nnums array -------------> 3 -1  4  2  1  7\\ncount array indices ----> 0  1  2  3  4  5  6  7\\n\\t\\t\\t\\t\\t      0  1  1  1  1  0  0  1\\n```\\n\\nNow when we iterate on this array from index 1 to 7 (following 1 based indexing), we see 5 is the first empty index. So we return 5.\\n\\n**Reducing auxiliary array size:**\\n\\nOne problem with this approach is if there are huge gaps between numbers, say 1, 2, 3, 22471. We will unnecessarily create a huge array. We can avoid that by making the following observation:\\n`first missing positive number has to lie within {1,n+1} , where n-> nums.size()`\\nSo we can create array only of size n + 1.\\n\\nDry run:\\nnums array -----> 3               -1               4                  2                1                7\\n\\nfor 3, we mark index 3 of array as true/1. We ignore -1. We mark indices 4,2,1 for numbers 4, 2, 1 in array respectively, and ignore 7 ( as 7 > nums.size() )\\n\\n```\\nnums array -------------> 3 -1  4  2  1  7\\ncount array indices ----> 0  1  2  3  4  5\\n\\t\\t\\t\\t\\t      0  1  1  1  1  0\\n```\\nWe return 1st index empty index or n + 1 if no empty index.\\n\\n\\n\\nCode for above idea (extra O(n) space ) :\\n\\n```\\nint firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> count(n + 1,0);\\n        for(int _n : nums)\\n\\t\\t\\tif(_n <= 0 || _n > n)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\telse\\n\\t\\t\\t\\tcount[_n] += 1;\\n        \\n\\t\\tfor(int i = 1; i < n + 1; ++i)\\n\\t\\t\\tif(count[i] == 0)\\n\\t\\t\\t\\treturn i;\\n\\t\\treturn n + 1;\\n}\\n```\\n\\n**Final approach by modifying above idea for constant space:**\\n\\nTo drop the extra array we are using to maintain index count, we can modify the given array itself to do the hashing.\\nIf we put each nums[i] that lie in range {1, n-1} in that index itself, i.e if nums[i] =3, we put nums[i] in index 3 (or 2 if 0 based indexing), then the first index not containing the number as the index itself will be the first missing positive number. If all indices have nums[i] == i, then we return n + 1.\\n\\nDry run: (using 0 based indexing)\\nnums array -----> 3               -1               4                  2                1                7\\n\\nfor 3, we put 3 in index 2. We ignore -1. We put 4 in index 3. We put 2 in index 1. We put 1 in index 0. We ignore 7.\\n```\\nInitially:\\n\\nindices    -------------> 0  1  2  3  4  5\\nnums array -------------> 3 -1  4  2  1  7\\n\\nAfter modification:\\n\\nindices    -------------> 0  1  2  3  4  5\\nnums array -------------> 1  2  3  4 -1  7\\n```\\n\\nBelow is the code implementing this idea with a zero-based indexing approach:\\n\\n```\\n\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n; ++i)\\n        {\\n            if(nums[i] <= 0 || nums[i] > n) //ignore numbers not in range of {1, n-1}\\n                continue;\\n            else\\n            {\\n                if(nums[nums[i]-1]==nums[i])  //already in correct place, then skip (else infinite loop of swapping)\\n                    continue;\\n                swap(nums[i], nums[nums[i] - 1]);\\n                --i;                          //can\\'t go forward without putting swapped number in correct place.\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; ++i)\\n            if(i + 1 != nums[i])\\n                return i + 1;\\n        return n + 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nnums array -------------> 3 -1  4  2  1  7\\ncount array indices ----> 0  1  2  3  4  5  6  7\\n\\t\\t\\t\\t\\t      0  1  1  1  1  0  0  1\\n```\n```\\nnums array -------------> 3 -1  4  2  1  7\\ncount array indices ----> 0  1  2  3  4  5\\n\\t\\t\\t\\t\\t      0  1  1  1  1  0\\n```\n```\\nint firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> count(n + 1,0);\\n        for(int _n : nums)\\n\\t\\t\\tif(_n <= 0 || _n > n)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\telse\\n\\t\\t\\t\\tcount[_n] += 1;\\n        \\n\\t\\tfor(int i = 1; i < n + 1; ++i)\\n\\t\\t\\tif(count[i] == 0)\\n\\t\\t\\t\\treturn i;\\n\\t\\treturn n + 1;\\n}\\n```\n```\\nInitially:\\n\\nindices    -------------> 0  1  2  3  4  5\\nnums array -------------> 3 -1  4  2  1  7\\n\\nAfter modification:\\n\\nindices    -------------> 0  1  2  3  4  5\\nnums array -------------> 1  2  3  4 -1  7\\n```\n```\\n\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n; ++i)\\n        {\\n            if(nums[i] <= 0 || nums[i] > n) //ignore numbers not in range of {1, n-1}\\n                continue;\\n            else\\n            {\\n                if(nums[nums[i]-1]==nums[i])  //already in correct place, then skip (else infinite loop of swapping)\\n                    continue;\\n                swap(nums[i], nums[nums[i] - 1]);\\n                --i;                          //can\\'t go forward without putting swapped number in correct place.\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; ++i)\\n            if(i + 1 != nums[i])\\n                return i + 1;\\n        return n + 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1119550,
                "title": "two-ways-of-solving-this-floyd-cycle-o-n-time-o-1-space-in-2nd-approach",
                "content": "\\n**Key Insight: If n = nums.length, that is size of nums is n, then the max possible answer can be n + 1 only. Think about it if you are not sure. Think of an input where the answer can be more than n + 1. You won\\'t be able to find it.**\\n\\nFirst way is to create an extra boolean array called `exists`. After filling this array, `exists[i]` should be able to indicate if a number `i+1` is the required answer or not. That is `if exists[i] is false` then this means that `i+1` is the answer.\\n\\n# <ins>First Approach - Extra Space:\\n\\n```java\\n    // TC: O(n), SC: O(n)\\n    public int firstMissingPositive_ExtraArray(int[] nums) {\\n        int n = nums.length;\\n        boolean[] exists = new boolean[n];\\n        for (int num : nums) {\\n            if (num > 0 && num <= n) exists[num - 1] = true;\\n        }\\n        for (int i = 0; i < exists.length; i++) {\\n            if (!exists[i]) return i + 1;\\n        }\\n        return n + 1;\\n    }\\n```\\n\\n<br>\\n<hr>\\n<br>\\n\\n# <ins>Second Approach - No Space:\\nSame as first approach, but instead of having an extra boolean array, think of using the giving input array itself. \\n\\n**Key Insight in second approach: Remember that we don\\'t care about negative values in the array. Let\\'s throw them into dustbin \\uD83D\\uDE02**\\n\\nSo we override the negatives, and then we manually flip the sign of the numbers to indicate if a value exists or not. Read the comments in the solution below.\\n\\n```java\\n    public int firstMissingPositive_NoSpace(int[] nums) {\\n        int n = nums.length;\\n        // pre-process array so that non-positive ints are overwritten with n + 1;\\n        // why n + 1? coz this is the safest value to choose during\\n        // floyd cycle way which we are about to do in second for loop below\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] <= 0) nums[i] = n + 1;\\n        }\\n\\n        // Take abs of A[i] and then make sure its within bounds and use that as index.\\n        // This is also called as Floyd Cycle algorithm or something. Another fancy name I think is tortoise-hare.\\n        for (int i = 0; i < n; i++) {\\n            int num = Math.abs(nums[i]);\\n            if (num > 0 && num <= n) {\\n                // Now indicate that the +ve value num was found.\\n                // We indicate this by setting nums[num - 1] as a negative value;\\n                // Why does this work? We are using the negative sign in the array to indicate that\\n                // a positive value has been found. On the other hand, value itself is encoded in Math.abs(nums[i])\\n                nums[num - 1] = -Math.abs(nums[num - 1]);\\n            }\\n        }\\n\\n        // Now check for the first value where nums[i] is not negative and we have found our answer\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] > 0) return i + 1;\\n        }\\n        return n + 1;\\n    }\\n```\\n\\n**Essentially in the first approach, we used an extra boolean array, while in the second approach we used existing array itself to do this. We simulated the \"boolean-ness\" using the negative sign. However since the initial input could have negatives already, we just overwrote the negatives to avoid problems for us down the line.**\\n\\nP.S. Correct me if I am wrong about the name of the algorithm(floyd cycle).\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n    // TC: O(n), SC: O(n)\\n    public int firstMissingPositive_ExtraArray(int[] nums) {\\n        int n = nums.length;\\n        boolean[] exists = new boolean[n];\\n        for (int num : nums) {\\n            if (num > 0 && num <= n) exists[num - 1] = true;\\n        }\\n        for (int i = 0; i < exists.length; i++) {\\n            if (!exists[i]) return i + 1;\\n        }\\n        return n + 1;\\n    }\\n```\n```java\\n    public int firstMissingPositive_NoSpace(int[] nums) {\\n        int n = nums.length;\\n        // pre-process array so that non-positive ints are overwritten with n + 1;\\n        // why n + 1? coz this is the safest value to choose during\\n        // floyd cycle way which we are about to do in second for loop below\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] <= 0) nums[i] = n + 1;\\n        }\\n\\n        // Take abs of A[i] and then make sure its within bounds and use that as index.\\n        // This is also called as Floyd Cycle algorithm or something. Another fancy name I think is tortoise-hare.\\n        for (int i = 0; i < n; i++) {\\n            int num = Math.abs(nums[i]);\\n            if (num > 0 && num <= n) {\\n                // Now indicate that the +ve value num was found.\\n                // We indicate this by setting nums[num - 1] as a negative value;\\n                // Why does this work? We are using the negative sign in the array to indicate that\\n                // a positive value has been found. On the other hand, value itself is encoded in Math.abs(nums[i])\\n                nums[num - 1] = -Math.abs(nums[num - 1]);\\n            }\\n        }\\n\\n        // Now check for the first value where nums[i] is not negative and we have found our answer\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] > 0) return i + 1;\\n        }\\n        return n + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17164,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution with discussion** https://discuss.leetcode.com/topic/76042/python-solution-with-detailed-explanation\\n\\n**First Missing Positive** https://leetcode.com/problems/first-missing-positive/\\n\\n**Solution using extra space: O(N) time and space**\\n* If the length of the nums array is N, then the first missing positive will be between 1 to N+1. Think Why N+1? We can have in the array 1 to N.\\n\\t* Take an temp array of size N and for any number x in nums such that 1<=x<=N, mark temp[x-1]. Then simply walk the temp array and report the first unmarked index.\\n\\n```\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        temp, N = [None]*len(nums), len(nums)\\n        for x in nums:\\n            if 1<=x<=N:\\n                temp[x-1] = x\\n        for i in range(N):\\n            if temp[i] == None:\\n                return i+1\\n        return N+1\\n```\\n\\n**Optimized solution with O(1) Space**\\n* Simply traverse the nums array and put any number within [1, N] in their right place. For example if 2 is in that input, then put 2 at index 1.\\n* Now traverse this \"shuffled\" array again. You expect 1 at 0th index. Otherwise it is missing. Then you expect 2 at 1st index and so on.\\n* Above idea can be a little tricky. What about cases like [1] and [1,1] - i.e. 1 is in its place or there are duplicates - we need to advance pointer regardless.\\n\\n```\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        N, i = len(nums), 0\\n        while i < N:\\n            while 1<=nums[i]<=N:\\n                idx_expected = nums[i]-1\\n                if nums[i] == nums[idx_expected]:\\n                    break\\n                nums[i], nums[idx_expected] = nums[idx_expected], nums[i]\\n            i = i + 1\\n        for i in range(N):\\n            if nums[i] != i+1:\\n                return i+1\\n        return N+1\\n```.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        temp, N = [None]*len(nums), len(nums)\\n        for x in nums:\\n            if 1<=x<=N:\\n                temp[x-1] = x\\n        for i in range(N):\\n            if temp[i] == None:\\n                return i+1\\n        return N+1\\n```\n```\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        N, i = len(nums), 0\\n        while i < N:\\n            while 1<=nums[i]<=N:\\n                idx_expected = nums[i]-1\\n                if nums[i] == nums[idx_expected]:\\n                    break\\n                nums[i], nums[idx_expected] = nums[idx_expected], nums[i]\\n            i = i + 1\\n        for i in range(N):\\n            if nums[i] != i+1:\\n                return i+1\\n        return N+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895048,
                "title": "simple-python-search-beats-98",
                "content": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        unique = set(nums)\\n        i = 1\\n        while i in unique:\\n            i += 1\\n        return i\\n```\\nIt is quite a simple solution. We first run it through set() to stop duplicate numbers (will cause a runtime error if not there when you submit it). You don\\'t need to sorted() it or anything else because the counter (which is \"i\") will scan through the list for it. \\n\\n\"i\" is the variable that i used as a counter to see if it is in the set(nums) or not. If it not in the set(nums), the `while` function will stop and and move on to the next code which is `return i`.\\n\\n`i += 1` is the same as `i = i + 1` which is what allow the \"while\" loop to continue. \\nYou substitute \"unique\" for \"j\" or something to decrease memory usage.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        unique = set(nums)\\n        i = 1\\n        while i in unique:\\n            i += 1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616956,
                "title": "c-solution-with-clear-explanation-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        //the missing number will always be less than or equal to the size of the vector\\n        //place all positive elements less than or equal to the size of the vector to their respective index in the vector, e.g., 1 at index 0\\n        \\n        int n = nums.size();\\n        for(int i = 0; i < n; i++)\\n            while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])\\n                swap(nums[i], nums[nums[i] - 1]); //place element x at index num[x - 1]\\n        \\n        //if the number at index i is not i + 1, the missing number is i + 1\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        \\n        //else, the missing number is one more than the size of the vector\\n        return n + 1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        //the missing number will always be less than or equal to the size of the vector\\n        //place all positive elements less than or equal to the size of the vector to their respective index in the vector, e.g., 1 at index 0\\n        \\n        int n = nums.size();\\n        for(int i = 0; i < n; i++)\\n            while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])\\n                swap(nums[i], nums[nums[i] - 1]); //place element x at index num[x - 1]\\n        \\n        //if the number at index i is not i + 1, the missing number is i + 1\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        \\n        //else, the missing number is one more than the size of the vector\\n        return n + 1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617430,
                "title": "python-swap-sort-o-1-space-and-o-n-time",
                "content": "Swap Sort Playlist by Aditya Verma - https://www.youtube.com/playlist?list=PL_z_8CaSLPWdJfdZHiNYYM46tYQUjbBJx\\n\\nThis problem is a variation of 1 to n missing number problems.\\n\\nHere, Range of numbers is from -2^31 to 2^31 - 1\\n\\nBut as the problem statement says, we need to return the first Missing \"Positive\" number which means we care about only the positive numbers.\\n\\nThe smallest missing positive number = the first missing number.\\n\\nSo, what we can do is we manually pick the range 1 to n where n is the length of given array and then place each element at its correct place.\\n\\n\\t\\tnums = [3,4,-1,1]\\n\\nSo here, n = 4 which means ideally, all numbers from 1 to 4 should be in this array. Lets apply swap sort on this array. We only care about numbers from range 1 to n because that\\'s how swap sort works.\\n\\nDo note that ideally, at index i, element should be i + 1. That\\'s what we are going to check.\\n\\n    at index = 0, we have 3. is 3 > 0 and <= n? YES. SO it can be considered. \\n\\n    It 3 at its correct place? NO. Its correct place is index 2. \\n\\n    So to place 3 at its correct place, swap element at index 2 with 3. \\n\\n    [-1,4,3,1]\\n\\n    Now at index = 0, we have a negative number so we ignore it and move ahead.\\n\\n    At index = 1, we have 4. It should be at index = 3. SO swap\\n\\n    [-1,1,3,4]\\n\\n    Again at index = 1, we have 1. But 1 should be at index = 0. So Swap.\\n\\n    [1,-1,3,4]\\n\\n    And since now we have a negative number at index = 1, ignore it.\\n\\n    At index = 2, we already have correct number i.e, 3\\n\\n    AT index = 3 we already have correct number i.e., 4\\n\\n\\nSo finally, our array becomes [1,-1,3,4]\\n\\nAnd now, we do the second part of Swap Sort algorithm, which is to find the missing number. If at index = i, we do not have i + 1, that means i + 1 is the missing number. And because we are asked to find the first positive missing number, as soon as we find a missing number, that will be the first/smallest so we can return.\\n\\nSo, in [1,-1,3,4] we will see that at index = 1, we should have 2 but instead there is -1. This means 2 is missing. So return 2.\\n\\n# **SPECIAL CASES**\\n\\nThere will be cases where we have arrays like - \\n\\n    [1]\\n\\nAnd in this case, smallest positive missing number is 2. That\\'s because as we know, positive range is from 1 to 2^31 - 1. So if 1 is there, then the next smallest number is 2 which is missing.\\n\\nBut our swap sort algorithm won\\'t be able to find it because we run the loop only till length of the array which in this case is 1.\\n\\nSo, if we did not get a missing number in the given array, that simply means the missing number is (length + 1)\\n\\n\\n```\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        # First put each number in range 1 to n at its correct place\\n        i = 0\\n        \\n        while i < n:\\n            # Swap\\n            # Only for the range 1 to n check if a number at any index is not at its correct place\\n            if nums[i] > 0 and nums[i] <= n and nums[i] != nums[nums[i] - 1]:\\n                nums[nums[i] - 1], nums[i]= nums[i], nums[nums[i] - 1]\\n            else:\\n                i += 1\\n        \\n        # And now just find the first missing number. That would be the smallest\\n        for i,num in enumerate(nums):\\n            if num != i + 1: return i + 1\\n        \\n        # Otherwise the missing positive number is n + 1 (e,g, for testcases such as [1])\\n        return n + 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        # First put each number in range 1 to n at its correct place\\n        i = 0\\n        \\n        while i < n:\\n            # Swap\\n            # Only for the range 1 to n check if a number at any index is not at its correct place\\n            if nums[i] > 0 and nums[i] <= n and nums[i] != nums[nums[i] - 1]:\\n                nums[nums[i] - 1], nums[i]= nums[i], nums[nums[i] - 1]\\n            else:\\n                i += 1\\n        \\n        # And now just find the first missing number. That would be the smallest\\n        for i,num in enumerate(nums):\\n            if num != i + 1: return i + 1\\n        \\n        # Otherwise the missing positive number is n + 1 (e,g, for testcases such as [1])\\n        return n + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1227747,
                "title": "java-solution-with-comments-o-n",
                "content": "For this problem, the numbers given are not bound by any range so we can have any number in the input array. We can iterate through the array and try to place the positive numbers between 1 and n in their correct indices. As we do so, we will ignore all the numbers that are out of range (i.e negative numbers and all numbers greater than the length of the array). Once we are done with the sorting, we will iterate through the array and find the first index that does not have the correct number.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n```\\n    public int firstMissingPositive(int[] nums) {\\n        int i = 0;\\n        int j;\\n        int n = nums.length;\\n        \\n        // handle case of a single-element array\\n        if (n == 1) {\\n            if (nums[i] == 1) return 2;\\n            else return 1;\\n        }\\n        \\n        // try to place numbers in their correct indices\\n        while (i < n) {  \\n            // ignore numbers out of range (negative numbers and numbers greater than length of the array)\\n            if (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {\\n                swap(nums, i, nums[i] - 1);\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        // loop through the array again\\n        // find the first number that is not at its correct index\\n        for (i = 0; i < n; i++) {\\n            if (nums[i] != i + 1) {\\n                return i + 1;\\n            }\\n        }\\n        \\n        return nums.length + 1;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "For this problem, the numbers given are not bound by any range so we can have any number in the input array. We can iterate through the array and try to place the positive numbers between 1 and n in their correct indices. As we do so, we will ignore all the numbers that are out of range (i.e negative numbers and all numbers greater than the length of the array). Once we are done with the sorting, we will iterate through the array and find the first index that does not have the correct number.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n```\\n    public int firstMissingPositive(int[] nums) {\\n        int i = 0;\\n        int j;\\n        int n = nums.length;\\n        \\n        // handle case of a single-element array\\n        if (n == 1) {\\n            if (nums[i] == 1) return 2;\\n            else return 1;\\n        }\\n        \\n        // try to place numbers in their correct indices\\n        while (i < n) {  \\n            // ignore numbers out of range (negative numbers and numbers greater than length of the array)\\n            if (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {\\n                swap(nums, i, nums[i] - 1);\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        // loop through the array again\\n        // find the first number that is not at its correct index\\n        for (i = 0; i < n; i++) {\\n            if (nums[i] != i + 1) {\\n                return i + 1;\\n            }\\n        }\\n        \\n        return nums.length + 1;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 382641,
                "title": "c-solution-moving-all-negative-numbers-to-right-side-of-the-array",
                "content": "```\\n\\npublic class Solution {\\n  public int FirstMissingPositive(int[] nums) {\\n    if (nums.Length == 0) return 1;\\n      if (nums.Length == 1) {\\n      if (nums[0] != 1) return 1;\\n      if (nums[0] == 1) return 2;\\n    }\\n      Array.Sort(nums);\\n    int maxNumber = nums.Max();\\n    if (maxNumber < 1) return 1;\\n      int indexPos = 0;\\n    for(int i = 0 ; i < nums.Length; i++)\\n    {\\n        if(nums[i] > 0 && nums[i] != 0)\\n        {\\n          nums[indexPos++] = nums[i];\\n        }\\n    }\\n      int negativeIndex = indexPos;\\n      for(int j = indexPos; j < nums.Length; j++)\\n          nums[indexPos] = -1;\\n      if(nums[0] != 1) return 1;\\n      for(int i = 0 ; i < negativeIndex - 1; i++)\\n      {\\n          if(nums[i + 1] != nums[i] + 1 && nums[i+1] != nums[i])\\n              return nums[i] + 1;\\n      }\\n    return maxNumber + 1;\\n  }\\n}\\n\\n````",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n  public int FirstMissingPositive(int[] nums) {\\n    if (nums.Length == 0) return 1;\\n      if (nums.Length == 1) {\\n      if (nums[0] != 1) return 1;\\n      if (nums[0] == 1) return 2;\\n    }\\n      Array.Sort(nums);\\n    int maxNumber = nums.Max();\\n    if (maxNumber < 1) return 1;\\n      int indexPos = 0;\\n    for(int i = 0 ; i < nums.Length; i++)\\n    {\\n        if(nums[i] > 0 && nums[i] != 0)\\n        {\\n          nums[indexPos++] = nums[i];\\n        }\\n    }\\n      int negativeIndex = indexPos;\\n      for(int j = indexPos; j < nums.Length; j++)\\n          nums[indexPos] = -1;\\n      if(nums[0] != 1) return 1;\\n      for(int i = 0 ; i < negativeIndex - 1; i++)\\n      {\\n          if(nums[i + 1] != nums[i] + 1 && nums[i+1] != nums[i])\\n              return nums[i] + 1;\\n      }\\n    return maxNumber + 1;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207882,
                "title": "python-beats-99-concise-4-line-solution-runtime",
                "content": "## **Please upvote/favourite/comment if you like this solution!**\\n\\n# Without space complexity restraint\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        nums_set, i = set(nums), 1\\n        while i in nums_set:\\n            i += 1\\n        return i\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Optimized\\n\\n```\\nclass Solution:\\n    def swap(self, arr, a, b):\\n        tmp = arr[a]\\n        arr[a] = arr[b]\\n        arr[b] = tmp\\n        return arr\\n\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(n):\\n            while 1 <= nums[i] <= n and nums[i] != nums[nums[i]-1]:\\n                nums = self.swap(nums,i,nums[i]-1)\\n        for j in range(n):\\n            if nums[j] != j+1:\\n                return j+1\\n        return n+1\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        nums_set, i = set(nums), 1\\n        while i in nums_set:\\n            i += 1\\n        return i\\n```\n```\\nclass Solution:\\n    def swap(self, arr, a, b):\\n        tmp = arr[a]\\n        arr[a] = arr[b]\\n        arr[b] = tmp\\n        return arr\\n\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(n):\\n            while 1 <= nums[i] <= n and nums[i] != nums[nums[i]-1]:\\n                nums = self.swap(nums,i,nums[i]-1)\\n        for j in range(n):\\n            if nums[j] != j+1:\\n                return j+1\\n        return n+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974305,
                "title": "using-cyclic-sort-technique-solve-any-range-based-questions",
                "content": "# Intuition\\nPrerequistes for solving the question is to know the **cyclic sort algorithm.**\\n\\n**Cyclic sort algorithm -** is used when the elements in the array are in the range 1 to n. \\n(n = size of the array)\\n\\n    Arr :  [4, 5, 2, 1, 3]\\n    index :[0, 1, 2, 3, 4]\\n\\nWe can see in the  above example that the elements in the array are in range 1 to n. \\n***So, how does cyclic sort work upon it to sort the array in O(n) complexity?***\\n\\n    arr: [4,5,2,1,3]\\n    arr[0]: 4 \\n\\n*To sort the array we Check - is the 0th element of the array at the correct index?* \\n-- No, so put it at its correct index by **swapping it with the element at its correct index.** \\n-- If Yes, then simply move to the next element and check.\\n-- Dry Run :- \\n\\n    Arr :  [4, 5, 2, 1, 3]\\n    index :[0, 1, 2, 3, 4]\\n\\n    Arr[0]: 4 [Not at the correct index, swap it]\\n    swap(Arr[0], Arr[4 - 1]) // 4 - 1, since 0 based indexing\\n    Arr: [1, 5, 2, 4, 3] // After placing arr[0] at correct index\\n\\n    Again check after swapping, is the swapperd element at correct index?   \\n    Arr[0]: 1 [At the correct index, move to the next element]\\n\\n    Arr[1]: 5 [Not at the correct index, swap it]\\n    swap(Arr[1], Arr[5 - 1]) \\n    Arr: [1, 3, 2, 4, 5] // After placing arr[1] at correct index\\n\\n    Again check after swapping, is the swapperd element at correct index? \\n    Arr[1]: 3 [Not at the correct index, swap it]\\n    swap(Arr[1], Arr[3 - 1]) \\n    Arr: [1, 2, 3, 4, 5] // After placing arr[1] at correct index\\n\\n     Again check after swapping, is the swapperd element at correct index? \\n    Arr[1]: 2 [At the correct index, move to the next element]\\n\\n    Again check after swapping, is the swapperd element at correct index? \\n    Arr[2]: 3 [At the correct index, move to the next element]\\n    .\\n    .\\n    .\\n    .\\n    Likewise, all the elements fall at right indices and we get a sorted array in O(n) complexity.\\n    P.S. - Works only when numbers in array range from 1 to n.\\n\\n\\n    \\n\\n\\n\\n\\n**We use cyclic sort when the given numbers in the array range from 1 to n.** But in this problem we have *negative numbers & numbers > arr.size()* as well in the array.\\n\\n**So, we need to have some clear observations first ->**\\n-- *The 1st missing number always lies between 1 to n.*\\n(Take few examples, and it will be clear)\\n-- We need not care about the negative numbers & numbers > n.\\n\\n# Complexity\\n- Time complexity:\\n0(n)\\n- Space complexity:\\nO(1)\\n\\n# Problems on cylcic sort:-\\n    --> Missing Number\\n    --> Find all numbers disappeared in array\\n    --> Find the Duplicate Numbers\\n    --> Set Mismatch\\n    --> First Missing Positive\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        // Using Cyclic Sort Technique\\n        for (int i = 0; i < n; ) {\\n\\n            // ignoring the negative & >n numbers, \\n            // as the 1st missing number would always lie between 1 to n \\n            if (nums[i] > 0 && nums[i] < nums.size() && nums[nums[i] - 1] != nums[i]) \\n                swap(nums[nums[i] - 1], nums[i]);\\n            else \\n                i++;\\n\\n        }\\n        // run a loop to check which is the 1st element, not at the correct index after sorting\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] != i + 1) {\\n                return i + 1;\\n            }\\n        }\\n        return n + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        // Using Cyclic Sort Technique\\n        for (int i = 0; i < n; ) {\\n\\n            // ignoring the negative & >n numbers, \\n            // as the 1st missing number would always lie between 1 to n \\n            if (nums[i] > 0 && nums[i] < nums.size() && nums[nums[i] - 1] != nums[i]) \\n                swap(nums[nums[i] - 1], nums[i]);\\n            else \\n                i++;\\n\\n        }\\n        // run a loop to check which is the 1st element, not at the correct index after sorting\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] != i + 1) {\\n                return i + 1;\\n            }\\n        }\\n        return n + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362460,
                "title": "c-simple-c-code-o-n-time-o-1-space",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        // Mark all out of range values as n+1\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] <= 0 || nums[i] > n){\\n                nums[i] = n+1;\\n                continue;\\n            }\\n        }\\n        // mark all ranged valued index as negative;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(abs(nums[i]) >= n+1) continue;\\n            int val = abs(nums[i]);\\n            nums[val-1] = -1*abs(nums[val-1]);\\n        }\\n        // if any ranged valued index is positive return one plus its idex since it is (1th indexing)\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] > 0) return i+1;\\n        return n+1;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        // Mark all out of range values as n+1\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] <= 0 || nums[i] > n){\\n                nums[i] = n+1;\\n                continue;\\n            }\\n        }\\n        // mark all ranged valued index as negative;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(abs(nums[i]) >= n+1) continue;\\n            int val = abs(nums[i]);\\n            nums[val-1] = -1*abs(nums[val-1]);\\n        }\\n        // if any ranged valued index is positive return one plus its idex since it is (1th indexing)\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] > 0) return i+1;\\n        return n+1;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905808,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used, if we have parameter nums as inout.\\n\\n    func firstMissingPositive(_ nums: [Int]) -> Int {\\n        var nums = nums\\n        var ans = 1\\n\\n        for (i, num) in nums.enumerated() {\\n            if num == ans { ans += 1 }\\n            if num <= 0 || num > nums.count { nums[i] = 1 }\\n        }\\n\\n        guard ans != 1, ans != nums.count + 1 else { return ans }\\n\\n        for i in 0..<nums.count {\\n            let num = abs(nums[i])\\n            if num == nums.count {\\n                nums[0] = -abs(nums[0])\\n            } else {\\n                nums[num] = -abs(nums[num])\\n            }\\n        }\\n\\n        for i in 1..<nums.count {\\n            guard nums[i] > 0 else { continue }\\n            return i\\n        }\\n        return nums.count + (nums[0] > 0 ? 0 : 1)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used, if we have parameter nums as inout.\\n\\n    func firstMissingPositive(_ nums: [Int]) -> Int {\\n        var nums = nums\\n        var ans = 1\\n\\n        for (i, num) in nums.enumerated() {\\n            if num == ans { ans += 1 }\\n            if num <= 0 || num > nums.count { nums[i] = 1 }\\n        }\\n\\n        guard ans != 1, ans != nums.count + 1 else { return ans }\\n\\n        for i in 0..<nums.count {\\n            let num = abs(nums[i])\\n            if num == nums.count {\\n                nums[0] = -abs(nums[0])\\n            } else {\\n                nums[num] = -abs(nums[num])\\n            }\\n        }\\n\\n        for i in 1..<nums.count {\\n            guard nums[i] > 0 else { continue }\\n            return i\\n        }\\n        return nums.count + (nums[0] > 0 ? 0 : 1)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334664,
                "title": "c-solution-with-o-n-time-and-o-1-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n// we can also use method where we first move all non-positive elements to left\\n// But, this method makes things more easy as we will have our answer in range [1, nums.size()+1]\\n    int firstMissingPositive(vector<int>& nums) {\\n\\t// first of all, make all -ve numbers and zeroes as some +ve value but that should be greater than nums.size()\\n\\t// because we are going to use these (elements-1) as index to mark the presence of corresponding element\\n        for(int i=0;i<nums.size();i++){\\n\\t\\t\\tif(nums[i]<=0)nums[i]=nums.size()+1;\\n\\t\\t}\\n        \\n\\t\\t// mark the presence of each element if it is between 1 to nums.size()\\n        for(int i=0;i<nums.size();i++){\\n\\t\\t\\t//since we are marking presence of an element by making element of its corresponding index as -ve\\n\\t\\t\\t// therefore, we need to take +ve value or actual value of that element (as it may have been made -ve during process)\\n\\t\\t\\tint element=abs(nums[i]);\\n\\t\\t\\t// now, presence of each element is marked at an index less by 1 than that element\\n\\t\\t\\t// eg. presence of 1 is marked at index 0\\n\\t\\t\\t// i.e. if 1 is present, we will make element at index 0 as -ve\\n            int index=element-1;;\\n            if(index<nums.size() && nums[index]>0)nums[index]*=(-1);\\n        }\\n        \\n\\t\\t// finally, index that is still having +ve value means that no element marked it\\n\\t\\t// i.e. that index+1 element is not present in the array\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0)return i+1;\\n        }\\n\\t\\t// & if all elements from 1 to nums.size() are present, then first missing positive integer is  nums.size()+1\\n        return nums.size()+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// we can also use method where we first move all non-positive elements to left\\n// But, this method makes things more easy as we will have our answer in range [1, nums.size()+1]\\n    int firstMissingPositive(vector<int>& nums) {\\n\\t// first of all, make all -ve numbers and zeroes as some +ve value but that should be greater than nums.size()\\n\\t// because we are going to use these (elements-1) as index to mark the presence of corresponding element\\n        for(int i=0;i<nums.size();i++){\\n\\t\\t\\tif(nums[i]<=0)nums[i]=nums.size()+1;\\n\\t\\t}\\n        \\n\\t\\t// mark the presence of each element if it is between 1 to nums.size()\\n        for(int i=0;i<nums.size();i++){\\n\\t\\t\\t//since we are marking presence of an element by making element of its corresponding index as -ve\\n\\t\\t\\t// therefore, we need to take +ve value or actual value of that element (as it may have been made -ve during process)\\n\\t\\t\\tint element=abs(nums[i]);\\n\\t\\t\\t// now, presence of each element is marked at an index less by 1 than that element\\n\\t\\t\\t// eg. presence of 1 is marked at index 0\\n\\t\\t\\t// i.e. if 1 is present, we will make element at index 0 as -ve\\n            int index=element-1;;\\n            if(index<nums.size() && nums[index]>0)nums[index]*=(-1);\\n        }\\n        \\n\\t\\t// finally, index that is still having +ve value means that no element marked it\\n\\t\\t// i.e. that index+1 element is not present in the array\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0)return i+1;\\n        }\\n\\t\\t// & if all elements from 1 to nums.size() are present, then first missing positive integer is  nums.size()+1\\n        return nums.size()+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997296,
                "title": "java-o-n-time-o-1-space-with-comments",
                "content": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n\\t\\t//set any 0 or negative number as the size of the array + 1\\n\\t\\t//[1,2,*-3*,4] => [1,2,*5*,4]\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] <= 0) {\\n                nums[i] = nums.length + 1;\\n            }\\n        }\\n        \\n\\t\\t//if the absolute value is a valid position of this array, then \\n\\t\\t//negate the value of the respective index\\n\\t\\t// [1,2,5,4] =>  [-1,-2,5,-4]\\n        for(int i = 0; i < nums.length; i++) {\\n            int valueIdx = Math.abs(nums[i]) - 1;\\n            if(valueIdx + 1 > 0 && valueIdx + 1 <= nums.length) {\\n                nums[valueIdx] = -Math.abs(nums[valueIdx]);\\n            }\\n        }\\n        \\n\\t\\t//traverse the array from left to right\\n\\t\\t//if there\\'s any positive number then\\n\\t\\t//we found the missing positive number\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] >= 1) {\\n                return i + 1;\\n            }\\n        }\\n        \\n\\t\\t//if all elements of the array are correct\\n\\t\\t//return the lenght of the array + 1\\n        return nums.length + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n\\t\\t//set any 0 or negative number as the size of the array + 1\\n\\t\\t//[1,2,*-3*,4] => [1,2,*5*,4]\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] <= 0) {\\n                nums[i] = nums.length + 1;\\n            }\\n        }\\n        \\n\\t\\t//if the absolute value is a valid position of this array, then \\n\\t\\t//negate the value of the respective index\\n\\t\\t// [1,2,5,4] =>  [-1,-2,5,-4]\\n        for(int i = 0; i < nums.length; i++) {\\n            int valueIdx = Math.abs(nums[i]) - 1;\\n            if(valueIdx + 1 > 0 && valueIdx + 1 <= nums.length) {\\n                nums[valueIdx] = -Math.abs(nums[valueIdx]);\\n            }\\n        }\\n        \\n\\t\\t//traverse the array from left to right\\n\\t\\t//if there\\'s any positive number then\\n\\t\\t//we found the missing positive number\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] >= 1) {\\n                return i + 1;\\n            }\\n        }\\n        \\n\\t\\t//if all elements of the array are correct\\n\\t\\t//return the lenght of the array + 1\\n        return nums.length + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17302,
                "title": "concise-o-n-solution",
                "content": "    // ignore all the negative, > n\\n    // put the other value back to its order position A[A[i]-1]\\n    int firstMissingPositive(int A[], int n) {\\n        if (n == 0) return 1;\\n        for (int i = 0; i != n; ) {\\n            if (A[i] != i + 1 && A[i] > 0 && A[i] <= n && A[A[i]-1] != A[i])\\n                swap(A[i], A[A[i] - 1]);\\n            else ++i;\\n        }\\n        \\n        for (int i = 0; i != n; ++i)\\n            if (A[i] != i + 1) return i + 1;\\n        return n+1;\\n    }",
                "solutionTags": [],
                "code": "    // ignore all the negative, > n\\n    // put the other value back to its order position A[A[i]-1]\\n    int firstMissingPositive(int A[], int n) {\\n        if (n == 0) return 1;\\n        for (int i = 0; i != n; ) {\\n            if (A[i] != i + 1 && A[i] > 0 && A[i] <= n && A[A[i]-1] != A[i])\\n                swap(A[i], A[A[i] - 1]);\\n            else ++i;\\n        }\\n        \\n        for (int i = 0; i != n; ++i)\\n            if (A[i] != i + 1) return i + 1;\\n        return n+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3259471,
                "title": "very-easy-solution-in-java-using-hashset-with-comment-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUpvote if you like it\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We will simply add add the values of nums[] in the hashset, then we will declare an  integer variable and initialize it with 1.\\n\\n- So it is clear that if an array conatins of counting numbers from 1 the max it can have is the length of the array.\\n\\n- So we\\'ll check for all the integers from 1 to nums.length if anyone is missing simply return it otherwise return nums.length +1.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158509,
                "title": "beats-83-14-first-missing-positive-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe algorithm works as follows:\\n\\nIterate through the array nums.\\nFor each element x in the array, if x is positive and less than or equal to n, and x is not in its correct position, swap it with the element at index x - 1.\\nAfter the above step, all positive integers in the range [1, n] should be in their correct positions.\\nIterate through the array nums again.\\nReturn the first index i where nums[i] != i + 1. The result is i + 1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def firstMissingPositive(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    \\n    for i in range(n):\\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\\n    \\n    for i in range(n):\\n        if nums[i] != i + 1:\\n            return i + 1\\n    \\n    return n + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def firstMissingPositive(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    \\n    for i in range(n):\\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\\n    \\n    for i in range(n):\\n        if nums[i] != i + 1:\\n            return i + 1\\n    \\n    return n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871770,
                "title": "java-easy-both-bruteforce-and-optimize-solution-0ms-100",
                "content": "**if helpful .. please do Upvote**\\n```\\nclass Solution {\\n    // public int firstMissingPositive(int[] nums) {\\n    //     //1st approach O(n) time and O(n) space\\n    //     Set<Integer> set=new HashSet<>();\\n    //     for(int i:nums){\\n    //         set.add(i);\\n    //     }\\n    //     for(int i=1;i<=nums.length;i++){\\n    //         if(!set.contains(i)){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return nums.length+1;\\n    // }\\n    \\n    \\n    public int firstMissingPositive(int[] nums) {\\n        //2nd approach O(n) time and O(1) space\\n       boolean oneExist=false;\\n        for(int i:nums){\\n            if(i==1){\\n                oneExist=true;\\n            }\\n        }\\n        if(!oneExist){\\n            return 1;\\n        }\\n        \\n        //making sure we will never see a number in the array apart from 1...n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<=0 || nums[i]>nums.length){\\n                nums[i]=1; //make those numbers 1\\n            }\\n        }\\n        \\n        //Numbers which we are found in the array mark its corresponding indices visited by making them -ve \\n        for(int i=0;i<nums.length;i++){\\n            int n=Math.abs(nums[i]);\\n            if(n==nums.length){\\n                nums[0]=-1*Math.abs(nums[0]);\\n            }\\n            else{\\n                nums[n]=-1*Math.abs(nums[n]);\\n            }\\n        }\\n        \\n        //now 1st +ve number we get in array that corresponding index is our required answer \\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>0){\\n                return i;\\n            }\\n        }\\n        if(nums[0]>0) return nums.length;\\n        \\n        return nums.length+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // public int firstMissingPositive(int[] nums) {\\n    //     //1st approach O(n) time and O(n) space\\n    //     Set<Integer> set=new HashSet<>();\\n    //     for(int i:nums){\\n    //         set.add(i);\\n    //     }\\n    //     for(int i=1;i<=nums.length;i++){\\n    //         if(!set.contains(i)){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return nums.length+1;\\n    // }\\n    \\n    \\n    public int firstMissingPositive(int[] nums) {\\n        //2nd approach O(n) time and O(1) space\\n       boolean oneExist=false;\\n        for(int i:nums){\\n            if(i==1){\\n                oneExist=true;\\n            }\\n        }\\n        if(!oneExist){\\n            return 1;\\n        }\\n        \\n        //making sure we will never see a number in the array apart from 1...n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<=0 || nums[i]>nums.length){\\n                nums[i]=1; //make those numbers 1\\n            }\\n        }\\n        \\n        //Numbers which we are found in the array mark its corresponding indices visited by making them -ve \\n        for(int i=0;i<nums.length;i++){\\n            int n=Math.abs(nums[i]);\\n            if(n==nums.length){\\n                nums[0]=-1*Math.abs(nums[0]);\\n            }\\n            else{\\n                nums[n]=-1*Math.abs(nums[n]);\\n            }\\n        }\\n        \\n        //now 1st +ve number we get in array that corresponding index is our required answer \\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>0){\\n                return i;\\n            }\\n        }\\n        if(nums[0]>0) return nums.length;\\n        \\n        return nums.length+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549123,
                "title": "python-straight-forward-with-explanation-must-read-beats-99",
                "content": "#3-pass solution\\n       #nums => [3, 4, 1, 0, -1]\\n#Pass 1: Replace all the non-positive numbers by (length of array)+1\\n       #nums => [3, 4, 1, 6, 6]\\n#Pass 2: Treat input array as array of index and make numbers present at the given index negative. \\n       #nums => [-3, 4, -1, -6, 6]\\n#Pass 3: Return the first index with positive number \\n       #Return 2 (As second number is positive)\\n\\n\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n \\n\\t#Pass 1\\n        for i,n in enumerate(nums):\\n            if n<=0:\\n                nums[i]=len(nums)+1\\n        \\n\\t#Pass 2\\n        for n in nums:\\n            n = abs(n)\\n            if n<=len(nums):\\n                nums[n-1] = -1 * abs(nums[n-1])    \\n     \\n\\t #Pass 3\\n        for i in range(len(nums)):\\n            if nums[i]>0:\\n                return i+1\\n            \\n        return len(nums)+1",
                "solutionTags": [],
                "code": "#3-pass solution\\n       #nums => [3, 4, 1, 0, -1]\\n#Pass 1: Replace all the non-positive numbers by (length of array)+1\\n       #nums => [3, 4, 1, 6, 6]\\n#Pass 2: Treat input array as array of index and make numbers present at the given index negative. \\n       #nums => [-3, 4, -1, -6, 6]\\n#Pass 3: Return the first index with positive number \\n       #Return 2 (As second number is positive)\\n\\n\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n \\n\\t#Pass 1\\n        for i,n in enumerate(nums):\\n            if n<=0:\\n                nums[i]=len(nums)+1\\n        \\n\\t#Pass 2\\n        for n in nums:\\n            n = abs(n)\\n            if n<=len(nums):\\n                nums[n-1] = -1 * abs(nums[n-1])    \\n     \\n\\t #Pass 3\\n        for i in range(len(nums)):\\n            if nums[i]>0:\\n                return i+1\\n            \\n        return len(nums)+1",
                "codeTag": "Python3"
            },
            {
                "id": 489072,
                "title": "c-simple-o-n-time-beats-100-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/first-missing-positive/solution/\\n    \\n    The idea is to move each number to its correct 0-indexed position. Then traverse\\n    the array for the second time and the first index where the number doesn\\'t match is\\n    the answer. If the array has everything in place, then N + 1 is the answer.\\n    The fact that the array size is N, so even if there are numbers greater than N,\\n    they need not be considered as the array that should be at that place can always be the\\n    answer even if all other numbers are present, so need to consider > N.\\n    \\n    TC: O(N)\\n    SC: O(1)\\n*/\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        for(int i = 0; i < nums.size();) {\\n            // swap the current number to its correct position\\n            if(nums[i] >= 0 && nums[i] - 1 >= 0 && nums[i] - 1 < nums.size()) {\\n                swap(nums[nums[i]-1], nums[i]);\\n            }\\n            // if the current number is -ve, 0 or greater than array length or\\n            // the number is already at its correct position or the correct position\\n            // of the current number already has a duplicate of this, skip current number\\n            if(nums[i] <= 0 || nums[i] == i+1 || nums[i] > nums.size() ||\\n               nums[nums[i]-1] == nums[i])\\n                ++i;\\n        }\\n        \\n        // answer is the first position (1 based) that doesn\\'t match the number there\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        return nums.size() + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/first-missing-positive/solution/\\n    \\n    The idea is to move each number to its correct 0-indexed position. Then traverse\\n    the array for the second time and the first index where the number doesn\\'t match is\\n    the answer. If the array has everything in place, then N + 1 is the answer.\\n    The fact that the array size is N, so even if there are numbers greater than N,\\n    they need not be considered as the array that should be at that place can always be the\\n    answer even if all other numbers are present, so need to consider > N.\\n    \\n    TC: O(N)\\n    SC: O(1)\\n*/\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        for(int i = 0; i < nums.size();) {\\n            // swap the current number to its correct position\\n            if(nums[i] >= 0 && nums[i] - 1 >= 0 && nums[i] - 1 < nums.size()) {\\n                swap(nums[nums[i]-1], nums[i]);\\n            }\\n            // if the current number is -ve, 0 or greater than array length or\\n            // the number is already at its correct position or the correct position\\n            // of the current number already has a duplicate of this, skip current number\\n            if(nums[i] <= 0 || nums[i] == i+1 || nums[i] > nums.size() ||\\n               nums[nums[i]-1] == nums[i])\\n                ++i;\\n        }\\n        \\n        // answer is the first position (1 based) that doesn\\'t match the number there\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        return nums.size() + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 311888,
                "title": "clearing-problem-description-with-detailed-solution-explaination",
                "content": "**Clearing problem description:**\\n- Problem is asking you to find the number \"starting from 1\" which is missing. For example:\\n- - [1,2,0], we are ignoring numbers<=0 so if we write this in order we get \"1 2\" here 3 is first missing positive\\n- - [3,4,-1,1] , writing this in order we get \"1 3 4\" and thus 2 is first missing positive\\n- - [7,8,9,10], starting from 1, here 1 is first missing positive\\n\\n**Solution:**\\nI am going to give you an O(3n) solution but using this similarly you can get the O(2n) solution. Note that both are O(n) solution\\n\\nTake N = length of array\\nFirst of all in array, set all \"zero and numbers greater than N\" to -1 since they are no use to us. I will tell you later why I chose -1.\\n\\nNow for all positive numbers \"p\" left in the array, we will set array[p-1] = 0, but before doing so we should also take care of the number present in (p-1)th position.\\nHere 0 implies that number p is present in the array. So later when we see 0 at index i in array we can say that i+1 is definitely present in the array. \\nAfter settings zeros, the first missing number will be:  index(\"non zero number\") +1\\nIf all are zeros then first missing number will be len(array)+1\\n\\nFor example: [3,4,-1,1] ,\\nApplying above procedure:\\n- when i=0 --> [3 4 0 1]\\n- when i =1 -->[3 4 0 0] --> [0 4 0 0]\\n- when i=2 since idx<0 pass\\n- when i=3 since idx<0 pass\\nwe get [0 4 0 0] so first missing is 2\\n\\n**Algorithm(pseudocode):**\\n\\nFor i in ( 0 to length(array)-1 )\\n**{**\\n\\n p = array[i];  \\n Index idx = p-1;\\n\\nwhile(idx>=0 and idx<length(array)) {\\n* store the value at idx to a variable temp. i.e. temp = array[idx]\\n* Set array[idx] = 0.  \\n* Jump to temp-1 location by doing idx=temp-1 \\n}\\n\\n**}**\\n\\nSo what will happen is that for all the positive numbers the inner loop will jump and set array[idx]=0 for numbers in the array. When temp<=0 then idx=temp-1<0, so inner loop will break. This is why I set useless items to -1.\\nOuter loop will ensure that no numbers are left out.\\n\\nTime complexity is O(3n) because setting all \"zero and numbers greater than N\" to -1 takes O(n),\\nouter loop takes O(n)\\nInner jumps will be at max O(n) because after setting all positive number\\'s corresponding indexes to 0 there will be no jump.\\n\\n**Python code:**\\n```\\ndef firstMissingPositive(self, nums):\\n\\tif not nums:\\n\\t    return 1\\n\\n\\tN = len(nums)\\n\\tfor i in xrange(len(nums)):\\n\\t    if nums[i] ==0 or nums[i] > N:\\n\\t        nums[i] = -1\\n\\tfor i in xrange(len(nums)):\\n\\t    idx = nums[i]-1\\n\\t    while(idx>=0 and idx<N):\\n\\t        tmp = nums[idx]\\n\\t        nums[idx] = 0\\n\\t        idx = tmp-1\\n\\tfor i in xrange(len(nums)):\\n\\t    if nums[i] != 0:\\n\\t        return i+1\\n\\treturn len(nums)+1\\n```\\n\\nThe O(2n) method involves setting array[idx] = idx+1 and breaking the inner while loop when array[idx] = idx+1 is already set",
                "solutionTags": [],
                "code": "```\\ndef firstMissingPositive(self, nums):\\n\\tif not nums:\\n\\t    return 1\\n\\n\\tN = len(nums)\\n\\tfor i in xrange(len(nums)):\\n\\t    if nums[i] ==0 or nums[i] > N:\\n\\t        nums[i] = -1\\n\\tfor i in xrange(len(nums)):\\n\\t    idx = nums[i]-1\\n\\t    while(idx>=0 and idx<N):\\n\\t        tmp = nums[idx]\\n\\t        nums[idx] = 0\\n\\t        idx = tmp-1\\n\\tfor i in xrange(len(nums)):\\n\\t    if nums[i] != 0:\\n\\t        return i+1\\n\\treturn len(nums)+1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3243954,
                "title": "java-easy-approach-constant-space",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nput the element that are in range 1 to n to their correct pos like \\nnums[i]-1 pos. then the first element which does match with their pos is the ans.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n=nums.length;\\n       int i=0;\\n       while(i<n){\\n           int a=nums[i];\\n           if(a>=1 && a<=n){\\n               if(nums[a-1]!=a){\\n                   nums[i]=nums[a-1];\\n                   nums[a-1]=a;\\n               }\\n               else i++;\\n           }\\n           else{\\n               i++;\\n           }\\n       }\\n      for(int j=0;j<n;j++){\\n          if(nums[j]!=j+1)return j+1;\\n      }\\n      return n+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n=nums.length;\\n       int i=0;\\n       while(i<n){\\n           int a=nums[i];\\n           if(a>=1 && a<=n){\\n               if(nums[a-1]!=a){\\n                   nums[i]=nums[a-1];\\n                   nums[a-1]=a;\\n               }\\n               else i++;\\n           }\\n           else{\\n               i++;\\n           }\\n       }\\n      for(int j=0;j<n;j++){\\n          if(nums[j]!=j+1)return j+1;\\n      }\\n      return n+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764215,
                "title": "python-o-n-with-explanation-inverse-pigeonhole-principle",
                "content": "Since we have to use constant space (ie. can\\'t allocate something of `nums` size), we can modify the original input array `nums` to help us instead. \\n\\n**Idea:** Modify `nums` in-place as an array that represents each positive integer\\'s (\\u2208 [1, n]) presence. Then scan from left to right to find smallest index without presence.\\n\\n`eg. nums = [3, 4, -1, 1]`\\n\\nFirst, since `nums` is of size n, we know the first missing positive will be in the range [1, n + 1]. Thus, we will transform all values outside of the range [1, n] to n + 1. You will see why I used n + 1 in the next step, but ultimately, it has to be a value > n or = 0.\\n\\n```\\nn = 4\\n[3, 4, 5, 1]\\n```\\n\\nNext, for each x \\u2208 `nums`, if x is in range [1, n], we mark `nums[x - 1]` as a negative value. We use the +/- representation here as a pseudo boolean value (seen in the code below) as we don\\'t want to modify the (absolute) value itself as the value may be accessed later on.\\n\\n`[-3, 4, -5, -1]`\\n\\nFinally, from left to right, if `nums[i] > 0`, then the `i + 1` value must be the first missing positive. If we go through this loop without finding a positive value, then `n + 1` must be the first missing positive.\\n\\n`[-3, 4, -5, -1] -> return 2 ( i = 1)`\\n\\n**Code:**\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(n):\\n            if not (0 < nums[i] <= n):\\n                nums[i] = n + 1\\n        for i in range(n):\\n            x = abs(nums[i])\\n            if 0 < x <= n:\\n                nums[x - 1] = abs(nums[x - 1]) * -1\\n        for i in range(n):\\n            if nums[i] > 0:\\n                return i + 1\\n        return n + 1\\n```\\nPS. This relies on something I\\'ll call inverse pigeonhole principle. If there are n values from [1, m], and each x \\u2208 [1, m] is put into index x - 1 of m containers with n <= m, then at least one container will not have anything, or m + 1 will be the smallest container we have to add that will not have anything.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nn = 4\\n[3, 4, 5, 1]\\n```\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(n):\\n            if not (0 < nums[i] <= n):\\n                nums[i] = n + 1\\n        for i in range(n):\\n            x = abs(nums[i])\\n            if 0 < x <= n:\\n                nums[x - 1] = abs(nums[x - 1]) * -1\\n        for i in range(n):\\n            if nums[i] > 0:\\n                return i + 1\\n        return n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024371,
                "title": "c-0ms-runtime-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int firstMissingPositive(vector<int>nums)\\n    {\\n        int n=nums.size();\\n        for(int i = 0; i < nums.size(); ++ i)\\n            while(nums[i] > 0 && nums[i] <= nums.size() && nums[nums[i] - 1] != nums[i])\\n                swap(nums[i], nums[nums[i] - 1]);\\n        \\n        for(int i = 0; i < nums.size(); ++ i)\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        \\n        return n + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int firstMissingPositive(vector<int>nums)\\n    {\\n        int n=nums.size();\\n        for(int i = 0; i < nums.size(); ++ i)\\n            while(nums[i] > 0 && nums[i] <= nums.size() && nums[nums[i] - 1] != nums[i])\\n                swap(nums[i], nums[nums[i] - 1]);\\n        \\n        for(int i = 0; i < nums.size(); ++ i)\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        \\n        return n + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722399,
                "title": "no-code-just-explanation-o-n-time-o-1-space-complexity",
                "content": "If we have an array of length n we know \"smallest missing positive integer\" must be in between 1 and n+1(inclusive).\\n\\nFor example:\\n[3,1,2,8,9] in this case we have an array of length n=5, so our smallest missing positive integer must lie between 1 and 5+1 = 6(inclusive).\\n\\nClearly, those values that are greater than n(5) should not be in here. Because if we have any value greater than n those values are occupying some samller values place. For example, 8 is occupying index 3 where we should have either 4 or 5 and also 9 is occupying index 4 where we should have either 5 or 4.\\n\\nThe same goes for any value less than or equal to 0.\\n\\nFor example:\\n[-1,-2,3,1,2]\\n-1 is at index 0 where we should either 4 or 5, the same is true for -2 as well.\\n\\nSo, values that are >n and <=0 are all garbage. We don\\'t need those.\\n\\nLet\\'s modify the array:\\n[3,1,2,8,9] will become [3,1,2,1,1]\\n[-1,-2,3,1,2] will become [1,1,3,1,2]\\n\\nWhy are we putting 1 in place of those values?\\n\\nWe know that, 1 is the smallest positive integer from 1 to infinity.\\n\\nSo if our array does not contain 1 then we know for sure that 1 is going to be the answer. There is no point checking further.\\n\\nBut, if we do have 1 as an item inside the array then some other value[ >1 && <=n ] inside the array which is missing will be the answer. If none are missing then n+1 will be the answer.\\n\\nWith that in mind when we see any garbage value that should not be in this array we replace that value with 1, which we already knew is present in the array. Between garbage value and 1, only 1 is allowed to be present in our modified array.\\n\\nOnce we are done processing our array, we know all the values inside the array should lie between 1 & n(inclusive).\\n\\nOne more processing needs to happen before we look for the answer.\\nAs an easier example, let\\'s say after processing up till this point we got an array like this:\\n[1,2,3,3]\\nIn an ideal case we should have had [1,2,3,4], if all the values were present. Now in this case which one is not present? How can you tell? \\nIf we take each value of each index and update the corresponding value to it\\'s negative then we will have an array like this [-1,-2,-3,3].\\nHow? Take i=2, update whatever is present to negative:\\n```\\n                int index = Math.abs(nums[i])-1;\\n                nums[index] = -Math.abs(nums[index]);\\n```\\n[1,2,2,3] , similarly:\\n[-1,-2,-2,3]\\n\\nAfter that, we will check for the first index where the value is still positive. Our answer will be that index+1.\\n\\nIf this is not the case then our answer will be n+1 since all the values between 1 and n are present in the array.\\n\\nHope this will help anyone who is not looking for code but explanation.\\n\\n**Still need the solution? \\nhttps://nextswe.com/leetcode-41-first-missing-positive/ \\nCode is at the bottom of the explanation.**",
                "solutionTags": [],
                "code": "```\\n                int index = Math.abs(nums[i])-1;\\n                nums[index] = -Math.abs(nums[index]);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17230,
                "title": "java-accepted-no-swap-just-use-push",
                "content": "number i should be in index i-1 of nums.\\nkeep pushing number A into its right place, and push out the existing number B from this place and continue push number B into its right place again.\\n\\ni.e. start from the first number 3\\n \\nIndex:0, 1, 2, 3,  4\\n\\nArray: 3, 4, 5, 1, -1  curr number 3\\n\\nArray: 3, 4, 3, 1, -1 push 3 to index 2, the number being pushed out is 5\\n\\nArray: 3, 4, 3, 1, 5  push 5 to index 4, the number being pushed out is -1, so we stop.\\n\\nArray: 3, 4, 3, 4, 5  next number is 4, push 4 to index 3, the number being pushed out is 1\\n\\nArray: 1, 4, 3, 4, 5  push 1 to index 0, the number being pushed out is 3\\n\\nArray: 1, 4, 3, 4, 5  since 3 is already at index 2 (right place), we stop\\n\\ncheck next number is 3 (already right place), then 4 (right place), then 5 (right place), stop.\\n\\nNow we compare each number with its index, should be number == index+1, otherwise the number is the first missing positive.\\n\\n    public class Solution {\\n        public int firstMissingPositive(int[] nums) {\\n            // nums[i] -> i+1\\n            int next;\\n            for (int i = 0 ; i < nums.length; i++) {\\n                int curr = nums[i];\\n                if (curr > 0 && curr != i+1 && curr <= nums.length) {\\n                    do {\\n                        next = nums[curr-1];\\n                        nums[curr-1] = curr;\\n                        curr = next;\\n                    } while (curr > 0 && curr <= nums.length && nums[curr-1] != curr);\\n                }\\n            }\\n            int j;\\n            for (j = 0; j < nums.length; j++) {\\n                if (nums[j] != j+1)\\n                    break;\\n            }\\n            return j+1;\\n        }\\n    }",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n        public int firstMissingPositive(int[] nums) {\\n            // nums[i] -> i+1\\n            int next;\\n            for (int i = 0 ; i < nums.length; i++) {\\n                int curr = nums[i];\\n                if (curr > 0 && curr != i+1 && curr <= nums.length) {\\n                    do {\\n                        next = nums[curr-1];\\n                        nums[curr-1] = curr;\\n                        curr = next;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 17256,
                "title": "short-python-solution-using-abs",
                "content": "set the index of the corresponding number to negative if the number does not exceed the length of list.\\n\\n    class Solution(object):\\n        def firstMissingPositive(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            n = len(nums)\\n            for i in xrange(n):\\n                if nums[i] <= 0: nums[i] = len(nums)+1\\n            for i in xrange(n):\\n                if abs(nums[i]) <= n: nums[abs(nums[i])-1] = -abs(nums[abs(nums[i])-1])\\n            for i in xrange(n):\\n                if nums[i] > 0: return i+1\\n            return n+1",
                "solutionTags": [
                    "Python"
                ],
                "code": "set the index of the corresponding number to negative if the number does not exceed the length of list.\\n\\n    class Solution(object):\\n        def firstMissingPositive(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            n = len(nums)\\n            for i in xrange(n):\\n                if nums[i] <= 0: nums[i] = len(nums)+1\\n            for i in xrange(n):\\n                if abs(nums[i]) <= n: nums[abs(nums[i])-1] = -abs(nums[abs(nums[i])-1])\\n            for i in xrange(n):\\n                if nums[i] > 0: return i+1\\n            return n+1",
                "codeTag": "Java"
            },
            {
                "id": 2644922,
                "title": "both-apporch-you-can-understand-easily",
                "content": "```\\nint firstMissingPositive(vector<int>& nums) {\\n\\n        unordered_map<int,int>m;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n           m[nums[i]]++;\\n        }\\n        for(int i=1;i<=n+1;i++)\\n        {\\n            if(m.find(i)==m.end())\\n                return i;\\n        }\\n        return -1;\\n    }\\n\\t// t(c)=o(n)\\n\\ts(c)=o(n)\\n\\t\\n\\t\\n\\t// swap sort\\n\\t int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=0;\\n        while(i<n)\\n        {\\n            if(nums[i]>0&&nums[i]<=n&&nums[i]!=nums[nums[i]-1])\\n                swap(nums[i],nums[nums[i]-1]);\\n            else\\n                i++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]!=i+1)\\n            {\\n               return i+1;\\n            }\\n        }\\n        return n+1;\\n    }\\n\\t\\tt(c)=o(n);\\n\\t\\ts(c)=o(1);\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint firstMissingPositive(vector<int>& nums) {\\n\\n        unordered_map<int,int>m;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n           m[nums[i]]++;\\n        }\\n        for(int i=1;i<=n+1;i++)\\n        {\\n            if(m.find(i)==m.end())\\n                return i;\\n        }\\n        return -1;\\n    }\\n\\t// t(c)=o(n)\\n\\ts(c)=o(n)\\n\\t\\n\\t\\n\\t// swap sort\\n\\t int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=0;\\n        while(i<n)\\n        {\\n            if(nums[i]>0&&nums[i]<=n&&nums[i]!=nums[nums[i]-1])\\n                swap(nums[i],nums[nums[i]-1]);\\n            else\\n                i++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]!=i+1)\\n            {\\n               return i+1;\\n            }\\n        }\\n        return n+1;\\n    }\\n\\t\\tt(c)=o(n);\\n\\t\\ts(c)=o(1);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2148440,
                "title": "cpp-solution-with-added-comments-o-1-memory-o-n-time",
                "content": "#  Runtime 54.15% and Memory 77.83%\\n\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        \\n//         we have no use with -ve elements iin list so, make them useless by making them out of range\\n       \\n        for(int i=0;i<nums.size();i++){\\n            if (nums[i]<=0){\\n                nums[i] = nums.size()+1;\\n            }\\n        }\\n       //         we convert our existing array to a map, without using extra space\\n//  so, all we need to check if you have the elements in range[1,nums.size()+1]\\n//         so basically if that element is present just go to tht index and make it negative\\n        for(int i =0;i<nums.size();i++){\\n            int ind = abs(nums[i])-1;\\n            if (ind>=0 and ind<nums.size() and nums[ind]>0) \\n                nums[ind]=-nums[ind];\\n        }\\n//         finally the missing element basically wont be flagged negative so return that position\\n        for(int i=0;i<nums.size();i++){\\n            if (nums[i]>=0)\\n                return i+1;\\n        }\\n// in case the array was flagged completely negative basically the missing element is 1 more than size of array\\n        return nums.size()+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        \\n//         we have no use with -ve elements iin list so, make them useless by making them out of range\\n       \\n        for(int i=0;i<nums.size();i++){\\n            if (nums[i]<=0){\\n                nums[i] = nums.size()+1;\\n            }\\n        }\\n       //         we convert our existing array to a map, without using extra space\\n//  so, all we need to check if you have the elements in range[1,nums.size()+1]\\n//         so basically if that element is present just go to tht index and make it negative\\n        for(int i =0;i<nums.size();i++){\\n            int ind = abs(nums[i])-1;\\n            if (ind>=0 and ind<nums.size() and nums[ind]>0) \\n                nums[ind]=-nums[ind];\\n        }\\n//         finally the missing element basically wont be flagged negative so return that position\\n        for(int i=0;i<nums.size();i++){\\n            if (nums[i]>=0)\\n                return i+1;\\n        }\\n// in case the array was flagged completely negative basically the missing element is 1 more than size of array\\n        return nums.size()+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704248,
                "title": "easy-c-solution-with-full-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- First, we store the minimum value in ***mn*** & in between make all values 1 which are less than 1 or greater than n.\\n- **The logic behind it:** if the array is size n, then max possible n positive character. if any value is greater than n, then there is already an element from 1 to n that is not present.\\n- After the loop ends, if we find ***mn is greater than 1***, that means 1 is not present & simply ***return 1***.\\n- Else we\\u2019ll iterate again & go to the index from elements and if it\\u2019s not negative then make it negative.\\n- Again iterate all elements & the first index where ***the element is positive***, which means that element is not present. So ***return i+1***.\\n- Still, we iterate all elements and didn\\u2019t find the ans that means elements are from 1 to n, in the array, so return ***n+1***.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int mn=INT_MAX;\\n        int n=nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i]>0 && mn>nums[i])\\n                mn = nums[i];\\n            if(nums[i]<1 || nums[i]>n) \\n                nums[i]=1;\\n        }\\n        if(mn > 1)\\n            return 1;\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[abs(nums[i])-1]>0) \\n                nums[abs(nums[i])-1] *= -1;            \\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i]>0) return i+1;\\n        }\\n        \\n        return n+1;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int mn=INT_MAX;\\n        int n=nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i]>0 && mn>nums[i])\\n                mn = nums[i];\\n            if(nums[i]<1 || nums[i]>n) \\n                nums[i]=1;\\n        }\\n        if(mn > 1)\\n            return 1;\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[abs(nums[i])-1]>0) \\n                nums[abs(nums[i])-1] *= -1;            \\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i]>0) return i+1;\\n        }\\n        \\n        return n+1;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318705,
                "title": "java-1-ms-time-beats-96-3-progressive-methods-with-idea",
                "content": "**Method 1:**\\n**T/S:** O(n lg n)/O(1)\\n```\\npublic int firstMissingPositive(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tvar lastPositiveSeen = 1;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tif (nums[i] <= 0 || (i > 0 && nums[i] == nums[i - 1])) // ignore non-positives and duplicates\\n\\t\\t\\tcontinue;\\n\\t\\tif (nums[i] == lastPositiveSeen)\\n\\t\\t\\tlastPositiveSeen++;\\n\\t\\telse\\n\\t\\t\\tbreak;\\n\\t}\\n\\treturn lastPositiveSeen;\\n}\\n```\\n\\n**Method 2:**\\n**T/S:** O(n)/O(n)\\n```\\npublic int firstMissingPositive(int[] nums) {\\n\\tvar max = Integer.MIN_VALUE;\\n\\tvar set = new HashSet<Integer>();\\n\\tfor (var num : nums) {\\n\\t\\tset.add(num);\\n\\t\\tmax = Math.max(max, num);\\n\\t}\\n\\tif (max < 1)\\n\\t\\treturn 1;\\n\\tfor (var i = 1; i <= max; i++)\\n\\t\\tif (!set.contains(i))\\n\\t\\t\\treturn i;\\n\\treturn max + 1;\\n}\\n```\\n\\n**Method 3:**\\n**Idea:**\\n* Progress from Method 2 to Method 3, thinking on the line of O(1) time access. Index of array can be paired up with values of array to give a hint on the solution.\\n* Ignore non-positives.\\n* The technique is a bit similar to wiggle sort. \\n* It needs some practice, experience and hitting the questions from multiple directions to arrive to this solution.\\n* Constant run-time in arrays is usually achieved with two-pointers, swapping, multi-scan (this question required traversing the array twice) etc.\\n* Arrays provide O(1) time access and are often used as look-up tables if the keys (array index) can be kept within bounds.\\n* Here we put positives in their \"right place\" which is defined as value of the number - 1\\n\\n**T/S:** O(n)/O(1) (This constraint makes it LC Hard)\\n```\\npublic int firstMissingPositive(int[] nums) {\\n\\tvar n = nums.length;\\n\\tfor (var i = 0; i < nums.length; i++)\\n\\t\\t//  put positives in their right place as long as possible\\n\\t\\twhile (0 <= nums[i] - 1 && nums[i] - 1 < n && nums[i] != nums[nums[i] - 1]) \\n\\t\\t\\tswap(nums, nums[i] - 1, i);\\n\\n\\t// scan for first missing positive\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tif (nums[i] != i + 1)\\n\\t\\t\\treturn i + 1;\\n\\treturn n + 1;\\n}\\n\\nprivate void swap(int[] nums, int i, int j) {\\n\\tvar temp = nums[i];\\n\\tnums[i] = nums[j];\\n\\tnums[j] = temp;\\n}\\n```\\n\\n```\\nWhat swap would look like for this array: [2, 3, 7, 6, 8, -1, -10, 15]\\n\\n[2, 3, 7, 6, 8, -1, -10, 15]\\n[3, 2, 7, 6, 8, -1, -10, 15]\\n[7, 2, 3, 6, 8, -1, -10, 15]\\n[-10, 2, 3, 6, 8, -1, 7, 15]\\n[-10, 2, 3, -1, 8, 6, 7, 15]\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int firstMissingPositive(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tvar lastPositiveSeen = 1;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tif (nums[i] <= 0 || (i > 0 && nums[i] == nums[i - 1])) // ignore non-positives and duplicates\\n\\t\\t\\tcontinue;\\n\\t\\tif (nums[i] == lastPositiveSeen)\\n\\t\\t\\tlastPositiveSeen++;\\n\\t\\telse\\n\\t\\t\\tbreak;\\n\\t}\\n\\treturn lastPositiveSeen;\\n}\\n```\n```\\npublic int firstMissingPositive(int[] nums) {\\n\\tvar max = Integer.MIN_VALUE;\\n\\tvar set = new HashSet<Integer>();\\n\\tfor (var num : nums) {\\n\\t\\tset.add(num);\\n\\t\\tmax = Math.max(max, num);\\n\\t}\\n\\tif (max < 1)\\n\\t\\treturn 1;\\n\\tfor (var i = 1; i <= max; i++)\\n\\t\\tif (!set.contains(i))\\n\\t\\t\\treturn i;\\n\\treturn max + 1;\\n}\\n```\n```\\npublic int firstMissingPositive(int[] nums) {\\n\\tvar n = nums.length;\\n\\tfor (var i = 0; i < nums.length; i++)\\n\\t\\t//  put positives in their right place as long as possible\\n\\t\\twhile (0 <= nums[i] - 1 && nums[i] - 1 < n && nums[i] != nums[nums[i] - 1]) \\n\\t\\t\\tswap(nums, nums[i] - 1, i);\\n\\n\\t// scan for first missing positive\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tif (nums[i] != i + 1)\\n\\t\\t\\treturn i + 1;\\n\\treturn n + 1;\\n}\\n\\nprivate void swap(int[] nums, int i, int j) {\\n\\tvar temp = nums[i];\\n\\tnums[i] = nums[j];\\n\\tnums[j] = temp;\\n}\\n```\n```\\nWhat swap would look like for this array: [2, 3, 7, 6, 8, -1, -10, 15]\\n\\n[2, 3, 7, 6, 8, -1, -10, 15]\\n[3, 2, 7, 6, 8, -1, -10, 15]\\n[7, 2, 3, 6, 8, -1, -10, 15]\\n[-10, 2, 3, 6, 8, -1, 7, 15]\\n[-10, 2, 3, -1, 8, 6, 7, 15]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 478668,
                "title": "java-clean-100-o-1-space-o-n-time-comments",
                "content": "```    \\n    /**\\n     * The insight here is that each number in the array must fall within the size of the array.\\n     * For example, if the size of the array is 20, then the first missing positive integer has\\n     * to be [1..21] (note 21 is the case where all the given numbers fall within the size of\\n     * the array).\\n     *\\n     * So, to figure out which number is missing, we place each number into the index that cooresponds\\n     * to the numbers\\'s value+1 (similar to a modified count sort).  If the number falls outside the\\n     * range of the array then it can\\'t be a missing value.\\n     *\\n     * Finally, we run through the array to find which index didn\\'t have a corresponding value.\\n     * In the case all values are present then the first one \"missing\" is the length of the array+1.\\n     */\\n    public static int firstMissingPositive(int[] nums) {\\n        \\n        for (int i=0; i < nums.length; i++) {\\n            int insertIdx = nums[i]-1;\\n            if (insertIdx >= 0 && insertIdx < nums.length && nums[insertIdx] != nums[i]) {\\n                int temp = nums[insertIdx];\\n                nums[insertIdx] = nums[i];\\n                nums[i] = temp;\\n                i--;\\n            }\\n        }\\n\\n        for (int i=0; i < nums.length; i++) {\\n            if (nums[i]-1 != i) return i+1;\\n        }\\n\\n        return nums.length+1;\\n    }",
                "solutionTags": [],
                "code": "```    \\n    /**\\n     * The insight here is that each number in the array must fall within the size of the array.\\n     * For example, if the size of the array is 20, then the first missing positive integer has\\n     * to be [1..21] (note 21 is the case where all the given numbers fall within the size of\\n     * the array).\\n     *\\n     * So, to figure out which number is missing, we place each number into the index that cooresponds\\n     * to the numbers\\'s value+1 (similar to a modified count sort).  If the number falls outside the\\n     * range of the array then it can\\'t be a missing value.\\n     *\\n     * Finally, we run through the array to find which index didn\\'t have a corresponding value.\\n     * In the case all values are present then the first one \"missing\" is the length of the array+1.\\n     */\\n    public static int firstMissingPositive(int[] nums) {\\n        \\n        for (int i=0; i < nums.length; i++) {\\n            int insertIdx = nums[i]-1;\\n            if (insertIdx >= 0 && insertIdx < nums.length && nums[insertIdx] != nums[i]) {\\n                int temp = nums[insertIdx];\\n                nums[insertIdx] = nums[i];\\n                nums[i] = temp;\\n                i--;\\n            }\\n        }\\n\\n        for (int i=0; i < nums.length; i++) {\\n            if (nums[i]-1 != i) return i+1;\\n        }\\n\\n        return nums.length+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 231337,
                "title": "python-solution",
                "content": "Idea: change `nums[n-1]` to `float(\\'inf\\')` for all `n` in `nums` if `1 <= n <= len(nums)`, meaning that we have seen `n` in `nums`. Then we traverse `nums` once more, and find the first `idx` such that `nums[idx] != float(\\'inf\\')`, then `idx+1` will be the first missing positive in `nums`. If no such `idx` exists, it means that we have seen `1, 2, ..., len(nums)` in `nums`, hence the first missing positive is `len(nums)+1`.\\n\\nTime complexity: `O(n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        for i, n in enumerate(nums):\\n            if n < 0:\\n                continue\\n            else:\\n                while n <= len(nums) and n > 0:\\n                    tmp = nums[n-1]\\n                    nums[n-1] = float(\\'inf\\')\\n                    n = tmp\\n        for i in range(len(nums)):\\n            if nums[i] != float(\\'inf\\'):\\n                return i+1\\n            \\n        return len(nums)+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        for i, n in enumerate(nums):\\n            if n < 0:\\n                continue\\n            else:\\n                while n <= len(nums) and n > 0:\\n                    tmp = nums[n-1]\\n                    nums[n-1] = float(\\'inf\\')\\n                    n = tmp\\n        for i in range(len(nums)):\\n            if nums[i] != float(\\'inf\\'):\\n                return i+1\\n            \\n        return len(nums)+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181362,
                "title": "o-n-time-o-1-space-solution-x-2",
                "content": "### Solution 1\\nMark all non-positve `nums` as `MAX`, and mark `nums[abs(nums[i]) - 1]` as negative when we first met `abs(nums[i])`. In this way, the first missing positive is the `index` of the first positive element in nums `+ 1`\\n****\\n```\\n    public int firstMissingPositive(int[] nums) {\\n        if (nums.length == 0) return 1;\\n        \\n        int numLen = nums.length;\\n\\t\\t\\n        // Mark non-positive as MAX.\\n        for (int i = 0; i < numLen; i++) {\\n            if (nums[i] <= 0) nums[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        // Mark on original array.\\n        for (int i = 0; i < numLen; i++) {\\n            int absNum = Math.abs(nums[i]);\\n            if (absNum != Integer.MAX_VALUE && absNum - 1 < numLen && nums[absNum - 1] > 0) {\\n                nums[absNum - 1] = -nums[absNum - 1];\\n            }\\n        }\\n        \\n        // Get first missing positive.\\n        for (int i = 0; i < numLen; i++) {\\n            if (nums[i] > 0) return i + 1;  \\n        }\\n\\n        return numLen + 1;\\n    }\\n```\\n### Solution 2\\nIf nums are consecutive, then `each nums[i] == i + 1`. If we put valid nums[i] into their right position by swapping, then the first `i + 1 such that nums[i] != i + 1` must be the first missing number.\\n```\\n    public int firstMissingPositive(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            while (nums[i] != i + 1 \\n                && nums[i] >= 1\\n                && nums[i] <= nums.length\\n                && nums[nums[i] - 1] != nums[i]) {\\n                swap(i, nums[i] - 1, nums);\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != i + 1)\\n                return i + 1;\\n        }\\n        \\n        return nums.length + 1;\\n    }\\n    \\n    \\n    private void swap(int i, int j, int[] nums) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int firstMissingPositive(int[] nums) {\\n        if (nums.length == 0) return 1;\\n        \\n        int numLen = nums.length;\\n\\t\\t\\n        // Mark non-positive as MAX.\\n        for (int i = 0; i < numLen; i++) {\\n            if (nums[i] <= 0) nums[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        // Mark on original array.\\n        for (int i = 0; i < numLen; i++) {\\n            int absNum = Math.abs(nums[i]);\\n            if (absNum != Integer.MAX_VALUE && absNum - 1 < numLen && nums[absNum - 1] > 0) {\\n                nums[absNum - 1] = -nums[absNum - 1];\\n            }\\n        }\\n        \\n        // Get first missing positive.\\n        for (int i = 0; i < numLen; i++) {\\n            if (nums[i] > 0) return i + 1;  \\n        }\\n\\n        return numLen + 1;\\n    }\\n```\n```\\n    public int firstMissingPositive(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            while (nums[i] != i + 1 \\n                && nums[i] >= 1\\n                && nums[i] <= nums.length\\n                && nums[nums[i] - 1] != nums[i]) {\\n                swap(i, nums[i] - 1, nums);\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != i + 1)\\n                return i + 1;\\n        }\\n        \\n        return nums.length + 1;\\n    }\\n    \\n    \\n    private void swap(int i, int j, int[] nums) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2599047,
                "title": "1-ms-java-solution-o-n-time-and-o-1-space",
                "content": "if you like it please upvote it\\n\\nclass Solution \\n{\\npublic int firstMissingPositive(int[] nums)\\n{\\n      int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<=0 || nums[i]>n)\\n            { \\n              nums[i]=n+1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=Math.abs(nums[i]);\\n            if(val>n)continue;\\n            \\n            if(nums[val-1]>0)\\n             nums[val-1]=-nums[val-1];\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>0)return i+1;\\n        }\\n        \\n        return n+1;\\n        \\n    }\\n}\\n-------------------------------------------------------------------\\n![image](https://assets.leetcode.com/users/images/d0c2c8ad-0b3c-46eb-94f0-75caf904b4c4_1663623875.2498913.png)\\n-------------------------------------------------------------------\\nApproach Explaination :- \\n-----------------\\n1. Assign all the values which is less than 1 and greater than n as n+1\\n2. Now iterate value one by one and mark the value as negative . Negative means value exist in array.\\n3. After completion of previous step iterate array again .\\n4. Now check for positive value  ! if you find any return index+1 . else return n+1\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution \\n{\\npublic int firstMissingPositive(int[] nums)\\n{\\n      int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<=0 || nums[i]>n)\\n            { \\n              nums[i]=n+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1641066,
                "title": "c-logical-solution-without-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n        \\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[nums[i]-1])\\n            {\\n                swap(nums[i],nums[nums[i]-1]);\\n            }\\n            \\n        }\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]!=i+1)\\n            {\\n                return i+1;\\n            }\\n        }\\n        \\n        return n+1;\\n        \\n    }\\n};\\n\\n\\n// please upvote if found helpful",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n        \\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[nums[i]-1])\\n            {\\n                swap(nums[i],nums[nums[i]-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1326347,
                "title": "6-lines-solution-c-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int i;\\n        for (i = 0; i < nums.size(); i++)\\n            if (nums[i] <= 0) nums[i] = 1000000;\\n\\t\\t\\t\\n        for (i = 0; i < nums.size(); i++)\\n            if (abs(nums[i]) - 1 < nums.size())\\n                nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1]);\\n\\t\\t\\t\\t\\n        for (i = 0; i < nums.size(); i++) if (nums[i] > 0) break;\\n        return i + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int i;\\n        for (i = 0; i < nums.size(); i++)\\n            if (nums[i] <= 0) nums[i] = 1000000;\\n\\t\\t\\t\\n        for (i = 0; i < nums.size(); i++)\\n            if (abs(nums[i]) - 1 < nums.size())\\n                nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1]);\\n\\t\\t\\t\\t\\n        for (i = 0; i < nums.size(); i++) if (nums[i] > 0) break;\\n        return i + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764421,
                "title": "c-o-1-space-o-n-time-with-explanation",
                "content": "For an array size of ```N```, we have that the first missing positive is between ```0``` and ```N+1```. This may take some time to think about but the best case is you have all the positive integers from ```0``` to ```N```, in which case the answer is ```N+1```. If you change any one of those values to something greater than ```N``` or less than ```0```, then the answer will be between ```0``` and ```N+1```. So this property holds.\\n\\nWe can abuse this property. Any number less than ```0``` and greater than ```N+1``` will not be inside this range. So we can iterate through and change these values to ```N+1``` (to keep it simple, but they need to be set to something that is at least ```N+1``` or bigger) since they are useless to us.\\n\\nThe next step is to iterate through the array again and use a simple hack: treat the numbers as indicies. We index the array using this value and we make the indexed value negative to \"tick\" it off. We need to remember to take the absoloute value every time we calculate the index because we are using the array for two purposes: to keep track which ones we tick off, and which ones we need to tick off still. This may be a little unintitive so here is how I thought about it (using an extrra array for visual purposes only):\\n\\nStarting array: ```[-5, 2, 3, 5, 1, 8]```\\nTicked off (```#``` is none, ```-``` is ticked): ```[#,#,#,#,#,#]```\\n\\nAfter setting to ```N+1```: ```[7, 2, 3, 5, 1, 7]```\\nTicked off: ```[#,#,#,#,#,#]```\\n\\nWe index ```nums[abs(7-1)]``` which is invalid. So we have\\nArray: ```[7, 2, 3, 5, 1, 7]```\\nTicked off: ```[#,#,#,#,#,#]```\\n\\n\\nWe index ```nums[abs(2)-1]``` which is ```2```. So we have\\nArray: ```[7, -2, 3, 5, 1, 7]```\\nTicked off: ```[#,-,#,#,#,#]```\\n\\nWe index ```nums[abs(3)-1]``` which is ```3```. So we have\\nArray: ```[7, -2, -3, 5, 1, 7]```\\nTicked off: ```[#,-,-,#,#,#]```\\n\\nWe index ```nums[abs(5)-1]``` which is ```1```. So we have\\nArray: ```[7, -2, -3, 5, -1, 7]```\\nTicked off: ```[#,-,-,#,-,#]```\\n\\nWe index ```nums[abs(-1)-1]``` which is ```7```. So we have\\nArray: ```[-7, -2, -3, 5, -1, 7]```\\nTicked off: ```[-,-,-,#,-,#]```\\n\\nWe index ```nums[abs(7)-1]``` which is not valid. So we have\\nArray: ```[-7, -2, -3, 5, 1, 7]```\\nTicked off: ```[-,-,-,#,-,#]```\\n\\nWe can see from the example that the ticked array matches the signs in the original array.\\n\\nWe finally iterate through the array (the index of the array starts at ```1``` for this problem) and return the first index that has a positive number. This will be the first number that has not been ticked off yet. So in the example, we would return ```4``` as ```nums[4]=5``` is not ticked off.\\n\\nHere is the code for reference:\\n\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int negatives = nums.size()-1;\\n        \\n        // change all negative numbers and numbers bigger than N \\n\\t\\t// (the amount of elements in the list)\\n        for (int i = nums.size()-1; i >= 0; i--){\\n            if (nums[i] <= 0 || nums[i] > nums.size()){\\n                nums[i] = nums.size()+1;\\n            }\\n        }\\n        \\n        int min = 1;\\n        \\n        // use nums[i] as the index and mark them off\\n        for (int i =0; i < nums.size(); i++){\\n            int index = abs(nums[i])-1;\\n            \\n            // check to see if it\\'s within the bounds and indexable\\n\\t\\t\\t// and check to not tick off the same value twice\\n            if ((index < nums.size() && index >= 0) && nums[index] > 0){\\n                nums[index] = -nums[index];\\n            }\\n        }\\n        \\n        // first positive value not ticked off \\n        for (min = 0; min < nums.size(); min++){\\n            if (nums[min] > 0){\\n                break;\\n            }\\n        }\\n        return min+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```N```\n```0```\n```N+1```\n```0```\n```N```\n```N+1```\n```N```\n```0```\n```0```\n```N+1```\n```0```\n```N+1```\n```N+1```\n```N+1```\n```[-5, 2, 3, 5, 1, 8]```\n```#```\n```-```\n```[#,#,#,#,#,#]```\n```N+1```\n```[7, 2, 3, 5, 1, 7]```\n```[#,#,#,#,#,#]```\n```nums[abs(7-1)]```\n```[7, 2, 3, 5, 1, 7]```\n```[#,#,#,#,#,#]```\n```nums[abs(2)-1]```\n```2```\n```[7, -2, 3, 5, 1, 7]```\n```[#,-,#,#,#,#]```\n```nums[abs(3)-1]```\n```3```\n```[7, -2, -3, 5, 1, 7]```\n```[#,-,-,#,#,#]```\n```nums[abs(5)-1]```\n```1```\n```[7, -2, -3, 5, -1, 7]```\n```[#,-,-,#,-,#]```\n```nums[abs(-1)-1]```\n```7```\n```[-7, -2, -3, 5, -1, 7]```\n```[-,-,-,#,-,#]```\n```nums[abs(7)-1]```\n```[-7, -2, -3, 5, 1, 7]```\n```[-,-,-,#,-,#]```\n```1```\n```4```\n```nums[4]=5```\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int negatives = nums.size()-1;\\n        \\n        // change all negative numbers and numbers bigger than N \\n\\t\\t// (the amount of elements in the list)\\n        for (int i = nums.size()-1; i >= 0; i--){\\n            if (nums[i] <= 0 || nums[i] > nums.size()){\\n                nums[i] = nums.size()+1;\\n            }\\n        }\\n        \\n        int min = 1;\\n        \\n        // use nums[i] as the index and mark them off\\n        for (int i =0; i < nums.size(); i++){\\n            int index = abs(nums[i])-1;\\n            \\n            // check to see if it\\'s within the bounds and indexable\\n\\t\\t\\t// and check to not tick off the same value twice\\n            if ((index < nums.size() && index >= 0) && nums[index] > 0){\\n                nums[index] = -nums[index];\\n            }\\n        }\\n        \\n        // first positive value not ticked off \\n        for (min = 0; min < nums.size(); min++){\\n            if (nums[min] > 0){\\n                break;\\n            }\\n        }\\n        return min+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746638,
                "title": "o-n-time-o-1-space-0ms-solution-beats-100",
                "content": "```\\n    int firstMissingPositive(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0 && nums[i]<=nums.size() && nums[i]!=nums[nums[i]-1])\\n            {\\n                swap(nums[i],nums[nums[i]-1]);\\n                i--;\\n            }\\n        }\\n        int ans=-1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=i+1)\\n            {\\n                ans=i+1;\\n                break;\\n            }\\n        }\\n        if(ans==-1)\\n        {\\n            ans=nums.size()+1;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    int firstMissingPositive(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0 && nums[i]<=nums.size() && nums[i]!=nums[nums[i]-1])\\n            {\\n                swap(nums[i],nums[nums[i]-1]);\\n                i--;\\n            }\\n        }\\n        int ans=-1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=i+1)\\n            {\\n                ans=i+1;\\n                break;\\n            }\\n        }\\n        if(ans==-1)\\n        {\\n            ans=nums.size()+1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 566511,
                "title": "simple-python-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        #Sorting positive numbers according to their space E.g [1,2,3,4]\\n        index = 0\\n        while index < len(nums):\\n            # Already in the place\\n            if index + 1 == nums[index]:    \\n                index += 1\\n            # No-use\\n            elif nums[index] <= 0:       \\n                  index += 1\\n            # No-use\\n            elif nums[index] > len(nums):  \\n                   index += 1\\n            # Already swapped\\n            elif nums[index] == nums[nums[index]-1]:\\n                index += 1\\n            else:\\n                A,B = index,nums[index]-1\\n                nums[A], nums[B] = nums[B], nums[A]\\n                \\n        #Smallest no which does not follow the true space\\n        for index in range(len(nums)):\\n            if index + 1 != nums[index]:   \\n                return index + 1\\n        # Otherwise, return the next positive number\\n        return len(nums) + 1\\n```\\n\\nNOTE : Improvements and comments are welcomed.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        #Sorting positive numbers according to their space E.g [1,2,3,4]\\n        index = 0\\n        while index < len(nums):\\n            # Already in the place\\n            if index + 1 == nums[index]:    \\n                index += 1\\n            # No-use\\n            elif nums[index] <= 0:       \\n                  index += 1\\n            # No-use\\n            elif nums[index] > len(nums):  \\n                   index += 1\\n            # Already swapped\\n            elif nums[index] == nums[nums[index]-1]:\\n                index += 1\\n            else:\\n                A,B = index,nums[index]-1\\n                nums[A], nums[B] = nums[B], nums[A]\\n                \\n        #Smallest no which does not follow the true space\\n        for index in range(len(nums)):\\n            if index + 1 != nums[index]:   \\n                return index + 1\\n        # Otherwise, return the next positive number\\n        return len(nums) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271306,
                "title": "java-0ms-solution",
                "content": "The idea is simple: put the positive integer ```n``` (```n > 0``` and ```n <= array.length```) at index ```n - 1```.  Then traverse the array, if ```nums[index] != index + 1```, then we find the first miss positive number. \\n```\\npublic int firstMissingPositive(int[] nums) {\\n\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\twhile( nums[i] > 0 && nums[i] <= nums.length ) {\\n\\t\\t\\tint temp = nums[nums[i] - 1];\\n\\t\\t\\tif( temp == nums[i] ) // If nums[nums[i] - 1] equals nums[i], then we don\\'t need to exchange them\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tnums[nums[i] - 1] = nums[i];\\n\\t\\t\\tnums[i] = temp;\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < nums.length; i++) \\n\\t\\tif( nums[i] != i + 1 )\\n\\t\\t\\treturn i + 1;\\n\\treturn nums.length + 1;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```n```\n```n > 0```\n```n <= array.length```\n```n - 1```\n```nums[index] != index + 1```\n```\\npublic int firstMissingPositive(int[] nums) {\\n\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\twhile( nums[i] > 0 && nums[i] <= nums.length ) {\\n\\t\\t\\tint temp = nums[nums[i] - 1];\\n\\t\\t\\tif( temp == nums[i] ) // If nums[nums[i] - 1] equals nums[i], then we don\\'t need to exchange them\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tnums[nums[i] - 1] = nums[i];\\n\\t\\t\\tnums[i] = temp;\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < nums.length; i++) \\n\\t\\tif( nums[i] != i + 1 )\\n\\t\\t\\treturn i + 1;\\n\\treturn nums.length + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17208,
                "title": "c-solution-no-extra-memory-using-pseudo-sort",
                "content": " The answer is between 1 and n, where n is the size of the vector and the trick is that you have to \"pseudo sort\", what I mean with that? Well, if the number nums[i] is between 1 and n you have to put it in the correct position swapping it with the number nums[nums[i]] if they are different.\\n  For example: [1,2,0] ->[1,2,0];\\n                        [3,4,-1,1] ->[1,-1,3,4];\\n                        [0,10,1,3,6,4]->[1,10,3,4,0,6].\\n You can do this in O(n), than it's easy to find the solution\\n\\n    int firstMissingPositive(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint p = 0;\\n\\tint expected = 1;\\n\\n\\t//pseudo sort\\n\\twhile (p < n) {\\n\\t\\tint pPos;\\n\\t\\tint aux;\\n\\t\\t\\n\\t\\tif (nums[p] > 0 && nums[p] <= n) {\\n\\t\\t\\tpPos = nums[p] - 1;\\n\\t\\t\\tif (nums[pPos] != nums[p]) {\\n\\t\\t\\t\\taux = nums[p];\\n\\t\\t\\t\\tnums[p] = nums[pPos];\\n\\t\\t\\t\\tnums[pPos] = aux;\\n\\t\\t\\t\\tp--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tp++;\\n\\t}\\n\\n\\t//Finding the answer\\n\\tfor (size_t i = 0; i < n && nums[i] == expected; i++, expected++);\\n\\n\\treturn expected;\\n}",
                "solutionTags": [],
                "code": " The answer is between 1 and n, where n is the size of the vector and the trick is that you have to \"pseudo sort\", what I mean with that? Well, if the number nums[i] is between 1 and n you have to put it in the correct position swapping it with the number nums[nums[i]] if they are different.\\n  For example: [1,2,0] ->[1,2,0];\\n                        [3,4,-1,1] ->[1,-1,3,4];\\n                        [0,10,1,3,6,4]->[1,10,3,4,0,6].\\n You can do this in O(n), than it's easy to find the solution\\n\\n    int firstMissingPositive(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint p = 0;\\n\\tint expected = 1;\\n\\n\\t//pseudo sort\\n\\twhile (p < n) {\\n\\t\\tint pPos;\\n\\t\\tint aux;\\n\\t\\t\\n\\t\\tif (nums[p] > 0 && nums[p] <= n) {\\n\\t\\t\\tpPos = nums[p] - 1;\\n\\t\\t\\tif (nums[pPos] != nums[p]) {\\n\\t\\t\\t\\taux = nums[p];\\n\\t\\t\\t\\tnums[p] = nums[pPos];\\n\\t\\t\\t\\tnums[pPos] = aux;\\n\\t\\t\\t\\tp--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tp++;\\n\\t}\\n\\n\\t//Finding the answer\\n\\tfor (size_t i = 0; i < n && nums[i] == expected; i++, expected++);\\n\\n\\treturn expected;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 17313,
                "title": "a-hashmap-based-solution-but-in-place",
                "content": "A[] is an array, but we can also treat it as an hashmap,\\nIf A[i] > 0, it mean i+1 exist,\\nIf A[i] < 0,  it mean i + 1 does not.\\nHere is the code\\n\\n    class Solution {\\n    public:\\n        int firstMissingPositive(int A[], int n) {\\n            /* first iteration: change all the value out of bound to (n + 1) */\\n        \\tconst int out_of_bound = n + 1;\\n        \\tfor (int i = 0; i < n; ++i)\\n        \\t\\tif (A[i] <= 0)\\n        \\t\\t\\tA[i] = out_of_bound;\\n    \\n    \\t\\t/* second iteration: construct a hash map. map<int, int>, first argument is index\\n    \\t\\t * second argument: if positive, it exist, else, it doesn't. e.g. A[0] = 4,\\n    \\t\\t * A[0] (i.e. 1) exist */\\n    \\t \\tfor (int i = 0; i < n; ++i) {\\n    \\t \\t\\tint abs_i = abs(A[i]);\\n    \\t \\t\\tif (abs_i <= n)\\n    \\t \\t\\t\\tA[abs_i-1] = -abs(A[abs_i-1]);\\n    \\t \\t}\\n    \\n    \\t \\t/* third iteration: check the first positive value in A[] */\\n    \\t \\tfor (int i = 0; i < n; ++i) {\\n    \\t \\t\\tif (A[i] > 0)\\n    \\t \\t\\t\\treturn i + 1; \\n    \\t \\t}\\n    \\t \\treturn n + 1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int firstMissingPositive(int A[], int n) {\\n            /* first iteration: change all the value out of bound to (n + 1) */\\n        \\tconst int out_of_bound = n + 1;\\n        \\tfor (int i = 0; i < n; ++i)\\n        \\t\\tif (A[i] <= 0)\\n        \\t\\t\\tA[i] = out_of_bound;\\n    \\n    \\t\\t/* second iteration: construct a hash map. map<int, int>, first argument is index\\n    \\t\\t * second argument: if positive, it exist, else, it doesn't. e.g. A[0] = 4,\\n    \\t\\t * A[0] (i.e. 1) exist */\\n    \\t \\tfor (int i = 0; i < n; ++i) {\\n    \\t \\t\\tint abs_i = abs(A[i]);\\n    \\t \\t\\tif (abs_i <= n)\\n    \\t \\t\\t\\tA[abs_i-1] = -abs(A[abs_i-1]);\\n    \\t \\t}",
                "codeTag": "Java"
            },
            {
                "id": 17319,
                "title": "python-solution-with-bit-manipulation",
                "content": "One pass of the list, but still O(2n)\\n\\n    def firstMissingPositive(self, A):\\n        num = 0\\n        for i in A:\\n            if i > 0:\\n                num = num | (1 << i)\\n        x = 1\\n        while True:\\n            if (1 << x) & num == 0:\\n                return x\\n            x += 1\\n\\nUpdate: not sure why the down votes, Python int converts to long(which has no precision limits) automatically, which means no overflow for `num`.",
                "solutionTags": [
                    "Python"
                ],
                "code": "One pass of the list, but still O(2n)\\n\\n    def firstMissingPositive(self, A):\\n        num = 0\\n        for i in A:\\n            if i > 0:\\n                num = num | (1 << i)\\n        x = 1\\n        while True:\\n            if (1 << x) & num == 0:\\n                return x\\n            x += 1\\n\\nUpdate: not sure why the down votes, Python int converts to long(which has no precision limits) automatically, which means no overflow for `num`.",
                "codeTag": "Python3"
            },
            {
                "id": 17140,
                "title": "c-and-python-modify-the-array-to-do-it-in-o-n-time-and-o-1-space",
                "content": "If there are queries after each insert operation, [disjoint-set][1] is able to answer each query in `O(log(alpha(n)))` time and `O(max(element in the array))` space,  but for this problem, only one query after all the insertion finished,  the time complexity should be `O(n)` and `O(1)` space, some simple method is in need.\\n\\nEven though it is not a good idea to modify the value of the origin array, this is the only space that is available, which means it must be made used of.  Then if it is possible to sort the element which is between `1...n`, then just loop over the sorted array, the job is done.\\n\\nComparison  sort is `O(n logn)`, it is too slow. So the `bucket sort` is the only way. As only the elements between 1...n are useful, each element `w` should be put into the `w th` position of the array. As it is possible there is some other element `v` in the `w th` position, take the `v` out before overwriting and then iteratively use the same logic on `v` and go on.\\n\\n    def firstMissingPositive(self, A):\\n      n = len(A)\\n      for index in xrange(n):\\n        element = A[index]\\n        while True:\\n          if element <= 0 or element > n or element == A[element - 1]:\\n            break\\n          A[element - 1], element = element, A[element - 1]\\n      for index in xrange(n):\\n        if A[index] != index + 1:\\n          return index + 1\\n      return n + 1\\n\\nTime complexity:  each element is looped 2 times and swapped 1 time, so the whole time compexity is `O(n)`\\n\\nSpace: `O(1)` apparently\\n\\n---\\n\\nA pure recursive `C` solution, which has the same time and space complexity.\\n\\n    void rotate(int A[], int n, int start){\\n      if(start <= 0 || start > n){\\n        return;\\n      }\\n      if(A[start - 1] == start){\\n        return;\\n      }\\n      int nxt = A[start - 1];\\n      A[start - 1] = start;\\n      rotate(A, n, nxt);\\n    }\\n    \\n    int firstMissingPositive(int A[], int n) {\\n      int i;\\n      for(i = 0; i < n; ++i){\\n        rotate(A, n, A[i]);\\n      }\\n      for(i = 0; i < n; ++i){\\n        if(A[i] != i + 1){\\n          return i + 1;\\n        }\\n      }\\n      return n + 1;\\n    }\\n\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Disjoint-set_data_structure",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "If there are queries after each insert operation, [disjoint-set][1] is able to answer each query in `O(log(alpha(n)))` time and `O(max(element in the array))` space,  but for this problem, only one query after all the insertion finished,  the time complexity should be `O(n)` and `O(1)` space, some simple method is in need.\\n\\nEven though it is not a good idea to modify the value of the origin array, this is the only space that is available, which means it must be made used of.  Then if it is possible to sort the element which is between `1...n`, then just loop over the sorted array, the job is done.\\n\\nComparison  sort is `O(n logn)`, it is too slow. So the `bucket sort` is the only way. As only the elements between 1...n are useful, each element `w` should be put into the `w th` position of the array. As it is possible there is some other element `v` in the `w th` position, take the `v` out before overwriting and then iteratively use the same logic on `v` and go on.\\n\\n    def firstMissingPositive(self, A):\\n      n = len(A)\\n      for index in xrange(n):\\n        element = A[index]\\n        while True:\\n          if element <= 0 or element > n or element == A[element - 1]:\\n            break\\n          A[element - 1], element = element, A[element - 1]\\n      for index in xrange(n):\\n        if A[index] != index + 1:\\n          return index + 1\\n      return n + 1\\n\\nTime complexity:  each element is looped 2 times and swapped 1 time, so the whole time compexity is `O(n)`\\n\\nSpace: `O(1)` apparently\\n\\n---\\n\\nA pure recursive `C` solution, which has the same time and space complexity.\\n\\n    void rotate(int A[], int n, int start){\\n      if(start <= 0 || start > n){\\n        return;\\n      }\\n      if(A[start - 1] == start){\\n        return;\\n      }\\n      int nxt = A[start - 1];\\n      A[start - 1] = start;\\n      rotate(A, n, nxt);\\n    }\\n    \\n    int firstMissingPositive(int A[], int n) {\\n      int i;\\n      for(i = 0; i < n; ++i){\\n        rotate(A, n, A[i]);\\n      }\\n      for(i = 0; i < n; ++i){\\n        if(A[i] != i + 1){\\n          return i + 1;\\n        }\\n      }\\n      return n + 1;\\n    }\\n\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Disjoint-set_data_structure",
                "codeTag": "Python3"
            },
            {
                "id": 2931346,
                "title": "simple-optimized-solution-in-o-1-space",
                "content": "# Approach\\nSteps:\\n1.remove all the elements having zero or negative value.\\n2.sort the new array and remove all the duplicates.\\n3.now, array has all the element are unique +ve & in increasing order.\\n4.run the loop & check the condition v[i]==i+1,if this fails,answer is i+1,return it.otherwise answer will be v.size()+1.\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& v) {\\n        //erase all the elements having negative and zero value.\\n       for(int i=0;i<v.size();i++){\\n           if(v[i]<=0){\\n               v.erase(v.begin()+i);\\n               i--;\\n           }\\n       }\\n       sort(v.begin(),v.end()); //sort the array.\\n       //Now,remove all duplicates.This approach works in O(n) time\\n       for(int i=0;i<v.size();i++){\\n            int com=v[i];\\n            int freq=0;\\n            while(i<v.size() && v[i]==com){\\n                freq++;\\n                if(freq>1){\\n                 v.erase(v.begin()+i);\\n                 i--;\\n                }\\n                i++;\\n            }\\n            i--;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]!=i+1){\\n                return i+1;\\n            }\\n        }\\n        int ans=v.size()+1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& v) {\\n        //erase all the elements having negative and zero value.\\n       for(int i=0;i<v.size();i++){\\n           if(v[i]<=0){\\n               v.erase(v.begin()+i);\\n               i--;\\n           }\\n       }\\n       sort(v.begin(),v.end()); //sort the array.\\n       //Now,remove all duplicates.This approach works in O(n) time\\n       for(int i=0;i<v.size();i++){\\n            int com=v[i];\\n            int freq=0;\\n            while(i<v.size() && v[i]==com){\\n                freq++;\\n                if(freq>1){\\n                 v.erase(v.begin()+i);\\n                 i--;\\n                }\\n                i++;\\n            }\\n            i--;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]!=i+1){\\n                return i+1;\\n            }\\n        }\\n        int ans=v.size()+1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924456,
                "title": "easy-c-solution",
                "content": "# Intuition\\nBrute Force Approach\\n\\n# Approach\\nStep 1: Sort the vector.\\nStep 2: Take the last element as max. Check if its negative, if it is negative, then return 1 as answer.\\nStep 3: Start a loop from 1 to max.\\nStep 4: Find the element in the vector using binary search and if not found return it.\\nStep 5: Repeat the process till we reach the end of vector.\\nStep 6: If we reach the end that means anything isn\\'t returned so now return max+1 (according to problem statement & examples).\\n\\n# Complexity\\n- Time complexity:\\nO(n logn)\\n\\n- Space complexity:\\nO(log n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int m = nums[nums.size()-1];\\n        if(m <= 0){\\n            return 1;\\n        }\\n        int s, e, mid;\\n        bool found;\\n        for(int key = 1; key < m; key++){\\n            s = 0, e = nums.size()-1;\\n            found = 0;\\n            while(s <= e){\\n                mid = s + (e - s)/2;\\n                if(nums[mid] == key){\\n                    found = 1;\\n                    break;\\n                }\\n                else if(nums[mid] > key){\\n                    e = mid-1;\\n                }\\n                else{\\n                    s = mid+1;\\n                }\\n            }\\n            if(!found){\\n                return key;\\n            }\\n        }\\n        return m+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Divide and Conquer",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int m = nums[nums.size()-1];\\n        if(m <= 0){\\n            return 1;\\n        }\\n        int s, e, mid;\\n        bool found;\\n        for(int key = 1; key < m; key++){\\n            s = 0, e = nums.size()-1;\\n            found = 0;\\n            while(s <= e){\\n                mid = s + (e - s)/2;\\n                if(nums[mid] == key){\\n                    found = 1;\\n                    break;\\n                }\\n                else if(nums[mid] > key){\\n                    e = mid-1;\\n                }\\n                else{\\n                    s = mid+1;\\n                }\\n            }\\n            if(!found){\\n                return key;\\n            }\\n        }\\n        return m+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670716,
                "title": "easiest-way-to-solve",
                "content": "class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        arr = set(nums)\\n        data=(i for i in range(1,len(arr)+2) if i not in arr)\\n        return min(data)\\n\\t**upvote if u found it useful**",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        arr = set(nums)\\n        data=(i for i in range(1,len(arr)+2) if i not in arr)\\n        return min(data)\\n\\t**upvote if u found it useful**",
                "codeTag": "Java"
            },
            {
                "id": 2576238,
                "title": "python-easy-solution",
                "content": "```\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n        nums = sorted(list(set(nums)))\\n        i = 1\\n        for num in nums:\\n            if num == i:\\n                i += 1\\n            elif num > 0:\\n                return i\\n        return i\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n        nums = sorted(list(set(nums)))\\n        i = 1\\n        for num in nums:\\n            if num == i:\\n                i += 1\\n            elif num > 0:\\n                return i\\n        return i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2083669,
                "title": "simple-hashmap-solution-o-n",
                "content": "Simple Solution using HashMap.\\n\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            map.put(nums[i], nums[i]);\\n        }\\n        int i;\\n        for (i = 1; i <= nums.length; i++) {\\n            if (!map.containsKey(i)) {\\n                return i;\\n            }\\n        }\\n        return i;\\n    }\\n}```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            map.put(nums[i], nums[i]);\\n        }\\n        int i;\\n        for (i = 1; i <= nums.length; i++) {\\n            if (!map.containsKey(i)) {\\n                return i;\\n            }\\n        }\\n        return i;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1866566,
                "title": "c-easy-and-understandable-approach-with-linear-time-and-constant-space",
                "content": "```\\nint firstMissingPositive(vector<int>& nums) {\\n        //case 1 : manage 1 and those who are out of bound;\\n        bool One = false;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 1) One = true;\\n            if(nums[i]>nums.size() or nums[i]<1){\\n                nums[i] = 1;\\n            }\\n        }\\n        if(One == false) return 1;\\n        \\n        //case 2 : map element with index\\n        for(int i=0;i<nums.size();i++){\\n            int idx = abs(nums[i]);\\n            nums[idx - 1] = -abs(nums[idx - 1]);\\n        }\\n        \\n        //case 3 : find positive number\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] > 0) return i+1;\\n        }\\n        return nums.size()+1;\\n    }\\n```\\n**Guys if you got the concept then please give one upvote for me.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint firstMissingPositive(vector<int>& nums) {\\n        //case 1 : manage 1 and those who are out of bound;\\n        bool One = false;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 1) One = true;\\n            if(nums[i]>nums.size() or nums[i]<1){\\n                nums[i] = 1;\\n            }\\n        }\\n        if(One == false) return 1;\\n        \\n        //case 2 : map element with index\\n        for(int i=0;i<nums.size();i++){\\n            int idx = abs(nums[i]);\\n            nums[idx - 1] = -abs(nums[idx - 1]);\\n        }\\n        \\n        //case 3 : find positive number\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] > 0) return i+1;\\n        }\\n        return nums.size()+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008481,
                "title": "java-100-fast-simple-and-easy",
                "content": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        for(int i = 0; i < nums.length;) {\\n            int curr = nums[i];\\n            //in place sorting 1 based index ignoring out of range numbers including 0\\n\\t\\t\\tif(curr > 0 && curr < nums.length && curr != nums[curr-1]) \\n                swap(nums, i, curr-1);\\n            else\\n                i++;\\n        }\\n        //check if the number on index i is equal to i + 1 (1 based idxs) if not we have our number\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] != i + 1) {\\n                return i + 1;\\n            }\\n        }\\n\\t\\t//if the whole array have the correct numbers the next number is the last pos (nums.length) + 1\\n        return nums.length + 1;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        for(int i = 0; i < nums.length;) {\\n            int curr = nums[i];\\n            //in place sorting 1 based index ignoring out of range numbers including 0\\n\\t\\t\\tif(curr > 0 && curr < nums.length && curr != nums[curr-1]) \\n                swap(nums, i, curr-1);\\n            else\\n                i++;\\n        }\\n        //check if the number on index i is equal to i + 1 (1 based idxs) if not we have our number\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] != i + 1) {\\n                return i + 1;\\n            }\\n        }\\n\\t\\t//if the whole array have the correct numbers the next number is the last pos (nums.length) + 1\\n        return nums.length + 1;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360518,
                "title": "my-cpp-solution-o-n-time-o-1-space-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int len = nums.size();\\n        int i = 0;\\n        int j = len-1;\\n        while(i<=j){\\n            if(nums[i]==i+1){\\n                ++i;\\n                continue;\\n            }\\n            // nums[i] looks for pos nums[i]-1\\n            else if(nums[i]>0 && nums[i]-1<=j && nums[nums[i]-1]!=nums[i]){\\n                swap(nums[nums[i]-1],nums[i]);\\n            }\\n\\t\\t\\t// put it at end of array as a \"junk\"\\n            else{\\n                swap(nums[j--],nums[i]);\\n            }\\n        }\\n        if(i==0){\\n            return 1;\\n        }\\n        else{\\n            return nums[i-1]+1;\\n        }\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/jellyzhang/image_1566046353.png)\\nFirst of all ,we know that , if nums looks like [1,2,3,4...] ,then num[i] should be at **pos** nums[i]-1.\\nnow we have 6 at pos i , which should be at pos 5.\\nHere is what we gonna do:\\n\\twe check if his **pos-to-put** is avavilable.\\n\\tsince pos 5 is an available pos , we swap them.\\n![image](https://assets.leetcode.com/users/jellyzhang/image_1566046685.png)\\nnow we have -1 at pos i ,which should be at pos -2.\\nof course pos -2 is not available.\\nso we put it at **junk area** by swapping with pos j. (then j--);\\n![image](https://assets.leetcode.com/users/jellyzhang/image_1566046869.png)\\nthen we facing 20 now...\\nif we cant find a 5 for pos i ,then it will keep looping ,until j hits i.So TIme complexity is O(n).\\n(also ,if **pos-to-put** is already has his number, then nums[i] is regard as junk too,cause we dont need a number twice.)\\nand we dont have to go over the nums again to find the first missing spot. cause where i hit j is what we need.\\n\\nsorry for my bad painting.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int len = nums.size();\\n        int i = 0;\\n        int j = len-1;\\n        while(i<=j){\\n            if(nums[i]==i+1){\\n                ++i;\\n                continue;\\n            }\\n            // nums[i] looks for pos nums[i]-1\\n            else if(nums[i]>0 && nums[i]-1<=j && nums[nums[i]-1]!=nums[i]){\\n                swap(nums[nums[i]-1],nums[i]);\\n            }\\n\\t\\t\\t// put it at end of array as a \"junk\"\\n            else{\\n                swap(nums[j--],nums[i]);\\n            }\\n        }\\n        if(i==0){\\n            return 1;\\n        }\\n        else{\\n            return nums[i-1]+1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202584,
                "title": "javascript-52ms-beats-100-supposedly",
                "content": "Solving this in O(n) time was tricky, but solving it in O(1) space was arguably more difficult.\\n\\n**Constraints:**\\n1. Can\\'t use an object to store values because that would no longer be constant extra space (as the size of the object would be dependent on the number of values in the array).\\n2.   For the same reason, we can\\'t iniitalize another array.\\n\\n**Possible Scenarios:**\\n1: Array has negative and/or positive values but does not contain the integer 1.  In that case, result would be 1.\\n2: Array contains the integer 1 and has one or more missing integers within the array.  In that case, we need to be able to tell where that gap is.\\n3: Array contains only positive integers and contains 1 through the length of the array.  In that case, result would be array length + 1.\\n\\n**Observations:**\\n1. If there are no gaps, the largest value for an integer in the array is the length of the array.\\n2. That means that we don\\'t care about any values that are greater than the length of the array (because they wouldn\\'t affect the calculation of what the smallest integer missing would be as their inclusion would ensure a gap elsewhere)\\n3. If the lowest value we care about is 1 and the largest value we care about is the length of the array, we can iterate through the array and swap the value at the current index to the index of the value - 1 in order to track whether or not a given value exists in the array.  That is, given an array [3, 2, 1], swapping 3 with 1, not incrementing the iterator so that you are still looking at the array at index 0, seeing that 1 is in place, incrementing the index, seeing that 2 is in place, incrementing the index, and seeing that 3 is in place.  We would then loop through the array a second time in order to find the lowest value that isn\\'t at the index of its value - 1.\\n\\n**Big O Analysis:**\\nThis function goes through the array, swapping the value at the current index with the value at the index of one less than the value.  If the value is less than 0 or greater than the length of the array, the value at that index gets set to 0 to make it easier on the eyes during debugging of edge cases.\\n\\nWhile it\\'s employing a for loop and a while loop in the first pass, it\\'s not nested in the sense that two counters are going as it\\'s utilizing the same counter for both, so I believe that portion is still O(n), and tacking on the for loop at the end to determine whether or not an integer is present in the array wouldn\\'t be significant enough to affect the time complexity.\\n\\nAs we\\'re utilizing the original array and just changing pointer values and not actually moving the array in any way, this should still be O(1) space complexity.\\n\\n```\\nvar firstMissingPositive = function (nums) {\\n  let current;\\n  let indexForCurrent;\\n   for (let i = 0; i < nums.length;) {\\n    if (nums[i] < 0) {\\n      nums[i] = 0;\\n      i++;\\n    } else if (nums[i] > nums.length){\\n      i++;\\n    }\\n      current = nums[i];     \\n      indexForCurrent = current - 1\\n      while (nums[i] != nums[indexForCurrent]) {\\n        if (current > 0 && current <= nums.length) {\\n          let next = nums[indexForCurrent];\\n          nums[indexForCurrent] = current;\\n          nums[i] = next;\\n          current = nums[i];\\n          indexForCurrent = current - 1;\\n        } else {\\n          nums[i] = 0;\\n          i++;\\n          current = nums[i];\\n          indexForCurrent = current - 1;           \\n      }\\n    }\\n    i++;\\n  }\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] !== i + 1) {\\n      return i + 1;\\n    }\\n  }\\n  return nums.length + 1\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar firstMissingPositive = function (nums) {\\n  let current;\\n  let indexForCurrent;\\n   for (let i = 0; i < nums.length;) {\\n    if (nums[i] < 0) {\\n      nums[i] = 0;\\n      i++;\\n    } else if (nums[i] > nums.length){\\n      i++;\\n    }\\n      current = nums[i];     \\n      indexForCurrent = current - 1\\n      while (nums[i] != nums[indexForCurrent]) {\\n        if (current > 0 && current <= nums.length) {\\n          let next = nums[indexForCurrent];\\n          nums[indexForCurrent] = current;\\n          nums[i] = next;\\n          current = nums[i];\\n          indexForCurrent = current - 1;\\n        } else {\\n          nums[i] = 0;\\n          i++;\\n          current = nums[i];\\n          indexForCurrent = current - 1;           \\n      }\\n    }\\n    i++;\\n  }\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] !== i + 1) {\\n      return i + 1;\\n    }\\n  }\\n  return nums.length + 1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17250,
                "title": "share-my-thoughts-4ms-soln",
                "content": "At beginning, I was thinking: \\n\\n 1. it requires O(n), means no sorting/binary searching. You should only go through the numbers then get the result.\\n 2. no extra memory, means you can not use bit vector to indicate if any number exists.\\n\\nSo, the first idea came into my mind is bit manipulation. But, after tried and thought it again, bit manipulation doesn't help here. Because the numbers can be duplicated. Re-visited the problem, I found one critical point: it's asking the smallest missing positive number. It means I can reorder the numbers to let the nums[0]=1, nums[1]=2... etc. Actually, I spent more than 30 minutes on bit manipulation direction. Once I found the solution, it only took about 10 minutes to code.\\n\\n    class Solution {\\n    public:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int size=nums.size();\\n        for(int i=0; i<size;){\\n            if(nums[i]>0 && nums[i]<=size && nums[i]!=nums[nums[i]-1]){\\n                swap(nums[i], nums[nums[i]-1]);\\n            }\\n            else{\\n                ++i;\\n            }\\n        }\\n        int i=0;\\n        for(; i<size && nums[i]==i+1; ++i);\\n        return i+1;\\n    }};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int size=nums.size();\\n        for(int i=0; i<size;){\\n            if(nums[i]>0 && nums[i]<=size && nums[i]!=nums[nums[i]-1]){\\n                swap(nums[i], nums[nums[i]-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 17339,
                "title": "as-o-n-solution-and-o-1-space-is-must-only-way-is-to-sort-array-in-o-n-time-with-optimal-space-and-time-overheads",
                "content": "It is certain that to get **O(n) time complexity** and to do in **constant space**  O(n) time complexity sorting technique need to be used, any of the following sorts counting sort, radix sort, bucket sort can be used. \\n\\nAs the input array can contain **negative integers**  counting sort may not be applied here as  we use keys as index in counting sort and it has memory overhead too, but when the input array has many **duplicates** then counting sort performs better it's good to discuss such trade offs with interviewer.\\n\\nRadix sort is a specific type of bucket sort, It starts with the top n-bit or n-digits and may sort those buckets using a radix sort until every entry is sorted. So if the elements in the input array are single digit integers in the **range [-9,9]** then essentially  radix sort and bucket sort are similar.\\n\\nBucket sort is the best sorting technique that might be used here because when the **input is uniformly** **distributed over a range**(here the elements of the input array are in range [-9,9]) bucket sort performs in O(n) time complexity and O(1) space complexity.\\n\\n**Counting sort** -- simple buckets, simple processing, memory overhead, performs well when input has many duplicates.\\n\\n**Radix sort** -- simple buckets, sophisticated processing, speed overhead (and still need additional static memory)\\n\\n**Bucket sort** -- sophisticated buckets, simple processing, requires dynamic memory, good in average compared to counting and radix sorts.\\n\\n\\n     class Solution {\\n        public:\\n            int firstMissingPositive(int A[], int n) {\\n                for (int i = 0; i < n; ++i)\\n                {\\n                    int digit = A[i];\\n                    while (digit <= n && digit > 0 && A[digit - 1] != digit)\\n                    {\\n                        swap(A[digit - 1], A[i]);\\n                        digit = A[i];\\n                    }\\n                }\\n                for (int i = 0; i < n; ++i)\\n                {\\n                    if (A[i] != i + 1)\\n                    {\\n                        return i + 1;\\n                    }\\n                }\\n                return n + 1;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int firstMissingPositive(int A[], int n) {\\n                for (int i = 0; i < n; ++i)\\n                {\\n                    int digit = A[i];\\n                    while (digit <= n && digit > 0 && A[digit - 1] != digit)\\n                    {\\n                        swap(A[digit - 1], A[i]);\\n                        digit = A[i];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3669832,
                "title": "easiest-c-code-highly-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& a) {\\n        unordered_map<int,int>map;\\n        int i,j,k,c=0;\\n\\n        for(auto x:a){\\n            if(x>0)\\n            map[x]++;\\n        }\\n\\n        for(i=1;i<a.size()+1;i++){\\n            if(map.find(i)==map.end())\\n            return i;\\n\\n        }\\n        return a.size()+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& a) {\\n        unordered_map<int,int>map;\\n        int i,j,k,c=0;\\n\\n        for(auto x:a){\\n            if(x>0)\\n            map[x]++;\\n        }\\n\\n        for(i=1;i<a.size()+1;i++){\\n            if(map.find(i)==map.end())\\n            return i;\\n\\n        }\\n        return a.size()+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379018,
                "title": "time-o-n-space-o-1-using-cycle-sort-beats-99-96",
                "content": "# Intuition\\ncorrect position for each positive element should be its index+1\\n\\n# Approach\\nRun a simple cycle sort by putting elements in there correct position(i.e. index+1).\\nthen return the first element which is not in correct postion, if all are then length+1;\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int i=0;\\n        while(i<nums.length){\\n            int correct=nums[i]-1;\\n          //check if its positive,in range and not in correct position\\n            if(nums[i]>0 && nums[i]<=nums.length && nums[i]!=nums[correct]){\\n                int temp=nums[i];\\n                nums[i]=nums[correct];\\n                nums[correct]=temp;\\n            }else{\\n                i++;\\n            }\\n        }\\n\\n        for(int index=0;index<nums.length;index++){\\n            if(nums[index]!=index+1){\\n                return index+1;\\n            }\\n        }\\n        return nums.length+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int i=0;\\n        while(i<nums.length){\\n            int correct=nums[i]-1;\\n          //check if its positive,in range and not in correct position\\n            if(nums[i]>0 && nums[i]<=nums.length && nums[i]!=nums[correct]){\\n                int temp=nums[i];\\n                nums[i]=nums[correct];\\n                nums[correct]=temp;\\n            }else{\\n                i++;\\n            }\\n        }\\n\\n        for(int index=0;index<nums.length;index++){\\n            if(nums[index]!=index+1){\\n                return index+1;\\n            }\\n        }\\n        return nums.length+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243937,
                "title": "java-1ms-easy-solution-with-explaination",
                "content": "\\n\\n# Approach\\nThe solution first moves all positive integers to the front of the array by swapping them with non-positive integers. It then marks indices that correspond to positive integers by negating the value at that index. Finally, it checks for the first positive integer that is not marked and returns its index + 1. If all positive integers are marked, it returns the length of the array + 1.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n), where n is the length of the input array. \\n\\n- Space complexity:\\n The space complexity is O(1) because it modifies the input array in place. This solution is very efficient and should be able to handle very large input arrays.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n = nums.length;\\n        \\n        // Move all positive integers to the front of the array\\n        int j = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] > 0) {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n                j++;\\n            }\\n        }\\n        \\n        // Mark indices that correspond to positive integers\\n        for (int i = 0; i < j; i++) {\\n            int idx = Math.abs(nums[i]) - 1;\\n            if (idx < j && nums[idx] > 0) {\\n                nums[idx] = -nums[idx];\\n            }\\n        }\\n        \\n        // Find the first missing positive integer\\n        for (int i = 0; i < j; i++) {\\n            if (nums[i] > 0) {\\n                return i + 1;\\n            }\\n        }\\n        \\n        return j + 1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n = nums.length;\\n        \\n        // Move all positive integers to the front of the array\\n        int j = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] > 0) {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n                j++;\\n            }\\n        }\\n        \\n        // Mark indices that correspond to positive integers\\n        for (int i = 0; i < j; i++) {\\n            int idx = Math.abs(nums[i]) - 1;\\n            if (idx < j && nums[idx] > 0) {\\n                nums[idx] = -nums[idx];\\n            }\\n        }\\n        \\n        // Find the first missing positive integer\\n        for (int i = 0; i < j; i++) {\\n            if (nums[i] > 0) {\\n                return i + 1;\\n            }\\n        }\\n        \\n        return j + 1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928138,
                "title": "javascript-solution-using-map-100-ms-array-map-includes",
                "content": "**Feel free to ask Q\\'s...**\\n*#happytohelpu*\\n\\n***Do upvote if you find this solution useful. Happy Coding!***\\n\\n```\\n/**\\n * \\n * @param {*} nums \\n * @param {*} map \\n * @returns \\n */\\nconst firstMissingPositive = (nums, map = new Map()) => {\\n    for (let i = 1; i <= nums.length + 1; i++) {\\n        map.set(i, 1);\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] > 0) map.delete(nums[i])\\n    }\\n    const [firstValue] = map.keys();\\n    return firstValue;\\n};\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * \\n * @param {*} nums \\n * @param {*} map \\n * @returns \\n */\\nconst firstMissingPositive = (nums, map = new Map()) => {\\n    for (let i = 1; i <= nums.length + 1; i++) {\\n        map.set(i, 1);\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] > 0) map.delete(nums[i])\\n    }\\n    const [firstValue] = map.keys();\\n    return firstValue;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2774190,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] <= 0 or nums[i] > n) {\\n                nums[i] = n+1;\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(abs(nums[i]) > n) continue;\\n            int id = abs(nums[i]);\\n            nums[id-1] = -1 * abs(nums[id-1]);\\n        }\\n        int ans = n + 1;\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] > 0) {\\n                ans = i+1;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }  \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] <= 0 or nums[i] > n) {\\n                nums[i] = n+1;\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(abs(nums[i]) > n) continue;\\n            int id = abs(nums[i]);\\n            nums[id-1] = -1 * abs(nums[id-1]);\\n        }\\n        int ans = n + 1;\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] > 0) {\\n                ans = i+1;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773300,
                "title": "0ms-java-solution",
                "content": "```\\nclass Solution {\\npublic int firstMissingPositive(int[] nums) {\\n    int n = nums.length;\\n   \\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] <= 0 || nums[i] > n) {\\n            nums[i] = n + 1;\\n        }\\n    }\\n    \\n    for (int i = 0; i < n; i++) {\\n        int num = Math.abs(nums[i]);\\n        if (num > n) {\\n            continue;\\n        }\\n        num--; \\n        if (nums[num] > 0) { \\n            nums[num] = -1 * nums[num];\\n        }\\n    }\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] >= 0) {\\n            return i + 1;\\n        }\\n    }\\n    \\n    return n + 1;\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic int firstMissingPositive(int[] nums) {\\n    int n = nums.length;\\n   \\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] <= 0 || nums[i] > n) {\\n            nums[i] = n + 1;\\n        }\\n    }\\n    \\n    for (int i = 0; i < n; i++) {\\n        int num = Math.abs(nums[i]);\\n        if (num > n) {\\n            continue;\\n        }\\n        num--; \\n        if (nums[num] > 0) { \\n            nums[num] = -1 * nums[num];\\n        }\\n    }\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] >= 0) {\\n            return i + 1;\\n        }\\n    }\\n    \\n    return n + 1;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316294,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans = 1;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]<1)\\n                continue;\\n            else{\\n                if(nums[i]==ans)\\n                    ans++;\\n                else if(nums[i]>ans)\\n                    return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans = 1;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]<1)\\n                continue;\\n            else{\\n                if(nums[i]==ans)\\n                    ans++;\\n                else if(nums[i]>ans)\\n                    return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302936,
                "title": "cpp-two-different-approaches-with-o-1-space-fully-explained",
                "content": "Hello World ! \\nFirst Approach I used is pretty simple and it\\'s time complexity is O(n)\\n\\n**Steps**\\n1. Traverse the input array and replace all zeroes and negative number by INT_MAX\\n2. Traverse the input array again, and during this traversal we will find the correct position of each element by making value at that index negative.\\n3. During final traversal, return the  (index+1) where \"index\" is the first index at which element found is positive.\\n\\n```\\n\\tint n=v.size();\\n    int ans=0;\\n\\t\\n\\t// step 1 - Replacing zeroes and negative numbers with INT_MAX\\n    for(int i=0;i<n;i++)\\n    if(v[i]<1) v[i]=INT_MAX;\\n\\t\\n\\t// step 2 - Finding correct position of each element.\\n    for(int i=0;i<n;i++)\\n        if(abs(v[i])<=n)\\n        v[abs(v[i])-1] = min(v[abs(v[i])-1],-v[abs(v[i])-1]);\\n    \\n    // step 3 - Returning (index+1) , where \"index\" is the first index at which element found is positive\\n\\tfor(;ans<n;ans++)\\n        if(v[ans]>0) return ans+1;\\n    return ans+1;\\n```\\n\\n**Second Approach**\\n\\nAlthough the above approach was working very good in terms of space and time. But i still went on to look for some other way of solving it, the way through which no one has ever done this yet.\\nThen, the idea of **heap**  crossed my mind.\\n Overall Time complexity i guess would be approx - O(n*logn)\\n\\n1. By using heapify, i convert the same array into min heap.\\n2. Initialised ```ans=1```   \\n3. Now compare with the root of min heap (root of min heap is arr[0])\\n\\t* If the root of min heap (i.e arr[0]) is equal to ans, then ans is incremented.\\n\\t* If the root of min heap is greater than ans, the ans is returned.\\n\\nSee the code and its comments for better understanding.\\n\\n**Iterative Min Heapify Function**\\n```\\nvoid minheapify(vector<int>&a,int i,int n){\\n    while(i<=n){\\n    int l= 2*i+1;\\n    int r=2*i+2;\\n    int largest =i;\\n    if(l<n  && a[l]<a[largest])\\n    largest=l;\\n    if(r<n && a[r]<a[largest])\\n    largest=r;\\n     if(largest!=i){\\n        swap(a[i],a[largest]);\\n        i=largest;\\n    }\\n    else break;\\n    }\\n}\\n```\\n\\n**Driver Code**\\n```\\nint n=v.size();\\n       \\n        int ans=1;\\n\\t\\t\\n\\t\\t//Heapify the input array\\n        for(int i = (n/2)-1;i>-1;i--)\\n            minheapify(v,i,n); \\n  \\n    while(n>0){\\n\\t// Comparing root with the ans\\n        if(ans==v[0]) ans++;\\n        else if(ans<v[0]) break;\\n        v[0]=v[n-1];\\n        n--;\\n        minheapify(v,0,n);\\n    }\\n\\t\\n\\treturn ans;   // Final answer returned\\n```\\n\\nI know the first approach was way better. But you know, one should try to solve the question with other approaches too. \\n\\nOpen for suggestions, edits and improvements.\\nPlease **Upvote** if you like.\\nThanks,\\n**Aadi**\\n",
                "solutionTags": [],
                "code": "```\\n\\tint n=v.size();\\n    int ans=0;\\n\\t\\n\\t// step 1 - Replacing zeroes and negative numbers with INT_MAX\\n    for(int i=0;i<n;i++)\\n    if(v[i]<1) v[i]=INT_MAX;\\n\\t\\n\\t// step 2 - Finding correct position of each element.\\n    for(int i=0;i<n;i++)\\n        if(abs(v[i])<=n)\\n        v[abs(v[i])-1] = min(v[abs(v[i])-1],-v[abs(v[i])-1]);\\n    \\n    // step 3 - Returning (index+1) , where \"index\" is the first index at which element found is positive\\n\\tfor(;ans<n;ans++)\\n        if(v[ans]>0) return ans+1;\\n    return ans+1;\\n```\n```ans=1```\n```\\nvoid minheapify(vector<int>&a,int i,int n){\\n    while(i<=n){\\n    int l= 2*i+1;\\n    int r=2*i+2;\\n    int largest =i;\\n    if(l<n  && a[l]<a[largest])\\n    largest=l;\\n    if(r<n && a[r]<a[largest])\\n    largest=r;\\n     if(largest!=i){\\n        swap(a[i],a[largest]);\\n        i=largest;\\n    }\\n    else break;\\n    }\\n}\\n```\n```\\nint n=v.size();\\n       \\n        int ans=1;\\n\\t\\t\\n\\t\\t//Heapify the input array\\n        for(int i = (n/2)-1;i>-1;i--)\\n            minheapify(v,i,n); \\n  \\n    while(n>0){\\n\\t// Comparing root with the ans\\n        if(ans==v[0]) ans++;\\n        else if(ans<v[0]) break;\\n        v[0]=v[n-1];\\n        n--;\\n        minheapify(v,0,n);\\n    }\\n\\t\\n\\treturn ans;   // Final answer returned\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1234110,
                "title": "c-o-n-time-and-o-1-space",
                "content": "The logic used is put each number in its right place. Example when we find 4, it is swapped with A[3]. At last, the first place where the number is not right, return (place + 1) as that would be the missing value.\\n\\n```\\n int firstMissingPositive(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int i = 0;\\n        \\n        while (i < n)\\n        {\\n            if (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])\\n                swap(nums[i], nums[nums[i] - 1]);\\n            else\\n                i++;\\n        }\\n        \\n        for (i = 0; i < n; i++)\\n            if (nums[i] != (i + 1))\\n                return i + 1;\\n        \\n        return n + 1;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n int firstMissingPositive(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int i = 0;\\n        \\n        while (i < n)\\n        {\\n            if (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])\\n                swap(nums[i], nums[nums[i] - 1]);\\n            else\\n                i++;\\n        }\\n        \\n        for (i = 0; i < n; i++)\\n            if (nums[i] != (i + 1))\\n                return i + 1;\\n        \\n        return n + 1;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1059738,
                "title": "100-faster-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_set<long long int>s;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]>0){\\n            s.insert(arr[i]);\\n                }\\n        }\\n  \\n        int i=1;\\n         while(1){\\n             if(s.find(i)==s.end()){\\n                 return i;\\n             }\\n             i++;\\n         }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_set<long long int>s;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]>0){\\n            s.insert(arr[i]);\\n                }\\n        }\\n  \\n        int i=1;\\n         while(1){\\n             if(s.find(i)==s.end()){\\n                 return i;\\n             }\\n             i++;\\n         }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980736,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i =0; i<n; i++)\\n        {\\n            while (nums[i]>= 1 && nums[i]<=n && nums[i] != nums[nums[i] - 1])\\n                swap(nums[i] , nums[nums[i] - 1]);          \\n        }\\n        for (int i =0; i<n; i++)\\n        {\\n            if (nums[i] != i +1)\\n                return i+1;\\n        }\\n        return n +1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i =0; i<n; i++)\\n        {\\n            while (nums[i]>= 1 && nums[i]<=n && nums[i] != nums[nums[i] - 1])\\n                swap(nums[i] , nums[nums[i] - 1]);          \\n        }\\n        for (int i =0; i<n; i++)\\n        {\\n            if (nums[i] != i +1)\\n                return i+1;\\n        }\\n        return n +1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872320,
                "title": "c-c-super-simple-short-solution-o-n-o-1-0-ms-faster-than-100",
                "content": "**C:**\\n```\\nint firstMissingPositive(int* nums, int numsSize){\\n    int i=0;\\n    while (i < numsSize) {\\n        if ((nums[i] <= 0) || (nums[i] > numsSize) || (nums[i]-1 == i) || (nums[i] == nums[nums[i]-1]))\\n            i++;\\n        else {\\n            \\n            int temp = nums[i];\\n            nums[i] = nums[nums[i] - 1];\\n            nums[temp - 1] = temp;\\n        }\\n    }\\n    for (int i=0; i<numsSize; i++)\\n        if (nums[i]-1 != i)\\n            return i+1;\\n    return numsSize+1;\\n}\\n```\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int numsSize = nums.size();\\n        int i=0;\\n        while (i < numsSize) {\\n            if ((nums[i] <= 0) || (nums[i] > numsSize) || (nums[i]-1 == i) || (nums[i] == nums[nums[i]-1]))\\n                i++;\\n            else {\\n                int temp = nums[i];\\n                nums[i] = nums[nums[i] - 1];\\n                nums[temp - 1] = temp;\\n            }\\n        }\\n        for (int i=0; i<numsSize; i++)\\n            if (nums[i]-1 != i)\\n                return i+1;\\n        return numsSize+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint firstMissingPositive(int* nums, int numsSize){\\n    int i=0;\\n    while (i < numsSize) {\\n        if ((nums[i] <= 0) || (nums[i] > numsSize) || (nums[i]-1 == i) || (nums[i] == nums[nums[i]-1]))\\n            i++;\\n        else {\\n            \\n            int temp = nums[i];\\n            nums[i] = nums[nums[i] - 1];\\n            nums[temp - 1] = temp;\\n        }\\n    }\\n    for (int i=0; i<numsSize; i++)\\n        if (nums[i]-1 != i)\\n            return i+1;\\n    return numsSize+1;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int numsSize = nums.size();\\n        int i=0;\\n        while (i < numsSize) {\\n            if ((nums[i] <= 0) || (nums[i] > numsSize) || (nums[i]-1 == i) || (nums[i] == nums[nums[i]-1]))\\n                i++;\\n            else {\\n                int temp = nums[i];\\n                nums[i] = nums[nums[i] - 1];\\n                nums[temp - 1] = temp;\\n            }\\n        }\\n        for (int i=0; i<numsSize; i++)\\n            if (nums[i]-1 != i)\\n                return i+1;\\n        return numsSize+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871621,
                "title": "first-missing-positive-solution-java-beat-100",
                "content": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        if (nums == null || nums.length == 0) return 1;\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (nums[i] < 1 || nums[i] > nums.length || nums[i] == nums[nums[i] -1]) continue;\\n            // swap the element\\n            int temp = nums[nums[i] -1];\\n            nums[nums[i] -1] = nums[i]; \\n            nums[i] = temp;\\n            i--;\\n        }\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (nums[i] != i+1) return i+1;\\n        }\\n        return nums.length + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        if (nums == null || nums.length == 0) return 1;\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (nums[i] < 1 || nums[i] > nums.length || nums[i] == nums[nums[i] -1]) continue;\\n            // swap the element\\n            int temp = nums[nums[i] -1];\\n            nums[nums[i] -1] = nums[i]; \\n            nums[i] = temp;\\n            i--;\\n        }\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (nums[i] != i+1) return i+1;\\n        }\\n        return nums.length + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735695,
                "title": "java-time-o-n-constant-space-swap-approach",
                "content": "```\\n/* The goal is to bring the positive element to its place(index=value-1) by swapping...\\neg. [-1,3,1,4,5]....\\nafter swapping the array will look like [1,-1,3,4,5]  \\nAfter swapping we have to find the value which is not in its expected position which is 2 in this case.\\n*/\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        if(nums.length==0) return 1;\\n        for(int i=0;i<nums.length;){\\n            if(nums[i]>nums.length || nums[i]<=0){           //only positive values\\n                i++;\\n              continue;    \\n            }else if(nums[nums[i]-1]==nums[i]){    //checking whether the element is at its position or not\\n                i++;\\n            } \\n\\t\\t// swapping the element to its desired position\\t\\n            else{\\n                \\n            int temp=nums[nums[i]-1];\\n            nums[nums[i]-1]=nums[i];\\n            nums[i]=temp;\\n            }\\n                         }\\n        // finding the smallest positive element out of its position\\n        int i=0;\\n        for(i=0;i<nums.length;i++){\\n            if(nums[i]!=i+1) return i+1;\\n        }\\n        \\n        return nums[i-1]+1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/* The goal is to bring the positive element to its place(index=value-1) by swapping...\\neg. [-1,3,1,4,5]....\\nafter swapping the array will look like [1,-1,3,4,5]  \\nAfter swapping we have to find the value which is not in its expected position which is 2 in this case.\\n*/\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        if(nums.length==0) return 1;\\n        for(int i=0;i<nums.length;){\\n            if(nums[i]>nums.length || nums[i]<=0){           //only positive values\\n                i++;\\n              continue;    \\n            }else if(nums[nums[i]-1]==nums[i]){    //checking whether the element is at its position or not\\n                i++;\\n            } \\n\\t\\t// swapping the element to its desired position\\t\\n            else{\\n                \\n            int temp=nums[nums[i]-1];\\n            nums[nums[i]-1]=nums[i];\\n            nums[i]=temp;\\n            }\\n                         }\\n        // finding the smallest positive element out of its position\\n        int i=0;\\n        for(i=0;i<nums.length;i++){\\n            if(nums[i]!=i+1) return i+1;\\n        }\\n        \\n        return nums[i-1]+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524319,
                "title": "brute-force-solution",
                "content": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums) {\\n            set.add(num);\\n        }\\n        int first = 1;\\n        while(set.contains(first)){\\n            first++;\\n        }\\n        return first;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums) {\\n            set.add(num);\\n        }\\n        int first = 1;\\n        while(set.contains(first)){\\n            first++;\\n        }\\n        return first;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17296,
                "title": "simple-method-with-a-little-trick",
                "content": "Firstly,the answer must be among [1..n+1]. so all numbers less than 0 or greater than n could be discared.(change them to 0).\\nThen, if \"i\" appeared, we modify a[i-1] to -a[i-1]-1. In this way, we could do it with constant extra space.\\n\\n    class Solution {\\n    public:\\n        int firstMissingPositive(vector<int>& nums) {\\n            vector<int> &a=nums;\\n            int n=a.size();\\n            if(n==0) return 1;\\n            for(int i=0;i<n;i++) if(a[i]<0||a[i]>n) a[i]=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(a[i]==0 || a[i]==-1) continue;\\n                int t=(a[i]>0)?(a[i]-1):(-a[i]-2);\\n                if(a[t]>=0) a[t]=-a[t]-1;\\n            }\\n            for(int i=0;i<n;i++) if(a[i]>=0) return i+1;\\n            return n+1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int firstMissingPositive(vector<int>& nums) {\\n            vector<int> &a=nums;\\n            int n=a.size();\\n            if(n==0) return 1;\\n            for(int i=0;i<n;i++) if(a[i]<0||a[i]>n) a[i]=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(a[i]==0 || a[i]==-1) continue;\\n                int t=(a[i]>0)?(a[i]-1):(-a[i]-2);\\n                if(a[t]>=0) a[t]=-a[t]-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4067658,
                "title": "easy-3-for-loop-c-o-1-space-based-on-pigeonhole-principle-using-cyclic-sort-with-explanation",
                "content": "1. **Clean the array:** We want to ignore numbers that are not useful for us. So, we go through our list (nums) one by one.If a number is zero or negative, or if it\\'s greater than m (our total number of elements), we consider it not useful and replace it with zero. This simplifies our task because we only care about positive integers up to m.\\n\\n* 2. **Put numbers to their place using cyclic sort i.e swap until you find the number :** (This works because of **[Pigeonhole Principle](https://en.wikipedia.org/wiki/Pigeonhole_principle)**) : The Pigeonhole Principle states that if you have more \"pigeons\" than \"pigeonholes,\" at least one pigeonhole must contain more than one pigeon. In this context:\\n* \\n* The \"pigeons\" are the positive integers from 1 to m (where m is the size of the input array nums).\\n* The \"pigeonholes\" are the indices of the array nums.\\n* The goal in this problem is to find the first missing positive integer. If there are no missing positive integers in the range from 1 to m, then all the pigeons are already in their correct pigeonholes, and no pigeonhole contains more than one pigeon.\\n* * So Now, we want to arrange the remaining positive integers in the correct order from 1 to m. We do this using a technique called cyclic sort. \\n* * We go through our list again, and for each number: If it\\'s not zero (useful) and not already in the right place (not equal to i + 1), we swap it with the number in its rightful position, which is nums[i] - 1. We repeat this until we can\\'t swap anymore.\\n\\n3. **Finding the First Missing Positive:** \\n* * Once we\\'ve sorted our list, we go through it one more time to find the first number that\\'s not in its expected position.\\n* * The first missing positive integer is equal to i + 1 (because we\\'re looking for the number that should be in the i-th position of our sorted list).\\n* * If we don\\'t find any missing positive integers in the range from 1 to m, we return m + 1, indicating that all positive integers up to m are present in the list.\\n\\n**If you liked the solution. Please Vote Up. Thank you! Happy Coding! Keep Finding the pigeons\\uD83D\\uDE02**\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int m = size(nums);\\n        \\n        for(int i=0;i<m;i++)if(nums[i]<=0 || nums[i]>m) nums[i]=0; //replace non needed numbers with zero\\n        \\n        \\n        for(int i=0;i<m;i++)                                     //arrange the position with cyclic sort\\n        {\\n           while(nums[i]!=0 && nums[i]!=i+1)                    //while loop runs till correct number on its place or the necessary condition fails\\n           {\\n               if (nums[i] == nums[ (nums[i] - 1) ])break;      //if both are same then no need to run loop\\n               swap(nums[i],nums[nums[i]-1]);                   //swap till they are at their required place\\n           }\\n        }\\n        \\n        \\n        for(int i=0;i<m;i++)if(nums[i]!=i+1)                    //find the missing numbers as all the needed numbers are on its place\\n            return i+1;\\n        \\n        return m+1;\\n    }\\n};\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/48d3adef-77ff-41b1-92c6-b3b9c501d46c_1695198038.9110086.png)\\n\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int m = size(nums);\\n        \\n        for(int i=0;i<m;i++)if(nums[i]<=0 || nums[i]>m) nums[i]=0; //replace non needed numbers with zero\\n        \\n        \\n        for(int i=0;i<m;i++)                                     //arrange the position with cyclic sort\\n        {\\n           while(nums[i]!=0 && nums[i]!=i+1)                    //while loop runs till correct number on its place or the necessary condition fails\\n           {\\n               if (nums[i] == nums[ (nums[i] - 1) ])break;      //if both are same then no need to run loop\\n               swap(nums[i],nums[nums[i]-1]);                   //swap till they are at their required place\\n           }\\n        }\\n        \\n        \\n        for(int i=0;i<m;i++)if(nums[i]!=i+1)                    //find the missing numbers as all the needed numbers are on its place\\n            return i+1;\\n        \\n        return m+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668423,
                "title": "basic-approach-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        vector<int> sol(nums.size()+2,0);\\n        int ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0 && nums[i]<=nums.size())\\n                sol[nums[i]]=1;\\n        }\\n        for(int i=1;i<sol.size();i++)\\n        {\\n            if(sol[i]==0)\\n            {\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        vector<int> sol(nums.size()+2,0);\\n        int ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0 && nums[i]<=nums.size())\\n                sol[nums[i]]=1;\\n        }\\n        for(int i=1;i<sol.size();i++)\\n        {\\n            if(sol[i]==0)\\n            {\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591829,
                "title": "very-very-easy-java-soln-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int b=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==b)\\n            {\\n               b++;\\n            }\\n            \\n        }\\n        return b;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int b=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==b)\\n            {\\n               b++;\\n            }\\n            \\n        }\\n        return b;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587781,
                "title": "c-very-simple-easy-to-understand-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(auto &i: nums){\\n            if(i>n) i = n+1;\\n            if(i<=0)i = n+1;\\n        }\\n        for(auto &i: nums){\\n            if(abs(i)-1<n && nums[abs(i)-1]>0)nums[abs(i)-1] *= -1;\\n        }\\n        int i;\\n        for(i = 0; i < n; i++){\\n            if(nums[i]>0)return i+1;\\n        }\\n        return n+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(auto &i: nums){\\n            if(i>n) i = n+1;\\n            if(i<=0)i = n+1;\\n        }\\n        for(auto &i: nums){\\n            if(abs(i)-1<n && nums[abs(i)-1]>0)nums[abs(i)-1] *= -1;\\n        }\\n        int i;\\n        for(i = 0; i < n; i++){\\n            if(nums[i]>0)return i+1;\\n        }\\n        return n+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388562,
                "title": "all-possible-solutions-include-hash-set-normal-sorting-and-cyclic-sort",
                "content": "The idea is that we `don\\'t care elements which less than 1 and and greater nums.count`. We try to `partly` sort the elements to build a final array like: `[1, 2, 3, ... out_of_bound_element ... ]`, which is calle `Cyclic Sorting`. Then just iterate from starting and return the fist missing number.\\n\\nOne thing to note that `nums[i] >= -2^31`, so have to compare `nums[i] with i + 1` but not `nums[i] - 1 with i` \\uD83D\\uDE02,\\n\\n# Code\\n```\\nclass Solution {\\n\\n    func firstMissingPositive(_ nums: [Int]) -> Int {\\n        return firstMissingPositiveUsingCylicSort(nums)\\n        // return firstMissingPositiveUsingNormalSort(nums)\\n        // return firstMissingPositiveUsingSet(nums)\\n    }\\n\\n    // Cylic sort\\n    // Time: O(n)\\n    // Space: O(1)\\n    func firstMissingPositiveUsingCylicSort(_ nums: [Int]) -> Int {\\n        var nums = nums\\n        var i = 0\\n        while i < nums.count {\\n            if nums[i] > 0, nums[i] <= nums.count, nums[i] != nums[nums[i] - 1] {\\n                nums.swapAt(i, nums[i] - 1)\\n            } else {\\n                i += 1\\n            }\\n        }\\n        for (i, num) in nums.enumerated() {\\n            if num != i + 1 {\\n                return i + 1\\n            }\\n        }\\n        return nums.count + 1\\n    }\\n\\n\\n    // Normal sort\\n    // Time: O(nlogn)\\n    // Space: O(1)\\n    func firstMissingPositiveUsingNormalSort(_ nums: [Int]) -> Int {\\n        var nums = nums.sorted()\\n\\n        if var minPositiveIndex = nums.firstIndex(where: { $0 > 0 }), nums[minPositiveIndex] == 1 {\\n            while minPositiveIndex + 1 < nums.count, nums[minPositiveIndex + 1] - nums[minPositiveIndex] <= 1 {\\n                minPositiveIndex += 1\\n            }\\n            return nums[minPositiveIndex] + 1\\n        } else {\\n            return 1\\n        }\\n    }\\n\\n    // Hash/Set\\n    // Time: O(n)\\n    // Space: O(n)\\n    func firstMissingPositiveUsingSet(_ nums: [Int]) -> Int {\\n        var set = Set<Int>()\\n        for num in nums {\\n            if num > 0, num <= nums.count {\\n                set.insert(num)\\n            }\\n        }\\n\\n        for i in 1...nums.count {\\n            if !set.contains(i) {\\n                return i\\n            }\\n        }\\n        return nums.count + 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n\\n    func firstMissingPositive(_ nums: [Int]) -> Int {\\n        return firstMissingPositiveUsingCylicSort(nums)\\n        // return firstMissingPositiveUsingNormalSort(nums)\\n        // return firstMissingPositiveUsingSet(nums)\\n    }\\n\\n    // Cylic sort\\n    // Time: O(n)\\n    // Space: O(1)\\n    func firstMissingPositiveUsingCylicSort(_ nums: [Int]) -> Int {\\n        var nums = nums\\n        var i = 0\\n        while i < nums.count {\\n            if nums[i] > 0, nums[i] <= nums.count, nums[i] != nums[nums[i] - 1] {\\n                nums.swapAt(i, nums[i] - 1)\\n            } else {\\n                i += 1\\n            }\\n        }\\n        for (i, num) in nums.enumerated() {\\n            if num != i + 1 {\\n                return i + 1\\n            }\\n        }\\n        return nums.count + 1\\n    }\\n\\n\\n    // Normal sort\\n    // Time: O(nlogn)\\n    // Space: O(1)\\n    func firstMissingPositiveUsingNormalSort(_ nums: [Int]) -> Int {\\n        var nums = nums.sorted()\\n\\n        if var minPositiveIndex = nums.firstIndex(where: { $0 > 0 }), nums[minPositiveIndex] == 1 {\\n            while minPositiveIndex + 1 < nums.count, nums[minPositiveIndex + 1] - nums[minPositiveIndex] <= 1 {\\n                minPositiveIndex += 1\\n            }\\n            return nums[minPositiveIndex] + 1\\n        } else {\\n            return 1\\n        }\\n    }\\n\\n    // Hash/Set\\n    // Time: O(n)\\n    // Space: O(n)\\n    func firstMissingPositiveUsingSet(_ nums: [Int]) -> Int {\\n        var set = Set<Int>()\\n        for num in nums {\\n            if num > 0, num <= nums.count {\\n                set.insert(num)\\n            }\\n        }\\n\\n        for i in 1...nums.count {\\n            if !set.contains(i) {\\n                return i\\n            }\\n        }\\n        return nums.count + 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263341,
                "title": "short-sweet-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        for(auto &i: nums){\\n            if(i<=0||i>n){\\n                i = n+1;\\n            }\\n        }\\n        for(auto &i: nums){\\n            if(abs(i)==n+1||nums[abs(i)-1]<0)continue;\\n            nums[abs(i)-1] *= -1;\\n        }\\n        for(i = 1; i <= n; i++){\\n            if(nums[i-1]>0)return i;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        for(auto &i: nums){\\n            if(i<=0||i>n){\\n                i = n+1;\\n            }\\n        }\\n        for(auto &i: nums){\\n            if(abs(i)==n+1||nums[abs(i)-1]<0)continue;\\n            nums[abs(i)-1] *= -1;\\n        }\\n        for(i = 1; i <= n; i++){\\n            if(nums[i-1]>0)return i;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160264,
                "title": "92-accepted-easy-solution-with-explanation",
                "content": "# Intuition\\n@first you think about to put ith value at its original position in sorted array (that is at i)\\n# Approach\\n@first you think about to put ith value at its original position in sorted array (that is at i)\\n@if the position is out of bound leave it as it is and move on this is done also in case of duplicate\\n@then re-iterate whole array find first time which is not at its original position return it \\n@ if all array is perfect after swap return size of array\\n# Complexity\\n- Time complexity:\\nTime complexity is O(n)  because for each element we find it original position or leave it on their position\\n\\n- Space complexity:\\nspace complexity is O(1)\\nbecause there is only 2 to 4 approx variable is taken\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // if(nums.)\\n        int i=0;\\n        while(i<nums.size()){\\n            if(nums[i]!=i){\\n                if(nums[i]>nums.size()-1||nums[i]<0){\\n                    i++;\\n                }else{\\n                     int j=nums[i];\\n                     int temp=nums[j];\\n                     nums[i]=temp;\\n                     nums[j]=j;\\n                     if(temp==j){\\n                         i++;\\n                     }\\n                }\\n            }else{\\n            i++;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=i&&i){\\n                return i;\\n            }\\n        }\\n        if(nums[0]==nums.size()){\\nreturn nums.size()+1;\\n        }else{\\n\\n        return nums.size();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // if(nums.)\\n        int i=0;\\n        while(i<nums.size()){\\n            if(nums[i]!=i){\\n                if(nums[i]>nums.size()-1||nums[i]<0){\\n                    i++;\\n                }else{\\n                     int j=nums[i];\\n                     int temp=nums[j];\\n                     nums[i]=temp;\\n                     nums[j]=j;\\n                     if(temp==j){\\n                         i++;\\n                     }\\n                }\\n            }else{\\n            i++;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=i&&i){\\n                return i;\\n            }\\n        }\\n        if(nums[0]==nums.size()){\\nreturn nums.size()+1;\\n        }else{\\n\\n        return nums.size();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148746,
                "title": "4-line-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int traversal =1;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==traversal)\\n            {\\n                traversal++;\\n            }\\n           \\n        }\\n        return traversal;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int traversal =1;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==traversal)\\n            {\\n                traversal++;\\n            }\\n           \\n        }\\n        return traversal;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127620,
                "title": "easy-peasy-soln-to-hard-problem",
                "content": "# Intuition \\n    Simple Math Operation and Logic\\n\\n# Approach\\n\\n- Since they\\'ve asked us to find out the smallest positive integer, then there\\'s no point of having the negative numbers in array.\\n\\n- All the negative numbers in the array is replaced by 0.\\n\\n- Check if the number one(1) is present in array or not. If not then you\\'ve got the answer :-))),  just return 1.\\n\\n- Otherwise sort the array and find out for that first element whose difference is greater than 1. If found, then store the result in a variable and break the loop. \\n\\n- If the value of the variable is same even before and after the iteration, then return (last element + 1).\\n\\n\\n# Complexity\\n- Time complexity: O(n*logn)\\n<!--  -->\\n\\n- Space complexity: O(1)\\n<!--  -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] < 0)\\n              nums[i] = 0;\\n        }\\n\\n        int ones = 0;\\n        for(auto x: nums)\\n        {\\n            if(x == 1)\\n               ones++;  \\n        }\\n\\n        if(ones == 0)\\n            return 1;\\n\\n        sort(nums.begin(), nums.end());\\n        int ele = -1;\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] - nums[i-1] > 1)\\n            {\\n                ele = nums[i-1] + 1;\\n                break;\\n            }\\n        } \\n\\n        return ele == -1 ? ++nums[n-1] : ele;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] < 0)\\n              nums[i] = 0;\\n        }\\n\\n        int ones = 0;\\n        for(auto x: nums)\\n        {\\n            if(x == 1)\\n               ones++;  \\n        }\\n\\n        if(ones == 0)\\n            return 1;\\n\\n        sort(nums.begin(), nums.end());\\n        int ele = -1;\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] - nums[i-1] > 1)\\n            {\\n                ele = nums[i-1] + 1;\\n                break;\\n            }\\n        } \\n\\n        return ele == -1 ? ++nums[n-1] : ele;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719139,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        int first = 1;\\n        \\n        for (int num : nums) {\\n            if (num > 0) {\\n                set.add(num);\\n            }\\n            \\n            if (num == first) {\\n                first++;\\n                \\n                while (set.contains(first)) {\\n                    first++;\\n                }\\n            }\\n        }\\n        \\n        return first;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        int first = 1;\\n        \\n        for (int num : nums) {\\n            if (num > 0) {\\n                set.add(num);\\n            }\\n            \\n            if (num == first) {\\n                first++;\\n                \\n                while (set.contains(first)) {\\n                    first++;\\n                }\\n            }\\n        }\\n        \\n        return first;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623142,
                "title": "easy-beginners-solution-explained",
                "content": "nums.sort() # sort the given array of numbers \\n        ans=1  # set 1 as ans because 1 is the smallest positive integer#\\n        for i in range(len(nums)):\\n            if nums[i] == ans: # if during the iteration current index value and ans matches then increment ans, at any point it does not match return ans #\\n                ans += 1\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "nums.sort() # sort the given array of numbers \\n        ans=1  # set 1 as ans because 1 is the smallest positive integer#\\n        for i in range(len(nums)):\\n            if nums[i] == ans: # if during the iteration current index value and ans matches then increment ans, at any point it does not match return ans #\\n                ans += 1\\n        return ans",
                "codeTag": "Unknown"
            },
            {
                "id": 2463829,
                "title": "python-4-approaches-summarized-with-o-n-o-1-solution",
                "content": "# Introduction\\nThis particular problem is much easier than it would usually be, as the problem\\u2019s description specifies the required time and space complexity, limiting the possible approaches.</br>\\nHowever, in the actual interview, you would likely be given a problem without specified constraints and solution time-space complexity. \\n* You should ask about input value constraints before proceeding to solve the problem. \\n* Optimal time-space complexity should be achieved in the solving process, starting with a brute-force solution and further seeking ways to optimize the process.</br>\\n\\n# Brute-Force solution\\nThe solution that comes to mind first consists of checking the presence in `nums` of every positive integer in ascending order, starting with *1*. The number of checks is limited by *N + 1*, because the lowest positive missing integer lies within the range *[1, \\u2026, N + 1]* for an array of length *N*, as the missing value would be *N + 1* if all values in *[1, \\u2026, n]* are present in `nums` once, and missing value would be in *[1, \\u2026, n]* otherwise.\\n## Code\\n```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n\\n\\t\\t# check presence of each value in [1, ..., N]\\n\\t\\t# missing value is N + 1 if every previous value is present\\n        for v in range(1, len(nums)):\\n\\n            if v not in nums:\\n                return v\\n\\n        return v + 1\\n```\\n## Complexity analysis\\nLet *N* be the length of the `nums` array, and *O(M)* be the time complexity of finding whether a certain number is present in the array.</br>\\nNote that linear search in an array takes *O(N)* time because it is conducted by iterating through the whole array until the number is found, meaning *O(M) = O(N)*\\n* Time Complexity: *O(N<sup>2</sup>)*\\nFor each number in *[1, \\u2026 N]*, we spend *O(M)* time to check whether it is present in `nums`</br>\\nIn total, we have *O(N \\\\* M) = O(N<sup>2</sup>))*</br>\\n\\n* Space Complexity: *O(1)*\\nWe use constant extra space to store a fixed number of variables to account for the currently processed number.\\n\\n# Sorting solution\\nAnother simple solution lies in sorting the array and iterating through it until we reach the last non-positive number and further checking that every positive number is present in the sorted array.\\n## Code:\\n```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n\\n        # sort nums\\n        nums.sort()\\n        cur = 0\\n        \\n        for idx, val in enumerate(nums):\\n            # skip the negatives\\n            if val <= 0:\\n                continue\\n\\n            # check that next value in sorted nums contains\\n            # number that immeadiately follows it or is equal to it\\n            # set current lowest positive to one that we checked\\n            elif val == cur or val == cur + 1:\\n                cur = val\\n           \\n           # break cycle if there is a gap of more than 1 between two\\n           # neighbouring values in sorted nums\\n           else:\\n                break\\n\\n        return cur + 1\\n```\\n## Complexity analysis\\nLet *N* be the length of the `nums` array.\\n* Time Complexity: *O(N \\\\* logN)*\\nQuicksort is generally considered the fastest among the usual sorting algorithms since its time complexity is *O(N \\\\* logN)* on average for a randomly sampled array. However, most programming languages use some sort of hybrid, heavily optimized algorithm as their native sort. Usually, the native sorting algorithms are the fastest, but their average time complexity is *O(N \\\\* logN)*.\\nFor each in `nums[i]`, we check whether the value is positive and equal to the previous or bigger by one.</br>\\nIn total we have *O(N \\\\* logN + N \\\\* M) = O(N \\\\* logN + N) = O(N \\\\* logN)*</br>\\n\\n* Space Complexity: *O(1)*\\nWe use constant extra space to store a fixed number of variables to account for the current number we search for. Quicksort is an in-place sorting algorithm, meaning that it uses no extra space.</br>\\nHowever, if you use native to your preferred language sorting algorithm, it may use a linear extra space in a worst-case scenario.\\n# Hash-Table solution\\nThe pros of using a hash table are that hash tables are implemented in such a way that adding, searching for, and deleting a value is done within average and amortized *O(1)* time. The solution lies in iterating through `nums` and adding every positive integer to the hash table, and then checking for the presence in the hash table of every positive integer in ascending order.\\n## Code:\\n```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n\\n        # create hash table\\n        present_values = set()\\n\\n        # add every value from nums to hash table\\n        for v in nums:\\n            if v > 0:\\n                present_values.add(v)\\n        \\n        # searching for lowest missing value, starting with 1\\n        cur = 1\\n        \\n        while cur in present_values:\\n            cur += 1\\n\\n        return cur\\n```\\n## Complexity analysis\\nLet *N* be the length of the `nums` array, and *O(M)* be the time complexity of finding whether a certain positive number is present in the hash table.\\n* Time Complexity: *O(N)*\\nFor each `nums[i]`, we add its value to the hash table in *O(1)* time. For values in the range *[1, \\u2026, N]*, we check whether they are present in the hash table in *O(M)* time.</br>\\nIn total we have *O(N \\\\* 1 + N \\\\* M) = O(N + N \\\\* 1) = O(N)*</br>\\n* Space Complexity: *O(N)*\\nWe use linear extra space to store the hash table (some of the values in `nums` are stored in the hash table). Not knowing the exact number of positive integers in `nums`, in the worst-case scenario, all values in `nums` will be positive), and thus hash table stores a certain percentage *P* of values in `nums`.</br>\\nNote that *O(P / 100 * N) = O(N)*\\n# Final solution\\nThere are a couple of constraints to the problem, which will help us find the right solution:\\n* We need to store somehow information about the existence of a certain positive number\\n* According to the problem\\u2019s formulation, we can not use additional space to store this information.\\n* We can not sort the `nums` array to store information in an intuitive ascending way because of the time complexity constraints which do not allow for sorting.\\n\\nThe only way to store all necessary information is in the `nums` array itself, and here is how we will do it. \\n1. We could use the cell at the index that corresponds to a specific value *v* to store information about the value *v* so that `nums[v]`, which contains some value *k*, will represent the existence of *v*, yet still containing information about the *k* value.\\n2. Since we only care about the positive numbers, upon reaching value *v*, we could make the value in `nums[v]` a negative value of the same power, `nums[v] = -nums[v]`. But you can already see some flaws in this approach:\\n\\n\\t* In case `nums[v] = 0`, then `-nums[v] = 0` as well, not reflecting the existence of *v*.\\n\\t* Negative integers could already be present in `nums`, confusing the algorithm, such as in the following case, say there is no value *v* in `nums`, but `nums[i] = -2`, then the algorithm would think that *v* was present in `nums`.\\n\\t* Large values greater than the highest index in `nums` can also be present in `nums`, calling for runtime errors.\\n3. Let us try to fix these issues:\\n\\t* In case `nums[v] = 0`: Since zero is not a positive integer, we do not care about its existence. We can replace it with any number that we know exists in `nums`, as adding a number already present in `nums` will not reflect on the lowest missing integer. The number that surely is the number *v* that we are processing at the moment `nums[v] = 0 => nums[v] = -v`.\\n\\t* Since the presence of negative values is irrelevant to us (we are looking for the lowest positive integer), we can replace all negatives with zeroes, especially since we have already solved the \\u2018zero\\u2019 problem.\\n\\t* As explained in the brute-force approach, missing values is in the range *[1, \\u2026, N + 1]* thus, we can ignore all values greater than *N* (if all values in *[1, \\u2026, N]* are present in `nums`, then *N + 1* is the lowest missing, thus no need to store information about *N + 1*), or perhaps more conveniently replace them with zeroes\\n4. And lastly, for convenience, to avoid messing with indices, we will add another zero value at the end of the array to represent the existence of value *N*; consequently, `nums[N]` will not present us with a runtime error.\\n![image](https://assets.leetcode.com/users/images/aefd3524-2345-4bbf-a834-5c4af0807abb_1661287627.2233372.gif)\\n## Code:\\n```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        # add zero value to the end to avoid messing with indices\\n        nums.append(0)\\n\\n        # nums preprocessing\\n        for idx, num in enumerate(nums):\\n            if nums[idx] <= 0 or nums[idx] >= len(nums):\\n                nums[idx] = 0\\n\\n        # getting nums to store information about the existence of processed positive integer\\n        for idx, num in enumerate(nums):\\n            i = abs(num)\\n\\n            if nums[i] == 0:\\n                nums[i] = -i\\n            else:\\n                nums[i] = -abs(nums[i])\\n\\n        idx = 1\\n\\n        # finding lowest positive integer that is missing from nums\\n        while idx < len(nums) and nums[idx] < 0:\\n            idx += 1\\n\\n        return idx\\n```\\n## Complexity analysis\\nLet *N* be the length of the `nums` array.\\n* Time Complexity: *O(N \\\\* logN)*\\nFor each `nums[i]`, we check whether it is negative or larger than *N* and replace it with zero if the condition is true in *O(N)* time. For each `nums[i] = v` we set `nums[|v|] = -|v|` in *O(N)* time. For each `nums[i] = v`, we check whether *v* is larger than zero, meaning that *v* was not present in `nums`, consequently *v* being the first missing positive in *O(N)* time</br>\\nIn total we have *O(N + N + N) = O(N)*\\n\\n* Space Complexity: *O(1)*\\nWe use constant extra space to store a fixed number of variables to account for the current number/index.\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n\\n\\t\\t# check presence of each value in [1, ..., N]\\n\\t\\t# missing value is N + 1 if every previous value is present\\n        for v in range(1, len(nums)):\\n\\n            if v not in nums:\\n                return v\\n\\n        return v + 1\\n```\n```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n\\n        # sort nums\\n        nums.sort()\\n        cur = 0\\n        \\n        for idx, val in enumerate(nums):\\n            # skip the negatives\\n            if val <= 0:\\n                continue\\n\\n            # check that next value in sorted nums contains\\n            # number that immeadiately follows it or is equal to it\\n            # set current lowest positive to one that we checked\\n            elif val == cur or val == cur + 1:\\n                cur = val\\n           \\n           # break cycle if there is a gap of more than 1 between two\\n           # neighbouring values in sorted nums\\n           else:\\n                break\\n\\n        return cur + 1\\n```\n```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n\\n        # create hash table\\n        present_values = set()\\n\\n        # add every value from nums to hash table\\n        for v in nums:\\n            if v > 0:\\n                present_values.add(v)\\n        \\n        # searching for lowest missing value, starting with 1\\n        cur = 1\\n        \\n        while cur in present_values:\\n            cur += 1\\n\\n        return cur\\n```\n```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        # add zero value to the end to avoid messing with indices\\n        nums.append(0)\\n\\n        # nums preprocessing\\n        for idx, num in enumerate(nums):\\n            if nums[idx] <= 0 or nums[idx] >= len(nums):\\n                nums[idx] = 0\\n\\n        # getting nums to store information about the existence of processed positive integer\\n        for idx, num in enumerate(nums):\\n            i = abs(num)\\n\\n            if nums[i] == 0:\\n                nums[i] = -i\\n            else:\\n                nums[i] = -abs(nums[i])\\n\\n        idx = 1\\n\\n        # finding lowest positive integer that is missing from nums\\n        while idx < len(nums) and nums[idx] < 0:\\n            idx += 1\\n\\n        return idx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718735,
                "title": "c-o-1-space-and-o-n-time-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    Algorithm- \\n    We will rearrange the array such that each `valid` element get its correct place and then search for the answer in rearranged array.\\n    \\n    Question-0: Why the thought of array rearrangement should click OR Why this method?\\n        We can easily solve this question using unordered_set but that will cost us O(n) space and we are expected to solve it in O(1) extra space hence\\n\\t\\twe have to somehow make use of existing space to get the answer and hence the thought of array rearrangment should click.\\n     \\n    Question-1: What is correct the place for an element in the rearranged array? \\n        For an element i its correct place is i-1 th index in the array.\\n        E.g. [5,3,4,1,2] -> [1,2,3,4,5] or [4,-2,5,3,0] -> [0,-2,3,4,5].\\n        \\n    Question-2: Which elements will not get its correct place OR which are `invalid` elements? \\n        1. Elements which are non-positive -> We do not have any index in the array to store them(Hence condition-1: nums[i] <= 0 then continue).\\n        2. If element is larger than array size -> We again do not have correct index to store such elements(Hence condition-2: nums[i] > sz then continue). \\n        3. Repeated elements -> As one index can hold only one correct element other repeated elements will have to be ignored (Hence condition-3: \\n\\t\\t   nums[nums[i]-1] == nums[i] means element with which we are swapping current element is already in its correct position so ignore).\\n        \\n    Question-3: How we will get the final answer?\\n        We will go through the modified array and find the first position(in or outside the array) which does not hold the correct element.\\n    */\\n    int firstMissingPositive(vector<int>& nums) {\\n        int sz = nums.size();\\n        for(int i=0;i<sz;i++) {\\n            while(nums[i] != i+1) {\\n                if(nums[i] <= 0 || nums[i] > sz || nums[nums[i]-1] == nums[i]) break;\\n                swap(nums[nums[i]-1], nums[i]);\\n            }\\n        }\\n        for(int i=0;i<sz;i++) if(nums[i] != i+1) return i+1;\\n        return sz+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    Algorithm- \\n    We will rearrange the array such that each `valid` element get its correct place and then search for the answer in rearranged array.\\n    \\n    Question-0: Why the thought of array rearrangement should click OR Why this method?\\n        We can easily solve this question using unordered_set but that will cost us O(n) space and we are expected to solve it in O(1) extra space hence\\n\\t\\twe have to somehow make use of existing space to get the answer and hence the thought of array rearrangment should click.\\n     \\n    Question-1: What is correct the place for an element in the rearranged array? \\n        For an element i its correct place is i-1 th index in the array.\\n        E.g. [5,3,4,1,2] -> [1,2,3,4,5] or [4,-2,5,3,0] -> [0,-2,3,4,5].\\n        \\n    Question-2: Which elements will not get its correct place OR which are `invalid` elements? \\n        1. Elements which are non-positive -> We do not have any index in the array to store them(Hence condition-1: nums[i] <= 0 then continue).\\n        2. If element is larger than array size -> We again do not have correct index to store such elements(Hence condition-2: nums[i] > sz then continue). \\n        3. Repeated elements -> As one index can hold only one correct element other repeated elements will have to be ignored (Hence condition-3: \\n\\t\\t   nums[nums[i]-1] == nums[i] means element with which we are swapping current element is already in its correct position so ignore).\\n        \\n    Question-3: How we will get the final answer?\\n        We will go through the modified array and find the first position(in or outside the array) which does not hold the correct element.\\n    */\\n    int firstMissingPositive(vector<int>& nums) {\\n        int sz = nums.size();\\n        for(int i=0;i<sz;i++) {\\n            while(nums[i] != i+1) {\\n                if(nums[i] <= 0 || nums[i] > sz || nums[nums[i]-1] == nums[i]) break;\\n                swap(nums[nums[i]-1], nums[i]);\\n            }\\n        }\\n        for(int i=0;i<sz;i++) if(nums[i] != i+1) return i+1;\\n        return sz+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371896,
                "title": "python-o-n-time-and-o-1-space-accepted-solution-with-explanation",
                "content": "**TECHNIQUE :**\\n\\nWhat we are going to use a simple trick that if we modify a element A as **A\\' =  A + (B * N)** (here A is smaller than N) then now we can obtain both the value A and B from this new A as : \\nA = A\\' % N and B = A\\' / N\\n\\nWe can use this technique here to use the current array as a hash array.\\n\\n**Approach :**\\n\\nIf we have an array of size say x then we can definitely say that our missing number will lie in range 1 to (x+1). So, we can modify the array so that ith number will get stored at ith cell. Then we can traverse through the array and the index at which arr[i] != i, will be our answer. In case, all are present, then we can check if n is present in original array or not, if yes then our answer will be (n+1) else our answer is n. \\n\\n**CODE :**\\n\\n```\\ndef missingNumber(self,arr,n):\\n\\t\\t/* variable to check if n is present in our array or not */\\n        hasN = False\\n        for i in range(0,n):\\n\\t\\t\\t# if n is present we update our boolean variable to True\\n            if arr[i] == n:\\n                hasN = True\\n\\t\\t\\t\\t\\n\\t\\t\\t# marking the useless elements as zero\\n            if arr[i]<=0 or arr[i]>=n:\\n                arr[i] = 0\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n        #using the above technique, we are updating the current array \\n\\t\\t\\t# so that arr[i] contains its original value as well as the desired value        \\n        for i in range(0,n):\\n            val = arr[i]%n\\n\\t\\t\\t\\n\\t\\t\\t# leaving the useless elements as well as\\n\\t\\t\\t# already updated elements\\n            if val==0 or arr[val]//n == val:\\n                continue\\n            arr[val] += val * n\\n        \\n        #simple check that updated arr[i] contains i or not\\n        for i in range(1,n):\\n            if arr[i]//n != i:\\n                return i\\n                \\n\\t\\t#in case 1 to n-1 are all present , we will check for n and n+1 using prev calculated hasN\\n        if hasN == True:\\n            return n+1\\n        else :\\n            return n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef missingNumber(self,arr,n):\\n\\t\\t/* variable to check if n is present in our array or not */\\n        hasN = False\\n        for i in range(0,n):\\n\\t\\t\\t# if n is present we update our boolean variable to True\\n            if arr[i] == n:\\n                hasN = True\\n\\t\\t\\t\\t\\n\\t\\t\\t# marking the useless elements as zero\\n            if arr[i]<=0 or arr[i]>=n:\\n                arr[i] = 0\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n        #using the above technique, we are updating the current array \\n\\t\\t\\t# so that arr[i] contains its original value as well as the desired value        \\n        for i in range(0,n):\\n            val = arr[i]%n\\n\\t\\t\\t\\n\\t\\t\\t# leaving the useless elements as well as\\n\\t\\t\\t# already updated elements\\n            if val==0 or arr[val]//n == val:\\n                continue\\n            arr[val] += val * n\\n        \\n        #simple check that updated arr[i] contains i or not\\n        for i in range(1,n):\\n            if arr[i]//n != i:\\n                return i\\n                \\n\\t\\t#in case 1 to n-1 are all present , we will check for n and n+1 using prev calculated hasN\\n        if hasN == True:\\n            return n+1\\n        else :\\n            return n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1291029,
                "title": "c-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        /*\\n        \\n        Lets say the size of the array is n\\n        We need to find the first missing positive number\\n        The range of values for this required number should be ? \\n        If the array is strictly increasing and starts with 1 then the missing number would be n+1;\\n        but if thats not the case then the first positive number should be in the range[1,n];\\n        \\n        algo should be:\\n        we can discard the negative and numbers greater than n.\\n        For the remaining numbers we can use them as index and\\n        mark the number in index position. \\n         One way to mark would be first replace negative number and number greater than n with n+1\\n         Then using marking technique mentioned convert the value to negative.\\n         \\n        After that iterate the array and return the first unmarked poition +1 value as the result.\\n        */\\n        \\n        if(nums.size()==1 && nums[0]<=0)\\n            return 1;\\n            \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=0 || nums[i] > nums.size()+1)\\n                nums[i]=nums.size()+1;            \\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(abs(nums[i]) > nums.size())continue;\\n            int idx = abs(nums[i])-1;\\n            \\n            if( nums[idx] > 0)\\n                nums[idx]=-nums[idx];\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0)\\n                return i+1;\\n        }\\n        return nums.size()+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        /*\\n        \\n        Lets say the size of the array is n\\n        We need to find the first missing positive number\\n        The range of values for this required number should be ? \\n        If the array is strictly increasing and starts with 1 then the missing number would be n+1;\\n        but if thats not the case then the first positive number should be in the range[1,n];\\n        \\n        algo should be:\\n        we can discard the negative and numbers greater than n.\\n        For the remaining numbers we can use them as index and\\n        mark the number in index position. \\n         One way to mark would be first replace negative number and number greater than n with n+1\\n         Then using marking technique mentioned convert the value to negative.\\n         \\n        After that iterate the array and return the first unmarked poition +1 value as the result.\\n        */\\n        \\n        if(nums.size()==1 && nums[0]<=0)\\n            return 1;\\n            \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=0 || nums[i] > nums.size()+1)\\n                nums[i]=nums.size()+1;            \\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(abs(nums[i]) > nums.size())continue;\\n            int idx = abs(nums[i])-1;\\n            \\n            if( nums[idx] > 0)\\n                nums[idx]=-nums[idx];\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0)\\n                return i+1;\\n        }\\n        return nums.size()+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060638,
                "title": "python-really-cool-solution-faster-than-99-32-o-n-time-o-1-memory",
                "content": "\\tclass Solution:\\n\\t\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\t\\tdef swap(nums: List[int], i: int, j: int):\\n\\t\\t\\t\\ttmp = nums[i]\\n\\t\\t\\t\\tnums[i] = nums[j]\\n\\t\\t\\t\\tnums[j] = tmp\\n\\t\\t\\t\\n\\t\\t\\tlength = len(nums)\\n\\t\\t\\tfor index in range(len(nums)):\\n\\t\\t\\t\\twhile( nums[index] > 0 and nums[index] <= length and nums[nums[index] - 1] != nums[index]):\\n\\t\\t\\t\\t\\tswap(nums, index, nums[index] - 1)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tfor index in range(len(nums)):\\n\\t\\t\\t\\tif nums[index] != index + 1: return index + 1\\n\\t\\t\\treturn length + 1",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\t\\tdef swap(nums: List[int], i: int, j: int):\\n\\t\\t\\t\\ttmp = nums[i]\\n\\t\\t\\t\\tnums[i] = nums[j]\\n\\t\\t\\t\\tnums[j] = tmp\\n\\t\\t\\t\\n\\t\\t\\tlength = len(nums)\\n\\t\\t\\tfor index in range(len(nums)):\\n\\t\\t\\t\\twhile( nums[index] > 0 and nums[index] <= length and nums[nums[index] - 1] != nums[index]):\\n\\t\\t\\t\\t\\tswap(nums, index, nums[index] - 1)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tfor index in range(len(nums)):\\n\\t\\t\\t\\tif nums[index] != index + 1: return index + 1\\n\\t\\t\\treturn length + 1",
                "codeTag": "Java"
            },
            {
                "id": 914496,
                "title": "c-o-n-time-o-1-space",
                "content": "Answer may be in [1, n] or it may be n + 1\\nElement bound [1, n]\\nIf there a element whose value is out of bound the the answer is between [1, n], else the answer is n + 1\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n\\t\\t// Checking if the answer is 1\\n        bool f = false;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                f = true;\\n                break;\\n            }\\n        }\\n        \\n        if(!f)\\n        {\\n            return 1;\\n        }\\n        // 1 is present so it doesn\\'t matter how many times it is present\\n        \\n\\t\\t// Making all the out of bound elements 1\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] < 1 || nums[i] > n)\\n            {\\n                nums[i] = 1;\\n            }\\n        }\\n        \\n\\t\\t// Hashing\\n        for(int i = 0; i < n; i++)\\n        {\\n            int c = abs(nums[i]);\\n            nums[c - 1] = -1 * abs(nums[c - 1]);\\n        }\\n        \\n\\t\\t// Checking\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] > 0)\\n            {\\n                return i + 1;\\n            }\\n        }\\n        \\n        \\n        return n + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n\\t\\t// Checking if the answer is 1\\n        bool f = false;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                f = true;\\n                break;\\n            }\\n        }\\n        \\n        if(!f)\\n        {\\n            return 1;\\n        }\\n        // 1 is present so it doesn\\'t matter how many times it is present\\n        \\n\\t\\t// Making all the out of bound elements 1\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] < 1 || nums[i] > n)\\n            {\\n                nums[i] = 1;\\n            }\\n        }\\n        \\n\\t\\t// Hashing\\n        for(int i = 0; i < n; i++)\\n        {\\n            int c = abs(nums[i]);\\n            nums[c - 1] = -1 * abs(nums[c - 1]);\\n        }\\n        \\n\\t\\t// Checking\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] > 0)\\n            {\\n                return i + 1;\\n            }\\n        }\\n        \\n        \\n        return n + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871583,
                "title": "c-two-pointers-o-n-with-swap",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int l = 0, r = nums.size() - 1;\\n        while(l < r)\\n        {\\n            if(l + 1 == nums[l])\\n                l++;\\n            else if(r + 1 == nums[r] || nums[r] <= 0 || nums[r] >= nums.size() || nums[nums[r] - 1] == nums[r])\\n                r--;\\n            else \\n                swap(nums[r], nums[nums[r] - 1]);\\n        }\\n        while(l < nums.size() && l + 1 == nums[l])\\n            l++;\\n        return l + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int l = 0, r = nums.size() - 1;\\n        while(l < r)\\n        {\\n            if(l + 1 == nums[l])\\n                l++;\\n            else if(r + 1 == nums[r] || nums[r] <= 0 || nums[r] >= nums.size() || nums[nums[r] - 1] == nums[r])\\n                r--;\\n            else \\n                swap(nums[r], nums[nums[r] - 1]);\\n        }\\n        while(l < nums.size() && l + 1 == nums[l])\\n            l++;\\n        return l + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 725846,
                "title": "python-easy-solution-with-comments",
                "content": "```py\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        # mark those elements who aren\\'t in the range of [1, n]\\n        for i in range(n):\\n            if nums[i] <= 0 or nums[i] > n:\\n                nums[i] = n + 1\\n        \\n        # mark visited elements as negative\\n        for i in range(n): \\n            if (abs(nums[i]) - 1 < n and nums[abs(nums[i]) - 1] > 0): \\n                nums[abs(nums[i]) - 1] = -nums[abs(nums[i]) - 1] \\n\\n        # find first positive/unmarked element and return its index\\n        for i in range(n): \\n            if (nums[i] > 0): \\n                return i + 1\\n        \\n        # if all elements are negative/marked means all elements are in the range of [1, n]\\n        return n + 1\\n```\\n\\nFor another approach, check out https://leetcode.com/problems/first-missing-positive/discuss/754516/O(1)-space-O(n)-time-Python-solution-by-placing-elements-to-their-right-position",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        # mark those elements who aren\\'t in the range of [1, n]\\n        for i in range(n):\\n            if nums[i] <= 0 or nums[i] > n:\\n                nums[i] = n + 1\\n        \\n        # mark visited elements as negative\\n        for i in range(n): \\n            if (abs(nums[i]) - 1 < n and nums[abs(nums[i]) - 1] > 0): \\n                nums[abs(nums[i]) - 1] = -nums[abs(nums[i]) - 1] \\n\\n        # find first positive/unmarked element and return its index\\n        for i in range(n): \\n            if (nums[i] > 0): \\n                return i + 1\\n        \\n        # if all elements are negative/marked means all elements are in the range of [1, n]\\n        return n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 364428,
                "title": "python-o-n-time-o-1-space-with-explanation",
                "content": "The key observation is that the smallest missing positive integer is NO MORE THAN n+1. Therefore, we can safely remove all the integers that are greater than n or less than 1, then all numbers in the list are less than or equal to n. By arranging each number in the new list to correspoding position(e.g. nums[0] = 1, nums[1] = 2 ...), we can spot the missing integer within O(n) time and O(1) space.\\n\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\n        i = 0\\n        while i < n:\\n            while 0 < nums[i] <= n and nums[i] != i + 1 and nums[nums[i] - 1] != nums[i]:\\n                # termination conditions:\\n                # 1. current number is less than zero or greater than n, leave it and check the next position\\n                # 2. current number is the right number\\n                # 3. the position corresponds to current number has already contain the right number\\n                # Otherwise, exchange between current position and the position corresponds to current number\\n\\t\\t\\t\\t\\n                tmp = nums[i]\\n                nums[i], nums[tmp - 1] = nums[tmp - 1], nums[i]\\n            i += 1\\n\\n        for i in range(n):\\n            if nums[i] != i + 1:\\n                return i + 1\\n        return n + 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\n        i = 0\\n        while i < n:\\n            while 0 < nums[i] <= n and nums[i] != i + 1 and nums[nums[i] - 1] != nums[i]:\\n                # termination conditions:\\n                # 1. current number is less than zero or greater than n, leave it and check the next position\\n                # 2. current number is the right number\\n                # 3. the position corresponds to current number has already contain the right number\\n                # Otherwise, exchange between current position and the position corresponds to current number\\n\\t\\t\\t\\t\\n                tmp = nums[i]\\n                nums[i], nums[tmp - 1] = nums[tmp - 1], nums[i]\\n            i += 1\\n\\n        for i in range(n):\\n            if nums[i] != i + 1:\\n                return i + 1\\n        return n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304741,
                "title": "cyclic-sort-o-n-runtime-0-ms-memory-usage-34-1-mb-java-with-comments",
                "content": "```\\nclass Solution {\\n    \\n\\tpublic int firstMissingPositive(int[] nums) {\\n       int i=0;\\n       // Convert the array to \"1 to n\" (example below) form using Cyclic Sort \\n       // and map +ve numbers to respective indices around negative numbers\\n       while(i < nums.length) {\\n         if(nums[i] > 0 // Skip negative numbers\\n         && nums[i] <= nums.length //Critical, so we do not want to go out of bound\\n         && nums[i] != nums[nums[i] - 1]) { // Cyclic Sort criteria\\n               swap (nums, i, nums[i] - 1);\\n         } else {\\n               ++i;\\n         }\\n       }\\n        \\n       // Example: For an input array [-3, 1, 5, 4, 2 ], the cyclic sorted \\n       // array after the above jumps will look like [1, 2, -3, 4, 5].\\n       // Looking at this we know the element after 2, i.e 3 is missing.\\n       for(i=0; i<nums.length; i++) {\\n           if(i+1 != nums[i]) {\\n               return i + 1;\\n           }\\n       }\\n        \\n       return i+1; // This will tc of all negative testcases like empty array etc\\n    }\\n\\t\\n\\tprivate static void swap (int [] nums, int a, int b) {\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n\\tpublic int firstMissingPositive(int[] nums) {\\n       int i=0;\\n       // Convert the array to \"1 to n\" (example below) form using Cyclic Sort \\n       // and map +ve numbers to respective indices around negative numbers\\n       while(i < nums.length) {\\n         if(nums[i] > 0 // Skip negative numbers\\n         && nums[i] <= nums.length //Critical, so we do not want to go out of bound\\n         && nums[i] != nums[nums[i] - 1]) { // Cyclic Sort criteria\\n               swap (nums, i, nums[i] - 1);\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 243173,
                "title": "java-solution-faster-than-100-o-1-space-and-o-n-time",
                "content": "We can assert the answer must be in [1, len + 1], the len is the length of input array. Because if the answer is greater than len + 1, then [1, 2, ...., len + 1] must be in the array, but the array of len length only can store [1, 2, ..., len]. \\nSo, first we can replace the zero or negative with len + 1, and that not change answer. then this problem similar with [find-all-numbers-disappeared-in-an-array](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/), [find-all-duplicates-in-an-array](https://leetcode.com/problems/find-all-duplicates-in-an-array/) :)\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int len = nums.length;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] <= 0) {\\n                nums[i] = len + 1;\\n            }\\n        }\\n        \\n        for (int i = 0; i < len; i++) {\\n            int n = Math.abs(nums[i]);\\n            if (n <= len && nums[n - 1] > 0) {\\n                nums[n - 1] *= -1;\\n            }\\n        }\\n        \\n        int first = len + 1;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] >= 0) {\\n                first = i + 1;\\n                break;\\n            }\\n        }\\n        \\n        return first;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int len = nums.length;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] <= 0) {\\n                nums[i] = len + 1;\\n            }\\n        }\\n        \\n        for (int i = 0; i < len; i++) {\\n            int n = Math.abs(nums[i]);\\n            if (n <= len && nums[n - 1] > 0) {\\n                nums[n - 1] *= -1;\\n            }\\n        }\\n        \\n        int first = len + 1;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] >= 0) {\\n                first = i + 1;\\n                break;\\n            }\\n        }\\n        \\n        return first;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 174383,
                "title": "o-n-time-o-1-space-without-swapping-with-explanation",
                "content": "## Idea:\\n1. Any element less than `0` or greater than `n` is useless, so change those to `0`\\n2. Track whether an element is present by making the element at the index negative\\n\\n## Steps:\\n1. Assign `0` to useless terms (`nums[i] < 0 || nums[i] > n`)\\n    - `[3,4,-1,1] -> [3,4,0,1]`\\n2. Treat each element as a pointer by making the element at that index negative (taking the absolute value to ignore whether we marked it as present). The one edge case is if the element is `0`: we point to itself since we assigned `0` to the useless elements.\\n\\t1. `nums[0] = 3: [3,4,0,1] -> [3,4,-3,1]` (the third element is 0 so we point to itself)\\n\\t2. `nums[1] = 4: [3,4,-3,1] -> [3,4,-3,-1]` (we negate the fourth element)\\n\\t3. `nums[2] = -3` (no change since the third element is already negative)\\n\\t4. `nums[3] = -1: [3,4,-3,-1] -> [-3,4,-3,-1]` (we negate the first element)\\n3. Return the correct index for the first element that is `>= 0`\\n\\n## Full solution:\\n```\\npublic int firstMissingPositive(int[] nums) {\\n    int n = nums.length;\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] < 0 || nums[i] > n) {\\n            nums[i] = 0;\\n        }\\n    }\\n\\n    for (int num : nums) {\\n        if (num != 0) {\\n            int index = Math.abs(num) - 1;\\n            if (nums[index] == 0) {\\n                nums[index] = -(index + 1);\\n            } else {\\n                nums[index] = -Math.abs(nums[index]);\\n            }\\n        }\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] >= 0) {\\n            return i + 1;\\n        }\\n    }\\n    return n + 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int firstMissingPositive(int[] nums) {\\n    int n = nums.length;\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] < 0 || nums[i] > n) {\\n            nums[i] = 0;\\n        }\\n    }\\n\\n    for (int num : nums) {\\n        if (num != 0) {\\n            int index = Math.abs(num) - 1;\\n            if (nums[index] == 0) {\\n                nums[index] = -(index + 1);\\n            } else {\\n                nums[index] = -Math.abs(nums[index]);\\n            }\\n        }\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] >= 0) {\\n            return i + 1;\\n        }\\n    }\\n    return n + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 170370,
                "title": "python-o-n-time-o-1-space-beats-100-changes-the-original-list",
                "content": "```\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        length = len(nums)\\n        k = 0\\n        \\n        # remove 0, negatives, and too large numbers\\n        for i, num in enumerate(nums):\\n            if num > 0 and num <= length:\\n                # move the positive integers up front\\n                nums[k] = num \\n                k += 1 \\n        \\n        # We manipulate the list up to the k-th index\\n        # We don\\'t care about the elements from indices (k+1)-th to length.\\n        # Now the nums[:k+1] only contains integers in the range 1 to k+1.\\n        # We treat the elements as the next indices. \\n        # When an element is reached, it is changed to be negative.\\n        # If the element is never reached, it\\'s gonna stay positive.\\n        # That is the first missing positive integer.\\n        for i in range(k):\\n            num = abs(nums[i])\\n            \\n            if nums[num-1] > 0:\\n                nums[num-1] *= -1\\n        \\n        for i in range(k):\\n            if nums[i] >= 0:\\n                return i+1\\n        \\n        return k+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        length = len(nums)\\n        k = 0\\n        \\n        # remove 0, negatives, and too large numbers\\n        for i, num in enumerate(nums):\\n            if num > 0 and num <= length:\\n                # move the positive integers up front\\n                nums[k] = num \\n                k += 1 \\n        \\n        # We manipulate the list up to the k-th index\\n        # We don\\'t care about the elements from indices (k+1)-th to length.\\n        # Now the nums[:k+1] only contains integers in the range 1 to k+1.\\n        # We treat the elements as the next indices. \\n        # When an element is reached, it is changed to be negative.\\n        # If the element is never reached, it\\'s gonna stay positive.\\n        # That is the first missing positive integer.\\n        for i in range(k):\\n            num = abs(nums[i])\\n            \\n            if nums[num-1] > 0:\\n                nums[num-1] *= -1\\n        \\n        for i in range(k):\\n            if nums[i] >= 0:\\n                return i+1\\n        \\n        return k+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996341,
                "title": "solution-explained-with-example-o-n-time-o-1-space",
                "content": "# Bruteforce\\nMark all the integers of array in separate array of n elements by updating corresponding value to 1 and then from start find index at which value is not 1 to identify the smallest missing positive integer.\\n\\n# Optimal Approach\\nHere we can\\'t mark all the integers as we only have O(1) auxiliary space. So, we will use the same array to mark the numbers. But you\\'ll think that how can we mark? There will be some number at each index. So, we will do this in loop until we reach the free space or come at begining, this way no data will be lost.\\n\\n# Example\\nArray : [5, 6, 2, 1, 2] => N = 5\\nPre Processing : We will remove all negatives integers and numbers greater than N by replacing them with 0.\\n0 = Represents position free to be marked, no loss of data.\\n-1 = Position already marked, integer present in input array.\\n\\nArray (current state) : [6, 0, 2, 1, 2] \\n\\nStart with Index: 0\\nRead number 5 and free up position(index: 0) by marking it with 0. Mark number 5 by replacing arr[5 - 1] with -1. In order to avoid loss of data at index 4, we will keep it in temp variable. After marking, we will do the same process for temp variable which is 1.\\n\\nArray (current state) : [-1, 0, 2, -1, 2] \\nInsights - Integer 1 and 5 was present in input array because they are marked in above array.\\n\\nIndex : 1\\nAlready 0. It\\'s free space and we can ignore it.\\n\\nIndex : 2\\n2 will be marked at arr[2 - 1] which is already free so no further processing.\\nArray (current state) : [-1, -1, 0, -1, 2]\\n\\nIndex : 3\\nNo data present to mark because it\\'s -1.\\n\\nIndex : 4\\n2 will be marked at arr[2 - 1], it\\'s already marked so we can either ignore or remark it.\\n\\nFinal array : [-1, -1, 0, -1, 0]\\n\\nTraverse the array and stop at first non -1 number. Here it will be index 2, So Integer 3 is missing.\\n\\nIf we don\\'t find any non -1 number then N + 1 will be the answer.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N) - Since we will come at every index only once.\\n\\n- Space complexity:\\nO(1) - No space is used other than few temporary variables.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // Remove negative and numbers greater than N, those are unwanted.\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < 0 || nums[i] > n) nums[i] = 0;\\n        }\\n\\n        // Starting from index 0, we will start marking.\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 0 || nums[i] == -1) continue;\\n\\n            int index = nums[i] - 1; // index is the position of number which needs to be updated\\n            nums[i] = 0; \\n            int temp;\\n            while (nums[index] > 0) {\\n                temp = nums[index];\\n                nums[index] = -1;\\n                index = temp - 1;\\n            }\\n            nums[index] = -1;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] != -1) return i + 1;\\n        }\\n        return n + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // Remove negative and numbers greater than N, those are unwanted.\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < 0 || nums[i] > n) nums[i] = 0;\\n        }\\n\\n        // Starting from index 0, we will start marking.\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 0 || nums[i] == -1) continue;\\n\\n            int index = nums[i] - 1; // index is the position of number which needs to be updated\\n            nums[i] = 0; \\n            int temp;\\n            while (nums[index] > 0) {\\n                temp = nums[index];\\n                nums[index] = -1;\\n                index = temp - 1;\\n            }\\n            nums[index] = -1;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] != -1) return i + 1;\\n        }\\n        return n + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738172,
                "title": "java-solution-using-min-heap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n    PriorityQueue <Integer> minHeap = new PriorityQueue<>();\\n    // Add all the positive numbers in the PriorityQueue\\n    for(int i = 0; i < nums.length; i ++) {\\n        if(nums[i] > 0) minHeap.add(nums[i]);\\n    }\\n    int minMissing = 1;\\n    // Check for all minimum missing positive number\\n    while(! minHeap.isEmpty()) {\\n        int element = minHeap.poll();\\n        if(element == minMissing) minMissing ++;\\n        else if(element > minMissing) break;\\n    }\\n    return minMissing;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n    PriorityQueue <Integer> minHeap = new PriorityQueue<>();\\n    // Add all the positive numbers in the PriorityQueue\\n    for(int i = 0; i < nums.length; i ++) {\\n        if(nums[i] > 0) minHeap.add(nums[i]);\\n    }\\n    int minMissing = 1;\\n    // Check for all minimum missing positive number\\n    while(! minHeap.isEmpty()) {\\n        int element = minHeap.poll();\\n        if(element == minMissing) minMissing ++;\\n        else if(element > minMissing) break;\\n    }\\n    return minMissing;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718092,
                "title": "easy-detailed-c-o-n-time-complexity-o-1-space-complexity-solution-beats-100",
                "content": "# Intuition\\nHashmap\\n\\n# Approach\\n1. shift all the negative numbers to the rightmost side using two pointers\\n\\n2. Use index as hashmap to check which positive number is missing\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        //Complexities - \\n        //time complexity O(n)\\n        //space complexity O(1)\\n        \\n        //Code improvement suggestion -\\n        //revert back the changes done to the array after getting the min missing positive number\\n\\n        //steps used - \\n        // 1. shift all the negative numbers to the rightmost side using two pointers\\n\\n\\n        //2. Use index as hashmap to check which positive number is missing\\n\\n        int maxElement = 0;\\n        int l = nums.size()-1;\\n        int r = nums.size() -1;\\n\\n        while(r>=0) {\\n            if(nums[r]<=0) {\\n                swap(nums[l], nums[r]);\\n                l--;\\n            }\\n            if(nums[r] > maxElement) {\\n                maxElement = nums[r];\\n            }\\n            r--;\\n        }\\n\\n          // l contains the location of last positive integer\\n          for(int i =0; i <=l; i++) {\\n              if( (abs(nums[i]) - 1) <=l && nums[abs(nums[i]) - 1] > 0) {\\n                  nums[abs(nums[i]) - 1] = 0 - nums[abs(nums[i]) - 1];\\n              }\\n          }\\n\\n          //any the number till l position if found postive the index value + 1 will be the first missing positive integer  \\n          for(int i =0; i <=l; i++) {\\n              if(nums[i] >0) {\\n                  return i+1;\\n              }\\n          }\\n\\n          // if we did not find out any missing number in seq that means whatever is the max positive integer till now + 1 will be the first missing posyive number  \\n          return maxElement+1;  \\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        //Complexities - \\n        //time complexity O(n)\\n        //space complexity O(1)\\n        \\n        //Code improvement suggestion -\\n        //revert back the changes done to the array after getting the min missing positive number\\n\\n        //steps used - \\n        // 1. shift all the negative numbers to the rightmost side using two pointers\\n\\n\\n        //2. Use index as hashmap to check which positive number is missing\\n\\n        int maxElement = 0;\\n        int l = nums.size()-1;\\n        int r = nums.size() -1;\\n\\n        while(r>=0) {\\n            if(nums[r]<=0) {\\n                swap(nums[l], nums[r]);\\n                l--;\\n            }\\n            if(nums[r] > maxElement) {\\n                maxElement = nums[r];\\n            }\\n            r--;\\n        }\\n\\n          // l contains the location of last positive integer\\n          for(int i =0; i <=l; i++) {\\n              if( (abs(nums[i]) - 1) <=l && nums[abs(nums[i]) - 1] > 0) {\\n                  nums[abs(nums[i]) - 1] = 0 - nums[abs(nums[i]) - 1];\\n              }\\n          }\\n\\n          //any the number till l position if found postive the index value + 1 will be the first missing positive integer  \\n          for(int i =0; i <=l; i++) {\\n              if(nums[i] >0) {\\n                  return i+1;\\n              }\\n          }\\n\\n          // if we did not find out any missing number in seq that means whatever is the max positive integer till now + 1 will be the first missing posyive number  \\n          return maxElement+1;  \\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693801,
                "title": "first-missing-positive-using-c-with-time-o-n-memory-o-1",
                "content": "# Intuition\\nCan we solve this problem in-place or without using extra space? \\n# Approach\\nThe approach described is known as the \"Cyclic Sort\" algorithm, which is used to solve the problem of finding the first missing positive number in an array without using extra space. It involves rearranging the elements in the array by swapping them into their correct positions.\\n\\nThe algorithm works as follows:\\n1. Iterate through the array from the start.\\n2. Check if the current number, X[i], is within the range of 1 to n and if it is not already present at index X[i] - 1.\\n3. If the conditions are met, swap X[i] with the number present at the index X[i] - 1.\\n4. Continue the process until the array is fully traversed.\\n\\nAfter the sorting is done, the next step is to scan the modified array again to find the first index where X[i] is not equal to i + 1. This indicates the presence of a missing positive number. If such an index is found, return i + 1 as the first missing positive. If no such index is found, it means all numbers from 1 to n are present in the array, so return the value n + 1 as the first missing positive.\\n\\nThis algorithm solves the problem in-place, meaning it rearranges the elements within the original array without requiring additional space.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int i = 0;\\n        while(i<nums.size()){\\n            if(nums[i] > 0 && nums[i] <= nums.size() && nums[nums[i]-1] != nums[i]){\\n                swap(nums[i], nums[nums[i]-1]);\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        for (int i = 0; i < nums.size(); i++) {\\n            if(nums[i] != i+1){\\n                return i+1;\\n            }\\n        }\\n\\n        return nums.size() + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int i = 0;\\n        while(i<nums.size()){\\n            if(nums[i] > 0 && nums[i] <= nums.size() && nums[nums[i]-1] != nums[i]){\\n                swap(nums[i], nums[nums[i]-1]);\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        for (int i = 0; i < nums.size(); i++) {\\n            if(nums[i] != i+1){\\n                return i+1;\\n            }\\n        }\\n\\n        return nums.size() + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618414,
                "title": "easy-peasy-c-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        unordered_set<int> st;\\n        for(auto x: nums) st.insert(x);\\n        for(int i=1; ;i++){\\n            if(st.find(i)==st.end()) return i;\\n        }\\n        return 0;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        unordered_set<int> st;\\n        for(auto x: nums) st.insert(x);\\n        for(int i=1; ;i++){\\n            if(st.find(i)==st.end()) return i;\\n        }\\n        return 0;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505754,
                "title": "beginner-friendly-approach-usinf-hashsets-basic-trick",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nintuition was to solve the problem with the help of sets in one loops\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ni stored the value in sets ,because sets automatically arrange it in increasing order making it very easy to solve.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        set<int> data;\\n        int n=nums.size();\\n        for(int x=0;x<n;x++)\\n        {\\n            data.insert(nums[x]);\\n        }\\n        int i=1;\\n        while(i<=n)\\n        {\\n            if(data.find(i)!=data.end()) i++;\\n            else return i;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        set<int> data;\\n        int n=nums.size();\\n        for(int x=0;x<n;x++)\\n        {\\n            data.insert(nums[x]);\\n        }\\n        int i=1;\\n        while(i<=n)\\n        {\\n            if(data.find(i)!=data.end()) i++;\\n            else return i;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447629,
                "title": "c-sorting-easy-10-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply sort the array and keep a current positive count , If you able to get it increment current positive else return it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.) Set curPos i.e. count for current positive to 1.\\n2.) Now  sort the array \\n3.)Then simply iterate the array , If you find it increment curPos and search in remaining array\\n4.) If you don\\'t find it i.e. i reaches to n-1(size-1) simply return curPos because it is missing in the array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*logN) -> sorting the array\\nO(N)->for searching \\n\\nTotal = O(NlogN + N) = O(N(logN+1))= O(N*logN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) -> no extra space used \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end()); // to sort the array \\n\\n        int curPos=1; // sets current Positive to 1 \\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]==curPos) curPos++;\\n        }\\n\\n        return curPos;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end()); // to sort the array \\n\\n        int curPos=1; // sets current Positive to 1 \\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]==curPos) curPos++;\\n        }\\n\\n        return curPos;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297321,
                "title": "first-missing-positive-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        for(int i=0 ; i<nums.length; ) {\\n\\t\\t\\tif(nums[i]<=0 || nums[i]>=nums.length || nums[i]-1== i || nums[i]==nums[nums[i]-1] )i++;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tint index= nums[i]-1; \\n\\t\\t\\t    int temp = nums[index]; \\n\\t\\t\\t\\tnums[index]= nums[i];\\n\\t\\t\\t\\tnums[i]= temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor(int i=0 ; i<nums.length ; i++) {\\n\\t\\t\\tif(nums[i]-1!=i) {\\n\\t\\t\\t\\treturn i+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn nums.length+1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        for(int i=0 ; i<nums.length; ) {\\n\\t\\t\\tif(nums[i]<=0 || nums[i]>=nums.length || nums[i]-1== i || nums[i]==nums[nums[i]-1] )i++;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tint index= nums[i]-1; \\n\\t\\t\\t    int temp = nums[index]; \\n\\t\\t\\t\\tnums[index]= nums[i];\\n\\t\\t\\t\\tnums[i]= temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor(int i=0 ; i<nums.length ; i++) {\\n\\t\\t\\tif(nums[i]-1!=i) {\\n\\t\\t\\t\\treturn i+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn nums.length+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290473,
                "title": "fast-and-simple-python3-no-modification",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        visited = {n for n in nums if n > 0 and n < 100_001}\\n        smallest = 1\\n        while smallest in visited:\\n            smallest += 1\\n        return smallest\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        visited = {n for n in nums if n > 0 and n < 100_001}\\n        smallest = 1\\n        while smallest in visited:\\n            smallest += 1\\n        return smallest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138111,
                "title": "c-beginner-friendly-small-and-readable-code-hard-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe used simple hash table to find it \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n    int p=nums.size()+1;\\n    vector<int> a(p,0);\\n    int i,j;\\n// to fill hashtable with 1\\n    for(i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]>0 && nums[i]<nums.size()+1)\\n        a[nums[i]]++;\\n    }\\n    //to find the no.\\n    for(i=1;i<nums.size()+1;i++)\\n    {\\n        if(a[i]==0) return i;\\n    }\\n\\n    return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n    int p=nums.size()+1;\\n    vector<int> a(p,0);\\n    int i,j;\\n// to fill hashtable with 1\\n    for(i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]>0 && nums[i]<nums.size()+1)\\n        a[nums[i]]++;\\n    }\\n    //to find the no.\\n    for(i=1;i<nums.size()+1;i++)\\n    {\\n        if(a[i]==0) return i;\\n    }\\n\\n    return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126783,
                "title": "c-solved-explained-with-o-n-time-and-uses-constant-extra-space",
                "content": "# Explanation\\nThe idea is to use the index of the array to store the value of the number in the array. For example, if the input array is [3, 4, -1, 1], we can use the index 0 to store 1, index 1 to store 2, index 2 to store 3 and so on.\\n\\nTo do this, we need to first separate the positive numbers from the negative numbers. Then, for each positive number, we use its value as the index to store its corresponding value in the array.\\n\\nAfter separating the positive numbers and rearranging the array, the first missing positive number will be the first position in the array that does not contain its corresponding value.\\n\\n# Use of Loops\\nIn the first loop, we separate the positive numbers from the negative numbers. We use while loop to swap the value of the current number with its corresponding value in the array until the current number is not in its correct position.\\n\\nIn the second loop, we find the first missing positive number. The first position in the array that does not contain its corresponding value is the first missing positive number. If all the positions contain their corresponding values, then the missing positive number is n+1.\\n\\nHere is the code in C++:\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        // separate the positive numbers from the negative numbers\\n        for (int i=0;i<n;i++) \\n            while (nums[i]>0 && nums[i]<=n && nums[nums[i]-1]!=nums[i])\\n                swap(nums[i],nums[nums[i]-1]);\\n        // find the first missing positive number\\n        for (int i=0;i<n;i++)\\n            if (nums[i]!=i+1)\\n                return i+1;\\n        return n+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        // separate the positive numbers from the negative numbers\\n        for (int i=0;i<n;i++) \\n            while (nums[i]>0 && nums[i]<=n && nums[nums[i]-1]!=nums[i])\\n                swap(nums[i],nums[nums[i]-1]);\\n        // find the first missing positive number\\n        for (int i=0;i<n;i++)\\n            if (nums[i]!=i+1)\\n                return i+1;\\n        return n+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971735,
                "title": "java-1ms-o-n-100-50mb-o-1-85-10-code-with-full-explanation-using-bits",
                "content": "Please Upvote if it helps! \\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        // O(n) time, O(1) space;\\n        int n = nums.length, size = 0;\\n        // -> Since: max(min integer not in nums ) <= n+1\\n        // -> we find the number of bits i.e. (size) of n\\n        // -> we know that no number <= n will have (size)th bit to 1\\n        // therefore we set the (size)th bit of the i to 1 if there exists\\n        // nums[j] such that nums[j] = i.\\n        // -> this set bit will be used in the final iteration as the judging criteria\\n        // -> for all values <=0 && values > n, we first partition them \\n\\t\\t//and then we set them to zero so that there does not arrive any conflict of  (size)th bit = 1 beforehand.\\n        // -> I have used zero indexing so if we have nums[j] = 1,\\n        // (size)th bit of nums[0] will be set to 1 and not of nums[1]\\n\\n        \\n        // CODE:        \\n        \\n        //calculating the variable size:\\n        while(n > 0){\\n            n = n>>1;\\n            size++;\\n        }\\n        n = nums.length;\\n        int pivot = 0;\\n        \\n        // using partitioning to partition values not to be included in the array (negatives, zeros, and values > n):\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] <= 0 || nums[i] > n){\\n                int temp = nums[i];\\n                nums[i] = nums[pivot];\\n                nums[pivot] = temp;\\n                pivot++;\\n            }\\n        }\\n        // setting all bits to zero for values not in range 1 - n:\\n        for(int i= 0; i < pivot; i++)\\n            nums[i] = 0;\\n        //setting the (size)th bit to 1 for all values in range\\n        for(int i= pivot; i < n; i++){\\n            nums[(nums[i] - 1)&((1<<size) - 1)] |= (1<<size);\\n        }\\n        //final checking condition iteration\\n        for(int i= 0; i < n; i++)\\n            if((nums[i] & (1<<size)) == 0)\\n                return i+1;\\n        //if all 1-n are present, then we return n+1\\n        return n+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        // O(n) time, O(1) space;\\n        int n = nums.length, size = 0;\\n        // -> Since: max(min integer not in nums ) <= n+1\\n        // -> we find the number of bits i.e. (size) of n\\n        // -> we know that no number <= n will have (size)th bit to 1\\n        // therefore we set the (size)th bit of the i to 1 if there exists\\n        // nums[j] such that nums[j] = i.\\n        // -> this set bit will be used in the final iteration as the judging criteria\\n        // -> for all values <=0 && values > n, we first partition them \\n\\t\\t//and then we set them to zero so that there does not arrive any conflict of  (size)th bit = 1 beforehand.\\n        // -> I have used zero indexing so if we have nums[j] = 1,\\n        // (size)th bit of nums[0] will be set to 1 and not of nums[1]\\n\\n        \\n        // CODE:        \\n        \\n        //calculating the variable size:\\n        while(n > 0){\\n            n = n>>1;\\n            size++;\\n        }\\n        n = nums.length;\\n        int pivot = 0;\\n        \\n        // using partitioning to partition values not to be included in the array (negatives, zeros, and values > n):\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] <= 0 || nums[i] > n){\\n                int temp = nums[i];\\n                nums[i] = nums[pivot];\\n                nums[pivot] = temp;\\n                pivot++;\\n            }\\n        }\\n        // setting all bits to zero for values not in range 1 - n:\\n        for(int i= 0; i < pivot; i++)\\n            nums[i] = 0;\\n        //setting the (size)th bit to 1 for all values in range\\n        for(int i= pivot; i < n; i++){\\n            nums[(nums[i] - 1)&((1<<size) - 1)] |= (1<<size);\\n        }\\n        //final checking condition iteration\\n        for(int i= 0; i < n; i++)\\n            if((nums[i] & (1<<size)) == 0)\\n                return i+1;\\n        //if all 1-n are present, then we return n+1\\n        return n+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805417,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] <= 0 or nums[i] > n) {\\n                nums[i] = n+1;\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(abs(nums[i]) > n) continue;\\n            int id = abs(nums[i]);\\n            nums[id-1] = -1 * abs(nums[id-1]);\\n        }\\n        int ans = n + 1;\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] > 0) {\\n                ans = i+1;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }  \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] <= 0 or nums[i] > n) {\\n                nums[i] = n+1;\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(abs(nums[i]) > n) continue;\\n            int id = abs(nums[i]);\\n            nums[id-1] = -1 * abs(nums[id-1]);\\n        }\\n        int ans = n + 1;\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] > 0) {\\n                ans = i+1;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792059,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n,,,\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\t\\tint k=1;\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\t\\t\\tif(k==nums[i]){\\n\\t\\t\\t\\t\\tk++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn k;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\t\\tint k=1;\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\t\\t\\tif(k==nums[i]){\\n\\t\\t\\t\\t\\tk++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2649319,
                "title": "javascript-fully-explained-solution-with-o-1-space-and-o-n-time-and-faster-than-99-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar firstMissingPositive = function(nums) {\\n    // In this approach we will loop through array and if we find element is in\\n    // range (1 to n) then swap the elemnt with index equal to its value-1.\\n    // example--> if 2 is element then swap 2 with index 2-1 or(1)\\'s value . Notice that if \\n    //another duplicate 2 is already present at index then no need to swap.\\n    let n=nums.length;\\n    let index;\\n    let element;\\n    let temp;\\n    // run a loop through the given array\\n    for(let i=0;i<n;i++){\\n        // if element is from 1 to n.\\n        if(nums[i]>=1 && nums[i]<=n){\\n            element=nums[i];\\n            index=element-1;\\n            // if element is not at correct index swap it.\\n            if(nums[index]!=element){\\n                   temp=nums[index];\\n                   nums[index]=element;\\n                   nums[i]=temp;\\n                   i--;\\n            }\\n        }\\n    }\\n\\n    // run a loop and find if index i has value=i+1. if not return i+1(because it will\\n    // be the first missing positive number)\\n    for(let i=0;i<n;i++){\\n        if(nums[i]!=i+1){\\n            return i+1;\\n        }\\n    }\\n\\n    // if all elements are found till length of array then return length+1.\\n    return n+1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar firstMissingPositive = function(nums) {\\n    // In this approach we will loop through array and if we find element is in\\n    // range (1 to n) then swap the elemnt with index equal to its value-1.\\n    // example--> if 2 is element then swap 2 with index 2-1 or(1)\\'s value . Notice that if \\n    //another duplicate 2 is already present at index then no need to swap.\\n    let n=nums.length;\\n    let index;\\n    let element;\\n    let temp;\\n    // run a loop through the given array\\n    for(let i=0;i<n;i++){\\n        // if element is from 1 to n.\\n        if(nums[i]>=1 && nums[i]<=n){\\n            element=nums[i];\\n            index=element-1;\\n            // if element is not at correct index swap it.\\n            if(nums[index]!=element){\\n                   temp=nums[index];\\n                   nums[index]=element;\\n                   nums[i]=temp;\\n                   i--;\\n            }\\n        }\\n    }\\n\\n    // run a loop and find if index i has value=i+1. if not return i+1(because it will\\n    // be the first missing positive number)\\n    for(let i=0;i<n;i++){\\n        if(nums[i]!=i+1){\\n            return i+1;\\n        }\\n    }\\n\\n    // if all elements are found till length of array then return length+1.\\n    return n+1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2391396,
                "title": "c-o-n-and-o-1-with-detail-explanation",
                "content": "\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        /*\\n            1. reorder nums to keep 1 in index 1, 2 in index 2 ... \\n                 3,4,-1,1 -> 1,-1,3,4\\n                 1,2,0 -> 1,2,0\\n                 7,8,9,11,12 -> 7,8,9,11,12\\n                algorithm: keep swapping if num in [1, N], if the two nums doesn\\'t equal\\n            2. the one missing in expected place is the missing one\\n        */\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            while (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1] ) {\\n                swap(nums[nums[i] - 1], nums[i]);\\n            } \\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] != i + 1)\\n                return i + 1;\\n        }\\n        // if it is already ordered, e.g. [1,2], [1], [1,2,3]\\n        return n + 1;\\n        \\n    }\\n};\\n```\\n\\nTime: O(n)\\n\\nSpace: O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        /*\\n            1. reorder nums to keep 1 in index 1, 2 in index 2 ... \\n                 3,4,-1,1 -> 1,-1,3,4\\n                 1,2,0 -> 1,2,0\\n                 7,8,9,11,12 -> 7,8,9,11,12\\n                algorithm: keep swapping if num in [1, N], if the two nums doesn\\'t equal\\n            2. the one missing in expected place is the missing one\\n        */\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            while (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1] ) {\\n                swap(nums[nums[i] - 1], nums[i]);\\n            } \\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] != i + 1)\\n                return i + 1;\\n        }\\n        // if it is already ordered, e.g. [1,2], [1], [1,2,3]\\n        return n + 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289046,
                "title": "explanation-for-o-n-time-and-o-1-space-complexity-solution-c",
                "content": "Firstly, we need to understand that **answer is going to lie among the first n + 1 positive integers**: \\nReason: \\nThe array can have at most n unique positive integers. Now if any of the positive numbers in the range [1, n] are missing in the array then our answer will be the smallest of those. In case all the integers in the range [1, n] are present, then the array has all its indices filled with the integers in the range[1, n] and so the answer will be n + 1.\\n\\nNow I think the easiest approach to come up with is to use a HashMap or HashSet to store the elements of the array and then check for the first n + 1 integers if they are present or not. Even though this approach is O(n) in time, it is pretty slow, because of the time it takes for the hashing operation. Also, the space complexity of the solution is O(n). As clearly mentioned in the problem statement, we can do better. \\n\\nThe main idea of the above approach was to somehow distinguish between the numbers that are present in the array vs the numbers that are not present in the array.\\n\\nWe can still use the same idea but implement it in a better way. \\n\\nFor every element in the array, if it is in not in the range[1, n] we can replace it with n + 2, since these numbers don\\'t really matter. \\nNow the array consists of elements that are either in the range [1, n] or n + 2.\\nFor every element in the array that is in the range [1, n], we can make the element in the array at (position = element - 1) negative\\ni.e. make sure that arr[arr[i] - 1] is negative for every i such that arr[i] belongs to [1, n].\\nthis way we would be able to distinguish between elements that are present in the array ( as for x, in range [1, n] if it is present in the array then arr[x - 1] would be negative, otherwise it will be positive), vs the numbers that are not present in the array. We can then loop from 1 to n, and then check if the corresponding index is negative or positive to check if the element exists in the array.\\n\\nMy Code:\\n```cpp\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i = 0; i < n; ++i)\\n            if(nums[i] <= 0 || nums[i] > n)\\n                nums[i] = n + 2;\\n        for(int i = 0; i < n; ++i){\\n            if(abs(nums[i]) == n + 2)\\n                continue;\\n            if(nums[abs(nums[i]) - 1] > 0)\\n                nums[abs(nums[i]) - 1] *= -1;\\n        }\\n        for(int i = 0; i < n; ++i){\\n            if(nums[i] > 0)\\n                return i + 1;\\n        }\\n        return n + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i = 0; i < n; ++i)\\n            if(nums[i] <= 0 || nums[i] > n)\\n                nums[i] = n + 2;\\n        for(int i = 0; i < n; ++i){\\n            if(abs(nums[i]) == n + 2)\\n                continue;\\n            if(nums[abs(nums[i]) - 1] > 0)\\n                nums[abs(nums[i]) - 1] *= -1;\\n        }\\n        for(int i = 0; i < n; ++i){\\n            if(nums[i] > 0)\\n                return i + 1;\\n        }\\n        return n + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232826,
                "title": "c-2-easiest-approaches-tc-o-n-space-o-1-easy-problem",
                "content": "**Approach 1**\\nTime complexity : **`O(N)`**\\nSpace Complexity : **`O(1)`**\\n\\n----\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // Cyclic sort \\n    // Arr :      [1,2,3,4,5,6] \\n    // indices :  [0,1,2,3,4,5]   arr[i] == i+1               \\n    int firstMissingPositive(vector<int>&nums) \\n    {\\n        int i = 0;\\n        int n = nums.size();\\n        while(i < n)\\n        {\\n            if(nums[i] > 0 and nums[i] <= n && nums[i] != nums[nums[i] - 1]){\\n                swap(nums,i,nums[i] - 1);\\n            }\\n            else\\n                i++;\\n        }\\n        \\n        for(i=0;i<n;i++){\\n            if(nums[i] != i + 1){\\n                return (i + 1); // missing positive number \\n            }\\n        }\\n        return n + 1; // [1,2,3] , ans  = 4 (missing positive integers)\\n    }\\n    \\n    void swap(vector<int>&nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n};\\n```\\n\\n\\n**Approach 2** \\nTime complexity : **`O(N)`**\\nSpace Complexity : **`O(N)`**\\n\\n----\\n```\\nclass Solution {\\npublic:\\n    \\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<bool>res(n+1, 0);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] > 0 and nums[i] <= n) // positive number inside the range 0 to n\\n            {\\n                res[nums[i]] = true;\\n            }   \\n        }\\n        \\n        // Indices start from 0 to n-1\\n        //  Number start from 1 to n\\n        for(int i=1;i<res.size();i++)\\n        {\\n            if(!res[i])  // first positive number that is false\\n                return i;\\n        }\\n        return (n+1);\\n    }\\n};\\n```\\n*Thanks for upvoting !*\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Cyclic sort \\n    // Arr :      [1,2,3,4,5,6] \\n    // indices :  [0,1,2,3,4,5]   arr[i] == i+1               \\n    int firstMissingPositive(vector<int>&nums) \\n    {\\n        int i = 0;\\n        int n = nums.size();\\n        while(i < n)\\n        {\\n            if(nums[i] > 0 and nums[i] <= n && nums[i] != nums[nums[i] - 1]){\\n                swap(nums,i,nums[i] - 1);\\n            }\\n            else\\n                i++;\\n        }\\n        \\n        for(i=0;i<n;i++){\\n            if(nums[i] != i + 1){\\n                return (i + 1); // missing positive number \\n            }\\n        }\\n        return n + 1; // [1,2,3] , ans  = 4 (missing positive integers)\\n    }\\n    \\n    void swap(vector<int>&nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<bool>res(n+1, 0);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] > 0 and nums[i] <= n) // positive number inside the range 0 to n\\n            {\\n                res[nums[i]] = true;\\n            }   \\n        }\\n        \\n        // Indices start from 0 to n-1\\n        //  Number start from 1 to n\\n        for(int i=1;i<res.size();i++)\\n        {\\n            if(!res[i])  // first positive number that is false\\n                return i;\\n        }\\n        return (n+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075835,
                "title": "cpp-fully-explained-o-1-space-o-n-time-70-faster-solution",
                "content": "```\\nEXPLANATION :\\n    \\n1) I just tried to put every number num: from 1-N, in the (num-1)th position.\\n2) So I just stored the arr[i] in the variable \\'in\\' and swapped arr[in-1] with arr[i].\\n3) Swapped it until I got repetations or arr[i]<=0 or arr[i]>n.\\n4) Did this for every number in the array.\\n5) After that just checked for the number which is not in the (num-1)th position\\n6) If no such number found that simply mean that Every number from 1-N are present in it\\'s position, so return N+1\\n\\nCOMPLEXITY ANALYSIS:\\nTIME: O(N) ,  SPACE: O(1)\\n    \\n    \\nKINDLY DO UPVOTE IF YOU UNDERSTAND MY SOLUTION\\nCOMMENT DOWN IF YOU HAVE ANY DOUBT\\n\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int firstMissingPositive(vector<int>& arr) {\\n        ll n=arr.size();\\n        for(ll i=0;i<n;i++){\\n            ll in=-1;\\n            while(1){\\n                if((ll)arr[i]-1==in || arr[i]>n || arr[i]<=0) break;\\n                in=arr[i]-1;\\n                swap(arr[i],arr[in]);\\n            }\\n        }\\n        for(ll i=0;i<n;i++){\\n            if((ll)arr[i]-1!=i) return (int)i+1;\\n        }\\n        return (int)n+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nEXPLANATION :\\n    \\n1) I just tried to put every number num: from 1-N, in the (num-1)th position.\\n2) So I just stored the arr[i] in the variable \\'in\\' and swapped arr[in-1] with arr[i].\\n3) Swapped it until I got repetations or arr[i]<=0 or arr[i]>n.\\n4) Did this for every number in the array.\\n5) After that just checked for the number which is not in the (num-1)th position\\n6) If no such number found that simply mean that Every number from 1-N are present in it\\'s position, so return N+1\\n\\nCOMPLEXITY ANALYSIS:\\nTIME: O(N) ,  SPACE: O(1)\\n    \\n    \\nKINDLY DO UPVOTE IF YOU UNDERSTAND MY SOLUTION\\nCOMMENT DOWN IF YOU HAVE ANY DOUBT\\n\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int firstMissingPositive(vector<int>& arr) {\\n        ll n=arr.size();\\n        for(ll i=0;i<n;i++){\\n            ll in=-1;\\n            while(1){\\n                if((ll)arr[i]-1==in || arr[i]>n || arr[i]<=0) break;\\n                in=arr[i]-1;\\n                swap(arr[i],arr[in]);\\n            }\\n        }\\n        for(ll i=0;i<n;i++){\\n            if((ll)arr[i]-1!=i) return (int)i+1;\\n        }\\n        return (int)n+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014426,
                "title": "very-clearly-explained-solution-in-python-easy-to-understand",
                "content": "A problem requiring O(n) time and constant extra space, **really hard**!\\n\\nUse the original **input list to work as a hashmap**!\\nWe will let:\\n**mark the value of that index as negative** <=> **mark that index as visited**\\n\\nI will **explain step by step** using an example:\\n[3 4 -1 1]\\n\\n**1. First**, we should know that the first missing positive should be **at most len(list) + 1**,\\n(for example, input list:[1 2 3 4], first missing positive is 5).\\n\\n**2. In the first loop** of the array list, we let number that are not in the range 1:n be n + 1.\\nIn the example:\\n[3 4 -1 1] -> [3 4 5 1]\\n\\n**3. In the second loop**, for every number, if its original value is not equal to n + 1, make it opposite.\\nIn the example:\\n[3 4 5 1]\\n-> [3 4 -5 1] (integer 3 exists, value of index 2 negative)\\n-> [3 4 -5 -1] (integer 4 exists, value of index 3 negative)\\n-> [3 4 -5 -1] (integer 5 equals n + 1, continue)\\n-> [-3 4 -5 -1] (integer 1 exists, value of index 0 negative)\\n\\n**4. In the last loop**, find the first index whose value is positive.\\n\\n**TIme:** O(n)\\n**Space:** O(1)\\n\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n        \\n        for i in range(n):\\n            if nums[i] <= 0 or nums[i] > n:\\n                nums[i] = n + 1\\n        \\n        for i in range(n): \\n            a = abs(nums[i])\\n\\n            if a == n + 1:\\n                continue\\n            \\n            nums[a - 1] = - abs(nums[a - 1])\\n            \\n        for i in range(n):\\n            if nums[i] > 0:\\n                return i + 1\\n            \\n        return n + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n        \\n        for i in range(n):\\n            if nums[i] <= 0 or nums[i] > n:\\n                nums[i] = n + 1\\n        \\n        for i in range(n): \\n            a = abs(nums[i])\\n\\n            if a == n + 1:\\n                continue\\n            \\n            nums[a - 1] = - abs(nums[a - 1])\\n            \\n        for i in range(n):\\n            if nums[i] > 0:\\n                return i + 1\\n            \\n        return n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1903797,
                "title": "java-solution-with-comment",
                "content": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int i =0 ;\\n       int i =0 ;\\n        while(i<nums.length)\\n        //nums[i] <nums.length with this we ignore arrayIndexBound error\\n            //nums[i] != nums[nums[i]-1] with this duplicacy is removed\\n        {\\n            if (nums[i] > 0 && nums[i] <nums.length && nums[i] != nums[nums[i]-1] )\\n                swap(nums, i , nums[i]-1);\\n            else\\n                i++;\\n        }\\n        for( i =0; i<nums.length; i++)\\n        {\\n            if (nums[i] != i+1 )\\n               return i+1;\\n        }\\n        return nums.length+1;\\n    }\\n    public  void swap (int nums[], int i , int j){\\n      int  temp =  nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int i =0 ;\\n       int i =0 ;\\n        while(i<nums.length)\\n        //nums[i] <nums.length with this we ignore arrayIndexBound error\\n            //nums[i] != nums[nums[i]-1] with this duplicacy is removed\\n        {\\n            if (nums[i] > 0 && nums[i] <nums.length && nums[i] != nums[nums[i]-1] )\\n                swap(nums, i , nums[i]-1);\\n            else\\n                i++;\\n        }\\n        for( i =0; i<nums.length; i++)\\n        {\\n            if (nums[i] != i+1 )\\n               return i+1;\\n        }\\n        return nums.length+1;\\n    }\\n    public  void swap (int nums[], int i , int j){\\n      int  temp =  nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789620,
                "title": "java-cyclic-sorting-easy-understanding",
                "content": "## **Please upvote if you understood it (\\u301C\\uFFE3\\u25BD\\uFFE3)\\u301C**\\n----\\n-----\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        for(int i=0;i<nums.length;){\\n            if(nums[i]>0 && nums[i]<nums.length && nums[i]!=nums[nums[i]-1]){\\n                swap(nums,i,nums[i]-1);\\n            }\\n            else i++;\\n        }\\n        \\n        if(nums[0]>1) return 1;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]!=i+1){\\n                return i+1;\\n            }\\n        }\\n        \\n        return nums.length+1;\\n    }\\n    \\n    \\n    public void swap(int[] nums, int first, int second){\\n        int temp = nums[first];\\n        nums[first] = nums[second];\\n        nums[second] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        for(int i=0;i<nums.length;){\\n            if(nums[i]>0 && nums[i]<nums.length && nums[i]!=nums[nums[i]-1]){\\n                swap(nums,i,nums[i]-1);\\n            }\\n            else i++;\\n        }\\n        \\n        if(nums[0]>1) return 1;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]!=i+1){\\n                return i+1;\\n            }\\n        }\\n        \\n        return nums.length+1;\\n    }\\n    \\n    \\n    public void swap(int[] nums, int first, int second){\\n        int temp = nums[first];\\n        nums[first] = nums[second];\\n        nums[second] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692023,
                "title": "c-o-n-time-o-1-space-solution-with-explanation",
                "content": "Not correct solution but for understanding the concept\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // intution\\n        // create a visited array of size n = nums.size()\\n        // mark whatever has been seen\\n        // once whole array is marked iterate and check\\n        // what is absent\\n        // return that\\n        // if nothing is absent return n+1\\n        // this will take O(n) space in extra\\n        // we will obtimise it later\\n        int n = nums.size();\\n        vector<bool> visited(n);\\n        \\n        //marking the exisitng numbers\\n        for (int i = 0; i < n; i++){\\n            if (nums[i] > 0 && nums[i] <= n) {\\n                // numbers are from 1 to ..\\n                // indexes to mark are from 0\\n                // so mark number i at i-1 \\n                // e.g mark 5 at index 4\\n                visited[i-1] = true;\\n            }\\n        }\\n        \\n        // cheking what was not present\\n        for(int i = 0; i < n; i++) {\\n            if(!visited[i]) \\n                return i+1;\\n        }\\n        \\n        // everything was present\\n        return n+1;\\n    }\\n};\\n```\\n\\nCorrect solution\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // now we cant use viisited array\\n        // so we need to mark that we have seen a number between 1 to n in nums itself\\n        // we have to do this without distroying any needed info in nums\\n        \\n        // idea\\n        // we dont need any negative number or 0\\n        // convert them to any number which we are sure will not be out answer\\n        // say intmax\\n        \\n        // now wenever we get any number betwen 1 to n\\n        // we can change the number at that index to its negative\\n        // this will help us store both info\\n        // the value will give us the value in the array\\n        // while the -ve sign will say that the idx+1 was present in the array\\n        int n = nums.size();\\n        \\n        \\n        \\n        //chnage all non positive to intmax or anything greater than n\\n        for (int i = 0; i < n; i++){\\n            if (nums[i] <= 0 ) {\\n               nums[i] = INT_MAX;\\n            }\\n        }\\n        \\n        //mark\\n        for (int i = 0; i < n; i++){\\n            // retrive the number\\n            // convert is to positive if it was negative\\n            // as negative was only used for marking\\n            int val = nums[i] > 0 ? nums[i] : -nums[i];\\n            if(val > 0 && val <= n){\\n                // got a number between 1 to n\\n                \\n                // check if it is already marked at index val-1\\n                // if its negative its marked\\n                // if its postive mark by changing it to negative\\n                if(nums[val-1] > 0) nums[val-1] *= -1;\\n                \\n            }\\n        }\\n        \\n        // check what was absent\\n        for (int i = 0; i < n; i++){\\n            if(nums[i] > 0) return i+1;\\n        }\\n        \\n        // everything was marked\\n        return n+1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // intution\\n        // create a visited array of size n = nums.size()\\n        // mark whatever has been seen\\n        // once whole array is marked iterate and check\\n        // what is absent\\n        // return that\\n        // if nothing is absent return n+1\\n        // this will take O(n) space in extra\\n        // we will obtimise it later\\n        int n = nums.size();\\n        vector<bool> visited(n);\\n        \\n        //marking the exisitng numbers\\n        for (int i = 0; i < n; i++){\\n            if (nums[i] > 0 && nums[i] <= n) {\\n                // numbers are from 1 to ..\\n                // indexes to mark are from 0\\n                // so mark number i at i-1 \\n                // e.g mark 5 at index 4\\n                visited[i-1] = true;\\n            }\\n        }\\n        \\n        // cheking what was not present\\n        for(int i = 0; i < n; i++) {\\n            if(!visited[i]) \\n                return i+1;\\n        }\\n        \\n        // everything was present\\n        return n+1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // now we cant use viisited array\\n        // so we need to mark that we have seen a number between 1 to n in nums itself\\n        // we have to do this without distroying any needed info in nums\\n        \\n        // idea\\n        // we dont need any negative number or 0\\n        // convert them to any number which we are sure will not be out answer\\n        // say intmax\\n        \\n        // now wenever we get any number betwen 1 to n\\n        // we can change the number at that index to its negative\\n        // this will help us store both info\\n        // the value will give us the value in the array\\n        // while the -ve sign will say that the idx+1 was present in the array\\n        int n = nums.size();\\n        \\n        \\n        \\n        //chnage all non positive to intmax or anything greater than n\\n        for (int i = 0; i < n; i++){\\n            if (nums[i] <= 0 ) {\\n               nums[i] = INT_MAX;\\n            }\\n        }\\n        \\n        //mark\\n        for (int i = 0; i < n; i++){\\n            // retrive the number\\n            // convert is to positive if it was negative\\n            // as negative was only used for marking\\n            int val = nums[i] > 0 ? nums[i] : -nums[i];\\n            if(val > 0 && val <= n){\\n                // got a number between 1 to n\\n                \\n                // check if it is already marked at index val-1\\n                // if its negative its marked\\n                // if its postive mark by changing it to negative\\n                if(nums[val-1] > 0) nums[val-1] *= -1;\\n                \\n            }\\n        }\\n        \\n        // check what was absent\\n        for (int i = 0; i < n; i++){\\n            if(nums[i] > 0) return i+1;\\n        }\\n        \\n        // everything was marked\\n        return n+1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1669736,
                "title": "solution-with-explaination",
                "content": "Solution Approach- Try placing the number at position where index and value can be equal. such that i= nums[i]-1 (zero based index)\\n```\\n// Time-O(N), Space-O(1)\\n\\tpublic static int firstMissingPositive(int[] nums) {\\n\\t\\tif (nums == null || nums.length == 0) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\n\\t\\tint n = nums.length;\\n\\t\\tint i = 0;\\n\\t\\twhile (i < n) {\\n\\t\\t\\t// if number is either less than 1 or already at the right position skip it\\n\\t\\t\\tif (nums[i] < 1 || nums[i] == i + 1) {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// don\\'t increment i here, we can compare again after its value is updated\\n\\t\\t\\t\\t// if number is beyond array size then change to out of range (-1)\\n\\t\\t\\t\\tif (nums[i] > n) {\\n\\t\\t\\t\\t\\tnums[i] = -1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// number being swapped already matches, don\\'t swap to avoid infinite loops [1,1]\\n\\t\\t\\t\\t\\tif (nums[i] == nums[nums[i] - 1]) {\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t// swap to make sure value of nums[i] can be placed to its desired position (if value is 4, place it at the 4th index- i=3)\\n\\t\\t\\t\\t\\t\\tint temp = nums[nums[i] - 1];\\n\\t\\t\\t\\t\\t\\tnums[nums[i] - 1] = nums[i];\\n\\t\\t\\t\\t\\t\\tnums[i] = temp;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// scan to see if number is not at its desired position, that position is the result\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (nums[j] != j + 1) {\\n\\t\\t\\t\\treturn j + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// if every number is at its desired position then size+1 is the answer\\n\\t\\treturn n + 1;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n// Time-O(N), Space-O(1)\\n\\tpublic static int firstMissingPositive(int[] nums) {\\n\\t\\tif (nums == null || nums.length == 0) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\n\\t\\tint n = nums.length;\\n\\t\\tint i = 0;\\n\\t\\twhile (i < n) {\\n\\t\\t\\t// if number is either less than 1 or already at the right position skip it\\n\\t\\t\\tif (nums[i] < 1 || nums[i] == i + 1) {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// don\\'t increment i here, we can compare again after its value is updated\\n\\t\\t\\t\\t// if number is beyond array size then change to out of range (-1)\\n\\t\\t\\t\\tif (nums[i] > n) {\\n\\t\\t\\t\\t\\tnums[i] = -1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// number being swapped already matches, don\\'t swap to avoid infinite loops [1,1]\\n\\t\\t\\t\\t\\tif (nums[i] == nums[nums[i] - 1]) {\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t// swap to make sure value of nums[i] can be placed to its desired position (if value is 4, place it at the 4th index- i=3)\\n\\t\\t\\t\\t\\t\\tint temp = nums[nums[i] - 1];\\n\\t\\t\\t\\t\\t\\tnums[nums[i] - 1] = nums[i];\\n\\t\\t\\t\\t\\t\\tnums[i] = temp;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// scan to see if number is not at its desired position, that position is the result\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (nums[j] != j + 1) {\\n\\t\\t\\t\\treturn j + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// if every number is at its desired position then size+1 is the answer\\n\\t\\treturn n + 1;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1631318,
                "title": "optimal-and-intuitive-solution-with-explanation-tc-o-n-sc-o-1",
                "content": "Ignore all the elements not in the range 1 to size (include only 1<= element <= size )\\nPlace the element at it\\'s index value ( arr[arr[i] - 1] = arr[i]) ( in zero based index)\\nfor instance  index for 1 is 0, 2 is 1, 3 is 2 and so on.\\n\\n``` arr = [3, 4, -1, 1, 7] ```\\n```\\n\\tplace 3 at index (3 - 1) = 2 i.e at index 2\\n    place 4 at index (4 - 1) = 3\\n    place 1 at index (1 - 1) = 0 \\n\\t\\n\\tsince -1 and 7 are not in the range 1 to size \\n\\tso ignore these elements\\n```\\nIf duplicate elements exist, then no need to place the duplicate element at its correct index as the  elements is already placed at its correct index.\\n\\n\\n\\n```\\n\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int size = nums.length;\\n        for(int i = 0; i < size; i++){\\n            while((nums[i] >= 1 && nums[i] <= size) && (nums[nums[i] - 1] != nums[i])){\\n                int temp = nums[nums[i] - 1];\\n                nums[nums[i] - 1] = nums[i];\\n                nums[i] = temp;\\n            }\\n        }\\n        \\n        for(int i = 0; i < size; i++){\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        }\\n     return size + 1;   \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "``` arr = [3, 4, -1, 1, 7] ```\n```\\n\\tplace 3 at index (3 - 1) = 2 i.e at index 2\\n    place 4 at index (4 - 1) = 3\\n    place 1 at index (1 - 1) = 0 \\n\\t\\n\\tsince -1 and 7 are not in the range 1 to size \\n\\tso ignore these elements\\n```\n```\\n\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int size = nums.length;\\n        for(int i = 0; i < size; i++){\\n            while((nums[i] >= 1 && nums[i] <= size) && (nums[nums[i] - 1] != nums[i])){\\n                int temp = nums[nums[i] - 1];\\n                nums[nums[i] - 1] = nums[i];\\n                nums[i] = temp;\\n            }\\n        }\\n        \\n        for(int i = 0; i < size; i++){\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        }\\n     return size + 1;   \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606058,
                "title": "c-index-marking-fast-easy-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // we convert all the numbers except 1to n into n+1 as they won\\'t give potential answer.\\n        int n = nums.size();\\n        for(int i =0;i<n;i++){\\n            if(nums[i]<=0){\\n                nums[i] = n+1;\\n            }\\n        }\\n        for(int i=0; i<n;i++){\\n            int temp = abs(nums[i]);\\n            //if there is any number in ranger 1to n , its index in 0 based array will get marked negative. \\n            if(temp<n+1){\\n                nums[temp-1] = -abs(nums[temp-1]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            // the first positive index+1 will give us result(if there was any element in array was not present\\n            //in the range of 1ton, otherwise we return n+1)\\n            if(nums[i]>0){\\n                return i+1;\\n            }\\n        }\\n        return n+1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // we convert all the numbers except 1to n into n+1 as they won\\'t give potential answer.\\n        int n = nums.size();\\n        for(int i =0;i<n;i++){\\n            if(nums[i]<=0){\\n                nums[i] = n+1;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564577,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1568115,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1565259,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1565425,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1567177,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1570529,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1565938,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1568865,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1571103,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1778745,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1564577,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1568115,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1565259,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1565425,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1567177,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1570529,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1565938,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1568865,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1571103,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1778745,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1572795,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1571099,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 2041972,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1899816,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1576134,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1574477,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1569200,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1571100,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1568866,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 2047614,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1997280,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1576234,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1576131,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1575308,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1574430,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1573760,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1571956,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1571102,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1570792,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1826191,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1575849,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 1571101,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2073255,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2064610,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2064595,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2061616,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2060767,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2057780,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2055998,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2053416,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2049691,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 2020252,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1988682,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1979497,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1979486,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1978604,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1967926,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1940061,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1939535,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1935217,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1931668,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1928904,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1922112,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1920360,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1915754,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1914993,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1904716,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1890475,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1887475,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1863876,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1861489,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1845980,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1845880,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1837770,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1826178,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1817599,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1815654,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1811624,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1810839,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1810250,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1809806,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1808741,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1807844,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1807475,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1799190,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1793774,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1792234,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1777029,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1773895,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1768444,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1755671,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1754856,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1752617,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1751311,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1743368,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1742391,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1733008,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1732948,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1729717,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1728888,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1725223,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1722682,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1718319,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1710782,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1705887,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1703683,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1698023,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1693402,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1690886,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1672177,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Linked List Cycle",
        "question_content": "<p>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p>\n\n<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the&nbsp;<code>next</code>&nbsp;pointer. Internally, <code>pos</code>&nbsp;is used to denote the index of the node that&nbsp;tail&#39;s&nbsp;<code>next</code>&nbsp;pointer is connected to.&nbsp;<strong>Note that&nbsp;<code>pos</code>&nbsp;is not passed as a parameter</strong>.</p>\n\n<p>Return&nbsp;<code>true</code><em> if there is a cycle in the linked list</em>. Otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png\" style=\"width: 300px; height: 97px; margin-top: 8px; margin-bottom: 8px;\" />\n<pre>\n<strong>Input:</strong> head = [3,2,0,-4], pos = 1\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"width: 141px; height: 74px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2], pos = 0\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 0th node.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"width: 45px; height: 45px;\" />\n<pre>\n<strong>Input:</strong> head = [1], pos = -1\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no cycle in the linked list.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p>\n",
        "solutions": [
            {
                "id": 1829489,
                "title": "c-easy-to-understand-2-pointer-fast-slow",
                "content": "# 141. Linked List Cycle\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Linked list problem, 2 pointer , fast slow / turtle hare algorithm.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n\\n[LeetCode](https://github.com/knockcat/Leetcode)          **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**EXPLANATION**\\n* **Floyd\\u2019s Cycle-Finding Algorithm** // fast slow approach // 2 pointers // **\"tortoise and the hare algorithm\"**\\n* Approach: This is the **fastest method** and has been described below:  \\n\\n* **Traverse linked list** using **two pointers**.\\n* Move **one pointer(slow_p) by one** and another **pointer(fast_p) by two.**\\n* If t**hese pointers meet at the same node** then **there is a loop**. If **pointers do not meet** then **linked list doesn\\u2019t have a loop.**\\n\\n![image](https://assets.leetcode.com/users/images/55a1e7fb-e28e-4a21-b7c5-43274d77e10a_1646699998.33529.png)\\n\\n*Above linked list has a loop as node 5 is connected to node 2 foming a Cycle.*\\n\\n**The algorithm can be reffered to as a real life scenario ->**\\n\\nSuppose there are **two people running on a track** one with a **speed x** and another with a **speed 2x** (twice of first) now it\\'s clear that **person 2 is faster**.\\nNow **assume the track to  be circular** and now since peson 2 will have faster speed so it is very sure that **person two will meet person 1 or he will overtake him**.\\n\\nNow the **above scenario is similar to our problem statement** where given ***linkedlist is the track*** and if the linked list would have a cycle it would be same as the circular track and the above conditon will definitely meet,  i.e person 2 will overtake or meet person one.\\n\\n**person 1 is slow pointer** here and moving by 1 node at a time and **person 2 is fast pointer** here moving with 2 nodes at a time. So they will meet definitely at some point **if the linkedlist contains a cycle** that is our **fast and slow pointer reference will become equal** or they point at same memory location.\\n\\n**CODE WITH EXPLANATION**\\n\\n* Time Complexity : O(N)\\n* Space Complexity : O(1)\\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n\\t\\n\\t\\t// making two pointers fast and slow and assignning them to head\\n        ListNode *fast = head;\\n        ListNode *slow = head;\\n        \\n\\t\\t// till fast and fast-> next not reaches NULL\\n\\t\\t// we will increment fast by 2 step and slow by 1 step\\n        while(fast != NULL && fast ->next != NULL)\\n        {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            \\n\\t\\t\\t\\n\\t\\t\\t// At the point if fast and slow are at same address\\n\\t\\t\\t// this means linked list has a cycle in it.\\n            if(fast == slow)\\n                return true;\\n        }\\n        \\n\\t\\t// if traversal reaches to NULL this means no cycle.\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Linked list problem, 2 pointer , fast slow / turtle hare algorithm.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n\\t\\n\\t\\t// making two pointers fast and slow and assignning them to head\\n        ListNode *fast = head;\\n        ListNode *slow = head;\\n        \\n\\t\\t// till fast and fast-> next not reaches NULL\\n\\t\\t// we will increment fast by 2 step and slow by 1 step\\n        while(fast != NULL && fast ->next != NULL)\\n        {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            \\n\\t\\t\\t\\n\\t\\t\\t// At the point if fast and slow are at same address\\n\\t\\t\\t// this means linked list has a cycle in it.\\n            if(fast == slow)\\n                return true;\\n        }\\n        \\n\\t\\t// if traversal reaches to NULL this means no cycle.\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829768,
                "title": "javascript-easy-to-understand-slow-fast-pointers-detailed-explanation",
                "content": "## Core Strategy\\n\\nFor this problem, let\\'s see what will happen if there\\'s a circle.\\nIf it\\'s a little abstract, then let\\'s think about we are running on a circular track.\\n\\nIf the track is 100m long, your speed is 10m/s, your friend\\'s speed is 5m/s. Then after 20s, you\\'ve run 200m, your friend has run 100m. But because the track is circular, so you will be at the same place with your friend since the difference between your distances is exactly 100m.\\n\\nHow about we change another track, change the speed of you and your friend? As long as your speeds are not the same, the faster person will always catch up with the slower person again.\\n\\nThat\\'s the key point for this problem.\\n\\n## Solution\\n\\nWe just need to follow the strategy above - make a slower pointer and a faster pointer. Then we loop and loop again:\\n- if the fast pointer catch up with slow pointer, then it\\'s a circular linked list\\n- if the fast pointer get to the end, then it\\'s not a circular linked list\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst hasCycle = (head) => {\\n  let fast = head;\\n  while (fast && fast.next) {\\n    head = head.next;\\n    fast = fast.next.next;\\n    if (head === fast) return true;\\n  }\\n  return false;\\n};\\n```\\n\\n---\\n\\nUPDATE at Apr 04 2023\\n\\nSince there\\'s a question in comments said the running case is a continuous process while linked-list is discrete, so let me put more here to explain.\\n\\nLet\\'s suppose we have these:\\n- `v1` is for the speed of pointer 1\\n- `v2` is for the speed of pointer 2\\n- `s` is for the length of the linked list\\n- `t` is for the time spent before meet\\n- `n` is an integer\\n\\nSo, we are looking for `(|v1-v2|) * t = s * n`, and we can get `t = s * n / (|v1-v2|)`. Since they are all integers, so it\\'s very easy to find a `n` to make it happen, at least we could let the `n` equals to `|v1-v2|`.\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst hasCycle = (head) => {\\n  let fast = head;\\n  while (fast && fast.next) {\\n    head = head.next;\\n    fast = fast.next.next;\\n    if (head === fast) return true;\\n  }\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1829641,
                "title": "c-my-first-c-code-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nIt\\'s a classic algo for detecting cycles in a linked list. We use two pointers to traverse the list: The first one is moving one node at the time and the second two nodes at the time. If there is a cycle, sooner or later pointers will meet and we return `true`. If the fast pointer reached the end of the list, that means there is no cycle and we can return `false`.\\n\\n*For reference: [Floyd\\'s Cycle Detection Algorithm](https://en.wikipedia.org/wiki/Cycle_detection#Floyd\\'s_tortoise_and_hare)*\\n\\nTime: O(n) - for traversing\\nSpace: O(1) - nothing stored\\n\\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode *slow = head, *fast = head;\\n        while (fast && fast->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast) return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode *slow = head, *fast = head;\\n        while (fast && fast->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast) return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44489,
                "title": "o-1-space-solution",
                "content": "```\\npublic boolean hasCycle(ListNode head) {\\n    if(head==null) return false;\\n    ListNode walker = head;\\n    ListNode runner = head;\\n    while(runner.next!=null && runner.next.next!=null) {\\n        walker = walker.next;\\n        runner = runner.next.next;\\n        if(walker==runner) return true;\\n    }\\n    return false;\\n}\\n```\\n 1. Use two pointers, **walker** and **runner**.\\n 2. **walker** moves step by step. **runner** moves two steps at time.\\n 3. if the Linked List has a cycle **walker** and **runner** will meet at some\\n    point.",
                "solutionTags": [],
                "code": "```\\npublic boolean hasCycle(ListNode head) {\\n    if(head==null) return false;\\n    ListNode walker = head;\\n    ListNode runner = head;\\n    while(runner.next!=null && runner.next.next!=null) {\\n        walker = walker.next;\\n        runner = runner.next.next;\\n        if(walker==runner) return true;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44494,
                "title": "except-ionally-fast-python",
                "content": "Took 88 ms and the \"Accepted Solutions Runtime Distribution\" doesn't show any faster Python submissions. The \"trick\" is to not check all the time whether we have reached the end but to handle it via an exception. [\"Easier to ask for forgiveness than permission.\"](https://docs.python.org/3/glossary.html#term-eafp)\\n\\nThe algorithm is of course [Tortoise and hare](https://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare).\\n\\n    def hasCycle(self, head):\\n        try:\\n            slow = head\\n            fast = head.next\\n            while slow is not fast:\\n                slow = slow.next\\n                fast = fast.next.next\\n            return True\\n        except:\\n            return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "Took 88 ms and the \"Accepted Solutions Runtime Distribution\" doesn't show any faster Python submissions. The \"trick\" is to not check all the time whether we have reached the end but to handle it via an exception. [\"Easier to ask for forgiveness than permission.\"](https://docs.python.org/3/glossary.html#term-eafp)\\n\\nThe algorithm is of course [Tortoise and hare](https://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare).\\n\\n    def hasCycle(self, head):\\n        try:\\n            slow = head\\n            fast = head.next\\n            while slow is not fast:\\n                slow = slow.next\\n                fast = fast.next.next\\n            return True\\n        except:\\n            return False",
                "codeTag": "Python3"
            },
            {
                "id": 44694,
                "title": "accepted-clean-java-solution",
                "content": "    public boolean hasCycle(ListNode head) {\\n      ListNode slow = head, fast = head;\\n      \\n      while (fast != null && fast.next != null) {\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        \\n        if (slow == fast) \\n            return true;\\n      }\\n      \\n      return false;\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "    public boolean hasCycle(ListNode head) {\\n      ListNode slow = head, fast = head;\\n      \\n      while (fast != null && fast.next != null) {\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        \\n        if (slow == fast) \\n            return true;\\n      }\\n      \\n      return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1047638,
                "title": "c-super-simple-and-short-two-pointer-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (!head) \\n            return false;\\n        \\n        ListNode *slow = head, *fast = head;\\n        \\n        while (fast->next && fast->next->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast) \\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (!head) \\n            return false;\\n        \\n        ListNode *slow = head, *fast = head;\\n        \\n        while (fast->next && fast->next->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast) \\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823960,
                "title": "two-approaches-in-python-3-dictionary-and-two-pointers",
                "content": "### Dictionary/Hash table\\n```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        dictionary = {}\\n        while head:\\n            if head in dictionary: \\n                return True\\n            else: \\n                dictionary[head]= True\\n            head = head.next\\n        return False\\n```\\n\\n### Two pointers\\n```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        if not head:\\n            return False\\n        slow = head\\n        fast = head.next\\n        while slow != fast:\\n            if not fast or not fast.next:\\n                return False\\n            slow = slow.next\\n            fast = fast.next.next\\n        return True\\n```\\n\\nIf you find this post useful, please consider **upvoting** it. Thanks!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        dictionary = {}\\n        while head:\\n            if head in dictionary: \\n                return True\\n            else: \\n                dictionary[head]= True\\n            head = head.next\\n        return False\\n```\n```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        if not head:\\n            return False\\n        slow = head\\n        fast = head.next\\n        while slow != fast:\\n            if not fast or not fast.next:\\n                return False\\n            slow = slow.next\\n            fast = fast.next.next\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289913,
                "title": "javascript-solution-98-faster",
                "content": "```\\nvar hasCycle = function(head) {\\n    if(!head) {\\n        return false;\\n    }\\n    let hare = head;\\n    let tortoise = head;\\n    while(hare) {\\n        if(!hare.next) {\\n            return false;\\n        } else {\\n            hare = hare.next.next;\\n            tortoise = tortoise.next;\\n        }\\n        if(tortoise == hare) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```\\n\\nWhen I finally learned about the tortoise and the hare analogy for this problem, I was estatic and I\\'m here to help you understand it for those that don\\'t! \\n\\nAnalogy:\\n\\nFor those that are unfamiliar with the story of the tortoise and the hare, it\\'s basically the story of how the hare, despite being the faster than the tortoise, it still loses the race. \\n\\nHowever, the story (other than the characters) are irrelevant. What is relevant is the speed of the characters.\\n\\nOkay, now that we have that context, let\\'s talk about the approach to this problem.\\n\\nWe understand that the linked list has a cycle, anyone running through this linked list will be running around this circle forever. If it wasn\\'t, they would have stopped at the end.\\n\\nLet\\'s now imagine two types of tracks. \\n\\nOne is a straight line you see in sprint racing. If we imagine a non-circular linked list, then it would be the straight line. The fastest run reaches the end and that\\'s that.\\n\\n![image](https://assets.leetcode.com/users/tryck/image_1557470440.png)\\n\\n\\nHowever, if it was an actual track where runners would have to run laps, then it would be a circular linked list.\\n\\n![image](https://assets.leetcode.com/users/tryck/image_1557470481.png)\\n\\nNow let\\'s bring back the tortoise and the hare.\\nSince we know that the hare is faster, it will likely reach the \"end\" of the linked list faster than the tortoise. So it\\'s reasonable to say that it goes at a faster speed in relation to the tortoise\\'s speed.\\n\\nIf the track (linked list) is circular, the hare will be running around in circles and eventually so will the tortoise. At one point, the hare will have lapped the tortoise, which would mean that they\\'re in a circle since the hare will have revist a position that it\\'s already been in since the tortoise is \"behind\" it.\\n\\nIf we were to look at this mathematically, we can formulize it like this:\\n\\nSuppose that the hare runs at a rate of `ax` , where `a` is a constant and the tortoise runs at a pace of `bx` where `b` is a constant and `a > b`.\\n\\nSince they have different slopes, mathematically, they will intersect at one point. That intersection indicates a circle because the hare will revisit a position it has already been in since it comes into the same position as the tortoise.\\n\\nRuntime: `O(n)`\\nSpace Complexity: `O(1)`",
                "solutionTags": [],
                "code": "```\\nvar hasCycle = function(head) {\\n    if(!head) {\\n        return false;\\n    }\\n    let hare = head;\\n    let tortoise = head;\\n    while(hare) {\\n        if(!hare.next) {\\n            return false;\\n        } else {\\n            hare = hare.next.next;\\n            tortoise = tortoise.next;\\n        }\\n        if(tortoise == hare) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44539,
                "title": "ac-python-76ms-floyd-loop-detection-in-7-lines",
                "content": "    def hasCycle(self, head):\\n        slow = fast = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n        return False\\n\\n    # 16 / 16 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 76 ms\\n    # 96.56%\\n\\n\\nThis way we do not need to check if head is null.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def hasCycle(self, head):\\n        slow = fast = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n        return False\\n\\n    # 16 / 16 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 76 ms\\n    # 96.56%\\n\\n\\nThis way we do not need to check if head is null.",
                "codeTag": "Python3"
            },
            {
                "id": 1047852,
                "title": "python-two-pointers-o-1-memory-explained",
                "content": "This is pretty classical and well-know problem about linked list. One way is just to put all linked list to for example hash table and check if we have repeating elements. However it will take `O(n)` space. There is better solution with only `O(1)` complexity. Imagine the following example:\\n`1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 3`, the list with loop. Idea is to use two pointers, one is slow and one is fast, let us do several steps:\\n1. At the beginning, both of them at number `1`.\\n2. Next step, slow pointer at `2` and fast at `3`.\\n3. Next step, slow pointer at `3` and fast at `5`.\\n4. Next step, slow pointer at `4` and fast at `3`.\\n5. Next step, slow pointer at `5` and fast is also `5`, so we have the same element and we return `True`.\\n\\nIf we do not have loop we will never have equal elements, if we have loop, because slow pointer moves with speed `1` and fast with speed `2`, fast pointer will always gain slow one.\\n\\n**Complexity**: time complexity is `O(n)`, space complexity is `O(1)`. \\n\\n```\\nclass Solution:\\n    def hasCycle(self, head):\\n        slow = fast = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast: return True\\n            \\n        return False\\n```\\n\\n**Similar problems**:\\n**142: Linked List Cycle II:** https://leetcode.com/problems/linked-list-cycle-ii/discuss/912276/Python-2-pointers-approach-explained\\n**287. Find the Duplicate Number:** https://leetcode.com/problems/find-the-duplicate-number/discuss/704693/Python-2-solutions%3A-Linked-List-Cycle-O(n)-and-BS-O(n-log-n)-explained\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head):\\n        slow = fast = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast: return True\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44498,
                "title": "just-reverse-the-list",
                "content": "    ListNode* reverseList(ListNode* head) \\n    {\\n    \\tListNode* prev = NULL;\\n    \\tListNode* follow = NULL;\\n    \\twhile (head)\\n    \\t{\\n    \\t\\tfollow = head->next;\\n    \\t\\thead->next = prev;\\n    \\t\\tprev = head;\\n    \\t\\thead = follow;\\n    \\t}\\n\\t    return prev;\\n    }\\n    bool hasCycle(ListNode *head)\\n    {\\n    \\tListNode* rev = reverseList(head);\\n    \\tif (head && head->next && rev == head)\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\nif the list has got a loop, then its reversed version must have got the same head pointer as its self;",
                "solutionTags": [
                    "C++"
                ],
                "code": "    ListNode* reverseList(ListNode* head) \\n    {\\n    \\tListNode* prev = NULL;\\n    \\tListNode* follow = NULL;\\n    \\twhile (head)\\n    \\t{\\n    \\t\\tfollow = head->next;\\n    \\t\\thead->next = prev;\\n    \\t\\tprev = head;\\n    \\t\\thead = follow;\\n    \\t}\\n\\t    return prev;\\n    }\\n    bool hasCycle(ListNode *head)\\n    {\\n    \\tListNode* rev = reverseList(head);\\n    \\tif (head && head->next && rev == head)\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\nif the list has got a loop, then its reversed version must have got the same head pointer as its self;",
                "codeTag": "Unknown"
            },
            {
                "id": 3999014,
                "title": "99-68-two-pointer-hash-table",
                "content": "# Interview Guide - Detecting Cycles in a Linked List: A Dual-Approach Analysis\\n\\n## Introduction & Problem Understanding\\n\\nDetecting cycles in a linked list is a classic problem that tests a developer\\'s ability to understand and manipulate data structures. In this problem, you are given the head of a singly-linked list. The objective is to determine whether the list contains a cycle. A cycle exists if a node in the list can be visited more than once by following the `next` pointers continuously.\\n\\n### Key Concepts and Constraints\\n\\n1. **Node Anatomy**:  \\n   Each node in the list contains an integer value and a `next` pointer that points to the subsequent node in the list.\\n\\n2. **Cycle Detection**:  \\n   The primary task is to identify whether a cycle exists within the list. If a cycle is detected, the function should return `True`. Otherwise, it should return `False`.\\n\\n3. **Memory Efficiency**:  \\n   The question poses an implicit challenge: Can you solve it using $$ O(1) $$ memory, meaning constant extra space?\\n\\n## Strategies to Tackle the Problem\\n\\n1. **Hash Table Method**:  \\nThis approach involves storing visited nodes in a hash table. During traversal, if a node is encountered that already exists in the hash table, a cycle is confirmed.\\n\\n2. **Two-Pointers Method (Floyd\\'s Cycle-Finding Algorithm)**:  \\nAlso known as the \"hare and tortoise\" algorithm, this method employs two pointers that move at different speeds. If there is a cycle, the fast pointer will eventually catch up to the slow pointer, confirming the cycle\\'s existence.\\n\\n---\\n\\n# Live Coding 2 Solution & More\\nhttps://youtu.be/ew-E3mHOBT0?si=DTvrijJplAk7XV1w\\n\\n## Solution #1: Hash Table Method\\n\\n### Intuition and Logic Behind the Solution\\n\\nThe basic idea here is to traverse the list and keep a record of the nodes we\\'ve visited so far. If at any point we encounter a node that we\\'ve already visited, we can conclude that there is a cycle in the list.\\n\\n### Step-by-step Explanation\\n\\n1. **Initialization**: \\n    - Create an empty set, `visited_nodes`, to keep track of the nodes that have been visited.\\n\\n2. **Traversal and Verification**:  \\n    - Traverse the list starting from the head node.\\n    - At each node, check whether it already exists in `visited_nodes`.\\n    - If it does, return `True` as a cycle is detected.\\n    - Otherwise, add the node to `visited_nodes`.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: $$ O(n) $$ \\u2014 Each node is visited once.\\n- **Space Complexity**: $$ O(n) $$ \\u2014 To store visited nodes.\\n\\n---\\n\\n## Solution #2: Two-Pointer Method (Floyd\\'s Cycle-Finding Algorithm)\\n\\n### Intuition and Logic Behind the Solution\\n\\nAlso known as the \"hare and tortoise\" algorithm, this method uses two pointers that traverse the list at different speeds. The slow pointer moves one step at a time, while the fast pointer moves two steps. If there is a cycle, the fast pointer will eventually catch up to the slow pointer.\\n\\n### Step-by-step Explanation\\n\\n1. **Initialization**:  \\n   - Initialize two pointers, `slow_pointer` and `fast_pointer`, both pointing to the head node initially.\\n\\n2. **Cycle Detection**:  \\n   - Traverse the list until the `fast_pointer` or its `next` becomes `None`.\\n   - Update `slow_pointer` and `fast_pointer` as follows:\\n        - `slow_pointer = slow_pointer.next`\\n        - `fast_pointer = fast_pointer.next.next`\\n   - If `slow_pointer` and `fast_pointer` meet at some point, return `True`.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: $$ O(n) $$ \\u2014 In the worst-case scenario, each node is visited once.\\n- **Space Complexity**: $$ O(1) $$ \\u2014 Constant space is used.\\n\\n---\\n\\n\\n# Performance\\n\\n### Two-Pointers\\n\\n| Language  | Execution Time (ms) | Memory Usage (MB) |\\n|-----------|---------------------|-------------------|\\n| Java      | 0                   | 44                |\\n| Go        | 8                   | 4.4               |\\n| PHP       | 10                  | 22.7              |\\n| C++       | 11                  | 8.2               |\\n| Python3   | 41                  | 20.6              |\\n| JavaScript| 65                  | 45                |\\n| C#        | 84                  | 43                |\\n\\n![4a.png](https://assets.leetcode.com/users/images/15ccece4-d8c7-4b20-a20e-ec68df3195c9_1693788120.9485033.png)\\n\\n### Hash Table\\n\\n| Language  | Execution Time (ms) | Memory Usage (MB) |\\n|-----------|---------------------|-------------------|\\n| Java      | 4                   | 43.7              |\\n| Go        | 10                  | 6.2               |\\n| C++       | 18                  | 10.5              |\\n| Python3   | 49                  | 20.7              |\\n| C#        | 82                  | 44.9              |\\n| JavaScript| 69                  | 45.9              |\\n| PHP       | 432                 | 22.8              |\\n\\n![4b.png](https://assets.leetcode.com/users/images/f7f852af-c713-4592-9702-274042cac052_1693788438.437233.png)\\n\\n\\n# Code Two-Pointer\\n``` Python []\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow_pointer = head\\n        fast_pointer = head\\n        while fast_pointer and fast_pointer.next:\\n            slow_pointer = slow_pointer.next\\n            fast_pointer = fast_pointer.next.next\\n            if slow_pointer == fast_pointer:\\n                return True\\n        return False\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode *slow_pointer = head, *fast_pointer = head;\\n        while (fast_pointer != nullptr && fast_pointer->next != nullptr) {\\n            slow_pointer = slow_pointer->next;\\n            fast_pointer = fast_pointer->next->next;\\n            if (slow_pointer == fast_pointer) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow_pointer = head, fast_pointer = head;\\n        while (fast_pointer != null && fast_pointer.next != null) {\\n            slow_pointer = slow_pointer.next;\\n            fast_pointer = fast_pointer.next.next;\\n            if (slow_pointer == fast_pointer) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        ListNode slow_pointer = head, fast_pointer = head;\\n        while (fast_pointer != null && fast_pointer.next != null) {\\n            slow_pointer = slow_pointer.next;\\n            fast_pointer = fast_pointer.next.next;\\n            if (slow_pointer == fast_pointer) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n``` Go []\\nfunc hasCycle(head *ListNode) bool {\\n    slow_pointer, fast_pointer := head, head\\n    for fast_pointer != nil && fast_pointer.Next != nil {\\n        slow_pointer = slow_pointer.Next\\n        fast_pointer = fast_pointer.Next.Next\\n        if slow_pointer == fast_pointer {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = function(head) {\\n    let slow_pointer = head, fast_pointer = head;\\n    while (fast_pointer !== null && fast_pointer.next !== null) {\\n        slow_pointer = slow_pointer.next;\\n        fast_pointer = fast_pointer.next.next;\\n        if (slow_pointer === fast_pointer) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```\\n``` PHP []\\nclass Solution {\\n    function hasCycle($head) {\\n        $slow_pointer = $head;\\n        $fast_pointer = $head;\\n        while ($fast_pointer !== null && $fast_pointer->next !== null) {\\n            $slow_pointer = $slow_pointer->next;\\n            $fast_pointer = $fast_pointer->next->next;\\n            if ($slow_pointer === $fast_pointer) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n# Code Hash Table\\n``` Python []\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        visited_nodes = set()\\n        current_node = head\\n        while current_node:\\n            if current_node in visited_nodes:\\n                return True\\n            visited_nodes.add(current_node)\\n            current_node = current_node.next\\n        return False                                                                 \\n```\\n``` Go []\\nfunc hasCycle(head *ListNode) bool {\\n    visited_nodes := make(map[*ListNode]bool)\\n    current_node := head\\n    for current_node != nil {\\n        if visited_nodes[current_node] {\\n            return true\\n        }\\n        visited_nodes[current_node] = true\\n        current_node = current_node.Next\\n    }\\n    return false\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        std::unordered_set<ListNode*> visited_nodes;\\n        ListNode *current_node = head;\\n        while (current_node != nullptr) {\\n            if (visited_nodes.find(current_node) != visited_nodes.end()) {\\n                return true;\\n            }\\n            visited_nodes.insert(current_node);\\n            current_node = current_node->next;\\n        }\\n        return false;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        HashSet<ListNode> visited_nodes = new HashSet<>();\\n        ListNode current_node = head;\\n        while (current_node != null) {\\n            if (visited_nodes.contains(current_node)) {\\n                return true;\\n            }\\n            visited_nodes.add(current_node);\\n            current_node = current_node.next;\\n        }\\n        return false;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        HashSet<ListNode> visited_nodes = new HashSet<ListNode>();\\n        ListNode current_node = head;\\n        while (current_node != null) {\\n            if (visited_nodes.Contains(current_node)) {\\n                return true;\\n            }\\n            visited_nodes.Add(current_node);\\n            current_node = current_node.next;\\n        }\\n        return false;\\n    }\\n}\\n```\\n``` PHP []\\nclass Solution {\\n    function hasCycle($head) {\\n        $visited_nodes = [];\\n        $current_node = $head;\\n        while ($current_node !== null) {\\n            if (in_array($current_node, $visited_nodes, true)) {\\n                return true;\\n            }\\n            $visited_nodes[] = $current_node;\\n            $current_node = $current_node->next;\\n        }\\n        return false;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = function(head) {\\n    let visited_nodes = new Set();\\n    let current_node = head;\\n    while (current_node !== null) {\\n        if (visited_nodes.has(current_node)) {\\n            return true;\\n        }\\n        visited_nodes.add(current_node);\\n        current_node = current_node.next;\\n    }\\n    return false;\\n};\\n```\\n\\n# Live Coding with Comments\\nhttps://youtu.be/aGbOOAKkhNo?si=IoPNL49uVessMpCv\\n\\n# Reflections on Cycle Detection\\n\\nBoth the Hash Table and Two-Pointers methods offer compelling strategies for detecting cycles in linked lists.\\n\\n1. **Hash Table Method**:  \\n   Intuitive and adaptable, though potentially memory-intensive.\\n   \\n2. **Two-Pointers Method**:  \\n   A marvel of memory efficiency, but perhaps less straightforward to the uninitiated.\\n\\nNavigating this problem is a dive into data structure nuances and algorithmic elegance. Whether you appreciate the directness of the Hash Table or the finesse of Two-Pointers, each method champions a facet of computational acumen. This isn\\'t just a problem; it\\'s a step in honing algorithmic artistry. Embrace the challenge! \\uD83D\\uDE80\\uD83C\\uDF1F",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "PHP",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow_pointer = head\\n        fast_pointer = head\\n        while fast_pointer and fast_pointer.next:\\n            slow_pointer = slow_pointer.next\\n            fast_pointer = fast_pointer.next.next\\n            if slow_pointer == fast_pointer:\\n                return True\\n        return False\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode *slow_pointer = head, *fast_pointer = head;\\n        while (fast_pointer != nullptr && fast_pointer->next != nullptr) {\\n            slow_pointer = slow_pointer->next;\\n            fast_pointer = fast_pointer->next->next;\\n            if (slow_pointer == fast_pointer) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow_pointer = head, fast_pointer = head;\\n        while (fast_pointer != null && fast_pointer.next != null) {\\n            slow_pointer = slow_pointer.next;\\n            fast_pointer = fast_pointer.next.next;\\n            if (slow_pointer == fast_pointer) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        ListNode slow_pointer = head, fast_pointer = head;\\n        while (fast_pointer != null && fast_pointer.next != null) {\\n            slow_pointer = slow_pointer.next;\\n            fast_pointer = fast_pointer.next.next;\\n            if (slow_pointer == fast_pointer) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n``` Go []\\nfunc hasCycle(head *ListNode) bool {\\n    slow_pointer, fast_pointer := head, head\\n    for fast_pointer != nil && fast_pointer.Next != nil {\\n        slow_pointer = slow_pointer.Next\\n        fast_pointer = fast_pointer.Next.Next\\n        if slow_pointer == fast_pointer {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = function(head) {\\n    let slow_pointer = head, fast_pointer = head;\\n    while (fast_pointer !== null && fast_pointer.next !== null) {\\n        slow_pointer = slow_pointer.next;\\n        fast_pointer = fast_pointer.next.next;\\n        if (slow_pointer === fast_pointer) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```\n``` PHP []\\nclass Solution {\\n    function hasCycle($head) {\\n        $slow_pointer = $head;\\n        $fast_pointer = $head;\\n        while ($fast_pointer !== null && $fast_pointer->next !== null) {\\n            $slow_pointer = $slow_pointer->next;\\n            $fast_pointer = $fast_pointer->next->next;\\n            if ($slow_pointer === $fast_pointer) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        visited_nodes = set()\\n        current_node = head\\n        while current_node:\\n            if current_node in visited_nodes:\\n                return True\\n            visited_nodes.add(current_node)\\n            current_node = current_node.next\\n        return False                                                                 \\n```\n``` Go []\\nfunc hasCycle(head *ListNode) bool {\\n    visited_nodes := make(map[*ListNode]bool)\\n    current_node := head\\n    for current_node != nil {\\n        if visited_nodes[current_node] {\\n            return true\\n        }\\n        visited_nodes[current_node] = true\\n        current_node = current_node.Next\\n    }\\n    return false\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        std::unordered_set<ListNode*> visited_nodes;\\n        ListNode *current_node = head;\\n        while (current_node != nullptr) {\\n            if (visited_nodes.find(current_node) != visited_nodes.end()) {\\n                return true;\\n            }\\n            visited_nodes.insert(current_node);\\n            current_node = current_node->next;\\n        }\\n        return false;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        HashSet<ListNode> visited_nodes = new HashSet<>();\\n        ListNode current_node = head;\\n        while (current_node != null) {\\n            if (visited_nodes.contains(current_node)) {\\n                return true;\\n            }\\n            visited_nodes.add(current_node);\\n            current_node = current_node.next;\\n        }\\n        return false;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        HashSet<ListNode> visited_nodes = new HashSet<ListNode>();\\n        ListNode current_node = head;\\n        while (current_node != null) {\\n            if (visited_nodes.Contains(current_node)) {\\n                return true;\\n            }\\n            visited_nodes.Add(current_node);\\n            current_node = current_node.next;\\n        }\\n        return false;\\n    }\\n}\\n```\n``` PHP []\\nclass Solution {\\n    function hasCycle($head) {\\n        $visited_nodes = [];\\n        $current_node = $head;\\n        while ($current_node !== null) {\\n            if (in_array($current_node, $visited_nodes, true)) {\\n                return true;\\n            }\\n            $visited_nodes[] = $current_node;\\n            $current_node = $current_node->next;\\n        }\\n        return false;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = function(head) {\\n    let visited_nodes = new Set();\\n    let current_node = head;\\n    while (current_node !== null) {\\n        if (visited_nodes.has(current_node)) {\\n            return true;\\n        }\\n        visited_nodes.add(current_node);\\n        current_node = current_node.next;\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44604,
                "title": "my-faster-and-slower-runner-solution",
                "content": "    /**\\n     * Definition for singly-linked list.\\n     * struct ListNode {\\n     *     int val;\\n     *     ListNode *next;\\n     *     ListNode(int x) : val(x), next(NULL) {}\\n     * };\\n     */\\n     /**\\n     use faster and lower runner solution. (2 pointers)\\n     the faster one move 2 steps, and slower one move only one step.\\n     if there's a circle, the faster one will finally \"catch\" the slower one. \\n     (the distance between these 2 pointers will decrease one every time.)\\n     \\n     if there's no circle, the faster runner will reach the end of linked list. (NULL)\\n     */\\n    class Solution {\\n    public:\\n        bool hasCycle(ListNode *head) {\\n            if(head == NULL || head -> next == NULL)    \\n                return false;\\n     \\n            ListNode *fast = head;\\n            ListNode *slow = head;\\n            \\n            while(fast -> next && fast -> next -> next){\\n                fast = fast -> next -> next;\\n                slow = slow -> next;\\n                if(fast == slow)\\n                    return true;\\n            }\\n     \\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool hasCycle(ListNode *head) {\\n            if(head == NULL || head -> next == NULL)    \\n                return false;\\n     \\n            ListNode *fast = head;\\n            ListNode *slow = head;\\n            \\n            while(fast -> next && fast -> next -> next){\\n                fast = fast -> next -> next;\\n                slow = slow -> next;\\n                if(fast == slow)\\n                    return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1501787,
                "title": "python-easy-single-pointer-approach-modifying-linked-list",
                "content": "```\\n # Approach 1 using a visited hash_set\\n        # Time -O(n), Space- O(n)\\nnode_set = set()\\nwhile(head):\\n\\tif head in node_set:\\n\\t\\treturn True\\n\\tnode_set.add(head)\\n\\thead = head.next\\nreturn False\\n```\\n\\n```\\n# Approach 2 slow and fast pointers slow moves one step at a time, fast moves 2, if they ever meet, means there was a cycle,\\n        # Time -O(n), Space- O(1)\\n        # Floyd\\'s Tortoise and Hare Algorithm\\n\\nslow = head\\nfast = head\\nwhile(fast and fast.next):\\n\\tslow = slow.next\\n\\tfast = fast.next.next\\n\\tif slow == fast:\\n\\t\\treturn True\\nreturn False\\n```\\n\\n```\\n # Approch 3 single pointer, marking nodes as visited, makes use of fact that node value\\'s are not None\\n  # Time -O(n), Space- O(1)\\nslow = head\\nwhile(slow):\\n\\tif slow.val == None:\\n\\t\\t# This was already visited\\n\\t\\treturn True\\n\\tslow.val = None # a way to mark visited\\n\\tslow = slow.next\\nreturn False\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n # Approach 1 using a visited hash_set\\n        # Time -O(n), Space- O(n)\\nnode_set = set()\\nwhile(head):\\n\\tif head in node_set:\\n\\t\\treturn True\\n\\tnode_set.add(head)\\n\\thead = head.next\\nreturn False\\n```\n```\\n# Approach 2 slow and fast pointers slow moves one step at a time, fast moves 2, if they ever meet, means there was a cycle,\\n        # Time -O(n), Space- O(1)\\n        # Floyd\\'s Tortoise and Hare Algorithm\\n\\nslow = head\\nfast = head\\nwhile(fast and fast.next):\\n\\tslow = slow.next\\n\\tfast = fast.next.next\\n\\tif slow == fast:\\n\\t\\treturn True\\nreturn False\\n```\n```\\n # Approch 3 single pointer, marking nodes as visited, makes use of fact that node value\\'s are not None\\n  # Time -O(n), Space- O(1)\\nslow = head\\nwhile(slow):\\n\\tif slow.val == None:\\n\\t\\t# This was already visited\\n\\t\\treturn True\\n\\tslow.val = None # a way to mark visited\\n\\tslow = slow.next\\nreturn False\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 805345,
                "title": "2-approach-hashmap-fast-and-slow-pointer-c",
                "content": "\\n    //fast and slow pointer approach\\n\\t\\n    bool hasCycle(ListNode *head) {\\n       ListNode* slow=head;\\n       ListNode* fast=head;\\n        while(fast && slow && fast->next){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(fast==slow)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\t\\n\\t//hashmap approach\\n\\t\\n\\tbool hasCycle(ListNode *head) {\\n        if(head==NULL)\\n            return false;\\n        unordered_map<ListNode*,int> map;\\n        while(head!=NULL){\\n            if(map.count(head)>0)\\n                return true;\\n            else\\n                map[head]=1;\\n            head=head->next;\\n        }\\n        return false;\\n    }\\n\\t\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "\\n    //fast and slow pointer approach\\n\\t\\n    bool hasCycle(ListNode *head) {\\n       ListNode* slow=head;\\n       ListNode* fast=head;\\n        while(fast && slow && fast->next){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(fast==slow)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\t\\n\\t//hashmap approach\\n\\t\\n\\tbool hasCycle(ListNode *head) {\\n        if(head==NULL)\\n            return false;\\n        unordered_map<ListNode*,int> map;\\n        while(head!=NULL){\\n            if(map.count(head)>0)\\n                return true;\\n            else\\n                map[head]=1;\\n            head=head->next;\\n        }\\n        return false;\\n    }\\n\\t\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 375999,
                "title": "slow-fast-runner-in-javascript",
                "content": "```\\nconst hasCycle = head => {\\n    let p1 = head\\n    let p2 = head\\n    \\n    while (p2 && p2.next && p2.next.next) {\\n        p1 = p1.next\\n        p2 = p2.next.next\\n        \\n        if (p1 === p2) {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst hasCycle = head => {\\n    let p1 = head\\n    let p2 = head\\n    \\n    while (p2 && p2.next && p2.next.next) {\\n        p1 = p1.next\\n        p2 = p2.next.next\\n        \\n        if (p1 === p2) {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44485,
                "title": "simple-and-easy-understanding-java-solution-time-o-n-space-o-1",
                "content": "    public class Solution {\\n        public boolean hasCycle(ListNode head) {\\n        \\tListNode p = head,pre = head;\\n        \\twhile(p != null && p.next != null){\\n        \\t\\tif (p.next == head) return true;\\n        \\t\\tp = p.next;\\n        \\t\\tpre.next = head;\\n        \\t\\tpre = p;\\n        \\t}\\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean hasCycle(ListNode head) {\\n        \\tListNode p = head,pre = head;\\n        \\twhile(p != null && p.next != null){\\n        \\t\\tif (p.next == head) return true;\\n        \\t\\tp = p.next;\\n        \\t\\tpre.next = head;\\n        \\t\\tpre = p;\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 44603,
                "title": "shorter-solution-in-java",
                "content": "    class HasCycleInLinkedList{\\n       public boolean hasCycle(ListNode head){\\n           if(head == null || head.next == null) return false;\\n           if(head.next == head) return true;\\n           ListNode nextNode = head.next; \\n           head.next = head;\\n           boolean isCycle = hasCycle(nextNode);\\n           return isCycle;\\n       }\\n    }",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "    class HasCycleInLinkedList{\\n       public boolean hasCycle(ListNode head){\\n           if(head == null || head.next == null) return false;\\n           if(head.next == head) return true;\\n           ListNode nextNode = head.next; \\n           head.next = head;\\n           boolean isCycle = hasCycle(nextNode);\\n           return isCycle;\\n       }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 44669,
                "title": "fully-explained-why-fast-and-slow-can-meet-in-the-cycle",
                "content": "I want to explain why we can get the answer when using `fast-slow` method. Share my opinion below.\\n\\nFast-Slow Solution:\\n-------------------\\n\\n    public class Solution { //java version\\n        public boolean hasCycle(ListNode head) {\\n            ListNode fast = head;\\n            ListNode slow = head;\\n            while(fast != null && fast.next != null){            \\n                fast = fast.next.next; //2 times\\n                slow = slow.next;\\n                if(fast == slow) return true;\\n            }\\n            return false;\\n        }\\n    }\\n\\nFirst,\\n------\\n\\nwe assume that they can meet. Set the `linear length` as `a`, the `cycle length` as `c`, the slow's running distance from cycle's start point to meeting point as `b`. `a and c are known, b is unknown.` We want a equation to describe `b` by using `a` and `c`.\\n\\nHere is the diagram:  \\n\\n                   b..3    \\n                   .   \\\\     \\n                   c   2   \\n                   \\\\  /     \\n    1-2-3-4-5-...-a -1  \\n\\nAn important point is that, `the running part of linear length` is not `a`, actually it's `a-1`.** That's because they use head as start point: \\n\\n        ListNode fast = head;\\n        ListNode slow = head;\\nthen begin to run:\\n\\n            fast = fast.next.next;\\n            slow = slow.next;\\nThe `head` point `can't be included` when calculating this relation: \\n\\n    slow total running length * 2 = fast total running length\\n\\nIf fast's speed is `twice` of slow's speed, we can get:\\n\\n    slow total running length = (a-1)+b //not a!!!\\n    \\n    fast total running length = 2*((a-1)+b) //2 can be t times\\n\\nBecause they meet at point `b`, we can get equation:\\n\\n    (fast total running length - running part of linear length) % c = b\\n\\nwhich is:\\n\\n    (2*((a-1)+b) - (a-1))%c = b\\n    2*((a-1)+b) - (a-1) = n*c +b\\n    (a-1)+b = n*c\\n    b = n*c-a+1\\n\\nThen,\\n-----\\n\\nif fast and slow can meet, we can get a integer `b` when `n` is increasing where `n` is an integer starting from `0`. Actually, the `b` is the first integer that is bigger than 0:\\n\\n    b = n*c-a+1 //write it on paper, compare b with code's result\\n\\nGenerally,\\n----------\\n\\nif fast's speed is `t times` of slow's speed, we get:\\n\\n    (fast total running length - running part of linear length) % c = b\\n    (t*((a-1)+b) - (a-1))%c = b\\nMost general equation:\\n\\n    b = n/(t-1) * c - a + 1 //1.fast&slow start from head, 2.t times, 3.a&c are known, 4.n from 0\\n                            //5.if b>c, b=b%c\\n\\n**(If we want to use `a` as the running part of linear length, we need a `dummy head`.)\\n\\nIf there is anything wrong, please figure it out. Welcome to write your ideas below.",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "class Solution { //java version\\n        public boolean hasCycle(ListNode head) {\\n            ListNode fast = head;\\n            ListNode slow = head;\\n            while(fast != null && fast.next != null){            \\n                fast = fast.next.next; //2 times\\n                slow = slow.next;\\n                if(fast == slow) return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2810093,
                "title": "java-o-1-memory-no-two-pointers-value-manipulation-original-solution",
                "content": "# Code\\n```\\n//since constraints for value are -10^5 <= Node.val <= 10^5\\n//then I use 1_000_000 as indicator that this node has been\\n//visited\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        while (head != null) {\\n            if (head.val == 1_000_000) return true;\\n            head.val = 1_000_000;\\n            head = head.next;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//since constraints for value are -10^5 <= Node.val <= 10^5\\n//then I use 1_000_000 as indicator that this node has been\\n//visited\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        while (head != null) {\\n            if (head.val == 1_000_000) return true;\\n            head.val = 1_000_000;\\n            head = head.next;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773893,
                "title": "javascript-3-solutions-using-hash-map-and-two-pointers",
                "content": "## Solution-1 : Using Hash Map\\n```javascript\\nvar hasCycle = function(head) {\\n    const seen = new Set();\\n    \\n    function traverse(node) {\\n        if(seen.has(node)) return true;\\n        if(!node) return false;\\n        seen.add(node);\\n        return traverse(node.next);\\n    }\\n    return traverse(head);\\n};\\n```\\n\\n## Solution-2: Two Pointers\\n```javascript\\nvar hasCycle = function(head) {\\n    \\n    function run(fast, slow) {\\n        if(!fast || !fast.next) return false;\\n        if(fast.next === slow) return true;\\n        return run(fast.next.next, slow.next);\\n    }\\n    return run(head, head);    \\n};\\n```\\n\\n## Solution-3: Add Property\\n```\\nvar hasCycle = function(head) {\\n    \\n    function run(node) {\\n        if(!node) return false;\\n        if(node.seen) return true;\\n        node.seen = true;\\n        return run(node.next);\\n    }\\n    return run(head);\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar hasCycle = function(head) {\\n    const seen = new Set();\\n    \\n    function traverse(node) {\\n        if(seen.has(node)) return true;\\n        if(!node) return false;\\n        seen.add(node);\\n        return traverse(node.next);\\n    }\\n    return traverse(head);\\n};\\n```\n```javascript\\nvar hasCycle = function(head) {\\n    \\n    function run(fast, slow) {\\n        if(!fast || !fast.next) return false;\\n        if(fast.next === slow) return true;\\n        return run(fast.next.next, slow.next);\\n    }\\n    return run(head, head);    \\n};\\n```\n```\\nvar hasCycle = function(head) {\\n    \\n    function run(node) {\\n        if(!node) return false;\\n        if(node.seen) return true;\\n        node.seen = true;\\n        return run(node.next);\\n    }\\n    return run(head);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44502,
                "title": "by-saying-using-no-extra-space-does-it-mean-o-0-in-space",
                "content": "I cannot give a solution to make it possible. I can only do it in O(1) space using the two runner solution, which I think is the best one.\\n\\n    \\n\\n    // set two runners\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    \\n    // fast runner move 2 steps at one time while slow runner move 1 step,\\n    // if traverse to a null, there must be no loop\\n    while (fast != null && fast.next != null) {\\n    \\tslow = slow.next;\\n    \\tfast = fast.next.next;\\n    \\tif (slow == fast) {\\n    \\t\\treturn true;\\n    \\t}\\n    }\\n    return false;",
                "solutionTags": [],
                "code": "I cannot give a solution to make it possible. I can only do it in O(1) space using the two runner solution, which I think is the best one.\\n\\n    \\n\\n    // set two runners\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    \\n    // fast runner move 2 steps at one time while slow runner move 1 step,\\n    // if traverse to a null, there must be no loop\\n    while (fast != null && fast.next != null) {\\n    \\tslow = slow.next;\\n    \\tfast = fast.next.next;\\n    \\tif (slow == fast) {\\n    \\t\\treturn true;\\n    \\t}\\n    }\\n    return false;",
                "codeTag": "Unknown"
            },
            {
                "id": 2656867,
                "title": "list-set-and-two-pointer-solutions-simply-explained",
                "content": "The simplest way to solve this problem is to keep a list, ```seen```, which will keep track of all the nodes we have already visited. If we ever encounter a node which we have already seen, that means that we must have a cycle! \\n\\n**Method 1: Using List; Time: O(N^2), Memory: O(N)**\\n```\\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\\n\\tseen = [] #list of nodes we have already seen\\n\\twhile head: \\n\\t\\tif head in seen: #if we already saw this node then there is a cycle\\n\\t\\t\\treturn True\\n\\t\\tseen.append(head) #add node to our list of seen nodes\\n\\t\\thead = head.next \\n\\treturn False #we reached the end of the list -- no cycle!\\n```\\n\\nThis method is accepted by LeetCode but is very slow due to the ```O(N)``` time it takes to check ```if head in seen```. We can make a quick optimization to this method by using ```set``` instead of ```list```, since ```set``` (an unordered data structure in python which doesn\\'t allow for duplicates) uses a hashing function for ```O(1)``` lookups (like a dictionary). This reduces the overall time complexity to ```O(N)```!\\n\\n**Method 2: Using Set; Time: O(N), Memory: O(N)**\\n```\\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\\n\\tseen = set() #set of nodes we have already seen\\n\\twhile head:\\n\\t\\tif head in seen: #if we already saw this node then there is a cycle\\n\\t\\t\\treturn True\\n\\t\\tseen.add(head) #add node to our list of seen nodes\\n\\t\\thead = head.next #visit next node\\n\\treturn False #we reached the end of the list -- no cycle!\\n```\\n\\nEven though this is a good solution, you can often solve linked list problems without extra data structures like ```set``` and ```list```. Often, the way to do this is with recursion or two-pointers. For this problem, recursion doesn\\'t offer much help since we would struggle to break the problem up into smaller sub-problems. However, two pointers can be super helpful! We can use a ```slow``` pointer and a ```fast``` pointer to travel through the linked list at different speeds and if they are ever the same node then we know there must be a cycle! Otherwise, the ```fast``` pointer will simply reach the end of the list.\\n\\n**Method 3: Two-pointers; Time: O(N), Memory: O(1)**\\n```\\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\\n\\tslow = fast = head #slow and fast pointers\\n\\twhile fast and fast.next: #while not at the end of the list\\n\\t\\tslow = slow.next #slow moves forward by 1\\n\\t\\tfast = fast.next.next #fast moves forward by 2\\n\\t\\tif slow == fast: #if they are the same then we must have a cycle!\\n\\t\\t\\treturn True\\n\\treturn False #no cycle found\\n```\\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```seen```\n```\\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\\n\\tseen = [] #list of nodes we have already seen\\n\\twhile head: \\n\\t\\tif head in seen: #if we already saw this node then there is a cycle\\n\\t\\t\\treturn True\\n\\t\\tseen.append(head) #add node to our list of seen nodes\\n\\t\\thead = head.next \\n\\treturn False #we reached the end of the list -- no cycle!\\n```\n```O(N)```\n```if head in seen```\n```set```\n```list```\n```set```\n```O(1)```\n```O(N)```\n```\\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\\n\\tseen = set() #set of nodes we have already seen\\n\\twhile head:\\n\\t\\tif head in seen: #if we already saw this node then there is a cycle\\n\\t\\t\\treturn True\\n\\t\\tseen.add(head) #add node to our list of seen nodes\\n\\t\\thead = head.next #visit next node\\n\\treturn False #we reached the end of the list -- no cycle!\\n```\n```set```\n```list```\n```slow```\n```fast```\n```fast```\n```\\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\\n\\tslow = fast = head #slow and fast pointers\\n\\twhile fast and fast.next: #while not at the end of the list\\n\\t\\tslow = slow.next #slow moves forward by 1\\n\\t\\tfast = fast.next.next #fast moves forward by 2\\n\\t\\tif slow == fast: #if they are the same then we must have a cycle!\\n\\t\\t\\treturn True\\n\\treturn False #no cycle found\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1320893,
                "title": "6ms-beats-100-cpp-engineering-hack",
                "content": "PS : Please let me know if this solution will be counted in O(1) space \\n\\n``` \\n if(!head) return false;\\n        int count = 0;\\n        while( head ){\\n            count++;\\n            if(count > 10000) break;\\n            head = head -> next;\\n        }\\n        return count > 10000 ? true : false;\\n\\n```\\n\\n**If you liked the engineering hack please click on UPVOTE icon (^ _ ^)**",
                "solutionTags": [
                    "C"
                ],
                "code": "``` \\n if(!head) return false;\\n        int count = 0;\\n        while( head ){\\n            count++;\\n            if(count > 10000) break;\\n            head = head -> next;\\n        }\\n        return count > 10000 ? true : false;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2439002,
                "title": "very-easy-0-ms-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Linked List Cycle.\\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        // Initialize two node slow and fast point to the hesd node...\\n        ListNode fastptr = head;\\n        ListNode slowptr = head;\\n        while(fastptr != null && fastptr.next != null){\\n            // Move slow pointer by 1 node and fast at 2 at each step.\\n            slowptr = slowptr.next;\\n            fastptr = fastptr.next.next;\\n            // If both the pointers meet at any point, then the cycle is present and return true...\\n            if(slowptr == fastptr)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        // Initialize two node slow and fast point to the hesd node...\\n        ListNode* fastptr = head;\\n        ListNode* slowptr = head;\\n        while(fastptr != NULL && fastptr->next != NULL){\\n            // Move slow pointer by 1 node and fast at 2 at each step.\\n            slowptr = slowptr->next;\\n            fastptr = fastptr->next->next;\\n            // If both the pointers meet at any point, then the cycle is present and return true...\\n            if(slowptr == fastptr)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def hasCycle(self, head):\\n        # Initialize two node slow and fast point to the hesd node...\\n        fastptr = head\\n        slowptr = head\\n        while fastptr is not None and fastptr.next is not None:\\n            # Move slow pointer by 1 node and fast at 2 at each step.\\n            slowptr = slowptr.next\\n            fastptr = fastptr.next.next\\n            # If both the pointers meet at any point, then the cycle is present and return true...\\n            if slowptr == fastptr:\\n                return 1\\n        return 0\\n```\\n                    \\n# **JavaScript Solution:**\\n```\\nvar hasCycle = function(head) {\\n    // Initialize two node slow and fast point to the hesd node...\\n    var fastptr = head;\\n    var slowptr = head;\\n    while(fastptr != null && fastptr.next != null){\\n        // Move slow pointer by 1 node and fast at 2 at each step.\\n        slowptr = slowptr.next;\\n        fastptr = fastptr.next.next;\\n        // If both the pointers meet at any point, then the cycle is present and return true...\\n        if(slowptr == fastptr)\\n            return true;\\n    }\\n    return false;\\n};\\n```\\n\\n# **C Language:**\\n```\\nbool hasCycle(struct ListNode *head) {\\n    // Initialize two node slow and fast point to the hesd node...\\n    struct ListNode* fastptr = head;\\n    struct ListNode* slowptr = head;\\n    while(fastptr != NULL && fastptr->next != NULL){\\n        // Move slow pointer by 1 node and fast at 2 at each step.\\n        slowptr = slowptr->next;\\n        fastptr = fastptr->next->next;\\n        // If both the pointers meet at any point, then the cycle is present and return true...\\n        if(slowptr == fastptr)\\n            return true;\\n    }\\n    return false;\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        # Initialize two node slow and fast point to the hesd node...\\n        fastptr = head\\n        slowptr = head\\n        while fastptr is not None and fastptr.next is not None:\\n            # Move slow pointer by 1 node and fast at 2 at each step.\\n            slowptr = slowptr.next\\n            fastptr = fastptr.next.next\\n            # If both the pointers meet at any point, then the cycle is present and return true...\\n            if slowptr == fastptr:\\n                return 1\\n        return 0\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        // Initialize two node slow and fast point to the hesd node...\\n        ListNode fastptr = head;\\n        ListNode slowptr = head;\\n        while(fastptr != null && fastptr.next != null){\\n            // Move slow pointer by 1 node and fast at 2 at each step.\\n            slowptr = slowptr.next;\\n            fastptr = fastptr.next.next;\\n            // If both the pointers meet at any point, then the cycle is present and return true...\\n            if(slowptr == fastptr)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        // Initialize two node slow and fast point to the hesd node...\\n        ListNode* fastptr = head;\\n        ListNode* slowptr = head;\\n        while(fastptr != NULL && fastptr->next != NULL){\\n            // Move slow pointer by 1 node and fast at 2 at each step.\\n            slowptr = slowptr->next;\\n            fastptr = fastptr->next->next;\\n            // If both the pointers meet at any point, then the cycle is present and return true...\\n            if(slowptr == fastptr)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def hasCycle(self, head):\\n        # Initialize two node slow and fast point to the hesd node...\\n        fastptr = head\\n        slowptr = head\\n        while fastptr is not None and fastptr.next is not None:\\n            # Move slow pointer by 1 node and fast at 2 at each step.\\n            slowptr = slowptr.next\\n            fastptr = fastptr.next.next\\n            # If both the pointers meet at any point, then the cycle is present and return true...\\n            if slowptr == fastptr:\\n                return 1\\n        return 0\\n```\n```\\nvar hasCycle = function(head) {\\n    // Initialize two node slow and fast point to the hesd node...\\n    var fastptr = head;\\n    var slowptr = head;\\n    while(fastptr != null && fastptr.next != null){\\n        // Move slow pointer by 1 node and fast at 2 at each step.\\n        slowptr = slowptr.next;\\n        fastptr = fastptr.next.next;\\n        // If both the pointers meet at any point, then the cycle is present and return true...\\n        if(slowptr == fastptr)\\n            return true;\\n    }\\n    return false;\\n};\\n```\n```\\nbool hasCycle(struct ListNode *head) {\\n    // Initialize two node slow and fast point to the hesd node...\\n    struct ListNode* fastptr = head;\\n    struct ListNode* slowptr = head;\\n    while(fastptr != NULL && fastptr->next != NULL){\\n        // Move slow pointer by 1 node and fast at 2 at each step.\\n        slowptr = slowptr->next;\\n        fastptr = fastptr->next->next;\\n        // If both the pointers meet at any point, then the cycle is present and return true...\\n        if(slowptr == fastptr)\\n            return true;\\n    }\\n    return false;\\n}\\n```\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        # Initialize two node slow and fast point to the hesd node...\\n        fastptr = head\\n        slowptr = head\\n        while fastptr is not None and fastptr.next is not None:\\n            # Move slow pointer by 1 node and fast at 2 at each step.\\n            slowptr = slowptr.next\\n            fastptr = fastptr.next.next\\n            # If both the pointers meet at any point, then the cycle is present and return true...\\n            if slowptr == fastptr:\\n                return 1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549670,
                "title": "2-solutions-easy-to-understand-faster-simple-python-solution",
                "content": "```\\ndef using_two_pointers(self, head):\\n        if not head: return False\\n        slow = head\\n        fast = head.next\\n        while slow and fast and fast != slow and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        return slow == fast\\n    \\n    \\n    def using_dict(self, head):\\n        mem = {}\\n        temp = head\\n        while temp:\\n            if temp in mem: return True\\n            else: mem[temp]= True\\n            temp = temp.next\\n        return False\\n```\\n\\n**I hope that you\\'ve found them useful.**\\n*In that case, please do upvote. It only motivates me to write more such posts\\uD83D\\uDE03*\\n**I am on my quest to document solution to every problem on leetcode\\uD83D\\uDE05**",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\ndef using_two_pointers(self, head):\\n        if not head: return False\\n        slow = head\\n        fast = head.next\\n        while slow and fast and fast != slow and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        return slow == fast\\n    \\n    \\n    def using_dict(self, head):\\n        mem = {}\\n        temp = head\\n        while temp:\\n            if temp in mem: return True\\n            else: mem[temp]= True\\n            temp = temp.next\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3417380,
                "title": "c-java-python-javascript-floyd-s-tortoise-and-hare-algorithm",
                "content": "# Intuition:\\nThe given problem is to detect if there is a cycle in the given linked list. To do so, we use the Floyd\\'s Cycle detection algorithm, which is also known as the \"Tortoise and Hare\" algorithm.\\n\\n# Approach:\\nWe use two pointers, rabbit and tortoise, which start from the head of the linked list. The rabbit moves twice as fast as the tortoise, i.e., it moves two nodes at a time while the tortoise moves one node at a time.\\n\\nIf there is no cycle in the linked list, the rabbit will reach the end of the list, i.e., it will become NULL, and we can return false. However, if there is a cycle, the rabbit will eventually catch up with the tortoise, and both pointers will point to the same node. We return true in this case.\\n\\n## Algorithm Steps:\\n\\n1. Initialize two pointers, rabbit and tortoise, to the head of the linked list.\\n2. While the rabbit pointer is not NULL and its next pointer is not NULL, repeat steps 3-4.\\n3. Move the rabbit pointer two nodes ahead.\\n4. Move the tortoise pointer one node ahead.\\n5. If the rabbit and tortoise pointers point to the same node, return true.\\n6. If the rabbit pointer becomes NULL, return false.\\n# Complexity:\\n- Time complexity: O(n), where n is the number of nodes in the linked list. In the worst case scenario, we will need to traverse the entire list to determine if there is a cycle.\\n- Space complexity: O(1), as we are only using two pointers and not using any additional data structures.\\n\\n# C++\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n       auto rabbit=head, tortoise=head;\\n       while(rabbit && rabbit->next){\\n           rabbit=rabbit->next->next;\\n           tortoise=tortoise->next;\\n           if(rabbit==tortoise){\\n               return true;\\n           }\\n       }\\n       return false;\\n    }\\n};\\n```\\n# JAVA\\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode rabbit = head;\\n        ListNode tortoise = head;\\n        while (rabbit != null && rabbit.next != null) {\\n            rabbit = rabbit.next.next;\\n            tortoise = tortoise.next;\\n            if (rabbit == tortoise) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n```\\n# Python\\n```\\nclass Solution(object):\\n    def hasCycle(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: bool\\n        \"\"\"\\n        rabbit = head\\n        tortoise = head\\n        while rabbit and rabbit.next:\\n            rabbit = rabbit.next.next\\n            tortoise = tortoise.next\\n            if rabbit == tortoise:\\n                return True\\n        return False\\n\\n```\\n# Javascript\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = function(head) {\\n    let rabbit = head, tortoise = head;\\n    while (rabbit && rabbit.next) {\\n        rabbit = rabbit.next.next;\\n        tortoise = tortoise.next;\\n        if (rabbit === tortoise) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n       auto rabbit=head, tortoise=head;\\n       while(rabbit && rabbit->next){\\n           rabbit=rabbit->next->next;\\n           tortoise=tortoise->next;\\n           if(rabbit==tortoise){\\n               return true;\\n           }\\n       }\\n       return false;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode rabbit = head;\\n        ListNode tortoise = head;\\n        while (rabbit != null && rabbit.next != null) {\\n            rabbit = rabbit.next.next;\\n            tortoise = tortoise.next;\\n            if (rabbit == tortoise) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def hasCycle(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: bool\\n        \"\"\"\\n        rabbit = head\\n        tortoise = head\\n        while rabbit and rabbit.next:\\n            rabbit = rabbit.next.next\\n            tortoise = tortoise.next\\n            if rabbit == tortoise:\\n                return True\\n        return False\\n\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = function(head) {\\n    let rabbit = head, tortoise = head;\\n    while (rabbit && rabbit.next) {\\n        rabbit = rabbit.next.next;\\n        tortoise = tortoise.next;\\n        if (rabbit === tortoise) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673790,
                "title": "python3-solution-without-new-pointer-in-8-lines",
                "content": "# Intuition\\nCome up with this solution when seeing the limit of node\\'s value is between -10^5 and 10^5.\\n\\n# Approach\\n1. Loop through the linked list. If the current node is None, it means there is no cycle.\\n2. Modify the value of the node that has checked. The value could be anything out of the range -10^5 and 10^5.\\n\\n# Complexity\\nTime: O(n)\\nSpace: O(1) \\n\\n# Code\\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        while head:\\n            if head.val == 10**6:\\n                return True\\n            head.val = 10**6\\n            head = head.next\\n        return False\\n\\n```\\n\\nPlease upvote \\u2B06 if you like my very first solution \\u0295\\u2022\\u1D25\\u2022\\u0294",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        while head:\\n            if head.val == 10**6:\\n                return True\\n            head.val = 10**6\\n            head = head.next\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938506,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.next = nil\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func hasCycle(_ head: ListNode?) -> Bool {\\n        var slow = head\\n        var fast = head?.next\\n        \\n        while slow != nil, fast != nil {\\n            guard slow !== fast else { return true }\\n            \\n            slow = slow?.next\\n            fast = fast?.next?.next            \\n        }\\n        \\n        return false\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.next = nil\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func hasCycle(_ head: ListNode?) -> Bool {\\n        var slow = head\\n        var fast = head?.next\\n        \\n        while slow != nil, fast != nil {\\n            guard slow !== fast else { return true }\\n            \\n            slow = slow?.next\\n            fast = fast?.next?.next            \\n        }\\n        \\n        return false\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44607,
                "title": "in-place-python-code-beats-90",
                "content": "Multiple pointers having different steps are our friend to solve Linked List problems. We can set two pointers to \"run through\" the linked list. Since they have different pace, if the list is cyclic, they **must** meet after the starting point. \\n\\nIn this case I choose two pointers and steps are `1` and `2` respectively. I think assigning one step as `3` is also doable, but I have no ideas which one is better.\\n<br>\\n\\n    def hasCycle(self, head):\\n        fast = slow = head\\n\\n        while slow and fast and fast.next:\\n            slow = slow.next                # Step of 1\\n            fast = fast.next.next           # Setp of 2\\n\\n            if slow is fast:                # Checking whether two pointers meet\\n                return True\\n\\n        return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "Multiple pointers having different steps are our friend to solve Linked List problems. We can set two pointers to \"run through\" the linked list. Since they have different pace, if the list is cyclic, they **must** meet after the starting point. \\n\\nIn this case I choose two pointers and steps are `1` and `2` respectively. I think assigning one step as `3` is also doable, but I have no ideas which one is better.\\n<br>\\n\\n    def hasCycle(self, head):\\n        fast = slow = head\\n\\n        while slow and fast and fast.next:\\n            slow = slow.next                # Step of 1\\n            fast = fast.next.next           # Setp of 2\\n\\n            if slow is fast:                # Checking whether two pointers meet\\n                return True\\n\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 44614,
                "title": "java-11ms-solution-with-hashset-and-1ms-solution-without-extra-space",
                "content": "        public boolean hasCycle(ListNode head) {\\n    \\t\\tif (head == null || head.next == null)\\n    \\t\\t\\treturn false;\\n    \\t\\tHashSet<ListNode> nodeSet = new HashSet<>();\\n    \\t\\twhile(head != null) {\\n    \\t\\t\\tif (nodeSet.contains(head))\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t\\tnodeSet.add(head);\\n    \\t\\t\\thead = head.next;\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}\\n    \\t\\n    \\tpublic boolean hasCycleNoExtraSpace(ListNode head) {\\n    \\t\\tif (head == null || head.next == null) \\n    \\t\\t\\treturn false;\\n    \\t\\tListNode p = head;\\n    \\t\\tListNode q = head;\\n    \\t\\twhile(q != null && q.next != null) {\\n    \\t\\t\\tp = p.next;\\n    \\t\\t\\tq = q.next.next;\\n    \\t\\t\\tif (p == q)\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "        public boolean hasCycle(ListNode head) {\\n    \\t\\tif (head == null || head.next == null)\\n    \\t\\t\\treturn false;\\n    \\t\\tHashSet<ListNode> nodeSet = new HashSet<>();\\n    \\t\\twhile(head != null) {\\n    \\t\\t\\tif (nodeSet.contains(head))\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t\\tnodeSet.add(head);\\n    \\t\\t\\thead = head.next;\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}\\n    \\t\\n    \\tpublic boolean hasCycleNoExtraSpace(ListNode head) {\\n    \\t\\tif (head == null || head.next == null) \\n    \\t\\t\\treturn false;\\n    \\t\\tListNode p = head;\\n    \\t\\tListNode q = head;\\n    \\t\\twhile(q != null && q.next != null) {\\n    \\t\\t\\tp = p.next;\\n    \\t\\t\\tq = q.next.next;\\n    \\t\\t\\tif (p == q)\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3999179,
                "title": "video-solution-with-two-pointers-and-a-bonus-video-python-javascript-java-c",
                "content": "# Intuition\\nThe main idea to solve the question of detecting a cycle in a singly-linked list is to use the concept of two pointers: a \"slow\" pointer that moves one step at a time and a \"fast\" pointer that moves two steps at a time. By having these two pointers traverse the list simultaneously, if there is a cycle, the fast pointer will eventually catch up to the slow pointer. If there is no cycle, the fast pointer will reach the end of the list.\\n\\n---\\n\\n# Solution Video\\n\\n### Please subscribe to my channel from here. I have 254 videos as of September 4th, 2023.\\n\\nhttps://youtu.be/AwlrFqjq0cY\\n\\n### In the video, the steps of approach below are visualized using diagrams and drawings. I\\'m sure you understand the solution easily!\\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nThe next subscriber will be exact 2200.\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. Initialize `fast` and `slow` pointers to the head of the linked list.\\n   - `fast` and `slow` are initially pointing to the head of the linked list, which is the starting point.\\n\\n2. Enter a loop while both `fast` and `fast.next` are not null.\\n   - This loop will continue until either `fast` or `fast.next` becomes null, indicating the end of the linked list or if there is no cycle.\\n\\n3. Move the `fast` pointer two steps ahead (`fast = fast.next.next`) and the `slow` pointer one step ahead (`slow = slow.next`).\\n   - This step simulates the two-pointer traversal where `fast` moves twice as fast as `slow`.\\n\\n4. Check if `fast` is equal to `slow`.\\n   - If `fast` and `slow` pointers meet at the same node, it means there is a cycle in the linked list, and we return `True`.\\n\\n5. If the loop exits without finding a cycle, return `False`.\\n   - If the loop completes without finding a cycle, it means that the `fast` pointer has reached the end of the list, and there is no cycle. In this case, we return `False`.\\n\\nThis algorithm uses two pointers, `fast` and `slow`, to traverse the linked list. The `fast` pointer moves twice as fast as the `slow` pointer. If there is a cycle, the `fast` pointer will eventually catch up to the `slow` pointer. If there is no cycle, the `fast` pointer will reach the end of the list, and the function will return `False`. This algorithm is an efficient way to detect cycles in a singly-linked list.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n```python []\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n    \\n        fast = head\\n        slow = head\\n        \\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            \\n            if fast == slow:\\n                return True\\n    \\n        return False\\n```\\n```javascript []\\nvar hasCycle = function(head) {\\n    let fast = head;\\n    let slow = head;\\n\\n    while (fast && fast.next) {\\n        fast = fast.next.next;\\n        slow = slow.next;\\n\\n        if (fast === slow) {\\n            return true;\\n        }\\n    }\\n\\n    return false;    \\n};\\n```\\n```java []\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n\\n            if (fast == slow) {\\n                return true;\\n            }\\n        }\\n\\n        return false;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n\\n        while (fast != nullptr && fast->next != nullptr) {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n\\n            if (fast == slow) {\\n                return true;\\n            }\\n        }\\n\\n        return false;        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n    \\n        fast = head\\n        slow = head\\n        \\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            \\n            if fast == slow:\\n                return True\\n    \\n        return False\\n```\n```javascript []\\nvar hasCycle = function(head) {\\n    let fast = head;\\n    let slow = head;\\n\\n    while (fast && fast.next) {\\n        fast = fast.next.next;\\n        slow = slow.next;\\n\\n        if (fast === slow) {\\n            return true;\\n        }\\n    }\\n\\n    return false;    \\n};\\n```\n```java []\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n\\n            if (fast == slow) {\\n                return true;\\n            }\\n        }\\n\\n        return false;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n\\n        while (fast != nullptr && fast->next != nullptr) {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n\\n            if (fast == slow) {\\n                return true;\\n            }\\n        }\\n\\n        return false;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048428,
                "title": "python-3-solutions-explained",
                "content": "**Solution 1:** Easiest method\\n```html5\\n<b>Time Complexity: O(n)</b> &becaus; we must traverse every node in the linked list\\n<b>Space Complexity: O(n)</b> &becaus; we need to store every node in the linked list in seen\\n```\\n\\nIterate over the linked list, if head is ever None, then we reached the end, there is no cycle.\\nIf head is ever a node that we have already seen, then return True, there is a cycle.\\n\\n```python\\ndef hasCycle(self, head: ListNode) -> bool:\\n\\tseen = set()\\n\\twhile head:\\n\\t\\tif head in seen:\\n\\t\\t\\treturn True\\n\\t\\tseen.add(head)\\n\\t\\thead = head.next\\n\\treturn False\\n```\\n\\n<br>\\n\\n**Solution 2:** Two turtles and one Hare\\n```html5\\n<b>Time Complexity: O(n)</b> &becaus; we must traverse every node in the linked list\\n<b>Space Complexity: O(1)</b> &becaus; we only need to store 3 pointers regardless of the length of the list\\n```\\n\\nTwo turtles start off at node\\'s 0 and 1, and the rabbit starts off at node 1.  \\nEach turn, the rabbit moves 2 nodes forward and each turtle only moves 1 node forward.\\nIf there is a cycle, eventually the rabbit **must** land on a turtle because it cannot move more\\nthan 2 spaces at a time, and the two turtles (side by side) cover 2 spaces.\\nIf the rabbit lands on the same node as a turtle, then there is a cycle.\\nIf the rabbit runs out of nodes, then there is no cycle.\\n\\n```python\\ndef hasCycle(self, head: ListNode) -> bool:\\n\\tif not head: return False\\n\\thare = turtle1 = head.next\\n\\tturtle2 = head\\n\\twhile True:\\n\\t\\t# move hare pointer up two\\n\\t\\tif not hare or not hare.next: return False\\n\\t\\thare = hare.next.next\\n\\n\\t\\t# move both turtles forward one node\\n\\t\\tif turtle1 == hare or turtle2 == hare: return True\\n\\t\\tturtle1, turtle2 = turtle1.next, turtle2.next\\n```\\n\\n<br>\\n\\n**Solution 3:** One turtle and one hare\\n```html5\\n<b>Time Complexity: O(n)</b> &becaus; we must traverse every node in the linked list\\n<b>Space Complexity: O(1)</b> &becaus; we only need to store 2 pointers regardless of the length of the list\\n```\\n\\n```python\\ndef hasCycle(self, head: ListNode) -> bool:\\n\\tif not head: return False\\n\\thare = turtle = head\\n\\twhile True:\\n\\t\\tturtle = turtle.next\\n\\t\\tif not hare or not hare.next: return False\\n\\t\\thare = hare.next.next\\n\\t\\tif hare == turtle:\\n\\t\\t\\treturn True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```html5\\n<b>Time Complexity: O(n)</b> &becaus; we must traverse every node in the linked list\\n<b>Space Complexity: O(n)</b> &becaus; we need to store every node in the linked list in seen\\n```\n```python\\ndef hasCycle(self, head: ListNode) -> bool:\\n\\tseen = set()\\n\\twhile head:\\n\\t\\tif head in seen:\\n\\t\\t\\treturn True\\n\\t\\tseen.add(head)\\n\\t\\thead = head.next\\n\\treturn False\\n```\n```html5\\n<b>Time Complexity: O(n)</b> &becaus; we must traverse every node in the linked list\\n<b>Space Complexity: O(1)</b> &becaus; we only need to store 3 pointers regardless of the length of the list\\n```\n```python\\ndef hasCycle(self, head: ListNode) -> bool:\\n\\tif not head: return False\\n\\thare = turtle1 = head.next\\n\\tturtle2 = head\\n\\twhile True:\\n\\t\\t# move hare pointer up two\\n\\t\\tif not hare or not hare.next: return False\\n\\t\\thare = hare.next.next\\n\\n\\t\\t# move both turtles forward one node\\n\\t\\tif turtle1 == hare or turtle2 == hare: return True\\n\\t\\tturtle1, turtle2 = turtle1.next, turtle2.next\\n```\n```html5\\n<b>Time Complexity: O(n)</b> &becaus; we must traverse every node in the linked list\\n<b>Space Complexity: O(1)</b> &becaus; we only need to store 2 pointers regardless of the length of the list\\n```\n```python\\ndef hasCycle(self, head: ListNode) -> bool:\\n\\tif not head: return False\\n\\thare = turtle = head\\n\\twhile True:\\n\\t\\tturtle = turtle.next\\n\\t\\tif not hare or not hare.next: return False\\n\\t\\thare = hare.next.next\\n\\t\\tif hare == turtle:\\n\\t\\t\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 44636,
                "title": "accepted-6-line-code-in-c",
                "content": "    bool hasCycle(struct ListNode *head) {\\n        struct ListNode *fast=head, *slow=head;\\n        while( slow && fast && fast->next ){\\n            fast=fast->next->next;\\n            slow=slow->next;\\n            if(fast==slow) return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    bool hasCycle(struct ListNode *head) {\\n        struct ListNode *fast=head, *slow=head;\\n        while( slow && fast && fast->next ){\\n            fast=fast->next->next;\\n            slow=slow->next;\\n            if(fast==slow) return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1535461,
                "title": "c-method-two-pointer",
                "content": "# First I tried using hashset but that requires O(n) space\\n```\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        \\n        HashSet<ListNode> finder = new HashSet<ListNode>();\\n        \\n        ListNode current = head;\\n        \\n        while(current != null)\\n        {\\n            if(finder.Contains(current))\\n                return true;\\n            \\n            finder.Add(current);\\n            current = current.next;\\n        }\\n        \\n        return false;\\n        \\n    }\\n}\\n```\\n# Then I tried two pointers approach \\n```\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        if(head == null) return false;\\n        \\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while(fast != null && fast.next != null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            \\n            if(slow == fast)\\n                return true;\\n        }\\n\\n        return false;\\n        \\n    }\\n}\\n```\\n\\n# Key here is that when you move one pointer slowly and another pointer faster then eventually if there is a cycle they will meetup.",
                "solutionTags": [
                    "C#",
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        \\n        HashSet<ListNode> finder = new HashSet<ListNode>();\\n        \\n        ListNode current = head;\\n        \\n        while(current != null)\\n        {\\n            if(finder.Contains(current))\\n                return true;\\n            \\n            finder.Add(current);\\n            current = current.next;\\n        }\\n        \\n        return false;\\n        \\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        if(head == null) return false;\\n        \\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while(fast != null && fast.next != null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            \\n            if(slow == fast)\\n                return true;\\n        }\\n\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 167587,
                "title": "java-python-logical-thinking",
                "content": "We set two pointers fast and slow. \\nfast moves 2 steps at a time, while slow moves one step a time as below,\\n\\n1: |sf--------|\\n2: |-s-f------|\\n3: |--s--f----|\\n4: |---s---f--|\\n5: |----s----f|\\n\\nIf there is no cycle in the List, the fast pointer reaches the tail at O(n/2) time.\\n\\nIf the List is circular, the slow pointer moves through the whole List and eventually equals to the fast pointer\\n\\n6: |--f---s---|\\n7: |----f--s--| x\\n8: |------f-s-|\\n9: |--------fs|\\n10: s == f\\n\\nIf the list contains a cycle (but not circular),\\ncase 1:\\n6: |---f--s---|\\n7: |-----f-s--|\\n8: |-------fs-|\\n9: s == f\\n\\ncase 2:\\n6: |----f-s---| same as x\\n...\\n\\ncase n:\\nsame as ...\\n****\\n**Java**\\n```\\n    public boolean hasCycle(ListNode head) {\\n        \\n        ListNode fast = head, slow = head;\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (slow == fast) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```\\n**Python**\\n```\\n    def hasCycle(self, head):        \\n        slow = fast = head\\n            \\n        while fast != None and fast.next != None:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n                    \\n        return False\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n    public boolean hasCycle(ListNode head) {\\n        \\n        ListNode fast = head, slow = head;\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (slow == fast) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```\n```\\n    def hasCycle(self, head):        \\n        slow = fast = head\\n            \\n        while fast != None and fast.next != None:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n                    \\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 44690,
                "title": "my-easy-12ms-c-solution-sharing",
                "content": "    bool hasCycle(ListNode *head) \\n    {\\n        ListNode *fast;\\n        fast = head;\\n        while (head)\\n        {\\n            head = head->next;\\n            if (fast->next && fast->next->next)\\n                fast = fast->next->next;\\n            else\\n                return false;\\n                \\n            if (fast == head)\\n                return true;\\n        }\\n        \\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    bool hasCycle(ListNode *head) \\n    {\\n        ListNode *fast;\\n        fast = head;\\n        while (head)\\n        {\\n            head = head->next;\\n            if (fast->next && fast->next->next)\\n                fast = fast->next->next;\\n            else\\n                return false;\\n                \\n            if (fast == head)\\n                return true;\\n        }\\n        \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1776569,
                "title": "javascript-time-o-n-space-o-1-simple-approach-with-explanation",
                "content": "1. Visit a Node and replace its value to any non integer, here I took \\'X\\' character.\\n2. Move to next Node and check if it is \\'X\\'\\n3. if true means it is a cycle so return true\\n4. else Move to next... repeat step 2 and 3 till end of the Linked list.\\n5. return false if no cycle found.\\n\\n\\n```\\nvar hasCycle = function(head) {\\n    let start = new ListNode(head);\\n    while(head){\\n        if(head.val === \\'X\\'){\\n            return true;\\n        }\\n        head.val = \\'X\\';\\n        head = head.next;\\n    }\\n    return false;\\n};\\n```\\n\\n**Upvote** if helped.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hasCycle = function(head) {\\n    let start = new ListNode(head);\\n    while(head){\\n        if(head.val === \\'X\\'){\\n            return true;\\n        }\\n        head.val = \\'X\\';\\n        head = head.next;\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1829907,
                "title": "c-detailed-explanation-w-images-see-visually-how-pointer-changes-commented-code",
                "content": "***Brief note about Question***-\\n* We have to return true if there is a cycle in the linked list. Otherwise, return false.\\n```\\nLet\\'s take an example not given in the question-\\nSuppose our head and position given to us as head = [4,5,6,7,8,9] & pos = 4\\n\\nSo, linked looks like-\\n\\n  4 --> 5 --> 6 --> 7 --> 8 --> 9\\n                          \\u2191     \\u2193\\n\\t\\t\\t\\t\\t\\t  \\u2190 \\u2190 \\u2190 \\u2193\\n\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t  So, their is a cycle at position 4,\\n\\t\\t\\t\\t\\t\\t  therefore we have to return true as our answer\\n```\\n_____________\\n***Solution - I (Accepted)-***\\n* We maintain two pointers i.e slow and fast.\\n* Our fast pointer takes two step at a time and slow pointer is slow so he takes one step at a time.\\n* So, if their is a cycle present in our linked list, then no matter how fast our fast pointer moves. their is a time come when both i.e slow and fast pointer are standing on a same position.\\n* Why this happen? See, since our fast pointer taking two steps at a time,so by defaullt he will be always ahead of our slow pointer.\\n* But their is a cycle present in the linked list, our fast pointer end up in moving the cycle only.\\n* And their is a time came when both our fast and slow pointer stands up the same position.\\n* So, If fast and slow pointer cames to same position then we will return true by saying that yes their is a cycle in the linked list.\\n* But, Suppose if their is no cycle present in the linked list, then? \\n* If their is no cyle present in the linked list then our fast pointer was the first one who reaches to the end.\\n* So if fast pointer reaches to the end, then we will say their is no cycle present in the linked list and hence return false.\\n* See below Image for better clarification.\\n_________________\\n* ![image](https://assets.leetcode.com/users/images/11e14acb-6005-4c2a-8ed5-59908440490a_1646713764.0097659.jpeg)\\n_________\\n**Code (C++)**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* slow = head; // making slow pointer\\n        ListNode* fast = head; // making fast pointer\\n\\n        while(fast != NULL && fast -> next != NULL)\\n        {\\n            slow = slow -> next; // move slow one step at a time\\n            fast = fast -> next -> next; // move fast two step at a time\\n            \\n            // if at any point slow and fast pointer reaches to the same pos\\n            // then we can say that yess!, their is a cycle and hence return true\\n\\t\\t\\t\\n            if(slow == fast) // if slow is equal to fast\\n            {\\n                return true; // means cycle, and hence return true\\n            }\\n        }\\n        \\n        // otherwise no cycle is present, hence return false\\n        return false;\\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLet\\'s take an example not given in the question-\\nSuppose our head and position given to us as head = [4,5,6,7,8,9] & pos = 4\\n\\nSo, linked looks like-\\n\\n  4 --> 5 --> 6 --> 7 --> 8 --> 9\\n                          \\u2191     \\u2193\\n\\t\\t\\t\\t\\t\\t  \\u2190 \\u2190 \\u2190 \\u2193\\n\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t  So, their is a cycle at position 4,\\n\\t\\t\\t\\t\\t\\t  therefore we have to return true as our answer\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* slow = head; // making slow pointer\\n        ListNode* fast = head; // making fast pointer\\n\\n        while(fast != NULL && fast -> next != NULL)\\n        {\\n            slow = slow -> next; // move slow one step at a time\\n            fast = fast -> next -> next; // move fast two step at a time\\n            \\n            // if at any point slow and fast pointer reaches to the same pos\\n            // then we can say that yess!, their is a cycle and hence return true\\n\\t\\t\\t\\n            if(slow == fast) // if slow is equal to fast\\n            {\\n                return true; // means cycle, and hence return true\\n            }\\n        }\\n        \\n        // otherwise no cycle is present, hence return false\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226855,
                "title": "javascript",
                "content": "**\\u65B9\\u6CD51:** \\u4F7F\\u7528\\u96C6\\u5408\\u5224\\u65AD\\n**\\u89E3\\u9898\\u601D\\u8DEF:**\\n1. \\u4E0D\\u65AD\\u904D\\u5386\\u94FE\\u8868, \\u5C06\\u904D\\u5386\\u8FC7\\u7684\\u8282\\u70B9\\u653E\\u5165\\u96C6\\u5408\\u4E2D.\\n2. \\u5982\\u679C\\u8282\\u70B9\\u51FA\\u73B0\\u5728\\u4E4B\\u524D\\u7684\\u96C6\\u5408\\u4E2D, \\u5219\\u4E3A\\u6709\\u73AF.\\n\\n**\\u4EE3\\u7801:**\\n```\\nvar hasCycle = function(head) {\\n  const nodes = new Set();\\n  while (head) {\\n    if (nodes.has(head)) return true;\\n    nodes.add(head);\\n    head = head.next;\\n  }\\n  return false;\\n};\\n```\\n\\n**\\u65B9\\u6CD52:** \\u5FEB\\u6162\\u6307\\u9488\\u6CD5\\n**\\u89E3\\u9898\\u601D\\u8DEF:**\\n1. \\u5FEB\\u6307\\u9488\\u6BCF\\u6B21\\u8D70\\u4E24\\u6B65, \\u6162\\u6307\\u9488\\u6BCF\\u6B21\\u8D70\\u4E00\\u6B65. \\u90A3\\u5B9E\\u9645\\u4E0A\\u5FEB\\u6307\\u9488\\u4F1A\\u6BD4\\u6162\\u6307\\u9488\\u591A\\u8D70\\u4E00\\u6B65.\\n2. \\u53EA\\u8981\\u5B58\\u5728\\u73AF\\u8DEF, \\u90A3\\u4E48\\u5FEB\\u6307\\u9488\\u4E00\\u5B9A\\u4F1A\\u8FFD\\u4E0A\\u6162\\u6307\\u9488, \\u5E76\\u4E14\\u76F8\\u7B49\\u800C\\u4E0D\\u4F1A\\u8DF3\\u8FC7.\\n\\n**\\u4EE3\\u7801:**\\n```\\nvar hasCycle = function(head) {\\n  let fast = head;\\n  let slow = head;\\n  \\n  while (fast && fast.next) {\\n    fast = fast.next.next;\\n    slow = slow.next;\\n    \\n    if (fast === slow) return true;\\n  }\\n  return false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar hasCycle = function(head) {\\n  const nodes = new Set();\\n  while (head) {\\n    if (nodes.has(head)) return true;\\n    nodes.add(head);\\n    head = head.next;\\n  }\\n  return false;\\n};\\n```\n```\\nvar hasCycle = function(head) {\\n  let fast = head;\\n  let slow = head;\\n  \\n  while (fast && fast.next) {\\n    fast = fast.next.next;\\n    slow = slow.next;\\n    \\n    if (fast === slow) return true;\\n  }\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1561115,
                "title": "python-easy-solution-with-explanation-institutive",
                "content": "* **Idea** : we create two runners \\n\\t*  slow : go through the linked list one step a time\\n\\t* fast : go through the linked list two step at a time\\n*  If the the fast or the slow hit the end before they meet\\n\\t* the linked list doesn\\'t have a cycle\\n* If they become equal at some point\\n\\t* \\tthe linked list has a cycle        \\n\\n        \\n```\\ndef hasCycle(self, head):\\n        if not head or not head.next:\\n            return False\\n        \\n        slow = head # slow mover pointer\\n        fast = head.next # fast mover pointer\\n        \\n        while fast != None and fast.next != None: # since the fast pointer is the leader; if there is an end it would be the fast who would hit the end first\\n            if slow == fast: # if they are equal the fast finsh the cycle and has catch the slow --> there is a cycle\\n                return True\\n            else:  # else just move slow one step and fast two step at a time\\n                slow = slow.next\\n                fast = fast.next.next\\n        return False # if the fast hit the end, there is no cycle\\n```\\n\\n##### If you\\'ve found this helpful, comment and upvote  \\n* ##### encourage me to on my quest to document leetcode problem solutions\\uD83D\\uDE03\\n##### Search for Abeni tag in the discussion, \\n* ##### if I have solved it, You will find a detial explanation there \\uD83E\\uDD16",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\ndef hasCycle(self, head):\\n        if not head or not head.next:\\n            return False\\n        \\n        slow = head # slow mover pointer\\n        fast = head.next # fast mover pointer\\n        \\n        while fast != None and fast.next != None: # since the fast pointer is the leader; if there is an end it would be the fast who would hit the end first\\n            if slow == fast: # if they are equal the fast finsh the cycle and has catch the slow --> there is a cycle\\n                return True\\n            else:  # else just move slow one step and fast two step at a time\\n                slow = slow.next\\n                fast = fast.next.next\\n        return False # if the fast hit the end, there is no cycle\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1515121,
                "title": "c-python-simple-two-pointers-solution",
                "content": "**C++ :**\\n\\n```\\nbool hasCycle(ListNode *head) {\\n\\tListNode* slow = head;\\n\\tListNode* fast = head;\\n\\n\\twhile(slow && fast && fast -> next)\\n\\t{\\n\\t\\tslow = slow -> next;\\n\\t\\tfast  = fast -> next -> next;\\n\\n\\t\\tif(slow == fast)\\n\\t\\t\\treturn true;\\n\\t}\\n\\n\\treturn false;\\n}\\n```\\n\\n**Python :**\\n\\n```\\ndef hasCycle(self, head: ListNode) -> bool:\\n\\tslow = head\\n\\tfast = head\\n\\n\\twhile slow and fast and fast.next:\\n\\t\\tslow = slow.next\\n\\t\\tfast  = fast.next.next\\n\\n\\t\\tif slow == fast:\\n\\t\\t\\treturn True\\n\\n\\treturn False\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nbool hasCycle(ListNode *head) {\\n\\tListNode* slow = head;\\n\\tListNode* fast = head;\\n\\n\\twhile(slow && fast && fast -> next)\\n\\t{\\n\\t\\tslow = slow -> next;\\n\\t\\tfast  = fast -> next -> next;\\n\\n\\t\\tif(slow == fast)\\n\\t\\t\\treturn true;\\n\\t}\\n\\n\\treturn false;\\n}\\n```\n```\\ndef hasCycle(self, head: ListNode) -> bool:\\n\\tslow = head\\n\\tfast = head\\n\\n\\twhile slow and fast and fast.next:\\n\\t\\tslow = slow.next\\n\\t\\tfast  = fast.next.next\\n\\n\\t\\tif slow == fast:\\n\\t\\t\\treturn True\\n\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1829693,
                "title": "python-go-floyd-s-cycle-detection-solution-and-explanation",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python/Go] \\uD83C\\uDF1FFloyd\\'s Cycle Detection Solution and Explanation \\uD83D\\uDC95\\n\\n## 1\\uFE0F\\u20E3 Floyd\\'s Cycle Detection Approach:\\nIn this question we set two pointer:\\n> **slow**: move to next pointer each time\\n> **fast**: move to next.next pointer each time\\n\\n> Step 1: Traverse slow and fast pointer all the way until they meet\\n( If there is no cycle in the linked list the fast pointer will point to None eventually)\\n\\n> Step 2: Return if slow == fast, (if there is no cycle fast will be None)\\n\\n## Math Explained\\nLet the whole linked-list\\'s length be *n*, distance between **head** and the **slow index** of the cycle be *m*,\\nThe distance between **slow index** of the cycle and the **index where slow and fast pointer meets** to be *p*\\n\\nWe can know that in the step 1: first pointer traverse the distance m+p and the second traverse 2(m + p) and also equals to  n+p => n = 2m + p\\nUpon this equation if we move second pointer m step it will traverse the linked-list again point at 2m + p which is our target\\n\\n### IF YOU CAN: Better draw a graph and mark these distance so you will know the whole math equation\\n\\n## Complexity Analysis\\n* Time: O(N): Let N be the length of linked list\\n* Space: O(1)\\n* \\n## Floyd\\'s Cycle Detection Code\\n**Python**\\n```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        if head is None or head.next is None:\\n            return False\\n        slow = head\\n        fast = head.next\\n        while fast.next and fast.next.next and slow != fast:\\n            slow = slow.next\\n            fast = fast.next.next\\n        return slow == fast\\n```\\n**Go**\\n```go\\nfunc hasCycle(head *ListNode) bool {\\n    if head == nil || head.Next == nil{\\n        return false\\n    }\\n    slow := head\\n    fast := head.Next\\n    \\n    for fast.Next != nil && fast.Next.Next != nil && fast != slow{\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n    }\\n    \\n    return slow == fast\\n}\\n```\\n\\nFOLLOW-UP : [142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/)\\nMy Explanation : https://leetcode.com/problems/linked-list-cycle-ii/discuss/1701051/Python-3-Solution-Tow-Pointer-O(N)-Explained\\n\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [
                    "Python",
                    "Go"
                ],
                "code": "```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        if head is None or head.next is None:\\n            return False\\n        slow = head\\n        fast = head.next\\n        while fast.next and fast.next.next and slow != fast:\\n            slow = slow.next\\n            fast = fast.next.next\\n        return slow == fast\\n```\n```go\\nfunc hasCycle(head *ListNode) bool {\\n    if head == nil || head.Next == nil{\\n        return false\\n    }\\n    slow := head\\n    fast := head.Next\\n    \\n    for fast.Next != nil && fast.Next.Next != nil && fast != slow{\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n    }\\n    \\n    return slow == fast\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1378006,
                "title": "java-easy-to-understand-slow-ptr-fast-ptr-approach",
                "content": "```\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow = head,fast = head;\\n        if(head == null || head.next == null)return false;\\n        while(fast != null && fast.next != null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow = head,fast = head;\\n        if(head == null || head.next == null)return false;\\n        while(fast != null && fast.next != null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047819,
                "title": "easy-in-python-o-1-beats-91",
                "content": "```\\nclass Solution(object):\\n    def hasCycle(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: bool\\n        \"\"\"\\n\\t\\tif head is None or head.next is None return False\\n        slow_ref = head\\n        fast_ref = head\\n        while fast_ref and fast_ref.next:\\n            slow_ref = slow_ref.next\\n            fast_ref = fast_ref.next.next\\n            if slow_ref == fast_ref:\\n                return True\\n        return False\\n\\t\\t\\n\\tIf you get it please Upvote.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution(object):\\n    def hasCycle(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: bool\\n        \"\"\"\\n\\t\\tif head is None or head.next is None return False\\n        slow_ref = head\\n        fast_ref = head\\n        while fast_ref and fast_ref.next:\\n            slow_ref = slow_ref.next\\n            fast_ref = fast_ref.next.next\\n            if slow_ref == fast_ref:\\n                return True\\n        return False\\n\\t\\t\\n\\tIf you get it please Upvote.",
                "codeTag": "Java"
            },
            {
                "id": 3493885,
                "title": "full-explanation-beautiful-easy-approach",
                "content": "# Intuition\\nFast slow pointer approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe will use two pointers with different steps forward. The process is as follows:-\\n\\n1. We will take two pointers, namely fast and slow. Fast pointer takes 2 steps ahead and slow pointer takes 2 points ahead.\\n2. Iterate through the list until the fast pointer is equal to NULL. This is because NULL indicates that there is no cycle present in the given list.\\n3. Cycle can be detected when fast and slow pointers collide.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow= head;\\n        ListNode fast= head;\\n        while(fast!=null&& fast.next!=null){\\n            slow= slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/e1101f1c-4697-4ad1-8f66-f761c855f316_1683395057.6222804.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow= head;\\n        ListNode fast= head;\\n        while(fast!=null&& fast.next!=null){\\n            slow= slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048089,
                "title": "c-floyd-s-cycle-finding-algorithm-o-n-fastest-solution",
                "content": "**Floyd\\u2019s Cycle-Finding Algorithm**\\n\\nTraverse linked list using one **slow** and one **fast** pointer. Move the **slow pointer** by one and the **fast pointer** by two.\\n\\n**CASE 1**\\nIf these pointers meet at the same node then there is a loop.\\n\\n**CASE 2**\\nIf pointers do not meet then the linked list doesn\\u2019t have a loop.\\n\\n**EXAMPLE**\\nConsider the below image.\\n**Initially considering fast pointer = slow pointer +1 , so Distance =1.**\\n\\n![Floyd-Algo-Proof](https://assets.leetcode.com/users/images/8be7aed7-e0d6-43c7-ae61-de4c1d359ede_1612365738.3477886.png)\\n\\n**Finally, if the Distance at any point becomes zero, that is Slow==Fast then cycle found.**\\n\\n\\n**NOTE**\\nIt is absolutely all right to start the **slow** and **fast** pointers from the first and second node respectively **or** both from the first node. ( if they exists ).\\n\\n\\n**CODE**\\n\\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n        ListNode *slow=head;\\n        ListNode *fast;\\n        \\n        if(slow)\\n            fast=head->next; // \"fast\" can also start from the same node as \"slow\"\\n        else\\n            return false;\\n        \\n        while(slow||fast){  // while traversing if both of them becomes NULL together, no cycle found\\n\\t\\t\\t\\n            if(slow==fast) // then we got the same node again, hence cycle found\\n                return true; // [ CASE 1 ]\\n            \\n            if(slow)\\n                slow=slow->next; // move 1 step at a time\\n            \\n            if(fast){\\n                if(fast->next)\\n                    fast=fast->next->next; // move 2 step at a time\\n                else\\n                    break; // if 2 step jump not possible at any node then break from loop, hence no cycle\\n            }\\n        }\\n        // [ CASE 2 ]\\n        return false; // no cycle found at this point\\n    }\\n};\\n```\\n\\n\\nConsidering *N* to be the total number of nodes of the link list\\n\\n**TIME COMPLEXITY:** O(N)\\n*[ Atmax the whole link list will be traversed by the slow pointer one time ]*\\n\\n**SPACE COMPLEXITY:** O(1)\\n*[ Since no extra space is used ]*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n        ListNode *slow=head;\\n        ListNode *fast;\\n        \\n        if(slow)\\n            fast=head->next; // \"fast\" can also start from the same node as \"slow\"\\n        else\\n            return false;\\n        \\n        while(slow||fast){  // while traversing if both of them becomes NULL together, no cycle found\\n\\t\\t\\t\\n            if(slow==fast) // then we got the same node again, hence cycle found\\n                return true; // [ CASE 1 ]\\n            \\n            if(slow)\\n                slow=slow->next; // move 1 step at a time\\n            \\n            if(fast){\\n                if(fast->next)\\n                    fast=fast->next->next; // move 2 step at a time\\n                else\\n                    break; // if 2 step jump not possible at any node then break from loop, hence no cycle\\n            }\\n        }\\n        // [ CASE 2 ]\\n        return false; // no cycle found at this point\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047648,
                "title": "cheating-solution-o-1-for-fun",
                "content": "as first constraint says \\nThe number of the nodes in the list is in the range **[0, 10^4]**\\nthen we can loop for 10^4 times:\\n* if we find null then we reached the end of the LinkedList => no cycle \\n* if we couldn\\'t find null => cycle found\\n```\\npublic boolean hasCycle(ListNode head) {\\n        int n = 10_001;\\n        for(int i=0; i<n; i++) {\\n            if(head == null) return false;\\n            head = head.next;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "as first constraint says \\nThe number of the nodes in the list is in the range **[0, 10^4]**\\nthen we can loop for 10^4 times:\\n* if we find null then we reached the end of the LinkedList => no cycle \\n* if we couldn\\'t find null => cycle found\\n```\\npublic boolean hasCycle(ListNode head) {\\n        int n = 10_001;\\n        for(int i=0; i<n; i++) {\\n            if(head == null) return false;\\n            head = head.next;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 239546,
                "title": "c-cheat-solution-make-use-of-consecutive-memory",
                "content": "Just sharing my solution. This is a special case. \\nConsider all the nodes are stored in consecutive memory. Next node of every node is in higher memory address except the tail node.\\nThe next node of the tail node is in lower memory address or NULL. If it is in lower address, cycle exists.\\n   \\n\\tbool hasCycle(ListNode *head) {\\n        ListNode* cur = head;\\n        if(cur==NULL){\\n            return false;\\n        }\\n        while(true){\\n            if(cur->next == NULL){\\n                return false;\\n            }else if(cur->next <= cur){\\n                return true;\\n            }\\n            cur=cur->next;\\n        }\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "Just sharing my solution. This is a special case. \\nConsider all the nodes are stored in consecutive memory. Next node of every node is in higher memory address except the tail node.\\nThe next node of the tail node is in lower memory address or NULL. If it is in lower address, cycle exists.\\n   \\n\\tbool hasCycle(ListNode *head) {\\n        ListNode* cur = head;\\n        if(cur==NULL){\\n            return false;\\n        }\\n        while(true){\\n            if(cur->next == NULL){\\n                return false;\\n            }else if(cur->next <= cur){\\n                return true;\\n            }\\n            cur=cur->next;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1369573,
                "title": "java-clean-solution-using-boundary-condition-beats-100",
                "content": "**In Question it is mentioned that total 10^4 nodes are possible so if there is a possiblity of a circular loop then head will never point towards null so as the count hits 10^4+1 we know that there is no end to this LinkedList so print True.**\\n\\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        int count=0;\\n        while(head!=null){\\n            count++;\\n            head = head.next;\\n            if(count==10001) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nPlease do upvote if you liked!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        int count=0;\\n        while(head!=null){\\n            count++;\\n            head = head.next;\\n            if(count==10001) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148048,
                "title": "please-support-swift-solution",
                "content": "Please support a Swift solution to this problem.\\n\\nHere is a solution using pointers.\\n\\n```\\nclass Solution {\\n    \\n    private func bridge<T : AnyObject>(obj : T) -> UnsafeRawPointer {\\n        return UnsafeRawPointer(Unmanaged.passUnretained(obj).toOpaque())\\n    }\\n    \\n    func hasCycle(_ head: ListNode?) -> Bool {\\n        \\n        var slow: ListNode? = head\\n        var fast: ListNode? = head\\n        while fast?.next != nil && fast != nil {\\n            slow = slow?.next\\n            fast = fast?.next?.next\\n            \\n            if let slow = slow, let fast = fast {\\n                let pslow = bridge(obj: slow)\\n                let pfast = bridge(obj: fast)\\n                if pslow == pfast {\\n                    return true\\n                }\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private func bridge<T : AnyObject>(obj : T) -> UnsafeRawPointer {\\n        return UnsafeRawPointer(Unmanaged.passUnretained(obj).toOpaque())\\n    }\\n    \\n    func hasCycle(_ head: ListNode?) -> Bool {\\n        \\n        var slow: ListNode? = head\\n        var fast: ListNode? = head\\n        while fast?.next != nil && fast != nil {\\n            slow = slow?.next\\n            fast = fast?.next?.next\\n            \\n            if let slow = slow, let fast = fast {\\n                let pslow = bridge(obj: slow)\\n                let pfast = bridge(obj: fast)\\n                if pslow == pfast {\\n                    return true\\n                }\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 117109,
                "title": "c-floyd-cycle-detection-algorithm",
                "content": "Firstly, I would like to thank @StefanPochmann for his solution. He uses a try catch method which would not work in cpp and will cause an infinite loop. \n\nWe will use the same [Tortoise and Hare](http://https://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare) approach where two pointers are mainted.\n1) Slow pointer //Moves only 1 step at a time\n2) Fast Pointer //Moves 2 steps at a time\n\nAs soon as these pointers meet, we are sure that there is a LOOP(return true). The stop condition for our loop  will be that if either of these pointers reach NULL - that means that the linked list has a definite end. Hence, we will break the loop and say that there is NO LOOP(return false).\n\nTo Understand how it works : https://www.youtube.com/watch?v=LUm2ABqAs1w\n\n```\nbool hasCycle(ListNode *head) {\n        ListNode *slow=head,*fast=head;\n        \n        while(slow!=NULL && fast!=NULL && fast->next!=NULL) {\n            \n            slow = slow->next;               //Slow moves by 1 step\n            fast = fast->next->next;        //Fast moves by two steps\n            \n            if(slow==fast) //If they meet then there is a loop\n                return true;\n        }\n        \n        return false; //No loop\n    }\n```\nFollow Up: [Linked List Cyle 2](https://leetcode.com/problems/linked-list-cycle-ii/description/) asks us to find  the point where the cycle is starting. If you have seen the video then you can easily solve it. If not then  check out my solution for that : https://leetcode.com/problems/linked-list-cycle-ii/discuss/117110/C++-Floyd-Cycle-Detection-Algorithm",
                "solutionTags": [],
                "code": "```\nbool hasCycle(ListNode *head) {\n        ListNode *slow=head,*fast=head;\n        \n        while(slow!=NULL && fast!=NULL && fast->next!=NULL) {\n            \n            slow = slow->next;               //Slow moves by 1 step\n            fast = fast->next->next;        //Fast moves by two steps\n            \n            if(slow==fast) //If they meet then there is a loop\n                return true;\n        }\n        \n        return false; //No loop\n    }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44632,
                "title": "my-c-solution",
                "content": "    class Solution {\\n    public:\\n        bool hasCycle(ListNode *head) {\\n            ListNode* slow = head;\\n    \\t\\tListNode* fast = head;\\n    \\t\\twhile (fast && fast->next){\\n    \\t\\t\\tfast = fast->next->next;\\n    \\t\\t\\tslow = slow->next;\\n    \\t\\t\\tif (slow == fast)\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t\\treturn false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool hasCycle(ListNode *head) {\\n            ListNode* slow = head;\\n    \\t\\tListNode* fast = head;\\n    \\t\\twhile (fast && fast->next){\\n    \\t\\t\\tfast = fast->next->next;\\n    \\t\\t\\tslow = slow->next;\\n    \\t\\t\\tif (slow == fast)\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3999268,
                "title": "2-approaches-slow-fast-pointer-set-method-easy-method",
                "content": "**Pls see the code It is well commented you will be easily understand.**\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# 2 Pointer Approach\\n```C++ []\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n\\t\\n\\t\\t// if head is NULL then return false;\\n        if(head == NULL)\\n            return false;\\n        \\n\\t\\t// making two pointers fast and slow and assignning them to head\\n        ListNode *fast = head;\\n        ListNode *slow = head;\\n        \\n\\t\\t// till fast and fast-> next not reaches NULL\\n\\t\\t// we will increment fast by 2 step and slow by 1 step\\n        while(fast != NULL && fast ->next != NULL)\\n        {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            \\n\\t\\t\\t\\n\\t\\t\\t// At the point if fast and slow are at same address\\n\\t\\t\\t// this means linked list has a cycle in it.\\n            if(fast == slow)\\n                return true;\\n        }\\n        \\n\\t\\t// if traversal reaches to NULL this means no cycle.\\n        return false;\\n    }\\n};\\n```\\n```Java []\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        // If head is null, return false\\n        if (head == null) {\\n            return false;\\n        }\\n        \\n        // Initialize two pointers, fast and slow, and assign them to head\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        \\n        // Traverse the list until fast and fast.next reach null\\n        // Increment fast by 2 steps and slow by 1 step\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            \\n            // If fast and slow point to the same node, there is a cycle\\n            if (fast == slow) {\\n                return true;\\n            }\\n        }\\n        \\n        // If traversal reaches null, there is no cycle\\n        return false;\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n    def hasCycle(self, head):\\n        # If head is None, return False\\n        if head is None:\\n            return False\\n        \\n        # Initialize two pointers, fast and slow, and assign them to head\\n        fast = head\\n        slow = head\\n        \\n        # Traverse the list until fast and fast.next reach None\\n        # Increment fast by 2 steps and slow by 1 step\\n        while fast is not None and fast.next is not None:\\n            fast = fast.next.next\\n            slow = slow.next\\n            \\n            # If fast and slow point to the same node, there is a cycle\\n            if fast == slow:\\n                return True\\n        \\n        # If traversal reaches None, there is no cycle\\n        return False\\n\\n```\\n# Code using Set method\\n```C++ []\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        unordered_set<ListNode*> st;\\n        while(head!=NULL){\\n            if(st.find(head)!=st.end()){\\n                return true;\\n            }\\n            st.insert(head);\\n            head=head->next;\\n        }\\n        return false;\\n    }\\n};\\n```\\n```Java []\\nimport java.util.HashSet;\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        HashSet<ListNode> set = new HashSet<>();\\n        while (head != null) {\\n            if (set.contains(head)) {\\n                return true;\\n            }\\n            set.add(head);\\n            head = head.next;\\n        }\\n        return false;\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def hasCycle(self, head):\\n        visited = set()\\n        while head is not None:\\n            if head in visited:\\n                return True\\n            visited.add(head)\\n            head = head.next\\n        return False\\n\\n```\\n![UPVOTE.png](https://assets.leetcode.com/users/images/5e406e5c-239d-483a-9333-b11d4aa6dd3d_1693794772.6311383.png)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n\\t\\n\\t\\t// if head is NULL then return false;\\n        if(head == NULL)\\n            return false;\\n        \\n\\t\\t// making two pointers fast and slow and assignning them to head\\n        ListNode *fast = head;\\n        ListNode *slow = head;\\n        \\n\\t\\t// till fast and fast-> next not reaches NULL\\n\\t\\t// we will increment fast by 2 step and slow by 1 step\\n        while(fast != NULL && fast ->next != NULL)\\n        {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            \\n\\t\\t\\t\\n\\t\\t\\t// At the point if fast and slow are at same address\\n\\t\\t\\t// this means linked list has a cycle in it.\\n            if(fast == slow)\\n                return true;\\n        }\\n        \\n\\t\\t// if traversal reaches to NULL this means no cycle.\\n        return false;\\n    }\\n};\\n```\n```Java []\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        // If head is null, return false\\n        if (head == null) {\\n            return false;\\n        }\\n        \\n        // Initialize two pointers, fast and slow, and assign them to head\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        \\n        // Traverse the list until fast and fast.next reach null\\n        // Increment fast by 2 steps and slow by 1 step\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            \\n            // If fast and slow point to the same node, there is a cycle\\n            if (fast == slow) {\\n                return true;\\n            }\\n        }\\n        \\n        // If traversal reaches null, there is no cycle\\n        return false;\\n    }\\n}\\n\\n```\n```Python3 []\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n    def hasCycle(self, head):\\n        # If head is None, return False\\n        if head is None:\\n            return False\\n        \\n        # Initialize two pointers, fast and slow, and assign them to head\\n        fast = head\\n        slow = head\\n        \\n        # Traverse the list until fast and fast.next reach None\\n        # Increment fast by 2 steps and slow by 1 step\\n        while fast is not None and fast.next is not None:\\n            fast = fast.next.next\\n            slow = slow.next\\n            \\n            # If fast and slow point to the same node, there is a cycle\\n            if fast == slow:\\n                return True\\n        \\n        # If traversal reaches None, there is no cycle\\n        return False\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        unordered_set<ListNode*> st;\\n        while(head!=NULL){\\n            if(st.find(head)!=st.end()){\\n                return true;\\n            }\\n            st.insert(head);\\n            head=head->next;\\n        }\\n        return false;\\n    }\\n};\\n```\n```Java []\\nimport java.util.HashSet;\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        HashSet<ListNode> set = new HashSet<>();\\n        while (head != null) {\\n            if (set.contains(head)) {\\n                return true;\\n            }\\n            set.add(head);\\n            head = head.next;\\n        }\\n        return false;\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def hasCycle(self, head):\\n        visited = set()\\n        while head is not None:\\n            if head in visited:\\n                return True\\n            visited.add(head)\\n            head = head.next\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999041,
                "title": "c-10ms-easy-to-understand-2-pointer",
                "content": "# C++ | 10ms | Easy to Understand | 2 Pointer\\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(head == NULL)\\n            return false;\\n        \\n        ListNode *fast = head;\\n        ListNode *slow = head;\\n    \\n        while(fast != NULL && fast ->next != NULL)\\n        {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            \\n            if(fast == slow)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(head == NULL)\\n            return false;\\n        \\n        ListNode *fast = head;\\n        ListNode *slow = head;\\n    \\n        while(fast != NULL && fast ->next != NULL)\\n        {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            \\n            if(fast == slow)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830758,
                "title": "floyd-s-cycle-detection-algorithm-java-explained-o-n-speed",
                "content": "The Algorithm is used to check if there are any loops in the linked list. It is really simple algorithm in which you take two pointers each pointing to the head node. One is a Fast node which jumps 2 nodes in single loop and the other one is Slow pointer which jumps 1 node at a time. If both of the pointers meet again at a point in the linked list then there is a loop exist and hence return true.\\n\\n***Bonus tip:- If there is no loop in the Linked List then this method can be used to find the middle of the Linked list without knowing the length of the linked list. You just run this same technique until and unless the fast pointer reaches null, and the slow pointer will be pointing to the middle element of the linked list.***\\n\\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null){\\n            return false;\\n        }\\n        \\n        ListNode fast = head;\\n        ListNode slow = head;\\n        boolean t = true;\\n        \\n        do{\\n            if(fast == null || fast.next == null){\\n                t = false;\\n                break;\\n            }\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }while(fast!=slow);\\n        return t;\\n    }\\n}\\n```\\n\\n***Please do upvote if this helped.***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null){\\n            return false;\\n        }\\n        \\n        ListNode fast = head;\\n        ListNode slow = head;\\n        boolean t = true;\\n        \\n        do{\\n            if(fast == null || fast.next == null){\\n                t = false;\\n                break;\\n            }\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }while(fast!=slow);\\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541807,
                "title": "java-easy-solution-hashset-and-two-pointers",
                "content": "### Two pointer approach\\n```java\\npublic boolean hasCycle(ListNode head) {\\n\\tListNode slow = head, fast = head;\\n\\n\\twhile(fast != null && fast.next != null) {\\n\\t\\tfast = fast.next.next;\\n\\t\\tif(slow == fast)\\n\\t\\t\\treturn true;\\n\\t\\tslow = slow.next;\\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n---\\n\\n### HashSet approach\\n```java\\npublic boolean hasCycleBrute(ListNode head) {\\n\\tHashSet<ListNode> set = new HashSet<>();\\n\\n\\tListNode temp = head;\\n\\twhile(temp != null) {\\n\\t\\tif(set.contains(temp)) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tset.add(temp);\\n\\t\\ttemp = temp.next;\\n\\t}\\n\\n\\treturn false;\\n}\\n```\\n\\nIf it helped, do upvote.\\nThanks",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\npublic boolean hasCycle(ListNode head) {\\n\\tListNode slow = head, fast = head;\\n\\n\\twhile(fast != null && fast.next != null) {\\n\\t\\tfast = fast.next.next;\\n\\t\\tif(slow == fast)\\n\\t\\t\\treturn true;\\n\\t\\tslow = slow.next;\\n\\t}\\n\\treturn false;\\n}\\n```\n```java\\npublic boolean hasCycleBrute(ListNode head) {\\n\\tHashSet<ListNode> set = new HashSet<>();\\n\\n\\tListNode temp = head;\\n\\twhile(temp != null) {\\n\\t\\tif(set.contains(temp)) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tset.add(temp);\\n\\t\\ttemp = temp.next;\\n\\t}\\n\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 345472,
                "title": "javascript",
                "content": "```\\n\\n\\nvar hasCycle = function(head) {\\n    \\n    while (head){\\n        if (head.visited) {return true}\\n        head.visited = true\\n        head = head.next\\n    }\\n    \\n    return false \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nvar hasCycle = function(head) {\\n    \\n    while (head){\\n        if (head.visited) {return true}\\n        head.visited = true\\n        head = head.next\\n    }\\n    \\n    return false \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44525,
                "title": "java-o-1-space-solution-with-fast-and-slow-pointer",
                "content": "    public class Solution {\\n        public boolean hasCycle(ListNode head) {\\n            if(head==null || head.next==null) return false;\\n            ListNode fast=head,slow=head;\\n            while(fast!=null&& fast.next!=null){\\n                fast=fast.next.next;\\n                slow=slow.next;\\n                if(fast==slow) return true;\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean hasCycle(ListNode head) {\\n            if(head==null || head.next==null) return false;\\n            ListNode fast=head,slow=head;\\n            while(fast!=null&& fast.next!=null){\\n                fast=fast.next.next;\\n                slow=slow.next;\\n                if(fast==slow) return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1777646,
                "title": "python-simple-o-1-memory-solution",
                "content": "\\n```class Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        count = 0\\n        while head != None and count < 1250:\\n            try:\\n                head = head.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next\\n            except:\\n                return False\\n            count += 1\\n        return count == 1250",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n```class Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        count = 0\\n        while head != None and count < 1250:\\n            try:\\n                head = head.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next\\n            except:\\n                return False\\n            count += 1\\n        return count == 1250",
                "codeTag": "Java"
            },
            {
                "id": 886506,
                "title": "python-intuitive-solution",
                "content": "Runtime: 44 ms, faster than 91.20% of Python3 online submissions for Linked List Cycle.\\nMemory Usage: 16.8 MB, less than 99.00% of Python3 online submissions for Linked List Cycle.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        if head is None:\\n            return False\\n        if head.next is None:\\n            return False\\n        while head.next is not None: \\n            if head.val==None:\\n                return True \\n            head.val=None\\n            head=head.next\\n        return False\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        if head is None:\\n            return False\\n        if head.next is None:\\n            return False\\n        while head.next is not None: \\n            if head.val==None:\\n                return True \\n            head.val=None\\n            head=head.next\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572350,
                "title": "python-simplest-iterative-solution-with-visual-explanation-beg-to-adv-linked-list",
                "content": "***Found helpful, Do upvote !!***\\n\\n**Approach:**\\nFirstly we are taking two pointers, Fast & Slow.\\n\\n**In each iteraton,**\\nFast pointer runs twice as fast than slow pointer, i.e each time, fast go 2 steps.\\nSlow pointer runs once, i.e slow go 1 steps.\\nThis results in when fast arrives at the end, slow will arrive right in the middle.\\n\\nNow, \\n**Condition - 1**, If the fast reaches the end before they meet, that implies linked list doesn\\'t have a cycle\\n**Condition - 2**, If they become equal at some point, that implies linked list has a cycle\\n![image](https://assets.leetcode.com/users/images/bedeb860-f204-451f-a76d-e42856093f56_1663094002.4657688.png)\\nCondition 1 is reaching to the null = Not a cyclic linked list\\nCondition 2 both pointer meet each other with they will = Is a cyclic linked list\\n**\"In the case of cyclic linked list , they will for sure meet at certain point.\"**\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow = fast = head # firstly we are assigning heads to our pointers slow and fast. \\n        while fast and fast.next:# Checking if head exixt or not as fast is head as we assigned earlier and by \"fast.next\" we are checking if we have some other element in the linked list or not. If we wont have then we are returing slow as it contains the head as well.\\n            slow = slow.next # Slow pointer is getting inceremented one by one & we are assiging immediate next value in it.\\n            fast = fast.next.next  # Fast pointer is getting incremented by 2 & we are assiging second next value to it.\\n            if fast == slow: # as described in the approach above.\\n                return True # If both pointer meet, implies there is a cycle.\\n        return False # If both pointer does meet, implies there is no cycle.\\n```\\n***Found helpful, Do upvote !!***\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow = fast = head # firstly we are assigning heads to our pointers slow and fast. \\n        while fast and fast.next:# Checking if head exixt or not as fast is head as we assigned earlier and by \"fast.next\" we are checking if we have some other element in the linked list or not. If we wont have then we are returing slow as it contains the head as well.\\n            slow = slow.next # Slow pointer is getting inceremented one by one & we are assiging immediate next value in it.\\n            fast = fast.next.next  # Fast pointer is getting incremented by 2 & we are assiging second next value to it.\\n            if fast == slow: # as described in the approach above.\\n                return True # If both pointer meet, implies there is a cycle.\\n        return False # If both pointer does meet, implies there is no cycle.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830548,
                "title": "simple-solution",
                "content": "\\n\\n\\n       if(head==NULL)\\n        return false;\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        \\n        if(fast==slow)\\n            return true;\\n        \\n    }\\n    return false;",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "\\n\\n\\n       if(head==NULL)\\n        return false;\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        \\n        if(fast==slow)\\n            return true;\\n        \\n    }\\n    return false;",
                "codeTag": "Unknown"
            },
            {
                "id": 1474599,
                "title": "java-short-100-faster-o-1-space-floyd-s-cycle-detection-algorithm",
                "content": "This is the initial part in Floyd\\'s Cycle Detection Algorithm.\\n\\nWe consider 2 pointers, fast and slow:\\n- slow pointer will move by one node\\n- fast pointer will move by two nodes\\n\\nThink of two cars running in a race track (one fast and second slow). The fast car will get far ahead of slow car at first, but after one/few laps, the fast car will again cross the slow car, as they are running in a circle/loop\\n\\n\\tpublic class Solution {\\n    \\n\\t\\tpublic boolean hasCycle(ListNode head) {\\n\\t\\t\\t\\n\\t\\t\\tListNode slow = head;\\n\\t\\t\\tListNode fast = head;\\n\\t\\t\\t\\n\\t\\t\\t// If fast or slow pointer is null, therefore, linked list has an end\\n\\t\\t\\twhile (fast != null && slow != null) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t// If fast.next is null, then we cannot move fast pointer by 2 nodes, hence end\\n\\t\\t\\t\\t// If we check this in while loop\\'s contition, then runtime error when fast == null\\n\\t\\t\\t\\tif (fast.next == null)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tslow = slow.next;\\n\\t\\t\\t\\tfast = fast.next.next;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// If there is a cycle/loop, eventually slow and fast pointers will collide\\n\\t\\t\\t\\tif (slow == fast)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn false;\\n\\t\\t\\t\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n\\t\\tpublic boolean hasCycle(ListNode head) {\\n\\t\\t\\t\\n\\t\\t\\tListNode slow = head;\\n\\t\\t\\tListNode fast = head;\\n\\t\\t\\t\\n\\t\\t\\t// If fast or slow pointer is null, therefore, linked list has an end\\n\\t\\t\\twhile (fast != null && slow != null) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t// If fast.next is null, then we cannot move fast pointer by 2 nodes, hence end\\n\\t\\t\\t\\t// If we check this in while loop\\'s contition, then runtime error when fast == null\\n\\t\\t\\t\\tif (fast.next == null)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tslow = slow.next;\\n\\t\\t\\t\\tfast = fast.next.next;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// If there is a cycle/loop, eventually slow and fast pointers will collide\\n\\t\\t\\t\\tif (slow == fast)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1450084,
                "title": "python-3-solutions-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Using HashSet**\\n```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        seen = set()\\n        while head != None:\\n            if head in seen: return True\\n            seen.add(head)\\n            head = head.next\\n        return False\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^4` is number of nodes in the Linked List.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Modify Linked List to point to visitedNode**\\n```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        visitedNode = ListNode(0)\\n        \\n        while head != None:\\n            if head.next == visitedNode:\\n                return True\\n            head.next, head = visitedNode, head.next\\n        return False\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^4` is number of nodes in the Linked List.\\n- Space: `O(1)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Floyd\\'s Cycle Finding Algorithm**\\n```python\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow = head\\n        fast = head\\n        while fast != None and fast.next != None:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow == fast: return True\\n        return False\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^4` is number of nodes in the Linked List.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        seen = set()\\n        while head != None:\\n            if head in seen: return True\\n            seen.add(head)\\n            head = head.next\\n        return False\\n```\n```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        visitedNode = ListNode(0)\\n        \\n        while head != None:\\n            if head.next == visitedNode:\\n                return True\\n            head.next, head = visitedNode, head.next\\n        return False\\n```\n```python\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow = head\\n        fast = head\\n        while fast != None and fast.next != None:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow == fast: return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004795,
                "title": "python-o-n-easy-clear-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef hasCycle(self, head: ListNode) -> bool:\\n\\t\\t\\twhile head and head.next:\\n\\t\\t\\t\\tif str(head.val) == \"T\":\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\thead.val = \"T\"\\n\\t\\t\\t\\thead = head.next\\n\\t\\t\\treturn False",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef hasCycle(self, head: ListNode) -> bool:\\n\\t\\t\\twhile head and head.next:\\n\\t\\t\\t\\tif str(head.val) == \"T\":\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\thead.val = \"T\"\\n\\t\\t\\t\\thead = head.next\\n\\t\\t\\treturn False",
                "codeTag": "Java"
            },
            {
                "id": 835202,
                "title": "c-implementation",
                "content": "```\\nbool hasCycle(struct ListNode *head) {\\n    struct ListNode * slow=head,*fast=NULL;\\n    \\n    if(!head || !(head->next))\\n        return false;\\n    \\n    fast=head->next;\\n    \\n    while(slow!=fast)\\n    {\\n        if(fast==NULL)\\n        {\\n            return false;\\n        }\\n        slow=slow->next;\\n        if(fast->next && fast->next->next)\\n            fast=fast->next->next;\\n        else\\n            fast = fast->next;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\nbool hasCycle(struct ListNode *head) {\\n    struct ListNode * slow=head,*fast=NULL;\\n    \\n    if(!head || !(head->next))\\n        return false;\\n    \\n    fast=head->next;\\n    \\n    while(slow!=fast)\\n    {\\n        if(fast==NULL)\\n        {\\n            return false;\\n        }\\n        slow=slow->next;\\n        if(fast->next && fast->next->next)\\n            fast=fast->next->next;\\n        else\\n            fast = fast->next;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 392464,
                "title": "solved-video-editorial-for-linked-list-cycle-leetcode",
                "content": "Hi all,\\n\\nClick on the below link for the solved video editorial for finding the  Linked List Cycle problem.\\nAlso, i will be adding more problems to my collection. Please follow and feedback is always appreciated.\\n\\nLink - [Click Here](https://www.youtube.com/watch?v=0DqxhTiVPGM&feature=youtu.be)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "Hi all,\\n\\nClick on the below link for the solved video editorial for finding the  Linked List Cycle problem.\\nAlso, i will be adding more problems to my collection. Please follow and feedback is always appreciated.\\n\\nLink - [Click Here](https://www.youtube.com/watch?v=0DqxhTiVPGM&feature=youtu.be)",
                "codeTag": "Unknown"
            },
            {
                "id": 44649,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "    /**\\n     * Definition for singly-linked list.\\n     * struct ListNode {\\n     *     int val;\\n     *     ListNode *next;\\n     *     ListNode(int x) : val(x), next(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        bool hasCycle(ListNode *head) {\\n            if (head == NULL || head->next == NULL) return false;\\n            \\n            ListNode *fast = head, *slow = head;\\n            \\n            while (fast != NULL && fast->next != NULL)\\n            {\\n                fast = fast->next->next;\\n                slow = slow->next;\\n                \\n                if (fast == slow)\\n                    return true;\\n            }\\n            \\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool hasCycle(ListNode *head) {\\n            if (head == NULL || head->next == NULL) return false;\\n            \\n            ListNode *fast = head, *slow = head;\\n            \\n            while (fast != NULL && fast->next != NULL)\\n            {\\n                fast = fast->next->next;\\n                slow = slow->next;\\n                \\n                if (fast == slow)\\n                    return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 44733,
                "title": "ac-solution-with-o-1-space-and-o-n-time-in-c",
                "content": "    class Solution {\\n    public:\\n    bool hasCycle(ListNode *head) {\\n        if(!head||!head->next)\\n            return false;\\n        ListNode* i = head; //slower pointer\\n        ListNode* j = i->next; //faster pointer\\n        while(i&&j&&j->next)\\n        {\\n            i = i->next;\\n            j = j->next->next;\\n            if(i==j)\\n                return true;\\n        }\\n        return false;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    bool hasCycle(ListNode *head) {\\n        if(!head||!head->next)\\n            return false;\\n        ListNode* i = head; //slower pointer\\n        ListNode* j = i->next; //faster pointer\\n        while(i&&j&&j->next)\\n        {\\n            i = i->next;\\n            j = j->next->next;\\n            if(i==j)\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3999262,
                "title": "python3-solution",
                "content": "\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self,head:Optional[ListNode])->bool:\\n        slow=head\\n        fast=head\\n        while slow and fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n\\n        return False                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self,head:Optional[ListNode])->bool:\\n        slow=head\\n        fast=head\\n        while slow and fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n\\n        return False                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999151,
                "title": "c-o-n-slow-fast-pointers",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach :**\\n* Slow pointer moves one step at a time and Fast pointer moves two steps at a time.\\n* Taking analogy from 2 people on a race track, if track is circular, they both will certainly meet at a point which is not the starting position as person sprinting fast will cover the lap 1st and eventually cross the slow person again on subsequent laps.\\n\\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n        if(!head) return false;\\n        \\n        ListNode *slow, *fast;\\n        slow = fast = head;\\n        \\n        do{\\n            slow=slow->next;\\n            fast=fast->next;\\n            if(fast) fast=fast->next;\\n        }while(fast!=NULL && fast!=slow);\\n        \\n        return (fast!=NULL && fast == slow);\\n    }\\n};\\n```\\n\\n**Do upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n        if(!head) return false;\\n        \\n        ListNode *slow, *fast;\\n        slow = fast = head;\\n        \\n        do{\\n            slow=slow->next;\\n            fast=fast->next;\\n            if(fast) fast=fast->next;\\n        }while(fast!=NULL && fast!=slow);\\n        \\n        return (fast!=NULL && fast == slow);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276905,
                "title": "python3-easy-detailed-2-methods",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Using two pointer**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- as per floyd\\'s cycle detection algorithen, we keep slow and fast pointers.\\n- increment slow by 1 and fast by 2.\\n- whenever they meet we found cycle in list.\\n- return True.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow = None\\n        fast = head\\n        while fast and fast.next:\\n            if slow == fast and slow:\\n                return slow\\n            slow = slow.next if slow else fast.next\\n            fast = fast.next.next\\n```\\n---\\n# Intuition \\n**Using hashmap**\\n# Approach\\n- keep hashmap of nodes.\\n- if we encounter node that is not in hashmap then add it.\\n- if it\\'s already in map then we found cycle.\\n- return true\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        hashmap = {}\\n        while head:\\n            if head in hashmap.keys():\\n                return head\\n            else:\\n                hashmap[head] = 1\\n            head = head.next\\n```\\n # Please like and comment below :-)",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow = None\\n        fast = head\\n        while fast and fast.next:\\n            if slow == fast and slow:\\n                return slow\\n            slow = slow.next if slow else fast.next\\n            fast = fast.next.next\\n```\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        hashmap = {}\\n        while head:\\n            if head in hashmap.keys():\\n                return head\\n            else:\\n                hashmap[head] = 1\\n            head = head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765240,
                "title": "python-fast",
                "content": "```\\ndef hasCycle(self, head):\\n    try:\\n        slow = head\\n        fast = head.next\\n        while slow is not fast:\\n            slow = slow.next\\n            fast = fast.next.next\\n        return True\\n    except:\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\ndef hasCycle(self, head):\\n    try:\\n        slow = head\\n        fast = head.next\\n        while slow is not fast:\\n            slow = slow.next\\n            fast = fast.next.next\\n        return True\\n    except:\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2048722,
                "title": "javascript-maximum-efficiency-o-n-time-o-1-space",
                "content": "This solution iterates through every node, setting the value within the node to null. Since we know the values are integers by default, if we encounter one of these null values, we know that we have cycled back to a value we have already iterated over.\\n```\\nconst hasCycle = (head) => {\\n  while (head) {\\n    if (!head.val) return true;\\n\\n    head.val = null;\\n    head = head.next;\\n  }\\n\\n  return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst hasCycle = (head) => {\\n  while (head) {\\n    if (!head.val) return true;\\n\\n    head.val = null;\\n    head = head.next;\\n  }\\n\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1830651,
                "title": "python-simple-o-n-with-comments",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        hsh = {} # hsh is not required. thanks for pointing it in comments\\n        \\n        while head:\\n            #empty the value of every node\\n            if head.val:\\n                head.val = None\\n            else:\\n                #if we come across empty node during traversal, it is a cycle\\n                return True\\n            head = head.next\\n        #if we reach the end, we can return False as no cycle formed\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        hsh = {} # hsh is not required. thanks for pointing it in comments\\n        \\n        while head:\\n            #empty the value of every node\\n            if head.val:\\n                head.val = None\\n            else:\\n                #if we come across empty node during traversal, it is a cycle\\n                return True\\n            head = head.next\\n        #if we reach the end, we can return False as no cycle formed\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829692,
                "title": "java-3-approaches",
                "content": "**Using slow and fast pointer**\\nTC - O(N)\\nSC - O(1)\\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null) {\\n            return false;\\n        }\\n        ListNode slow = head, fast = head;\\n        \\n        while (fast.next != null && fast.next.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            \\n            if (fast == slow) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n**Using Java Set.**\\nTC - O(N)\\nSC - O(N)\\n```\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null) {\\n            return false;\\n        }\\n        \\n        Set<ListNode> set = new HashSet<>();\\n        \\n        while (head != null) {\\n            if (set.contains(head)) {\\n                return true;\\n            }\\n            \\n            set.add(head);\\n            head = head.next;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n**Using flagging mechanism**\\nTC - O(N)\\nSC - O(1)\\n\\n-10 ^ 5 <= node.val <=  10^5 \\nWe can use some other value out of this range so we can mark the node as visited. When the node comes with the marked value then we can say there is a cycke.\\n\\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null) {\\n            return false;\\n        }\\n        \\n        while (head != null) {\\n            if (head.val == Integer.MAX_VALUE) { // already visited\\n                return true;\\n            }\\n\\t\\t\\t//flagging the node\\n            head.val = Integer.MAX_VALUE;\\n            head = head.next;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null) {\\n            return false;\\n        }\\n        ListNode slow = head, fast = head;\\n        \\n        while (fast.next != null && fast.next.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            \\n            if (fast == slow) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null) {\\n            return false;\\n        }\\n        \\n        Set<ListNode> set = new HashSet<>();\\n        \\n        while (head != null) {\\n            if (set.contains(head)) {\\n                return true;\\n            }\\n            \\n            set.add(head);\\n            head = head.next;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null) {\\n            return false;\\n        }\\n        \\n        while (head != null) {\\n            if (head.val == Integer.MAX_VALUE) { // already visited\\n                return true;\\n            }\\n\\t\\t\\t//flagging the node\\n            head.val = Integer.MAX_VALUE;\\n            head = head.next;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787725,
                "title": "go-multiple-solutions-clean-code-0ms-100",
                "content": "Hello Gophers!\\n\\n### Solution 1: HashSet (0ms 100%)\\n\\nWe simply iterate over all nodes and record them until:\\n- we are on a node  that we already checked (cycle) **or**\\n- until the current node is nil (not cycle)\\n\\nTime: `O(n)`\\nSpace: `O(n)`\\n\\n```go\\n// Time: O(n)\\n// Space: O(n)\\nfunc hasCycle(head *ListNode) bool {\\n    // Space: O(n)\\n    current, set := head, NewSet()\\n    \\n    // Time: O(n)\\n    for current != nil {\\n        if set.Has(current) {\\n            return true\\n        }\\n        set.Add(current)\\n        current = current.Next\\n    }\\n    return false\\n}\\n\\ntype Set struct {\\n    items map[*ListNode]struct{}\\n}\\n\\nfunc NewSet() *Set{\\n    return &Set{\\n        items: make(map[*ListNode]struct{}),\\n    }\\n}\\n\\nfunc (s *Set) Has(n *ListNode) bool {\\n    _, exists := s.items[n]\\n    return exists\\n}\\n\\nfunc (s *Set) Add(n *ListNode) {\\n    s.items[n] = struct{}{}\\n}\\n```\\n\\n### Solution 2: Fast & Slow Pointers (0ms 100%)\\n\\nThis is called the `Fast & Slow Pointers Algorithm`, the `Hair & Tortoise Algorithm` and the `Floyd\\'s Cycle Finding Algorithm`.  \\nIt\\'s like the `Two Pointers` algorithm, but one of the pointers is going faster than the other one.  \\nIt is useful when dealing with cyclic linked list: the \"fast pointer\" will reach the \"slow pointer\" if there is a cycle!\\n\\nTime: `O(n)`\\nSpace: `O(1)`\\n\\n```go\\n// Time: O(n)\\n// Space: O(1)\\nfunc hasCycle(head *ListNode) bool {\\n    if head == nil {\\n        return false\\n    }\\n\\t\\n\\t// Time: O(n)\\n    for slow, fast := head, head; fast != nil && fast.Next != nil; {\\n        fast, slow = fast.Next.Next, slow.Next\\n        if fast == slow { return true }\\n    }\\n    return false\\n}\\n```\\n\\n### Solution 3: Mixt of solution 1 and 2 (0ms 100%)\\n\\nIf we want to make it faster and we don\\'t care about the `O(1)` space complexity, we can merge both solution, maybe the \"fast pointer\" will cycle on his path before reaching the slow pointer:\\n\\nTime: `O(n)`\\nSpace: `O(n)`\\n\\n```go\\n// Time: O(n)\\n// Space: O(n)\\nfunc hasCycle(head *ListNode) bool {\\n    if head == nil {\\n        return false\\n    }\\n\\t\\n\\t// Space: O(n)\\n    set := NewSet()\\n\\t\\n\\t// Time: O(n)\\n    for slow, fast := head, head; fast != nil && fast.Next != nil; {\\n        if set.Has(fast.Next) || set.Has(fast.Next.Next) {\\n            return true\\n        }\\n        set.Add(fast.Next, fast.Next.Next)\\n    \\n        fast, slow = fast.Next.Next, slow.Next\\n        if fast == slow {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\ntype Set struct {\\n    items map[*ListNode]struct{}\\n}\\n\\nfunc NewSet() *Set{\\n    return &Set{\\n        items: make(map[*ListNode]struct{}),\\n    }\\n}\\n\\nfunc (s *Set) Has(n *ListNode) bool {\\n    _, exists := s.items[n]\\n    return exists\\n}\\n\\nfunc (s *Set) Add(nodes ...*ListNode) {\\n    for _, node := range nodes {\\n        s.items[node] = struct{}{}\\n    }\\n}\\n```\\n\\nHere are my solutions to other problems with this same algorithm pattern (Fast and Slow pointer):\\n\\n- [Happy Number](https://leetcode.com/problems/happy-number/discuss/1790169/go-multiple-solutions-clean-code-0ms-100) \\n- [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/discuss/1787725/go-multiple-solutions-clean-code-0ms-100) (this problem)\\n- [Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/discuss/1790316/go-multiple-solutions-clean-and-commented-code-0ms-100)\\n- [Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/discuss/1801437/go-multiple-solutions-clean-code-with-comments)\\n- [Delete the Middle Node of a Linked List](https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/discuss/1804509/Go-Fast-and-Slow-pointer-Clean-code-(220ms-100))\\n- [Reorder List](https://leetcode.com/problems/reorder-list/discuss/1804821/Go-Clean-and-commented-code-(4ms-100)) \\n\\nI hope it helped! :)",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n// Time: O(n)\\n// Space: O(n)\\nfunc hasCycle(head *ListNode) bool {\\n    // Space: O(n)\\n    current, set := head, NewSet()\\n    \\n    // Time: O(n)\\n    for current != nil {\\n        if set.Has(current) {\\n            return true\\n        }\\n        set.Add(current)\\n        current = current.Next\\n    }\\n    return false\\n}\\n\\ntype Set struct {\\n    items map[*ListNode]struct{}\\n}\\n\\nfunc NewSet() *Set{\\n    return &Set{\\n        items: make(map[*ListNode]struct{}),\\n    }\\n}\\n\\nfunc (s *Set) Has(n *ListNode) bool {\\n    _, exists := s.items[n]\\n    return exists\\n}\\n\\nfunc (s *Set) Add(n *ListNode) {\\n    s.items[n] = struct{}{}\\n}\\n```\n```go\\n// Time: O(n)\\n// Space: O(1)\\nfunc hasCycle(head *ListNode) bool {\\n    if head == nil {\\n        return false\\n    }\\n\\t\\n\\t// Time: O(n)\\n    for slow, fast := head, head; fast != nil && fast.Next != nil; {\\n        fast, slow = fast.Next.Next, slow.Next\\n        if fast == slow { return true }\\n    }\\n    return false\\n}\\n```\n```go\\n// Time: O(n)\\n// Space: O(n)\\nfunc hasCycle(head *ListNode) bool {\\n    if head == nil {\\n        return false\\n    }\\n\\t\\n\\t// Space: O(n)\\n    set := NewSet()\\n\\t\\n\\t// Time: O(n)\\n    for slow, fast := head, head; fast != nil && fast.Next != nil; {\\n        if set.Has(fast.Next) || set.Has(fast.Next.Next) {\\n            return true\\n        }\\n        set.Add(fast.Next, fast.Next.Next)\\n    \\n        fast, slow = fast.Next.Next, slow.Next\\n        if fast == slow {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\ntype Set struct {\\n    items map[*ListNode]struct{}\\n}\\n\\nfunc NewSet() *Set{\\n    return &Set{\\n        items: make(map[*ListNode]struct{}),\\n    }\\n}\\n\\nfunc (s *Set) Has(n *ListNode) bool {\\n    _, exists := s.items[n]\\n    return exists\\n}\\n\\nfunc (s *Set) Add(nodes ...*ListNode) {\\n    for _, node := range nodes {\\n        s.items[node] = struct{}{}\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1601414,
                "title": "simple-python-solution-with-explaination",
                "content": "To check the **presence of cycle in LinkedList**. we can using the **slow and fast pointer approach.**\\n1. We are traversing the whole LinkedList using the slow pointer. which take **1 step** at a time **(slow.next)** and fast poiner which take** 2 steps (fast.next.next)** every time.\\n2. If the slow pointer and fast pointer **collide with each other** then there is presence of cycle in LinkedList. \\n\\n\\n```\\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\\n        \\n        slow = head\\n        fast = head\\n        \\n        while fast!= None and fast.next!= None:\\n            slow = slow.next\\n            fast = fast.next.next \\n            if slow==fast:\\n                return True\\n            \\n        return False\\n```\\n\\nIf you find this post helpful then do **upvote!** It give me motivation to write more.\\nThanks!",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\\n        \\n        slow = head\\n        fast = head\\n        \\n        while fast!= None and fast.next!= None:\\n            slow = slow.next\\n            fast = fast.next.next \\n            if slow==fast:\\n                return True\\n            \\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1597757,
                "title": "o-1-space-solution-easy-to-understand",
                "content": "We know that minimum value that a node value can take is -10^5. \\nSo I looped through all elements and change their values to negative infinity. \\nAnd when the pointer come back to a node that were previously visited then its value will be negative infinity.\\nIf there is no cycle the while loop will end and the program will return false;\\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        \\n        ListNode curr = head;\\n        \\n        while(curr!=null){\\n            if(curr.val==Integer.MIN_VALUE)\\n                return true;\\n            else{\\n                curr.val=Integer.MIN_VALUE;\\n                curr = curr.next;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\nIf you find it Informitive please don\\'t forget to upvote so others can benefit.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        \\n        ListNode curr = head;\\n        \\n        while(curr!=null){\\n            if(curr.val==Integer.MIN_VALUE)\\n                return true;\\n            else{\\n                curr.val=Integer.MIN_VALUE;\\n                curr = curr.next;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047646,
                "title": "c-c-cool-solution",
                "content": "```\\nbool hasCycle(struct ListNode *head) \\n{\\n    if (!head || !head->next)\\n        return false;\\n    \\n    struct ListNode *slow = head->next, *fast = head->next->next;\\n    \\n    while (fast && fast->next)\\n    {\\n        if (slow == fast)\\n            return true;\\n        \\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    \\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool hasCycle(struct ListNode *head) \\n{\\n    if (!head || !head->next)\\n        return false;\\n    \\n    struct ListNode *slow = head->next, *fast = head->next->next;\\n    \\n    while (fast && fast->next)\\n    {\\n        if (slow == fast)\\n            return true;\\n        \\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    \\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 499021,
                "title": "intuitive-javascript-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = function(head) {\\n    const set = new Set();\\n    let node = head;\\n    // return true when node has been visited and saved in the set\\n    while (node !== null) {\\n        if (set.has(node)) {\\n            return true;\\n        }\\n        set.add(node);\\n        node = node.next\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = function(head) {\\n    const set = new Set();\\n    let node = head;\\n    // return true when node has been visited and saved in the set\\n    while (node !== null) {\\n        if (set.has(node)) {\\n            return true;\\n        }\\n        set.add(node);\\n        node = node.next\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 289830,
                "title": "c-slow-fast",
                "content": "```\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        if (head == null) return false;\\n        \\n        var slow = head;\\n        var fast = head.next;\\n\\n        while (slow != fast) {\\n            if (fast == null || fast.next == null) {\\n                return false;\\n            }\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        if (head == null) return false;\\n        \\n        var slow = head;\\n        var fast = head.next;\\n\\n        while (slow != fast) {\\n            if (fast == null || fast.next == null) {\\n                return false;\\n            }\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44725,
                "title": "very-clear-python-solution-where-you-don-t-need-to-worry-about-the-corner-case",
                "content": "    class Solution:\\n        # @param head, a ListNode\\n        # @return a boolean\\n        def hasCycle(self, head):\\n            try:\\n                fast = head.next.next\\n                slow = head.next\\n                \\n                while fast != slow:\\n                    fast = fast.next.next\\n                    slow = slow.next\\n                \\n                return True\\n            except:\\n                return False",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @param head, a ListNode\\n        # @return a boolean\\n        def hasCycle(self, head):\\n            try:\\n                fast = head.next.next\\n                slow = head.next\\n                \\n                while fast != slow:\\n                    fast = fast.next.next\\n                    slow = slow.next\\n                \\n                return True\\n            except:\\n                return False",
                "codeTag": "Java"
            },
            {
                "id": 3403199,
                "title": "python-easy-dictionary",
                "content": "# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        nodes = {}\\n    \\n        while (head):\\n            if head.next not in nodes:\\n                nodes[head.next] = 1\\n            else:\\n                return True\\n            head = head.next\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        nodes = {}\\n    \\n        while (head):\\n            if head.next not in nodes:\\n                nodes[head.next] = 1\\n            else:\\n                return True\\n            head = head.next\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276274,
                "title": "slow-fast-pointer-logic-python3",
                "content": "\\n# 1. Slow and Fast Concept at same node\\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\n#   please upvote me it would encourage me alot\\n\\n```\\n# 2. Slow and fast at different Node\\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        if not head:\\n            return False\\n        slow,fast=head,head.next\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\n#   please upvote me it would encourage me alot\\n\\n```\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        if not head:\\n            return False\\n        slow,fast=head,head.next\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181800,
                "title": "tc-o-n-sc-o-1-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n    \\n    if(head==NULL || head->next==NULL)\\n    return false;\\n\\n    ListNode* slow=head;\\n    ListNode* fast=head;\\n\\n    while(slow!=NULL && fast!=NULL){\\n        fast=fast->next;\\n        if(fast!=NULL){\\n            fast=fast->next;\\n        }\\n        slow=slow->next;\\n\\n        if(slow==fast){\\n            // cout<<\"cycle present on element \"<<slow->data<<endl;\\n            return true; \\n        }\\n    }\\n    return false; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n    \\n    if(head==NULL || head->next==NULL)\\n    return false;\\n\\n    ListNode* slow=head;\\n    ListNode* fast=head;\\n\\n    while(slow!=NULL && fast!=NULL){\\n        fast=fast->next;\\n        if(fast!=NULL){\\n            fast=fast->next;\\n        }\\n        slow=slow->next;\\n\\n        if(slow==fast){\\n            // cout<<\"cycle present on element \"<<slow->data<<endl;\\n            return true; \\n        }\\n    }\\n    return false; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2791622,
                "title": "java-fast-slow-pointer-method",
                "content": "# Intuition\\nThumb-Rule: If need to detect a cycle anywhere first use Fast-Slow Pointer method.\\n\\n# Approach\\nUse the Two pointer Approach. Fast pointer will move ahead by two nodes and slow pointer willl move one node. If they meet at certain point, then it confirms the availability of the cycle.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null){\\n            fast = fast.next.next;\\n            slow = slow.next;\\n\\n            if(fast == slow){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null){\\n            fast = fast.next.next;\\n            slow = slow.next;\\n\\n            if(fast == slow){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501273,
                "title": "java-solution-using-hashset-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/65d7f87d-21a6-4666-93e6-6814ffec3b24_1661795327.8672297.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/65d7f87d-21a6-4666-93e6-6814ffec3b24_1661795327.8672297.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1857668,
                "title": "2-python-solutions",
                "content": "-----------------\\n### ***Two pointers Solution***\\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow=fast=head\\n        while fast and fast.next:\\n            fast=fast.next.next\\n            slow=slow.next\\n            if slow==fast: return True\\n        return False\\n```\\n-----------------\\n### ***Dictionary Solution***\\n-------------------\\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        D={}\\n        while head:\\n            if head in D: return True\\n            D[head]=True\\n            head=head.next\\n        return False\\n```\\n-----------------\\n### ***Set Solution***\\n-------------------\\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        S=set()\\n        while head:\\n            if head in S: return True\\n            S.add(head)\\n            head=head.next\\n        return False\\n```\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow=fast=head\\n        while fast and fast.next:\\n            fast=fast.next.next\\n            slow=slow.next\\n            if slow==fast: return True\\n        return False\\n```\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        D={}\\n        while head:\\n            if head in D: return True\\n            D[head]=True\\n            head=head.next\\n        return False\\n```\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        S=set()\\n        while head:\\n            if head in S: return True\\n            S.add(head)\\n            head=head.next\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531932,
                "title": "c-solution-o-1-auxiliary-space-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(head == NULL){\\n            return NULL;\\n        }\\n        \\n        ListNode *slow = head;\\n        ListNode *fast = head->next;\\n        \\n        while(fast!=NULL && fast->next!=NULL){\\n            if(slow == fast)\\n                return true;\\n            \\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n**Consider UPVOTING this content if you find it useful.**\\n\\nThank you.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(head == NULL){\\n            return NULL;\\n        }\\n        \\n        ListNode *slow = head;\\n        ListNode *fast = head->next;\\n        \\n        while(fast!=NULL && fast->next!=NULL){\\n            if(slow == fast)\\n                return true;\\n            \\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526451,
                "title": "go",
                "content": "two pointers\\n```\\nfunc hasCycle(head *ListNode) bool {\\n    if head == nil || head.Next == nil {\\n        return false\\n    }\\n    p1, p2 := head, head.Next\\n    for p1 != p2 {\\n        if p2 == nil || p2.Next == nil {\\n            return false\\n        }\\n        p1 = p1.Next\\n        p2 = p2.Next.Next\\n    }\\n    return true\\n}\\n```\\nhash\\n```\\nfunc hasCycle(head *ListNode) bool {\\n    dict := make(map[*ListNode]struct{})\\n    for head != nil {\\n        if _, ok := dict[head]; ok {\\n            return true\\n        } \\n        dict[head] = struct{}{}\\n        head = head.Next\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc hasCycle(head *ListNode) bool {\\n    if head == nil || head.Next == nil {\\n        return false\\n    }\\n    p1, p2 := head, head.Next\\n    for p1 != p2 {\\n        if p2 == nil || p2.Next == nil {\\n            return false\\n        }\\n        p1 = p1.Next\\n        p2 = p2.Next.Next\\n    }\\n    return true\\n}\\n```\n```\\nfunc hasCycle(head *ListNode) bool {\\n    dict := make(map[*ListNode]struct{})\\n    for head != nil {\\n        if _, ok := dict[head]; ok {\\n            return true\\n        } \\n        dict[head] = struct{}{}\\n        head = head.Next\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44535,
                "title": "python-solution",
                "content": "Python O(n) Solution\\n```Python\\nclass Solution(object):\\n    def hasCycle(self, head):\\n        fast = slow = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution(object):\\n    def hasCycle(self, head):\\n        fast = slow = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44664,
                "title": "c-solutions-set-and-two-pointer",
                "content": "    // O(n) space\\n    bool hasCycle1(ListNode *head) {\\n        unordered_set<ListNode *> mySet;\\n        while (head) {\\n            if (mySet.find(head) != mySet.end())\\n                return true;\\n            mySet.insert(head);\\n            head = head->next;\\n        }\\n        return false;\\n    }\\n    \\n    // O(1) space\\n    bool hasCycle(ListNode *head) {\\n        ListNode *fast, *slow;\\n        fast = slow = head;\\n        while (fast && fast->next) {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            if (slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Ordered Set"
                ],
                "code": "    // O(n) space\\n    bool hasCycle1(ListNode *head) {\\n        unordered_set<ListNode *> mySet;\\n        while (head) {\\n            if (mySet.find(head) != mySet.end())\\n                return true;\\n            mySet.insert(head);\\n            head = head->next;\\n        }\\n        return false;\\n    }\\n    \\n    // O(1) space\\n    bool hasCycle(ListNode *head) {\\n        ListNode *fast, *slow;\\n        fast = slow = head;\\n        while (fast && fast->next) {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            if (slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3999313,
                "title": "simple-c-single-pointer-no-hash-map-o-n-space-o-1",
                "content": "# Intuition\\nThe constraints for node->val are from -10^5 to 10^5. Simply change the value out of this range so that we will know if we visited that node or not.\\n\\n# Approach\\nFirst we iterate the list untill we get null. First we check if `val == -100001`. `-100001` (say `bignum`) is just a number outside the constraints bounds. If the node val is equal to bignum then that means the node is already visites so we `return true` because cycle is there. \\nElse we change the value to bignum and go to the next node. After few iteration if any node val == bignum that means we already visited that node so cycle is present. \\nIf we get out of that loop that means we didnot visit the same node twice, so no cycle is present so we `return false`. \\n\\n`bignum` can be any number outside the range `-10^5 to 10^5`\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {     \\n        while(head)\\n        {\\n            if(head->val == -100001) return true;\\n            head->val = -100001;\\n            head = head->next;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {     \\n        while(head)\\n        {\\n            if(head->val == -100001) return true;\\n            head->val = -100001;\\n            head = head->next;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443184,
                "title": "c-easy-solution-3-approaches",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        \\n        //-------------------Approach 1(HASHSET)-------------------\\n\\n        HashSet<ListNode> visited = new HashSet<ListNode>();\\n\\n        while(head != null){\\n            if(visited.Contains(head))  return true;\\n                \\n             visited.Add(head);\\n             head = head.next;\\n        }\\n        return false;\\n\\n\\n\\n        //-------------------Approach 2(TWO POINTER)---------------------\\n\\n        if(head == null) return false;\\n            \\n\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast != null && fast.next != null){\\n\\n            slow = slow.next;\\n            fast = fast.next.next;\\n\\n            if(slow == fast)  return true;    \\n                  \\n        }\\n        return false;\\n\\n\\n\\n        //-----------Approach 3-------------------\\n\\n        if(head == null) return false;\\n\\n        while(head != null){\\n            if(head.val == Int32.MaxValue) return true;\\n                \\n            head.val = Int32.MaxValue;\\n            head = head.next;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        \\n        //-------------------Approach 1(HASHSET)-------------------\\n\\n        HashSet<ListNode> visited = new HashSet<ListNode>();\\n\\n        while(head != null){\\n            if(visited.Contains(head))  return true;\\n                \\n             visited.Add(head);\\n             head = head.next;\\n        }\\n        return false;\\n\\n\\n\\n        //-------------------Approach 2(TWO POINTER)---------------------\\n\\n        if(head == null) return false;\\n            \\n\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast != null && fast.next != null){\\n\\n            slow = slow.next;\\n            fast = fast.next.next;\\n\\n            if(slow == fast)  return true;    \\n                  \\n        }\\n        return false;\\n\\n\\n\\n        //-----------Approach 3-------------------\\n\\n        if(head == null) return false;\\n\\n        while(head != null){\\n            if(head.val == Int32.MaxValue) return true;\\n                \\n            head.val = Int32.MaxValue;\\n            head = head.next;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205798,
                "title": "141-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the linked list.\\n\\n- Space complexity:\\nSpace complexity is O(1), since we only need two pointers to traverse the linked list.\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n  def hasCycle(self, head: ListNode) -> bool:\\n    # Initialize two pointers to point to the head of the linked list\\n    slow = fast = head\\n    \\n    # Loop through the linked list\\n    while fast and fast.next:\\n        # Move the slow pointer one node at a time\\n        slow = slow.next\\n        \\n        # Move the fast pointer two nodes at a time\\n        fast = fast.next.next\\n        \\n        # If the slow and fast pointers ever point to the same node, then there is a cycle in the linked list\\n        if slow == fast:\\n            return True\\n    \\n    # If the fast pointer encounters a null value, then there is no cycle in the linked list\\n    return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n  def hasCycle(self, head: ListNode) -> bool:\\n    # Initialize two pointers to point to the head of the linked list\\n    slow = fast = head\\n    \\n    # Loop through the linked list\\n    while fast and fast.next:\\n        # Move the slow pointer one node at a time\\n        slow = slow.next\\n        \\n        # Move the fast pointer two nodes at a time\\n        fast = fast.next.next\\n        \\n        # If the slow and fast pointers ever point to the same node, then there is a cycle in the linked list\\n        if slow == fast:\\n            return True\\n    \\n    # If the fast pointer encounters a null value, then there is no cycle in the linked list\\n    return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198356,
                "title": "python-clean-simple-floyd-s-cycle-detaction-using-2-pointer-slow-fast",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow = fast = head\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow == fast:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow = fast = head\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow == fast:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135556,
                "title": "python-simple-and-clean-beats-92-69",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thought in solving this problem is to find a way to detect if a linked list has a cycle. To accomplish this, we can use two pointers, a slow pointer, and a fast pointer. The slow pointer moves one step at a time while the fast pointer moves two steps at a time. If the linked list has a cycle, the fast pointer will eventually catch up with the slow pointer, and they will both point to the same node.\\n# Approach\\nThe approach to solving this problem is to use the two pointers, slow and fast, to traverse the linked list. The slow pointer moves one step at a time, and the fast pointer moves two steps at a time. If the linked list has a cycle, the fast pointer will eventually catch up with the slow pointer, and they will both point to the same node.\\n\\nTo check if the linked list has a cycle, we first check if the head of the linked list is None or if the next node is None. If either of these conditions is True, then the linked list has no cycle, and we return False.\\n\\nNext, we initialize the slow pointer to the head of the linked list, and the fast pointer to the next node. We then enter a while loop that continues as long as the fast pointer is not None and the next node of the fast pointer is not None.\\n\\nIn the while loop, we check if the slow pointer is equal to the fast pointer. If this is True, then we have found a cycle in the linked list, and we return True.\\n\\nIf the slow pointer is not equal to the fast pointer, we move the slow pointer one step at a time and the fast pointer two steps at a time. We repeat this process until either the fast pointer is None or the next node of the fast pointer is None.\\n\\nIf the while loop terminates, then the linked list has no cycle, and we return False.\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        if not head or not head.next:\\n            return False\\n        slow=head\\n        fast=head.next\\n        while(fast and fast.next):\\n            if slow==fast:\\n                return True\\n            slow=slow.next\\n            fast=fast.next.next\\n        return False\\n```\\n### Please upvote!",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        if not head or not head.next:\\n            return False\\n        slow=head\\n        fast=head.next\\n        while(fast and fast.next):\\n            if slow==fast:\\n                return True\\n            slow=slow.next\\n            fast=fast.next.next\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054968,
                "title": "c-2-easy-approaches-slow-fast-pointer-set",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Slow & Fast Pointer Approach\\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n\\n        while(fast != NULL && fast -> next != NULL){\\n            fast = fast -> next ->next;\\n            slow = slow -> next;\\n            if(slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n# Set Approach\\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        set<ListNode*> st;\\n        while(!st.count(head) && head != NULL){\\n            st.insert(head);\\n            head = head->next;\\n        }\\n        if(head == NULL)\\n            return false;\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n# Please Upvote \\uD83D\\uDE4F, if you find this helpful\\n#### Thank you in advance :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n\\n        while(fast != NULL && fast -> next != NULL){\\n            fast = fast -> next ->next;\\n            slow = slow -> next;\\n            if(slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        set<ListNode*> st;\\n        while(!st.count(head) && head != NULL){\\n            st.insert(head);\\n            head = head->next;\\n        }\\n        if(head == NULL)\\n            return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011940,
                "title": "two-pointers-c",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (!head) \\n            return false;\\n        \\n        ListNode *slow = head, *fast = head;\\n        \\n        while (fast->next && fast->next->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast) \\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (!head) \\n            return false;\\n        \\n        ListNode *slow = head, *fast = head;\\n        \\n        while (fast->next && fast->next->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast) \\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671994,
                "title": "easy-slow-and-fast-pointer-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(!head) return false;\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(!head) return false;\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563252,
                "title": "java-2-pointer-approach-easy-understandable-code",
                "content": "**Please upvote if it helps you. I\\'ll keep updating with quality code.**\\n*if any query, pls comment. I\\'ll respond as quickly as possible.*\\n# Two-Pointer Approach\\nImagine there are two runners with different speed. If they are running on a straight path, the fast runner will first arrive at the destination. However, if they are running on a circular track, the fast runner will catch up with the slow runner if they keep running.\\n\\nThat\\'s exactly what we will come across using two pointers with different speed in a linked list:\\n\\n* **If there is no cycle, the fast pointer will stop at the end of the linked list.**\\n* **If there is a cycle, the fast pointer will eventually meet with the slow pointer.**\\n\\n***In this solution, Slow runner is moving 1 step while Fast runner is moving 2 step forward.***\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    \\n    //  Time Complexity = O(N)\\n    //  Space Complexity = O(1)\\n    \\n    public boolean hasCycle(ListNode head) {\\n        //   Edge Case\\n        if(head == null )\\n            return false;\\n        \\n        //  2 Pointers slow and fast\\n        ListNode slow = head, fast = head;\\n        \\n        while(fast != null && fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next.next;      //  2 times of slow pointer\\n            \\n            //  if slow pointer met the same value as of fast pointer then it means linked list contains cycle inside it\\n            if(slow == fast)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    \\n    //  Time Complexity = O(N)\\n    //  Space Complexity = O(1)\\n    \\n    public boolean hasCycle(ListNode head) {\\n        //   Edge Case\\n        if(head == null )\\n            return false;\\n        \\n        //  2 Pointers slow and fast\\n        ListNode slow = head, fast = head;\\n        \\n        while(fast != null && fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next.next;      //  2 times of slow pointer\\n            \\n            //  if slow pointer met the same value as of fast pointer then it means linked list contains cycle inside it\\n            if(slow == fast)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092812,
                "title": "easy-destructive-solution-c",
                "content": "Since we know that -10^5 <= Node.val <= 10^5, an easy way to mark a node as visited is to set its value to something beyond the range of valid values. Note: this will destroy the list unlike some other solutions.\\n\\n```\\npublic class Solution\\n{\\n    public bool HasCycle(ListNode head)\\n    {\\n        if (head == null) return false;\\n        \\n        while (head.next != null)\\n        {\\n            if (head.val == Int32.MaxValue) return true;\\n\\t\\t\\t\\n            head.val = Int32.MaxValue;\\n            head = head.next;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool HasCycle(ListNode head)\\n    {\\n        if (head == null) return false;\\n        \\n        while (head.next != null)\\n        {\\n            if (head.val == Int32.MaxValue) return true;\\n\\t\\t\\t\\n            head.val = Int32.MaxValue;\\n            head = head.next;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830141,
                "title": "typescript-easy",
                "content": "1. In a list with a cycle, the nodes will be `Error! Cycle in List Found`.\\n2. Add each node to a set `check` as you iterate through a `while` loop.\\n\\n\\n```\\nfunction hasCycle(head: ListNode | null): boolean {\\n    const check = new Set<ListNode | null>()\\n    let res: boolean = false\\n    \\n    while (head && !res){\\n        {check.has(head)\\n            ?\\n            res = true\\n            :\\n            check.add(head)\\n            head = head.next\\n        }\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Ordered Set"
                ],
                "code": "```\\nfunction hasCycle(head: ListNode | null): boolean {\\n    const check = new Set<ListNode | null>()\\n    let res: boolean = false\\n    \\n    while (head && !res){\\n        {check.has(head)\\n            ?\\n            res = true\\n            :\\n            check.add(head)\\n            head = head.next\\n        }\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1797732,
                "title": "java-clean-solution-beats-100",
                "content": "This problem uses famous Tortoise-Haire Algorithm.\\nHere slowPointer is Tortoise and FastPointer is Haire.\\nWhile Tortoise moves one step at a time, Haire moves 2 steps at a time, so it should reach end earlier than tortoise.\\nBut in any case, they both meet, that means there is a cycle present.\\n**O(N) Time, O(1) Space**\\n```\\npublic boolean hasCycle(ListNode head) {\\n        ListNode slowPointer = head;\\n        ListNode fastPointer = head;\\n        \\n        do {\\n            if (slowPointer == null || fastPointer == null || fastPointer.next == null) {\\n                return false;\\n            } \\n            slowPointer = slowPointer.next;\\n            fastPointer = fastPointer.next.next;\\n        } while (slowPointer != fastPointer);\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\npublic boolean hasCycle(ListNode head) {\\n        ListNode slowPointer = head;\\n        ListNode fastPointer = head;\\n        \\n        do {\\n            if (slowPointer == null || fastPointer == null || fastPointer.next == null) {\\n                return false;\\n            } \\n            slowPointer = slowPointer.next;\\n            fastPointer = fastPointer.next.next;\\n        } while (slowPointer != fastPointer);\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1766179,
                "title": "abuse-the-constraints-single-pointer-solution",
                "content": "A very notable constraint in the problem definition: \\n> The number of the nodes in the list is in the range [0, 10^4].\\n\\nYou don\\'t need two pointers when you know exactly how long the list can be!\\n\\n```\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        ushort count = 0;\\n        while (count++ < 10001) {\\n            if (head == null) return false;\\n            head = head.next;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        ushort count = 0;\\n        while (count++ < 10001) {\\n            if (head == null) return false;\\n            head = head.next;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701581,
                "title": "o-1-space-using-floyd-cycle-algo-easy",
                "content": "In floyd Cycle detection algo\\nwe use 2 ptr slow and fast and by moving them forward in such way\\n**slow = slow->next\\nfast = fast->next->next**\\nwhenever they meet that means there is cycle present in our Linked List if not that means Linked List is linear. :)\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    // by floyd cycle method\\n    bool hasCycle(ListNode *head) {\\n        if(head == NULL || head->next == NULL){\\n            return false;\\n        }\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        while(fast != NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            \\n            if(slow == fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nPlease Upvote if you like the sloution :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // by floyd cycle method\\n    bool hasCycle(ListNode *head) {\\n        if(head == NULL || head->next == NULL){\\n            return false;\\n        }\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        while(fast != NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            \\n            if(slow == fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674356,
                "title": "two-pointer-approach-easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* fast = head , *slow = head;\\n        while(fast && fast->next){\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            if(fast == slow) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* fast = head , *slow = head;\\n        while(fast && fast->next){\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            if(fast == slow) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639985,
                "title": "o-1-space-10-liner-with-easy-explanation",
                "content": "Time Complexity: **O(N)**\\nSpace Complexity: **O(1)**\\n\\n### Algorithm\\n- Use 2 pointer. And looping the given linked list.\\n- The pointer `double` is faster one which passes though double nodes per step.\\n- Another pointer `single` is slower one which passes though single node per step.\\n- the pointer `double` and `single` gonna meets, if there are **cycle**. We gonna stop the looping and return `true`.\\n- Eventually pointer meets end of the node, if there are **no cycle**. We gonna stop the looping and return `false`.\\n\\n### Example\\n![image](https://assets.leetcode.com/users/images/d500c239-5f75-4358-9b7b-559e01305f88_1640107593.2537055.png)\\n- step 1\\n  - `double` -> 0 \\n  - `single` -> 2\\n- step 2\\n  - `double` -> 2\\n  - `single` -> 0\\n- step 3\\n  - `double` -> -4\\n  - `single` -> -4\\n  - `double` and `single` meet! return `true`\\n\\n\\n![image](https://assets.leetcode.com/users/images/f54417e1-4999-44f3-a516-e2f88d368d57_1640107614.5570474.png)\\n- step 1\\n  - `double` -> 1\\n  - `single` -> 2\\n- step 2\\n  - `double` -> 1\\n  - `single` -> 1\\n  - `double` and `single` meet! return `true`\\n\\n![image](https://assets.leetcode.com/users/images/2c5688f6-9297-41d2-8eaf-ac03f1587b51_1640107623.5081694.png)\\n- step 1\\n  - `double` -> null\\n  - `single` -> null\\n- step 2\\n  - `double` is null! Stop looping and return `false`\\n\\n\\n### Code\\n```JavaScript\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = head => {\\n    let double = head\\n    let single = head;\\n    while (double) {\\n        double = double.next?.next;\\n        single = single.next;\\n        if (double && double == single) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```\\n`?.` is optional chaining, which only working when object is not nullable.\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = head => {\\n    let double = head\\n    let single = head;\\n    while (double) {\\n        double = double.next?.next;\\n        single = single.next;\\n        if (double && double == single) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1422031,
                "title": "python-single-pass-o-n-98-time-o-1-80-space-commented-and-explained",
                "content": "# 141. Linked List Cycle\\nI originally approached this problem simply seeking a solution. After getting a solution I read the little follow up at the bottom (can you do it in O(1) space) and it immediately clicked for me. This post will still go through the same logic and thought process. We will just take the extra step to get to the optimized solution.\\n\\n## Initial Thoughts\\n* If we travel through the linked list and encounter a value twice there is a cycle\\n* If we store all of the nodes in an array of seen nodes we increase both runtime and space complexity\\n* Instead of storing values we can use flag values to denote encountered nodes (note on this below)\\n* An apporpriate flag value would be 10<sup>6</sup> since it is out of the defined Node.val bounds (-10<sup>5</sup> < Node.val < 10<sup>5</sup>)\\n\\n## Approach\\n\\nThis problem breaks down on the smallest level to a decision structure. Has the current node been seen or not? If it has been seen then we have a cycle and return True. Otherwise, flag the node and move on.\\nThat is the hard part really. As long as our current node has a value we execute this decision structure and move on. Rinse, lather, repeat.\\n\\nWe start with while head != None. This does a few things for us.\\n\\n1. If we reach a node that has a value of None, the previous node was the last node. This means we traversed a linear (non-cyclic) linked list. Success!\\n2. Handles the edge case of null input\\n\\nOnce we have our loop set each time we havent seen a node we flag it and move on. If we encounter a flagged node the stop everything and return True. Successfully traversing the liked list and reaching the end guarantees that our input had no cycle.\\n\\n#### Note on bullet point 3\\nIf you thought about the fact that the data is being altered, I did too. What if we need this data to use somewhere else? The way I figured this could be done is assume the data value constraints and choose a addition/subtraction factor. In this case if we encounter a positive value add 10<sup>6</sup> and if it is negative subtract 10<sup>6</sup>. Then the flags are now ranges of numbers. For example: `if num in range(-10e5, 10e5 + 1)` could replace `if head.val == 10e6`. Then at the end we could call a \"fix\" function that would go through an fix all the flags.\\n\\n```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        \\n        # We want to visit each node and mark it as visited\\n        # We can use a simple boolean value or a value outside of our Node.val range \\n        # (ex. -10e6 or 10e6 would be fine)\\n        while head != None:\\n            \\n            # We will use the flag value of 10e6. If Node.val == 10e6 we\\'ve encountered a cycle\\n            # else change the node\\'s value to 10e6 and move to the next node\\n            if head.val == 10e6:\\n                return True\\n            else:\\n                head.val = 10e6\\n                head = head.next\\n                \\n        # Breaking out of the while loop indicates we have no cycles\\n        # This would mean we encountered a node with Node.next = None\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        \\n        # We want to visit each node and mark it as visited\\n        # We can use a simple boolean value or a value outside of our Node.val range \\n        # (ex. -10e6 or 10e6 would be fine)\\n        while head != None:\\n            \\n            # We will use the flag value of 10e6. If Node.val == 10e6 we\\'ve encountered a cycle\\n            # else change the node\\'s value to 10e6 and move to the next node\\n            if head.val == 10e6:\\n                return True\\n            else:\\n                head.val = 10e6\\n                head = head.next\\n                \\n        # Breaking out of the while loop indicates we have no cycles\\n        # This would mean we encountered a node with Node.next = None\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355291,
                "title": "golang-slow-and-fast-pointer-method-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc hasCycle(head *ListNode) bool {\\n    //slow and fast pointer\\n    slow := head\\n    fast := head\\n    for fast != nil && fast.Next != nil {\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n        if slow == fast {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc hasCycle(head *ListNode) bool {\\n    //slow and fast pointer\\n    slow := head\\n    fast := head\\n    for fast != nil && fast.Next != nil {\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n        if slow == fast {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1145123,
                "title": "faster-than-99-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head){\\n        ListNode* slow=head, *fast=head;\\n        while (slow && fast && fast->next){\\n        slow= slow->next; fast= fast->next->next;\\n        if(slow==fast) return 1;\\n    }\\n    return 0;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head){\\n        ListNode* slow=head, *fast=head;\\n        while (slow && fast && fast->next){\\n        slow= slow->next; fast= fast->next->next;\\n        if(slow==fast) return 1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1048356,
                "title": "linked-list-cycle-floyd-s-algorithm-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nOne brute force solution here would be to map every single pointer in the list until we either reach the end of the list or find a duplicate, but that would use **O(n) space**.\\n\\nThe other brute force solution would involve counting nodes until we reached the designated constraint (**10e4**). If we pass that amount before reaching the end of the linked list, it must be a cycle. This solution is **O(1) space**, but much slower than an optimal solution.\\n\\nBut this problem is also an entry into the common question of **cycle detection**. One of the easiest methods of cycle detection is **Floyd\\'s Tortoise and the Hare algorithm**, which states that if you define two branches (**slow** and **fast**), and have the slow branch perform a given function once per iteration and the fast branch perform the same function twice per iteration, that they will eventually meet at the same point if the function is cyclical.\\n\\nIn essence, we start the hare just ahead of the tortoise, let them go, and see if the hare cycles back around to catch up with the tortoise again.\\n\\nOtherwise, if we ever reach the end of the linked list, we know that there can be no cycle.\\n\\n---\\n\\n***Implementation:***\\n\\nFor the javascript solution, we can also use **optional chaining** to good effect here to make the code slightly more readable.\\n\\n---\\n\\n**Javascript Code:**\\n\\nThe best result for the code below is **80ms / 41.1MB** (beats 96%).\\n```javascript\\nvar hasCycle = function(head) {\\n    let slow = head, fast = head?.next\\n    while (slow && fast)\\n        if (slow === fast) return true\\n        else slow = slow.next, fast = fast.next?.next\\n    return false\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar hasCycle = function(head) {\\n    let slow = head, fast = head?.next\\n    while (slow && fast)\\n        if (slow === fast) return true\\n        else slow = slow.next, fast = fast.next?.next\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1047666,
                "title": "java-solution-100-faster-0ms",
                "content": "```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) \\n    {\\n        if (head == null || head.next == null) \\n    \\t\\treturn false; \\n  \\n        ListNode slow = head, fast = head; \\n  \\n        slow = slow.next; \\n        fast = fast.next.next; \\n\\n        while (fast != null && fast.next != null)\\n        { \\n            if (slow == fast) \\n                return true; \\n\\n            slow = slow.next; \\n            fast = fast.next.next; \\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) \\n    {\\n        if (head == null || head.next == null) \\n    \\t\\treturn false; \\n  \\n        ListNode slow = head, fast = head; \\n  \\n        slow = slow.next; \\n        fast = fast.next.next; \\n\\n        while (fast != null && fast.next != null)\\n        { \\n            if (slow == fast) \\n                return true; \\n\\n            slow = slow.next; \\n            fast = fast.next.next; \\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004321,
                "title": "simple-approach-with-hashmap-88-faster",
                "content": "\\n```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        dix = {} # to store the addresses of the nodes \\n        while head:\\n            if id(head) in dix:\\n                return True # if an address is already pointed by another node i.e. there is cycle\\n            else:\\n                dix[id(head)] =  1\\n                head = head.next\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        dix = {} # to store the addresses of the nodes \\n        while head:\\n            if id(head) in dix:\\n                return True # if an address is already pointed by another node i.e. there is cycle\\n            else:\\n                dix[id(head)] =  1\\n                head = head.next\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802137,
                "title": "javascript-solution-141",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = function(head) {\\n    let r1 = head, r2 = head;\\n    while (r1 && r1.next) {\\n        r1 = r1.next.next;\\n        r2 = r2.next;\\n        if (r1 == r2) {\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n**Runtime: 76 ms, faster than 90.45% of JavaScript online submissions for Linked List Cycle.**\\n\\n**Memory Usage: 39.6 MB, less than 15.59% of JavaScript online submissions for Linked List Cycle.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = function(head) {\\n    let r1 = head, r2 = head;\\n    while (r1 && r1.next) {\\n        r1 = r1.next.next;\\n        r2 = r2.next;\\n        if (r1 == r2) {\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 712820,
                "title": "c-easy-to-understand-solution-94-59",
                "content": "***Runtime: 8 ms, faster than 94.59% of C++ online submissions for Linked List Cycle.\\nMemory Usage: 7.6 MB, less than 86.65% of C++ online submissions for Linked List Cycle.***\\n\\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(!head)   return false;\\n        ListNode *slowptr = head;\\n        ListNode *fastptr = head;\\n        do{\\n            slowptr = slowptr->next;\\n            fastptr = fastptr->next;\\n            if(fastptr)\\n                fastptr = fastptr->next;\\n        }while(fastptr && slowptr!=fastptr);\\n        return fastptr ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(!head)   return false;\\n        ListNode *slowptr = head;\\n        ListNode *fastptr = head;\\n        do{\\n            slowptr = slowptr->next;\\n            fastptr = fastptr->next;\\n            if(fastptr)\\n                fastptr = fastptr->next;\\n        }while(fastptr && slowptr!=fastptr);\\n        return fastptr ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535603,
                "title": "c-12ms-constant-space-solution-runner-technique",
                "content": "```\\n    bool hasCycle(ListNode *head) {\\n        ListNode *slow = head, *fast = head;\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast) return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    bool hasCycle(ListNode *head) {\\n        ListNode *slow = head, *fast = head;\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44629,
                "title": "java-fast-slow-pointers-solution",
                "content": "        \\n    public boolean hasCycle(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return false;\\n        }\\n        ListNode slow = head, fast = head.next.next;\\n        // if \"fast\" is null, there is no circle\\n        while (fast != null && fast.next != null) {\\n            if (slow == fast) {\\n                return true;\\n            }\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        } \\n        return false;\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "        \\n    public boolean hasCycle(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return false;\\n        }\\n        ListNode slow = head, fast = head.next.next;\\n        // if \"fast\" is null, there is no circle\\n        while (fast != null && fast.next != null) {\\n            if (slow == fast) {\\n                return true;\\n            }\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        } \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4102699,
                "title": "video-visualization-of-tortoise-and-hare-floyd-s-cycle-detection-algorithm",
                "content": "https://youtu.be/RRSItF-Ts4Q\\n\\nThe last pointer in a linked list usually points to a null value to singal the end of the list, but if the last pointer points back to another node in the linked list instead, we now have a cycle.  The most common way to solve this problem is by using the Tortoise and Hare algorithm.\\n\\nThe idea is that we create two pointers,  a slow one and a fast one.  The slow pointer traverses the linked list 1 node at a time, while the fast pointer traverses the linked list 2 nodes at a time.  If at some point the two pointers meet on the same node, then that means a cycle exists.\\n\\nWhy does this work? For a visual animation, please see the video, but for a simple explanation, think of two people running on a circular track.  If both people run and one of them runs faster than the other, then the faster person will eventually catch up to the slower one and \"lap\" them.  In other words, they will be back at the same position again.  This is what we\\'re looking for in the algorithm and it\\'s how we detect a cycle. \\n\\n# Code\\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        fast = head\\n        while fast and fast.next:\\n            head = head.next\\n            fast = fast.next.next\\n            if head is fast:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        fast = head\\n        while fast and fast.next:\\n            head = head.next\\n            fast = fast.next.next\\n            if head is fast:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999419,
                "title": "java-0ms-100-faster",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n\\n        ListNode fast = head.next;\\n        ListNode slow = head;\\n\\n        while(slow != fast && fast != null && fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        if(slow == fast)\\n            return true;\\n\\n        return false;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n\\n        ListNode fast = head.next;\\n        ListNode slow = head;\\n\\n        while(slow != fast && fast != null && fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        if(slow == fast)\\n            return true;\\n\\n        return false;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999114,
                "title": "easy-c-slow-fast-with-different-strides-beats-91-08",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse 2 pointers slow & fast to detect the cycle. Floyd\\'s Algorithm\\n(Tortoise and Hare Algorithm)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf once fast==slow then there is a cycle, otherwise til null.\\nIn usual, the stride for slow is taken 1, and the stride for fast is taken 2.\\nIn 2nd approach, the stride for slow is taken 2, and the stride for fast is taken  3. since 2, 3 are coprime, if there is a cycle, fast & slow will meet.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (!head||!head->next || !head->next->next) \\n            return 0;\\n        ListNode *fast=head, *slow=head;\\n        //int i=0;\\n        while(fast!=NULL && fast->next!=NULL){\\n            fast=fast->next->next;\\n            slow=slow->next;\\n        //    cout<<++i<<\",\";\\n            if (fast==slow) return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n# 2nd Code slow with stride=2 and fast with stride=3\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (!head||!head->next || !head->next->next) \\n            return 0;\\n        ListNode *fast=head, *slow=head;\\n        //int i=0;\\n        while(fast && fast->next && fast->next->next){\\n            fast=fast->next->next->next;\\n            slow=slow->next->next;\\n        //    cout<<++i<<\",\";\\n            if (fast==slow) return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (!head||!head->next || !head->next->next) \\n            return 0;\\n        ListNode *fast=head, *slow=head;\\n        //int i=0;\\n        while(fast!=NULL && fast->next!=NULL){\\n            fast=fast->next->next;\\n            slow=slow->next;\\n        //    cout<<++i<<\",\";\\n            if (fast==slow) return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (!head||!head->next || !head->next->next) \\n            return 0;\\n        ListNode *fast=head, *slow=head;\\n        //int i=0;\\n        while(fast && fast->next && fast->next->next){\\n            fast=fast->next->next->next;\\n            slow=slow->next->next;\\n        //    cout<<++i<<\",\";\\n            if (fast==slow) return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3473808,
                "title": "c-easy-to-understand-100-fast-slow-and-fast-pointer",
                "content": "\\nclass Solution {\\npublic:\\n\\n    bool hasCycle(ListNode *head) {\\n        if(head == NULL)\\n            return false;\\n        if(head-> next == NULL)\\n            return false;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n         while(slow != NULL && fast != NULL){\\n             fast = fast->next;\\n             if(fast != NULL)\\n                 fast = fast->next;\\n             slow = slow-> next;\\n             if(slow == fast)\\n                 return true;\\n         }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool hasCycle(ListNode *head) {\\n        if(head == NULL)\\n            return false;\\n        if(head-> next == NULL)\\n            return false;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n         while(slow != NULL && fast != NULL){\\n             fast = fast->next;\\n             if(fast != NULL)\\n                 fast = fast->next;\\n             slow = slow-> next;\\n             if(slow == fast)\\n                 return true;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 3460021,
                "title": "beats-92-12-20-145-top-interview-question",
                "content": "# Intuition\\n*Floyds, fast and slow two pointer technique*\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is a Python implementation of the Floyd\\'s Cycle Detection Algorithm to detect whether a linked list has a cycle or not. Here\\'s an explanation of the code:\\n\\nThe input is a linked list represented by the head node.\\n\\nThe function `hasCycle` takes in the head node as an argument and returns a boolean value indicating whether the linked list contains a cycle or not.\\n\\nWe initialize two pointers, `s` (slow) and `f` (fast), both pointing to the head node.\\n\\nWe then start iterating over the linked list using `s` and `f` pointers. The `s` pointer moves one step at a time while the `f` pointer moves two steps at a time.\\n\\nIf there is a cycle in the linked list, the `f` pointer will eventually catch up to the `s` pointer from behind, i.e., `f` will eventually become equal to `s`.\\n\\nAt this point, we can return `True` as there is a cycle in the linked list.\\n\\nIf `f` reaches the end of the linked list, i.e., `f` becomes `None`, it means that there is no cycle in the linked list. We can return `False` in this case.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n\\nThe `time complexity` of this algorithm is `O(n)`, where `n` is the number of nodes in the linked list. The `space complexity` is `O(1)` since we are only using two pointers, regardless of the size of the linked list.\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        s, f = head,head\\n        while f and f.next: \\n            s = s.next\\n            f = f.next.next\\n            if f == s: return True\\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        s, f = head,head\\n        while f and f.next: \\n            s = s.next\\n            f = f.next.next\\n            if f == s: return True\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442290,
                "title": "java",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null) {\\n            return false;\\n        }\\n\\n        ListNode slow = head;\\n        ListNode fast = head;\\n\\n        while (fast.next != null && fast.next.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null) {\\n            return false;\\n        }\\n\\n        ListNode slow = head;\\n        ListNode fast = head;\\n\\n        while (fast.next != null && fast.next.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360992,
                "title": "java-solution-in-o-1-easy-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to print ``true`` or ``false`` if Cylce in the list repeats then we have to print ``true`` otherwise ``false``. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake Two pointers, one for head and second for next node.\\nStart traversal with a ``while`` loop with condition if ``p1 != p2``\\nand first check that ``p2 and p2.next`` must not ``null``  because if it is null then ``no cycle found`` and after it taking another value in pointes `p1 = p1.next && p2 = p2.next.next`. If the loop sucessfully run then there is cycle present other wise not.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null || head.next == null)\\n            return false;\\n        ListNode p1 = head;\\n        ListNode p2 = head.next;\\n        while (p1 != p2){\\n            if (p2 == null || p2.next == null)\\n                return false;\\n            p1 = p1.next;\\n            p2 = p2.next.next;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n# UpVote If you like and Understand otherwise not.\\n#### Thank you",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null || head.next == null)\\n            return false;\\n        ListNode p1 = head;\\n        ListNode p2 = head.next;\\n        while (p1 != p2){\\n            if (p2 == null || p2.next == null)\\n                return false;\\n            p1 = p1.next;\\n            p2 = p2.next.next;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300459,
                "title": "trust-me-no-one-can-beat-this-2-approaches-step-by-step-explained",
                "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot 2023-03-15 185755.png](https://assets.leetcode.com/users/images/0b16712a-c2f1-402b-a89f-f73f64a230b0_1678889126.3366673.png)\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        // Check if the list is empty\\n        if (head == null) {\\n            return false;\\n        }\\n    \\n        // Initialize two pointers: slow and fast\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n    \\n        // Loop until the fast pointer reaches the end of the list or catches up to the slow pointer\\n        while (fast != null && fast.next != null) {\\n            // Check if the slow and fast pointers point to the same node, indicating a cycle\\n            if (slow == fast) {\\n                return true;\\n            }\\n            // Move the slow pointer one step forward and the fast pointer two steps forward\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n    \\n    // If the loop completes without finding a cycle, return false\\n    return false;\\n    }\\n}\\n```\\n\\n\\n# HASHSET APPROACH\\n\\n    public boolean hasCycle(ListNode head) {\\n\\n        //check if head or head.next is null\\n\\n        if(head==null || head.next == null){\\n            return false;\\n        }\\n        //creat a HashSet\\n        HashSet<ListNode> map = new HashSet<>();\\n\\n        //Run a loop till head is not null\\n\\n        while(head.next != null){\\n\\n            //If map contains head then there is loop\\n\\n            if(map.contains(head)){\\n                return true;\\n            }\\n            //If it has occured for the first time then add it to hashmap\\n            else{\\n                map.add(head);\\n            }\\n            //move the head pointer\\n            head = head.next;\\n        }\\n        return false;\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        // Check if the list is empty\\n        if (head == null) {\\n            return false;\\n        }\\n    \\n        // Initialize two pointers: slow and fast\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n    \\n        // Loop until the fast pointer reaches the end of the list or catches up to the slow pointer\\n        while (fast != null && fast.next != null) {\\n            // Check if the slow and fast pointers point to the same node, indicating a cycle\\n            if (slow == fast) {\\n                return true;\\n            }\\n            // Move the slow pointer one step forward and the fast pointer two steps forward\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n    \\n    // If the loop completes without finding a cycle, return false\\n    return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198648,
                "title": "using-floyd-s-cycle-finding-algorithm-to-detect-a-cycle-in-a-linked-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo detect a cycle in a linked list, we can use the \"Floyd\\'s cycle-finding algorithm\" (also known as the \"tortoise and hare algorithm\").\\n\\nThe idea behind this algorithm is to use two pointers - a slow pointer and a fast pointer - to traverse the linked list. The slow pointer moves one node at a time, while the fast pointer moves two nodes at a time. If there is a cycle in the linked list, the fast pointer will eventually catch up to the slow pointer, and they will meet at some node in the cycle.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere\\'s the algorithm:\\n\\n1. Initialize two pointers, slow and fast, to the head of the linked list.\\n2. Traverse the linked list using the slow and fast pointers as follows:\\na. Move the slow pointer one node at a time.\\nb. Move the fast pointer two nodes at a time.\\nc. If the fast pointer reaches the end of the linked list (i.e., its next node is null), then the linked list has no cycle, so return false.\\nd. If the fast pointer ever equals the slow pointer, then there is a cycle in the linked list, so return true.\\n3. If we have reached the end of the linked list (i.e., the fast pointer is null), then the linked list has no cycle, so return false.\\n\\n# Complexity\\n- Time complexity: The algorithm traverses the linked list once using two pointers. The slow pointer moves one step at a time, and the fast pointer moves two steps at a time. The maximum number of steps that the fast pointer can take is N/2, where N is the length of the linked list. Therefore, the time complexity of the algorithm is O(N).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  The algorithm only uses two pointers, so the space complexity is O(1) (constant space).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nnote : This algorithm has a time complexity of O(n) and a space complexity of O(1), as it only uses two pointers to traverse the linked list.\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        # Initialize two pointers to the head of the linked list\\n        slow = head\\n        fast = head\\n    \\n        # Traverse the linked list using the slow and fast pointers\\n        while fast and fast.next:\\n        # Move the slow pointer one node at a time\\n            slow = slow.next\\n        \\n        # Move the fast pointer two nodes at a time\\n            fast = fast.next.next\\n        \\n        # If the fast pointer ever equals the slow pointer, then there is a cycle\\n            if slow == fast:\\n                return True\\n    \\n        # If we have reached the end of the linked list, then there is no cycle\\n        return False\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        # Initialize two pointers to the head of the linked list\\n        slow = head\\n        fast = head\\n    \\n        # Traverse the linked list using the slow and fast pointers\\n        while fast and fast.next:\\n        # Move the slow pointer one node at a time\\n            slow = slow.next\\n        \\n        # Move the fast pointer two nodes at a time\\n            fast = fast.next.next\\n        \\n        # If the fast pointer ever equals the slow pointer, then there is a cycle\\n            if slow == fast:\\n                return True\\n    \\n        # If we have reached the end of the linked list, then there is no cycle\\n        return False\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080048,
                "title": "brute-force-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbrute force\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n         int n=0;\\n        ListNode temp=head;\\n        while(temp!=null){\\n            temp=temp.next;\\n            n++; \\n            if(n>10000){\\n                return true;\\n            }     \\n        }\\n       return false;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n         int n=0;\\n        ListNode temp=head;\\n        while(temp!=null){\\n            temp=temp.next;\\n            n++; \\n            if(n>10000){\\n                return true;\\n            }     \\n        }\\n       return false;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931329,
                "title": "simplest-java-sloution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow= head;\\n        ListNode fast= head;\\n        while(fast != null && fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow= head;\\n        ListNode fast= head;\\n        while(fast != null && fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765271,
                "title": "two-pointers",
                "content": "```\\nclass Solution:\\n    def hasCycle(self, head):\\n        slow = fast = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast: return True\\n            \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head):\\n        slow = fast = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast: return True\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714734,
                "title": "easy-python-solution",
                "content": "\\n        try:\\n            slow = head\\n            fast = head.next\\n            while slow is not fast:\\n                slow = slow.next\\n                fast = fast.next.next\\n            return True\\n        except:\\n            return False\\n\\t\\t\\t\\n\\t\\t\\t\"\"\"create two pointers and make them chase each other ,when the fast catches the slow ,you have your condition ,Make sure all errors are returned as false\"\"\"",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "\\n        try:\\n            slow = head\\n            fast = head.next\\n            while slow is not fast:\\n                slow = slow.next\\n                fast = fast.next.next\\n            return True\\n        except:\\n            return False\\n\\t\\t\\t\\n\\t\\t\\t\"\"\"create two pointers and make them chase each other ,when the fast catches the slow ,you have your condition ,Make sure all errors are returned as false\"\"\"",
                "codeTag": "Unknown"
            },
            {
                "id": 1900811,
                "title": "java-easy-to-understand-2-methods-detailed-explanation",
                "content": "We can solve this problem by using any of the 2 methods below-\\n***Please upvote if this explanation helps you.***\\n\\n1. Using **Floyd\\'s Cycle Finding Algorithm**-\\nFloyd\\u2019s cycle-finding algorithm is a pointer algorithm that uses only two pointers, moving through the sequence at different speeds. It states the usage of Linked List in this algorithm and its output.\\nThe purpose is to determine whether the linked list has a cycle or not. First, we keep two pointers of the head node they are, **slow pointer** and **fast pointer**. At each iteration, you move one of the pointers by two steps and the other one by one step. So you have two pointers tortoise and the hare. Eventually one of the two cases will happen:\\n\\n- **fastPointer** will reach the tail of the linked list(null), which means that there is no cycle in it\\n- **fastPointer** will meet **slowPointer**, which means that there is a cycle.\\n\\n\\nLet\\'s understand by the below example-\\nHere the **Car M** is **SlowPointer** and **Car B** is **FastPointer**.\\n\\n![image](https://assets.leetcode.com/users/images/d5d5ace4-2acd-49e9-8426-ae1deefb2cd0_1648740035.1112502.png)\\n![image](https://assets.leetcode.com/users/images/922c80fe-b2bd-4969-8323-8a063267e39d_1648740045.818089.png)\\n![image](https://assets.leetcode.com/users/images/4debbcc6-2098-4853-ad03-15338b2828b1_1648740053.1831126.png)\\n![image](https://assets.leetcode.com/users/images/b7bc0632-72da-4123-b3ee-7a4187ba3ef2_1648740059.1595976.png)\\n![image](https://assets.leetcode.com/users/images/b00d602e-ac6e-494f-a93a-de820f9ca028_1648740064.7201557.png)\\n![image](https://assets.leetcode.com/users/images/f870c926-189b-4f31-bc6b-770f4dfb27f1_1648740071.0575871.png)\\n![image](https://assets.leetcode.com/users/images/3601f3f4-0a21-4db9-abad-7f094ce79e69_1648740077.4067209.png)\\n\\n```\\npublic boolean hasCycle(ListNode head) {\\n        ListNode slowPointer = head;\\n        ListNode fastPointer = head;\\n        \\n        do {\\n            if (slowPointer == null || fastPointer == null || fastPointer.next == null) {\\n                return false;\\n            } \\n            slowPointer = slowPointer.next;\\n            fastPointer = fastPointer.next.next;\\n        } while (slowPointer != fastPointer);\\n        \\n        return true;\\n    }\\n```\\n**Time Complexity- O(N) \\nSpace Complexity- O(1)**\\n\\n\\n2. Using **HashSet**-\\n- Hashset posses an unique property of storing only distinct values.\\n- The boolean **contains(element)** method in Java HashSet returns false if a same element exists in the set.If the element doesn\\'t exists in the HashSet then add the element by using **add(element)** method.\\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head==null || head.next == null){\\n            return false;\\n        }\\n        HashSet<ListNode> llSet = new HashSet<>();\\n        while(head.next!=null){\\n            if(llSet.contains(head)){\\n                return true;\\n            }\\n            else{\\n                llSet.add(head);\\n            }\\n            head = head.next;\\n        }\\n        return false;\\n    }\\n}\\n```\\n**Time Complexity- O(N) \\nSpace Complexity- O(N)**\\n\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\npublic boolean hasCycle(ListNode head) {\\n        ListNode slowPointer = head;\\n        ListNode fastPointer = head;\\n        \\n        do {\\n            if (slowPointer == null || fastPointer == null || fastPointer.next == null) {\\n                return false;\\n            } \\n            slowPointer = slowPointer.next;\\n            fastPointer = fastPointer.next.next;\\n        } while (slowPointer != fastPointer);\\n        \\n        return true;\\n    }\\n```\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head==null || head.next == null){\\n            return false;\\n        }\\n        HashSet<ListNode> llSet = new HashSet<>();\\n        while(head.next!=null){\\n            if(llSet.contains(head)){\\n                return true;\\n            }\\n            else{\\n                llSet.add(head);\\n            }\\n            head = head.next;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830937,
                "title": "c-easy-to-understand-using-tortoise-approach-daily-leetcoding-challenge-day-8",
                "content": "// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09If it helps please Upvote\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\n\\nEXPLANATION : \\n* **Traverse linked list using two pointers.**\\n\\n*  **Move one pointer(slow) by one and another pointer(fast) by two.**\\n\\n* **If these pointers meet at the same node then there is a loop. If pointers do not meet then linked list doesn\\u2019t have a loop.** \\n\\n\\n* **Time Complexity : O(N)**\\n* **Space Complexity : O(1)**\\n```\\nclass Solution \\n{\\npublic:\\n    bool hasCycle(ListNode *head) \\n    {\\n        // check if head is on null or head next is on null\\n        if(head==NULL or head->next==NULL)\\n        {\\n            return false;\\n        }\\n        \\n        // 2 pointer approach\\n        // Tortoise and Hare approach\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        // till next->null or null is not find\\n        while(fast->next && fast->next->next)\\n        {\\n            slow = slow->next;       // move slow by one\\n            fast = fast->next->next; // move fast by two\\n            \\n            // if they collide\\n            if(slow==fast)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n// Example : \\n// [3,2,0,-4]\\n\\n// 1. slow = 3 , fast = 3\\n\\n// 2. slow = 2 , fast = 0\\n    \\n// 3. slow = 0 , fast = 2\\n    \\n// 4. slow = -4 , fast = -4     (they collide it means there is a cycle exist in the given linked list)\\n```\\n// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09If it helps please Upvote\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool hasCycle(ListNode *head) \\n    {\\n        // check if head is on null or head next is on null\\n        if(head==NULL or head->next==NULL)\\n        {\\n            return false;\\n        }\\n        \\n        // 2 pointer approach\\n        // Tortoise and Hare approach\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        // till next->null or null is not find\\n        while(fast->next && fast->next->next)\\n        {\\n            slow = slow->next;       // move slow by one\\n            fast = fast->next->next; // move fast by two\\n            \\n            // if they collide\\n            if(slow==fast)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n// Example : \\n// [3,2,0,-4]\\n\\n// 1. slow = 3 , fast = 3\\n\\n// 2. slow = 2 , fast = 0\\n    \\n// 3. slow = 0 , fast = 2\\n    \\n// 4. slow = -4 , fast = -4     (they collide it means there is a cycle exist in the given linked list)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829480,
                "title": "c-3-methods-100-faster-easy",
                "content": "```\\nMethod 1\\n\\n//Using hashing\\n//Here we will chech if the node we have visisted is present or not if we have visited it then it mean there is cycle.\\n\\n//Time complexity: O(n)\\n//Space complexity: O(n)\\n\\nclass Solution {\\npublic:\\n    unordered_map<ListNode*,int> mp;\\n    bool hasCycle(ListNode *head) {\\n        while(head!=NULL){\\n            if(mp.find(head) == mp.end()){\\n                mp[head]++;\\n            }\\n            else{\\n                return true;\\n            }\\n            head=head->next;\\n        }\\n        return false;\\n    }\\n};\\n\\nMethod 2\\n\\n//Floyd\\u2019s Cycle-Finding Algorithm \\n//Here we will use two pointers slow and fast \\n//where slow will travel one step and fast two step\\n//if they become same at some time there is cycle\\n//if fast is null then there is no cycle\\n\\n//Time complexity: O(n)\\n//Space complexity: O(1)\\n\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(head==NULL){\\n            return false;\\n        }\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        while(fast && fast->next){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nMethod 3\\n\\n//One easy methos is to modify the values of the linked list to tha value which is not in the range.\\n//When you encounter this value again then there is loop\\n\\n//Time complexity: O(n)\\n//Space complexity: O(1)\\n\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(head==NULL){\\n            return false;\\n        }\\n        while(head){\\n            if(head->val==1000000){\\n                return true;\\n            }\\n            head->val=1000000;\\n            head=head->next;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nMethod 1\\n\\n//Using hashing\\n//Here we will chech if the node we have visisted is present or not if we have visited it then it mean there is cycle.\\n\\n//Time complexity: O(n)\\n//Space complexity: O(n)\\n\\nclass Solution {\\npublic:\\n    unordered_map<ListNode*,int> mp;\\n    bool hasCycle(ListNode *head) {\\n        while(head!=NULL){\\n            if(mp.find(head) == mp.end()){\\n                mp[head]++;\\n            }\\n            else{\\n                return true;\\n            }\\n            head=head->next;\\n        }\\n        return false;\\n    }\\n};\\n\\nMethod 2\\n\\n//Floyd\\u2019s Cycle-Finding Algorithm \\n//Here we will use two pointers slow and fast \\n//where slow will travel one step and fast two step\\n//if they become same at some time there is cycle\\n//if fast is null then there is no cycle\\n\\n//Time complexity: O(n)\\n//Space complexity: O(1)\\n\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(head==NULL){\\n            return false;\\n        }\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        while(fast && fast->next){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nMethod 3\\n\\n//One easy methos is to modify the values of the linked list to tha value which is not in the range.\\n//When you encounter this value again then there is loop\\n\\n//Time complexity: O(n)\\n//Space complexity: O(1)\\n\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(head==NULL){\\n            return false;\\n        }\\n        while(head){\\n            if(head->val==1000000){\\n                return true;\\n            }\\n            head->val=1000000;\\n            head=head->next;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777202,
                "title": "simple-java-code-2-pointers-100-faster",
                "content": "```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode a=head,b=head;\\n        while(a!=null && a.next!=null){\\n            a=a.next.next;\\n            b=b.next;\\n            if(a==b && a.val==b.val)\\n                break;\\n        }\\n        return a!=null && a.next!=null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode a=head,b=head;\\n        while(a!=null && a.next!=null){\\n            a=a.next.next;\\n            b=b.next;\\n            if(a==b && a.val==b.val)\\n                break;\\n        }\\n        return a!=null && a.next!=null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626949,
                "title": "c-o-n-two-approaches-with-explanation",
                "content": "**The Problem can be solved with two different approaches**\\n* Method-1: Using extra space(HashTable)\\nThe idea here is to traverse through the LinkedList and For every node: check if it exists in the unordered_set.\\n->  If yes we simply return true\\n->otherwise we store the address of this node in the set   \\nThe intuition is that if there is no cycle in the Linkedlist then we will never reach a node again which has already \\nbeen visited.\\n```\\n\\t\\t\\t// there must be atleast two nodes to form a cycle\\n\\t\\t\\tif (head == NULL || head->next == NULL)\\n                return false;\\n            ListNode *dummy = head;\\n            unordered_set<ListNode *> s;\\n            while (dummy != NULL)\\n            {\\n                if (s.find(dummy) != s.end())\\n                {\\n                    return true;\\n                }\\n                s.insert(dummy);\\n                dummy = dummy->next;\\n            }\\n            return false;\\n```\\nThe Time Complexity is O(n) and and extra space O(n) is needed to store the nodes.\\n\\n* Method-2: Two Pointer Approach\\n->This is an efficient method of finding the cycle as it doesnot use any extra space.\\n->The idea is to use two pointers fast and slow where slow moves by one step and fast by two steps.\\n->If there is no cycle in the Linkedlist the two pointers will never meet and fast pointer will eventually become null.\\n->if there is a cycle then the pointers will revolve around the cycle and will definitely meet at some node because fast will chase down slow at some point of time.\\n\\n```         // base case\\n\\t\\t\\tif (head == NULL || head->next == NULL)\\n                return false;\\n            ListNode *slow, *fast;\\n            slow = fast = head;\\n            while (fast != NULL && fast->next != NULL)\\n            {\\n                slow = slow->next;\\n                fast = fast->next->next;\\n                if (slow == fast)\\n                {\\n                    return true;\\n                }\\n            }\\n\\t\\t\\t// the control will come out of while loop only when the List is linear\\n            return false;\\n```\\nTime Complexity: O(n) \\nDo upvote if u like this. Happy Coding :)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\t\\t\\t// there must be atleast two nodes to form a cycle\\n\\t\\t\\tif (head == NULL || head->next == NULL)\\n                return false;\\n            ListNode *dummy = head;\\n            unordered_set<ListNode *> s;\\n            while (dummy != NULL)\\n            {\\n                if (s.find(dummy) != s.end())\\n                {\\n                    return true;\\n                }\\n                s.insert(dummy);\\n                dummy = dummy->next;\\n            }\\n            return false;\\n```\n```         // base case\\n\\t\\t\\tif (head == NULL || head->next == NULL)\\n                return false;\\n            ListNode *slow, *fast;\\n            slow = fast = head;\\n            while (fast != NULL && fast->next != NULL)\\n            {\\n                slow = slow->next;\\n                fast = fast->next->next;\\n                if (slow == fast)\\n                {\\n                    return true;\\n                }\\n            }\\n\\t\\t\\t// the control will come out of while loop only when the List is linear\\n            return false;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1511575,
                "title": "accepted-clean-c-solution",
                "content": "class Solution {\\npublic:\\n\\n    bool hasCycle(ListNode *head) {\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        \\n        while(fast!=NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(fast==slow){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    bool hasCycle(ListNode *head) {\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        \\n        while(fast!=NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(fast==slow){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1460220,
                "title": "linked-list-cycle-c-floyd-s-cycle-finding-algorithm-optimal-solution",
                "content": "**Floyd\\'s Cycle Detection Algorithm** (**Two Pointer Approach**) :\\n\\nclass Solution {\\npublic:\\n\\n    bool hasCycle(ListNode *head) {\\n    \\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n       \\n        while(slow && fast && fast->next)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(slow == fast)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nTime Complexity :- O(N)\\nSpace Complexity :- O(1)\\n\\n**if you like this solution. so please upvoted.**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool hasCycle(ListNode *head) {\\n    \\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n       \\n        while(slow && fast && fast->next)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(slow == fast)\\n            {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1447426,
                "title": "optimised-c-solution-floyd-s-algorithm-full-explanation-of-code",
                "content": "This is the **Floyd\\'s Algorithm** also known as **Hare and Tortoise Algorithm**. It use two pointers ```slow``` and ```fast``` pointer.\\nAccording to the algorithm we will move the ```slow``` pointer by one step and ```fast```pointer by 2 steps , and if the ```slow``` and ```fast``` pointers colides that means there is a cycle in a linked list and we return true .\\n\\n```\\nbool hasCycle(ListNode *head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        while(fast != NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            \\n            if(slow == fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nHope This explaination was helpful !!! \\uD83D\\uDE4C",
                "solutionTags": [],
                "code": "```slow```\n```fast```\n```slow```\n```fast```\n```slow```\n```fast```\n```\\nbool hasCycle(ListNode *head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        while(fast != NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            \\n            if(slow == fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1165659,
                "title": "c-unique-single-traversal-time-o-n-and-space-o-1",
                "content": "**This approach is little bit faster than two-pointer approach. Because here we are traversing each element only single time.**\\n```\\n    bool hasCycle(ListNode *head) {  \\n        while(head && head->val != INT_MIN) {\\n            head->val = INT_MIN;\\n            head = head->next;\\n        }\\t\\t\\n        return head != NULL;\\n    }\\n```\\n\\n**Comment below if you have any queries. I would love to answer them and don\\'t forget to upvote, if you like the solution.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    bool hasCycle(ListNode *head) {  \\n        while(head && head->val != INT_MIN) {\\n            head->val = INT_MIN;\\n            head = head->next;\\n        }\\t\\t\\n        return head != NULL;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1164503,
                "title": "easy-to-understand-2-java-solution-using-two-pointers-beats-100",
                "content": "we will use two pointers slow and fast. if it is not a cyclic list then it will end in null so check that condition in while loop for fast pointer as it will aprroach to end first.\\nif it is cyclic list then sometimes slow and fast will always meet.\\nfor example consider a cricular Racing car track  one car is moving slow and one is moving fast just like our pointer now fast will finish first and if it keeps moving in circular track(like in this case) then on its way it will always meet the slow car , may be in first round may be in second but it will meet for sure.\\n\\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null){\\n            return false;\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while(fast.next != null && fast.next.next != null){     \\n            slow = slow.next;\\n            fast = fast.next.next;\\n            \\n             if(slow == fast){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\nApproach 2(Point the next of every node to head and check it some node\\'s next is already pointing to head it means there is a cycle in linked list\\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null){\\n            return false;\\n        }\\n        ListNode curr = head;\\n        ListNode next = head.next;\\n        \\n        while(curr != null && curr.next != null){\\n            if(curr.next == head){\\n                return true;\\n            }\\n            next = curr.next;//secure the remaining chain so that we don\\'t loose it after changing the link\\n            curr.next = head; // pointing every pointer to head\\n            curr = next; // iteration logic\\n            \\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null){\\n            return false;\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while(fast.next != null && fast.next.next != null){     \\n            slow = slow.next;\\n            fast = fast.next.next;\\n            \\n             if(slow == fast){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null){\\n            return false;\\n        }\\n        ListNode curr = head;\\n        ListNode next = head.next;\\n        \\n        while(curr != null && curr.next != null){\\n            if(curr.next == head){\\n                return true;\\n            }\\n            next = curr.next;//secure the remaining chain so that we don\\'t loose it after changing the link\\n            curr.next = head; // pointing every pointer to head\\n            curr = next; // iteration logic\\n            \\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088956,
                "title": "destructively-fast-python-faster-than-99-o-n-time-o-1-space",
                "content": "Seeing this problem, a couple things come to mind:\\n\\nWe have to traverse the entire linked list -> leading to minimum O(n) runtime. \\n\\nWhen does this worst case occur? In the case that there is no cycle, or the last node creates the cycle.\\n\\nWe alse need to ensure that if there is a cycle, we are not looping around endlessly.\\n\\nOne way to solve this would be to keep a record of what nodes we have seen, and then check each time, however this increases space complexity (This is a good start though)\\n\\nIf we allow ourself to destruct the original list -> we can just set the value of the nodes we have seen to None, and then check the value each time to make sure it is not None (we havent seen it). If we have seen it, so value is None, return True (Cycle Exists)\\n\\nElse, the loop will reach the end of the linkedlist and return False.\\n\\n```\\n    def hasCycle(self, head: ListNode) -> bool:        \\n        curr = head\\n        \\n        while curr:\\n            if curr.val is None:\\n                return True\\n            curr.val = None\\n            curr = curr.next\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\n    def hasCycle(self, head: ListNode) -> bool:        \\n        curr = head\\n        \\n        while curr:\\n            if curr.val is None:\\n                return True\\n            curr.val = None\\n            curr = curr.next\\n        \\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1048061,
                "title": "linkedlistcycle-two-solutions-fully-explained-3ms-0ms",
                "content": "Key problem is that there is a linked list which may loop back on itself, forming a cycle.\\nWhen walking the list the cycle can be detected by noticing that the tail node points to a node that has already been seen.\\n\\nMy initial approach was to use a set to maintain a set of nodes previously traversed. Then if I came across a node already in the set I had a cycle. This ran in 3ms.\\n\\nA better approach was to use [Floyd\\'s Tortoise and Hare algorithm](https://en.wikipedia.org/wiki/Cycle_detection#Floyd\\'s_tortoise_and_hare). This ran in 0ms.\\n\\nBoth algorithms are outlined below:\\n\\n**Set Based Algorithm**\\nThis maintains a set of previously visited nodes. If a pointer to a null node is reached then the algorithm terminates, otherwise it checks the current node against the set and if it already exists then a cycle has been found.\\n\\n**Time Complexity O(N)** as adding/checking entries in the set is O(1) and we run until we find the cycle or reach the end.\\n**Space Complexity O(N)** because we maintain a set of all the previously seen nodes and we will not detect a cycle until we have seen all nodes and added them to the set.\\n\\n**Algorithm**\\n* While node != null\\n\\t* if set contains node then found a cycle\\n\\t\\t* return false\\n\\t* Add node to set\\n\\t* Set node to successor node\\n* return false as found a null\\n\\nNote the code below could be improved by noting that the add operation returns false if the iterm is already in the set, reducing the number of calls in the loop to the set by half. This would change the code to\\n```\\n\\t\\tif (!set.add(head))\\n\\t\\t\\treturn true;\\n```\\nwhich is more efficient but I feel lacks some clarity of purpose.\\n```\\npublic boolean hasCycle(ListNode head) {\\n\\tSet<ListNode> set = new HashSet<>();\\n\\twhile (head != null) {\\n\\t\\tif (set.contains(head))\\n\\t\\t\\treturn true;\\n\\t\\tset.add(head);\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n**Floyd\\'s Tortoise & Hare Algorithm**\\nThe [Wikipedia article](https://en.wikipedia.org/wiki/Cycle_detection#Floyd\\'s_tortoise_and_hare) mentioned above is a little technical but the concept is very simple. We maintain two pointers, a slow pointer and a fast pointer. The slow pointer moves one node at a time while the fast pointer moves two nodes at a time. Eventually both pointers will be going around the cycle. Because of this we can imagine that the fast pointer is behind the slow pointer and  closes in on it one node at a time. This means that the fast pointer will always catch up with the slow pointer. For example if the fast pointer is 3 nodes behind the slow pointer (remember that this is a cycle so in one sense the fast pointer is always behind the slow pointer), then the slow pointer moves one node to open the gap to four nodes, but the fast pointer moves two nodes to reduce the gap to two node, thus closing the gap by one node. So for a loop of K nodes the fast pointer will always reach the slow pointer in at most K steps of the slow pointer.\\n\\nThis algorithm ran in 0ms.\\n\\n**Time Complexity O(N)** because slow pointer takes N-K steps to reach K sized cycle and once in the cycle in worst case fast pointer will reach it in K steps. So total complexity is O(3N) as we do two fast pointer operations for every slow pointer operation.\\n\\n**Space Complexity O(1)** as no extra storage required beyond fast and slow pointers.\\n\\n**Algorithm**\\n* If head or head.next is null reach end without cycle\\n\\t* return false\\n* Initialise slow pointer to head and fast pointer to successor to head\\n* While fast ! = slow\\n\\t* Check if either of next two nodes for fast are null, if so then no cycles\\n\\t\\t* return false\\n\\t* Move slow to next node\\n\\t* Move fast two nodes ahead\\n* return true as fast and slow are pointing to same node so muct be a cycle\\n```\\npublic boolean hasCycle(ListNode head) {\\n\\tif (head == null || head.next == null)\\n\\t\\treturn false;\\n\\tListNode slow = head;\\n\\tListNode fast = head.next;\\n\\twhile (slow != fast) {\\n\\t\\tif (fast.next == null || fast.next.next == null)\\n\\t\\t\\treturn false;\\n\\t\\tslow = slow.next;\\n\\t\\tfast = fast.next.next;\\n\\t}\\n\\treturn true;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tif (!set.add(head))\\n\\t\\t\\treturn true;\\n```\n```\\npublic boolean hasCycle(ListNode head) {\\n\\tSet<ListNode> set = new HashSet<>();\\n\\twhile (head != null) {\\n\\t\\tif (set.contains(head))\\n\\t\\t\\treturn true;\\n\\t\\tset.add(head);\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn false;\\n}\\n```\n```\\npublic boolean hasCycle(ListNode head) {\\n\\tif (head == null || head.next == null)\\n\\t\\treturn false;\\n\\tListNode slow = head;\\n\\tListNode fast = head.next;\\n\\twhile (slow != fast) {\\n\\t\\tif (fast.next == null || fast.next.next == null)\\n\\t\\t\\treturn false;\\n\\t\\tslow = slow.next;\\n\\t\\tfast = fast.next.next;\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1047745,
                "title": "o-n-easy-solution-no-slow-and-fast-pointer-no-maping-for-visited-node-only-constraint-analysis",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        int test=-1*999999;\\n        while(head)\\n        {\\n            if(head->val==test)\\n                return true;\\n            head->val=test;\\n            head=head->next;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        int test=-1*999999;\\n        while(head)\\n        {\\n            if(head->val==test)\\n                return true;\\n            head->val=test;\\n            head=head->next;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030589,
                "title": "easy-solution-without-hashtable-and-floyd-s-cycle-finding-algorithm",
                "content": "The key idea is to use constraint `-10^5 <= Node.val <= 10^5`.\\n1. Choose value out of range, for example `Int32.MaxValue`\\n2. Traverse LinkedList\\n3. Mark all nodes with chosen value\\n4. Once we meet chosen value -> we have a cycle!\\n```\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        var cycle = Int32.MaxValue;\\n        while(head != null)\\n        {\\n            if(head.val == cycle) return true;\\n            head.val = cycle;\\n            head = head.next;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        var cycle = Int32.MaxValue;\\n        while(head != null)\\n        {\\n            if(head.val == cycle) return true;\\n            head.val = cycle;\\n            head = head.next;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856032,
                "title": "ruby-thank-you-safe-navigation-operator",
                "content": "```ruby\\ndef hasCycle(head)\\n  return false unless head\\n  hare = tortoise = head\\n\\n  loop do\\n    return false unless hare = hare&.next&.next\\n    tortoise = tortoise.next\\n    return true if hare == tortoise\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef hasCycle(head)\\n  return false unless head\\n  hare = tortoise = head\\n\\n  loop do\\n    return false unless hare = hare&.next&.next\\n    tortoise = tortoise.next\\n    return true if hare == tortoise\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 816171,
                "title": "c-solution",
                "content": "```\\nbool hasCycle(struct ListNode *head) {\\n    for(; head!=NULL; head = head->next)\\n    {\\n        if(head->val == -100000)\\n            return true;\\n        head->val = -100000;   \\n    }\\n    return false;\\n}\\n```\\nI used -100000, but there wasn\\'t any indication about the range of values, in this case btw it works",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool hasCycle(struct ListNode *head) {\\n    for(; head!=NULL; head = head->next)\\n    {\\n        if(head->val == -100000)\\n            return true;\\n        head->val = -100000;   \\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564592,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1566358,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1566128,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1575449,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1570510,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1566240,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1570016,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1569995,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1662891,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1838322,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1564592,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1566358,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1566128,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1575449,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1570510,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1566240,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1570016,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1569995,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1662891,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1838322,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1652162,
                "content": [
                    {
                        "username": "YananLyu",
                        "content": "if there is cycle, it would meet together,\\nif there is no cycle, it would reach out to tail.\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@codymorazan](/codymorazan) Exactly! I\\'m thinking about the same and looks like it doesn\\'t matter. From the description it\\'s not clear that the cycle can\\'t be between first and last nodes. Or I could understand that moment. \\nCould someone explain? \\n"
                    },
                    {
                        "username": "codymorazan",
                        "content": "Doesn\\'t this only account for cycles that exist either 1 or 2 indices behind the farthest pointer? How does this account for pointer with large spaces in between them, say 1 -> 2 -> 3 -> 4 -> 5 -> 1?"
                    },
                    {
                        "username": "jabberwky",
                        "content": "Where is the `pos` input parameter in the input?\\nThe question is just simply checking if there is a loop in the linked list."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the Tortoise and Hare algorithm\\n\\nhttps://youtu.be/RRSItF-Ts4Q"
                    },
                    {
                        "username": "anon301176",
                        "content": "my solution is failing under this test case: [-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5] very clearly there is a loop in this data, but its telling me i should be returning false. can someone explain this?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "If pos == -1, than it should return false."
                    },
                    {
                        "username": "amiramri",
                        "content": "How did you find that there is a loop? are you saying that base on the existing of the same value more than once? if so you are not correct. we can have different nodes with the same value."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I would not be so sure that there is a cycle. The same value doesn\\'t mean that it is the same Object. \\nI could create two ListNodes like this: \\nvar a = new ListNode(1) and\\nvar b = new ListNode(1), \\nthey will be different Objects, thus a == b will return false (but a.equals(b) may return true, if it\\'s implemented correctly).\\nNow, for this task we are compering reference a and b, not values. Think about it in terms of OOP.  "
                    },
                    {
                        "username": "krenast",
                        "content": "I understand how to answer the question, however I am still struggling how can I perform test case on my computer (construct the list and the linkedlist). Can someone can explain me how to code it ?\\n\\nThanks!"
                    },
                    {
                        "username": "user2903My",
                        "content": "You\\'ve commented part of code in code editor. For this task it\\'s looks like \"\\n* class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\"\\nOnly one that you can do - it\\'s create instances of all ListNode intances and set next property for everyone to next created instance"
                    },
                    {
                        "username": "maheshdeverapu",
                        "content": "[@njalgo](/njalgo) no need of constructing list and linkedlist. just take head as linkedlist and perform the logic and return the sol."
                    },
                    {
                        "username": "njalgo",
                        "content": "On your local computer, just set the Next pointer of the last node to any previous node. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked list problem! A hint: just use 2 pointers 1 fast & 1 slow. It\\'s fine."
                    },
                    {
                        "username": "ybank",
                        "content": "Basically, I came up with an accepted solution without using extra space, but destructed the linked list internally. The way I did was that after traversing the current node but before moving to the next node, I make the next pointer pointing to the current node.\\n\\nThis works fine but resetting the next pointer really annoys me. Other solutions I saw from the discussions either change the next pointers in other ways, or rely on a lucky number for the val of the node.\\n\\nI was wondering if anyone has a non-destructive solution, in the way that it preserves all the next pointers, that uses no extra space?\\n\\nThanks!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/linked-list-cycle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Cycle Finding Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tifv",
                        "content": "Hey, LeetCode, what the hell? I was happily writing Rust solutions for 126 days straight\\u2026"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe LeetCode doesn\\'t want to change the design of struct from using `next: Option<Box<ListNode>>`..."
                    },
                    {
                        "username": "SheekhaJ",
                        "content": "Hi, \\n\\nThe question mentions that pos is used to identify the location where the tail connects to. How is this being used during judging? \\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1569603,
                "content": [
                    {
                        "username": "YananLyu",
                        "content": "if there is cycle, it would meet together,\\nif there is no cycle, it would reach out to tail.\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@codymorazan](/codymorazan) Exactly! I\\'m thinking about the same and looks like it doesn\\'t matter. From the description it\\'s not clear that the cycle can\\'t be between first and last nodes. Or I could understand that moment. \\nCould someone explain? \\n"
                    },
                    {
                        "username": "codymorazan",
                        "content": "Doesn\\'t this only account for cycles that exist either 1 or 2 indices behind the farthest pointer? How does this account for pointer with large spaces in between them, say 1 -> 2 -> 3 -> 4 -> 5 -> 1?"
                    },
                    {
                        "username": "jabberwky",
                        "content": "Where is the `pos` input parameter in the input?\\nThe question is just simply checking if there is a loop in the linked list."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the Tortoise and Hare algorithm\\n\\nhttps://youtu.be/RRSItF-Ts4Q"
                    },
                    {
                        "username": "anon301176",
                        "content": "my solution is failing under this test case: [-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5] very clearly there is a loop in this data, but its telling me i should be returning false. can someone explain this?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "If pos == -1, than it should return false."
                    },
                    {
                        "username": "amiramri",
                        "content": "How did you find that there is a loop? are you saying that base on the existing of the same value more than once? if so you are not correct. we can have different nodes with the same value."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I would not be so sure that there is a cycle. The same value doesn\\'t mean that it is the same Object. \\nI could create two ListNodes like this: \\nvar a = new ListNode(1) and\\nvar b = new ListNode(1), \\nthey will be different Objects, thus a == b will return false (but a.equals(b) may return true, if it\\'s implemented correctly).\\nNow, for this task we are compering reference a and b, not values. Think about it in terms of OOP.  "
                    },
                    {
                        "username": "krenast",
                        "content": "I understand how to answer the question, however I am still struggling how can I perform test case on my computer (construct the list and the linkedlist). Can someone can explain me how to code it ?\\n\\nThanks!"
                    },
                    {
                        "username": "user2903My",
                        "content": "You\\'ve commented part of code in code editor. For this task it\\'s looks like \"\\n* class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\"\\nOnly one that you can do - it\\'s create instances of all ListNode intances and set next property for everyone to next created instance"
                    },
                    {
                        "username": "maheshdeverapu",
                        "content": "[@njalgo](/njalgo) no need of constructing list and linkedlist. just take head as linkedlist and perform the logic and return the sol."
                    },
                    {
                        "username": "njalgo",
                        "content": "On your local computer, just set the Next pointer of the last node to any previous node. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked list problem! A hint: just use 2 pointers 1 fast & 1 slow. It\\'s fine."
                    },
                    {
                        "username": "ybank",
                        "content": "Basically, I came up with an accepted solution without using extra space, but destructed the linked list internally. The way I did was that after traversing the current node but before moving to the next node, I make the next pointer pointing to the current node.\\n\\nThis works fine but resetting the next pointer really annoys me. Other solutions I saw from the discussions either change the next pointers in other ways, or rely on a lucky number for the val of the node.\\n\\nI was wondering if anyone has a non-destructive solution, in the way that it preserves all the next pointers, that uses no extra space?\\n\\nThanks!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/linked-list-cycle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Cycle Finding Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tifv",
                        "content": "Hey, LeetCode, what the hell? I was happily writing Rust solutions for 126 days straight\\u2026"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe LeetCode doesn\\'t want to change the design of struct from using `next: Option<Box<ListNode>>`..."
                    },
                    {
                        "username": "SheekhaJ",
                        "content": "Hi, \\n\\nThe question mentions that pos is used to identify the location where the tail connects to. How is this being used during judging? \\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1992444,
                "content": [
                    {
                        "username": "YananLyu",
                        "content": "if there is cycle, it would meet together,\\nif there is no cycle, it would reach out to tail.\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@codymorazan](/codymorazan) Exactly! I\\'m thinking about the same and looks like it doesn\\'t matter. From the description it\\'s not clear that the cycle can\\'t be between first and last nodes. Or I could understand that moment. \\nCould someone explain? \\n"
                    },
                    {
                        "username": "codymorazan",
                        "content": "Doesn\\'t this only account for cycles that exist either 1 or 2 indices behind the farthest pointer? How does this account for pointer with large spaces in between them, say 1 -> 2 -> 3 -> 4 -> 5 -> 1?"
                    },
                    {
                        "username": "jabberwky",
                        "content": "Where is the `pos` input parameter in the input?\\nThe question is just simply checking if there is a loop in the linked list."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the Tortoise and Hare algorithm\\n\\nhttps://youtu.be/RRSItF-Ts4Q"
                    },
                    {
                        "username": "anon301176",
                        "content": "my solution is failing under this test case: [-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5] very clearly there is a loop in this data, but its telling me i should be returning false. can someone explain this?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "If pos == -1, than it should return false."
                    },
                    {
                        "username": "amiramri",
                        "content": "How did you find that there is a loop? are you saying that base on the existing of the same value more than once? if so you are not correct. we can have different nodes with the same value."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I would not be so sure that there is a cycle. The same value doesn\\'t mean that it is the same Object. \\nI could create two ListNodes like this: \\nvar a = new ListNode(1) and\\nvar b = new ListNode(1), \\nthey will be different Objects, thus a == b will return false (but a.equals(b) may return true, if it\\'s implemented correctly).\\nNow, for this task we are compering reference a and b, not values. Think about it in terms of OOP.  "
                    },
                    {
                        "username": "krenast",
                        "content": "I understand how to answer the question, however I am still struggling how can I perform test case on my computer (construct the list and the linkedlist). Can someone can explain me how to code it ?\\n\\nThanks!"
                    },
                    {
                        "username": "user2903My",
                        "content": "You\\'ve commented part of code in code editor. For this task it\\'s looks like \"\\n* class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\"\\nOnly one that you can do - it\\'s create instances of all ListNode intances and set next property for everyone to next created instance"
                    },
                    {
                        "username": "maheshdeverapu",
                        "content": "[@njalgo](/njalgo) no need of constructing list and linkedlist. just take head as linkedlist and perform the logic and return the sol."
                    },
                    {
                        "username": "njalgo",
                        "content": "On your local computer, just set the Next pointer of the last node to any previous node. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked list problem! A hint: just use 2 pointers 1 fast & 1 slow. It\\'s fine."
                    },
                    {
                        "username": "ybank",
                        "content": "Basically, I came up with an accepted solution without using extra space, but destructed the linked list internally. The way I did was that after traversing the current node but before moving to the next node, I make the next pointer pointing to the current node.\\n\\nThis works fine but resetting the next pointer really annoys me. Other solutions I saw from the discussions either change the next pointers in other ways, or rely on a lucky number for the val of the node.\\n\\nI was wondering if anyone has a non-destructive solution, in the way that it preserves all the next pointers, that uses no extra space?\\n\\nThanks!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/linked-list-cycle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Cycle Finding Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tifv",
                        "content": "Hey, LeetCode, what the hell? I was happily writing Rust solutions for 126 days straight\\u2026"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe LeetCode doesn\\'t want to change the design of struct from using `next: Option<Box<ListNode>>`..."
                    },
                    {
                        "username": "SheekhaJ",
                        "content": "Hi, \\n\\nThe question mentions that pos is used to identify the location where the tail connects to. How is this being used during judging? \\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1801398,
                "content": [
                    {
                        "username": "YananLyu",
                        "content": "if there is cycle, it would meet together,\\nif there is no cycle, it would reach out to tail.\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@codymorazan](/codymorazan) Exactly! I\\'m thinking about the same and looks like it doesn\\'t matter. From the description it\\'s not clear that the cycle can\\'t be between first and last nodes. Or I could understand that moment. \\nCould someone explain? \\n"
                    },
                    {
                        "username": "codymorazan",
                        "content": "Doesn\\'t this only account for cycles that exist either 1 or 2 indices behind the farthest pointer? How does this account for pointer with large spaces in between them, say 1 -> 2 -> 3 -> 4 -> 5 -> 1?"
                    },
                    {
                        "username": "jabberwky",
                        "content": "Where is the `pos` input parameter in the input?\\nThe question is just simply checking if there is a loop in the linked list."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the Tortoise and Hare algorithm\\n\\nhttps://youtu.be/RRSItF-Ts4Q"
                    },
                    {
                        "username": "anon301176",
                        "content": "my solution is failing under this test case: [-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5] very clearly there is a loop in this data, but its telling me i should be returning false. can someone explain this?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "If pos == -1, than it should return false."
                    },
                    {
                        "username": "amiramri",
                        "content": "How did you find that there is a loop? are you saying that base on the existing of the same value more than once? if so you are not correct. we can have different nodes with the same value."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I would not be so sure that there is a cycle. The same value doesn\\'t mean that it is the same Object. \\nI could create two ListNodes like this: \\nvar a = new ListNode(1) and\\nvar b = new ListNode(1), \\nthey will be different Objects, thus a == b will return false (but a.equals(b) may return true, if it\\'s implemented correctly).\\nNow, for this task we are compering reference a and b, not values. Think about it in terms of OOP.  "
                    },
                    {
                        "username": "krenast",
                        "content": "I understand how to answer the question, however I am still struggling how can I perform test case on my computer (construct the list and the linkedlist). Can someone can explain me how to code it ?\\n\\nThanks!"
                    },
                    {
                        "username": "user2903My",
                        "content": "You\\'ve commented part of code in code editor. For this task it\\'s looks like \"\\n* class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\"\\nOnly one that you can do - it\\'s create instances of all ListNode intances and set next property for everyone to next created instance"
                    },
                    {
                        "username": "maheshdeverapu",
                        "content": "[@njalgo](/njalgo) no need of constructing list and linkedlist. just take head as linkedlist and perform the logic and return the sol."
                    },
                    {
                        "username": "njalgo",
                        "content": "On your local computer, just set the Next pointer of the last node to any previous node. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked list problem! A hint: just use 2 pointers 1 fast & 1 slow. It\\'s fine."
                    },
                    {
                        "username": "ybank",
                        "content": "Basically, I came up with an accepted solution without using extra space, but destructed the linked list internally. The way I did was that after traversing the current node but before moving to the next node, I make the next pointer pointing to the current node.\\n\\nThis works fine but resetting the next pointer really annoys me. Other solutions I saw from the discussions either change the next pointers in other ways, or rely on a lucky number for the val of the node.\\n\\nI was wondering if anyone has a non-destructive solution, in the way that it preserves all the next pointers, that uses no extra space?\\n\\nThanks!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/linked-list-cycle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Cycle Finding Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tifv",
                        "content": "Hey, LeetCode, what the hell? I was happily writing Rust solutions for 126 days straight\\u2026"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe LeetCode doesn\\'t want to change the design of struct from using `next: Option<Box<ListNode>>`..."
                    },
                    {
                        "username": "SheekhaJ",
                        "content": "Hi, \\n\\nThe question mentions that pos is used to identify the location where the tail connects to. How is this being used during judging? \\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1573467,
                "content": [
                    {
                        "username": "YananLyu",
                        "content": "if there is cycle, it would meet together,\\nif there is no cycle, it would reach out to tail.\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@codymorazan](/codymorazan) Exactly! I\\'m thinking about the same and looks like it doesn\\'t matter. From the description it\\'s not clear that the cycle can\\'t be between first and last nodes. Or I could understand that moment. \\nCould someone explain? \\n"
                    },
                    {
                        "username": "codymorazan",
                        "content": "Doesn\\'t this only account for cycles that exist either 1 or 2 indices behind the farthest pointer? How does this account for pointer with large spaces in between them, say 1 -> 2 -> 3 -> 4 -> 5 -> 1?"
                    },
                    {
                        "username": "jabberwky",
                        "content": "Where is the `pos` input parameter in the input?\\nThe question is just simply checking if there is a loop in the linked list."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the Tortoise and Hare algorithm\\n\\nhttps://youtu.be/RRSItF-Ts4Q"
                    },
                    {
                        "username": "anon301176",
                        "content": "my solution is failing under this test case: [-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5] very clearly there is a loop in this data, but its telling me i should be returning false. can someone explain this?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "If pos == -1, than it should return false."
                    },
                    {
                        "username": "amiramri",
                        "content": "How did you find that there is a loop? are you saying that base on the existing of the same value more than once? if so you are not correct. we can have different nodes with the same value."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I would not be so sure that there is a cycle. The same value doesn\\'t mean that it is the same Object. \\nI could create two ListNodes like this: \\nvar a = new ListNode(1) and\\nvar b = new ListNode(1), \\nthey will be different Objects, thus a == b will return false (but a.equals(b) may return true, if it\\'s implemented correctly).\\nNow, for this task we are compering reference a and b, not values. Think about it in terms of OOP.  "
                    },
                    {
                        "username": "krenast",
                        "content": "I understand how to answer the question, however I am still struggling how can I perform test case on my computer (construct the list and the linkedlist). Can someone can explain me how to code it ?\\n\\nThanks!"
                    },
                    {
                        "username": "user2903My",
                        "content": "You\\'ve commented part of code in code editor. For this task it\\'s looks like \"\\n* class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\"\\nOnly one that you can do - it\\'s create instances of all ListNode intances and set next property for everyone to next created instance"
                    },
                    {
                        "username": "maheshdeverapu",
                        "content": "[@njalgo](/njalgo) no need of constructing list and linkedlist. just take head as linkedlist and perform the logic and return the sol."
                    },
                    {
                        "username": "njalgo",
                        "content": "On your local computer, just set the Next pointer of the last node to any previous node. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked list problem! A hint: just use 2 pointers 1 fast & 1 slow. It\\'s fine."
                    },
                    {
                        "username": "ybank",
                        "content": "Basically, I came up with an accepted solution without using extra space, but destructed the linked list internally. The way I did was that after traversing the current node but before moving to the next node, I make the next pointer pointing to the current node.\\n\\nThis works fine but resetting the next pointer really annoys me. Other solutions I saw from the discussions either change the next pointers in other ways, or rely on a lucky number for the val of the node.\\n\\nI was wondering if anyone has a non-destructive solution, in the way that it preserves all the next pointers, that uses no extra space?\\n\\nThanks!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/linked-list-cycle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Cycle Finding Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tifv",
                        "content": "Hey, LeetCode, what the hell? I was happily writing Rust solutions for 126 days straight\\u2026"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe LeetCode doesn\\'t want to change the design of struct from using `next: Option<Box<ListNode>>`..."
                    },
                    {
                        "username": "SheekhaJ",
                        "content": "Hi, \\n\\nThe question mentions that pos is used to identify the location where the tail connects to. How is this being used during judging? \\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 2043260,
                "content": [
                    {
                        "username": "YananLyu",
                        "content": "if there is cycle, it would meet together,\\nif there is no cycle, it would reach out to tail.\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@codymorazan](/codymorazan) Exactly! I\\'m thinking about the same and looks like it doesn\\'t matter. From the description it\\'s not clear that the cycle can\\'t be between first and last nodes. Or I could understand that moment. \\nCould someone explain? \\n"
                    },
                    {
                        "username": "codymorazan",
                        "content": "Doesn\\'t this only account for cycles that exist either 1 or 2 indices behind the farthest pointer? How does this account for pointer with large spaces in between them, say 1 -> 2 -> 3 -> 4 -> 5 -> 1?"
                    },
                    {
                        "username": "jabberwky",
                        "content": "Where is the `pos` input parameter in the input?\\nThe question is just simply checking if there is a loop in the linked list."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the Tortoise and Hare algorithm\\n\\nhttps://youtu.be/RRSItF-Ts4Q"
                    },
                    {
                        "username": "anon301176",
                        "content": "my solution is failing under this test case: [-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5] very clearly there is a loop in this data, but its telling me i should be returning false. can someone explain this?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "If pos == -1, than it should return false."
                    },
                    {
                        "username": "amiramri",
                        "content": "How did you find that there is a loop? are you saying that base on the existing of the same value more than once? if so you are not correct. we can have different nodes with the same value."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I would not be so sure that there is a cycle. The same value doesn\\'t mean that it is the same Object. \\nI could create two ListNodes like this: \\nvar a = new ListNode(1) and\\nvar b = new ListNode(1), \\nthey will be different Objects, thus a == b will return false (but a.equals(b) may return true, if it\\'s implemented correctly).\\nNow, for this task we are compering reference a and b, not values. Think about it in terms of OOP.  "
                    },
                    {
                        "username": "krenast",
                        "content": "I understand how to answer the question, however I am still struggling how can I perform test case on my computer (construct the list and the linkedlist). Can someone can explain me how to code it ?\\n\\nThanks!"
                    },
                    {
                        "username": "user2903My",
                        "content": "You\\'ve commented part of code in code editor. For this task it\\'s looks like \"\\n* class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\"\\nOnly one that you can do - it\\'s create instances of all ListNode intances and set next property for everyone to next created instance"
                    },
                    {
                        "username": "maheshdeverapu",
                        "content": "[@njalgo](/njalgo) no need of constructing list and linkedlist. just take head as linkedlist and perform the logic and return the sol."
                    },
                    {
                        "username": "njalgo",
                        "content": "On your local computer, just set the Next pointer of the last node to any previous node. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked list problem! A hint: just use 2 pointers 1 fast & 1 slow. It\\'s fine."
                    },
                    {
                        "username": "ybank",
                        "content": "Basically, I came up with an accepted solution without using extra space, but destructed the linked list internally. The way I did was that after traversing the current node but before moving to the next node, I make the next pointer pointing to the current node.\\n\\nThis works fine but resetting the next pointer really annoys me. Other solutions I saw from the discussions either change the next pointers in other ways, or rely on a lucky number for the val of the node.\\n\\nI was wondering if anyone has a non-destructive solution, in the way that it preserves all the next pointers, that uses no extra space?\\n\\nThanks!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/linked-list-cycle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Cycle Finding Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tifv",
                        "content": "Hey, LeetCode, what the hell? I was happily writing Rust solutions for 126 days straight\\u2026"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe LeetCode doesn\\'t want to change the design of struct from using `next: Option<Box<ListNode>>`..."
                    },
                    {
                        "username": "SheekhaJ",
                        "content": "Hi, \\n\\nThe question mentions that pos is used to identify the location where the tail connects to. How is this being used during judging? \\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1571307,
                "content": [
                    {
                        "username": "YananLyu",
                        "content": "if there is cycle, it would meet together,\\nif there is no cycle, it would reach out to tail.\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@codymorazan](/codymorazan) Exactly! I\\'m thinking about the same and looks like it doesn\\'t matter. From the description it\\'s not clear that the cycle can\\'t be between first and last nodes. Or I could understand that moment. \\nCould someone explain? \\n"
                    },
                    {
                        "username": "codymorazan",
                        "content": "Doesn\\'t this only account for cycles that exist either 1 or 2 indices behind the farthest pointer? How does this account for pointer with large spaces in between them, say 1 -> 2 -> 3 -> 4 -> 5 -> 1?"
                    },
                    {
                        "username": "jabberwky",
                        "content": "Where is the `pos` input parameter in the input?\\nThe question is just simply checking if there is a loop in the linked list."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the Tortoise and Hare algorithm\\n\\nhttps://youtu.be/RRSItF-Ts4Q"
                    },
                    {
                        "username": "anon301176",
                        "content": "my solution is failing under this test case: [-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5] very clearly there is a loop in this data, but its telling me i should be returning false. can someone explain this?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "If pos == -1, than it should return false."
                    },
                    {
                        "username": "amiramri",
                        "content": "How did you find that there is a loop? are you saying that base on the existing of the same value more than once? if so you are not correct. we can have different nodes with the same value."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I would not be so sure that there is a cycle. The same value doesn\\'t mean that it is the same Object. \\nI could create two ListNodes like this: \\nvar a = new ListNode(1) and\\nvar b = new ListNode(1), \\nthey will be different Objects, thus a == b will return false (but a.equals(b) may return true, if it\\'s implemented correctly).\\nNow, for this task we are compering reference a and b, not values. Think about it in terms of OOP.  "
                    },
                    {
                        "username": "krenast",
                        "content": "I understand how to answer the question, however I am still struggling how can I perform test case on my computer (construct the list and the linkedlist). Can someone can explain me how to code it ?\\n\\nThanks!"
                    },
                    {
                        "username": "user2903My",
                        "content": "You\\'ve commented part of code in code editor. For this task it\\'s looks like \"\\n* class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\"\\nOnly one that you can do - it\\'s create instances of all ListNode intances and set next property for everyone to next created instance"
                    },
                    {
                        "username": "maheshdeverapu",
                        "content": "[@njalgo](/njalgo) no need of constructing list and linkedlist. just take head as linkedlist and perform the logic and return the sol."
                    },
                    {
                        "username": "njalgo",
                        "content": "On your local computer, just set the Next pointer of the last node to any previous node. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked list problem! A hint: just use 2 pointers 1 fast & 1 slow. It\\'s fine."
                    },
                    {
                        "username": "ybank",
                        "content": "Basically, I came up with an accepted solution without using extra space, but destructed the linked list internally. The way I did was that after traversing the current node but before moving to the next node, I make the next pointer pointing to the current node.\\n\\nThis works fine but resetting the next pointer really annoys me. Other solutions I saw from the discussions either change the next pointers in other ways, or rely on a lucky number for the val of the node.\\n\\nI was wondering if anyone has a non-destructive solution, in the way that it preserves all the next pointers, that uses no extra space?\\n\\nThanks!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/linked-list-cycle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Cycle Finding Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tifv",
                        "content": "Hey, LeetCode, what the hell? I was happily writing Rust solutions for 126 days straight\\u2026"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe LeetCode doesn\\'t want to change the design of struct from using `next: Option<Box<ListNode>>`..."
                    },
                    {
                        "username": "SheekhaJ",
                        "content": "Hi, \\n\\nThe question mentions that pos is used to identify the location where the tail connects to. How is this being used during judging? \\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1566212,
                "content": [
                    {
                        "username": "YananLyu",
                        "content": "if there is cycle, it would meet together,\\nif there is no cycle, it would reach out to tail.\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@codymorazan](/codymorazan) Exactly! I\\'m thinking about the same and looks like it doesn\\'t matter. From the description it\\'s not clear that the cycle can\\'t be between first and last nodes. Or I could understand that moment. \\nCould someone explain? \\n"
                    },
                    {
                        "username": "codymorazan",
                        "content": "Doesn\\'t this only account for cycles that exist either 1 or 2 indices behind the farthest pointer? How does this account for pointer with large spaces in between them, say 1 -> 2 -> 3 -> 4 -> 5 -> 1?"
                    },
                    {
                        "username": "jabberwky",
                        "content": "Where is the `pos` input parameter in the input?\\nThe question is just simply checking if there is a loop in the linked list."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the Tortoise and Hare algorithm\\n\\nhttps://youtu.be/RRSItF-Ts4Q"
                    },
                    {
                        "username": "anon301176",
                        "content": "my solution is failing under this test case: [-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5] very clearly there is a loop in this data, but its telling me i should be returning false. can someone explain this?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "If pos == -1, than it should return false."
                    },
                    {
                        "username": "amiramri",
                        "content": "How did you find that there is a loop? are you saying that base on the existing of the same value more than once? if so you are not correct. we can have different nodes with the same value."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I would not be so sure that there is a cycle. The same value doesn\\'t mean that it is the same Object. \\nI could create two ListNodes like this: \\nvar a = new ListNode(1) and\\nvar b = new ListNode(1), \\nthey will be different Objects, thus a == b will return false (but a.equals(b) may return true, if it\\'s implemented correctly).\\nNow, for this task we are compering reference a and b, not values. Think about it in terms of OOP.  "
                    },
                    {
                        "username": "krenast",
                        "content": "I understand how to answer the question, however I am still struggling how can I perform test case on my computer (construct the list and the linkedlist). Can someone can explain me how to code it ?\\n\\nThanks!"
                    },
                    {
                        "username": "user2903My",
                        "content": "You\\'ve commented part of code in code editor. For this task it\\'s looks like \"\\n* class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\"\\nOnly one that you can do - it\\'s create instances of all ListNode intances and set next property for everyone to next created instance"
                    },
                    {
                        "username": "maheshdeverapu",
                        "content": "[@njalgo](/njalgo) no need of constructing list and linkedlist. just take head as linkedlist and perform the logic and return the sol."
                    },
                    {
                        "username": "njalgo",
                        "content": "On your local computer, just set the Next pointer of the last node to any previous node. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked list problem! A hint: just use 2 pointers 1 fast & 1 slow. It\\'s fine."
                    },
                    {
                        "username": "ybank",
                        "content": "Basically, I came up with an accepted solution without using extra space, but destructed the linked list internally. The way I did was that after traversing the current node but before moving to the next node, I make the next pointer pointing to the current node.\\n\\nThis works fine but resetting the next pointer really annoys me. Other solutions I saw from the discussions either change the next pointers in other ways, or rely on a lucky number for the val of the node.\\n\\nI was wondering if anyone has a non-destructive solution, in the way that it preserves all the next pointers, that uses no extra space?\\n\\nThanks!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/linked-list-cycle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Cycle Finding Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tifv",
                        "content": "Hey, LeetCode, what the hell? I was happily writing Rust solutions for 126 days straight\\u2026"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe LeetCode doesn\\'t want to change the design of struct from using `next: Option<Box<ListNode>>`..."
                    },
                    {
                        "username": "SheekhaJ",
                        "content": "Hi, \\n\\nThe question mentions that pos is used to identify the location where the tail connects to. How is this being used during judging? \\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 2043317,
                "content": [
                    {
                        "username": "YananLyu",
                        "content": "if there is cycle, it would meet together,\\nif there is no cycle, it would reach out to tail.\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@codymorazan](/codymorazan) Exactly! I\\'m thinking about the same and looks like it doesn\\'t matter. From the description it\\'s not clear that the cycle can\\'t be between first and last nodes. Or I could understand that moment. \\nCould someone explain? \\n"
                    },
                    {
                        "username": "codymorazan",
                        "content": "Doesn\\'t this only account for cycles that exist either 1 or 2 indices behind the farthest pointer? How does this account for pointer with large spaces in between them, say 1 -> 2 -> 3 -> 4 -> 5 -> 1?"
                    },
                    {
                        "username": "jabberwky",
                        "content": "Where is the `pos` input parameter in the input?\\nThe question is just simply checking if there is a loop in the linked list."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the Tortoise and Hare algorithm\\n\\nhttps://youtu.be/RRSItF-Ts4Q"
                    },
                    {
                        "username": "anon301176",
                        "content": "my solution is failing under this test case: [-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5] very clearly there is a loop in this data, but its telling me i should be returning false. can someone explain this?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "If pos == -1, than it should return false."
                    },
                    {
                        "username": "amiramri",
                        "content": "How did you find that there is a loop? are you saying that base on the existing of the same value more than once? if so you are not correct. we can have different nodes with the same value."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I would not be so sure that there is a cycle. The same value doesn\\'t mean that it is the same Object. \\nI could create two ListNodes like this: \\nvar a = new ListNode(1) and\\nvar b = new ListNode(1), \\nthey will be different Objects, thus a == b will return false (but a.equals(b) may return true, if it\\'s implemented correctly).\\nNow, for this task we are compering reference a and b, not values. Think about it in terms of OOP.  "
                    },
                    {
                        "username": "krenast",
                        "content": "I understand how to answer the question, however I am still struggling how can I perform test case on my computer (construct the list and the linkedlist). Can someone can explain me how to code it ?\\n\\nThanks!"
                    },
                    {
                        "username": "user2903My",
                        "content": "You\\'ve commented part of code in code editor. For this task it\\'s looks like \"\\n* class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\"\\nOnly one that you can do - it\\'s create instances of all ListNode intances and set next property for everyone to next created instance"
                    },
                    {
                        "username": "maheshdeverapu",
                        "content": "[@njalgo](/njalgo) no need of constructing list and linkedlist. just take head as linkedlist and perform the logic and return the sol."
                    },
                    {
                        "username": "njalgo",
                        "content": "On your local computer, just set the Next pointer of the last node to any previous node. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked list problem! A hint: just use 2 pointers 1 fast & 1 slow. It\\'s fine."
                    },
                    {
                        "username": "ybank",
                        "content": "Basically, I came up with an accepted solution without using extra space, but destructed the linked list internally. The way I did was that after traversing the current node but before moving to the next node, I make the next pointer pointing to the current node.\\n\\nThis works fine but resetting the next pointer really annoys me. Other solutions I saw from the discussions either change the next pointers in other ways, or rely on a lucky number for the val of the node.\\n\\nI was wondering if anyone has a non-destructive solution, in the way that it preserves all the next pointers, that uses no extra space?\\n\\nThanks!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/linked-list-cycle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Cycle Finding Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tifv",
                        "content": "Hey, LeetCode, what the hell? I was happily writing Rust solutions for 126 days straight\\u2026"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe LeetCode doesn\\'t want to change the design of struct from using `next: Option<Box<ListNode>>`..."
                    },
                    {
                        "username": "SheekhaJ",
                        "content": "Hi, \\n\\nThe question mentions that pos is used to identify the location where the tail connects to. How is this being used during judging? \\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1569830,
                "content": [
                    {
                        "username": "YananLyu",
                        "content": "if there is cycle, it would meet together,\\nif there is no cycle, it would reach out to tail.\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@codymorazan](/codymorazan) Exactly! I\\'m thinking about the same and looks like it doesn\\'t matter. From the description it\\'s not clear that the cycle can\\'t be between first and last nodes. Or I could understand that moment. \\nCould someone explain? \\n"
                    },
                    {
                        "username": "codymorazan",
                        "content": "Doesn\\'t this only account for cycles that exist either 1 or 2 indices behind the farthest pointer? How does this account for pointer with large spaces in between them, say 1 -> 2 -> 3 -> 4 -> 5 -> 1?"
                    },
                    {
                        "username": "jabberwky",
                        "content": "Where is the `pos` input parameter in the input?\\nThe question is just simply checking if there is a loop in the linked list."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the Tortoise and Hare algorithm\\n\\nhttps://youtu.be/RRSItF-Ts4Q"
                    },
                    {
                        "username": "anon301176",
                        "content": "my solution is failing under this test case: [-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5] very clearly there is a loop in this data, but its telling me i should be returning false. can someone explain this?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "If pos == -1, than it should return false."
                    },
                    {
                        "username": "amiramri",
                        "content": "How did you find that there is a loop? are you saying that base on the existing of the same value more than once? if so you are not correct. we can have different nodes with the same value."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I would not be so sure that there is a cycle. The same value doesn\\'t mean that it is the same Object. \\nI could create two ListNodes like this: \\nvar a = new ListNode(1) and\\nvar b = new ListNode(1), \\nthey will be different Objects, thus a == b will return false (but a.equals(b) may return true, if it\\'s implemented correctly).\\nNow, for this task we are compering reference a and b, not values. Think about it in terms of OOP.  "
                    },
                    {
                        "username": "krenast",
                        "content": "I understand how to answer the question, however I am still struggling how can I perform test case on my computer (construct the list and the linkedlist). Can someone can explain me how to code it ?\\n\\nThanks!"
                    },
                    {
                        "username": "user2903My",
                        "content": "You\\'ve commented part of code in code editor. For this task it\\'s looks like \"\\n* class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\"\\nOnly one that you can do - it\\'s create instances of all ListNode intances and set next property for everyone to next created instance"
                    },
                    {
                        "username": "maheshdeverapu",
                        "content": "[@njalgo](/njalgo) no need of constructing list and linkedlist. just take head as linkedlist and perform the logic and return the sol."
                    },
                    {
                        "username": "njalgo",
                        "content": "On your local computer, just set the Next pointer of the last node to any previous node. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked list problem! A hint: just use 2 pointers 1 fast & 1 slow. It\\'s fine."
                    },
                    {
                        "username": "ybank",
                        "content": "Basically, I came up with an accepted solution without using extra space, but destructed the linked list internally. The way I did was that after traversing the current node but before moving to the next node, I make the next pointer pointing to the current node.\\n\\nThis works fine but resetting the next pointer really annoys me. Other solutions I saw from the discussions either change the next pointers in other ways, or rely on a lucky number for the val of the node.\\n\\nI was wondering if anyone has a non-destructive solution, in the way that it preserves all the next pointers, that uses no extra space?\\n\\nThanks!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/linked-list-cycle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Cycle Finding Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tifv",
                        "content": "Hey, LeetCode, what the hell? I was happily writing Rust solutions for 126 days straight\\u2026"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe LeetCode doesn\\'t want to change the design of struct from using `next: Option<Box<ListNode>>`..."
                    },
                    {
                        "username": "SheekhaJ",
                        "content": "Hi, \\n\\nThe question mentions that pos is used to identify the location where the tail connects to. How is this being used during judging? \\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1569542,
                "content": [
                    {
                        "username": "tanghao",
                        "content": "Even though my code is correct the test case [3,2,0,-4] 1 always output False. Also where is python3 option for this question?"
                    },
                    {
                        "username": "rkaldawy",
                        "content": "Hello, when I try to submit a solution for this problem in C, I get double free/corruption errors. This is nonsensical, since my solution never malloc\\'s or frees. I suspect that the solution tester for C is broken. "
                    },
                    {
                        "username": "Ishika_07",
                        "content": "I was out of practice for some time, and have been attempting leetcode daily problems for past one month and was not able to solve the problems on my own but finally yesterday and today I'm just glad that I finally was able to solve the problems on my own (although they are not of much difficulty, it does help boost confidence)\nIf you are reading this post, I hope you are able to solve the daily problems by yourself and if not keep working hard. ALL THE BEST!! "
                    },
                    {
                        "username": "i_am_guts",
                        "content": "the problem was very interesting and the question does not ask you to find the head of the circular list , just you have to confirm if it has a cycle or not , the  `pos` variable here is non of anyone's business , Hint - Floyd's Cycle Detection Algorithm "
                    },
                    {
                        "username": "4ndr01d",
                        "content": "terrible description\\n"
                    },
                    {
                        "username": "yliang12",
                        "content": "I am not sure if it is acceptable to modify the linkedlist, but it uses space O(1). After visited the node, make the node point to itself, so that it can be recognized that it is visited."
                    },
                    {
                        "username": "nitin135",
                        "content": "Where the hell is \\'Run Code\\' button in this problem ?"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "in console"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I don't understand this question. From some answers, I find maybe only 1->2->3->1 exists a cycle. 1->2->3->2 doesn't exist cycle????\\nReally thx yr help"
                    },
                    {
                        "username": "Darth-InVader15",
                        "content": "This is the first question I solved on Leetcode, 2 years back. I guess my life\\'s also a cycle :)"
                    },
                    {
                        "username": "Prikers",
                        "content": "Do you think a recruter would find this solution amusing? \\uD83E\\uDD23\\n ```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return head.__repr__() == \\'Error - Found cycle in the ListNode\\'\\n``` "
                    },
                    {
                        "username": "arshita129",
                        "content": "Instantly Hired!!! \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sergei99",
                        "content": "I think this should be shown to an IT person, not HR. At least, if they give you a boot, you would know that you have successfully evaded a dark place where nobody is ever smiling."
                    }
                ]
            },
            {
                "id": 1572169,
                "content": [
                    {
                        "username": "tanghao",
                        "content": "Even though my code is correct the test case [3,2,0,-4] 1 always output False. Also where is python3 option for this question?"
                    },
                    {
                        "username": "rkaldawy",
                        "content": "Hello, when I try to submit a solution for this problem in C, I get double free/corruption errors. This is nonsensical, since my solution never malloc\\'s or frees. I suspect that the solution tester for C is broken. "
                    },
                    {
                        "username": "Ishika_07",
                        "content": "I was out of practice for some time, and have been attempting leetcode daily problems for past one month and was not able to solve the problems on my own but finally yesterday and today I'm just glad that I finally was able to solve the problems on my own (although they are not of much difficulty, it does help boost confidence)\nIf you are reading this post, I hope you are able to solve the daily problems by yourself and if not keep working hard. ALL THE BEST!! "
                    },
                    {
                        "username": "i_am_guts",
                        "content": "the problem was very interesting and the question does not ask you to find the head of the circular list , just you have to confirm if it has a cycle or not , the  `pos` variable here is non of anyone's business , Hint - Floyd's Cycle Detection Algorithm "
                    },
                    {
                        "username": "4ndr01d",
                        "content": "terrible description\\n"
                    },
                    {
                        "username": "yliang12",
                        "content": "I am not sure if it is acceptable to modify the linkedlist, but it uses space O(1). After visited the node, make the node point to itself, so that it can be recognized that it is visited."
                    },
                    {
                        "username": "nitin135",
                        "content": "Where the hell is \\'Run Code\\' button in this problem ?"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "in console"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I don't understand this question. From some answers, I find maybe only 1->2->3->1 exists a cycle. 1->2->3->2 doesn't exist cycle????\\nReally thx yr help"
                    },
                    {
                        "username": "Darth-InVader15",
                        "content": "This is the first question I solved on Leetcode, 2 years back. I guess my life\\'s also a cycle :)"
                    },
                    {
                        "username": "Prikers",
                        "content": "Do you think a recruter would find this solution amusing? \\uD83E\\uDD23\\n ```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return head.__repr__() == \\'Error - Found cycle in the ListNode\\'\\n``` "
                    },
                    {
                        "username": "arshita129",
                        "content": "Instantly Hired!!! \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sergei99",
                        "content": "I think this should be shown to an IT person, not HR. At least, if they give you a boot, you would know that you have successfully evaded a dark place where nobody is ever smiling."
                    }
                ]
            },
            {
                "id": 2043398,
                "content": [
                    {
                        "username": "tanghao",
                        "content": "Even though my code is correct the test case [3,2,0,-4] 1 always output False. Also where is python3 option for this question?"
                    },
                    {
                        "username": "rkaldawy",
                        "content": "Hello, when I try to submit a solution for this problem in C, I get double free/corruption errors. This is nonsensical, since my solution never malloc\\'s or frees. I suspect that the solution tester for C is broken. "
                    },
                    {
                        "username": "Ishika_07",
                        "content": "I was out of practice for some time, and have been attempting leetcode daily problems for past one month and was not able to solve the problems on my own but finally yesterday and today I'm just glad that I finally was able to solve the problems on my own (although they are not of much difficulty, it does help boost confidence)\nIf you are reading this post, I hope you are able to solve the daily problems by yourself and if not keep working hard. ALL THE BEST!! "
                    },
                    {
                        "username": "i_am_guts",
                        "content": "the problem was very interesting and the question does not ask you to find the head of the circular list , just you have to confirm if it has a cycle or not , the  `pos` variable here is non of anyone's business , Hint - Floyd's Cycle Detection Algorithm "
                    },
                    {
                        "username": "4ndr01d",
                        "content": "terrible description\\n"
                    },
                    {
                        "username": "yliang12",
                        "content": "I am not sure if it is acceptable to modify the linkedlist, but it uses space O(1). After visited the node, make the node point to itself, so that it can be recognized that it is visited."
                    },
                    {
                        "username": "nitin135",
                        "content": "Where the hell is \\'Run Code\\' button in this problem ?"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "in console"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I don't understand this question. From some answers, I find maybe only 1->2->3->1 exists a cycle. 1->2->3->2 doesn't exist cycle????\\nReally thx yr help"
                    },
                    {
                        "username": "Darth-InVader15",
                        "content": "This is the first question I solved on Leetcode, 2 years back. I guess my life\\'s also a cycle :)"
                    },
                    {
                        "username": "Prikers",
                        "content": "Do you think a recruter would find this solution amusing? \\uD83E\\uDD23\\n ```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return head.__repr__() == \\'Error - Found cycle in the ListNode\\'\\n``` "
                    },
                    {
                        "username": "arshita129",
                        "content": "Instantly Hired!!! \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sergei99",
                        "content": "I think this should be shown to an IT person, not HR. At least, if they give you a boot, you would know that you have successfully evaded a dark place where nobody is ever smiling."
                    }
                ]
            },
            {
                "id": 2002631,
                "content": [
                    {
                        "username": "tanghao",
                        "content": "Even though my code is correct the test case [3,2,0,-4] 1 always output False. Also where is python3 option for this question?"
                    },
                    {
                        "username": "rkaldawy",
                        "content": "Hello, when I try to submit a solution for this problem in C, I get double free/corruption errors. This is nonsensical, since my solution never malloc\\'s or frees. I suspect that the solution tester for C is broken. "
                    },
                    {
                        "username": "Ishika_07",
                        "content": "I was out of practice for some time, and have been attempting leetcode daily problems for past one month and was not able to solve the problems on my own but finally yesterday and today I'm just glad that I finally was able to solve the problems on my own (although they are not of much difficulty, it does help boost confidence)\nIf you are reading this post, I hope you are able to solve the daily problems by yourself and if not keep working hard. ALL THE BEST!! "
                    },
                    {
                        "username": "i_am_guts",
                        "content": "the problem was very interesting and the question does not ask you to find the head of the circular list , just you have to confirm if it has a cycle or not , the  `pos` variable here is non of anyone's business , Hint - Floyd's Cycle Detection Algorithm "
                    },
                    {
                        "username": "4ndr01d",
                        "content": "terrible description\\n"
                    },
                    {
                        "username": "yliang12",
                        "content": "I am not sure if it is acceptable to modify the linkedlist, but it uses space O(1). After visited the node, make the node point to itself, so that it can be recognized that it is visited."
                    },
                    {
                        "username": "nitin135",
                        "content": "Where the hell is \\'Run Code\\' button in this problem ?"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "in console"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I don't understand this question. From some answers, I find maybe only 1->2->3->1 exists a cycle. 1->2->3->2 doesn't exist cycle????\\nReally thx yr help"
                    },
                    {
                        "username": "Darth-InVader15",
                        "content": "This is the first question I solved on Leetcode, 2 years back. I guess my life\\'s also a cycle :)"
                    },
                    {
                        "username": "Prikers",
                        "content": "Do you think a recruter would find this solution amusing? \\uD83E\\uDD23\\n ```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return head.__repr__() == \\'Error - Found cycle in the ListNode\\'\\n``` "
                    },
                    {
                        "username": "arshita129",
                        "content": "Instantly Hired!!! \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sergei99",
                        "content": "I think this should be shown to an IT person, not HR. At least, if they give you a boot, you would know that you have successfully evaded a dark place where nobody is ever smiling."
                    }
                ]
            },
            {
                "id": 2001886,
                "content": [
                    {
                        "username": "tanghao",
                        "content": "Even though my code is correct the test case [3,2,0,-4] 1 always output False. Also where is python3 option for this question?"
                    },
                    {
                        "username": "rkaldawy",
                        "content": "Hello, when I try to submit a solution for this problem in C, I get double free/corruption errors. This is nonsensical, since my solution never malloc\\'s or frees. I suspect that the solution tester for C is broken. "
                    },
                    {
                        "username": "Ishika_07",
                        "content": "I was out of practice for some time, and have been attempting leetcode daily problems for past one month and was not able to solve the problems on my own but finally yesterday and today I'm just glad that I finally was able to solve the problems on my own (although they are not of much difficulty, it does help boost confidence)\nIf you are reading this post, I hope you are able to solve the daily problems by yourself and if not keep working hard. ALL THE BEST!! "
                    },
                    {
                        "username": "i_am_guts",
                        "content": "the problem was very interesting and the question does not ask you to find the head of the circular list , just you have to confirm if it has a cycle or not , the  `pos` variable here is non of anyone's business , Hint - Floyd's Cycle Detection Algorithm "
                    },
                    {
                        "username": "4ndr01d",
                        "content": "terrible description\\n"
                    },
                    {
                        "username": "yliang12",
                        "content": "I am not sure if it is acceptable to modify the linkedlist, but it uses space O(1). After visited the node, make the node point to itself, so that it can be recognized that it is visited."
                    },
                    {
                        "username": "nitin135",
                        "content": "Where the hell is \\'Run Code\\' button in this problem ?"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "in console"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I don't understand this question. From some answers, I find maybe only 1->2->3->1 exists a cycle. 1->2->3->2 doesn't exist cycle????\\nReally thx yr help"
                    },
                    {
                        "username": "Darth-InVader15",
                        "content": "This is the first question I solved on Leetcode, 2 years back. I guess my life\\'s also a cycle :)"
                    },
                    {
                        "username": "Prikers",
                        "content": "Do you think a recruter would find this solution amusing? \\uD83E\\uDD23\\n ```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return head.__repr__() == \\'Error - Found cycle in the ListNode\\'\\n``` "
                    },
                    {
                        "username": "arshita129",
                        "content": "Instantly Hired!!! \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sergei99",
                        "content": "I think this should be shown to an IT person, not HR. At least, if they give you a boot, you would know that you have successfully evaded a dark place where nobody is ever smiling."
                    }
                ]
            },
            {
                "id": 1572012,
                "content": [
                    {
                        "username": "tanghao",
                        "content": "Even though my code is correct the test case [3,2,0,-4] 1 always output False. Also where is python3 option for this question?"
                    },
                    {
                        "username": "rkaldawy",
                        "content": "Hello, when I try to submit a solution for this problem in C, I get double free/corruption errors. This is nonsensical, since my solution never malloc\\'s or frees. I suspect that the solution tester for C is broken. "
                    },
                    {
                        "username": "Ishika_07",
                        "content": "I was out of practice for some time, and have been attempting leetcode daily problems for past one month and was not able to solve the problems on my own but finally yesterday and today I'm just glad that I finally was able to solve the problems on my own (although they are not of much difficulty, it does help boost confidence)\nIf you are reading this post, I hope you are able to solve the daily problems by yourself and if not keep working hard. ALL THE BEST!! "
                    },
                    {
                        "username": "i_am_guts",
                        "content": "the problem was very interesting and the question does not ask you to find the head of the circular list , just you have to confirm if it has a cycle or not , the  `pos` variable here is non of anyone's business , Hint - Floyd's Cycle Detection Algorithm "
                    },
                    {
                        "username": "4ndr01d",
                        "content": "terrible description\\n"
                    },
                    {
                        "username": "yliang12",
                        "content": "I am not sure if it is acceptable to modify the linkedlist, but it uses space O(1). After visited the node, make the node point to itself, so that it can be recognized that it is visited."
                    },
                    {
                        "username": "nitin135",
                        "content": "Where the hell is \\'Run Code\\' button in this problem ?"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "in console"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I don't understand this question. From some answers, I find maybe only 1->2->3->1 exists a cycle. 1->2->3->2 doesn't exist cycle????\\nReally thx yr help"
                    },
                    {
                        "username": "Darth-InVader15",
                        "content": "This is the first question I solved on Leetcode, 2 years back. I guess my life\\'s also a cycle :)"
                    },
                    {
                        "username": "Prikers",
                        "content": "Do you think a recruter would find this solution amusing? \\uD83E\\uDD23\\n ```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return head.__repr__() == \\'Error - Found cycle in the ListNode\\'\\n``` "
                    },
                    {
                        "username": "arshita129",
                        "content": "Instantly Hired!!! \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sergei99",
                        "content": "I think this should be shown to an IT person, not HR. At least, if they give you a boot, you would know that you have successfully evaded a dark place where nobody is ever smiling."
                    }
                ]
            },
            {
                "id": 1567303,
                "content": [
                    {
                        "username": "tanghao",
                        "content": "Even though my code is correct the test case [3,2,0,-4] 1 always output False. Also where is python3 option for this question?"
                    },
                    {
                        "username": "rkaldawy",
                        "content": "Hello, when I try to submit a solution for this problem in C, I get double free/corruption errors. This is nonsensical, since my solution never malloc\\'s or frees. I suspect that the solution tester for C is broken. "
                    },
                    {
                        "username": "Ishika_07",
                        "content": "I was out of practice for some time, and have been attempting leetcode daily problems for past one month and was not able to solve the problems on my own but finally yesterday and today I'm just glad that I finally was able to solve the problems on my own (although they are not of much difficulty, it does help boost confidence)\nIf you are reading this post, I hope you are able to solve the daily problems by yourself and if not keep working hard. ALL THE BEST!! "
                    },
                    {
                        "username": "i_am_guts",
                        "content": "the problem was very interesting and the question does not ask you to find the head of the circular list , just you have to confirm if it has a cycle or not , the  `pos` variable here is non of anyone's business , Hint - Floyd's Cycle Detection Algorithm "
                    },
                    {
                        "username": "4ndr01d",
                        "content": "terrible description\\n"
                    },
                    {
                        "username": "yliang12",
                        "content": "I am not sure if it is acceptable to modify the linkedlist, but it uses space O(1). After visited the node, make the node point to itself, so that it can be recognized that it is visited."
                    },
                    {
                        "username": "nitin135",
                        "content": "Where the hell is \\'Run Code\\' button in this problem ?"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "in console"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I don't understand this question. From some answers, I find maybe only 1->2->3->1 exists a cycle. 1->2->3->2 doesn't exist cycle????\\nReally thx yr help"
                    },
                    {
                        "username": "Darth-InVader15",
                        "content": "This is the first question I solved on Leetcode, 2 years back. I guess my life\\'s also a cycle :)"
                    },
                    {
                        "username": "Prikers",
                        "content": "Do you think a recruter would find this solution amusing? \\uD83E\\uDD23\\n ```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return head.__repr__() == \\'Error - Found cycle in the ListNode\\'\\n``` "
                    },
                    {
                        "username": "arshita129",
                        "content": "Instantly Hired!!! \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sergei99",
                        "content": "I think this should be shown to an IT person, not HR. At least, if they give you a boot, you would know that you have successfully evaded a dark place where nobody is ever smiling."
                    }
                ]
            },
            {
                "id": 1568965,
                "content": [
                    {
                        "username": "tanghao",
                        "content": "Even though my code is correct the test case [3,2,0,-4] 1 always output False. Also where is python3 option for this question?"
                    },
                    {
                        "username": "rkaldawy",
                        "content": "Hello, when I try to submit a solution for this problem in C, I get double free/corruption errors. This is nonsensical, since my solution never malloc\\'s or frees. I suspect that the solution tester for C is broken. "
                    },
                    {
                        "username": "Ishika_07",
                        "content": "I was out of practice for some time, and have been attempting leetcode daily problems for past one month and was not able to solve the problems on my own but finally yesterday and today I'm just glad that I finally was able to solve the problems on my own (although they are not of much difficulty, it does help boost confidence)\nIf you are reading this post, I hope you are able to solve the daily problems by yourself and if not keep working hard. ALL THE BEST!! "
                    },
                    {
                        "username": "i_am_guts",
                        "content": "the problem was very interesting and the question does not ask you to find the head of the circular list , just you have to confirm if it has a cycle or not , the  `pos` variable here is non of anyone's business , Hint - Floyd's Cycle Detection Algorithm "
                    },
                    {
                        "username": "4ndr01d",
                        "content": "terrible description\\n"
                    },
                    {
                        "username": "yliang12",
                        "content": "I am not sure if it is acceptable to modify the linkedlist, but it uses space O(1). After visited the node, make the node point to itself, so that it can be recognized that it is visited."
                    },
                    {
                        "username": "nitin135",
                        "content": "Where the hell is \\'Run Code\\' button in this problem ?"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "in console"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I don't understand this question. From some answers, I find maybe only 1->2->3->1 exists a cycle. 1->2->3->2 doesn't exist cycle????\\nReally thx yr help"
                    },
                    {
                        "username": "Darth-InVader15",
                        "content": "This is the first question I solved on Leetcode, 2 years back. I guess my life\\'s also a cycle :)"
                    },
                    {
                        "username": "Prikers",
                        "content": "Do you think a recruter would find this solution amusing? \\uD83E\\uDD23\\n ```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return head.__repr__() == \\'Error - Found cycle in the ListNode\\'\\n``` "
                    },
                    {
                        "username": "arshita129",
                        "content": "Instantly Hired!!! \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sergei99",
                        "content": "I think this should be shown to an IT person, not HR. At least, if they give you a boot, you would know that you have successfully evaded a dark place where nobody is ever smiling."
                    }
                ]
            },
            {
                "id": 2043846,
                "content": [
                    {
                        "username": "tanghao",
                        "content": "Even though my code is correct the test case [3,2,0,-4] 1 always output False. Also where is python3 option for this question?"
                    },
                    {
                        "username": "rkaldawy",
                        "content": "Hello, when I try to submit a solution for this problem in C, I get double free/corruption errors. This is nonsensical, since my solution never malloc\\'s or frees. I suspect that the solution tester for C is broken. "
                    },
                    {
                        "username": "Ishika_07",
                        "content": "I was out of practice for some time, and have been attempting leetcode daily problems for past one month and was not able to solve the problems on my own but finally yesterday and today I'm just glad that I finally was able to solve the problems on my own (although they are not of much difficulty, it does help boost confidence)\nIf you are reading this post, I hope you are able to solve the daily problems by yourself and if not keep working hard. ALL THE BEST!! "
                    },
                    {
                        "username": "i_am_guts",
                        "content": "the problem was very interesting and the question does not ask you to find the head of the circular list , just you have to confirm if it has a cycle or not , the  `pos` variable here is non of anyone's business , Hint - Floyd's Cycle Detection Algorithm "
                    },
                    {
                        "username": "4ndr01d",
                        "content": "terrible description\\n"
                    },
                    {
                        "username": "yliang12",
                        "content": "I am not sure if it is acceptable to modify the linkedlist, but it uses space O(1). After visited the node, make the node point to itself, so that it can be recognized that it is visited."
                    },
                    {
                        "username": "nitin135",
                        "content": "Where the hell is \\'Run Code\\' button in this problem ?"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "in console"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I don't understand this question. From some answers, I find maybe only 1->2->3->1 exists a cycle. 1->2->3->2 doesn't exist cycle????\\nReally thx yr help"
                    },
                    {
                        "username": "Darth-InVader15",
                        "content": "This is the first question I solved on Leetcode, 2 years back. I guess my life\\'s also a cycle :)"
                    },
                    {
                        "username": "Prikers",
                        "content": "Do you think a recruter would find this solution amusing? \\uD83E\\uDD23\\n ```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return head.__repr__() == \\'Error - Found cycle in the ListNode\\'\\n``` "
                    },
                    {
                        "username": "arshita129",
                        "content": "Instantly Hired!!! \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sergei99",
                        "content": "I think this should be shown to an IT person, not HR. At least, if they give you a boot, you would know that you have successfully evaded a dark place where nobody is ever smiling."
                    }
                ]
            },
            {
                "id": 2043769,
                "content": [
                    {
                        "username": "tanghao",
                        "content": "Even though my code is correct the test case [3,2,0,-4] 1 always output False. Also where is python3 option for this question?"
                    },
                    {
                        "username": "rkaldawy",
                        "content": "Hello, when I try to submit a solution for this problem in C, I get double free/corruption errors. This is nonsensical, since my solution never malloc\\'s or frees. I suspect that the solution tester for C is broken. "
                    },
                    {
                        "username": "Ishika_07",
                        "content": "I was out of practice for some time, and have been attempting leetcode daily problems for past one month and was not able to solve the problems on my own but finally yesterday and today I'm just glad that I finally was able to solve the problems on my own (although they are not of much difficulty, it does help boost confidence)\nIf you are reading this post, I hope you are able to solve the daily problems by yourself and if not keep working hard. ALL THE BEST!! "
                    },
                    {
                        "username": "i_am_guts",
                        "content": "the problem was very interesting and the question does not ask you to find the head of the circular list , just you have to confirm if it has a cycle or not , the  `pos` variable here is non of anyone's business , Hint - Floyd's Cycle Detection Algorithm "
                    },
                    {
                        "username": "4ndr01d",
                        "content": "terrible description\\n"
                    },
                    {
                        "username": "yliang12",
                        "content": "I am not sure if it is acceptable to modify the linkedlist, but it uses space O(1). After visited the node, make the node point to itself, so that it can be recognized that it is visited."
                    },
                    {
                        "username": "nitin135",
                        "content": "Where the hell is \\'Run Code\\' button in this problem ?"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "in console"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I don't understand this question. From some answers, I find maybe only 1->2->3->1 exists a cycle. 1->2->3->2 doesn't exist cycle????\\nReally thx yr help"
                    },
                    {
                        "username": "Darth-InVader15",
                        "content": "This is the first question I solved on Leetcode, 2 years back. I guess my life\\'s also a cycle :)"
                    },
                    {
                        "username": "Prikers",
                        "content": "Do you think a recruter would find this solution amusing? \\uD83E\\uDD23\\n ```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return head.__repr__() == \\'Error - Found cycle in the ListNode\\'\\n``` "
                    },
                    {
                        "username": "arshita129",
                        "content": "Instantly Hired!!! \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sergei99",
                        "content": "I think this should be shown to an IT person, not HR. At least, if they give you a boot, you would know that you have successfully evaded a dark place where nobody is ever smiling."
                    }
                ]
            },
            {
                "id": 2043369,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Try using two pointers that move at different speeds. If either of them can get to a null then it\\'s obvious there isn\\'t a cycle. But what happens if there is a cycle? Eventually the faster pointer will make a full lap and be equal to the slow pointer. Therefore if during the traversal the faster pointer == slower pointer, you can return true."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Nodes that contains in my life cycle are eat,sleep..repeat :("
                    },
                    {
                        "username": "HikuMai",
                        "content": "Leetcode has mercy on me this time :))"
                    },
                    {
                        "username": "harshit1271gupta",
                        "content": " public boolean hasCycle(ListNode head) {\\n    // apparoch 1   using hashset cuz if it store same location that means there is a cycle \\n    // HashSet<ListNode> map = new HashSet<>();\\n    //     ListNode temp = head;\\n    //     while (temp != null) {\\n    //         if (map.contains(temp)) {\\n    //             return true;\\n    //         }else{\\n    //             map.add(temp);\\n    //         }\\n    //         temp = temp.next;\\n    //     }\\n    //     return false;\\n    // }\\n   // apparoch 2    space complexity 0(1)\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==null || head.next==null){\\n        return false;\\n    }\\n    while(fast!=null){\\n\\n        if(slow==null)return false;\\n        if(fast.next==null)return false;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow==fast)return true;\\n    }\\n    return false;"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "what is the use of mentioning the pos +  "
                    },
                    {
                        "username": "soukumpan",
                        "content": "ignore that "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "Here the set logic will not work because node-values may be repeated means for ex 2->4->3->7->4->6->null  then by set logic it will return true but actually it\\'s not containing any cycle so we need to use another logic for detect cycle ."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Why not? You just need to use node1 == node2 instead of node1.val == node2.val, means we check if a node actually refers to the same rather than checking a val. Works for Java.\\nBtw, it\\'s not necessary to use HashSet (or HashMap), it will work with simple list too, however Set seems to be faster.   "
                    },
                    {
                        "username": "ali__code",
                        "content": "how to use pos when it is not in parameter."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\n\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/3024832/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "knightryder098",
                        "content": "It\\'s given that POS is the valid position in the linked list. So if we just comapre it with 0, it should give us whether cycle is present or not. \\n\\nAm i am wrong? Plz explain . Thank You"
                    },
                    {
                        "username": "yazanmaini",
                        "content": "![image](https://assets.leetcode.com/users/images/e4307283-b136-4212-babe-2f7dd6051505_1596530623.2097838.png)\\n"
                    }
                ]
            },
            {
                "id": 2043282,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Try using two pointers that move at different speeds. If either of them can get to a null then it\\'s obvious there isn\\'t a cycle. But what happens if there is a cycle? Eventually the faster pointer will make a full lap and be equal to the slow pointer. Therefore if during the traversal the faster pointer == slower pointer, you can return true."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Nodes that contains in my life cycle are eat,sleep..repeat :("
                    },
                    {
                        "username": "HikuMai",
                        "content": "Leetcode has mercy on me this time :))"
                    },
                    {
                        "username": "harshit1271gupta",
                        "content": " public boolean hasCycle(ListNode head) {\\n    // apparoch 1   using hashset cuz if it store same location that means there is a cycle \\n    // HashSet<ListNode> map = new HashSet<>();\\n    //     ListNode temp = head;\\n    //     while (temp != null) {\\n    //         if (map.contains(temp)) {\\n    //             return true;\\n    //         }else{\\n    //             map.add(temp);\\n    //         }\\n    //         temp = temp.next;\\n    //     }\\n    //     return false;\\n    // }\\n   // apparoch 2    space complexity 0(1)\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==null || head.next==null){\\n        return false;\\n    }\\n    while(fast!=null){\\n\\n        if(slow==null)return false;\\n        if(fast.next==null)return false;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow==fast)return true;\\n    }\\n    return false;"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "what is the use of mentioning the pos +  "
                    },
                    {
                        "username": "soukumpan",
                        "content": "ignore that "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "Here the set logic will not work because node-values may be repeated means for ex 2->4->3->7->4->6->null  then by set logic it will return true but actually it\\'s not containing any cycle so we need to use another logic for detect cycle ."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Why not? You just need to use node1 == node2 instead of node1.val == node2.val, means we check if a node actually refers to the same rather than checking a val. Works for Java.\\nBtw, it\\'s not necessary to use HashSet (or HashMap), it will work with simple list too, however Set seems to be faster.   "
                    },
                    {
                        "username": "ali__code",
                        "content": "how to use pos when it is not in parameter."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\n\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/3024832/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "knightryder098",
                        "content": "It\\'s given that POS is the valid position in the linked list. So if we just comapre it with 0, it should give us whether cycle is present or not. \\n\\nAm i am wrong? Plz explain . Thank You"
                    },
                    {
                        "username": "yazanmaini",
                        "content": "![image](https://assets.leetcode.com/users/images/e4307283-b136-4212-babe-2f7dd6051505_1596530623.2097838.png)\\n"
                    }
                ]
            },
            {
                "id": 2043248,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Try using two pointers that move at different speeds. If either of them can get to a null then it\\'s obvious there isn\\'t a cycle. But what happens if there is a cycle? Eventually the faster pointer will make a full lap and be equal to the slow pointer. Therefore if during the traversal the faster pointer == slower pointer, you can return true."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Nodes that contains in my life cycle are eat,sleep..repeat :("
                    },
                    {
                        "username": "HikuMai",
                        "content": "Leetcode has mercy on me this time :))"
                    },
                    {
                        "username": "harshit1271gupta",
                        "content": " public boolean hasCycle(ListNode head) {\\n    // apparoch 1   using hashset cuz if it store same location that means there is a cycle \\n    // HashSet<ListNode> map = new HashSet<>();\\n    //     ListNode temp = head;\\n    //     while (temp != null) {\\n    //         if (map.contains(temp)) {\\n    //             return true;\\n    //         }else{\\n    //             map.add(temp);\\n    //         }\\n    //         temp = temp.next;\\n    //     }\\n    //     return false;\\n    // }\\n   // apparoch 2    space complexity 0(1)\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==null || head.next==null){\\n        return false;\\n    }\\n    while(fast!=null){\\n\\n        if(slow==null)return false;\\n        if(fast.next==null)return false;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow==fast)return true;\\n    }\\n    return false;"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "what is the use of mentioning the pos +  "
                    },
                    {
                        "username": "soukumpan",
                        "content": "ignore that "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "Here the set logic will not work because node-values may be repeated means for ex 2->4->3->7->4->6->null  then by set logic it will return true but actually it\\'s not containing any cycle so we need to use another logic for detect cycle ."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Why not? You just need to use node1 == node2 instead of node1.val == node2.val, means we check if a node actually refers to the same rather than checking a val. Works for Java.\\nBtw, it\\'s not necessary to use HashSet (or HashMap), it will work with simple list too, however Set seems to be faster.   "
                    },
                    {
                        "username": "ali__code",
                        "content": "how to use pos when it is not in parameter."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\n\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/3024832/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "knightryder098",
                        "content": "It\\'s given that POS is the valid position in the linked list. So if we just comapre it with 0, it should give us whether cycle is present or not. \\n\\nAm i am wrong? Plz explain . Thank You"
                    },
                    {
                        "username": "yazanmaini",
                        "content": "![image](https://assets.leetcode.com/users/images/e4307283-b136-4212-babe-2f7dd6051505_1596530623.2097838.png)\\n"
                    }
                ]
            },
            {
                "id": 1953864,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Try using two pointers that move at different speeds. If either of them can get to a null then it\\'s obvious there isn\\'t a cycle. But what happens if there is a cycle? Eventually the faster pointer will make a full lap and be equal to the slow pointer. Therefore if during the traversal the faster pointer == slower pointer, you can return true."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Nodes that contains in my life cycle are eat,sleep..repeat :("
                    },
                    {
                        "username": "HikuMai",
                        "content": "Leetcode has mercy on me this time :))"
                    },
                    {
                        "username": "harshit1271gupta",
                        "content": " public boolean hasCycle(ListNode head) {\\n    // apparoch 1   using hashset cuz if it store same location that means there is a cycle \\n    // HashSet<ListNode> map = new HashSet<>();\\n    //     ListNode temp = head;\\n    //     while (temp != null) {\\n    //         if (map.contains(temp)) {\\n    //             return true;\\n    //         }else{\\n    //             map.add(temp);\\n    //         }\\n    //         temp = temp.next;\\n    //     }\\n    //     return false;\\n    // }\\n   // apparoch 2    space complexity 0(1)\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==null || head.next==null){\\n        return false;\\n    }\\n    while(fast!=null){\\n\\n        if(slow==null)return false;\\n        if(fast.next==null)return false;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow==fast)return true;\\n    }\\n    return false;"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "what is the use of mentioning the pos +  "
                    },
                    {
                        "username": "soukumpan",
                        "content": "ignore that "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "Here the set logic will not work because node-values may be repeated means for ex 2->4->3->7->4->6->null  then by set logic it will return true but actually it\\'s not containing any cycle so we need to use another logic for detect cycle ."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Why not? You just need to use node1 == node2 instead of node1.val == node2.val, means we check if a node actually refers to the same rather than checking a val. Works for Java.\\nBtw, it\\'s not necessary to use HashSet (or HashMap), it will work with simple list too, however Set seems to be faster.   "
                    },
                    {
                        "username": "ali__code",
                        "content": "how to use pos when it is not in parameter."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\n\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/3024832/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "knightryder098",
                        "content": "It\\'s given that POS is the valid position in the linked list. So if we just comapre it with 0, it should give us whether cycle is present or not. \\n\\nAm i am wrong? Plz explain . Thank You"
                    },
                    {
                        "username": "yazanmaini",
                        "content": "![image](https://assets.leetcode.com/users/images/e4307283-b136-4212-babe-2f7dd6051505_1596530623.2097838.png)\\n"
                    }
                ]
            },
            {
                "id": 1826966,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Try using two pointers that move at different speeds. If either of them can get to a null then it\\'s obvious there isn\\'t a cycle. But what happens if there is a cycle? Eventually the faster pointer will make a full lap and be equal to the slow pointer. Therefore if during the traversal the faster pointer == slower pointer, you can return true."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Nodes that contains in my life cycle are eat,sleep..repeat :("
                    },
                    {
                        "username": "HikuMai",
                        "content": "Leetcode has mercy on me this time :))"
                    },
                    {
                        "username": "harshit1271gupta",
                        "content": " public boolean hasCycle(ListNode head) {\\n    // apparoch 1   using hashset cuz if it store same location that means there is a cycle \\n    // HashSet<ListNode> map = new HashSet<>();\\n    //     ListNode temp = head;\\n    //     while (temp != null) {\\n    //         if (map.contains(temp)) {\\n    //             return true;\\n    //         }else{\\n    //             map.add(temp);\\n    //         }\\n    //         temp = temp.next;\\n    //     }\\n    //     return false;\\n    // }\\n   // apparoch 2    space complexity 0(1)\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==null || head.next==null){\\n        return false;\\n    }\\n    while(fast!=null){\\n\\n        if(slow==null)return false;\\n        if(fast.next==null)return false;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow==fast)return true;\\n    }\\n    return false;"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "what is the use of mentioning the pos +  "
                    },
                    {
                        "username": "soukumpan",
                        "content": "ignore that "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "Here the set logic will not work because node-values may be repeated means for ex 2->4->3->7->4->6->null  then by set logic it will return true but actually it\\'s not containing any cycle so we need to use another logic for detect cycle ."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Why not? You just need to use node1 == node2 instead of node1.val == node2.val, means we check if a node actually refers to the same rather than checking a val. Works for Java.\\nBtw, it\\'s not necessary to use HashSet (or HashMap), it will work with simple list too, however Set seems to be faster.   "
                    },
                    {
                        "username": "ali__code",
                        "content": "how to use pos when it is not in parameter."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\n\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/3024832/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "knightryder098",
                        "content": "It\\'s given that POS is the valid position in the linked list. So if we just comapre it with 0, it should give us whether cycle is present or not. \\n\\nAm i am wrong? Plz explain . Thank You"
                    },
                    {
                        "username": "yazanmaini",
                        "content": "![image](https://assets.leetcode.com/users/images/e4307283-b136-4212-babe-2f7dd6051505_1596530623.2097838.png)\\n"
                    }
                ]
            },
            {
                "id": 1794706,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Try using two pointers that move at different speeds. If either of them can get to a null then it\\'s obvious there isn\\'t a cycle. But what happens if there is a cycle? Eventually the faster pointer will make a full lap and be equal to the slow pointer. Therefore if during the traversal the faster pointer == slower pointer, you can return true."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Nodes that contains in my life cycle are eat,sleep..repeat :("
                    },
                    {
                        "username": "HikuMai",
                        "content": "Leetcode has mercy on me this time :))"
                    },
                    {
                        "username": "harshit1271gupta",
                        "content": " public boolean hasCycle(ListNode head) {\\n    // apparoch 1   using hashset cuz if it store same location that means there is a cycle \\n    // HashSet<ListNode> map = new HashSet<>();\\n    //     ListNode temp = head;\\n    //     while (temp != null) {\\n    //         if (map.contains(temp)) {\\n    //             return true;\\n    //         }else{\\n    //             map.add(temp);\\n    //         }\\n    //         temp = temp.next;\\n    //     }\\n    //     return false;\\n    // }\\n   // apparoch 2    space complexity 0(1)\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==null || head.next==null){\\n        return false;\\n    }\\n    while(fast!=null){\\n\\n        if(slow==null)return false;\\n        if(fast.next==null)return false;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow==fast)return true;\\n    }\\n    return false;"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "what is the use of mentioning the pos +  "
                    },
                    {
                        "username": "soukumpan",
                        "content": "ignore that "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "Here the set logic will not work because node-values may be repeated means for ex 2->4->3->7->4->6->null  then by set logic it will return true but actually it\\'s not containing any cycle so we need to use another logic for detect cycle ."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Why not? You just need to use node1 == node2 instead of node1.val == node2.val, means we check if a node actually refers to the same rather than checking a val. Works for Java.\\nBtw, it\\'s not necessary to use HashSet (or HashMap), it will work with simple list too, however Set seems to be faster.   "
                    },
                    {
                        "username": "ali__code",
                        "content": "how to use pos when it is not in parameter."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\n\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/3024832/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "knightryder098",
                        "content": "It\\'s given that POS is the valid position in the linked list. So if we just comapre it with 0, it should give us whether cycle is present or not. \\n\\nAm i am wrong? Plz explain . Thank You"
                    },
                    {
                        "username": "yazanmaini",
                        "content": "![image](https://assets.leetcode.com/users/images/e4307283-b136-4212-babe-2f7dd6051505_1596530623.2097838.png)\\n"
                    }
                ]
            },
            {
                "id": 1785619,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Try using two pointers that move at different speeds. If either of them can get to a null then it\\'s obvious there isn\\'t a cycle. But what happens if there is a cycle? Eventually the faster pointer will make a full lap and be equal to the slow pointer. Therefore if during the traversal the faster pointer == slower pointer, you can return true."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Nodes that contains in my life cycle are eat,sleep..repeat :("
                    },
                    {
                        "username": "HikuMai",
                        "content": "Leetcode has mercy on me this time :))"
                    },
                    {
                        "username": "harshit1271gupta",
                        "content": " public boolean hasCycle(ListNode head) {\\n    // apparoch 1   using hashset cuz if it store same location that means there is a cycle \\n    // HashSet<ListNode> map = new HashSet<>();\\n    //     ListNode temp = head;\\n    //     while (temp != null) {\\n    //         if (map.contains(temp)) {\\n    //             return true;\\n    //         }else{\\n    //             map.add(temp);\\n    //         }\\n    //         temp = temp.next;\\n    //     }\\n    //     return false;\\n    // }\\n   // apparoch 2    space complexity 0(1)\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==null || head.next==null){\\n        return false;\\n    }\\n    while(fast!=null){\\n\\n        if(slow==null)return false;\\n        if(fast.next==null)return false;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow==fast)return true;\\n    }\\n    return false;"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "what is the use of mentioning the pos +  "
                    },
                    {
                        "username": "soukumpan",
                        "content": "ignore that "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "Here the set logic will not work because node-values may be repeated means for ex 2->4->3->7->4->6->null  then by set logic it will return true but actually it\\'s not containing any cycle so we need to use another logic for detect cycle ."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Why not? You just need to use node1 == node2 instead of node1.val == node2.val, means we check if a node actually refers to the same rather than checking a val. Works for Java.\\nBtw, it\\'s not necessary to use HashSet (or HashMap), it will work with simple list too, however Set seems to be faster.   "
                    },
                    {
                        "username": "ali__code",
                        "content": "how to use pos when it is not in parameter."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\n\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/3024832/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "knightryder098",
                        "content": "It\\'s given that POS is the valid position in the linked list. So if we just comapre it with 0, it should give us whether cycle is present or not. \\n\\nAm i am wrong? Plz explain . Thank You"
                    },
                    {
                        "username": "yazanmaini",
                        "content": "![image](https://assets.leetcode.com/users/images/e4307283-b136-4212-babe-2f7dd6051505_1596530623.2097838.png)\\n"
                    }
                ]
            },
            {
                "id": 1749805,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Try using two pointers that move at different speeds. If either of them can get to a null then it\\'s obvious there isn\\'t a cycle. But what happens if there is a cycle? Eventually the faster pointer will make a full lap and be equal to the slow pointer. Therefore if during the traversal the faster pointer == slower pointer, you can return true."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Nodes that contains in my life cycle are eat,sleep..repeat :("
                    },
                    {
                        "username": "HikuMai",
                        "content": "Leetcode has mercy on me this time :))"
                    },
                    {
                        "username": "harshit1271gupta",
                        "content": " public boolean hasCycle(ListNode head) {\\n    // apparoch 1   using hashset cuz if it store same location that means there is a cycle \\n    // HashSet<ListNode> map = new HashSet<>();\\n    //     ListNode temp = head;\\n    //     while (temp != null) {\\n    //         if (map.contains(temp)) {\\n    //             return true;\\n    //         }else{\\n    //             map.add(temp);\\n    //         }\\n    //         temp = temp.next;\\n    //     }\\n    //     return false;\\n    // }\\n   // apparoch 2    space complexity 0(1)\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==null || head.next==null){\\n        return false;\\n    }\\n    while(fast!=null){\\n\\n        if(slow==null)return false;\\n        if(fast.next==null)return false;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow==fast)return true;\\n    }\\n    return false;"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "what is the use of mentioning the pos +  "
                    },
                    {
                        "username": "soukumpan",
                        "content": "ignore that "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "Here the set logic will not work because node-values may be repeated means for ex 2->4->3->7->4->6->null  then by set logic it will return true but actually it\\'s not containing any cycle so we need to use another logic for detect cycle ."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Why not? You just need to use node1 == node2 instead of node1.val == node2.val, means we check if a node actually refers to the same rather than checking a val. Works for Java.\\nBtw, it\\'s not necessary to use HashSet (or HashMap), it will work with simple list too, however Set seems to be faster.   "
                    },
                    {
                        "username": "ali__code",
                        "content": "how to use pos when it is not in parameter."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\n\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/3024832/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "knightryder098",
                        "content": "It\\'s given that POS is the valid position in the linked list. So if we just comapre it with 0, it should give us whether cycle is present or not. \\n\\nAm i am wrong? Plz explain . Thank You"
                    },
                    {
                        "username": "yazanmaini",
                        "content": "![image](https://assets.leetcode.com/users/images/e4307283-b136-4212-babe-2f7dd6051505_1596530623.2097838.png)\\n"
                    }
                ]
            },
            {
                "id": 1574921,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Try using two pointers that move at different speeds. If either of them can get to a null then it\\'s obvious there isn\\'t a cycle. But what happens if there is a cycle? Eventually the faster pointer will make a full lap and be equal to the slow pointer. Therefore if during the traversal the faster pointer == slower pointer, you can return true."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Nodes that contains in my life cycle are eat,sleep..repeat :("
                    },
                    {
                        "username": "HikuMai",
                        "content": "Leetcode has mercy on me this time :))"
                    },
                    {
                        "username": "harshit1271gupta",
                        "content": " public boolean hasCycle(ListNode head) {\\n    // apparoch 1   using hashset cuz if it store same location that means there is a cycle \\n    // HashSet<ListNode> map = new HashSet<>();\\n    //     ListNode temp = head;\\n    //     while (temp != null) {\\n    //         if (map.contains(temp)) {\\n    //             return true;\\n    //         }else{\\n    //             map.add(temp);\\n    //         }\\n    //         temp = temp.next;\\n    //     }\\n    //     return false;\\n    // }\\n   // apparoch 2    space complexity 0(1)\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==null || head.next==null){\\n        return false;\\n    }\\n    while(fast!=null){\\n\\n        if(slow==null)return false;\\n        if(fast.next==null)return false;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow==fast)return true;\\n    }\\n    return false;"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "what is the use of mentioning the pos +  "
                    },
                    {
                        "username": "soukumpan",
                        "content": "ignore that "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "Here the set logic will not work because node-values may be repeated means for ex 2->4->3->7->4->6->null  then by set logic it will return true but actually it\\'s not containing any cycle so we need to use another logic for detect cycle ."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Why not? You just need to use node1 == node2 instead of node1.val == node2.val, means we check if a node actually refers to the same rather than checking a val. Works for Java.\\nBtw, it\\'s not necessary to use HashSet (or HashMap), it will work with simple list too, however Set seems to be faster.   "
                    },
                    {
                        "username": "ali__code",
                        "content": "how to use pos when it is not in parameter."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\n\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/3024832/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "knightryder098",
                        "content": "It\\'s given that POS is the valid position in the linked list. So if we just comapre it with 0, it should give us whether cycle is present or not. \\n\\nAm i am wrong? Plz explain . Thank You"
                    },
                    {
                        "username": "yazanmaini",
                        "content": "![image](https://assets.leetcode.com/users/images/e4307283-b136-4212-babe-2f7dd6051505_1596530623.2097838.png)\\n"
                    }
                ]
            },
            {
                "id": 1574160,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Try using two pointers that move at different speeds. If either of them can get to a null then it\\'s obvious there isn\\'t a cycle. But what happens if there is a cycle? Eventually the faster pointer will make a full lap and be equal to the slow pointer. Therefore if during the traversal the faster pointer == slower pointer, you can return true."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Nodes that contains in my life cycle are eat,sleep..repeat :("
                    },
                    {
                        "username": "HikuMai",
                        "content": "Leetcode has mercy on me this time :))"
                    },
                    {
                        "username": "harshit1271gupta",
                        "content": " public boolean hasCycle(ListNode head) {\\n    // apparoch 1   using hashset cuz if it store same location that means there is a cycle \\n    // HashSet<ListNode> map = new HashSet<>();\\n    //     ListNode temp = head;\\n    //     while (temp != null) {\\n    //         if (map.contains(temp)) {\\n    //             return true;\\n    //         }else{\\n    //             map.add(temp);\\n    //         }\\n    //         temp = temp.next;\\n    //     }\\n    //     return false;\\n    // }\\n   // apparoch 2    space complexity 0(1)\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==null || head.next==null){\\n        return false;\\n    }\\n    while(fast!=null){\\n\\n        if(slow==null)return false;\\n        if(fast.next==null)return false;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow==fast)return true;\\n    }\\n    return false;"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "what is the use of mentioning the pos +  "
                    },
                    {
                        "username": "soukumpan",
                        "content": "ignore that "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "Here the set logic will not work because node-values may be repeated means for ex 2->4->3->7->4->6->null  then by set logic it will return true but actually it\\'s not containing any cycle so we need to use another logic for detect cycle ."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Why not? You just need to use node1 == node2 instead of node1.val == node2.val, means we check if a node actually refers to the same rather than checking a val. Works for Java.\\nBtw, it\\'s not necessary to use HashSet (or HashMap), it will work with simple list too, however Set seems to be faster.   "
                    },
                    {
                        "username": "ali__code",
                        "content": "how to use pos when it is not in parameter."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\n\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/3024832/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "knightryder098",
                        "content": "It\\'s given that POS is the valid position in the linked list. So if we just comapre it with 0, it should give us whether cycle is present or not. \\n\\nAm i am wrong? Plz explain . Thank You"
                    },
                    {
                        "username": "yazanmaini",
                        "content": "![image](https://assets.leetcode.com/users/images/e4307283-b136-4212-babe-2f7dd6051505_1596530623.2097838.png)\\n"
                    }
                ]
            },
            {
                "id": 1573831,
                "content": [
                    {
                        "username": "Skidro",
                        "content": "Why are we moving the fast pointer with 2x speed why not with 3x or any other ?"
                    },
                    {
                        "username": "lmckeon",
                        "content": "By only gaining on the slow node by one node at a time, you guarantee that you only have to make one full loop through the cycle once slow enters it. Other values can cause you to jump over slow node and make more loops through the cycle which is slower. This is my opinion."
                    },
                    {
                        "username": "ShawnDu2020",
                        "content": "may i ask I cannot see the pos in the input variable, am I wrong?"
                    },
                    {
                        "username": "theonewhocreates",
                        "content": "In the example, it is given that position we have to check for will be part of the input. But it is not one of the attirbutes of the function. Is there something I\\'m missing?"
                    },
                    {
                        "username": "GCC97",
                        "content": "Input ixample in the question description has a pos variable and so does the test input. I cannot  access it. Why is it put there?"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "therahulgoel",
                        "content": "Hi,\\nPlease suggest how can i submit the solution in Swift language as i dont see it the langauges options dropdown.\\n"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "so it doesnt depend on pos argument just check if any of the nodes are forming a cycle, i think this needs pure logical thinking"
                    },
                    {
                        "username": "roycwc",
                        "content": "For js user, you need to set up this at the beginning:\\n\\n```\\nlet toLinkedList = (arr, pos) => {\\n    class ListNode {\\n        constructor(val){\\n            this.val = val;\\n            this.next = null;\\n        }\\n    }\\n\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new ListNode(arr[i])\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        arr[i].next = i === arr.length - 1 ? (pos === -1 ? null : arr[pos]) : arr[i+1]\\n    }\\n    return arr[0]\\n}\\n\\nmodule.exports = { toLinkedList }\\n```\\n\\n```\\nvar arr  = [3,2,0,-4]\\nvar pos  = 1\\nvar linkedList = toLinkedList(arr, pos)\\n\\nvar result = hasCycle(linkedList)\\nassert.equal(true, result)\\n```"
                    },
                    {
                        "username": "chumaumenze",
                        "content": "#### Just testing out a Leetcode hack. Haha!\\n\\n```py\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return True if \"Error\" in str(head) else False\\n```"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`pos`  helps to indicate the node where the last node of the linked list points to\nfor example: [1,2,3,4,5,6]\nif `pos == 0` then `6->next = 1`\nif `pos == 1` then `6->next = 2`\nif `pos == 5` then `6->next = 6` (i.e. 6 points to itself, so there's also a valid cycle in the list)\nif `pos == -1` then `6->next = null`. hence, there's no cycle in the list\n\nbasically, if they give us `pos`, we can easily `return pos != -1` as the answer"
                    }
                ]
            },
            {
                "id": 1573061,
                "content": [
                    {
                        "username": "Skidro",
                        "content": "Why are we moving the fast pointer with 2x speed why not with 3x or any other ?"
                    },
                    {
                        "username": "lmckeon",
                        "content": "By only gaining on the slow node by one node at a time, you guarantee that you only have to make one full loop through the cycle once slow enters it. Other values can cause you to jump over slow node and make more loops through the cycle which is slower. This is my opinion."
                    },
                    {
                        "username": "ShawnDu2020",
                        "content": "may i ask I cannot see the pos in the input variable, am I wrong?"
                    },
                    {
                        "username": "theonewhocreates",
                        "content": "In the example, it is given that position we have to check for will be part of the input. But it is not one of the attirbutes of the function. Is there something I\\'m missing?"
                    },
                    {
                        "username": "GCC97",
                        "content": "Input ixample in the question description has a pos variable and so does the test input. I cannot  access it. Why is it put there?"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "therahulgoel",
                        "content": "Hi,\\nPlease suggest how can i submit the solution in Swift language as i dont see it the langauges options dropdown.\\n"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "so it doesnt depend on pos argument just check if any of the nodes are forming a cycle, i think this needs pure logical thinking"
                    },
                    {
                        "username": "roycwc",
                        "content": "For js user, you need to set up this at the beginning:\\n\\n```\\nlet toLinkedList = (arr, pos) => {\\n    class ListNode {\\n        constructor(val){\\n            this.val = val;\\n            this.next = null;\\n        }\\n    }\\n\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new ListNode(arr[i])\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        arr[i].next = i === arr.length - 1 ? (pos === -1 ? null : arr[pos]) : arr[i+1]\\n    }\\n    return arr[0]\\n}\\n\\nmodule.exports = { toLinkedList }\\n```\\n\\n```\\nvar arr  = [3,2,0,-4]\\nvar pos  = 1\\nvar linkedList = toLinkedList(arr, pos)\\n\\nvar result = hasCycle(linkedList)\\nassert.equal(true, result)\\n```"
                    },
                    {
                        "username": "chumaumenze",
                        "content": "#### Just testing out a Leetcode hack. Haha!\\n\\n```py\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return True if \"Error\" in str(head) else False\\n```"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`pos`  helps to indicate the node where the last node of the linked list points to\nfor example: [1,2,3,4,5,6]\nif `pos == 0` then `6->next = 1`\nif `pos == 1` then `6->next = 2`\nif `pos == 5` then `6->next = 6` (i.e. 6 points to itself, so there's also a valid cycle in the list)\nif `pos == -1` then `6->next = null`. hence, there's no cycle in the list\n\nbasically, if they give us `pos`, we can easily `return pos != -1` as the answer"
                    }
                ]
            },
            {
                "id": 1572763,
                "content": [
                    {
                        "username": "Skidro",
                        "content": "Why are we moving the fast pointer with 2x speed why not with 3x or any other ?"
                    },
                    {
                        "username": "lmckeon",
                        "content": "By only gaining on the slow node by one node at a time, you guarantee that you only have to make one full loop through the cycle once slow enters it. Other values can cause you to jump over slow node and make more loops through the cycle which is slower. This is my opinion."
                    },
                    {
                        "username": "ShawnDu2020",
                        "content": "may i ask I cannot see the pos in the input variable, am I wrong?"
                    },
                    {
                        "username": "theonewhocreates",
                        "content": "In the example, it is given that position we have to check for will be part of the input. But it is not one of the attirbutes of the function. Is there something I\\'m missing?"
                    },
                    {
                        "username": "GCC97",
                        "content": "Input ixample in the question description has a pos variable and so does the test input. I cannot  access it. Why is it put there?"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "therahulgoel",
                        "content": "Hi,\\nPlease suggest how can i submit the solution in Swift language as i dont see it the langauges options dropdown.\\n"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "so it doesnt depend on pos argument just check if any of the nodes are forming a cycle, i think this needs pure logical thinking"
                    },
                    {
                        "username": "roycwc",
                        "content": "For js user, you need to set up this at the beginning:\\n\\n```\\nlet toLinkedList = (arr, pos) => {\\n    class ListNode {\\n        constructor(val){\\n            this.val = val;\\n            this.next = null;\\n        }\\n    }\\n\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new ListNode(arr[i])\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        arr[i].next = i === arr.length - 1 ? (pos === -1 ? null : arr[pos]) : arr[i+1]\\n    }\\n    return arr[0]\\n}\\n\\nmodule.exports = { toLinkedList }\\n```\\n\\n```\\nvar arr  = [3,2,0,-4]\\nvar pos  = 1\\nvar linkedList = toLinkedList(arr, pos)\\n\\nvar result = hasCycle(linkedList)\\nassert.equal(true, result)\\n```"
                    },
                    {
                        "username": "chumaumenze",
                        "content": "#### Just testing out a Leetcode hack. Haha!\\n\\n```py\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return True if \"Error\" in str(head) else False\\n```"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`pos`  helps to indicate the node where the last node of the linked list points to\nfor example: [1,2,3,4,5,6]\nif `pos == 0` then `6->next = 1`\nif `pos == 1` then `6->next = 2`\nif `pos == 5` then `6->next = 6` (i.e. 6 points to itself, so there's also a valid cycle in the list)\nif `pos == -1` then `6->next = null`. hence, there's no cycle in the list\n\nbasically, if they give us `pos`, we can easily `return pos != -1` as the answer"
                    }
                ]
            },
            {
                "id": 1572342,
                "content": [
                    {
                        "username": "Skidro",
                        "content": "Why are we moving the fast pointer with 2x speed why not with 3x or any other ?"
                    },
                    {
                        "username": "lmckeon",
                        "content": "By only gaining on the slow node by one node at a time, you guarantee that you only have to make one full loop through the cycle once slow enters it. Other values can cause you to jump over slow node and make more loops through the cycle which is slower. This is my opinion."
                    },
                    {
                        "username": "ShawnDu2020",
                        "content": "may i ask I cannot see the pos in the input variable, am I wrong?"
                    },
                    {
                        "username": "theonewhocreates",
                        "content": "In the example, it is given that position we have to check for will be part of the input. But it is not one of the attirbutes of the function. Is there something I\\'m missing?"
                    },
                    {
                        "username": "GCC97",
                        "content": "Input ixample in the question description has a pos variable and so does the test input. I cannot  access it. Why is it put there?"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "therahulgoel",
                        "content": "Hi,\\nPlease suggest how can i submit the solution in Swift language as i dont see it the langauges options dropdown.\\n"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "so it doesnt depend on pos argument just check if any of the nodes are forming a cycle, i think this needs pure logical thinking"
                    },
                    {
                        "username": "roycwc",
                        "content": "For js user, you need to set up this at the beginning:\\n\\n```\\nlet toLinkedList = (arr, pos) => {\\n    class ListNode {\\n        constructor(val){\\n            this.val = val;\\n            this.next = null;\\n        }\\n    }\\n\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new ListNode(arr[i])\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        arr[i].next = i === arr.length - 1 ? (pos === -1 ? null : arr[pos]) : arr[i+1]\\n    }\\n    return arr[0]\\n}\\n\\nmodule.exports = { toLinkedList }\\n```\\n\\n```\\nvar arr  = [3,2,0,-4]\\nvar pos  = 1\\nvar linkedList = toLinkedList(arr, pos)\\n\\nvar result = hasCycle(linkedList)\\nassert.equal(true, result)\\n```"
                    },
                    {
                        "username": "chumaumenze",
                        "content": "#### Just testing out a Leetcode hack. Haha!\\n\\n```py\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return True if \"Error\" in str(head) else False\\n```"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`pos`  helps to indicate the node where the last node of the linked list points to\nfor example: [1,2,3,4,5,6]\nif `pos == 0` then `6->next = 1`\nif `pos == 1` then `6->next = 2`\nif `pos == 5` then `6->next = 6` (i.e. 6 points to itself, so there's also a valid cycle in the list)\nif `pos == -1` then `6->next = null`. hence, there's no cycle in the list\n\nbasically, if they give us `pos`, we can easily `return pos != -1` as the answer"
                    }
                ]
            },
            {
                "id": 1575690,
                "content": [
                    {
                        "username": "Skidro",
                        "content": "Why are we moving the fast pointer with 2x speed why not with 3x or any other ?"
                    },
                    {
                        "username": "lmckeon",
                        "content": "By only gaining on the slow node by one node at a time, you guarantee that you only have to make one full loop through the cycle once slow enters it. Other values can cause you to jump over slow node and make more loops through the cycle which is slower. This is my opinion."
                    },
                    {
                        "username": "ShawnDu2020",
                        "content": "may i ask I cannot see the pos in the input variable, am I wrong?"
                    },
                    {
                        "username": "theonewhocreates",
                        "content": "In the example, it is given that position we have to check for will be part of the input. But it is not one of the attirbutes of the function. Is there something I\\'m missing?"
                    },
                    {
                        "username": "GCC97",
                        "content": "Input ixample in the question description has a pos variable and so does the test input. I cannot  access it. Why is it put there?"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "therahulgoel",
                        "content": "Hi,\\nPlease suggest how can i submit the solution in Swift language as i dont see it the langauges options dropdown.\\n"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "so it doesnt depend on pos argument just check if any of the nodes are forming a cycle, i think this needs pure logical thinking"
                    },
                    {
                        "username": "roycwc",
                        "content": "For js user, you need to set up this at the beginning:\\n\\n```\\nlet toLinkedList = (arr, pos) => {\\n    class ListNode {\\n        constructor(val){\\n            this.val = val;\\n            this.next = null;\\n        }\\n    }\\n\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new ListNode(arr[i])\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        arr[i].next = i === arr.length - 1 ? (pos === -1 ? null : arr[pos]) : arr[i+1]\\n    }\\n    return arr[0]\\n}\\n\\nmodule.exports = { toLinkedList }\\n```\\n\\n```\\nvar arr  = [3,2,0,-4]\\nvar pos  = 1\\nvar linkedList = toLinkedList(arr, pos)\\n\\nvar result = hasCycle(linkedList)\\nassert.equal(true, result)\\n```"
                    },
                    {
                        "username": "chumaumenze",
                        "content": "#### Just testing out a Leetcode hack. Haha!\\n\\n```py\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return True if \"Error\" in str(head) else False\\n```"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`pos`  helps to indicate the node where the last node of the linked list points to\nfor example: [1,2,3,4,5,6]\nif `pos == 0` then `6->next = 1`\nif `pos == 1` then `6->next = 2`\nif `pos == 5` then `6->next = 6` (i.e. 6 points to itself, so there's also a valid cycle in the list)\nif `pos == -1` then `6->next = null`. hence, there's no cycle in the list\n\nbasically, if they give us `pos`, we can easily `return pos != -1` as the answer"
                    }
                ]
            },
            {
                "id": 1573017,
                "content": [
                    {
                        "username": "Skidro",
                        "content": "Why are we moving the fast pointer with 2x speed why not with 3x or any other ?"
                    },
                    {
                        "username": "lmckeon",
                        "content": "By only gaining on the slow node by one node at a time, you guarantee that you only have to make one full loop through the cycle once slow enters it. Other values can cause you to jump over slow node and make more loops through the cycle which is slower. This is my opinion."
                    },
                    {
                        "username": "ShawnDu2020",
                        "content": "may i ask I cannot see the pos in the input variable, am I wrong?"
                    },
                    {
                        "username": "theonewhocreates",
                        "content": "In the example, it is given that position we have to check for will be part of the input. But it is not one of the attirbutes of the function. Is there something I\\'m missing?"
                    },
                    {
                        "username": "GCC97",
                        "content": "Input ixample in the question description has a pos variable and so does the test input. I cannot  access it. Why is it put there?"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "therahulgoel",
                        "content": "Hi,\\nPlease suggest how can i submit the solution in Swift language as i dont see it the langauges options dropdown.\\n"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "so it doesnt depend on pos argument just check if any of the nodes are forming a cycle, i think this needs pure logical thinking"
                    },
                    {
                        "username": "roycwc",
                        "content": "For js user, you need to set up this at the beginning:\\n\\n```\\nlet toLinkedList = (arr, pos) => {\\n    class ListNode {\\n        constructor(val){\\n            this.val = val;\\n            this.next = null;\\n        }\\n    }\\n\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new ListNode(arr[i])\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        arr[i].next = i === arr.length - 1 ? (pos === -1 ? null : arr[pos]) : arr[i+1]\\n    }\\n    return arr[0]\\n}\\n\\nmodule.exports = { toLinkedList }\\n```\\n\\n```\\nvar arr  = [3,2,0,-4]\\nvar pos  = 1\\nvar linkedList = toLinkedList(arr, pos)\\n\\nvar result = hasCycle(linkedList)\\nassert.equal(true, result)\\n```"
                    },
                    {
                        "username": "chumaumenze",
                        "content": "#### Just testing out a Leetcode hack. Haha!\\n\\n```py\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return True if \"Error\" in str(head) else False\\n```"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`pos`  helps to indicate the node where the last node of the linked list points to\nfor example: [1,2,3,4,5,6]\nif `pos == 0` then `6->next = 1`\nif `pos == 1` then `6->next = 2`\nif `pos == 5` then `6->next = 6` (i.e. 6 points to itself, so there's also a valid cycle in the list)\nif `pos == -1` then `6->next = null`. hence, there's no cycle in the list\n\nbasically, if they give us `pos`, we can easily `return pos != -1` as the answer"
                    }
                ]
            },
            {
                "id": 2075357,
                "content": [
                    {
                        "username": "Skidro",
                        "content": "Why are we moving the fast pointer with 2x speed why not with 3x or any other ?"
                    },
                    {
                        "username": "lmckeon",
                        "content": "By only gaining on the slow node by one node at a time, you guarantee that you only have to make one full loop through the cycle once slow enters it. Other values can cause you to jump over slow node and make more loops through the cycle which is slower. This is my opinion."
                    },
                    {
                        "username": "ShawnDu2020",
                        "content": "may i ask I cannot see the pos in the input variable, am I wrong?"
                    },
                    {
                        "username": "theonewhocreates",
                        "content": "In the example, it is given that position we have to check for will be part of the input. But it is not one of the attirbutes of the function. Is there something I\\'m missing?"
                    },
                    {
                        "username": "GCC97",
                        "content": "Input ixample in the question description has a pos variable and so does the test input. I cannot  access it. Why is it put there?"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "therahulgoel",
                        "content": "Hi,\\nPlease suggest how can i submit the solution in Swift language as i dont see it the langauges options dropdown.\\n"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "so it doesnt depend on pos argument just check if any of the nodes are forming a cycle, i think this needs pure logical thinking"
                    },
                    {
                        "username": "roycwc",
                        "content": "For js user, you need to set up this at the beginning:\\n\\n```\\nlet toLinkedList = (arr, pos) => {\\n    class ListNode {\\n        constructor(val){\\n            this.val = val;\\n            this.next = null;\\n        }\\n    }\\n\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new ListNode(arr[i])\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        arr[i].next = i === arr.length - 1 ? (pos === -1 ? null : arr[pos]) : arr[i+1]\\n    }\\n    return arr[0]\\n}\\n\\nmodule.exports = { toLinkedList }\\n```\\n\\n```\\nvar arr  = [3,2,0,-4]\\nvar pos  = 1\\nvar linkedList = toLinkedList(arr, pos)\\n\\nvar result = hasCycle(linkedList)\\nassert.equal(true, result)\\n```"
                    },
                    {
                        "username": "chumaumenze",
                        "content": "#### Just testing out a Leetcode hack. Haha!\\n\\n```py\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return True if \"Error\" in str(head) else False\\n```"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`pos`  helps to indicate the node where the last node of the linked list points to\nfor example: [1,2,3,4,5,6]\nif `pos == 0` then `6->next = 1`\nif `pos == 1` then `6->next = 2`\nif `pos == 5` then `6->next = 6` (i.e. 6 points to itself, so there's also a valid cycle in the list)\nif `pos == -1` then `6->next = null`. hence, there's no cycle in the list\n\nbasically, if they give us `pos`, we can easily `return pos != -1` as the answer"
                    }
                ]
            },
            {
                "id": 2067090,
                "content": [
                    {
                        "username": "Skidro",
                        "content": "Why are we moving the fast pointer with 2x speed why not with 3x or any other ?"
                    },
                    {
                        "username": "lmckeon",
                        "content": "By only gaining on the slow node by one node at a time, you guarantee that you only have to make one full loop through the cycle once slow enters it. Other values can cause you to jump over slow node and make more loops through the cycle which is slower. This is my opinion."
                    },
                    {
                        "username": "ShawnDu2020",
                        "content": "may i ask I cannot see the pos in the input variable, am I wrong?"
                    },
                    {
                        "username": "theonewhocreates",
                        "content": "In the example, it is given that position we have to check for will be part of the input. But it is not one of the attirbutes of the function. Is there something I\\'m missing?"
                    },
                    {
                        "username": "GCC97",
                        "content": "Input ixample in the question description has a pos variable and so does the test input. I cannot  access it. Why is it put there?"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "therahulgoel",
                        "content": "Hi,\\nPlease suggest how can i submit the solution in Swift language as i dont see it the langauges options dropdown.\\n"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "so it doesnt depend on pos argument just check if any of the nodes are forming a cycle, i think this needs pure logical thinking"
                    },
                    {
                        "username": "roycwc",
                        "content": "For js user, you need to set up this at the beginning:\\n\\n```\\nlet toLinkedList = (arr, pos) => {\\n    class ListNode {\\n        constructor(val){\\n            this.val = val;\\n            this.next = null;\\n        }\\n    }\\n\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new ListNode(arr[i])\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        arr[i].next = i === arr.length - 1 ? (pos === -1 ? null : arr[pos]) : arr[i+1]\\n    }\\n    return arr[0]\\n}\\n\\nmodule.exports = { toLinkedList }\\n```\\n\\n```\\nvar arr  = [3,2,0,-4]\\nvar pos  = 1\\nvar linkedList = toLinkedList(arr, pos)\\n\\nvar result = hasCycle(linkedList)\\nassert.equal(true, result)\\n```"
                    },
                    {
                        "username": "chumaumenze",
                        "content": "#### Just testing out a Leetcode hack. Haha!\\n\\n```py\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return True if \"Error\" in str(head) else False\\n```"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`pos`  helps to indicate the node where the last node of the linked list points to\nfor example: [1,2,3,4,5,6]\nif `pos == 0` then `6->next = 1`\nif `pos == 1` then `6->next = 2`\nif `pos == 5` then `6->next = 6` (i.e. 6 points to itself, so there's also a valid cycle in the list)\nif `pos == -1` then `6->next = null`. hence, there's no cycle in the list\n\nbasically, if they give us `pos`, we can easily `return pos != -1` as the answer"
                    }
                ]
            },
            {
                "id": 2064454,
                "content": [
                    {
                        "username": "Skidro",
                        "content": "Why are we moving the fast pointer with 2x speed why not with 3x or any other ?"
                    },
                    {
                        "username": "lmckeon",
                        "content": "By only gaining on the slow node by one node at a time, you guarantee that you only have to make one full loop through the cycle once slow enters it. Other values can cause you to jump over slow node and make more loops through the cycle which is slower. This is my opinion."
                    },
                    {
                        "username": "ShawnDu2020",
                        "content": "may i ask I cannot see the pos in the input variable, am I wrong?"
                    },
                    {
                        "username": "theonewhocreates",
                        "content": "In the example, it is given that position we have to check for will be part of the input. But it is not one of the attirbutes of the function. Is there something I\\'m missing?"
                    },
                    {
                        "username": "GCC97",
                        "content": "Input ixample in the question description has a pos variable and so does the test input. I cannot  access it. Why is it put there?"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "therahulgoel",
                        "content": "Hi,\\nPlease suggest how can i submit the solution in Swift language as i dont see it the langauges options dropdown.\\n"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "so it doesnt depend on pos argument just check if any of the nodes are forming a cycle, i think this needs pure logical thinking"
                    },
                    {
                        "username": "roycwc",
                        "content": "For js user, you need to set up this at the beginning:\\n\\n```\\nlet toLinkedList = (arr, pos) => {\\n    class ListNode {\\n        constructor(val){\\n            this.val = val;\\n            this.next = null;\\n        }\\n    }\\n\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new ListNode(arr[i])\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        arr[i].next = i === arr.length - 1 ? (pos === -1 ? null : arr[pos]) : arr[i+1]\\n    }\\n    return arr[0]\\n}\\n\\nmodule.exports = { toLinkedList }\\n```\\n\\n```\\nvar arr  = [3,2,0,-4]\\nvar pos  = 1\\nvar linkedList = toLinkedList(arr, pos)\\n\\nvar result = hasCycle(linkedList)\\nassert.equal(true, result)\\n```"
                    },
                    {
                        "username": "chumaumenze",
                        "content": "#### Just testing out a Leetcode hack. Haha!\\n\\n```py\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return True if \"Error\" in str(head) else False\\n```"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`pos`  helps to indicate the node where the last node of the linked list points to\nfor example: [1,2,3,4,5,6]\nif `pos == 0` then `6->next = 1`\nif `pos == 1` then `6->next = 2`\nif `pos == 5` then `6->next = 6` (i.e. 6 points to itself, so there's also a valid cycle in the list)\nif `pos == -1` then `6->next = null`. hence, there's no cycle in the list\n\nbasically, if they give us `pos`, we can easily `return pos != -1` as the answer"
                    }
                ]
            },
            {
                "id": 2063886,
                "content": [
                    {
                        "username": "Skidro",
                        "content": "Why are we moving the fast pointer with 2x speed why not with 3x or any other ?"
                    },
                    {
                        "username": "lmckeon",
                        "content": "By only gaining on the slow node by one node at a time, you guarantee that you only have to make one full loop through the cycle once slow enters it. Other values can cause you to jump over slow node and make more loops through the cycle which is slower. This is my opinion."
                    },
                    {
                        "username": "ShawnDu2020",
                        "content": "may i ask I cannot see the pos in the input variable, am I wrong?"
                    },
                    {
                        "username": "theonewhocreates",
                        "content": "In the example, it is given that position we have to check for will be part of the input. But it is not one of the attirbutes of the function. Is there something I\\'m missing?"
                    },
                    {
                        "username": "GCC97",
                        "content": "Input ixample in the question description has a pos variable and so does the test input. I cannot  access it. Why is it put there?"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "therahulgoel",
                        "content": "Hi,\\nPlease suggest how can i submit the solution in Swift language as i dont see it the langauges options dropdown.\\n"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "so it doesnt depend on pos argument just check if any of the nodes are forming a cycle, i think this needs pure logical thinking"
                    },
                    {
                        "username": "roycwc",
                        "content": "For js user, you need to set up this at the beginning:\\n\\n```\\nlet toLinkedList = (arr, pos) => {\\n    class ListNode {\\n        constructor(val){\\n            this.val = val;\\n            this.next = null;\\n        }\\n    }\\n\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new ListNode(arr[i])\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        arr[i].next = i === arr.length - 1 ? (pos === -1 ? null : arr[pos]) : arr[i+1]\\n    }\\n    return arr[0]\\n}\\n\\nmodule.exports = { toLinkedList }\\n```\\n\\n```\\nvar arr  = [3,2,0,-4]\\nvar pos  = 1\\nvar linkedList = toLinkedList(arr, pos)\\n\\nvar result = hasCycle(linkedList)\\nassert.equal(true, result)\\n```"
                    },
                    {
                        "username": "chumaumenze",
                        "content": "#### Just testing out a Leetcode hack. Haha!\\n\\n```py\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return True if \"Error\" in str(head) else False\\n```"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`pos`  helps to indicate the node where the last node of the linked list points to\nfor example: [1,2,3,4,5,6]\nif `pos == 0` then `6->next = 1`\nif `pos == 1` then `6->next = 2`\nif `pos == 5` then `6->next = 6` (i.e. 6 points to itself, so there's also a valid cycle in the list)\nif `pos == -1` then `6->next = null`. hence, there's no cycle in the list\n\nbasically, if they give us `pos`, we can easily `return pos != -1` as the answer"
                    }
                ]
            },
            {
                "id": 2059854,
                "content": [
                    {
                        "username": "AayushSrivastav29",
                        "content": "Make two pointers-\\n1) fast; which travels two nodes at once\\n2) slow; which travels one node at a time. \\nat any future node they will meet bcz its a circle, then return true, otherwise false."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "runtime error although the cases are passed in the test runs,  any idea?  thanks\n\nattributeError: 'NoneType' object has no attribute 'next'\n    fast=head.next\nLine 29 in hasCycle (Solution.py)\n    ret = Solution().hasCycle(param_1)\nLine 61 in _driver (Solution.py)\n    _driver()\nLine 74 in <module> (Solution.py)"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) oh yeah, I missed a small test case lol. Updated the answer."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) I copied and pasted your code,  it got the same error.\\n"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) This is a rather simple but confusing error. \nThis code would fail for the testcases:\n```\n[1,2,3]\n-1\n[]\n-1\n```\n\nYou initialized the fast pointer to `head.next` (in this case 2), incremented fast twice (now pointing at `None`). Now `while` tries to call `fast.next` which is `None.next` and hence the error. Set both to `head` at first but then don't forget to reorder the if statement to increment pointers and then check and check if `fast` is not `None` in the `while` loop.\n `slow.next` can never be `None` (why? because `fast` would've already got there), instead you should be checking whether `fast` is `None`.\n\nAlso, check if `slow` is same as `fast` instead of checking if they are equal. Because some test cases have repeated values, but they are not the same node. Example test case:\n```\n[1,2,3,2,4]\n-1\n```\n\nFixed code:\n```python\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow=head\n        fast=head\n        while fast and fast.next:\n            # print('here')\n            slow=slow.next\n            fast=fast.next.next\n            if(slow==fast):\n                return True\n                \n        return False\n```\n\nHope this helps. \n"
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) # Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\n\\n\\n# Time complexity is O(N) \\n# Space Complexity is O(1)\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow=head\\n        fast=head.next\\n\\n        while(slow.next!=None and fast.next!=None):\\n            # print(\\'here\\')\\n            if(slow.val==fast.val):\\n                return True\\n            else:\\n                slow=slow.next\\n                fast=fast.next.next\\n        return False"
                    },
                    {
                        "username": "parapsychic",
                        "content": "you are calling next on a NoneType. If you could post the code, I can check. It\\'s usually because you reached the end of the list and still called next which returns a None, but then you call next again on that None."
                    },
                    {
                        "username": "parapsychic",
                        "content": "So, I was looking at some of the best memory efficient solution and I found that they just took the `pos` variable and returned true or false. Isn\\'t that cheating? I think those submissions should be removed.\\n[sample of cheating](https://imgur.com/yo6IPk2)"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Don\\'t worry. Practice for your own self-improvement. People who cheat are harming themselves. They won\\'t gain anything. Just keep improving, man!"
                    },
                    {
                        "username": "sergei99",
                        "content": "There is lots of cheating here. E.g. people open the output file (they somehow know its name) and write the hardcoded solution output from a static block executed prior to measurement stuff. So they get a really low execution time of their code, which is totally useless in solving real life problems."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "EASY   | |   USING SLOW & FAST POINTER\nconsider this example as you are in a circular racing track and there another person (he is faster then you ) , so if in 1second you go 1metre he in 1second goes 2meter, so now you start running and there will be a time where he will catch you from behind (as track is circular) if this happens then our list is circular else our list is not circular(consider the track was straight and the faster person finished the track but didn't overtake you as it was a straight track)\n\nNOTE:- there is no need to use 'pos' , our logic works fine.\n\n1. Check a base condition if list is empty or not.\n\n2. Initialize two pointer slow and fast to head.\n\n3. traverse the list and during each iteration move 'slow' 1 step ahead and move 'fast' 2 step ahead. And within this loop check if our slow and fast pointer are pointing to same node or not , if they are pointing to same node somewhere in the list then we got our cycle and return true.\n\n4. But even after loop termination if these two pointers didn't point same position then it is sure that they never met and we can say our list does not has any cycle.\n\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast!=NULL && fast->next !=NULL){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow==fast)\n                return true;\n        }\n        return false;\n    }\n};\n"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "My solution was to go throught entire LinkedList and keep saving the values in a list. If I come across any values in the linkedlist which is already present in the list I will return false. But for one of my test cases I can see 2 5s in the LL and pos = -1 the expected output is false. Why? Shouldn\\'t it be true?"
                    },
                    {
                        "username": "toanngo",
                        "content": "Instead of using a fast/slow pointer, you can just use one, and have a map that checks whether you\\'ve visited the node. In python, do something like `visited = {head:True}`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Think about 2 pointers where one moves one node at a time while the other moves 2 at a time. What will happen then??"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Ignore Pos . We can use fast and slow pointers or regular old reliable set."
                    },
                    {
                        "username": "Mouli_ch",
                        "content": "can anyone please explain the problem briefly"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "So, we need to find if there is a cycle in the linked list or not. In the explanation, they propose this pos argument in order to show that the \\'last\\' element of the linked list is pointing to. another element in the same list, creating then a infinite cycle in it. \\nSo our duty is to identify if a cycle exists in the leetcode tests."
                    },
                    {
                        "username": "jebbe",
                        "content": "As a beginner with JS, There is no way to log the head object to understand the linked list properties due to there being a cycle in the object. The third testcase is only one element.    \\nIncluding a longer true testcase would be more beginner friendly for me :)"
                    }
                ]
            },
            {
                "id": 2056077,
                "content": [
                    {
                        "username": "AayushSrivastav29",
                        "content": "Make two pointers-\\n1) fast; which travels two nodes at once\\n2) slow; which travels one node at a time. \\nat any future node they will meet bcz its a circle, then return true, otherwise false."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "runtime error although the cases are passed in the test runs,  any idea?  thanks\n\nattributeError: 'NoneType' object has no attribute 'next'\n    fast=head.next\nLine 29 in hasCycle (Solution.py)\n    ret = Solution().hasCycle(param_1)\nLine 61 in _driver (Solution.py)\n    _driver()\nLine 74 in <module> (Solution.py)"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) oh yeah, I missed a small test case lol. Updated the answer."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) I copied and pasted your code,  it got the same error.\\n"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) This is a rather simple but confusing error. \nThis code would fail for the testcases:\n```\n[1,2,3]\n-1\n[]\n-1\n```\n\nYou initialized the fast pointer to `head.next` (in this case 2), incremented fast twice (now pointing at `None`). Now `while` tries to call `fast.next` which is `None.next` and hence the error. Set both to `head` at first but then don't forget to reorder the if statement to increment pointers and then check and check if `fast` is not `None` in the `while` loop.\n `slow.next` can never be `None` (why? because `fast` would've already got there), instead you should be checking whether `fast` is `None`.\n\nAlso, check if `slow` is same as `fast` instead of checking if they are equal. Because some test cases have repeated values, but they are not the same node. Example test case:\n```\n[1,2,3,2,4]\n-1\n```\n\nFixed code:\n```python\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow=head\n        fast=head\n        while fast and fast.next:\n            # print('here')\n            slow=slow.next\n            fast=fast.next.next\n            if(slow==fast):\n                return True\n                \n        return False\n```\n\nHope this helps. \n"
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) # Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\n\\n\\n# Time complexity is O(N) \\n# Space Complexity is O(1)\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow=head\\n        fast=head.next\\n\\n        while(slow.next!=None and fast.next!=None):\\n            # print(\\'here\\')\\n            if(slow.val==fast.val):\\n                return True\\n            else:\\n                slow=slow.next\\n                fast=fast.next.next\\n        return False"
                    },
                    {
                        "username": "parapsychic",
                        "content": "you are calling next on a NoneType. If you could post the code, I can check. It\\'s usually because you reached the end of the list and still called next which returns a None, but then you call next again on that None."
                    },
                    {
                        "username": "parapsychic",
                        "content": "So, I was looking at some of the best memory efficient solution and I found that they just took the `pos` variable and returned true or false. Isn\\'t that cheating? I think those submissions should be removed.\\n[sample of cheating](https://imgur.com/yo6IPk2)"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Don\\'t worry. Practice for your own self-improvement. People who cheat are harming themselves. They won\\'t gain anything. Just keep improving, man!"
                    },
                    {
                        "username": "sergei99",
                        "content": "There is lots of cheating here. E.g. people open the output file (they somehow know its name) and write the hardcoded solution output from a static block executed prior to measurement stuff. So they get a really low execution time of their code, which is totally useless in solving real life problems."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "EASY   | |   USING SLOW & FAST POINTER\nconsider this example as you are in a circular racing track and there another person (he is faster then you ) , so if in 1second you go 1metre he in 1second goes 2meter, so now you start running and there will be a time where he will catch you from behind (as track is circular) if this happens then our list is circular else our list is not circular(consider the track was straight and the faster person finished the track but didn't overtake you as it was a straight track)\n\nNOTE:- there is no need to use 'pos' , our logic works fine.\n\n1. Check a base condition if list is empty or not.\n\n2. Initialize two pointer slow and fast to head.\n\n3. traverse the list and during each iteration move 'slow' 1 step ahead and move 'fast' 2 step ahead. And within this loop check if our slow and fast pointer are pointing to same node or not , if they are pointing to same node somewhere in the list then we got our cycle and return true.\n\n4. But even after loop termination if these two pointers didn't point same position then it is sure that they never met and we can say our list does not has any cycle.\n\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast!=NULL && fast->next !=NULL){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow==fast)\n                return true;\n        }\n        return false;\n    }\n};\n"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "My solution was to go throught entire LinkedList and keep saving the values in a list. If I come across any values in the linkedlist which is already present in the list I will return false. But for one of my test cases I can see 2 5s in the LL and pos = -1 the expected output is false. Why? Shouldn\\'t it be true?"
                    },
                    {
                        "username": "toanngo",
                        "content": "Instead of using a fast/slow pointer, you can just use one, and have a map that checks whether you\\'ve visited the node. In python, do something like `visited = {head:True}`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Think about 2 pointers where one moves one node at a time while the other moves 2 at a time. What will happen then??"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Ignore Pos . We can use fast and slow pointers or regular old reliable set."
                    },
                    {
                        "username": "Mouli_ch",
                        "content": "can anyone please explain the problem briefly"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "So, we need to find if there is a cycle in the linked list or not. In the explanation, they propose this pos argument in order to show that the \\'last\\' element of the linked list is pointing to. another element in the same list, creating then a infinite cycle in it. \\nSo our duty is to identify if a cycle exists in the leetcode tests."
                    },
                    {
                        "username": "jebbe",
                        "content": "As a beginner with JS, There is no way to log the head object to understand the linked list properties due to there being a cycle in the object. The third testcase is only one element.    \\nIncluding a longer true testcase would be more beginner friendly for me :)"
                    }
                ]
            },
            {
                "id": 2053519,
                "content": [
                    {
                        "username": "AayushSrivastav29",
                        "content": "Make two pointers-\\n1) fast; which travels two nodes at once\\n2) slow; which travels one node at a time. \\nat any future node they will meet bcz its a circle, then return true, otherwise false."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "runtime error although the cases are passed in the test runs,  any idea?  thanks\n\nattributeError: 'NoneType' object has no attribute 'next'\n    fast=head.next\nLine 29 in hasCycle (Solution.py)\n    ret = Solution().hasCycle(param_1)\nLine 61 in _driver (Solution.py)\n    _driver()\nLine 74 in <module> (Solution.py)"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) oh yeah, I missed a small test case lol. Updated the answer."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) I copied and pasted your code,  it got the same error.\\n"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) This is a rather simple but confusing error. \nThis code would fail for the testcases:\n```\n[1,2,3]\n-1\n[]\n-1\n```\n\nYou initialized the fast pointer to `head.next` (in this case 2), incremented fast twice (now pointing at `None`). Now `while` tries to call `fast.next` which is `None.next` and hence the error. Set both to `head` at first but then don't forget to reorder the if statement to increment pointers and then check and check if `fast` is not `None` in the `while` loop.\n `slow.next` can never be `None` (why? because `fast` would've already got there), instead you should be checking whether `fast` is `None`.\n\nAlso, check if `slow` is same as `fast` instead of checking if they are equal. Because some test cases have repeated values, but they are not the same node. Example test case:\n```\n[1,2,3,2,4]\n-1\n```\n\nFixed code:\n```python\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow=head\n        fast=head\n        while fast and fast.next:\n            # print('here')\n            slow=slow.next\n            fast=fast.next.next\n            if(slow==fast):\n                return True\n                \n        return False\n```\n\nHope this helps. \n"
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) # Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\n\\n\\n# Time complexity is O(N) \\n# Space Complexity is O(1)\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow=head\\n        fast=head.next\\n\\n        while(slow.next!=None and fast.next!=None):\\n            # print(\\'here\\')\\n            if(slow.val==fast.val):\\n                return True\\n            else:\\n                slow=slow.next\\n                fast=fast.next.next\\n        return False"
                    },
                    {
                        "username": "parapsychic",
                        "content": "you are calling next on a NoneType. If you could post the code, I can check. It\\'s usually because you reached the end of the list and still called next which returns a None, but then you call next again on that None."
                    },
                    {
                        "username": "parapsychic",
                        "content": "So, I was looking at some of the best memory efficient solution and I found that they just took the `pos` variable and returned true or false. Isn\\'t that cheating? I think those submissions should be removed.\\n[sample of cheating](https://imgur.com/yo6IPk2)"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Don\\'t worry. Practice for your own self-improvement. People who cheat are harming themselves. They won\\'t gain anything. Just keep improving, man!"
                    },
                    {
                        "username": "sergei99",
                        "content": "There is lots of cheating here. E.g. people open the output file (they somehow know its name) and write the hardcoded solution output from a static block executed prior to measurement stuff. So they get a really low execution time of their code, which is totally useless in solving real life problems."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "EASY   | |   USING SLOW & FAST POINTER\nconsider this example as you are in a circular racing track and there another person (he is faster then you ) , so if in 1second you go 1metre he in 1second goes 2meter, so now you start running and there will be a time where he will catch you from behind (as track is circular) if this happens then our list is circular else our list is not circular(consider the track was straight and the faster person finished the track but didn't overtake you as it was a straight track)\n\nNOTE:- there is no need to use 'pos' , our logic works fine.\n\n1. Check a base condition if list is empty or not.\n\n2. Initialize two pointer slow and fast to head.\n\n3. traverse the list and during each iteration move 'slow' 1 step ahead and move 'fast' 2 step ahead. And within this loop check if our slow and fast pointer are pointing to same node or not , if they are pointing to same node somewhere in the list then we got our cycle and return true.\n\n4. But even after loop termination if these two pointers didn't point same position then it is sure that they never met and we can say our list does not has any cycle.\n\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast!=NULL && fast->next !=NULL){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow==fast)\n                return true;\n        }\n        return false;\n    }\n};\n"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "My solution was to go throught entire LinkedList and keep saving the values in a list. If I come across any values in the linkedlist which is already present in the list I will return false. But for one of my test cases I can see 2 5s in the LL and pos = -1 the expected output is false. Why? Shouldn\\'t it be true?"
                    },
                    {
                        "username": "toanngo",
                        "content": "Instead of using a fast/slow pointer, you can just use one, and have a map that checks whether you\\'ve visited the node. In python, do something like `visited = {head:True}`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Think about 2 pointers where one moves one node at a time while the other moves 2 at a time. What will happen then??"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Ignore Pos . We can use fast and slow pointers or regular old reliable set."
                    },
                    {
                        "username": "Mouli_ch",
                        "content": "can anyone please explain the problem briefly"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "So, we need to find if there is a cycle in the linked list or not. In the explanation, they propose this pos argument in order to show that the \\'last\\' element of the linked list is pointing to. another element in the same list, creating then a infinite cycle in it. \\nSo our duty is to identify if a cycle exists in the leetcode tests."
                    },
                    {
                        "username": "jebbe",
                        "content": "As a beginner with JS, There is no way to log the head object to understand the linked list properties due to there being a cycle in the object. The third testcase is only one element.    \\nIncluding a longer true testcase would be more beginner friendly for me :)"
                    }
                ]
            },
            {
                "id": 2049018,
                "content": [
                    {
                        "username": "AayushSrivastav29",
                        "content": "Make two pointers-\\n1) fast; which travels two nodes at once\\n2) slow; which travels one node at a time. \\nat any future node they will meet bcz its a circle, then return true, otherwise false."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "runtime error although the cases are passed in the test runs,  any idea?  thanks\n\nattributeError: 'NoneType' object has no attribute 'next'\n    fast=head.next\nLine 29 in hasCycle (Solution.py)\n    ret = Solution().hasCycle(param_1)\nLine 61 in _driver (Solution.py)\n    _driver()\nLine 74 in <module> (Solution.py)"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) oh yeah, I missed a small test case lol. Updated the answer."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) I copied and pasted your code,  it got the same error.\\n"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) This is a rather simple but confusing error. \nThis code would fail for the testcases:\n```\n[1,2,3]\n-1\n[]\n-1\n```\n\nYou initialized the fast pointer to `head.next` (in this case 2), incremented fast twice (now pointing at `None`). Now `while` tries to call `fast.next` which is `None.next` and hence the error. Set both to `head` at first but then don't forget to reorder the if statement to increment pointers and then check and check if `fast` is not `None` in the `while` loop.\n `slow.next` can never be `None` (why? because `fast` would've already got there), instead you should be checking whether `fast` is `None`.\n\nAlso, check if `slow` is same as `fast` instead of checking if they are equal. Because some test cases have repeated values, but they are not the same node. Example test case:\n```\n[1,2,3,2,4]\n-1\n```\n\nFixed code:\n```python\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow=head\n        fast=head\n        while fast and fast.next:\n            # print('here')\n            slow=slow.next\n            fast=fast.next.next\n            if(slow==fast):\n                return True\n                \n        return False\n```\n\nHope this helps. \n"
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) # Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\n\\n\\n# Time complexity is O(N) \\n# Space Complexity is O(1)\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow=head\\n        fast=head.next\\n\\n        while(slow.next!=None and fast.next!=None):\\n            # print(\\'here\\')\\n            if(slow.val==fast.val):\\n                return True\\n            else:\\n                slow=slow.next\\n                fast=fast.next.next\\n        return False"
                    },
                    {
                        "username": "parapsychic",
                        "content": "you are calling next on a NoneType. If you could post the code, I can check. It\\'s usually because you reached the end of the list and still called next which returns a None, but then you call next again on that None."
                    },
                    {
                        "username": "parapsychic",
                        "content": "So, I was looking at some of the best memory efficient solution and I found that they just took the `pos` variable and returned true or false. Isn\\'t that cheating? I think those submissions should be removed.\\n[sample of cheating](https://imgur.com/yo6IPk2)"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Don\\'t worry. Practice for your own self-improvement. People who cheat are harming themselves. They won\\'t gain anything. Just keep improving, man!"
                    },
                    {
                        "username": "sergei99",
                        "content": "There is lots of cheating here. E.g. people open the output file (they somehow know its name) and write the hardcoded solution output from a static block executed prior to measurement stuff. So they get a really low execution time of their code, which is totally useless in solving real life problems."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "EASY   | |   USING SLOW & FAST POINTER\nconsider this example as you are in a circular racing track and there another person (he is faster then you ) , so if in 1second you go 1metre he in 1second goes 2meter, so now you start running and there will be a time where he will catch you from behind (as track is circular) if this happens then our list is circular else our list is not circular(consider the track was straight and the faster person finished the track but didn't overtake you as it was a straight track)\n\nNOTE:- there is no need to use 'pos' , our logic works fine.\n\n1. Check a base condition if list is empty or not.\n\n2. Initialize two pointer slow and fast to head.\n\n3. traverse the list and during each iteration move 'slow' 1 step ahead and move 'fast' 2 step ahead. And within this loop check if our slow and fast pointer are pointing to same node or not , if they are pointing to same node somewhere in the list then we got our cycle and return true.\n\n4. But even after loop termination if these two pointers didn't point same position then it is sure that they never met and we can say our list does not has any cycle.\n\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast!=NULL && fast->next !=NULL){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow==fast)\n                return true;\n        }\n        return false;\n    }\n};\n"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "My solution was to go throught entire LinkedList and keep saving the values in a list. If I come across any values in the linkedlist which is already present in the list I will return false. But for one of my test cases I can see 2 5s in the LL and pos = -1 the expected output is false. Why? Shouldn\\'t it be true?"
                    },
                    {
                        "username": "toanngo",
                        "content": "Instead of using a fast/slow pointer, you can just use one, and have a map that checks whether you\\'ve visited the node. In python, do something like `visited = {head:True}`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Think about 2 pointers where one moves one node at a time while the other moves 2 at a time. What will happen then??"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Ignore Pos . We can use fast and slow pointers or regular old reliable set."
                    },
                    {
                        "username": "Mouli_ch",
                        "content": "can anyone please explain the problem briefly"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "So, we need to find if there is a cycle in the linked list or not. In the explanation, they propose this pos argument in order to show that the \\'last\\' element of the linked list is pointing to. another element in the same list, creating then a infinite cycle in it. \\nSo our duty is to identify if a cycle exists in the leetcode tests."
                    },
                    {
                        "username": "jebbe",
                        "content": "As a beginner with JS, There is no way to log the head object to understand the linked list properties due to there being a cycle in the object. The third testcase is only one element.    \\nIncluding a longer true testcase would be more beginner friendly for me :)"
                    }
                ]
            },
            {
                "id": 2046422,
                "content": [
                    {
                        "username": "AayushSrivastav29",
                        "content": "Make two pointers-\\n1) fast; which travels two nodes at once\\n2) slow; which travels one node at a time. \\nat any future node they will meet bcz its a circle, then return true, otherwise false."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "runtime error although the cases are passed in the test runs,  any idea?  thanks\n\nattributeError: 'NoneType' object has no attribute 'next'\n    fast=head.next\nLine 29 in hasCycle (Solution.py)\n    ret = Solution().hasCycle(param_1)\nLine 61 in _driver (Solution.py)\n    _driver()\nLine 74 in <module> (Solution.py)"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) oh yeah, I missed a small test case lol. Updated the answer."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) I copied and pasted your code,  it got the same error.\\n"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) This is a rather simple but confusing error. \nThis code would fail for the testcases:\n```\n[1,2,3]\n-1\n[]\n-1\n```\n\nYou initialized the fast pointer to `head.next` (in this case 2), incremented fast twice (now pointing at `None`). Now `while` tries to call `fast.next` which is `None.next` and hence the error. Set both to `head` at first but then don't forget to reorder the if statement to increment pointers and then check and check if `fast` is not `None` in the `while` loop.\n `slow.next` can never be `None` (why? because `fast` would've already got there), instead you should be checking whether `fast` is `None`.\n\nAlso, check if `slow` is same as `fast` instead of checking if they are equal. Because some test cases have repeated values, but they are not the same node. Example test case:\n```\n[1,2,3,2,4]\n-1\n```\n\nFixed code:\n```python\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow=head\n        fast=head\n        while fast and fast.next:\n            # print('here')\n            slow=slow.next\n            fast=fast.next.next\n            if(slow==fast):\n                return True\n                \n        return False\n```\n\nHope this helps. \n"
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) # Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\n\\n\\n# Time complexity is O(N) \\n# Space Complexity is O(1)\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow=head\\n        fast=head.next\\n\\n        while(slow.next!=None and fast.next!=None):\\n            # print(\\'here\\')\\n            if(slow.val==fast.val):\\n                return True\\n            else:\\n                slow=slow.next\\n                fast=fast.next.next\\n        return False"
                    },
                    {
                        "username": "parapsychic",
                        "content": "you are calling next on a NoneType. If you could post the code, I can check. It\\'s usually because you reached the end of the list and still called next which returns a None, but then you call next again on that None."
                    },
                    {
                        "username": "parapsychic",
                        "content": "So, I was looking at some of the best memory efficient solution and I found that they just took the `pos` variable and returned true or false. Isn\\'t that cheating? I think those submissions should be removed.\\n[sample of cheating](https://imgur.com/yo6IPk2)"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Don\\'t worry. Practice for your own self-improvement. People who cheat are harming themselves. They won\\'t gain anything. Just keep improving, man!"
                    },
                    {
                        "username": "sergei99",
                        "content": "There is lots of cheating here. E.g. people open the output file (they somehow know its name) and write the hardcoded solution output from a static block executed prior to measurement stuff. So they get a really low execution time of their code, which is totally useless in solving real life problems."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "EASY   | |   USING SLOW & FAST POINTER\nconsider this example as you are in a circular racing track and there another person (he is faster then you ) , so if in 1second you go 1metre he in 1second goes 2meter, so now you start running and there will be a time where he will catch you from behind (as track is circular) if this happens then our list is circular else our list is not circular(consider the track was straight and the faster person finished the track but didn't overtake you as it was a straight track)\n\nNOTE:- there is no need to use 'pos' , our logic works fine.\n\n1. Check a base condition if list is empty or not.\n\n2. Initialize two pointer slow and fast to head.\n\n3. traverse the list and during each iteration move 'slow' 1 step ahead and move 'fast' 2 step ahead. And within this loop check if our slow and fast pointer are pointing to same node or not , if they are pointing to same node somewhere in the list then we got our cycle and return true.\n\n4. But even after loop termination if these two pointers didn't point same position then it is sure that they never met and we can say our list does not has any cycle.\n\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast!=NULL && fast->next !=NULL){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow==fast)\n                return true;\n        }\n        return false;\n    }\n};\n"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "My solution was to go throught entire LinkedList and keep saving the values in a list. If I come across any values in the linkedlist which is already present in the list I will return false. But for one of my test cases I can see 2 5s in the LL and pos = -1 the expected output is false. Why? Shouldn\\'t it be true?"
                    },
                    {
                        "username": "toanngo",
                        "content": "Instead of using a fast/slow pointer, you can just use one, and have a map that checks whether you\\'ve visited the node. In python, do something like `visited = {head:True}`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Think about 2 pointers where one moves one node at a time while the other moves 2 at a time. What will happen then??"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Ignore Pos . We can use fast and slow pointers or regular old reliable set."
                    },
                    {
                        "username": "Mouli_ch",
                        "content": "can anyone please explain the problem briefly"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "So, we need to find if there is a cycle in the linked list or not. In the explanation, they propose this pos argument in order to show that the \\'last\\' element of the linked list is pointing to. another element in the same list, creating then a infinite cycle in it. \\nSo our duty is to identify if a cycle exists in the leetcode tests."
                    },
                    {
                        "username": "jebbe",
                        "content": "As a beginner with JS, There is no way to log the head object to understand the linked list properties due to there being a cycle in the object. The third testcase is only one element.    \\nIncluding a longer true testcase would be more beginner friendly for me :)"
                    }
                ]
            },
            {
                "id": 2045565,
                "content": [
                    {
                        "username": "AayushSrivastav29",
                        "content": "Make two pointers-\\n1) fast; which travels two nodes at once\\n2) slow; which travels one node at a time. \\nat any future node they will meet bcz its a circle, then return true, otherwise false."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "runtime error although the cases are passed in the test runs,  any idea?  thanks\n\nattributeError: 'NoneType' object has no attribute 'next'\n    fast=head.next\nLine 29 in hasCycle (Solution.py)\n    ret = Solution().hasCycle(param_1)\nLine 61 in _driver (Solution.py)\n    _driver()\nLine 74 in <module> (Solution.py)"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) oh yeah, I missed a small test case lol. Updated the answer."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) I copied and pasted your code,  it got the same error.\\n"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) This is a rather simple but confusing error. \nThis code would fail for the testcases:\n```\n[1,2,3]\n-1\n[]\n-1\n```\n\nYou initialized the fast pointer to `head.next` (in this case 2), incremented fast twice (now pointing at `None`). Now `while` tries to call `fast.next` which is `None.next` and hence the error. Set both to `head` at first but then don't forget to reorder the if statement to increment pointers and then check and check if `fast` is not `None` in the `while` loop.\n `slow.next` can never be `None` (why? because `fast` would've already got there), instead you should be checking whether `fast` is `None`.\n\nAlso, check if `slow` is same as `fast` instead of checking if they are equal. Because some test cases have repeated values, but they are not the same node. Example test case:\n```\n[1,2,3,2,4]\n-1\n```\n\nFixed code:\n```python\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow=head\n        fast=head\n        while fast and fast.next:\n            # print('here')\n            slow=slow.next\n            fast=fast.next.next\n            if(slow==fast):\n                return True\n                \n        return False\n```\n\nHope this helps. \n"
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) # Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\n\\n\\n# Time complexity is O(N) \\n# Space Complexity is O(1)\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow=head\\n        fast=head.next\\n\\n        while(slow.next!=None and fast.next!=None):\\n            # print(\\'here\\')\\n            if(slow.val==fast.val):\\n                return True\\n            else:\\n                slow=slow.next\\n                fast=fast.next.next\\n        return False"
                    },
                    {
                        "username": "parapsychic",
                        "content": "you are calling next on a NoneType. If you could post the code, I can check. It\\'s usually because you reached the end of the list and still called next which returns a None, but then you call next again on that None."
                    },
                    {
                        "username": "parapsychic",
                        "content": "So, I was looking at some of the best memory efficient solution and I found that they just took the `pos` variable and returned true or false. Isn\\'t that cheating? I think those submissions should be removed.\\n[sample of cheating](https://imgur.com/yo6IPk2)"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Don\\'t worry. Practice for your own self-improvement. People who cheat are harming themselves. They won\\'t gain anything. Just keep improving, man!"
                    },
                    {
                        "username": "sergei99",
                        "content": "There is lots of cheating here. E.g. people open the output file (they somehow know its name) and write the hardcoded solution output from a static block executed prior to measurement stuff. So they get a really low execution time of their code, which is totally useless in solving real life problems."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "EASY   | |   USING SLOW & FAST POINTER\nconsider this example as you are in a circular racing track and there another person (he is faster then you ) , so if in 1second you go 1metre he in 1second goes 2meter, so now you start running and there will be a time where he will catch you from behind (as track is circular) if this happens then our list is circular else our list is not circular(consider the track was straight and the faster person finished the track but didn't overtake you as it was a straight track)\n\nNOTE:- there is no need to use 'pos' , our logic works fine.\n\n1. Check a base condition if list is empty or not.\n\n2. Initialize two pointer slow and fast to head.\n\n3. traverse the list and during each iteration move 'slow' 1 step ahead and move 'fast' 2 step ahead. And within this loop check if our slow and fast pointer are pointing to same node or not , if they are pointing to same node somewhere in the list then we got our cycle and return true.\n\n4. But even after loop termination if these two pointers didn't point same position then it is sure that they never met and we can say our list does not has any cycle.\n\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast!=NULL && fast->next !=NULL){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow==fast)\n                return true;\n        }\n        return false;\n    }\n};\n"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "My solution was to go throught entire LinkedList and keep saving the values in a list. If I come across any values in the linkedlist which is already present in the list I will return false. But for one of my test cases I can see 2 5s in the LL and pos = -1 the expected output is false. Why? Shouldn\\'t it be true?"
                    },
                    {
                        "username": "toanngo",
                        "content": "Instead of using a fast/slow pointer, you can just use one, and have a map that checks whether you\\'ve visited the node. In python, do something like `visited = {head:True}`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Think about 2 pointers where one moves one node at a time while the other moves 2 at a time. What will happen then??"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Ignore Pos . We can use fast and slow pointers or regular old reliable set."
                    },
                    {
                        "username": "Mouli_ch",
                        "content": "can anyone please explain the problem briefly"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "So, we need to find if there is a cycle in the linked list or not. In the explanation, they propose this pos argument in order to show that the \\'last\\' element of the linked list is pointing to. another element in the same list, creating then a infinite cycle in it. \\nSo our duty is to identify if a cycle exists in the leetcode tests."
                    },
                    {
                        "username": "jebbe",
                        "content": "As a beginner with JS, There is no way to log the head object to understand the linked list properties due to there being a cycle in the object. The third testcase is only one element.    \\nIncluding a longer true testcase would be more beginner friendly for me :)"
                    }
                ]
            },
            {
                "id": 2044423,
                "content": [
                    {
                        "username": "AayushSrivastav29",
                        "content": "Make two pointers-\\n1) fast; which travels two nodes at once\\n2) slow; which travels one node at a time. \\nat any future node they will meet bcz its a circle, then return true, otherwise false."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "runtime error although the cases are passed in the test runs,  any idea?  thanks\n\nattributeError: 'NoneType' object has no attribute 'next'\n    fast=head.next\nLine 29 in hasCycle (Solution.py)\n    ret = Solution().hasCycle(param_1)\nLine 61 in _driver (Solution.py)\n    _driver()\nLine 74 in <module> (Solution.py)"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) oh yeah, I missed a small test case lol. Updated the answer."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) I copied and pasted your code,  it got the same error.\\n"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) This is a rather simple but confusing error. \nThis code would fail for the testcases:\n```\n[1,2,3]\n-1\n[]\n-1\n```\n\nYou initialized the fast pointer to `head.next` (in this case 2), incremented fast twice (now pointing at `None`). Now `while` tries to call `fast.next` which is `None.next` and hence the error. Set both to `head` at first but then don't forget to reorder the if statement to increment pointers and then check and check if `fast` is not `None` in the `while` loop.\n `slow.next` can never be `None` (why? because `fast` would've already got there), instead you should be checking whether `fast` is `None`.\n\nAlso, check if `slow` is same as `fast` instead of checking if they are equal. Because some test cases have repeated values, but they are not the same node. Example test case:\n```\n[1,2,3,2,4]\n-1\n```\n\nFixed code:\n```python\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow=head\n        fast=head\n        while fast and fast.next:\n            # print('here')\n            slow=slow.next\n            fast=fast.next.next\n            if(slow==fast):\n                return True\n                \n        return False\n```\n\nHope this helps. \n"
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) # Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\n\\n\\n# Time complexity is O(N) \\n# Space Complexity is O(1)\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow=head\\n        fast=head.next\\n\\n        while(slow.next!=None and fast.next!=None):\\n            # print(\\'here\\')\\n            if(slow.val==fast.val):\\n                return True\\n            else:\\n                slow=slow.next\\n                fast=fast.next.next\\n        return False"
                    },
                    {
                        "username": "parapsychic",
                        "content": "you are calling next on a NoneType. If you could post the code, I can check. It\\'s usually because you reached the end of the list and still called next which returns a None, but then you call next again on that None."
                    },
                    {
                        "username": "parapsychic",
                        "content": "So, I was looking at some of the best memory efficient solution and I found that they just took the `pos` variable and returned true or false. Isn\\'t that cheating? I think those submissions should be removed.\\n[sample of cheating](https://imgur.com/yo6IPk2)"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Don\\'t worry. Practice for your own self-improvement. People who cheat are harming themselves. They won\\'t gain anything. Just keep improving, man!"
                    },
                    {
                        "username": "sergei99",
                        "content": "There is lots of cheating here. E.g. people open the output file (they somehow know its name) and write the hardcoded solution output from a static block executed prior to measurement stuff. So they get a really low execution time of their code, which is totally useless in solving real life problems."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "EASY   | |   USING SLOW & FAST POINTER\nconsider this example as you are in a circular racing track and there another person (he is faster then you ) , so if in 1second you go 1metre he in 1second goes 2meter, so now you start running and there will be a time where he will catch you from behind (as track is circular) if this happens then our list is circular else our list is not circular(consider the track was straight and the faster person finished the track but didn't overtake you as it was a straight track)\n\nNOTE:- there is no need to use 'pos' , our logic works fine.\n\n1. Check a base condition if list is empty or not.\n\n2. Initialize two pointer slow and fast to head.\n\n3. traverse the list and during each iteration move 'slow' 1 step ahead and move 'fast' 2 step ahead. And within this loop check if our slow and fast pointer are pointing to same node or not , if they are pointing to same node somewhere in the list then we got our cycle and return true.\n\n4. But even after loop termination if these two pointers didn't point same position then it is sure that they never met and we can say our list does not has any cycle.\n\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast!=NULL && fast->next !=NULL){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow==fast)\n                return true;\n        }\n        return false;\n    }\n};\n"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "My solution was to go throught entire LinkedList and keep saving the values in a list. If I come across any values in the linkedlist which is already present in the list I will return false. But for one of my test cases I can see 2 5s in the LL and pos = -1 the expected output is false. Why? Shouldn\\'t it be true?"
                    },
                    {
                        "username": "toanngo",
                        "content": "Instead of using a fast/slow pointer, you can just use one, and have a map that checks whether you\\'ve visited the node. In python, do something like `visited = {head:True}`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Think about 2 pointers where one moves one node at a time while the other moves 2 at a time. What will happen then??"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Ignore Pos . We can use fast and slow pointers or regular old reliable set."
                    },
                    {
                        "username": "Mouli_ch",
                        "content": "can anyone please explain the problem briefly"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "So, we need to find if there is a cycle in the linked list or not. In the explanation, they propose this pos argument in order to show that the \\'last\\' element of the linked list is pointing to. another element in the same list, creating then a infinite cycle in it. \\nSo our duty is to identify if a cycle exists in the leetcode tests."
                    },
                    {
                        "username": "jebbe",
                        "content": "As a beginner with JS, There is no way to log the head object to understand the linked list properties due to there being a cycle in the object. The third testcase is only one element.    \\nIncluding a longer true testcase would be more beginner friendly for me :)"
                    }
                ]
            },
            {
                "id": 2044240,
                "content": [
                    {
                        "username": "AayushSrivastav29",
                        "content": "Make two pointers-\\n1) fast; which travels two nodes at once\\n2) slow; which travels one node at a time. \\nat any future node they will meet bcz its a circle, then return true, otherwise false."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "runtime error although the cases are passed in the test runs,  any idea?  thanks\n\nattributeError: 'NoneType' object has no attribute 'next'\n    fast=head.next\nLine 29 in hasCycle (Solution.py)\n    ret = Solution().hasCycle(param_1)\nLine 61 in _driver (Solution.py)\n    _driver()\nLine 74 in <module> (Solution.py)"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) oh yeah, I missed a small test case lol. Updated the answer."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) I copied and pasted your code,  it got the same error.\\n"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) This is a rather simple but confusing error. \nThis code would fail for the testcases:\n```\n[1,2,3]\n-1\n[]\n-1\n```\n\nYou initialized the fast pointer to `head.next` (in this case 2), incremented fast twice (now pointing at `None`). Now `while` tries to call `fast.next` which is `None.next` and hence the error. Set both to `head` at first but then don't forget to reorder the if statement to increment pointers and then check and check if `fast` is not `None` in the `while` loop.\n `slow.next` can never be `None` (why? because `fast` would've already got there), instead you should be checking whether `fast` is `None`.\n\nAlso, check if `slow` is same as `fast` instead of checking if they are equal. Because some test cases have repeated values, but they are not the same node. Example test case:\n```\n[1,2,3,2,4]\n-1\n```\n\nFixed code:\n```python\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow=head\n        fast=head\n        while fast and fast.next:\n            # print('here')\n            slow=slow.next\n            fast=fast.next.next\n            if(slow==fast):\n                return True\n                \n        return False\n```\n\nHope this helps. \n"
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) # Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\n\\n\\n# Time complexity is O(N) \\n# Space Complexity is O(1)\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow=head\\n        fast=head.next\\n\\n        while(slow.next!=None and fast.next!=None):\\n            # print(\\'here\\')\\n            if(slow.val==fast.val):\\n                return True\\n            else:\\n                slow=slow.next\\n                fast=fast.next.next\\n        return False"
                    },
                    {
                        "username": "parapsychic",
                        "content": "you are calling next on a NoneType. If you could post the code, I can check. It\\'s usually because you reached the end of the list and still called next which returns a None, but then you call next again on that None."
                    },
                    {
                        "username": "parapsychic",
                        "content": "So, I was looking at some of the best memory efficient solution and I found that they just took the `pos` variable and returned true or false. Isn\\'t that cheating? I think those submissions should be removed.\\n[sample of cheating](https://imgur.com/yo6IPk2)"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Don\\'t worry. Practice for your own self-improvement. People who cheat are harming themselves. They won\\'t gain anything. Just keep improving, man!"
                    },
                    {
                        "username": "sergei99",
                        "content": "There is lots of cheating here. E.g. people open the output file (they somehow know its name) and write the hardcoded solution output from a static block executed prior to measurement stuff. So they get a really low execution time of their code, which is totally useless in solving real life problems."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "EASY   | |   USING SLOW & FAST POINTER\nconsider this example as you are in a circular racing track and there another person (he is faster then you ) , so if in 1second you go 1metre he in 1second goes 2meter, so now you start running and there will be a time where he will catch you from behind (as track is circular) if this happens then our list is circular else our list is not circular(consider the track was straight and the faster person finished the track but didn't overtake you as it was a straight track)\n\nNOTE:- there is no need to use 'pos' , our logic works fine.\n\n1. Check a base condition if list is empty or not.\n\n2. Initialize two pointer slow and fast to head.\n\n3. traverse the list and during each iteration move 'slow' 1 step ahead and move 'fast' 2 step ahead. And within this loop check if our slow and fast pointer are pointing to same node or not , if they are pointing to same node somewhere in the list then we got our cycle and return true.\n\n4. But even after loop termination if these two pointers didn't point same position then it is sure that they never met and we can say our list does not has any cycle.\n\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast!=NULL && fast->next !=NULL){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow==fast)\n                return true;\n        }\n        return false;\n    }\n};\n"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "My solution was to go throught entire LinkedList and keep saving the values in a list. If I come across any values in the linkedlist which is already present in the list I will return false. But for one of my test cases I can see 2 5s in the LL and pos = -1 the expected output is false. Why? Shouldn\\'t it be true?"
                    },
                    {
                        "username": "toanngo",
                        "content": "Instead of using a fast/slow pointer, you can just use one, and have a map that checks whether you\\'ve visited the node. In python, do something like `visited = {head:True}`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Think about 2 pointers where one moves one node at a time while the other moves 2 at a time. What will happen then??"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Ignore Pos . We can use fast and slow pointers or regular old reliable set."
                    },
                    {
                        "username": "Mouli_ch",
                        "content": "can anyone please explain the problem briefly"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "So, we need to find if there is a cycle in the linked list or not. In the explanation, they propose this pos argument in order to show that the \\'last\\' element of the linked list is pointing to. another element in the same list, creating then a infinite cycle in it. \\nSo our duty is to identify if a cycle exists in the leetcode tests."
                    },
                    {
                        "username": "jebbe",
                        "content": "As a beginner with JS, There is no way to log the head object to understand the linked list properties due to there being a cycle in the object. The third testcase is only one element.    \\nIncluding a longer true testcase would be more beginner friendly for me :)"
                    }
                ]
            },
            {
                "id": 2044047,
                "content": [
                    {
                        "username": "AayushSrivastav29",
                        "content": "Make two pointers-\\n1) fast; which travels two nodes at once\\n2) slow; which travels one node at a time. \\nat any future node they will meet bcz its a circle, then return true, otherwise false."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "runtime error although the cases are passed in the test runs,  any idea?  thanks\n\nattributeError: 'NoneType' object has no attribute 'next'\n    fast=head.next\nLine 29 in hasCycle (Solution.py)\n    ret = Solution().hasCycle(param_1)\nLine 61 in _driver (Solution.py)\n    _driver()\nLine 74 in <module> (Solution.py)"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) oh yeah, I missed a small test case lol. Updated the answer."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) I copied and pasted your code,  it got the same error.\\n"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) This is a rather simple but confusing error. \nThis code would fail for the testcases:\n```\n[1,2,3]\n-1\n[]\n-1\n```\n\nYou initialized the fast pointer to `head.next` (in this case 2), incremented fast twice (now pointing at `None`). Now `while` tries to call `fast.next` which is `None.next` and hence the error. Set both to `head` at first but then don't forget to reorder the if statement to increment pointers and then check and check if `fast` is not `None` in the `while` loop.\n `slow.next` can never be `None` (why? because `fast` would've already got there), instead you should be checking whether `fast` is `None`.\n\nAlso, check if `slow` is same as `fast` instead of checking if they are equal. Because some test cases have repeated values, but they are not the same node. Example test case:\n```\n[1,2,3,2,4]\n-1\n```\n\nFixed code:\n```python\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow=head\n        fast=head\n        while fast and fast.next:\n            # print('here')\n            slow=slow.next\n            fast=fast.next.next\n            if(slow==fast):\n                return True\n                \n        return False\n```\n\nHope this helps. \n"
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) # Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\n\\n\\n# Time complexity is O(N) \\n# Space Complexity is O(1)\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow=head\\n        fast=head.next\\n\\n        while(slow.next!=None and fast.next!=None):\\n            # print(\\'here\\')\\n            if(slow.val==fast.val):\\n                return True\\n            else:\\n                slow=slow.next\\n                fast=fast.next.next\\n        return False"
                    },
                    {
                        "username": "parapsychic",
                        "content": "you are calling next on a NoneType. If you could post the code, I can check. It\\'s usually because you reached the end of the list and still called next which returns a None, but then you call next again on that None."
                    },
                    {
                        "username": "parapsychic",
                        "content": "So, I was looking at some of the best memory efficient solution and I found that they just took the `pos` variable and returned true or false. Isn\\'t that cheating? I think those submissions should be removed.\\n[sample of cheating](https://imgur.com/yo6IPk2)"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Don\\'t worry. Practice for your own self-improvement. People who cheat are harming themselves. They won\\'t gain anything. Just keep improving, man!"
                    },
                    {
                        "username": "sergei99",
                        "content": "There is lots of cheating here. E.g. people open the output file (they somehow know its name) and write the hardcoded solution output from a static block executed prior to measurement stuff. So they get a really low execution time of their code, which is totally useless in solving real life problems."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "EASY   | |   USING SLOW & FAST POINTER\nconsider this example as you are in a circular racing track and there another person (he is faster then you ) , so if in 1second you go 1metre he in 1second goes 2meter, so now you start running and there will be a time where he will catch you from behind (as track is circular) if this happens then our list is circular else our list is not circular(consider the track was straight and the faster person finished the track but didn't overtake you as it was a straight track)\n\nNOTE:- there is no need to use 'pos' , our logic works fine.\n\n1. Check a base condition if list is empty or not.\n\n2. Initialize two pointer slow and fast to head.\n\n3. traverse the list and during each iteration move 'slow' 1 step ahead and move 'fast' 2 step ahead. And within this loop check if our slow and fast pointer are pointing to same node or not , if they are pointing to same node somewhere in the list then we got our cycle and return true.\n\n4. But even after loop termination if these two pointers didn't point same position then it is sure that they never met and we can say our list does not has any cycle.\n\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast!=NULL && fast->next !=NULL){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow==fast)\n                return true;\n        }\n        return false;\n    }\n};\n"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "My solution was to go throught entire LinkedList and keep saving the values in a list. If I come across any values in the linkedlist which is already present in the list I will return false. But for one of my test cases I can see 2 5s in the LL and pos = -1 the expected output is false. Why? Shouldn\\'t it be true?"
                    },
                    {
                        "username": "toanngo",
                        "content": "Instead of using a fast/slow pointer, you can just use one, and have a map that checks whether you\\'ve visited the node. In python, do something like `visited = {head:True}`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Think about 2 pointers where one moves one node at a time while the other moves 2 at a time. What will happen then??"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Ignore Pos . We can use fast and slow pointers or regular old reliable set."
                    },
                    {
                        "username": "Mouli_ch",
                        "content": "can anyone please explain the problem briefly"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "So, we need to find if there is a cycle in the linked list or not. In the explanation, they propose this pos argument in order to show that the \\'last\\' element of the linked list is pointing to. another element in the same list, creating then a infinite cycle in it. \\nSo our duty is to identify if a cycle exists in the leetcode tests."
                    },
                    {
                        "username": "jebbe",
                        "content": "As a beginner with JS, There is no way to log the head object to understand the linked list properties due to there being a cycle in the object. The third testcase is only one element.    \\nIncluding a longer true testcase would be more beginner friendly for me :)"
                    }
                ]
            },
            {
                "id": 2044042,
                "content": [
                    {
                        "username": "AayushSrivastav29",
                        "content": "Make two pointers-\\n1) fast; which travels two nodes at once\\n2) slow; which travels one node at a time. \\nat any future node they will meet bcz its a circle, then return true, otherwise false."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "runtime error although the cases are passed in the test runs,  any idea?  thanks\n\nattributeError: 'NoneType' object has no attribute 'next'\n    fast=head.next\nLine 29 in hasCycle (Solution.py)\n    ret = Solution().hasCycle(param_1)\nLine 61 in _driver (Solution.py)\n    _driver()\nLine 74 in <module> (Solution.py)"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) oh yeah, I missed a small test case lol. Updated the answer."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) I copied and pasted your code,  it got the same error.\\n"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) This is a rather simple but confusing error. \nThis code would fail for the testcases:\n```\n[1,2,3]\n-1\n[]\n-1\n```\n\nYou initialized the fast pointer to `head.next` (in this case 2), incremented fast twice (now pointing at `None`). Now `while` tries to call `fast.next` which is `None.next` and hence the error. Set both to `head` at first but then don't forget to reorder the if statement to increment pointers and then check and check if `fast` is not `None` in the `while` loop.\n `slow.next` can never be `None` (why? because `fast` would've already got there), instead you should be checking whether `fast` is `None`.\n\nAlso, check if `slow` is same as `fast` instead of checking if they are equal. Because some test cases have repeated values, but they are not the same node. Example test case:\n```\n[1,2,3,2,4]\n-1\n```\n\nFixed code:\n```python\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow=head\n        fast=head\n        while fast and fast.next:\n            # print('here')\n            slow=slow.next\n            fast=fast.next.next\n            if(slow==fast):\n                return True\n                \n        return False\n```\n\nHope this helps. \n"
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) # Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\n\\n\\n# Time complexity is O(N) \\n# Space Complexity is O(1)\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow=head\\n        fast=head.next\\n\\n        while(slow.next!=None and fast.next!=None):\\n            # print(\\'here\\')\\n            if(slow.val==fast.val):\\n                return True\\n            else:\\n                slow=slow.next\\n                fast=fast.next.next\\n        return False"
                    },
                    {
                        "username": "parapsychic",
                        "content": "you are calling next on a NoneType. If you could post the code, I can check. It\\'s usually because you reached the end of the list and still called next which returns a None, but then you call next again on that None."
                    },
                    {
                        "username": "parapsychic",
                        "content": "So, I was looking at some of the best memory efficient solution and I found that they just took the `pos` variable and returned true or false. Isn\\'t that cheating? I think those submissions should be removed.\\n[sample of cheating](https://imgur.com/yo6IPk2)"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Don\\'t worry. Practice for your own self-improvement. People who cheat are harming themselves. They won\\'t gain anything. Just keep improving, man!"
                    },
                    {
                        "username": "sergei99",
                        "content": "There is lots of cheating here. E.g. people open the output file (they somehow know its name) and write the hardcoded solution output from a static block executed prior to measurement stuff. So they get a really low execution time of their code, which is totally useless in solving real life problems."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "EASY   | |   USING SLOW & FAST POINTER\nconsider this example as you are in a circular racing track and there another person (he is faster then you ) , so if in 1second you go 1metre he in 1second goes 2meter, so now you start running and there will be a time where he will catch you from behind (as track is circular) if this happens then our list is circular else our list is not circular(consider the track was straight and the faster person finished the track but didn't overtake you as it was a straight track)\n\nNOTE:- there is no need to use 'pos' , our logic works fine.\n\n1. Check a base condition if list is empty or not.\n\n2. Initialize two pointer slow and fast to head.\n\n3. traverse the list and during each iteration move 'slow' 1 step ahead and move 'fast' 2 step ahead. And within this loop check if our slow and fast pointer are pointing to same node or not , if they are pointing to same node somewhere in the list then we got our cycle and return true.\n\n4. But even after loop termination if these two pointers didn't point same position then it is sure that they never met and we can say our list does not has any cycle.\n\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast!=NULL && fast->next !=NULL){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow==fast)\n                return true;\n        }\n        return false;\n    }\n};\n"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "My solution was to go throught entire LinkedList and keep saving the values in a list. If I come across any values in the linkedlist which is already present in the list I will return false. But for one of my test cases I can see 2 5s in the LL and pos = -1 the expected output is false. Why? Shouldn\\'t it be true?"
                    },
                    {
                        "username": "toanngo",
                        "content": "Instead of using a fast/slow pointer, you can just use one, and have a map that checks whether you\\'ve visited the node. In python, do something like `visited = {head:True}`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Think about 2 pointers where one moves one node at a time while the other moves 2 at a time. What will happen then??"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Ignore Pos . We can use fast and slow pointers or regular old reliable set."
                    },
                    {
                        "username": "Mouli_ch",
                        "content": "can anyone please explain the problem briefly"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "So, we need to find if there is a cycle in the linked list or not. In the explanation, they propose this pos argument in order to show that the \\'last\\' element of the linked list is pointing to. another element in the same list, creating then a infinite cycle in it. \\nSo our duty is to identify if a cycle exists in the leetcode tests."
                    },
                    {
                        "username": "jebbe",
                        "content": "As a beginner with JS, There is no way to log the head object to understand the linked list properties due to there being a cycle in the object. The third testcase is only one element.    \\nIncluding a longer true testcase would be more beginner friendly for me :)"
                    }
                ]
            },
            {
                "id": 2043952,
                "content": [
                    {
                        "username": "julkar9",
                        "content": "I hate this kind of questions, its either you know the solution or don\\'t. There\\'s no in-between."
                    },
                    {
                        "username": "psionl0",
                        "content": "The fast and slow pointer technique is useful in a variety of linked list situations. It is worth while learning about it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "I\\'m not going to read the whole question just for \"Find cycle\""
                    },
                    {
                        "username": "katalma",
                        "content": "Beginning of the week, beginning of the month. I can believe I am smart. But in the end..."
                    },
                    {
                        "username": "sakibmondal7",
                        "content": "Just check the solution with minimum space under Python language.. They did some strange things.. \n\nThey edited the user response in backend with pos variable. I guess that is why `POS` is given.\n\nThis is cheatings at next level.. "
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "## there is no use of pos here ##\\n`\\nhead = [3,2,0,-4], pos = 3\\n`\\nWill pass the test case since refreance of last node is to pos 1 node"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Okay, so we all know the constant memory solution - but is there a different approach (that uses more than constant space) that also takes linear time? Best I can think of is quadratic."
                    },
                    {
                        "username": "aitachii",
                        "content": "Hash table/dictionary of ListNodes take up O(n) space. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Is LeetCode softening us up?"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Check out this testcase\n```\n[-158, -157, -156, -155, -154, -153, -152, -151, -150, -149, -148, -147, -146, -145, -144, -143, -142, -141, -140, -139, -138, -137, -136, -135, -134, -133, -132, -131, -130, -129, -128, -127, -126, -125, -124, -123, -122, -121, -120, -119, -118, -117, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -106, -105, -104, -103, -102, -101, -100, -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099, 4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, -500, -499, -498, -497, -496, -495, -494, -493, -492, -491, -490, -489, -488, -487, -486, -485, -484, -483, -482, -481, -480, -479, -478, -477, -476, -475, -474, -473, -472, -471, -470, -469, -468, -467, -466, -465, -464, -463, -462, -461, -460, -459, -458, -457, -456, -455, -454, -453, -452, -451, -450, -449, -448, -447, -446, -445, -444, -443, -442, -441, -440, -439, -438, -437, -436, -435, -434, -433, -432, -431, -430, -429, -428, -427, -426, -425, -424, -423, -422, -421, -420, -419, -418, -417, -416, -415, -414, -413, -412, -411, -410, -409, -408, -407, -406, -405, -404, -403, -402, -401, -400, -399, -398, -397, -396, -395, -394, -393, -392, -391, -390, -389, -388, -387, -386, -385, -384, -383, -382, -381, -380, -379, -378, -377, -376, -375, -374, -373, -372, -371, -370, -369, -368, -367, -366, -365, -364, -363, -362, -361, -360, -359, -358, -357, -356, -355, -354, -353, -352, -351, -350, -349, -348, -347, -346, -345, -344, -343, -342, -341, -340, -339, -338, -337, -336, -335, -334, -333, -332, -331, -330, -329, -328, -327, -326, -325, -324, -323, -322, -321, -320, -319, -318, -317, -316, -315, -314, -313, -312, -311, -310, -309, -308, -307, -306, -305, -304, -303, -302, -301, -300, -299, -298, -297, -296, -295, -294, -293, -292, -291, -290, -289, -288, -287, -286, -285, -284, -283, -282, -281, -280, -279, -278, -277, -276, -275, -274, -273, -272, -271, -270, -269, -268, -267, -266, -265, -264, -263, -262, -261, -260, -259, -258, -257, -256, -255, -254, -253, -252, -251, -250, -249, -248, -247, -246, -245, -244, -243, -242, -241, -240, -239, -238, -237, -236, -235, -234, -233, -232, -231, -230, -229, -228, -227, -226, -225, -224, -223, -222, -221, -220, -219, -218, -217, -216, -215, -214, -213, -212, -211, -210, -209, -208, -207, -206, -205, -204, -203, -202, -201, -200, -199, -198, -197, -196, -195, -194, -193, -192, -191, -190, -189, -188, -187, -186, -185, -184, -183, -182, -181, -180, -179, -178, -177, -176, -175, -174, -173, -172, -171, -170, -169, -168, -167, -166, -165, -164, -163, -162, -161, -160, -159]\n0\n```\nand also this one\n```\n[1,2,1,2,1,2,1,2,1,2]\n-1\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, we need to find out cycle means cycle detection.\\nLet\\'s say Two people are running on a circle then definately they meet at any point. If they meet means cycle present. \\n\\n# Approach\\nSo, Here I will use Fast and Slow pointer (Two pointer approach).\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- When loop run slow pointer move step ahead while fast pointer move it\\'s double.\\n4- If both pointer meet at a particular point it means cycle present other no."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Forget the garbage task.\\n\\nRead the real one:\\nRetuen `True` for neighboring Nodes with equal values, otherwise `False`"
                    },
                    {
                        "username": "arshita129",
                        "content": "neighboring nodes with equal values?? We are not trying to see if neighboring nodes have equal values.\\n"
                    }
                ]
            },
            {
                "id": 2043939,
                "content": [
                    {
                        "username": "julkar9",
                        "content": "I hate this kind of questions, its either you know the solution or don\\'t. There\\'s no in-between."
                    },
                    {
                        "username": "psionl0",
                        "content": "The fast and slow pointer technique is useful in a variety of linked list situations. It is worth while learning about it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "I\\'m not going to read the whole question just for \"Find cycle\""
                    },
                    {
                        "username": "katalma",
                        "content": "Beginning of the week, beginning of the month. I can believe I am smart. But in the end..."
                    },
                    {
                        "username": "sakibmondal7",
                        "content": "Just check the solution with minimum space under Python language.. They did some strange things.. \n\nThey edited the user response in backend with pos variable. I guess that is why `POS` is given.\n\nThis is cheatings at next level.. "
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "## there is no use of pos here ##\\n`\\nhead = [3,2,0,-4], pos = 3\\n`\\nWill pass the test case since refreance of last node is to pos 1 node"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Okay, so we all know the constant memory solution - but is there a different approach (that uses more than constant space) that also takes linear time? Best I can think of is quadratic."
                    },
                    {
                        "username": "aitachii",
                        "content": "Hash table/dictionary of ListNodes take up O(n) space. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Is LeetCode softening us up?"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Check out this testcase\n```\n[-158, -157, -156, -155, -154, -153, -152, -151, -150, -149, -148, -147, -146, -145, -144, -143, -142, -141, -140, -139, -138, -137, -136, -135, -134, -133, -132, -131, -130, -129, -128, -127, -126, -125, -124, -123, -122, -121, -120, -119, -118, -117, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -106, -105, -104, -103, -102, -101, -100, -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099, 4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, -500, -499, -498, -497, -496, -495, -494, -493, -492, -491, -490, -489, -488, -487, -486, -485, -484, -483, -482, -481, -480, -479, -478, -477, -476, -475, -474, -473, -472, -471, -470, -469, -468, -467, -466, -465, -464, -463, -462, -461, -460, -459, -458, -457, -456, -455, -454, -453, -452, -451, -450, -449, -448, -447, -446, -445, -444, -443, -442, -441, -440, -439, -438, -437, -436, -435, -434, -433, -432, -431, -430, -429, -428, -427, -426, -425, -424, -423, -422, -421, -420, -419, -418, -417, -416, -415, -414, -413, -412, -411, -410, -409, -408, -407, -406, -405, -404, -403, -402, -401, -400, -399, -398, -397, -396, -395, -394, -393, -392, -391, -390, -389, -388, -387, -386, -385, -384, -383, -382, -381, -380, -379, -378, -377, -376, -375, -374, -373, -372, -371, -370, -369, -368, -367, -366, -365, -364, -363, -362, -361, -360, -359, -358, -357, -356, -355, -354, -353, -352, -351, -350, -349, -348, -347, -346, -345, -344, -343, -342, -341, -340, -339, -338, -337, -336, -335, -334, -333, -332, -331, -330, -329, -328, -327, -326, -325, -324, -323, -322, -321, -320, -319, -318, -317, -316, -315, -314, -313, -312, -311, -310, -309, -308, -307, -306, -305, -304, -303, -302, -301, -300, -299, -298, -297, -296, -295, -294, -293, -292, -291, -290, -289, -288, -287, -286, -285, -284, -283, -282, -281, -280, -279, -278, -277, -276, -275, -274, -273, -272, -271, -270, -269, -268, -267, -266, -265, -264, -263, -262, -261, -260, -259, -258, -257, -256, -255, -254, -253, -252, -251, -250, -249, -248, -247, -246, -245, -244, -243, -242, -241, -240, -239, -238, -237, -236, -235, -234, -233, -232, -231, -230, -229, -228, -227, -226, -225, -224, -223, -222, -221, -220, -219, -218, -217, -216, -215, -214, -213, -212, -211, -210, -209, -208, -207, -206, -205, -204, -203, -202, -201, -200, -199, -198, -197, -196, -195, -194, -193, -192, -191, -190, -189, -188, -187, -186, -185, -184, -183, -182, -181, -180, -179, -178, -177, -176, -175, -174, -173, -172, -171, -170, -169, -168, -167, -166, -165, -164, -163, -162, -161, -160, -159]\n0\n```\nand also this one\n```\n[1,2,1,2,1,2,1,2,1,2]\n-1\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, we need to find out cycle means cycle detection.\\nLet\\'s say Two people are running on a circle then definately they meet at any point. If they meet means cycle present. \\n\\n# Approach\\nSo, Here I will use Fast and Slow pointer (Two pointer approach).\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- When loop run slow pointer move step ahead while fast pointer move it\\'s double.\\n4- If both pointer meet at a particular point it means cycle present other no."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Forget the garbage task.\\n\\nRead the real one:\\nRetuen `True` for neighboring Nodes with equal values, otherwise `False`"
                    },
                    {
                        "username": "arshita129",
                        "content": "neighboring nodes with equal values?? We are not trying to see if neighboring nodes have equal values.\\n"
                    }
                ]
            },
            {
                "id": 2043842,
                "content": [
                    {
                        "username": "julkar9",
                        "content": "I hate this kind of questions, its either you know the solution or don\\'t. There\\'s no in-between."
                    },
                    {
                        "username": "psionl0",
                        "content": "The fast and slow pointer technique is useful in a variety of linked list situations. It is worth while learning about it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "I\\'m not going to read the whole question just for \"Find cycle\""
                    },
                    {
                        "username": "katalma",
                        "content": "Beginning of the week, beginning of the month. I can believe I am smart. But in the end..."
                    },
                    {
                        "username": "sakibmondal7",
                        "content": "Just check the solution with minimum space under Python language.. They did some strange things.. \n\nThey edited the user response in backend with pos variable. I guess that is why `POS` is given.\n\nThis is cheatings at next level.. "
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "## there is no use of pos here ##\\n`\\nhead = [3,2,0,-4], pos = 3\\n`\\nWill pass the test case since refreance of last node is to pos 1 node"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Okay, so we all know the constant memory solution - but is there a different approach (that uses more than constant space) that also takes linear time? Best I can think of is quadratic."
                    },
                    {
                        "username": "aitachii",
                        "content": "Hash table/dictionary of ListNodes take up O(n) space. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Is LeetCode softening us up?"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Check out this testcase\n```\n[-158, -157, -156, -155, -154, -153, -152, -151, -150, -149, -148, -147, -146, -145, -144, -143, -142, -141, -140, -139, -138, -137, -136, -135, -134, -133, -132, -131, -130, -129, -128, -127, -126, -125, -124, -123, -122, -121, -120, -119, -118, -117, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -106, -105, -104, -103, -102, -101, -100, -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099, 4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, -500, -499, -498, -497, -496, -495, -494, -493, -492, -491, -490, -489, -488, -487, -486, -485, -484, -483, -482, -481, -480, -479, -478, -477, -476, -475, -474, -473, -472, -471, -470, -469, -468, -467, -466, -465, -464, -463, -462, -461, -460, -459, -458, -457, -456, -455, -454, -453, -452, -451, -450, -449, -448, -447, -446, -445, -444, -443, -442, -441, -440, -439, -438, -437, -436, -435, -434, -433, -432, -431, -430, -429, -428, -427, -426, -425, -424, -423, -422, -421, -420, -419, -418, -417, -416, -415, -414, -413, -412, -411, -410, -409, -408, -407, -406, -405, -404, -403, -402, -401, -400, -399, -398, -397, -396, -395, -394, -393, -392, -391, -390, -389, -388, -387, -386, -385, -384, -383, -382, -381, -380, -379, -378, -377, -376, -375, -374, -373, -372, -371, -370, -369, -368, -367, -366, -365, -364, -363, -362, -361, -360, -359, -358, -357, -356, -355, -354, -353, -352, -351, -350, -349, -348, -347, -346, -345, -344, -343, -342, -341, -340, -339, -338, -337, -336, -335, -334, -333, -332, -331, -330, -329, -328, -327, -326, -325, -324, -323, -322, -321, -320, -319, -318, -317, -316, -315, -314, -313, -312, -311, -310, -309, -308, -307, -306, -305, -304, -303, -302, -301, -300, -299, -298, -297, -296, -295, -294, -293, -292, -291, -290, -289, -288, -287, -286, -285, -284, -283, -282, -281, -280, -279, -278, -277, -276, -275, -274, -273, -272, -271, -270, -269, -268, -267, -266, -265, -264, -263, -262, -261, -260, -259, -258, -257, -256, -255, -254, -253, -252, -251, -250, -249, -248, -247, -246, -245, -244, -243, -242, -241, -240, -239, -238, -237, -236, -235, -234, -233, -232, -231, -230, -229, -228, -227, -226, -225, -224, -223, -222, -221, -220, -219, -218, -217, -216, -215, -214, -213, -212, -211, -210, -209, -208, -207, -206, -205, -204, -203, -202, -201, -200, -199, -198, -197, -196, -195, -194, -193, -192, -191, -190, -189, -188, -187, -186, -185, -184, -183, -182, -181, -180, -179, -178, -177, -176, -175, -174, -173, -172, -171, -170, -169, -168, -167, -166, -165, -164, -163, -162, -161, -160, -159]\n0\n```\nand also this one\n```\n[1,2,1,2,1,2,1,2,1,2]\n-1\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, we need to find out cycle means cycle detection.\\nLet\\'s say Two people are running on a circle then definately they meet at any point. If they meet means cycle present. \\n\\n# Approach\\nSo, Here I will use Fast and Slow pointer (Two pointer approach).\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- When loop run slow pointer move step ahead while fast pointer move it\\'s double.\\n4- If both pointer meet at a particular point it means cycle present other no."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Forget the garbage task.\\n\\nRead the real one:\\nRetuen `True` for neighboring Nodes with equal values, otherwise `False`"
                    },
                    {
                        "username": "arshita129",
                        "content": "neighboring nodes with equal values?? We are not trying to see if neighboring nodes have equal values.\\n"
                    }
                ]
            },
            {
                "id": 2043654,
                "content": [
                    {
                        "username": "julkar9",
                        "content": "I hate this kind of questions, its either you know the solution or don\\'t. There\\'s no in-between."
                    },
                    {
                        "username": "psionl0",
                        "content": "The fast and slow pointer technique is useful in a variety of linked list situations. It is worth while learning about it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "I\\'m not going to read the whole question just for \"Find cycle\""
                    },
                    {
                        "username": "katalma",
                        "content": "Beginning of the week, beginning of the month. I can believe I am smart. But in the end..."
                    },
                    {
                        "username": "sakibmondal7",
                        "content": "Just check the solution with minimum space under Python language.. They did some strange things.. \n\nThey edited the user response in backend with pos variable. I guess that is why `POS` is given.\n\nThis is cheatings at next level.. "
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "## there is no use of pos here ##\\n`\\nhead = [3,2,0,-4], pos = 3\\n`\\nWill pass the test case since refreance of last node is to pos 1 node"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Okay, so we all know the constant memory solution - but is there a different approach (that uses more than constant space) that also takes linear time? Best I can think of is quadratic."
                    },
                    {
                        "username": "aitachii",
                        "content": "Hash table/dictionary of ListNodes take up O(n) space. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Is LeetCode softening us up?"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Check out this testcase\n```\n[-158, -157, -156, -155, -154, -153, -152, -151, -150, -149, -148, -147, -146, -145, -144, -143, -142, -141, -140, -139, -138, -137, -136, -135, -134, -133, -132, -131, -130, -129, -128, -127, -126, -125, -124, -123, -122, -121, -120, -119, -118, -117, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -106, -105, -104, -103, -102, -101, -100, -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099, 4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, -500, -499, -498, -497, -496, -495, -494, -493, -492, -491, -490, -489, -488, -487, -486, -485, -484, -483, -482, -481, -480, -479, -478, -477, -476, -475, -474, -473, -472, -471, -470, -469, -468, -467, -466, -465, -464, -463, -462, -461, -460, -459, -458, -457, -456, -455, -454, -453, -452, -451, -450, -449, -448, -447, -446, -445, -444, -443, -442, -441, -440, -439, -438, -437, -436, -435, -434, -433, -432, -431, -430, -429, -428, -427, -426, -425, -424, -423, -422, -421, -420, -419, -418, -417, -416, -415, -414, -413, -412, -411, -410, -409, -408, -407, -406, -405, -404, -403, -402, -401, -400, -399, -398, -397, -396, -395, -394, -393, -392, -391, -390, -389, -388, -387, -386, -385, -384, -383, -382, -381, -380, -379, -378, -377, -376, -375, -374, -373, -372, -371, -370, -369, -368, -367, -366, -365, -364, -363, -362, -361, -360, -359, -358, -357, -356, -355, -354, -353, -352, -351, -350, -349, -348, -347, -346, -345, -344, -343, -342, -341, -340, -339, -338, -337, -336, -335, -334, -333, -332, -331, -330, -329, -328, -327, -326, -325, -324, -323, -322, -321, -320, -319, -318, -317, -316, -315, -314, -313, -312, -311, -310, -309, -308, -307, -306, -305, -304, -303, -302, -301, -300, -299, -298, -297, -296, -295, -294, -293, -292, -291, -290, -289, -288, -287, -286, -285, -284, -283, -282, -281, -280, -279, -278, -277, -276, -275, -274, -273, -272, -271, -270, -269, -268, -267, -266, -265, -264, -263, -262, -261, -260, -259, -258, -257, -256, -255, -254, -253, -252, -251, -250, -249, -248, -247, -246, -245, -244, -243, -242, -241, -240, -239, -238, -237, -236, -235, -234, -233, -232, -231, -230, -229, -228, -227, -226, -225, -224, -223, -222, -221, -220, -219, -218, -217, -216, -215, -214, -213, -212, -211, -210, -209, -208, -207, -206, -205, -204, -203, -202, -201, -200, -199, -198, -197, -196, -195, -194, -193, -192, -191, -190, -189, -188, -187, -186, -185, -184, -183, -182, -181, -180, -179, -178, -177, -176, -175, -174, -173, -172, -171, -170, -169, -168, -167, -166, -165, -164, -163, -162, -161, -160, -159]\n0\n```\nand also this one\n```\n[1,2,1,2,1,2,1,2,1,2]\n-1\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, we need to find out cycle means cycle detection.\\nLet\\'s say Two people are running on a circle then definately they meet at any point. If they meet means cycle present. \\n\\n# Approach\\nSo, Here I will use Fast and Slow pointer (Two pointer approach).\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- When loop run slow pointer move step ahead while fast pointer move it\\'s double.\\n4- If both pointer meet at a particular point it means cycle present other no."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Forget the garbage task.\\n\\nRead the real one:\\nRetuen `True` for neighboring Nodes with equal values, otherwise `False`"
                    },
                    {
                        "username": "arshita129",
                        "content": "neighboring nodes with equal values?? We are not trying to see if neighboring nodes have equal values.\\n"
                    }
                ]
            },
            {
                "id": 2043653,
                "content": [
                    {
                        "username": "julkar9",
                        "content": "I hate this kind of questions, its either you know the solution or don\\'t. There\\'s no in-between."
                    },
                    {
                        "username": "psionl0",
                        "content": "The fast and slow pointer technique is useful in a variety of linked list situations. It is worth while learning about it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "I\\'m not going to read the whole question just for \"Find cycle\""
                    },
                    {
                        "username": "katalma",
                        "content": "Beginning of the week, beginning of the month. I can believe I am smart. But in the end..."
                    },
                    {
                        "username": "sakibmondal7",
                        "content": "Just check the solution with minimum space under Python language.. They did some strange things.. \n\nThey edited the user response in backend with pos variable. I guess that is why `POS` is given.\n\nThis is cheatings at next level.. "
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "## there is no use of pos here ##\\n`\\nhead = [3,2,0,-4], pos = 3\\n`\\nWill pass the test case since refreance of last node is to pos 1 node"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Okay, so we all know the constant memory solution - but is there a different approach (that uses more than constant space) that also takes linear time? Best I can think of is quadratic."
                    },
                    {
                        "username": "aitachii",
                        "content": "Hash table/dictionary of ListNodes take up O(n) space. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Is LeetCode softening us up?"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Check out this testcase\n```\n[-158, -157, -156, -155, -154, -153, -152, -151, -150, -149, -148, -147, -146, -145, -144, -143, -142, -141, -140, -139, -138, -137, -136, -135, -134, -133, -132, -131, -130, -129, -128, -127, -126, -125, -124, -123, -122, -121, -120, -119, -118, -117, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -106, -105, -104, -103, -102, -101, -100, -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099, 4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, -500, -499, -498, -497, -496, -495, -494, -493, -492, -491, -490, -489, -488, -487, -486, -485, -484, -483, -482, -481, -480, -479, -478, -477, -476, -475, -474, -473, -472, -471, -470, -469, -468, -467, -466, -465, -464, -463, -462, -461, -460, -459, -458, -457, -456, -455, -454, -453, -452, -451, -450, -449, -448, -447, -446, -445, -444, -443, -442, -441, -440, -439, -438, -437, -436, -435, -434, -433, -432, -431, -430, -429, -428, -427, -426, -425, -424, -423, -422, -421, -420, -419, -418, -417, -416, -415, -414, -413, -412, -411, -410, -409, -408, -407, -406, -405, -404, -403, -402, -401, -400, -399, -398, -397, -396, -395, -394, -393, -392, -391, -390, -389, -388, -387, -386, -385, -384, -383, -382, -381, -380, -379, -378, -377, -376, -375, -374, -373, -372, -371, -370, -369, -368, -367, -366, -365, -364, -363, -362, -361, -360, -359, -358, -357, -356, -355, -354, -353, -352, -351, -350, -349, -348, -347, -346, -345, -344, -343, -342, -341, -340, -339, -338, -337, -336, -335, -334, -333, -332, -331, -330, -329, -328, -327, -326, -325, -324, -323, -322, -321, -320, -319, -318, -317, -316, -315, -314, -313, -312, -311, -310, -309, -308, -307, -306, -305, -304, -303, -302, -301, -300, -299, -298, -297, -296, -295, -294, -293, -292, -291, -290, -289, -288, -287, -286, -285, -284, -283, -282, -281, -280, -279, -278, -277, -276, -275, -274, -273, -272, -271, -270, -269, -268, -267, -266, -265, -264, -263, -262, -261, -260, -259, -258, -257, -256, -255, -254, -253, -252, -251, -250, -249, -248, -247, -246, -245, -244, -243, -242, -241, -240, -239, -238, -237, -236, -235, -234, -233, -232, -231, -230, -229, -228, -227, -226, -225, -224, -223, -222, -221, -220, -219, -218, -217, -216, -215, -214, -213, -212, -211, -210, -209, -208, -207, -206, -205, -204, -203, -202, -201, -200, -199, -198, -197, -196, -195, -194, -193, -192, -191, -190, -189, -188, -187, -186, -185, -184, -183, -182, -181, -180, -179, -178, -177, -176, -175, -174, -173, -172, -171, -170, -169, -168, -167, -166, -165, -164, -163, -162, -161, -160, -159]\n0\n```\nand also this one\n```\n[1,2,1,2,1,2,1,2,1,2]\n-1\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, we need to find out cycle means cycle detection.\\nLet\\'s say Two people are running on a circle then definately they meet at any point. If they meet means cycle present. \\n\\n# Approach\\nSo, Here I will use Fast and Slow pointer (Two pointer approach).\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- When loop run slow pointer move step ahead while fast pointer move it\\'s double.\\n4- If both pointer meet at a particular point it means cycle present other no."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Forget the garbage task.\\n\\nRead the real one:\\nRetuen `True` for neighboring Nodes with equal values, otherwise `False`"
                    },
                    {
                        "username": "arshita129",
                        "content": "neighboring nodes with equal values?? We are not trying to see if neighboring nodes have equal values.\\n"
                    }
                ]
            },
            {
                "id": 2043635,
                "content": [
                    {
                        "username": "julkar9",
                        "content": "I hate this kind of questions, its either you know the solution or don\\'t. There\\'s no in-between."
                    },
                    {
                        "username": "psionl0",
                        "content": "The fast and slow pointer technique is useful in a variety of linked list situations. It is worth while learning about it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "I\\'m not going to read the whole question just for \"Find cycle\""
                    },
                    {
                        "username": "katalma",
                        "content": "Beginning of the week, beginning of the month. I can believe I am smart. But in the end..."
                    },
                    {
                        "username": "sakibmondal7",
                        "content": "Just check the solution with minimum space under Python language.. They did some strange things.. \n\nThey edited the user response in backend with pos variable. I guess that is why `POS` is given.\n\nThis is cheatings at next level.. "
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "## there is no use of pos here ##\\n`\\nhead = [3,2,0,-4], pos = 3\\n`\\nWill pass the test case since refreance of last node is to pos 1 node"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Okay, so we all know the constant memory solution - but is there a different approach (that uses more than constant space) that also takes linear time? Best I can think of is quadratic."
                    },
                    {
                        "username": "aitachii",
                        "content": "Hash table/dictionary of ListNodes take up O(n) space. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Is LeetCode softening us up?"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Check out this testcase\n```\n[-158, -157, -156, -155, -154, -153, -152, -151, -150, -149, -148, -147, -146, -145, -144, -143, -142, -141, -140, -139, -138, -137, -136, -135, -134, -133, -132, -131, -130, -129, -128, -127, -126, -125, -124, -123, -122, -121, -120, -119, -118, -117, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -106, -105, -104, -103, -102, -101, -100, -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099, 4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, -500, -499, -498, -497, -496, -495, -494, -493, -492, -491, -490, -489, -488, -487, -486, -485, -484, -483, -482, -481, -480, -479, -478, -477, -476, -475, -474, -473, -472, -471, -470, -469, -468, -467, -466, -465, -464, -463, -462, -461, -460, -459, -458, -457, -456, -455, -454, -453, -452, -451, -450, -449, -448, -447, -446, -445, -444, -443, -442, -441, -440, -439, -438, -437, -436, -435, -434, -433, -432, -431, -430, -429, -428, -427, -426, -425, -424, -423, -422, -421, -420, -419, -418, -417, -416, -415, -414, -413, -412, -411, -410, -409, -408, -407, -406, -405, -404, -403, -402, -401, -400, -399, -398, -397, -396, -395, -394, -393, -392, -391, -390, -389, -388, -387, -386, -385, -384, -383, -382, -381, -380, -379, -378, -377, -376, -375, -374, -373, -372, -371, -370, -369, -368, -367, -366, -365, -364, -363, -362, -361, -360, -359, -358, -357, -356, -355, -354, -353, -352, -351, -350, -349, -348, -347, -346, -345, -344, -343, -342, -341, -340, -339, -338, -337, -336, -335, -334, -333, -332, -331, -330, -329, -328, -327, -326, -325, -324, -323, -322, -321, -320, -319, -318, -317, -316, -315, -314, -313, -312, -311, -310, -309, -308, -307, -306, -305, -304, -303, -302, -301, -300, -299, -298, -297, -296, -295, -294, -293, -292, -291, -290, -289, -288, -287, -286, -285, -284, -283, -282, -281, -280, -279, -278, -277, -276, -275, -274, -273, -272, -271, -270, -269, -268, -267, -266, -265, -264, -263, -262, -261, -260, -259, -258, -257, -256, -255, -254, -253, -252, -251, -250, -249, -248, -247, -246, -245, -244, -243, -242, -241, -240, -239, -238, -237, -236, -235, -234, -233, -232, -231, -230, -229, -228, -227, -226, -225, -224, -223, -222, -221, -220, -219, -218, -217, -216, -215, -214, -213, -212, -211, -210, -209, -208, -207, -206, -205, -204, -203, -202, -201, -200, -199, -198, -197, -196, -195, -194, -193, -192, -191, -190, -189, -188, -187, -186, -185, -184, -183, -182, -181, -180, -179, -178, -177, -176, -175, -174, -173, -172, -171, -170, -169, -168, -167, -166, -165, -164, -163, -162, -161, -160, -159]\n0\n```\nand also this one\n```\n[1,2,1,2,1,2,1,2,1,2]\n-1\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, we need to find out cycle means cycle detection.\\nLet\\'s say Two people are running on a circle then definately they meet at any point. If they meet means cycle present. \\n\\n# Approach\\nSo, Here I will use Fast and Slow pointer (Two pointer approach).\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- When loop run slow pointer move step ahead while fast pointer move it\\'s double.\\n4- If both pointer meet at a particular point it means cycle present other no."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Forget the garbage task.\\n\\nRead the real one:\\nRetuen `True` for neighboring Nodes with equal values, otherwise `False`"
                    },
                    {
                        "username": "arshita129",
                        "content": "neighboring nodes with equal values?? We are not trying to see if neighboring nodes have equal values.\\n"
                    }
                ]
            },
            {
                "id": 2043419,
                "content": [
                    {
                        "username": "julkar9",
                        "content": "I hate this kind of questions, its either you know the solution or don\\'t. There\\'s no in-between."
                    },
                    {
                        "username": "psionl0",
                        "content": "The fast and slow pointer technique is useful in a variety of linked list situations. It is worth while learning about it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "I\\'m not going to read the whole question just for \"Find cycle\""
                    },
                    {
                        "username": "katalma",
                        "content": "Beginning of the week, beginning of the month. I can believe I am smart. But in the end..."
                    },
                    {
                        "username": "sakibmondal7",
                        "content": "Just check the solution with minimum space under Python language.. They did some strange things.. \n\nThey edited the user response in backend with pos variable. I guess that is why `POS` is given.\n\nThis is cheatings at next level.. "
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "## there is no use of pos here ##\\n`\\nhead = [3,2,0,-4], pos = 3\\n`\\nWill pass the test case since refreance of last node is to pos 1 node"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Okay, so we all know the constant memory solution - but is there a different approach (that uses more than constant space) that also takes linear time? Best I can think of is quadratic."
                    },
                    {
                        "username": "aitachii",
                        "content": "Hash table/dictionary of ListNodes take up O(n) space. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Is LeetCode softening us up?"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Check out this testcase\n```\n[-158, -157, -156, -155, -154, -153, -152, -151, -150, -149, -148, -147, -146, -145, -144, -143, -142, -141, -140, -139, -138, -137, -136, -135, -134, -133, -132, -131, -130, -129, -128, -127, -126, -125, -124, -123, -122, -121, -120, -119, -118, -117, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -106, -105, -104, -103, -102, -101, -100, -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099, 4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, -500, -499, -498, -497, -496, -495, -494, -493, -492, -491, -490, -489, -488, -487, -486, -485, -484, -483, -482, -481, -480, -479, -478, -477, -476, -475, -474, -473, -472, -471, -470, -469, -468, -467, -466, -465, -464, -463, -462, -461, -460, -459, -458, -457, -456, -455, -454, -453, -452, -451, -450, -449, -448, -447, -446, -445, -444, -443, -442, -441, -440, -439, -438, -437, -436, -435, -434, -433, -432, -431, -430, -429, -428, -427, -426, -425, -424, -423, -422, -421, -420, -419, -418, -417, -416, -415, -414, -413, -412, -411, -410, -409, -408, -407, -406, -405, -404, -403, -402, -401, -400, -399, -398, -397, -396, -395, -394, -393, -392, -391, -390, -389, -388, -387, -386, -385, -384, -383, -382, -381, -380, -379, -378, -377, -376, -375, -374, -373, -372, -371, -370, -369, -368, -367, -366, -365, -364, -363, -362, -361, -360, -359, -358, -357, -356, -355, -354, -353, -352, -351, -350, -349, -348, -347, -346, -345, -344, -343, -342, -341, -340, -339, -338, -337, -336, -335, -334, -333, -332, -331, -330, -329, -328, -327, -326, -325, -324, -323, -322, -321, -320, -319, -318, -317, -316, -315, -314, -313, -312, -311, -310, -309, -308, -307, -306, -305, -304, -303, -302, -301, -300, -299, -298, -297, -296, -295, -294, -293, -292, -291, -290, -289, -288, -287, -286, -285, -284, -283, -282, -281, -280, -279, -278, -277, -276, -275, -274, -273, -272, -271, -270, -269, -268, -267, -266, -265, -264, -263, -262, -261, -260, -259, -258, -257, -256, -255, -254, -253, -252, -251, -250, -249, -248, -247, -246, -245, -244, -243, -242, -241, -240, -239, -238, -237, -236, -235, -234, -233, -232, -231, -230, -229, -228, -227, -226, -225, -224, -223, -222, -221, -220, -219, -218, -217, -216, -215, -214, -213, -212, -211, -210, -209, -208, -207, -206, -205, -204, -203, -202, -201, -200, -199, -198, -197, -196, -195, -194, -193, -192, -191, -190, -189, -188, -187, -186, -185, -184, -183, -182, -181, -180, -179, -178, -177, -176, -175, -174, -173, -172, -171, -170, -169, -168, -167, -166, -165, -164, -163, -162, -161, -160, -159]\n0\n```\nand also this one\n```\n[1,2,1,2,1,2,1,2,1,2]\n-1\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, we need to find out cycle means cycle detection.\\nLet\\'s say Two people are running on a circle then definately they meet at any point. If they meet means cycle present. \\n\\n# Approach\\nSo, Here I will use Fast and Slow pointer (Two pointer approach).\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- When loop run slow pointer move step ahead while fast pointer move it\\'s double.\\n4- If both pointer meet at a particular point it means cycle present other no."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Forget the garbage task.\\n\\nRead the real one:\\nRetuen `True` for neighboring Nodes with equal values, otherwise `False`"
                    },
                    {
                        "username": "arshita129",
                        "content": "neighboring nodes with equal values?? We are not trying to see if neighboring nodes have equal values.\\n"
                    }
                ]
            },
            {
                "id": 2043410,
                "content": [
                    {
                        "username": "julkar9",
                        "content": "I hate this kind of questions, its either you know the solution or don\\'t. There\\'s no in-between."
                    },
                    {
                        "username": "psionl0",
                        "content": "The fast and slow pointer technique is useful in a variety of linked list situations. It is worth while learning about it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "I\\'m not going to read the whole question just for \"Find cycle\""
                    },
                    {
                        "username": "katalma",
                        "content": "Beginning of the week, beginning of the month. I can believe I am smart. But in the end..."
                    },
                    {
                        "username": "sakibmondal7",
                        "content": "Just check the solution with minimum space under Python language.. They did some strange things.. \n\nThey edited the user response in backend with pos variable. I guess that is why `POS` is given.\n\nThis is cheatings at next level.. "
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "## there is no use of pos here ##\\n`\\nhead = [3,2,0,-4], pos = 3\\n`\\nWill pass the test case since refreance of last node is to pos 1 node"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Okay, so we all know the constant memory solution - but is there a different approach (that uses more than constant space) that also takes linear time? Best I can think of is quadratic."
                    },
                    {
                        "username": "aitachii",
                        "content": "Hash table/dictionary of ListNodes take up O(n) space. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Is LeetCode softening us up?"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Check out this testcase\n```\n[-158, -157, -156, -155, -154, -153, -152, -151, -150, -149, -148, -147, -146, -145, -144, -143, -142, -141, -140, -139, -138, -137, -136, -135, -134, -133, -132, -131, -130, -129, -128, -127, -126, -125, -124, -123, -122, -121, -120, -119, -118, -117, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -106, -105, -104, -103, -102, -101, -100, -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099, 4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, -500, -499, -498, -497, -496, -495, -494, -493, -492, -491, -490, -489, -488, -487, -486, -485, -484, -483, -482, -481, -480, -479, -478, -477, -476, -475, -474, -473, -472, -471, -470, -469, -468, -467, -466, -465, -464, -463, -462, -461, -460, -459, -458, -457, -456, -455, -454, -453, -452, -451, -450, -449, -448, -447, -446, -445, -444, -443, -442, -441, -440, -439, -438, -437, -436, -435, -434, -433, -432, -431, -430, -429, -428, -427, -426, -425, -424, -423, -422, -421, -420, -419, -418, -417, -416, -415, -414, -413, -412, -411, -410, -409, -408, -407, -406, -405, -404, -403, -402, -401, -400, -399, -398, -397, -396, -395, -394, -393, -392, -391, -390, -389, -388, -387, -386, -385, -384, -383, -382, -381, -380, -379, -378, -377, -376, -375, -374, -373, -372, -371, -370, -369, -368, -367, -366, -365, -364, -363, -362, -361, -360, -359, -358, -357, -356, -355, -354, -353, -352, -351, -350, -349, -348, -347, -346, -345, -344, -343, -342, -341, -340, -339, -338, -337, -336, -335, -334, -333, -332, -331, -330, -329, -328, -327, -326, -325, -324, -323, -322, -321, -320, -319, -318, -317, -316, -315, -314, -313, -312, -311, -310, -309, -308, -307, -306, -305, -304, -303, -302, -301, -300, -299, -298, -297, -296, -295, -294, -293, -292, -291, -290, -289, -288, -287, -286, -285, -284, -283, -282, -281, -280, -279, -278, -277, -276, -275, -274, -273, -272, -271, -270, -269, -268, -267, -266, -265, -264, -263, -262, -261, -260, -259, -258, -257, -256, -255, -254, -253, -252, -251, -250, -249, -248, -247, -246, -245, -244, -243, -242, -241, -240, -239, -238, -237, -236, -235, -234, -233, -232, -231, -230, -229, -228, -227, -226, -225, -224, -223, -222, -221, -220, -219, -218, -217, -216, -215, -214, -213, -212, -211, -210, -209, -208, -207, -206, -205, -204, -203, -202, -201, -200, -199, -198, -197, -196, -195, -194, -193, -192, -191, -190, -189, -188, -187, -186, -185, -184, -183, -182, -181, -180, -179, -178, -177, -176, -175, -174, -173, -172, -171, -170, -169, -168, -167, -166, -165, -164, -163, -162, -161, -160, -159]\n0\n```\nand also this one\n```\n[1,2,1,2,1,2,1,2,1,2]\n-1\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, we need to find out cycle means cycle detection.\\nLet\\'s say Two people are running on a circle then definately they meet at any point. If they meet means cycle present. \\n\\n# Approach\\nSo, Here I will use Fast and Slow pointer (Two pointer approach).\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- When loop run slow pointer move step ahead while fast pointer move it\\'s double.\\n4- If both pointer meet at a particular point it means cycle present other no."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Forget the garbage task.\\n\\nRead the real one:\\nRetuen `True` for neighboring Nodes with equal values, otherwise `False`"
                    },
                    {
                        "username": "arshita129",
                        "content": "neighboring nodes with equal values?? We are not trying to see if neighboring nodes have equal values.\\n"
                    }
                ]
            },
            {
                "id": 2043401,
                "content": [
                    {
                        "username": "julkar9",
                        "content": "I hate this kind of questions, its either you know the solution or don\\'t. There\\'s no in-between."
                    },
                    {
                        "username": "psionl0",
                        "content": "The fast and slow pointer technique is useful in a variety of linked list situations. It is worth while learning about it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "I\\'m not going to read the whole question just for \"Find cycle\""
                    },
                    {
                        "username": "katalma",
                        "content": "Beginning of the week, beginning of the month. I can believe I am smart. But in the end..."
                    },
                    {
                        "username": "sakibmondal7",
                        "content": "Just check the solution with minimum space under Python language.. They did some strange things.. \n\nThey edited the user response in backend with pos variable. I guess that is why `POS` is given.\n\nThis is cheatings at next level.. "
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "## there is no use of pos here ##\\n`\\nhead = [3,2,0,-4], pos = 3\\n`\\nWill pass the test case since refreance of last node is to pos 1 node"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Okay, so we all know the constant memory solution - but is there a different approach (that uses more than constant space) that also takes linear time? Best I can think of is quadratic."
                    },
                    {
                        "username": "aitachii",
                        "content": "Hash table/dictionary of ListNodes take up O(n) space. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Is LeetCode softening us up?"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Check out this testcase\n```\n[-158, -157, -156, -155, -154, -153, -152, -151, -150, -149, -148, -147, -146, -145, -144, -143, -142, -141, -140, -139, -138, -137, -136, -135, -134, -133, -132, -131, -130, -129, -128, -127, -126, -125, -124, -123, -122, -121, -120, -119, -118, -117, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -106, -105, -104, -103, -102, -101, -100, -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099, 4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, -500, -499, -498, -497, -496, -495, -494, -493, -492, -491, -490, -489, -488, -487, -486, -485, -484, -483, -482, -481, -480, -479, -478, -477, -476, -475, -474, -473, -472, -471, -470, -469, -468, -467, -466, -465, -464, -463, -462, -461, -460, -459, -458, -457, -456, -455, -454, -453, -452, -451, -450, -449, -448, -447, -446, -445, -444, -443, -442, -441, -440, -439, -438, -437, -436, -435, -434, -433, -432, -431, -430, -429, -428, -427, -426, -425, -424, -423, -422, -421, -420, -419, -418, -417, -416, -415, -414, -413, -412, -411, -410, -409, -408, -407, -406, -405, -404, -403, -402, -401, -400, -399, -398, -397, -396, -395, -394, -393, -392, -391, -390, -389, -388, -387, -386, -385, -384, -383, -382, -381, -380, -379, -378, -377, -376, -375, -374, -373, -372, -371, -370, -369, -368, -367, -366, -365, -364, -363, -362, -361, -360, -359, -358, -357, -356, -355, -354, -353, -352, -351, -350, -349, -348, -347, -346, -345, -344, -343, -342, -341, -340, -339, -338, -337, -336, -335, -334, -333, -332, -331, -330, -329, -328, -327, -326, -325, -324, -323, -322, -321, -320, -319, -318, -317, -316, -315, -314, -313, -312, -311, -310, -309, -308, -307, -306, -305, -304, -303, -302, -301, -300, -299, -298, -297, -296, -295, -294, -293, -292, -291, -290, -289, -288, -287, -286, -285, -284, -283, -282, -281, -280, -279, -278, -277, -276, -275, -274, -273, -272, -271, -270, -269, -268, -267, -266, -265, -264, -263, -262, -261, -260, -259, -258, -257, -256, -255, -254, -253, -252, -251, -250, -249, -248, -247, -246, -245, -244, -243, -242, -241, -240, -239, -238, -237, -236, -235, -234, -233, -232, -231, -230, -229, -228, -227, -226, -225, -224, -223, -222, -221, -220, -219, -218, -217, -216, -215, -214, -213, -212, -211, -210, -209, -208, -207, -206, -205, -204, -203, -202, -201, -200, -199, -198, -197, -196, -195, -194, -193, -192, -191, -190, -189, -188, -187, -186, -185, -184, -183, -182, -181, -180, -179, -178, -177, -176, -175, -174, -173, -172, -171, -170, -169, -168, -167, -166, -165, -164, -163, -162, -161, -160, -159]\n0\n```\nand also this one\n```\n[1,2,1,2,1,2,1,2,1,2]\n-1\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, we need to find out cycle means cycle detection.\\nLet\\'s say Two people are running on a circle then definately they meet at any point. If they meet means cycle present. \\n\\n# Approach\\nSo, Here I will use Fast and Slow pointer (Two pointer approach).\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- When loop run slow pointer move step ahead while fast pointer move it\\'s double.\\n4- If both pointer meet at a particular point it means cycle present other no."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Forget the garbage task.\\n\\nRead the real one:\\nRetuen `True` for neighboring Nodes with equal values, otherwise `False`"
                    },
                    {
                        "username": "arshita129",
                        "content": "neighboring nodes with equal values?? We are not trying to see if neighboring nodes have equal values.\\n"
                    }
                ]
            },
            {
                "id": 2043393,
                "content": [
                    {
                        "username": "julkar9",
                        "content": "I hate this kind of questions, its either you know the solution or don\\'t. There\\'s no in-between."
                    },
                    {
                        "username": "psionl0",
                        "content": "The fast and slow pointer technique is useful in a variety of linked list situations. It is worth while learning about it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "I\\'m not going to read the whole question just for \"Find cycle\""
                    },
                    {
                        "username": "katalma",
                        "content": "Beginning of the week, beginning of the month. I can believe I am smart. But in the end..."
                    },
                    {
                        "username": "sakibmondal7",
                        "content": "Just check the solution with minimum space under Python language.. They did some strange things.. \n\nThey edited the user response in backend with pos variable. I guess that is why `POS` is given.\n\nThis is cheatings at next level.. "
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "## there is no use of pos here ##\\n`\\nhead = [3,2,0,-4], pos = 3\\n`\\nWill pass the test case since refreance of last node is to pos 1 node"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Okay, so we all know the constant memory solution - but is there a different approach (that uses more than constant space) that also takes linear time? Best I can think of is quadratic."
                    },
                    {
                        "username": "aitachii",
                        "content": "Hash table/dictionary of ListNodes take up O(n) space. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Is LeetCode softening us up?"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Check out this testcase\n```\n[-158, -157, -156, -155, -154, -153, -152, -151, -150, -149, -148, -147, -146, -145, -144, -143, -142, -141, -140, -139, -138, -137, -136, -135, -134, -133, -132, -131, -130, -129, -128, -127, -126, -125, -124, -123, -122, -121, -120, -119, -118, -117, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -106, -105, -104, -103, -102, -101, -100, -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099, 4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, -500, -499, -498, -497, -496, -495, -494, -493, -492, -491, -490, -489, -488, -487, -486, -485, -484, -483, -482, -481, -480, -479, -478, -477, -476, -475, -474, -473, -472, -471, -470, -469, -468, -467, -466, -465, -464, -463, -462, -461, -460, -459, -458, -457, -456, -455, -454, -453, -452, -451, -450, -449, -448, -447, -446, -445, -444, -443, -442, -441, -440, -439, -438, -437, -436, -435, -434, -433, -432, -431, -430, -429, -428, -427, -426, -425, -424, -423, -422, -421, -420, -419, -418, -417, -416, -415, -414, -413, -412, -411, -410, -409, -408, -407, -406, -405, -404, -403, -402, -401, -400, -399, -398, -397, -396, -395, -394, -393, -392, -391, -390, -389, -388, -387, -386, -385, -384, -383, -382, -381, -380, -379, -378, -377, -376, -375, -374, -373, -372, -371, -370, -369, -368, -367, -366, -365, -364, -363, -362, -361, -360, -359, -358, -357, -356, -355, -354, -353, -352, -351, -350, -349, -348, -347, -346, -345, -344, -343, -342, -341, -340, -339, -338, -337, -336, -335, -334, -333, -332, -331, -330, -329, -328, -327, -326, -325, -324, -323, -322, -321, -320, -319, -318, -317, -316, -315, -314, -313, -312, -311, -310, -309, -308, -307, -306, -305, -304, -303, -302, -301, -300, -299, -298, -297, -296, -295, -294, -293, -292, -291, -290, -289, -288, -287, -286, -285, -284, -283, -282, -281, -280, -279, -278, -277, -276, -275, -274, -273, -272, -271, -270, -269, -268, -267, -266, -265, -264, -263, -262, -261, -260, -259, -258, -257, -256, -255, -254, -253, -252, -251, -250, -249, -248, -247, -246, -245, -244, -243, -242, -241, -240, -239, -238, -237, -236, -235, -234, -233, -232, -231, -230, -229, -228, -227, -226, -225, -224, -223, -222, -221, -220, -219, -218, -217, -216, -215, -214, -213, -212, -211, -210, -209, -208, -207, -206, -205, -204, -203, -202, -201, -200, -199, -198, -197, -196, -195, -194, -193, -192, -191, -190, -189, -188, -187, -186, -185, -184, -183, -182, -181, -180, -179, -178, -177, -176, -175, -174, -173, -172, -171, -170, -169, -168, -167, -166, -165, -164, -163, -162, -161, -160, -159]\n0\n```\nand also this one\n```\n[1,2,1,2,1,2,1,2,1,2]\n-1\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, we need to find out cycle means cycle detection.\\nLet\\'s say Two people are running on a circle then definately they meet at any point. If they meet means cycle present. \\n\\n# Approach\\nSo, Here I will use Fast and Slow pointer (Two pointer approach).\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- When loop run slow pointer move step ahead while fast pointer move it\\'s double.\\n4- If both pointer meet at a particular point it means cycle present other no."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Forget the garbage task.\\n\\nRead the real one:\\nRetuen `True` for neighboring Nodes with equal values, otherwise `False`"
                    },
                    {
                        "username": "arshita129",
                        "content": "neighboring nodes with equal values?? We are not trying to see if neighboring nodes have equal values.\\n"
                    }
                ]
            },
            {
                "id": 2043349,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "What do you mean Daily Question? I\\'ve already solved it on Aug 26, and then resubmitted a couple improvements to the code just the day before yesterday. Where is my steak now?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@tifv](/tifv) yeah I\\'ve just done that, but in a different language from the previous solution."
                    },
                    {
                        "username": "tifv",
                        "content": "One have to resubmit already solved daily questions."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[floyd\\'s algo solution easy explanation](https://leetcode.com/problems/linked-list-cycle/solutions/3773770/two-pointers-fast-and-slow-floyd-s-tortoise-and-hare-algorithm/?envType=daily-question&envId=2023-09-04) found this useful"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why do we need `pos` here?? why??"
                    },
                    {
                        "username": "psionl0",
                        "content": "The LeetCode program will call your ``hasCycle()`` method and verify that its return value is false when ``pos = -1`` and true otherwise. We don't have any access to this value."
                    },
                    {
                        "username": "tifv",
                        "content": "It specifies whether there is a cycle in the testcase or not. `pos >= 0` implies that there is a cycle, `pos == -1` means that there is no cycle."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Is it possible to do this with $O(1)$ space in linear time?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Yes, fast/slow pointers"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Yes but unless we already know the approach it is not obvious."
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "ahh here we go again."
                    },
                    {
                        "username": "kcharris77",
                        "content": "Good follow up question."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Was hoping for a little challenge today"
                    },
                    {
                        "username": "psionl0",
                        "content": "Try this one: https://leetcode.com/problems/linked-list-cycle-ii/"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "I have one easy solution. I will use cycle detection trick or also known as Fast and slow methods. Let\\'s discuss :\\n1- Take two pointer as fast and slow.\\n2- Slow pointer will move one step while fast pointer will move two times.\\n3- Hence if fast pointer will reach last then slow pointer cover only half distance.\\n4- If any particular node both fast and slower meet, It means list have cycle otherwise cycle not detected.\\n5- If does not meet, in this case fast pointer will point to null.\\n\\nLet me know if above steps are clear otherwise I will provide more explaination."
                    },
                    {
                        "username": "22mca036",
                        "content": "I have pass all the test cases but when pos is -1 i got a error please let me know if someone has faced same issus."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "        slow, fast = head, head\\n        while True:\\n            fast = fast.next.next\\n            if not fast:\\n                return False\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n\\nIt shows 3rd line \"fast = fast.next.next\" is error on python3.\\n\\nWhy it is not available?"
                    }
                ]
            },
            {
                "id": 2043322,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "What do you mean Daily Question? I\\'ve already solved it on Aug 26, and then resubmitted a couple improvements to the code just the day before yesterday. Where is my steak now?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@tifv](/tifv) yeah I\\'ve just done that, but in a different language from the previous solution."
                    },
                    {
                        "username": "tifv",
                        "content": "One have to resubmit already solved daily questions."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[floyd\\'s algo solution easy explanation](https://leetcode.com/problems/linked-list-cycle/solutions/3773770/two-pointers-fast-and-slow-floyd-s-tortoise-and-hare-algorithm/?envType=daily-question&envId=2023-09-04) found this useful"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why do we need `pos` here?? why??"
                    },
                    {
                        "username": "psionl0",
                        "content": "The LeetCode program will call your ``hasCycle()`` method and verify that its return value is false when ``pos = -1`` and true otherwise. We don't have any access to this value."
                    },
                    {
                        "username": "tifv",
                        "content": "It specifies whether there is a cycle in the testcase or not. `pos >= 0` implies that there is a cycle, `pos == -1` means that there is no cycle."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Is it possible to do this with $O(1)$ space in linear time?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Yes, fast/slow pointers"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Yes but unless we already know the approach it is not obvious."
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "ahh here we go again."
                    },
                    {
                        "username": "kcharris77",
                        "content": "Good follow up question."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Was hoping for a little challenge today"
                    },
                    {
                        "username": "psionl0",
                        "content": "Try this one: https://leetcode.com/problems/linked-list-cycle-ii/"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "I have one easy solution. I will use cycle detection trick or also known as Fast and slow methods. Let\\'s discuss :\\n1- Take two pointer as fast and slow.\\n2- Slow pointer will move one step while fast pointer will move two times.\\n3- Hence if fast pointer will reach last then slow pointer cover only half distance.\\n4- If any particular node both fast and slower meet, It means list have cycle otherwise cycle not detected.\\n5- If does not meet, in this case fast pointer will point to null.\\n\\nLet me know if above steps are clear otherwise I will provide more explaination."
                    },
                    {
                        "username": "22mca036",
                        "content": "I have pass all the test cases but when pos is -1 i got a error please let me know if someone has faced same issus."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "        slow, fast = head, head\\n        while True:\\n            fast = fast.next.next\\n            if not fast:\\n                return False\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n\\nIt shows 3rd line \"fast = fast.next.next\" is error on python3.\\n\\nWhy it is not available?"
                    }
                ]
            },
            {
                "id": 2043286,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "What do you mean Daily Question? I\\'ve already solved it on Aug 26, and then resubmitted a couple improvements to the code just the day before yesterday. Where is my steak now?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@tifv](/tifv) yeah I\\'ve just done that, but in a different language from the previous solution."
                    },
                    {
                        "username": "tifv",
                        "content": "One have to resubmit already solved daily questions."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[floyd\\'s algo solution easy explanation](https://leetcode.com/problems/linked-list-cycle/solutions/3773770/two-pointers-fast-and-slow-floyd-s-tortoise-and-hare-algorithm/?envType=daily-question&envId=2023-09-04) found this useful"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why do we need `pos` here?? why??"
                    },
                    {
                        "username": "psionl0",
                        "content": "The LeetCode program will call your ``hasCycle()`` method and verify that its return value is false when ``pos = -1`` and true otherwise. We don't have any access to this value."
                    },
                    {
                        "username": "tifv",
                        "content": "It specifies whether there is a cycle in the testcase or not. `pos >= 0` implies that there is a cycle, `pos == -1` means that there is no cycle."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Is it possible to do this with $O(1)$ space in linear time?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Yes, fast/slow pointers"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Yes but unless we already know the approach it is not obvious."
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "ahh here we go again."
                    },
                    {
                        "username": "kcharris77",
                        "content": "Good follow up question."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Was hoping for a little challenge today"
                    },
                    {
                        "username": "psionl0",
                        "content": "Try this one: https://leetcode.com/problems/linked-list-cycle-ii/"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "I have one easy solution. I will use cycle detection trick or also known as Fast and slow methods. Let\\'s discuss :\\n1- Take two pointer as fast and slow.\\n2- Slow pointer will move one step while fast pointer will move two times.\\n3- Hence if fast pointer will reach last then slow pointer cover only half distance.\\n4- If any particular node both fast and slower meet, It means list have cycle otherwise cycle not detected.\\n5- If does not meet, in this case fast pointer will point to null.\\n\\nLet me know if above steps are clear otherwise I will provide more explaination."
                    },
                    {
                        "username": "22mca036",
                        "content": "I have pass all the test cases but when pos is -1 i got a error please let me know if someone has faced same issus."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "        slow, fast = head, head\\n        while True:\\n            fast = fast.next.next\\n            if not fast:\\n                return False\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n\\nIt shows 3rd line \"fast = fast.next.next\" is error on python3.\\n\\nWhy it is not available?"
                    }
                ]
            },
            {
                "id": 2043264,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "What do you mean Daily Question? I\\'ve already solved it on Aug 26, and then resubmitted a couple improvements to the code just the day before yesterday. Where is my steak now?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@tifv](/tifv) yeah I\\'ve just done that, but in a different language from the previous solution."
                    },
                    {
                        "username": "tifv",
                        "content": "One have to resubmit already solved daily questions."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[floyd\\'s algo solution easy explanation](https://leetcode.com/problems/linked-list-cycle/solutions/3773770/two-pointers-fast-and-slow-floyd-s-tortoise-and-hare-algorithm/?envType=daily-question&envId=2023-09-04) found this useful"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why do we need `pos` here?? why??"
                    },
                    {
                        "username": "psionl0",
                        "content": "The LeetCode program will call your ``hasCycle()`` method and verify that its return value is false when ``pos = -1`` and true otherwise. We don't have any access to this value."
                    },
                    {
                        "username": "tifv",
                        "content": "It specifies whether there is a cycle in the testcase or not. `pos >= 0` implies that there is a cycle, `pos == -1` means that there is no cycle."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Is it possible to do this with $O(1)$ space in linear time?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Yes, fast/slow pointers"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Yes but unless we already know the approach it is not obvious."
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "ahh here we go again."
                    },
                    {
                        "username": "kcharris77",
                        "content": "Good follow up question."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Was hoping for a little challenge today"
                    },
                    {
                        "username": "psionl0",
                        "content": "Try this one: https://leetcode.com/problems/linked-list-cycle-ii/"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "I have one easy solution. I will use cycle detection trick or also known as Fast and slow methods. Let\\'s discuss :\\n1- Take two pointer as fast and slow.\\n2- Slow pointer will move one step while fast pointer will move two times.\\n3- Hence if fast pointer will reach last then slow pointer cover only half distance.\\n4- If any particular node both fast and slower meet, It means list have cycle otherwise cycle not detected.\\n5- If does not meet, in this case fast pointer will point to null.\\n\\nLet me know if above steps are clear otherwise I will provide more explaination."
                    },
                    {
                        "username": "22mca036",
                        "content": "I have pass all the test cases but when pos is -1 i got a error please let me know if someone has faced same issus."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "        slow, fast = head, head\\n        while True:\\n            fast = fast.next.next\\n            if not fast:\\n                return False\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n\\nIt shows 3rd line \"fast = fast.next.next\" is error on python3.\\n\\nWhy it is not available?"
                    }
                ]
            },
            {
                "id": 2043263,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "What do you mean Daily Question? I\\'ve already solved it on Aug 26, and then resubmitted a couple improvements to the code just the day before yesterday. Where is my steak now?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@tifv](/tifv) yeah I\\'ve just done that, but in a different language from the previous solution."
                    },
                    {
                        "username": "tifv",
                        "content": "One have to resubmit already solved daily questions."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[floyd\\'s algo solution easy explanation](https://leetcode.com/problems/linked-list-cycle/solutions/3773770/two-pointers-fast-and-slow-floyd-s-tortoise-and-hare-algorithm/?envType=daily-question&envId=2023-09-04) found this useful"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why do we need `pos` here?? why??"
                    },
                    {
                        "username": "psionl0",
                        "content": "The LeetCode program will call your ``hasCycle()`` method and verify that its return value is false when ``pos = -1`` and true otherwise. We don't have any access to this value."
                    },
                    {
                        "username": "tifv",
                        "content": "It specifies whether there is a cycle in the testcase or not. `pos >= 0` implies that there is a cycle, `pos == -1` means that there is no cycle."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Is it possible to do this with $O(1)$ space in linear time?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Yes, fast/slow pointers"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Yes but unless we already know the approach it is not obvious."
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "ahh here we go again."
                    },
                    {
                        "username": "kcharris77",
                        "content": "Good follow up question."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Was hoping for a little challenge today"
                    },
                    {
                        "username": "psionl0",
                        "content": "Try this one: https://leetcode.com/problems/linked-list-cycle-ii/"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "I have one easy solution. I will use cycle detection trick or also known as Fast and slow methods. Let\\'s discuss :\\n1- Take two pointer as fast and slow.\\n2- Slow pointer will move one step while fast pointer will move two times.\\n3- Hence if fast pointer will reach last then slow pointer cover only half distance.\\n4- If any particular node both fast and slower meet, It means list have cycle otherwise cycle not detected.\\n5- If does not meet, in this case fast pointer will point to null.\\n\\nLet me know if above steps are clear otherwise I will provide more explaination."
                    },
                    {
                        "username": "22mca036",
                        "content": "I have pass all the test cases but when pos is -1 i got a error please let me know if someone has faced same issus."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "        slow, fast = head, head\\n        while True:\\n            fast = fast.next.next\\n            if not fast:\\n                return False\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n\\nIt shows 3rd line \"fast = fast.next.next\" is error on python3.\\n\\nWhy it is not available?"
                    }
                ]
            },
            {
                "id": 2043223,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "What do you mean Daily Question? I\\'ve already solved it on Aug 26, and then resubmitted a couple improvements to the code just the day before yesterday. Where is my steak now?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@tifv](/tifv) yeah I\\'ve just done that, but in a different language from the previous solution."
                    },
                    {
                        "username": "tifv",
                        "content": "One have to resubmit already solved daily questions."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[floyd\\'s algo solution easy explanation](https://leetcode.com/problems/linked-list-cycle/solutions/3773770/two-pointers-fast-and-slow-floyd-s-tortoise-and-hare-algorithm/?envType=daily-question&envId=2023-09-04) found this useful"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why do we need `pos` here?? why??"
                    },
                    {
                        "username": "psionl0",
                        "content": "The LeetCode program will call your ``hasCycle()`` method and verify that its return value is false when ``pos = -1`` and true otherwise. We don't have any access to this value."
                    },
                    {
                        "username": "tifv",
                        "content": "It specifies whether there is a cycle in the testcase or not. `pos >= 0` implies that there is a cycle, `pos == -1` means that there is no cycle."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Is it possible to do this with $O(1)$ space in linear time?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Yes, fast/slow pointers"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Yes but unless we already know the approach it is not obvious."
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "ahh here we go again."
                    },
                    {
                        "username": "kcharris77",
                        "content": "Good follow up question."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Was hoping for a little challenge today"
                    },
                    {
                        "username": "psionl0",
                        "content": "Try this one: https://leetcode.com/problems/linked-list-cycle-ii/"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "I have one easy solution. I will use cycle detection trick or also known as Fast and slow methods. Let\\'s discuss :\\n1- Take two pointer as fast and slow.\\n2- Slow pointer will move one step while fast pointer will move two times.\\n3- Hence if fast pointer will reach last then slow pointer cover only half distance.\\n4- If any particular node both fast and slower meet, It means list have cycle otherwise cycle not detected.\\n5- If does not meet, in this case fast pointer will point to null.\\n\\nLet me know if above steps are clear otherwise I will provide more explaination."
                    },
                    {
                        "username": "22mca036",
                        "content": "I have pass all the test cases but when pos is -1 i got a error please let me know if someone has faced same issus."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "        slow, fast = head, head\\n        while True:\\n            fast = fast.next.next\\n            if not fast:\\n                return False\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n\\nIt shows 3rd line \"fast = fast.next.next\" is error on python3.\\n\\nWhy it is not available?"
                    }
                ]
            },
            {
                "id": 2043217,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "What do you mean Daily Question? I\\'ve already solved it on Aug 26, and then resubmitted a couple improvements to the code just the day before yesterday. Where is my steak now?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@tifv](/tifv) yeah I\\'ve just done that, but in a different language from the previous solution."
                    },
                    {
                        "username": "tifv",
                        "content": "One have to resubmit already solved daily questions."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[floyd\\'s algo solution easy explanation](https://leetcode.com/problems/linked-list-cycle/solutions/3773770/two-pointers-fast-and-slow-floyd-s-tortoise-and-hare-algorithm/?envType=daily-question&envId=2023-09-04) found this useful"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why do we need `pos` here?? why??"
                    },
                    {
                        "username": "psionl0",
                        "content": "The LeetCode program will call your ``hasCycle()`` method and verify that its return value is false when ``pos = -1`` and true otherwise. We don't have any access to this value."
                    },
                    {
                        "username": "tifv",
                        "content": "It specifies whether there is a cycle in the testcase or not. `pos >= 0` implies that there is a cycle, `pos == -1` means that there is no cycle."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Is it possible to do this with $O(1)$ space in linear time?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Yes, fast/slow pointers"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Yes but unless we already know the approach it is not obvious."
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "ahh here we go again."
                    },
                    {
                        "username": "kcharris77",
                        "content": "Good follow up question."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Was hoping for a little challenge today"
                    },
                    {
                        "username": "psionl0",
                        "content": "Try this one: https://leetcode.com/problems/linked-list-cycle-ii/"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "I have one easy solution. I will use cycle detection trick or also known as Fast and slow methods. Let\\'s discuss :\\n1- Take two pointer as fast and slow.\\n2- Slow pointer will move one step while fast pointer will move two times.\\n3- Hence if fast pointer will reach last then slow pointer cover only half distance.\\n4- If any particular node both fast and slower meet, It means list have cycle otherwise cycle not detected.\\n5- If does not meet, in this case fast pointer will point to null.\\n\\nLet me know if above steps are clear otherwise I will provide more explaination."
                    },
                    {
                        "username": "22mca036",
                        "content": "I have pass all the test cases but when pos is -1 i got a error please let me know if someone has faced same issus."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "        slow, fast = head, head\\n        while True:\\n            fast = fast.next.next\\n            if not fast:\\n                return False\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n\\nIt shows 3rd line \"fast = fast.next.next\" is error on python3.\\n\\nWhy it is not available?"
                    }
                ]
            },
            {
                "id": 2038484,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "What do you mean Daily Question? I\\'ve already solved it on Aug 26, and then resubmitted a couple improvements to the code just the day before yesterday. Where is my steak now?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@tifv](/tifv) yeah I\\'ve just done that, but in a different language from the previous solution."
                    },
                    {
                        "username": "tifv",
                        "content": "One have to resubmit already solved daily questions."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[floyd\\'s algo solution easy explanation](https://leetcode.com/problems/linked-list-cycle/solutions/3773770/two-pointers-fast-and-slow-floyd-s-tortoise-and-hare-algorithm/?envType=daily-question&envId=2023-09-04) found this useful"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why do we need `pos` here?? why??"
                    },
                    {
                        "username": "psionl0",
                        "content": "The LeetCode program will call your ``hasCycle()`` method and verify that its return value is false when ``pos = -1`` and true otherwise. We don't have any access to this value."
                    },
                    {
                        "username": "tifv",
                        "content": "It specifies whether there is a cycle in the testcase or not. `pos >= 0` implies that there is a cycle, `pos == -1` means that there is no cycle."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Is it possible to do this with $O(1)$ space in linear time?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Yes, fast/slow pointers"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Yes but unless we already know the approach it is not obvious."
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "ahh here we go again."
                    },
                    {
                        "username": "kcharris77",
                        "content": "Good follow up question."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Was hoping for a little challenge today"
                    },
                    {
                        "username": "psionl0",
                        "content": "Try this one: https://leetcode.com/problems/linked-list-cycle-ii/"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "I have one easy solution. I will use cycle detection trick or also known as Fast and slow methods. Let\\'s discuss :\\n1- Take two pointer as fast and slow.\\n2- Slow pointer will move one step while fast pointer will move two times.\\n3- Hence if fast pointer will reach last then slow pointer cover only half distance.\\n4- If any particular node both fast and slower meet, It means list have cycle otherwise cycle not detected.\\n5- If does not meet, in this case fast pointer will point to null.\\n\\nLet me know if above steps are clear otherwise I will provide more explaination."
                    },
                    {
                        "username": "22mca036",
                        "content": "I have pass all the test cases but when pos is -1 i got a error please let me know if someone has faced same issus."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "        slow, fast = head, head\\n        while True:\\n            fast = fast.next.next\\n            if not fast:\\n                return False\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n\\nIt shows 3rd line \"fast = fast.next.next\" is error on python3.\\n\\nWhy it is not available?"
                    }
                ]
            },
            {
                "id": 2038146,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "What do you mean Daily Question? I\\'ve already solved it on Aug 26, and then resubmitted a couple improvements to the code just the day before yesterday. Where is my steak now?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@tifv](/tifv) yeah I\\'ve just done that, but in a different language from the previous solution."
                    },
                    {
                        "username": "tifv",
                        "content": "One have to resubmit already solved daily questions."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[floyd\\'s algo solution easy explanation](https://leetcode.com/problems/linked-list-cycle/solutions/3773770/two-pointers-fast-and-slow-floyd-s-tortoise-and-hare-algorithm/?envType=daily-question&envId=2023-09-04) found this useful"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why do we need `pos` here?? why??"
                    },
                    {
                        "username": "psionl0",
                        "content": "The LeetCode program will call your ``hasCycle()`` method and verify that its return value is false when ``pos = -1`` and true otherwise. We don't have any access to this value."
                    },
                    {
                        "username": "tifv",
                        "content": "It specifies whether there is a cycle in the testcase or not. `pos >= 0` implies that there is a cycle, `pos == -1` means that there is no cycle."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Is it possible to do this with $O(1)$ space in linear time?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Yes, fast/slow pointers"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Yes but unless we already know the approach it is not obvious."
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "ahh here we go again."
                    },
                    {
                        "username": "kcharris77",
                        "content": "Good follow up question."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Was hoping for a little challenge today"
                    },
                    {
                        "username": "psionl0",
                        "content": "Try this one: https://leetcode.com/problems/linked-list-cycle-ii/"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "I have one easy solution. I will use cycle detection trick or also known as Fast and slow methods. Let\\'s discuss :\\n1- Take two pointer as fast and slow.\\n2- Slow pointer will move one step while fast pointer will move two times.\\n3- Hence if fast pointer will reach last then slow pointer cover only half distance.\\n4- If any particular node both fast and slower meet, It means list have cycle otherwise cycle not detected.\\n5- If does not meet, in this case fast pointer will point to null.\\n\\nLet me know if above steps are clear otherwise I will provide more explaination."
                    },
                    {
                        "username": "22mca036",
                        "content": "I have pass all the test cases but when pos is -1 i got a error please let me know if someone has faced same issus."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "        slow, fast = head, head\\n        while True:\\n            fast = fast.next.next\\n            if not fast:\\n                return False\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n\\nIt shows 3rd line \"fast = fast.next.next\" is error on python3.\\n\\nWhy it is not available?"
                    }
                ]
            },
            {
                "id": 2017282,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "What do you mean Daily Question? I\\'ve already solved it on Aug 26, and then resubmitted a couple improvements to the code just the day before yesterday. Where is my steak now?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@tifv](/tifv) yeah I\\'ve just done that, but in a different language from the previous solution."
                    },
                    {
                        "username": "tifv",
                        "content": "One have to resubmit already solved daily questions."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[floyd\\'s algo solution easy explanation](https://leetcode.com/problems/linked-list-cycle/solutions/3773770/two-pointers-fast-and-slow-floyd-s-tortoise-and-hare-algorithm/?envType=daily-question&envId=2023-09-04) found this useful"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why do we need `pos` here?? why??"
                    },
                    {
                        "username": "psionl0",
                        "content": "The LeetCode program will call your ``hasCycle()`` method and verify that its return value is false when ``pos = -1`` and true otherwise. We don't have any access to this value."
                    },
                    {
                        "username": "tifv",
                        "content": "It specifies whether there is a cycle in the testcase or not. `pos >= 0` implies that there is a cycle, `pos == -1` means that there is no cycle."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Is it possible to do this with $O(1)$ space in linear time?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Yes, fast/slow pointers"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Yes but unless we already know the approach it is not obvious."
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "ahh here we go again."
                    },
                    {
                        "username": "kcharris77",
                        "content": "Good follow up question."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Was hoping for a little challenge today"
                    },
                    {
                        "username": "psionl0",
                        "content": "Try this one: https://leetcode.com/problems/linked-list-cycle-ii/"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "I have one easy solution. I will use cycle detection trick or also known as Fast and slow methods. Let\\'s discuss :\\n1- Take two pointer as fast and slow.\\n2- Slow pointer will move one step while fast pointer will move two times.\\n3- Hence if fast pointer will reach last then slow pointer cover only half distance.\\n4- If any particular node both fast and slower meet, It means list have cycle otherwise cycle not detected.\\n5- If does not meet, in this case fast pointer will point to null.\\n\\nLet me know if above steps are clear otherwise I will provide more explaination."
                    },
                    {
                        "username": "22mca036",
                        "content": "I have pass all the test cases but when pos is -1 i got a error please let me know if someone has faced same issus."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "        slow, fast = head, head\\n        while True:\\n            fast = fast.next.next\\n            if not fast:\\n                return False\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n\\nIt shows 3rd line \"fast = fast.next.next\" is error on python3.\\n\\nWhy it is not available?"
                    }
                ]
            },
            {
                "id": 2012400,
                "content": [
                    {
                        "username": "Prat_2030",
                        "content": "\\n\\n1. Version with Array (nums):\\nIn the first version, the slow and fast pointers are used in the context of manipulating an array. This is often used in cyclic arrays or sequences where you want to detect cycles or perform some other operation. The idea is that the fast pointer advances faster than the slow pointer, and they might eventually meet or cross paths if there\\'s a cycle. This version is commonly used in algorithms like Floyd\\'s cycle detection algorithm for finding cycles in linked lists or arrays.\\nExample use cases:\\n\\nDetecting cycles in an array or linked list.\\nFinding the duplicate element in an array (Floyd\\'s Tortoise and Hare algorithm).\\n\\n```cpp\\n#include <iostream>\\n#include <vector>\\n\\nbool hasCycle(const std::vector<int>& nums) {\\n    int slow = 0, fast = 0;\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n        if (slow == fast) {\\n            return true; // Cycle detected\\n        }\\n        if (slow < 0 || fast < 0 || fast >= nums.size()) {\\n            return false; // No cycle\\n        }\\n    }\\n}\\n\\nint main() {\\n    std::vector<int> nums = {2, 5, 1, 3, 4, 2}; // Example cyclic array\\n    bool hasCycleResult = hasCycle(nums);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n    return 0;\\n}\\n```\\n\\n2. Version with Linked List:\\nIn the second version, the slow and fast pointers are used in the context of a singly linked list. The fast pointer advances by two steps while the slow pointer advances by one step. This approach is often used for operations that require traversing or processing a linked list in a certain way.\\n\\nExample use cases:\\n\\nDetecting a loop in a linked list (similar to Floyd\\'s cycle detection in arrays).\\nFinding the middle element of a linked list.\\nChecking for palindromes in a linked list.\\nMerging two sorted linked lists.\\n\\n```cpp\\n#include <iostream>\\n\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int val) : val(val), next(nullptr) {}\\n};\\n\\nbool hasCycle(ListNode* head) {\\n    if (!head || !head->next) {\\n        return false; // No cycle with 0 or 1 nodes\\n    }\\n    ListNode* slow = head->next;\\n    ListNode* fast = head->next->next;\\n    while (slow != fast) {\\n        if (!fast || !fast->next) {\\n            return false; // No cycle\\n        }\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return true; // Cycle detected\\n}\\n\\nint main() {\\n    // Example linked list with a cycle\\n    ListNode* head = new ListNode(3);\\n    head->next = new ListNode(2);\\n    head->next->next = new ListNode(0);\\n    head->next->next->next = new ListNode(-4);\\n    head->next->next->next->next = head->next; // Creating a cycle\\n\\n    bool hasCycleResult = hasCycle(head);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n\\n    // Clean up memory (not shown in the example)\\n    return 0;\\n}\\n```\\n\\nWhen to use each version:\\n\\nVersion with Array (nums):\\nUse this version when you\\'re dealing with cyclic arrays or sequences, and you need to detect cycles or perform operations related to cycles.\\nVersion with Linked List:\\nUse this version when you\\'re working with linked lists and need to traverse, manipulate, or perform specific operations like detecting loops, finding middle elements, or merging lists."
                    },
                    {
                        "username": "tawashi105",
                        "content": "The \"Input\" (e.g. head=[1], pos=1) in this problem explanation, is not input to the hasCycle function, it is input to the function which produces a ListNode instance, right?\nIf this is true, this explanation is too confusing. I wasted 2 hours."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "detecting cycles is actually a simple solution. All the question is saying that i am passing the initial node\\'s address you check weather it has a loop in it or not neverthless. Congratulations on your progress so far!"
                    },
                    {
                        "username": "louislhotte",
                        "content": "Funny problem. My answer was accepted, but it turns out it was a famous algorithm that we needed to use which was much more efficient! "
                    },
                    {
                        "username": "user8763jW",
                        "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL )\\n          return false;\\n        ListNode* slow;\\n        ListNode* fast;\\n        bool t =0;\\n        slow = head;\\n        fast = head;\\n        while (slow->next && fast->next->next)\\n        {\\n            if (slow == fast)\\n           { \\n           t=1;\\n           break;\\n           }\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return t?1:0;\\n    }\\n};\\n\\n\\n\\nwhy above code failed for \\n[-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5]\\n\\n\\n"
                    },
                    {
                        "username": "user5388FE",
                        "content": "I don\\'t really understand this question, what does cycle mean, how does -4 point to 2??? doesn\\'t the tail of the LL point to null?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@Lokadithya_M](/Lokadithya_M) Given input format: head = [3,2,0,-4], pos = 1 means that the last element -4 i.e. the tail is linked to pos=1 i.e. 2. \\n\\nPos is given with 0-index notation.  Hence, thats the difference here tail doesn\\'t point to null but an element in the list."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "read about circular linked lists  you will understand\\n"
                    },
                    {
                        "username": "Ravi_kant123",
                        "content": "Intution for this problem is if there is a cycle present in present that means we are again traversing over the nodes which we have already encounter. simple use maps to store nodes if node is already present that means there is a cycle.\\naccording to me this one is the most simple solution.\\nthere are other methods also like Floyed cyle detection you guys can also check out that.\\n\\nand in this question pos is in question just to clarify us that yes cycle is present otherwise how will they tell us. so don\\'t worry about that just solve the problem"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "quick neat method?\\n\\ntry using the Floyd cycle method. "
                    },
                    {
                        "username": "Kilderon",
                        "content": "How can i emulate this testcases in my IDE using java?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "You will have to build the whole linked list and then just pass the head as input. "
                    },
                    {
                        "username": "balinome",
                        "content": "i dont understand the 2 pointer approach , lets say we start : slow* = head and fast* = head and the slow moves 1 node at a time and fast moves 2 nodes at a time , what id the cycle is on the second and 4th nodes , the fast will not even get to those nodes ??? the fast will go from 1st to 3rd to 5th , like i just dont understand the logic "
                    },
                    {
                        "username": "Emerold",
                        "content": "If there is a cycle, eventually, you enter it, as this list is a linked list and we go from the front to the end. If the second node is part of the cycle and the second node points to the third node (by definition), the third node is also part of the cycle. You cannot have the situation that the second and 4th node are part of the cycle but the third node is not.\\n\\nAnd then, you can use the logic of the walker and runner variable.\\n\\nOnce, the runner is in the cycle, we will just run around it again and again. Yes, it skips one node every time, but this doesn\\'t matter yet. Assuming, the runner is already in the cycle going in circles, the walker will eventually reach that cycle, too (if it exists).\\n\\nNow, we have the following situation: The runner moves to steps a time, the walker moves one step a time. Lets say, the gap between the runner is of length n. Every time the walker moves one step and the runner moves two steps, this length between the two gets reduced by exactly one. As this gap gets smaller by exactly one per iteration, you will not jump over the walker with the runner by doing two steps at a time while the walker does one.\\n\\nBy that, you will eventually get the situation, that the runner is equal to the walker (if there exists a circle). \\n\\nTo be honest, in the beginning, it was confusing for me, too, that the runner wont skip over the walker. But this argument of the gap getting smaller only by one per iteration answered, why we can\\'t skip over the walker with the runner without having the equality first."
                    },
                    {
                        "username": "ankush57",
                        "content": "`class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n            if(head == NULL || head -> next == NULL)return false ;\\n\\n            int count = 10001 ;\\n\\n            while(count){\\n\\n                if(!head)return false ;\\n\\n                head = head -> next ;\\n                count-- ;\\n            } \\n\\n            return true ;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1990029,
                "content": [
                    {
                        "username": "Prat_2030",
                        "content": "\\n\\n1. Version with Array (nums):\\nIn the first version, the slow and fast pointers are used in the context of manipulating an array. This is often used in cyclic arrays or sequences where you want to detect cycles or perform some other operation. The idea is that the fast pointer advances faster than the slow pointer, and they might eventually meet or cross paths if there\\'s a cycle. This version is commonly used in algorithms like Floyd\\'s cycle detection algorithm for finding cycles in linked lists or arrays.\\nExample use cases:\\n\\nDetecting cycles in an array or linked list.\\nFinding the duplicate element in an array (Floyd\\'s Tortoise and Hare algorithm).\\n\\n```cpp\\n#include <iostream>\\n#include <vector>\\n\\nbool hasCycle(const std::vector<int>& nums) {\\n    int slow = 0, fast = 0;\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n        if (slow == fast) {\\n            return true; // Cycle detected\\n        }\\n        if (slow < 0 || fast < 0 || fast >= nums.size()) {\\n            return false; // No cycle\\n        }\\n    }\\n}\\n\\nint main() {\\n    std::vector<int> nums = {2, 5, 1, 3, 4, 2}; // Example cyclic array\\n    bool hasCycleResult = hasCycle(nums);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n    return 0;\\n}\\n```\\n\\n2. Version with Linked List:\\nIn the second version, the slow and fast pointers are used in the context of a singly linked list. The fast pointer advances by two steps while the slow pointer advances by one step. This approach is often used for operations that require traversing or processing a linked list in a certain way.\\n\\nExample use cases:\\n\\nDetecting a loop in a linked list (similar to Floyd\\'s cycle detection in arrays).\\nFinding the middle element of a linked list.\\nChecking for palindromes in a linked list.\\nMerging two sorted linked lists.\\n\\n```cpp\\n#include <iostream>\\n\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int val) : val(val), next(nullptr) {}\\n};\\n\\nbool hasCycle(ListNode* head) {\\n    if (!head || !head->next) {\\n        return false; // No cycle with 0 or 1 nodes\\n    }\\n    ListNode* slow = head->next;\\n    ListNode* fast = head->next->next;\\n    while (slow != fast) {\\n        if (!fast || !fast->next) {\\n            return false; // No cycle\\n        }\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return true; // Cycle detected\\n}\\n\\nint main() {\\n    // Example linked list with a cycle\\n    ListNode* head = new ListNode(3);\\n    head->next = new ListNode(2);\\n    head->next->next = new ListNode(0);\\n    head->next->next->next = new ListNode(-4);\\n    head->next->next->next->next = head->next; // Creating a cycle\\n\\n    bool hasCycleResult = hasCycle(head);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n\\n    // Clean up memory (not shown in the example)\\n    return 0;\\n}\\n```\\n\\nWhen to use each version:\\n\\nVersion with Array (nums):\\nUse this version when you\\'re dealing with cyclic arrays or sequences, and you need to detect cycles or perform operations related to cycles.\\nVersion with Linked List:\\nUse this version when you\\'re working with linked lists and need to traverse, manipulate, or perform specific operations like detecting loops, finding middle elements, or merging lists."
                    },
                    {
                        "username": "tawashi105",
                        "content": "The \"Input\" (e.g. head=[1], pos=1) in this problem explanation, is not input to the hasCycle function, it is input to the function which produces a ListNode instance, right?\nIf this is true, this explanation is too confusing. I wasted 2 hours."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "detecting cycles is actually a simple solution. All the question is saying that i am passing the initial node\\'s address you check weather it has a loop in it or not neverthless. Congratulations on your progress so far!"
                    },
                    {
                        "username": "louislhotte",
                        "content": "Funny problem. My answer was accepted, but it turns out it was a famous algorithm that we needed to use which was much more efficient! "
                    },
                    {
                        "username": "user8763jW",
                        "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL )\\n          return false;\\n        ListNode* slow;\\n        ListNode* fast;\\n        bool t =0;\\n        slow = head;\\n        fast = head;\\n        while (slow->next && fast->next->next)\\n        {\\n            if (slow == fast)\\n           { \\n           t=1;\\n           break;\\n           }\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return t?1:0;\\n    }\\n};\\n\\n\\n\\nwhy above code failed for \\n[-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5]\\n\\n\\n"
                    },
                    {
                        "username": "user5388FE",
                        "content": "I don\\'t really understand this question, what does cycle mean, how does -4 point to 2??? doesn\\'t the tail of the LL point to null?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@Lokadithya_M](/Lokadithya_M) Given input format: head = [3,2,0,-4], pos = 1 means that the last element -4 i.e. the tail is linked to pos=1 i.e. 2. \\n\\nPos is given with 0-index notation.  Hence, thats the difference here tail doesn\\'t point to null but an element in the list."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "read about circular linked lists  you will understand\\n"
                    },
                    {
                        "username": "Ravi_kant123",
                        "content": "Intution for this problem is if there is a cycle present in present that means we are again traversing over the nodes which we have already encounter. simple use maps to store nodes if node is already present that means there is a cycle.\\naccording to me this one is the most simple solution.\\nthere are other methods also like Floyed cyle detection you guys can also check out that.\\n\\nand in this question pos is in question just to clarify us that yes cycle is present otherwise how will they tell us. so don\\'t worry about that just solve the problem"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "quick neat method?\\n\\ntry using the Floyd cycle method. "
                    },
                    {
                        "username": "Kilderon",
                        "content": "How can i emulate this testcases in my IDE using java?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "You will have to build the whole linked list and then just pass the head as input. "
                    },
                    {
                        "username": "balinome",
                        "content": "i dont understand the 2 pointer approach , lets say we start : slow* = head and fast* = head and the slow moves 1 node at a time and fast moves 2 nodes at a time , what id the cycle is on the second and 4th nodes , the fast will not even get to those nodes ??? the fast will go from 1st to 3rd to 5th , like i just dont understand the logic "
                    },
                    {
                        "username": "Emerold",
                        "content": "If there is a cycle, eventually, you enter it, as this list is a linked list and we go from the front to the end. If the second node is part of the cycle and the second node points to the third node (by definition), the third node is also part of the cycle. You cannot have the situation that the second and 4th node are part of the cycle but the third node is not.\\n\\nAnd then, you can use the logic of the walker and runner variable.\\n\\nOnce, the runner is in the cycle, we will just run around it again and again. Yes, it skips one node every time, but this doesn\\'t matter yet. Assuming, the runner is already in the cycle going in circles, the walker will eventually reach that cycle, too (if it exists).\\n\\nNow, we have the following situation: The runner moves to steps a time, the walker moves one step a time. Lets say, the gap between the runner is of length n. Every time the walker moves one step and the runner moves two steps, this length between the two gets reduced by exactly one. As this gap gets smaller by exactly one per iteration, you will not jump over the walker with the runner by doing two steps at a time while the walker does one.\\n\\nBy that, you will eventually get the situation, that the runner is equal to the walker (if there exists a circle). \\n\\nTo be honest, in the beginning, it was confusing for me, too, that the runner wont skip over the walker. But this argument of the gap getting smaller only by one per iteration answered, why we can\\'t skip over the walker with the runner without having the equality first."
                    },
                    {
                        "username": "ankush57",
                        "content": "`class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n            if(head == NULL || head -> next == NULL)return false ;\\n\\n            int count = 10001 ;\\n\\n            while(count){\\n\\n                if(!head)return false ;\\n\\n                head = head -> next ;\\n                count-- ;\\n            } \\n\\n            return true ;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1982710,
                "content": [
                    {
                        "username": "Prat_2030",
                        "content": "\\n\\n1. Version with Array (nums):\\nIn the first version, the slow and fast pointers are used in the context of manipulating an array. This is often used in cyclic arrays or sequences where you want to detect cycles or perform some other operation. The idea is that the fast pointer advances faster than the slow pointer, and they might eventually meet or cross paths if there\\'s a cycle. This version is commonly used in algorithms like Floyd\\'s cycle detection algorithm for finding cycles in linked lists or arrays.\\nExample use cases:\\n\\nDetecting cycles in an array or linked list.\\nFinding the duplicate element in an array (Floyd\\'s Tortoise and Hare algorithm).\\n\\n```cpp\\n#include <iostream>\\n#include <vector>\\n\\nbool hasCycle(const std::vector<int>& nums) {\\n    int slow = 0, fast = 0;\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n        if (slow == fast) {\\n            return true; // Cycle detected\\n        }\\n        if (slow < 0 || fast < 0 || fast >= nums.size()) {\\n            return false; // No cycle\\n        }\\n    }\\n}\\n\\nint main() {\\n    std::vector<int> nums = {2, 5, 1, 3, 4, 2}; // Example cyclic array\\n    bool hasCycleResult = hasCycle(nums);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n    return 0;\\n}\\n```\\n\\n2. Version with Linked List:\\nIn the second version, the slow and fast pointers are used in the context of a singly linked list. The fast pointer advances by two steps while the slow pointer advances by one step. This approach is often used for operations that require traversing or processing a linked list in a certain way.\\n\\nExample use cases:\\n\\nDetecting a loop in a linked list (similar to Floyd\\'s cycle detection in arrays).\\nFinding the middle element of a linked list.\\nChecking for palindromes in a linked list.\\nMerging two sorted linked lists.\\n\\n```cpp\\n#include <iostream>\\n\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int val) : val(val), next(nullptr) {}\\n};\\n\\nbool hasCycle(ListNode* head) {\\n    if (!head || !head->next) {\\n        return false; // No cycle with 0 or 1 nodes\\n    }\\n    ListNode* slow = head->next;\\n    ListNode* fast = head->next->next;\\n    while (slow != fast) {\\n        if (!fast || !fast->next) {\\n            return false; // No cycle\\n        }\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return true; // Cycle detected\\n}\\n\\nint main() {\\n    // Example linked list with a cycle\\n    ListNode* head = new ListNode(3);\\n    head->next = new ListNode(2);\\n    head->next->next = new ListNode(0);\\n    head->next->next->next = new ListNode(-4);\\n    head->next->next->next->next = head->next; // Creating a cycle\\n\\n    bool hasCycleResult = hasCycle(head);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n\\n    // Clean up memory (not shown in the example)\\n    return 0;\\n}\\n```\\n\\nWhen to use each version:\\n\\nVersion with Array (nums):\\nUse this version when you\\'re dealing with cyclic arrays or sequences, and you need to detect cycles or perform operations related to cycles.\\nVersion with Linked List:\\nUse this version when you\\'re working with linked lists and need to traverse, manipulate, or perform specific operations like detecting loops, finding middle elements, or merging lists."
                    },
                    {
                        "username": "tawashi105",
                        "content": "The \"Input\" (e.g. head=[1], pos=1) in this problem explanation, is not input to the hasCycle function, it is input to the function which produces a ListNode instance, right?\nIf this is true, this explanation is too confusing. I wasted 2 hours."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "detecting cycles is actually a simple solution. All the question is saying that i am passing the initial node\\'s address you check weather it has a loop in it or not neverthless. Congratulations on your progress so far!"
                    },
                    {
                        "username": "louislhotte",
                        "content": "Funny problem. My answer was accepted, but it turns out it was a famous algorithm that we needed to use which was much more efficient! "
                    },
                    {
                        "username": "user8763jW",
                        "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL )\\n          return false;\\n        ListNode* slow;\\n        ListNode* fast;\\n        bool t =0;\\n        slow = head;\\n        fast = head;\\n        while (slow->next && fast->next->next)\\n        {\\n            if (slow == fast)\\n           { \\n           t=1;\\n           break;\\n           }\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return t?1:0;\\n    }\\n};\\n\\n\\n\\nwhy above code failed for \\n[-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5]\\n\\n\\n"
                    },
                    {
                        "username": "user5388FE",
                        "content": "I don\\'t really understand this question, what does cycle mean, how does -4 point to 2??? doesn\\'t the tail of the LL point to null?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@Lokadithya_M](/Lokadithya_M) Given input format: head = [3,2,0,-4], pos = 1 means that the last element -4 i.e. the tail is linked to pos=1 i.e. 2. \\n\\nPos is given with 0-index notation.  Hence, thats the difference here tail doesn\\'t point to null but an element in the list."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "read about circular linked lists  you will understand\\n"
                    },
                    {
                        "username": "Ravi_kant123",
                        "content": "Intution for this problem is if there is a cycle present in present that means we are again traversing over the nodes which we have already encounter. simple use maps to store nodes if node is already present that means there is a cycle.\\naccording to me this one is the most simple solution.\\nthere are other methods also like Floyed cyle detection you guys can also check out that.\\n\\nand in this question pos is in question just to clarify us that yes cycle is present otherwise how will they tell us. so don\\'t worry about that just solve the problem"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "quick neat method?\\n\\ntry using the Floyd cycle method. "
                    },
                    {
                        "username": "Kilderon",
                        "content": "How can i emulate this testcases in my IDE using java?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "You will have to build the whole linked list and then just pass the head as input. "
                    },
                    {
                        "username": "balinome",
                        "content": "i dont understand the 2 pointer approach , lets say we start : slow* = head and fast* = head and the slow moves 1 node at a time and fast moves 2 nodes at a time , what id the cycle is on the second and 4th nodes , the fast will not even get to those nodes ??? the fast will go from 1st to 3rd to 5th , like i just dont understand the logic "
                    },
                    {
                        "username": "Emerold",
                        "content": "If there is a cycle, eventually, you enter it, as this list is a linked list and we go from the front to the end. If the second node is part of the cycle and the second node points to the third node (by definition), the third node is also part of the cycle. You cannot have the situation that the second and 4th node are part of the cycle but the third node is not.\\n\\nAnd then, you can use the logic of the walker and runner variable.\\n\\nOnce, the runner is in the cycle, we will just run around it again and again. Yes, it skips one node every time, but this doesn\\'t matter yet. Assuming, the runner is already in the cycle going in circles, the walker will eventually reach that cycle, too (if it exists).\\n\\nNow, we have the following situation: The runner moves to steps a time, the walker moves one step a time. Lets say, the gap between the runner is of length n. Every time the walker moves one step and the runner moves two steps, this length between the two gets reduced by exactly one. As this gap gets smaller by exactly one per iteration, you will not jump over the walker with the runner by doing two steps at a time while the walker does one.\\n\\nBy that, you will eventually get the situation, that the runner is equal to the walker (if there exists a circle). \\n\\nTo be honest, in the beginning, it was confusing for me, too, that the runner wont skip over the walker. But this argument of the gap getting smaller only by one per iteration answered, why we can\\'t skip over the walker with the runner without having the equality first."
                    },
                    {
                        "username": "ankush57",
                        "content": "`class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n            if(head == NULL || head -> next == NULL)return false ;\\n\\n            int count = 10001 ;\\n\\n            while(count){\\n\\n                if(!head)return false ;\\n\\n                head = head -> next ;\\n                count-- ;\\n            } \\n\\n            return true ;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1976666,
                "content": [
                    {
                        "username": "Prat_2030",
                        "content": "\\n\\n1. Version with Array (nums):\\nIn the first version, the slow and fast pointers are used in the context of manipulating an array. This is often used in cyclic arrays or sequences where you want to detect cycles or perform some other operation. The idea is that the fast pointer advances faster than the slow pointer, and they might eventually meet or cross paths if there\\'s a cycle. This version is commonly used in algorithms like Floyd\\'s cycle detection algorithm for finding cycles in linked lists or arrays.\\nExample use cases:\\n\\nDetecting cycles in an array or linked list.\\nFinding the duplicate element in an array (Floyd\\'s Tortoise and Hare algorithm).\\n\\n```cpp\\n#include <iostream>\\n#include <vector>\\n\\nbool hasCycle(const std::vector<int>& nums) {\\n    int slow = 0, fast = 0;\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n        if (slow == fast) {\\n            return true; // Cycle detected\\n        }\\n        if (slow < 0 || fast < 0 || fast >= nums.size()) {\\n            return false; // No cycle\\n        }\\n    }\\n}\\n\\nint main() {\\n    std::vector<int> nums = {2, 5, 1, 3, 4, 2}; // Example cyclic array\\n    bool hasCycleResult = hasCycle(nums);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n    return 0;\\n}\\n```\\n\\n2. Version with Linked List:\\nIn the second version, the slow and fast pointers are used in the context of a singly linked list. The fast pointer advances by two steps while the slow pointer advances by one step. This approach is often used for operations that require traversing or processing a linked list in a certain way.\\n\\nExample use cases:\\n\\nDetecting a loop in a linked list (similar to Floyd\\'s cycle detection in arrays).\\nFinding the middle element of a linked list.\\nChecking for palindromes in a linked list.\\nMerging two sorted linked lists.\\n\\n```cpp\\n#include <iostream>\\n\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int val) : val(val), next(nullptr) {}\\n};\\n\\nbool hasCycle(ListNode* head) {\\n    if (!head || !head->next) {\\n        return false; // No cycle with 0 or 1 nodes\\n    }\\n    ListNode* slow = head->next;\\n    ListNode* fast = head->next->next;\\n    while (slow != fast) {\\n        if (!fast || !fast->next) {\\n            return false; // No cycle\\n        }\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return true; // Cycle detected\\n}\\n\\nint main() {\\n    // Example linked list with a cycle\\n    ListNode* head = new ListNode(3);\\n    head->next = new ListNode(2);\\n    head->next->next = new ListNode(0);\\n    head->next->next->next = new ListNode(-4);\\n    head->next->next->next->next = head->next; // Creating a cycle\\n\\n    bool hasCycleResult = hasCycle(head);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n\\n    // Clean up memory (not shown in the example)\\n    return 0;\\n}\\n```\\n\\nWhen to use each version:\\n\\nVersion with Array (nums):\\nUse this version when you\\'re dealing with cyclic arrays or sequences, and you need to detect cycles or perform operations related to cycles.\\nVersion with Linked List:\\nUse this version when you\\'re working with linked lists and need to traverse, manipulate, or perform specific operations like detecting loops, finding middle elements, or merging lists."
                    },
                    {
                        "username": "tawashi105",
                        "content": "The \"Input\" (e.g. head=[1], pos=1) in this problem explanation, is not input to the hasCycle function, it is input to the function which produces a ListNode instance, right?\nIf this is true, this explanation is too confusing. I wasted 2 hours."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "detecting cycles is actually a simple solution. All the question is saying that i am passing the initial node\\'s address you check weather it has a loop in it or not neverthless. Congratulations on your progress so far!"
                    },
                    {
                        "username": "louislhotte",
                        "content": "Funny problem. My answer was accepted, but it turns out it was a famous algorithm that we needed to use which was much more efficient! "
                    },
                    {
                        "username": "user8763jW",
                        "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL )\\n          return false;\\n        ListNode* slow;\\n        ListNode* fast;\\n        bool t =0;\\n        slow = head;\\n        fast = head;\\n        while (slow->next && fast->next->next)\\n        {\\n            if (slow == fast)\\n           { \\n           t=1;\\n           break;\\n           }\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return t?1:0;\\n    }\\n};\\n\\n\\n\\nwhy above code failed for \\n[-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5]\\n\\n\\n"
                    },
                    {
                        "username": "user5388FE",
                        "content": "I don\\'t really understand this question, what does cycle mean, how does -4 point to 2??? doesn\\'t the tail of the LL point to null?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@Lokadithya_M](/Lokadithya_M) Given input format: head = [3,2,0,-4], pos = 1 means that the last element -4 i.e. the tail is linked to pos=1 i.e. 2. \\n\\nPos is given with 0-index notation.  Hence, thats the difference here tail doesn\\'t point to null but an element in the list."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "read about circular linked lists  you will understand\\n"
                    },
                    {
                        "username": "Ravi_kant123",
                        "content": "Intution for this problem is if there is a cycle present in present that means we are again traversing over the nodes which we have already encounter. simple use maps to store nodes if node is already present that means there is a cycle.\\naccording to me this one is the most simple solution.\\nthere are other methods also like Floyed cyle detection you guys can also check out that.\\n\\nand in this question pos is in question just to clarify us that yes cycle is present otherwise how will they tell us. so don\\'t worry about that just solve the problem"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "quick neat method?\\n\\ntry using the Floyd cycle method. "
                    },
                    {
                        "username": "Kilderon",
                        "content": "How can i emulate this testcases in my IDE using java?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "You will have to build the whole linked list and then just pass the head as input. "
                    },
                    {
                        "username": "balinome",
                        "content": "i dont understand the 2 pointer approach , lets say we start : slow* = head and fast* = head and the slow moves 1 node at a time and fast moves 2 nodes at a time , what id the cycle is on the second and 4th nodes , the fast will not even get to those nodes ??? the fast will go from 1st to 3rd to 5th , like i just dont understand the logic "
                    },
                    {
                        "username": "Emerold",
                        "content": "If there is a cycle, eventually, you enter it, as this list is a linked list and we go from the front to the end. If the second node is part of the cycle and the second node points to the third node (by definition), the third node is also part of the cycle. You cannot have the situation that the second and 4th node are part of the cycle but the third node is not.\\n\\nAnd then, you can use the logic of the walker and runner variable.\\n\\nOnce, the runner is in the cycle, we will just run around it again and again. Yes, it skips one node every time, but this doesn\\'t matter yet. Assuming, the runner is already in the cycle going in circles, the walker will eventually reach that cycle, too (if it exists).\\n\\nNow, we have the following situation: The runner moves to steps a time, the walker moves one step a time. Lets say, the gap between the runner is of length n. Every time the walker moves one step and the runner moves two steps, this length between the two gets reduced by exactly one. As this gap gets smaller by exactly one per iteration, you will not jump over the walker with the runner by doing two steps at a time while the walker does one.\\n\\nBy that, you will eventually get the situation, that the runner is equal to the walker (if there exists a circle). \\n\\nTo be honest, in the beginning, it was confusing for me, too, that the runner wont skip over the walker. But this argument of the gap getting smaller only by one per iteration answered, why we can\\'t skip over the walker with the runner without having the equality first."
                    },
                    {
                        "username": "ankush57",
                        "content": "`class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n            if(head == NULL || head -> next == NULL)return false ;\\n\\n            int count = 10001 ;\\n\\n            while(count){\\n\\n                if(!head)return false ;\\n\\n                head = head -> next ;\\n                count-- ;\\n            } \\n\\n            return true ;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1976595,
                "content": [
                    {
                        "username": "Prat_2030",
                        "content": "\\n\\n1. Version with Array (nums):\\nIn the first version, the slow and fast pointers are used in the context of manipulating an array. This is often used in cyclic arrays or sequences where you want to detect cycles or perform some other operation. The idea is that the fast pointer advances faster than the slow pointer, and they might eventually meet or cross paths if there\\'s a cycle. This version is commonly used in algorithms like Floyd\\'s cycle detection algorithm for finding cycles in linked lists or arrays.\\nExample use cases:\\n\\nDetecting cycles in an array or linked list.\\nFinding the duplicate element in an array (Floyd\\'s Tortoise and Hare algorithm).\\n\\n```cpp\\n#include <iostream>\\n#include <vector>\\n\\nbool hasCycle(const std::vector<int>& nums) {\\n    int slow = 0, fast = 0;\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n        if (slow == fast) {\\n            return true; // Cycle detected\\n        }\\n        if (slow < 0 || fast < 0 || fast >= nums.size()) {\\n            return false; // No cycle\\n        }\\n    }\\n}\\n\\nint main() {\\n    std::vector<int> nums = {2, 5, 1, 3, 4, 2}; // Example cyclic array\\n    bool hasCycleResult = hasCycle(nums);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n    return 0;\\n}\\n```\\n\\n2. Version with Linked List:\\nIn the second version, the slow and fast pointers are used in the context of a singly linked list. The fast pointer advances by two steps while the slow pointer advances by one step. This approach is often used for operations that require traversing or processing a linked list in a certain way.\\n\\nExample use cases:\\n\\nDetecting a loop in a linked list (similar to Floyd\\'s cycle detection in arrays).\\nFinding the middle element of a linked list.\\nChecking for palindromes in a linked list.\\nMerging two sorted linked lists.\\n\\n```cpp\\n#include <iostream>\\n\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int val) : val(val), next(nullptr) {}\\n};\\n\\nbool hasCycle(ListNode* head) {\\n    if (!head || !head->next) {\\n        return false; // No cycle with 0 or 1 nodes\\n    }\\n    ListNode* slow = head->next;\\n    ListNode* fast = head->next->next;\\n    while (slow != fast) {\\n        if (!fast || !fast->next) {\\n            return false; // No cycle\\n        }\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return true; // Cycle detected\\n}\\n\\nint main() {\\n    // Example linked list with a cycle\\n    ListNode* head = new ListNode(3);\\n    head->next = new ListNode(2);\\n    head->next->next = new ListNode(0);\\n    head->next->next->next = new ListNode(-4);\\n    head->next->next->next->next = head->next; // Creating a cycle\\n\\n    bool hasCycleResult = hasCycle(head);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n\\n    // Clean up memory (not shown in the example)\\n    return 0;\\n}\\n```\\n\\nWhen to use each version:\\n\\nVersion with Array (nums):\\nUse this version when you\\'re dealing with cyclic arrays or sequences, and you need to detect cycles or perform operations related to cycles.\\nVersion with Linked List:\\nUse this version when you\\'re working with linked lists and need to traverse, manipulate, or perform specific operations like detecting loops, finding middle elements, or merging lists."
                    },
                    {
                        "username": "tawashi105",
                        "content": "The \"Input\" (e.g. head=[1], pos=1) in this problem explanation, is not input to the hasCycle function, it is input to the function which produces a ListNode instance, right?\nIf this is true, this explanation is too confusing. I wasted 2 hours."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "detecting cycles is actually a simple solution. All the question is saying that i am passing the initial node\\'s address you check weather it has a loop in it or not neverthless. Congratulations on your progress so far!"
                    },
                    {
                        "username": "louislhotte",
                        "content": "Funny problem. My answer was accepted, but it turns out it was a famous algorithm that we needed to use which was much more efficient! "
                    },
                    {
                        "username": "user8763jW",
                        "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL )\\n          return false;\\n        ListNode* slow;\\n        ListNode* fast;\\n        bool t =0;\\n        slow = head;\\n        fast = head;\\n        while (slow->next && fast->next->next)\\n        {\\n            if (slow == fast)\\n           { \\n           t=1;\\n           break;\\n           }\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return t?1:0;\\n    }\\n};\\n\\n\\n\\nwhy above code failed for \\n[-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5]\\n\\n\\n"
                    },
                    {
                        "username": "user5388FE",
                        "content": "I don\\'t really understand this question, what does cycle mean, how does -4 point to 2??? doesn\\'t the tail of the LL point to null?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@Lokadithya_M](/Lokadithya_M) Given input format: head = [3,2,0,-4], pos = 1 means that the last element -4 i.e. the tail is linked to pos=1 i.e. 2. \\n\\nPos is given with 0-index notation.  Hence, thats the difference here tail doesn\\'t point to null but an element in the list."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "read about circular linked lists  you will understand\\n"
                    },
                    {
                        "username": "Ravi_kant123",
                        "content": "Intution for this problem is if there is a cycle present in present that means we are again traversing over the nodes which we have already encounter. simple use maps to store nodes if node is already present that means there is a cycle.\\naccording to me this one is the most simple solution.\\nthere are other methods also like Floyed cyle detection you guys can also check out that.\\n\\nand in this question pos is in question just to clarify us that yes cycle is present otherwise how will they tell us. so don\\'t worry about that just solve the problem"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "quick neat method?\\n\\ntry using the Floyd cycle method. "
                    },
                    {
                        "username": "Kilderon",
                        "content": "How can i emulate this testcases in my IDE using java?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "You will have to build the whole linked list and then just pass the head as input. "
                    },
                    {
                        "username": "balinome",
                        "content": "i dont understand the 2 pointer approach , lets say we start : slow* = head and fast* = head and the slow moves 1 node at a time and fast moves 2 nodes at a time , what id the cycle is on the second and 4th nodes , the fast will not even get to those nodes ??? the fast will go from 1st to 3rd to 5th , like i just dont understand the logic "
                    },
                    {
                        "username": "Emerold",
                        "content": "If there is a cycle, eventually, you enter it, as this list is a linked list and we go from the front to the end. If the second node is part of the cycle and the second node points to the third node (by definition), the third node is also part of the cycle. You cannot have the situation that the second and 4th node are part of the cycle but the third node is not.\\n\\nAnd then, you can use the logic of the walker and runner variable.\\n\\nOnce, the runner is in the cycle, we will just run around it again and again. Yes, it skips one node every time, but this doesn\\'t matter yet. Assuming, the runner is already in the cycle going in circles, the walker will eventually reach that cycle, too (if it exists).\\n\\nNow, we have the following situation: The runner moves to steps a time, the walker moves one step a time. Lets say, the gap between the runner is of length n. Every time the walker moves one step and the runner moves two steps, this length between the two gets reduced by exactly one. As this gap gets smaller by exactly one per iteration, you will not jump over the walker with the runner by doing two steps at a time while the walker does one.\\n\\nBy that, you will eventually get the situation, that the runner is equal to the walker (if there exists a circle). \\n\\nTo be honest, in the beginning, it was confusing for me, too, that the runner wont skip over the walker. But this argument of the gap getting smaller only by one per iteration answered, why we can\\'t skip over the walker with the runner without having the equality first."
                    },
                    {
                        "username": "ankush57",
                        "content": "`class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n            if(head == NULL || head -> next == NULL)return false ;\\n\\n            int count = 10001 ;\\n\\n            while(count){\\n\\n                if(!head)return false ;\\n\\n                head = head -> next ;\\n                count-- ;\\n            } \\n\\n            return true ;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1965274,
                "content": [
                    {
                        "username": "Prat_2030",
                        "content": "\\n\\n1. Version with Array (nums):\\nIn the first version, the slow and fast pointers are used in the context of manipulating an array. This is often used in cyclic arrays or sequences where you want to detect cycles or perform some other operation. The idea is that the fast pointer advances faster than the slow pointer, and they might eventually meet or cross paths if there\\'s a cycle. This version is commonly used in algorithms like Floyd\\'s cycle detection algorithm for finding cycles in linked lists or arrays.\\nExample use cases:\\n\\nDetecting cycles in an array or linked list.\\nFinding the duplicate element in an array (Floyd\\'s Tortoise and Hare algorithm).\\n\\n```cpp\\n#include <iostream>\\n#include <vector>\\n\\nbool hasCycle(const std::vector<int>& nums) {\\n    int slow = 0, fast = 0;\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n        if (slow == fast) {\\n            return true; // Cycle detected\\n        }\\n        if (slow < 0 || fast < 0 || fast >= nums.size()) {\\n            return false; // No cycle\\n        }\\n    }\\n}\\n\\nint main() {\\n    std::vector<int> nums = {2, 5, 1, 3, 4, 2}; // Example cyclic array\\n    bool hasCycleResult = hasCycle(nums);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n    return 0;\\n}\\n```\\n\\n2. Version with Linked List:\\nIn the second version, the slow and fast pointers are used in the context of a singly linked list. The fast pointer advances by two steps while the slow pointer advances by one step. This approach is often used for operations that require traversing or processing a linked list in a certain way.\\n\\nExample use cases:\\n\\nDetecting a loop in a linked list (similar to Floyd\\'s cycle detection in arrays).\\nFinding the middle element of a linked list.\\nChecking for palindromes in a linked list.\\nMerging two sorted linked lists.\\n\\n```cpp\\n#include <iostream>\\n\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int val) : val(val), next(nullptr) {}\\n};\\n\\nbool hasCycle(ListNode* head) {\\n    if (!head || !head->next) {\\n        return false; // No cycle with 0 or 1 nodes\\n    }\\n    ListNode* slow = head->next;\\n    ListNode* fast = head->next->next;\\n    while (slow != fast) {\\n        if (!fast || !fast->next) {\\n            return false; // No cycle\\n        }\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return true; // Cycle detected\\n}\\n\\nint main() {\\n    // Example linked list with a cycle\\n    ListNode* head = new ListNode(3);\\n    head->next = new ListNode(2);\\n    head->next->next = new ListNode(0);\\n    head->next->next->next = new ListNode(-4);\\n    head->next->next->next->next = head->next; // Creating a cycle\\n\\n    bool hasCycleResult = hasCycle(head);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n\\n    // Clean up memory (not shown in the example)\\n    return 0;\\n}\\n```\\n\\nWhen to use each version:\\n\\nVersion with Array (nums):\\nUse this version when you\\'re dealing with cyclic arrays or sequences, and you need to detect cycles or perform operations related to cycles.\\nVersion with Linked List:\\nUse this version when you\\'re working with linked lists and need to traverse, manipulate, or perform specific operations like detecting loops, finding middle elements, or merging lists."
                    },
                    {
                        "username": "tawashi105",
                        "content": "The \"Input\" (e.g. head=[1], pos=1) in this problem explanation, is not input to the hasCycle function, it is input to the function which produces a ListNode instance, right?\nIf this is true, this explanation is too confusing. I wasted 2 hours."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "detecting cycles is actually a simple solution. All the question is saying that i am passing the initial node\\'s address you check weather it has a loop in it or not neverthless. Congratulations on your progress so far!"
                    },
                    {
                        "username": "louislhotte",
                        "content": "Funny problem. My answer was accepted, but it turns out it was a famous algorithm that we needed to use which was much more efficient! "
                    },
                    {
                        "username": "user8763jW",
                        "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL )\\n          return false;\\n        ListNode* slow;\\n        ListNode* fast;\\n        bool t =0;\\n        slow = head;\\n        fast = head;\\n        while (slow->next && fast->next->next)\\n        {\\n            if (slow == fast)\\n           { \\n           t=1;\\n           break;\\n           }\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return t?1:0;\\n    }\\n};\\n\\n\\n\\nwhy above code failed for \\n[-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5]\\n\\n\\n"
                    },
                    {
                        "username": "user5388FE",
                        "content": "I don\\'t really understand this question, what does cycle mean, how does -4 point to 2??? doesn\\'t the tail of the LL point to null?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@Lokadithya_M](/Lokadithya_M) Given input format: head = [3,2,0,-4], pos = 1 means that the last element -4 i.e. the tail is linked to pos=1 i.e. 2. \\n\\nPos is given with 0-index notation.  Hence, thats the difference here tail doesn\\'t point to null but an element in the list."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "read about circular linked lists  you will understand\\n"
                    },
                    {
                        "username": "Ravi_kant123",
                        "content": "Intution for this problem is if there is a cycle present in present that means we are again traversing over the nodes which we have already encounter. simple use maps to store nodes if node is already present that means there is a cycle.\\naccording to me this one is the most simple solution.\\nthere are other methods also like Floyed cyle detection you guys can also check out that.\\n\\nand in this question pos is in question just to clarify us that yes cycle is present otherwise how will they tell us. so don\\'t worry about that just solve the problem"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "quick neat method?\\n\\ntry using the Floyd cycle method. "
                    },
                    {
                        "username": "Kilderon",
                        "content": "How can i emulate this testcases in my IDE using java?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "You will have to build the whole linked list and then just pass the head as input. "
                    },
                    {
                        "username": "balinome",
                        "content": "i dont understand the 2 pointer approach , lets say we start : slow* = head and fast* = head and the slow moves 1 node at a time and fast moves 2 nodes at a time , what id the cycle is on the second and 4th nodes , the fast will not even get to those nodes ??? the fast will go from 1st to 3rd to 5th , like i just dont understand the logic "
                    },
                    {
                        "username": "Emerold",
                        "content": "If there is a cycle, eventually, you enter it, as this list is a linked list and we go from the front to the end. If the second node is part of the cycle and the second node points to the third node (by definition), the third node is also part of the cycle. You cannot have the situation that the second and 4th node are part of the cycle but the third node is not.\\n\\nAnd then, you can use the logic of the walker and runner variable.\\n\\nOnce, the runner is in the cycle, we will just run around it again and again. Yes, it skips one node every time, but this doesn\\'t matter yet. Assuming, the runner is already in the cycle going in circles, the walker will eventually reach that cycle, too (if it exists).\\n\\nNow, we have the following situation: The runner moves to steps a time, the walker moves one step a time. Lets say, the gap between the runner is of length n. Every time the walker moves one step and the runner moves two steps, this length between the two gets reduced by exactly one. As this gap gets smaller by exactly one per iteration, you will not jump over the walker with the runner by doing two steps at a time while the walker does one.\\n\\nBy that, you will eventually get the situation, that the runner is equal to the walker (if there exists a circle). \\n\\nTo be honest, in the beginning, it was confusing for me, too, that the runner wont skip over the walker. But this argument of the gap getting smaller only by one per iteration answered, why we can\\'t skip over the walker with the runner without having the equality first."
                    },
                    {
                        "username": "ankush57",
                        "content": "`class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n            if(head == NULL || head -> next == NULL)return false ;\\n\\n            int count = 10001 ;\\n\\n            while(count){\\n\\n                if(!head)return false ;\\n\\n                head = head -> next ;\\n                count-- ;\\n            } \\n\\n            return true ;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1950537,
                "content": [
                    {
                        "username": "Prat_2030",
                        "content": "\\n\\n1. Version with Array (nums):\\nIn the first version, the slow and fast pointers are used in the context of manipulating an array. This is often used in cyclic arrays or sequences where you want to detect cycles or perform some other operation. The idea is that the fast pointer advances faster than the slow pointer, and they might eventually meet or cross paths if there\\'s a cycle. This version is commonly used in algorithms like Floyd\\'s cycle detection algorithm for finding cycles in linked lists or arrays.\\nExample use cases:\\n\\nDetecting cycles in an array or linked list.\\nFinding the duplicate element in an array (Floyd\\'s Tortoise and Hare algorithm).\\n\\n```cpp\\n#include <iostream>\\n#include <vector>\\n\\nbool hasCycle(const std::vector<int>& nums) {\\n    int slow = 0, fast = 0;\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n        if (slow == fast) {\\n            return true; // Cycle detected\\n        }\\n        if (slow < 0 || fast < 0 || fast >= nums.size()) {\\n            return false; // No cycle\\n        }\\n    }\\n}\\n\\nint main() {\\n    std::vector<int> nums = {2, 5, 1, 3, 4, 2}; // Example cyclic array\\n    bool hasCycleResult = hasCycle(nums);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n    return 0;\\n}\\n```\\n\\n2. Version with Linked List:\\nIn the second version, the slow and fast pointers are used in the context of a singly linked list. The fast pointer advances by two steps while the slow pointer advances by one step. This approach is often used for operations that require traversing or processing a linked list in a certain way.\\n\\nExample use cases:\\n\\nDetecting a loop in a linked list (similar to Floyd\\'s cycle detection in arrays).\\nFinding the middle element of a linked list.\\nChecking for palindromes in a linked list.\\nMerging two sorted linked lists.\\n\\n```cpp\\n#include <iostream>\\n\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int val) : val(val), next(nullptr) {}\\n};\\n\\nbool hasCycle(ListNode* head) {\\n    if (!head || !head->next) {\\n        return false; // No cycle with 0 or 1 nodes\\n    }\\n    ListNode* slow = head->next;\\n    ListNode* fast = head->next->next;\\n    while (slow != fast) {\\n        if (!fast || !fast->next) {\\n            return false; // No cycle\\n        }\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return true; // Cycle detected\\n}\\n\\nint main() {\\n    // Example linked list with a cycle\\n    ListNode* head = new ListNode(3);\\n    head->next = new ListNode(2);\\n    head->next->next = new ListNode(0);\\n    head->next->next->next = new ListNode(-4);\\n    head->next->next->next->next = head->next; // Creating a cycle\\n\\n    bool hasCycleResult = hasCycle(head);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n\\n    // Clean up memory (not shown in the example)\\n    return 0;\\n}\\n```\\n\\nWhen to use each version:\\n\\nVersion with Array (nums):\\nUse this version when you\\'re dealing with cyclic arrays or sequences, and you need to detect cycles or perform operations related to cycles.\\nVersion with Linked List:\\nUse this version when you\\'re working with linked lists and need to traverse, manipulate, or perform specific operations like detecting loops, finding middle elements, or merging lists."
                    },
                    {
                        "username": "tawashi105",
                        "content": "The \"Input\" (e.g. head=[1], pos=1) in this problem explanation, is not input to the hasCycle function, it is input to the function which produces a ListNode instance, right?\nIf this is true, this explanation is too confusing. I wasted 2 hours."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "detecting cycles is actually a simple solution. All the question is saying that i am passing the initial node\\'s address you check weather it has a loop in it or not neverthless. Congratulations on your progress so far!"
                    },
                    {
                        "username": "louislhotte",
                        "content": "Funny problem. My answer was accepted, but it turns out it was a famous algorithm that we needed to use which was much more efficient! "
                    },
                    {
                        "username": "user8763jW",
                        "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL )\\n          return false;\\n        ListNode* slow;\\n        ListNode* fast;\\n        bool t =0;\\n        slow = head;\\n        fast = head;\\n        while (slow->next && fast->next->next)\\n        {\\n            if (slow == fast)\\n           { \\n           t=1;\\n           break;\\n           }\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return t?1:0;\\n    }\\n};\\n\\n\\n\\nwhy above code failed for \\n[-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5]\\n\\n\\n"
                    },
                    {
                        "username": "user5388FE",
                        "content": "I don\\'t really understand this question, what does cycle mean, how does -4 point to 2??? doesn\\'t the tail of the LL point to null?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@Lokadithya_M](/Lokadithya_M) Given input format: head = [3,2,0,-4], pos = 1 means that the last element -4 i.e. the tail is linked to pos=1 i.e. 2. \\n\\nPos is given with 0-index notation.  Hence, thats the difference here tail doesn\\'t point to null but an element in the list."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "read about circular linked lists  you will understand\\n"
                    },
                    {
                        "username": "Ravi_kant123",
                        "content": "Intution for this problem is if there is a cycle present in present that means we are again traversing over the nodes which we have already encounter. simple use maps to store nodes if node is already present that means there is a cycle.\\naccording to me this one is the most simple solution.\\nthere are other methods also like Floyed cyle detection you guys can also check out that.\\n\\nand in this question pos is in question just to clarify us that yes cycle is present otherwise how will they tell us. so don\\'t worry about that just solve the problem"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "quick neat method?\\n\\ntry using the Floyd cycle method. "
                    },
                    {
                        "username": "Kilderon",
                        "content": "How can i emulate this testcases in my IDE using java?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "You will have to build the whole linked list and then just pass the head as input. "
                    },
                    {
                        "username": "balinome",
                        "content": "i dont understand the 2 pointer approach , lets say we start : slow* = head and fast* = head and the slow moves 1 node at a time and fast moves 2 nodes at a time , what id the cycle is on the second and 4th nodes , the fast will not even get to those nodes ??? the fast will go from 1st to 3rd to 5th , like i just dont understand the logic "
                    },
                    {
                        "username": "Emerold",
                        "content": "If there is a cycle, eventually, you enter it, as this list is a linked list and we go from the front to the end. If the second node is part of the cycle and the second node points to the third node (by definition), the third node is also part of the cycle. You cannot have the situation that the second and 4th node are part of the cycle but the third node is not.\\n\\nAnd then, you can use the logic of the walker and runner variable.\\n\\nOnce, the runner is in the cycle, we will just run around it again and again. Yes, it skips one node every time, but this doesn\\'t matter yet. Assuming, the runner is already in the cycle going in circles, the walker will eventually reach that cycle, too (if it exists).\\n\\nNow, we have the following situation: The runner moves to steps a time, the walker moves one step a time. Lets say, the gap between the runner is of length n. Every time the walker moves one step and the runner moves two steps, this length between the two gets reduced by exactly one. As this gap gets smaller by exactly one per iteration, you will not jump over the walker with the runner by doing two steps at a time while the walker does one.\\n\\nBy that, you will eventually get the situation, that the runner is equal to the walker (if there exists a circle). \\n\\nTo be honest, in the beginning, it was confusing for me, too, that the runner wont skip over the walker. But this argument of the gap getting smaller only by one per iteration answered, why we can\\'t skip over the walker with the runner without having the equality first."
                    },
                    {
                        "username": "ankush57",
                        "content": "`class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n            if(head == NULL || head -> next == NULL)return false ;\\n\\n            int count = 10001 ;\\n\\n            while(count){\\n\\n                if(!head)return false ;\\n\\n                head = head -> next ;\\n                count-- ;\\n            } \\n\\n            return true ;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1944024,
                "content": [
                    {
                        "username": "Prat_2030",
                        "content": "\\n\\n1. Version with Array (nums):\\nIn the first version, the slow and fast pointers are used in the context of manipulating an array. This is often used in cyclic arrays or sequences where you want to detect cycles or perform some other operation. The idea is that the fast pointer advances faster than the slow pointer, and they might eventually meet or cross paths if there\\'s a cycle. This version is commonly used in algorithms like Floyd\\'s cycle detection algorithm for finding cycles in linked lists or arrays.\\nExample use cases:\\n\\nDetecting cycles in an array or linked list.\\nFinding the duplicate element in an array (Floyd\\'s Tortoise and Hare algorithm).\\n\\n```cpp\\n#include <iostream>\\n#include <vector>\\n\\nbool hasCycle(const std::vector<int>& nums) {\\n    int slow = 0, fast = 0;\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n        if (slow == fast) {\\n            return true; // Cycle detected\\n        }\\n        if (slow < 0 || fast < 0 || fast >= nums.size()) {\\n            return false; // No cycle\\n        }\\n    }\\n}\\n\\nint main() {\\n    std::vector<int> nums = {2, 5, 1, 3, 4, 2}; // Example cyclic array\\n    bool hasCycleResult = hasCycle(nums);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n    return 0;\\n}\\n```\\n\\n2. Version with Linked List:\\nIn the second version, the slow and fast pointers are used in the context of a singly linked list. The fast pointer advances by two steps while the slow pointer advances by one step. This approach is often used for operations that require traversing or processing a linked list in a certain way.\\n\\nExample use cases:\\n\\nDetecting a loop in a linked list (similar to Floyd\\'s cycle detection in arrays).\\nFinding the middle element of a linked list.\\nChecking for palindromes in a linked list.\\nMerging two sorted linked lists.\\n\\n```cpp\\n#include <iostream>\\n\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int val) : val(val), next(nullptr) {}\\n};\\n\\nbool hasCycle(ListNode* head) {\\n    if (!head || !head->next) {\\n        return false; // No cycle with 0 or 1 nodes\\n    }\\n    ListNode* slow = head->next;\\n    ListNode* fast = head->next->next;\\n    while (slow != fast) {\\n        if (!fast || !fast->next) {\\n            return false; // No cycle\\n        }\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return true; // Cycle detected\\n}\\n\\nint main() {\\n    // Example linked list with a cycle\\n    ListNode* head = new ListNode(3);\\n    head->next = new ListNode(2);\\n    head->next->next = new ListNode(0);\\n    head->next->next->next = new ListNode(-4);\\n    head->next->next->next->next = head->next; // Creating a cycle\\n\\n    bool hasCycleResult = hasCycle(head);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n\\n    // Clean up memory (not shown in the example)\\n    return 0;\\n}\\n```\\n\\nWhen to use each version:\\n\\nVersion with Array (nums):\\nUse this version when you\\'re dealing with cyclic arrays or sequences, and you need to detect cycles or perform operations related to cycles.\\nVersion with Linked List:\\nUse this version when you\\'re working with linked lists and need to traverse, manipulate, or perform specific operations like detecting loops, finding middle elements, or merging lists."
                    },
                    {
                        "username": "tawashi105",
                        "content": "The \"Input\" (e.g. head=[1], pos=1) in this problem explanation, is not input to the hasCycle function, it is input to the function which produces a ListNode instance, right?\nIf this is true, this explanation is too confusing. I wasted 2 hours."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "detecting cycles is actually a simple solution. All the question is saying that i am passing the initial node\\'s address you check weather it has a loop in it or not neverthless. Congratulations on your progress so far!"
                    },
                    {
                        "username": "louislhotte",
                        "content": "Funny problem. My answer was accepted, but it turns out it was a famous algorithm that we needed to use which was much more efficient! "
                    },
                    {
                        "username": "user8763jW",
                        "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL )\\n          return false;\\n        ListNode* slow;\\n        ListNode* fast;\\n        bool t =0;\\n        slow = head;\\n        fast = head;\\n        while (slow->next && fast->next->next)\\n        {\\n            if (slow == fast)\\n           { \\n           t=1;\\n           break;\\n           }\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return t?1:0;\\n    }\\n};\\n\\n\\n\\nwhy above code failed for \\n[-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5]\\n\\n\\n"
                    },
                    {
                        "username": "user5388FE",
                        "content": "I don\\'t really understand this question, what does cycle mean, how does -4 point to 2??? doesn\\'t the tail of the LL point to null?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@Lokadithya_M](/Lokadithya_M) Given input format: head = [3,2,0,-4], pos = 1 means that the last element -4 i.e. the tail is linked to pos=1 i.e. 2. \\n\\nPos is given with 0-index notation.  Hence, thats the difference here tail doesn\\'t point to null but an element in the list."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "read about circular linked lists  you will understand\\n"
                    },
                    {
                        "username": "Ravi_kant123",
                        "content": "Intution for this problem is if there is a cycle present in present that means we are again traversing over the nodes which we have already encounter. simple use maps to store nodes if node is already present that means there is a cycle.\\naccording to me this one is the most simple solution.\\nthere are other methods also like Floyed cyle detection you guys can also check out that.\\n\\nand in this question pos is in question just to clarify us that yes cycle is present otherwise how will they tell us. so don\\'t worry about that just solve the problem"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "quick neat method?\\n\\ntry using the Floyd cycle method. "
                    },
                    {
                        "username": "Kilderon",
                        "content": "How can i emulate this testcases in my IDE using java?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "You will have to build the whole linked list and then just pass the head as input. "
                    },
                    {
                        "username": "balinome",
                        "content": "i dont understand the 2 pointer approach , lets say we start : slow* = head and fast* = head and the slow moves 1 node at a time and fast moves 2 nodes at a time , what id the cycle is on the second and 4th nodes , the fast will not even get to those nodes ??? the fast will go from 1st to 3rd to 5th , like i just dont understand the logic "
                    },
                    {
                        "username": "Emerold",
                        "content": "If there is a cycle, eventually, you enter it, as this list is a linked list and we go from the front to the end. If the second node is part of the cycle and the second node points to the third node (by definition), the third node is also part of the cycle. You cannot have the situation that the second and 4th node are part of the cycle but the third node is not.\\n\\nAnd then, you can use the logic of the walker and runner variable.\\n\\nOnce, the runner is in the cycle, we will just run around it again and again. Yes, it skips one node every time, but this doesn\\'t matter yet. Assuming, the runner is already in the cycle going in circles, the walker will eventually reach that cycle, too (if it exists).\\n\\nNow, we have the following situation: The runner moves to steps a time, the walker moves one step a time. Lets say, the gap between the runner is of length n. Every time the walker moves one step and the runner moves two steps, this length between the two gets reduced by exactly one. As this gap gets smaller by exactly one per iteration, you will not jump over the walker with the runner by doing two steps at a time while the walker does one.\\n\\nBy that, you will eventually get the situation, that the runner is equal to the walker (if there exists a circle). \\n\\nTo be honest, in the beginning, it was confusing for me, too, that the runner wont skip over the walker. But this argument of the gap getting smaller only by one per iteration answered, why we can\\'t skip over the walker with the runner without having the equality first."
                    },
                    {
                        "username": "ankush57",
                        "content": "`class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n            if(head == NULL || head -> next == NULL)return false ;\\n\\n            int count = 10001 ;\\n\\n            while(count){\\n\\n                if(!head)return false ;\\n\\n                head = head -> next ;\\n                count-- ;\\n            } \\n\\n            return true ;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1917200,
                "content": [
                    {
                        "username": "Prat_2030",
                        "content": "\\n\\n1. Version with Array (nums):\\nIn the first version, the slow and fast pointers are used in the context of manipulating an array. This is often used in cyclic arrays or sequences where you want to detect cycles or perform some other operation. The idea is that the fast pointer advances faster than the slow pointer, and they might eventually meet or cross paths if there\\'s a cycle. This version is commonly used in algorithms like Floyd\\'s cycle detection algorithm for finding cycles in linked lists or arrays.\\nExample use cases:\\n\\nDetecting cycles in an array or linked list.\\nFinding the duplicate element in an array (Floyd\\'s Tortoise and Hare algorithm).\\n\\n```cpp\\n#include <iostream>\\n#include <vector>\\n\\nbool hasCycle(const std::vector<int>& nums) {\\n    int slow = 0, fast = 0;\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n        if (slow == fast) {\\n            return true; // Cycle detected\\n        }\\n        if (slow < 0 || fast < 0 || fast >= nums.size()) {\\n            return false; // No cycle\\n        }\\n    }\\n}\\n\\nint main() {\\n    std::vector<int> nums = {2, 5, 1, 3, 4, 2}; // Example cyclic array\\n    bool hasCycleResult = hasCycle(nums);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n    return 0;\\n}\\n```\\n\\n2. Version with Linked List:\\nIn the second version, the slow and fast pointers are used in the context of a singly linked list. The fast pointer advances by two steps while the slow pointer advances by one step. This approach is often used for operations that require traversing or processing a linked list in a certain way.\\n\\nExample use cases:\\n\\nDetecting a loop in a linked list (similar to Floyd\\'s cycle detection in arrays).\\nFinding the middle element of a linked list.\\nChecking for palindromes in a linked list.\\nMerging two sorted linked lists.\\n\\n```cpp\\n#include <iostream>\\n\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int val) : val(val), next(nullptr) {}\\n};\\n\\nbool hasCycle(ListNode* head) {\\n    if (!head || !head->next) {\\n        return false; // No cycle with 0 or 1 nodes\\n    }\\n    ListNode* slow = head->next;\\n    ListNode* fast = head->next->next;\\n    while (slow != fast) {\\n        if (!fast || !fast->next) {\\n            return false; // No cycle\\n        }\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return true; // Cycle detected\\n}\\n\\nint main() {\\n    // Example linked list with a cycle\\n    ListNode* head = new ListNode(3);\\n    head->next = new ListNode(2);\\n    head->next->next = new ListNode(0);\\n    head->next->next->next = new ListNode(-4);\\n    head->next->next->next->next = head->next; // Creating a cycle\\n\\n    bool hasCycleResult = hasCycle(head);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n\\n    // Clean up memory (not shown in the example)\\n    return 0;\\n}\\n```\\n\\nWhen to use each version:\\n\\nVersion with Array (nums):\\nUse this version when you\\'re dealing with cyclic arrays or sequences, and you need to detect cycles or perform operations related to cycles.\\nVersion with Linked List:\\nUse this version when you\\'re working with linked lists and need to traverse, manipulate, or perform specific operations like detecting loops, finding middle elements, or merging lists."
                    },
                    {
                        "username": "tawashi105",
                        "content": "The \"Input\" (e.g. head=[1], pos=1) in this problem explanation, is not input to the hasCycle function, it is input to the function which produces a ListNode instance, right?\nIf this is true, this explanation is too confusing. I wasted 2 hours."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "detecting cycles is actually a simple solution. All the question is saying that i am passing the initial node\\'s address you check weather it has a loop in it or not neverthless. Congratulations on your progress so far!"
                    },
                    {
                        "username": "louislhotte",
                        "content": "Funny problem. My answer was accepted, but it turns out it was a famous algorithm that we needed to use which was much more efficient! "
                    },
                    {
                        "username": "user8763jW",
                        "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL )\\n          return false;\\n        ListNode* slow;\\n        ListNode* fast;\\n        bool t =0;\\n        slow = head;\\n        fast = head;\\n        while (slow->next && fast->next->next)\\n        {\\n            if (slow == fast)\\n           { \\n           t=1;\\n           break;\\n           }\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return t?1:0;\\n    }\\n};\\n\\n\\n\\nwhy above code failed for \\n[-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5]\\n\\n\\n"
                    },
                    {
                        "username": "user5388FE",
                        "content": "I don\\'t really understand this question, what does cycle mean, how does -4 point to 2??? doesn\\'t the tail of the LL point to null?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@Lokadithya_M](/Lokadithya_M) Given input format: head = [3,2,0,-4], pos = 1 means that the last element -4 i.e. the tail is linked to pos=1 i.e. 2. \\n\\nPos is given with 0-index notation.  Hence, thats the difference here tail doesn\\'t point to null but an element in the list."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "read about circular linked lists  you will understand\\n"
                    },
                    {
                        "username": "Ravi_kant123",
                        "content": "Intution for this problem is if there is a cycle present in present that means we are again traversing over the nodes which we have already encounter. simple use maps to store nodes if node is already present that means there is a cycle.\\naccording to me this one is the most simple solution.\\nthere are other methods also like Floyed cyle detection you guys can also check out that.\\n\\nand in this question pos is in question just to clarify us that yes cycle is present otherwise how will they tell us. so don\\'t worry about that just solve the problem"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "quick neat method?\\n\\ntry using the Floyd cycle method. "
                    },
                    {
                        "username": "Kilderon",
                        "content": "How can i emulate this testcases in my IDE using java?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "You will have to build the whole linked list and then just pass the head as input. "
                    },
                    {
                        "username": "balinome",
                        "content": "i dont understand the 2 pointer approach , lets say we start : slow* = head and fast* = head and the slow moves 1 node at a time and fast moves 2 nodes at a time , what id the cycle is on the second and 4th nodes , the fast will not even get to those nodes ??? the fast will go from 1st to 3rd to 5th , like i just dont understand the logic "
                    },
                    {
                        "username": "Emerold",
                        "content": "If there is a cycle, eventually, you enter it, as this list is a linked list and we go from the front to the end. If the second node is part of the cycle and the second node points to the third node (by definition), the third node is also part of the cycle. You cannot have the situation that the second and 4th node are part of the cycle but the third node is not.\\n\\nAnd then, you can use the logic of the walker and runner variable.\\n\\nOnce, the runner is in the cycle, we will just run around it again and again. Yes, it skips one node every time, but this doesn\\'t matter yet. Assuming, the runner is already in the cycle going in circles, the walker will eventually reach that cycle, too (if it exists).\\n\\nNow, we have the following situation: The runner moves to steps a time, the walker moves one step a time. Lets say, the gap between the runner is of length n. Every time the walker moves one step and the runner moves two steps, this length between the two gets reduced by exactly one. As this gap gets smaller by exactly one per iteration, you will not jump over the walker with the runner by doing two steps at a time while the walker does one.\\n\\nBy that, you will eventually get the situation, that the runner is equal to the walker (if there exists a circle). \\n\\nTo be honest, in the beginning, it was confusing for me, too, that the runner wont skip over the walker. But this argument of the gap getting smaller only by one per iteration answered, why we can\\'t skip over the walker with the runner without having the equality first."
                    },
                    {
                        "username": "ankush57",
                        "content": "`class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n            if(head == NULL || head -> next == NULL)return false ;\\n\\n            int count = 10001 ;\\n\\n            while(count){\\n\\n                if(!head)return false ;\\n\\n                head = head -> next ;\\n                count-- ;\\n            } \\n\\n            return true ;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1910365,
                "content": [
                    {
                        "username": "Prat_2030",
                        "content": "\\n\\n1. Version with Array (nums):\\nIn the first version, the slow and fast pointers are used in the context of manipulating an array. This is often used in cyclic arrays or sequences where you want to detect cycles or perform some other operation. The idea is that the fast pointer advances faster than the slow pointer, and they might eventually meet or cross paths if there\\'s a cycle. This version is commonly used in algorithms like Floyd\\'s cycle detection algorithm for finding cycles in linked lists or arrays.\\nExample use cases:\\n\\nDetecting cycles in an array or linked list.\\nFinding the duplicate element in an array (Floyd\\'s Tortoise and Hare algorithm).\\n\\n```cpp\\n#include <iostream>\\n#include <vector>\\n\\nbool hasCycle(const std::vector<int>& nums) {\\n    int slow = 0, fast = 0;\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n        if (slow == fast) {\\n            return true; // Cycle detected\\n        }\\n        if (slow < 0 || fast < 0 || fast >= nums.size()) {\\n            return false; // No cycle\\n        }\\n    }\\n}\\n\\nint main() {\\n    std::vector<int> nums = {2, 5, 1, 3, 4, 2}; // Example cyclic array\\n    bool hasCycleResult = hasCycle(nums);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n    return 0;\\n}\\n```\\n\\n2. Version with Linked List:\\nIn the second version, the slow and fast pointers are used in the context of a singly linked list. The fast pointer advances by two steps while the slow pointer advances by one step. This approach is often used for operations that require traversing or processing a linked list in a certain way.\\n\\nExample use cases:\\n\\nDetecting a loop in a linked list (similar to Floyd\\'s cycle detection in arrays).\\nFinding the middle element of a linked list.\\nChecking for palindromes in a linked list.\\nMerging two sorted linked lists.\\n\\n```cpp\\n#include <iostream>\\n\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int val) : val(val), next(nullptr) {}\\n};\\n\\nbool hasCycle(ListNode* head) {\\n    if (!head || !head->next) {\\n        return false; // No cycle with 0 or 1 nodes\\n    }\\n    ListNode* slow = head->next;\\n    ListNode* fast = head->next->next;\\n    while (slow != fast) {\\n        if (!fast || !fast->next) {\\n            return false; // No cycle\\n        }\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return true; // Cycle detected\\n}\\n\\nint main() {\\n    // Example linked list with a cycle\\n    ListNode* head = new ListNode(3);\\n    head->next = new ListNode(2);\\n    head->next->next = new ListNode(0);\\n    head->next->next->next = new ListNode(-4);\\n    head->next->next->next->next = head->next; // Creating a cycle\\n\\n    bool hasCycleResult = hasCycle(head);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n\\n    // Clean up memory (not shown in the example)\\n    return 0;\\n}\\n```\\n\\nWhen to use each version:\\n\\nVersion with Array (nums):\\nUse this version when you\\'re dealing with cyclic arrays or sequences, and you need to detect cycles or perform operations related to cycles.\\nVersion with Linked List:\\nUse this version when you\\'re working with linked lists and need to traverse, manipulate, or perform specific operations like detecting loops, finding middle elements, or merging lists."
                    },
                    {
                        "username": "tawashi105",
                        "content": "The \"Input\" (e.g. head=[1], pos=1) in this problem explanation, is not input to the hasCycle function, it is input to the function which produces a ListNode instance, right?\nIf this is true, this explanation is too confusing. I wasted 2 hours."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "detecting cycles is actually a simple solution. All the question is saying that i am passing the initial node\\'s address you check weather it has a loop in it or not neverthless. Congratulations on your progress so far!"
                    },
                    {
                        "username": "louislhotte",
                        "content": "Funny problem. My answer was accepted, but it turns out it was a famous algorithm that we needed to use which was much more efficient! "
                    },
                    {
                        "username": "user8763jW",
                        "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL )\\n          return false;\\n        ListNode* slow;\\n        ListNode* fast;\\n        bool t =0;\\n        slow = head;\\n        fast = head;\\n        while (slow->next && fast->next->next)\\n        {\\n            if (slow == fast)\\n           { \\n           t=1;\\n           break;\\n           }\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return t?1:0;\\n    }\\n};\\n\\n\\n\\nwhy above code failed for \\n[-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5]\\n\\n\\n"
                    },
                    {
                        "username": "user5388FE",
                        "content": "I don\\'t really understand this question, what does cycle mean, how does -4 point to 2??? doesn\\'t the tail of the LL point to null?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@Lokadithya_M](/Lokadithya_M) Given input format: head = [3,2,0,-4], pos = 1 means that the last element -4 i.e. the tail is linked to pos=1 i.e. 2. \\n\\nPos is given with 0-index notation.  Hence, thats the difference here tail doesn\\'t point to null but an element in the list."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "read about circular linked lists  you will understand\\n"
                    },
                    {
                        "username": "Ravi_kant123",
                        "content": "Intution for this problem is if there is a cycle present in present that means we are again traversing over the nodes which we have already encounter. simple use maps to store nodes if node is already present that means there is a cycle.\\naccording to me this one is the most simple solution.\\nthere are other methods also like Floyed cyle detection you guys can also check out that.\\n\\nand in this question pos is in question just to clarify us that yes cycle is present otherwise how will they tell us. so don\\'t worry about that just solve the problem"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "quick neat method?\\n\\ntry using the Floyd cycle method. "
                    },
                    {
                        "username": "Kilderon",
                        "content": "How can i emulate this testcases in my IDE using java?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "You will have to build the whole linked list and then just pass the head as input. "
                    },
                    {
                        "username": "balinome",
                        "content": "i dont understand the 2 pointer approach , lets say we start : slow* = head and fast* = head and the slow moves 1 node at a time and fast moves 2 nodes at a time , what id the cycle is on the second and 4th nodes , the fast will not even get to those nodes ??? the fast will go from 1st to 3rd to 5th , like i just dont understand the logic "
                    },
                    {
                        "username": "Emerold",
                        "content": "If there is a cycle, eventually, you enter it, as this list is a linked list and we go from the front to the end. If the second node is part of the cycle and the second node points to the third node (by definition), the third node is also part of the cycle. You cannot have the situation that the second and 4th node are part of the cycle but the third node is not.\\n\\nAnd then, you can use the logic of the walker and runner variable.\\n\\nOnce, the runner is in the cycle, we will just run around it again and again. Yes, it skips one node every time, but this doesn\\'t matter yet. Assuming, the runner is already in the cycle going in circles, the walker will eventually reach that cycle, too (if it exists).\\n\\nNow, we have the following situation: The runner moves to steps a time, the walker moves one step a time. Lets say, the gap between the runner is of length n. Every time the walker moves one step and the runner moves two steps, this length between the two gets reduced by exactly one. As this gap gets smaller by exactly one per iteration, you will not jump over the walker with the runner by doing two steps at a time while the walker does one.\\n\\nBy that, you will eventually get the situation, that the runner is equal to the walker (if there exists a circle). \\n\\nTo be honest, in the beginning, it was confusing for me, too, that the runner wont skip over the walker. But this argument of the gap getting smaller only by one per iteration answered, why we can\\'t skip over the walker with the runner without having the equality first."
                    },
                    {
                        "username": "ankush57",
                        "content": "`class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n            if(head == NULL || head -> next == NULL)return false ;\\n\\n            int count = 10001 ;\\n\\n            while(count){\\n\\n                if(!head)return false ;\\n\\n                head = head -> next ;\\n                count-- ;\\n            } \\n\\n            return true ;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1894084,
                "content": [
                    {
                        "username": "kevinjoythomas7",
                        "content": "what does pos -1 mean would its be at null or what number"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That means, we don\\'t have any cycle and the last node has as next: null."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test some edge cases\n```\n[3,2,0,-4,5]\n4\n[3,2,0,-4,5]\n0\n[3,2,0,-4,5]\n1\n[3,2,0,-4,5]\n-1\n[1,2]\n0\n[1,2]\n1\n[1]\n-1\n[1]\n0\n[]\n-1\n```\n\n"
                    },
                    {
                        "username": "prabal2308",
                        "content": "pos is not passed as parameter but still given as input, seems strange!!\\n"
                    },
                    {
                        "username": "Surya9776036576",
                        "content": "friends here #pos has an important role although we r not going to use this in code but for test cases the #pos value ask ,to which indexed node your  last node will point "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "QUESTTION SOLUTION strikes after reading question I\\'M not pro coder but first understand the condition what task is given how to get solution If not idea strike in mind at that moment then add question in your list after 1 -2 days or week after try same question instead of watching tutorial try to solve by your own ok brother"
                    },
                    {
                        "username": "mo1ok",
                        "content": "JS interpreter seems to be missing [].findLastIndex, which can be used to handily solve this problem."
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "there is no use of \\'pos\\' in the code, it is just for the understanding what is actually going behind the scene , if tail->next points the \\'pos\\' it means cycle is present .\\n\\nYou can do this question using Floyd\\'s cycle detection algorithm\\n"
                    },
                    {
                        "username": "Ornik",
                        "content": "There is a cycle in all lists that are larger than 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442. More precisely, except for head = [1], in all the others there is a cycle, let\\'s say head = [1,2], head = [1,2,3] and so on. Do I understand correctly?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In fact, we can change that by changing pos. if pos equal -1, that means no cycle and the last node point at null."
                    },
                    {
                        "username": "mestremi6a",
                        "content": "When hit Submit get `process exited with signal SIGSEGV` error.\n\nDid anyone get this error?"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "\\nWhy can\\'t I do with one node, just check if it\\'s nullptr then it doesn\\'t have a loop, still has it, that\\'s it? "
                    },
                    {
                        "username": "amiramri",
                        "content": "In a list which has a cycle you will never see a nullptr and your programme will never reach the end. In fact you don\\'t know when to decide whether there is a nullptr or not."
                    }
                ]
            },
            {
                "id": 1889430,
                "content": [
                    {
                        "username": "kevinjoythomas7",
                        "content": "what does pos -1 mean would its be at null or what number"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That means, we don\\'t have any cycle and the last node has as next: null."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test some edge cases\n```\n[3,2,0,-4,5]\n4\n[3,2,0,-4,5]\n0\n[3,2,0,-4,5]\n1\n[3,2,0,-4,5]\n-1\n[1,2]\n0\n[1,2]\n1\n[1]\n-1\n[1]\n0\n[]\n-1\n```\n\n"
                    },
                    {
                        "username": "prabal2308",
                        "content": "pos is not passed as parameter but still given as input, seems strange!!\\n"
                    },
                    {
                        "username": "Surya9776036576",
                        "content": "friends here #pos has an important role although we r not going to use this in code but for test cases the #pos value ask ,to which indexed node your  last node will point "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "QUESTTION SOLUTION strikes after reading question I\\'M not pro coder but first understand the condition what task is given how to get solution If not idea strike in mind at that moment then add question in your list after 1 -2 days or week after try same question instead of watching tutorial try to solve by your own ok brother"
                    },
                    {
                        "username": "mo1ok",
                        "content": "JS interpreter seems to be missing [].findLastIndex, which can be used to handily solve this problem."
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "there is no use of \\'pos\\' in the code, it is just for the understanding what is actually going behind the scene , if tail->next points the \\'pos\\' it means cycle is present .\\n\\nYou can do this question using Floyd\\'s cycle detection algorithm\\n"
                    },
                    {
                        "username": "Ornik",
                        "content": "There is a cycle in all lists that are larger than 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442. More precisely, except for head = [1], in all the others there is a cycle, let\\'s say head = [1,2], head = [1,2,3] and so on. Do I understand correctly?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In fact, we can change that by changing pos. if pos equal -1, that means no cycle and the last node point at null."
                    },
                    {
                        "username": "mestremi6a",
                        "content": "When hit Submit get `process exited with signal SIGSEGV` error.\n\nDid anyone get this error?"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "\\nWhy can\\'t I do with one node, just check if it\\'s nullptr then it doesn\\'t have a loop, still has it, that\\'s it? "
                    },
                    {
                        "username": "amiramri",
                        "content": "In a list which has a cycle you will never see a nullptr and your programme will never reach the end. In fact you don\\'t know when to decide whether there is a nullptr or not."
                    }
                ]
            },
            {
                "id": 1885147,
                "content": [
                    {
                        "username": "kevinjoythomas7",
                        "content": "what does pos -1 mean would its be at null or what number"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That means, we don\\'t have any cycle and the last node has as next: null."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test some edge cases\n```\n[3,2,0,-4,5]\n4\n[3,2,0,-4,5]\n0\n[3,2,0,-4,5]\n1\n[3,2,0,-4,5]\n-1\n[1,2]\n0\n[1,2]\n1\n[1]\n-1\n[1]\n0\n[]\n-1\n```\n\n"
                    },
                    {
                        "username": "prabal2308",
                        "content": "pos is not passed as parameter but still given as input, seems strange!!\\n"
                    },
                    {
                        "username": "Surya9776036576",
                        "content": "friends here #pos has an important role although we r not going to use this in code but for test cases the #pos value ask ,to which indexed node your  last node will point "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "QUESTTION SOLUTION strikes after reading question I\\'M not pro coder but first understand the condition what task is given how to get solution If not idea strike in mind at that moment then add question in your list after 1 -2 days or week after try same question instead of watching tutorial try to solve by your own ok brother"
                    },
                    {
                        "username": "mo1ok",
                        "content": "JS interpreter seems to be missing [].findLastIndex, which can be used to handily solve this problem."
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "there is no use of \\'pos\\' in the code, it is just for the understanding what is actually going behind the scene , if tail->next points the \\'pos\\' it means cycle is present .\\n\\nYou can do this question using Floyd\\'s cycle detection algorithm\\n"
                    },
                    {
                        "username": "Ornik",
                        "content": "There is a cycle in all lists that are larger than 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442. More precisely, except for head = [1], in all the others there is a cycle, let\\'s say head = [1,2], head = [1,2,3] and so on. Do I understand correctly?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In fact, we can change that by changing pos. if pos equal -1, that means no cycle and the last node point at null."
                    },
                    {
                        "username": "mestremi6a",
                        "content": "When hit Submit get `process exited with signal SIGSEGV` error.\n\nDid anyone get this error?"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "\\nWhy can\\'t I do with one node, just check if it\\'s nullptr then it doesn\\'t have a loop, still has it, that\\'s it? "
                    },
                    {
                        "username": "amiramri",
                        "content": "In a list which has a cycle you will never see a nullptr and your programme will never reach the end. In fact you don\\'t know when to decide whether there is a nullptr or not."
                    }
                ]
            },
            {
                "id": 1879002,
                "content": [
                    {
                        "username": "kevinjoythomas7",
                        "content": "what does pos -1 mean would its be at null or what number"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That means, we don\\'t have any cycle and the last node has as next: null."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test some edge cases\n```\n[3,2,0,-4,5]\n4\n[3,2,0,-4,5]\n0\n[3,2,0,-4,5]\n1\n[3,2,0,-4,5]\n-1\n[1,2]\n0\n[1,2]\n1\n[1]\n-1\n[1]\n0\n[]\n-1\n```\n\n"
                    },
                    {
                        "username": "prabal2308",
                        "content": "pos is not passed as parameter but still given as input, seems strange!!\\n"
                    },
                    {
                        "username": "Surya9776036576",
                        "content": "friends here #pos has an important role although we r not going to use this in code but for test cases the #pos value ask ,to which indexed node your  last node will point "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "QUESTTION SOLUTION strikes after reading question I\\'M not pro coder but first understand the condition what task is given how to get solution If not idea strike in mind at that moment then add question in your list after 1 -2 days or week after try same question instead of watching tutorial try to solve by your own ok brother"
                    },
                    {
                        "username": "mo1ok",
                        "content": "JS interpreter seems to be missing [].findLastIndex, which can be used to handily solve this problem."
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "there is no use of \\'pos\\' in the code, it is just for the understanding what is actually going behind the scene , if tail->next points the \\'pos\\' it means cycle is present .\\n\\nYou can do this question using Floyd\\'s cycle detection algorithm\\n"
                    },
                    {
                        "username": "Ornik",
                        "content": "There is a cycle in all lists that are larger than 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442. More precisely, except for head = [1], in all the others there is a cycle, let\\'s say head = [1,2], head = [1,2,3] and so on. Do I understand correctly?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In fact, we can change that by changing pos. if pos equal -1, that means no cycle and the last node point at null."
                    },
                    {
                        "username": "mestremi6a",
                        "content": "When hit Submit get `process exited with signal SIGSEGV` error.\n\nDid anyone get this error?"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "\\nWhy can\\'t I do with one node, just check if it\\'s nullptr then it doesn\\'t have a loop, still has it, that\\'s it? "
                    },
                    {
                        "username": "amiramri",
                        "content": "In a list which has a cycle you will never see a nullptr and your programme will never reach the end. In fact you don\\'t know when to decide whether there is a nullptr or not."
                    }
                ]
            },
            {
                "id": 1871713,
                "content": [
                    {
                        "username": "kevinjoythomas7",
                        "content": "what does pos -1 mean would its be at null or what number"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That means, we don\\'t have any cycle and the last node has as next: null."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test some edge cases\n```\n[3,2,0,-4,5]\n4\n[3,2,0,-4,5]\n0\n[3,2,0,-4,5]\n1\n[3,2,0,-4,5]\n-1\n[1,2]\n0\n[1,2]\n1\n[1]\n-1\n[1]\n0\n[]\n-1\n```\n\n"
                    },
                    {
                        "username": "prabal2308",
                        "content": "pos is not passed as parameter but still given as input, seems strange!!\\n"
                    },
                    {
                        "username": "Surya9776036576",
                        "content": "friends here #pos has an important role although we r not going to use this in code but for test cases the #pos value ask ,to which indexed node your  last node will point "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "QUESTTION SOLUTION strikes after reading question I\\'M not pro coder but first understand the condition what task is given how to get solution If not idea strike in mind at that moment then add question in your list after 1 -2 days or week after try same question instead of watching tutorial try to solve by your own ok brother"
                    },
                    {
                        "username": "mo1ok",
                        "content": "JS interpreter seems to be missing [].findLastIndex, which can be used to handily solve this problem."
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "there is no use of \\'pos\\' in the code, it is just for the understanding what is actually going behind the scene , if tail->next points the \\'pos\\' it means cycle is present .\\n\\nYou can do this question using Floyd\\'s cycle detection algorithm\\n"
                    },
                    {
                        "username": "Ornik",
                        "content": "There is a cycle in all lists that are larger than 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442. More precisely, except for head = [1], in all the others there is a cycle, let\\'s say head = [1,2], head = [1,2,3] and so on. Do I understand correctly?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In fact, we can change that by changing pos. if pos equal -1, that means no cycle and the last node point at null."
                    },
                    {
                        "username": "mestremi6a",
                        "content": "When hit Submit get `process exited with signal SIGSEGV` error.\n\nDid anyone get this error?"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "\\nWhy can\\'t I do with one node, just check if it\\'s nullptr then it doesn\\'t have a loop, still has it, that\\'s it? "
                    },
                    {
                        "username": "amiramri",
                        "content": "In a list which has a cycle you will never see a nullptr and your programme will never reach the end. In fact you don\\'t know when to decide whether there is a nullptr or not."
                    }
                ]
            },
            {
                "id": 1869365,
                "content": [
                    {
                        "username": "kevinjoythomas7",
                        "content": "what does pos -1 mean would its be at null or what number"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That means, we don\\'t have any cycle and the last node has as next: null."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test some edge cases\n```\n[3,2,0,-4,5]\n4\n[3,2,0,-4,5]\n0\n[3,2,0,-4,5]\n1\n[3,2,0,-4,5]\n-1\n[1,2]\n0\n[1,2]\n1\n[1]\n-1\n[1]\n0\n[]\n-1\n```\n\n"
                    },
                    {
                        "username": "prabal2308",
                        "content": "pos is not passed as parameter but still given as input, seems strange!!\\n"
                    },
                    {
                        "username": "Surya9776036576",
                        "content": "friends here #pos has an important role although we r not going to use this in code but for test cases the #pos value ask ,to which indexed node your  last node will point "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "QUESTTION SOLUTION strikes after reading question I\\'M not pro coder but first understand the condition what task is given how to get solution If not idea strike in mind at that moment then add question in your list after 1 -2 days or week after try same question instead of watching tutorial try to solve by your own ok brother"
                    },
                    {
                        "username": "mo1ok",
                        "content": "JS interpreter seems to be missing [].findLastIndex, which can be used to handily solve this problem."
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "there is no use of \\'pos\\' in the code, it is just for the understanding what is actually going behind the scene , if tail->next points the \\'pos\\' it means cycle is present .\\n\\nYou can do this question using Floyd\\'s cycle detection algorithm\\n"
                    },
                    {
                        "username": "Ornik",
                        "content": "There is a cycle in all lists that are larger than 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442. More precisely, except for head = [1], in all the others there is a cycle, let\\'s say head = [1,2], head = [1,2,3] and so on. Do I understand correctly?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In fact, we can change that by changing pos. if pos equal -1, that means no cycle and the last node point at null."
                    },
                    {
                        "username": "mestremi6a",
                        "content": "When hit Submit get `process exited with signal SIGSEGV` error.\n\nDid anyone get this error?"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "\\nWhy can\\'t I do with one node, just check if it\\'s nullptr then it doesn\\'t have a loop, still has it, that\\'s it? "
                    },
                    {
                        "username": "amiramri",
                        "content": "In a list which has a cycle you will never see a nullptr and your programme will never reach the end. In fact you don\\'t know when to decide whether there is a nullptr or not."
                    }
                ]
            },
            {
                "id": 1862947,
                "content": [
                    {
                        "username": "kevinjoythomas7",
                        "content": "what does pos -1 mean would its be at null or what number"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That means, we don\\'t have any cycle and the last node has as next: null."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test some edge cases\n```\n[3,2,0,-4,5]\n4\n[3,2,0,-4,5]\n0\n[3,2,0,-4,5]\n1\n[3,2,0,-4,5]\n-1\n[1,2]\n0\n[1,2]\n1\n[1]\n-1\n[1]\n0\n[]\n-1\n```\n\n"
                    },
                    {
                        "username": "prabal2308",
                        "content": "pos is not passed as parameter but still given as input, seems strange!!\\n"
                    },
                    {
                        "username": "Surya9776036576",
                        "content": "friends here #pos has an important role although we r not going to use this in code but for test cases the #pos value ask ,to which indexed node your  last node will point "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "QUESTTION SOLUTION strikes after reading question I\\'M not pro coder but first understand the condition what task is given how to get solution If not idea strike in mind at that moment then add question in your list after 1 -2 days or week after try same question instead of watching tutorial try to solve by your own ok brother"
                    },
                    {
                        "username": "mo1ok",
                        "content": "JS interpreter seems to be missing [].findLastIndex, which can be used to handily solve this problem."
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "there is no use of \\'pos\\' in the code, it is just for the understanding what is actually going behind the scene , if tail->next points the \\'pos\\' it means cycle is present .\\n\\nYou can do this question using Floyd\\'s cycle detection algorithm\\n"
                    },
                    {
                        "username": "Ornik",
                        "content": "There is a cycle in all lists that are larger than 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442. More precisely, except for head = [1], in all the others there is a cycle, let\\'s say head = [1,2], head = [1,2,3] and so on. Do I understand correctly?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In fact, we can change that by changing pos. if pos equal -1, that means no cycle and the last node point at null."
                    },
                    {
                        "username": "mestremi6a",
                        "content": "When hit Submit get `process exited with signal SIGSEGV` error.\n\nDid anyone get this error?"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "\\nWhy can\\'t I do with one node, just check if it\\'s nullptr then it doesn\\'t have a loop, still has it, that\\'s it? "
                    },
                    {
                        "username": "amiramri",
                        "content": "In a list which has a cycle you will never see a nullptr and your programme will never reach the end. In fact you don\\'t know when to decide whether there is a nullptr or not."
                    }
                ]
            },
            {
                "id": 1856433,
                "content": [
                    {
                        "username": "kevinjoythomas7",
                        "content": "what does pos -1 mean would its be at null or what number"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That means, we don\\'t have any cycle and the last node has as next: null."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test some edge cases\n```\n[3,2,0,-4,5]\n4\n[3,2,0,-4,5]\n0\n[3,2,0,-4,5]\n1\n[3,2,0,-4,5]\n-1\n[1,2]\n0\n[1,2]\n1\n[1]\n-1\n[1]\n0\n[]\n-1\n```\n\n"
                    },
                    {
                        "username": "prabal2308",
                        "content": "pos is not passed as parameter but still given as input, seems strange!!\\n"
                    },
                    {
                        "username": "Surya9776036576",
                        "content": "friends here #pos has an important role although we r not going to use this in code but for test cases the #pos value ask ,to which indexed node your  last node will point "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "QUESTTION SOLUTION strikes after reading question I\\'M not pro coder but first understand the condition what task is given how to get solution If not idea strike in mind at that moment then add question in your list after 1 -2 days or week after try same question instead of watching tutorial try to solve by your own ok brother"
                    },
                    {
                        "username": "mo1ok",
                        "content": "JS interpreter seems to be missing [].findLastIndex, which can be used to handily solve this problem."
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "there is no use of \\'pos\\' in the code, it is just for the understanding what is actually going behind the scene , if tail->next points the \\'pos\\' it means cycle is present .\\n\\nYou can do this question using Floyd\\'s cycle detection algorithm\\n"
                    },
                    {
                        "username": "Ornik",
                        "content": "There is a cycle in all lists that are larger than 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442. More precisely, except for head = [1], in all the others there is a cycle, let\\'s say head = [1,2], head = [1,2,3] and so on. Do I understand correctly?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In fact, we can change that by changing pos. if pos equal -1, that means no cycle and the last node point at null."
                    },
                    {
                        "username": "mestremi6a",
                        "content": "When hit Submit get `process exited with signal SIGSEGV` error.\n\nDid anyone get this error?"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "\\nWhy can\\'t I do with one node, just check if it\\'s nullptr then it doesn\\'t have a loop, still has it, that\\'s it? "
                    },
                    {
                        "username": "amiramri",
                        "content": "In a list which has a cycle you will never see a nullptr and your programme will never reach the end. In fact you don\\'t know when to decide whether there is a nullptr or not."
                    }
                ]
            },
            {
                "id": 1838474,
                "content": [
                    {
                        "username": "kevinjoythomas7",
                        "content": "what does pos -1 mean would its be at null or what number"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That means, we don\\'t have any cycle and the last node has as next: null."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test some edge cases\n```\n[3,2,0,-4,5]\n4\n[3,2,0,-4,5]\n0\n[3,2,0,-4,5]\n1\n[3,2,0,-4,5]\n-1\n[1,2]\n0\n[1,2]\n1\n[1]\n-1\n[1]\n0\n[]\n-1\n```\n\n"
                    },
                    {
                        "username": "prabal2308",
                        "content": "pos is not passed as parameter but still given as input, seems strange!!\\n"
                    },
                    {
                        "username": "Surya9776036576",
                        "content": "friends here #pos has an important role although we r not going to use this in code but for test cases the #pos value ask ,to which indexed node your  last node will point "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "QUESTTION SOLUTION strikes after reading question I\\'M not pro coder but first understand the condition what task is given how to get solution If not idea strike in mind at that moment then add question in your list after 1 -2 days or week after try same question instead of watching tutorial try to solve by your own ok brother"
                    },
                    {
                        "username": "mo1ok",
                        "content": "JS interpreter seems to be missing [].findLastIndex, which can be used to handily solve this problem."
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "there is no use of \\'pos\\' in the code, it is just for the understanding what is actually going behind the scene , if tail->next points the \\'pos\\' it means cycle is present .\\n\\nYou can do this question using Floyd\\'s cycle detection algorithm\\n"
                    },
                    {
                        "username": "Ornik",
                        "content": "There is a cycle in all lists that are larger than 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442. More precisely, except for head = [1], in all the others there is a cycle, let\\'s say head = [1,2], head = [1,2,3] and so on. Do I understand correctly?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In fact, we can change that by changing pos. if pos equal -1, that means no cycle and the last node point at null."
                    },
                    {
                        "username": "mestremi6a",
                        "content": "When hit Submit get `process exited with signal SIGSEGV` error.\n\nDid anyone get this error?"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "\\nWhy can\\'t I do with one node, just check if it\\'s nullptr then it doesn\\'t have a loop, still has it, that\\'s it? "
                    },
                    {
                        "username": "amiramri",
                        "content": "In a list which has a cycle you will never see a nullptr and your programme will never reach the end. In fact you don\\'t know when to decide whether there is a nullptr or not."
                    }
                ]
            },
            {
                "id": 1834042,
                "content": [
                    {
                        "username": "kevinjoythomas7",
                        "content": "what does pos -1 mean would its be at null or what number"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That means, we don\\'t have any cycle and the last node has as next: null."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test some edge cases\n```\n[3,2,0,-4,5]\n4\n[3,2,0,-4,5]\n0\n[3,2,0,-4,5]\n1\n[3,2,0,-4,5]\n-1\n[1,2]\n0\n[1,2]\n1\n[1]\n-1\n[1]\n0\n[]\n-1\n```\n\n"
                    },
                    {
                        "username": "prabal2308",
                        "content": "pos is not passed as parameter but still given as input, seems strange!!\\n"
                    },
                    {
                        "username": "Surya9776036576",
                        "content": "friends here #pos has an important role although we r not going to use this in code but for test cases the #pos value ask ,to which indexed node your  last node will point "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "QUESTTION SOLUTION strikes after reading question I\\'M not pro coder but first understand the condition what task is given how to get solution If not idea strike in mind at that moment then add question in your list after 1 -2 days or week after try same question instead of watching tutorial try to solve by your own ok brother"
                    },
                    {
                        "username": "mo1ok",
                        "content": "JS interpreter seems to be missing [].findLastIndex, which can be used to handily solve this problem."
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "there is no use of \\'pos\\' in the code, it is just for the understanding what is actually going behind the scene , if tail->next points the \\'pos\\' it means cycle is present .\\n\\nYou can do this question using Floyd\\'s cycle detection algorithm\\n"
                    },
                    {
                        "username": "Ornik",
                        "content": "There is a cycle in all lists that are larger than 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442. More precisely, except for head = [1], in all the others there is a cycle, let\\'s say head = [1,2], head = [1,2,3] and so on. Do I understand correctly?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In fact, we can change that by changing pos. if pos equal -1, that means no cycle and the last node point at null."
                    },
                    {
                        "username": "mestremi6a",
                        "content": "When hit Submit get `process exited with signal SIGSEGV` error.\n\nDid anyone get this error?"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "\\nWhy can\\'t I do with one node, just check if it\\'s nullptr then it doesn\\'t have a loop, still has it, that\\'s it? "
                    },
                    {
                        "username": "amiramri",
                        "content": "In a list which has a cycle you will never see a nullptr and your programme will never reach the end. In fact you don\\'t know when to decide whether there is a nullptr or not."
                    }
                ]
            },
            {
                "id": 1828352,
                "content": [
                    {
                        "username": "Mukul_reign",
                        "content": "basically if in the traversal of the linked list if we discover NULL that means the linked list is not in a cycle ,... so to check the loop we can use Floyd\\'s Cycle detection algorithm which uses an two pointer,..."
                    },
                    {
                        "username": "cagils",
                        "content": "A simple solution is using the fast-slow pointer comparison approach and doing the iteration entirely in the header of the for() like this:\\nJavascript example:\\n```js\\n    for(let s = head, f = s?.next?.next; f; s = s.next, f=f.next?.next) if (f === s) return true\\n    return false\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lopharb",
                        "content": "so, can someone please explain the 3rd test case to me? the list consists of just a single element, but i\\'m pretty sure it actually has a cycle (my code returns `true` only of we encounter the same element twice, and, well, it does return `true` on the 3rd case). on the other hand, `head.next == next ` returns `false`, which makes sense cause that\\'s the answer. but, what I can\\'t understand is how does it get into a loop then? are there hidden elements or something?\\n\\nfor those who are interested in how my code works\\ni\\'ve actually tried several methods, including relative velocity, marking elements seen by changing their value to \"-\" and simply storing each element into a dictionary and seeing if any of them appears twice\\nso, i think at least one of them should work on that one\\nand each one of this approaches says there\\'s a loop in the 3rd test case\\nidk maybe i did make a mistake somewhere, but i can\\'t seem to figure out where\\n"
                    },
                    {
                        "username": "Vikasreddy369",
                        "content": "I solved by making use of constraints ,suprisingly  my solution got  accepted, but i dont think it is a better solution  , . May be i need to further optimise it"
                    },
                    {
                        "username": "user0949Z",
                        "content": "Idk what happening here. Why \\'Error - Found cycle in the ListNode\\' shows in head.next?"
                    },
                    {
                        "username": "jdsalasca",
                        "content": "Easy using the tortoise and hate algorithm"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This doesn't make sense to me: \n  class ListNode {\n      int val;\n      ListNode next;\n      ListNode(int x) {\n          val = x;\n          next = null;\n      }\n  }\n\nHow is it possible to create a node that has next different from null? Could someone explain?"
                    },
                    {
                        "username": "aakriti_meh",
                        "content": "it is simply giving the default value for any node .........even if u do not assign any value for val and next then too it will assume the default values as 0 and null [in java it works this way..i am not sure of other languages ]"
                    },
                    {
                        "username": "storzian",
                        "content": "Are all values in the list unique?"
                    },
                    {
                        "username": "vuoxa",
                        "content": "How do I need to understand from the sequences ```[3,2,0,-4]``` and ```[1,2]``` that there\\'s a cycle in them?"
                    },
                    {
                        "username": "Niemand1337",
                        "content": "There is a mistake in this question: In the inputs \\'pos\\' is given, wich is what searched in the code. For the funktion itself it is not given, as this would give the solution away. But with some code it can be read out outside of the solution and the result can be written in the user out.\\nAs this is just reading the \\'pos\\' value it is the fastes way with the least use of memory.\\n\\nI have done this in python in this problem and in the follow-up linked list cycle II, with time beat of 99.9% and memory beat of 100%.\\nThis is unfair and should be fixed in future\\n(If it is not wanted)\\n\\nFor those who want to try this:\\nIn python this can be done with the following:\\n\\'with open(\"user.out\", \"w\") as f\\'\\n\\'__Utils__().read_lines()\\'\\nand\\n\\'f.write()\\'"
                    }
                ]
            },
            {
                "id": 1826204,
                "content": [
                    {
                        "username": "Mukul_reign",
                        "content": "basically if in the traversal of the linked list if we discover NULL that means the linked list is not in a cycle ,... so to check the loop we can use Floyd\\'s Cycle detection algorithm which uses an two pointer,..."
                    },
                    {
                        "username": "cagils",
                        "content": "A simple solution is using the fast-slow pointer comparison approach and doing the iteration entirely in the header of the for() like this:\\nJavascript example:\\n```js\\n    for(let s = head, f = s?.next?.next; f; s = s.next, f=f.next?.next) if (f === s) return true\\n    return false\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lopharb",
                        "content": "so, can someone please explain the 3rd test case to me? the list consists of just a single element, but i\\'m pretty sure it actually has a cycle (my code returns `true` only of we encounter the same element twice, and, well, it does return `true` on the 3rd case). on the other hand, `head.next == next ` returns `false`, which makes sense cause that\\'s the answer. but, what I can\\'t understand is how does it get into a loop then? are there hidden elements or something?\\n\\nfor those who are interested in how my code works\\ni\\'ve actually tried several methods, including relative velocity, marking elements seen by changing their value to \"-\" and simply storing each element into a dictionary and seeing if any of them appears twice\\nso, i think at least one of them should work on that one\\nand each one of this approaches says there\\'s a loop in the 3rd test case\\nidk maybe i did make a mistake somewhere, but i can\\'t seem to figure out where\\n"
                    },
                    {
                        "username": "Vikasreddy369",
                        "content": "I solved by making use of constraints ,suprisingly  my solution got  accepted, but i dont think it is a better solution  , . May be i need to further optimise it"
                    },
                    {
                        "username": "user0949Z",
                        "content": "Idk what happening here. Why \\'Error - Found cycle in the ListNode\\' shows in head.next?"
                    },
                    {
                        "username": "jdsalasca",
                        "content": "Easy using the tortoise and hate algorithm"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This doesn't make sense to me: \n  class ListNode {\n      int val;\n      ListNode next;\n      ListNode(int x) {\n          val = x;\n          next = null;\n      }\n  }\n\nHow is it possible to create a node that has next different from null? Could someone explain?"
                    },
                    {
                        "username": "aakriti_meh",
                        "content": "it is simply giving the default value for any node .........even if u do not assign any value for val and next then too it will assume the default values as 0 and null [in java it works this way..i am not sure of other languages ]"
                    },
                    {
                        "username": "storzian",
                        "content": "Are all values in the list unique?"
                    },
                    {
                        "username": "vuoxa",
                        "content": "How do I need to understand from the sequences ```[3,2,0,-4]``` and ```[1,2]``` that there\\'s a cycle in them?"
                    },
                    {
                        "username": "Niemand1337",
                        "content": "There is a mistake in this question: In the inputs \\'pos\\' is given, wich is what searched in the code. For the funktion itself it is not given, as this would give the solution away. But with some code it can be read out outside of the solution and the result can be written in the user out.\\nAs this is just reading the \\'pos\\' value it is the fastes way with the least use of memory.\\n\\nI have done this in python in this problem and in the follow-up linked list cycle II, with time beat of 99.9% and memory beat of 100%.\\nThis is unfair and should be fixed in future\\n(If it is not wanted)\\n\\nFor those who want to try this:\\nIn python this can be done with the following:\\n\\'with open(\"user.out\", \"w\") as f\\'\\n\\'__Utils__().read_lines()\\'\\nand\\n\\'f.write()\\'"
                    }
                ]
            },
            {
                "id": 1817726,
                "content": [
                    {
                        "username": "Mukul_reign",
                        "content": "basically if in the traversal of the linked list if we discover NULL that means the linked list is not in a cycle ,... so to check the loop we can use Floyd\\'s Cycle detection algorithm which uses an two pointer,..."
                    },
                    {
                        "username": "cagils",
                        "content": "A simple solution is using the fast-slow pointer comparison approach and doing the iteration entirely in the header of the for() like this:\\nJavascript example:\\n```js\\n    for(let s = head, f = s?.next?.next; f; s = s.next, f=f.next?.next) if (f === s) return true\\n    return false\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lopharb",
                        "content": "so, can someone please explain the 3rd test case to me? the list consists of just a single element, but i\\'m pretty sure it actually has a cycle (my code returns `true` only of we encounter the same element twice, and, well, it does return `true` on the 3rd case). on the other hand, `head.next == next ` returns `false`, which makes sense cause that\\'s the answer. but, what I can\\'t understand is how does it get into a loop then? are there hidden elements or something?\\n\\nfor those who are interested in how my code works\\ni\\'ve actually tried several methods, including relative velocity, marking elements seen by changing their value to \"-\" and simply storing each element into a dictionary and seeing if any of them appears twice\\nso, i think at least one of them should work on that one\\nand each one of this approaches says there\\'s a loop in the 3rd test case\\nidk maybe i did make a mistake somewhere, but i can\\'t seem to figure out where\\n"
                    },
                    {
                        "username": "Vikasreddy369",
                        "content": "I solved by making use of constraints ,suprisingly  my solution got  accepted, but i dont think it is a better solution  , . May be i need to further optimise it"
                    },
                    {
                        "username": "user0949Z",
                        "content": "Idk what happening here. Why \\'Error - Found cycle in the ListNode\\' shows in head.next?"
                    },
                    {
                        "username": "jdsalasca",
                        "content": "Easy using the tortoise and hate algorithm"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This doesn't make sense to me: \n  class ListNode {\n      int val;\n      ListNode next;\n      ListNode(int x) {\n          val = x;\n          next = null;\n      }\n  }\n\nHow is it possible to create a node that has next different from null? Could someone explain?"
                    },
                    {
                        "username": "aakriti_meh",
                        "content": "it is simply giving the default value for any node .........even if u do not assign any value for val and next then too it will assume the default values as 0 and null [in java it works this way..i am not sure of other languages ]"
                    },
                    {
                        "username": "storzian",
                        "content": "Are all values in the list unique?"
                    },
                    {
                        "username": "vuoxa",
                        "content": "How do I need to understand from the sequences ```[3,2,0,-4]``` and ```[1,2]``` that there\\'s a cycle in them?"
                    },
                    {
                        "username": "Niemand1337",
                        "content": "There is a mistake in this question: In the inputs \\'pos\\' is given, wich is what searched in the code. For the funktion itself it is not given, as this would give the solution away. But with some code it can be read out outside of the solution and the result can be written in the user out.\\nAs this is just reading the \\'pos\\' value it is the fastes way with the least use of memory.\\n\\nI have done this in python in this problem and in the follow-up linked list cycle II, with time beat of 99.9% and memory beat of 100%.\\nThis is unfair and should be fixed in future\\n(If it is not wanted)\\n\\nFor those who want to try this:\\nIn python this can be done with the following:\\n\\'with open(\"user.out\", \"w\") as f\\'\\n\\'__Utils__().read_lines()\\'\\nand\\n\\'f.write()\\'"
                    }
                ]
            },
            {
                "id": 1808526,
                "content": [
                    {
                        "username": "Mukul_reign",
                        "content": "basically if in the traversal of the linked list if we discover NULL that means the linked list is not in a cycle ,... so to check the loop we can use Floyd\\'s Cycle detection algorithm which uses an two pointer,..."
                    },
                    {
                        "username": "cagils",
                        "content": "A simple solution is using the fast-slow pointer comparison approach and doing the iteration entirely in the header of the for() like this:\\nJavascript example:\\n```js\\n    for(let s = head, f = s?.next?.next; f; s = s.next, f=f.next?.next) if (f === s) return true\\n    return false\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lopharb",
                        "content": "so, can someone please explain the 3rd test case to me? the list consists of just a single element, but i\\'m pretty sure it actually has a cycle (my code returns `true` only of we encounter the same element twice, and, well, it does return `true` on the 3rd case). on the other hand, `head.next == next ` returns `false`, which makes sense cause that\\'s the answer. but, what I can\\'t understand is how does it get into a loop then? are there hidden elements or something?\\n\\nfor those who are interested in how my code works\\ni\\'ve actually tried several methods, including relative velocity, marking elements seen by changing their value to \"-\" and simply storing each element into a dictionary and seeing if any of them appears twice\\nso, i think at least one of them should work on that one\\nand each one of this approaches says there\\'s a loop in the 3rd test case\\nidk maybe i did make a mistake somewhere, but i can\\'t seem to figure out where\\n"
                    },
                    {
                        "username": "Vikasreddy369",
                        "content": "I solved by making use of constraints ,suprisingly  my solution got  accepted, but i dont think it is a better solution  , . May be i need to further optimise it"
                    },
                    {
                        "username": "user0949Z",
                        "content": "Idk what happening here. Why \\'Error - Found cycle in the ListNode\\' shows in head.next?"
                    },
                    {
                        "username": "jdsalasca",
                        "content": "Easy using the tortoise and hate algorithm"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This doesn't make sense to me: \n  class ListNode {\n      int val;\n      ListNode next;\n      ListNode(int x) {\n          val = x;\n          next = null;\n      }\n  }\n\nHow is it possible to create a node that has next different from null? Could someone explain?"
                    },
                    {
                        "username": "aakriti_meh",
                        "content": "it is simply giving the default value for any node .........even if u do not assign any value for val and next then too it will assume the default values as 0 and null [in java it works this way..i am not sure of other languages ]"
                    },
                    {
                        "username": "storzian",
                        "content": "Are all values in the list unique?"
                    },
                    {
                        "username": "vuoxa",
                        "content": "How do I need to understand from the sequences ```[3,2,0,-4]``` and ```[1,2]``` that there\\'s a cycle in them?"
                    },
                    {
                        "username": "Niemand1337",
                        "content": "There is a mistake in this question: In the inputs \\'pos\\' is given, wich is what searched in the code. For the funktion itself it is not given, as this would give the solution away. But with some code it can be read out outside of the solution and the result can be written in the user out.\\nAs this is just reading the \\'pos\\' value it is the fastes way with the least use of memory.\\n\\nI have done this in python in this problem and in the follow-up linked list cycle II, with time beat of 99.9% and memory beat of 100%.\\nThis is unfair and should be fixed in future\\n(If it is not wanted)\\n\\nFor those who want to try this:\\nIn python this can be done with the following:\\n\\'with open(\"user.out\", \"w\") as f\\'\\n\\'__Utils__().read_lines()\\'\\nand\\n\\'f.write()\\'"
                    }
                ]
            },
            {
                "id": 1797981,
                "content": [
                    {
                        "username": "Mukul_reign",
                        "content": "basically if in the traversal of the linked list if we discover NULL that means the linked list is not in a cycle ,... so to check the loop we can use Floyd\\'s Cycle detection algorithm which uses an two pointer,..."
                    },
                    {
                        "username": "cagils",
                        "content": "A simple solution is using the fast-slow pointer comparison approach and doing the iteration entirely in the header of the for() like this:\\nJavascript example:\\n```js\\n    for(let s = head, f = s?.next?.next; f; s = s.next, f=f.next?.next) if (f === s) return true\\n    return false\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lopharb",
                        "content": "so, can someone please explain the 3rd test case to me? the list consists of just a single element, but i\\'m pretty sure it actually has a cycle (my code returns `true` only of we encounter the same element twice, and, well, it does return `true` on the 3rd case). on the other hand, `head.next == next ` returns `false`, which makes sense cause that\\'s the answer. but, what I can\\'t understand is how does it get into a loop then? are there hidden elements or something?\\n\\nfor those who are interested in how my code works\\ni\\'ve actually tried several methods, including relative velocity, marking elements seen by changing their value to \"-\" and simply storing each element into a dictionary and seeing if any of them appears twice\\nso, i think at least one of them should work on that one\\nand each one of this approaches says there\\'s a loop in the 3rd test case\\nidk maybe i did make a mistake somewhere, but i can\\'t seem to figure out where\\n"
                    },
                    {
                        "username": "Vikasreddy369",
                        "content": "I solved by making use of constraints ,suprisingly  my solution got  accepted, but i dont think it is a better solution  , . May be i need to further optimise it"
                    },
                    {
                        "username": "user0949Z",
                        "content": "Idk what happening here. Why \\'Error - Found cycle in the ListNode\\' shows in head.next?"
                    },
                    {
                        "username": "jdsalasca",
                        "content": "Easy using the tortoise and hate algorithm"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This doesn't make sense to me: \n  class ListNode {\n      int val;\n      ListNode next;\n      ListNode(int x) {\n          val = x;\n          next = null;\n      }\n  }\n\nHow is it possible to create a node that has next different from null? Could someone explain?"
                    },
                    {
                        "username": "aakriti_meh",
                        "content": "it is simply giving the default value for any node .........even if u do not assign any value for val and next then too it will assume the default values as 0 and null [in java it works this way..i am not sure of other languages ]"
                    },
                    {
                        "username": "storzian",
                        "content": "Are all values in the list unique?"
                    },
                    {
                        "username": "vuoxa",
                        "content": "How do I need to understand from the sequences ```[3,2,0,-4]``` and ```[1,2]``` that there\\'s a cycle in them?"
                    },
                    {
                        "username": "Niemand1337",
                        "content": "There is a mistake in this question: In the inputs \\'pos\\' is given, wich is what searched in the code. For the funktion itself it is not given, as this would give the solution away. But with some code it can be read out outside of the solution and the result can be written in the user out.\\nAs this is just reading the \\'pos\\' value it is the fastes way with the least use of memory.\\n\\nI have done this in python in this problem and in the follow-up linked list cycle II, with time beat of 99.9% and memory beat of 100%.\\nThis is unfair and should be fixed in future\\n(If it is not wanted)\\n\\nFor those who want to try this:\\nIn python this can be done with the following:\\n\\'with open(\"user.out\", \"w\") as f\\'\\n\\'__Utils__().read_lines()\\'\\nand\\n\\'f.write()\\'"
                    }
                ]
            },
            {
                "id": 1796905,
                "content": [
                    {
                        "username": "Mukul_reign",
                        "content": "basically if in the traversal of the linked list if we discover NULL that means the linked list is not in a cycle ,... so to check the loop we can use Floyd\\'s Cycle detection algorithm which uses an two pointer,..."
                    },
                    {
                        "username": "cagils",
                        "content": "A simple solution is using the fast-slow pointer comparison approach and doing the iteration entirely in the header of the for() like this:\\nJavascript example:\\n```js\\n    for(let s = head, f = s?.next?.next; f; s = s.next, f=f.next?.next) if (f === s) return true\\n    return false\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lopharb",
                        "content": "so, can someone please explain the 3rd test case to me? the list consists of just a single element, but i\\'m pretty sure it actually has a cycle (my code returns `true` only of we encounter the same element twice, and, well, it does return `true` on the 3rd case). on the other hand, `head.next == next ` returns `false`, which makes sense cause that\\'s the answer. but, what I can\\'t understand is how does it get into a loop then? are there hidden elements or something?\\n\\nfor those who are interested in how my code works\\ni\\'ve actually tried several methods, including relative velocity, marking elements seen by changing their value to \"-\" and simply storing each element into a dictionary and seeing if any of them appears twice\\nso, i think at least one of them should work on that one\\nand each one of this approaches says there\\'s a loop in the 3rd test case\\nidk maybe i did make a mistake somewhere, but i can\\'t seem to figure out where\\n"
                    },
                    {
                        "username": "Vikasreddy369",
                        "content": "I solved by making use of constraints ,suprisingly  my solution got  accepted, but i dont think it is a better solution  , . May be i need to further optimise it"
                    },
                    {
                        "username": "user0949Z",
                        "content": "Idk what happening here. Why \\'Error - Found cycle in the ListNode\\' shows in head.next?"
                    },
                    {
                        "username": "jdsalasca",
                        "content": "Easy using the tortoise and hate algorithm"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This doesn't make sense to me: \n  class ListNode {\n      int val;\n      ListNode next;\n      ListNode(int x) {\n          val = x;\n          next = null;\n      }\n  }\n\nHow is it possible to create a node that has next different from null? Could someone explain?"
                    },
                    {
                        "username": "aakriti_meh",
                        "content": "it is simply giving the default value for any node .........even if u do not assign any value for val and next then too it will assume the default values as 0 and null [in java it works this way..i am not sure of other languages ]"
                    },
                    {
                        "username": "storzian",
                        "content": "Are all values in the list unique?"
                    },
                    {
                        "username": "vuoxa",
                        "content": "How do I need to understand from the sequences ```[3,2,0,-4]``` and ```[1,2]``` that there\\'s a cycle in them?"
                    },
                    {
                        "username": "Niemand1337",
                        "content": "There is a mistake in this question: In the inputs \\'pos\\' is given, wich is what searched in the code. For the funktion itself it is not given, as this would give the solution away. But with some code it can be read out outside of the solution and the result can be written in the user out.\\nAs this is just reading the \\'pos\\' value it is the fastes way with the least use of memory.\\n\\nI have done this in python in this problem and in the follow-up linked list cycle II, with time beat of 99.9% and memory beat of 100%.\\nThis is unfair and should be fixed in future\\n(If it is not wanted)\\n\\nFor those who want to try this:\\nIn python this can be done with the following:\\n\\'with open(\"user.out\", \"w\") as f\\'\\n\\'__Utils__().read_lines()\\'\\nand\\n\\'f.write()\\'"
                    }
                ]
            },
            {
                "id": 1796031,
                "content": [
                    {
                        "username": "Mukul_reign",
                        "content": "basically if in the traversal of the linked list if we discover NULL that means the linked list is not in a cycle ,... so to check the loop we can use Floyd\\'s Cycle detection algorithm which uses an two pointer,..."
                    },
                    {
                        "username": "cagils",
                        "content": "A simple solution is using the fast-slow pointer comparison approach and doing the iteration entirely in the header of the for() like this:\\nJavascript example:\\n```js\\n    for(let s = head, f = s?.next?.next; f; s = s.next, f=f.next?.next) if (f === s) return true\\n    return false\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lopharb",
                        "content": "so, can someone please explain the 3rd test case to me? the list consists of just a single element, but i\\'m pretty sure it actually has a cycle (my code returns `true` only of we encounter the same element twice, and, well, it does return `true` on the 3rd case). on the other hand, `head.next == next ` returns `false`, which makes sense cause that\\'s the answer. but, what I can\\'t understand is how does it get into a loop then? are there hidden elements or something?\\n\\nfor those who are interested in how my code works\\ni\\'ve actually tried several methods, including relative velocity, marking elements seen by changing their value to \"-\" and simply storing each element into a dictionary and seeing if any of them appears twice\\nso, i think at least one of them should work on that one\\nand each one of this approaches says there\\'s a loop in the 3rd test case\\nidk maybe i did make a mistake somewhere, but i can\\'t seem to figure out where\\n"
                    },
                    {
                        "username": "Vikasreddy369",
                        "content": "I solved by making use of constraints ,suprisingly  my solution got  accepted, but i dont think it is a better solution  , . May be i need to further optimise it"
                    },
                    {
                        "username": "user0949Z",
                        "content": "Idk what happening here. Why \\'Error - Found cycle in the ListNode\\' shows in head.next?"
                    },
                    {
                        "username": "jdsalasca",
                        "content": "Easy using the tortoise and hate algorithm"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This doesn't make sense to me: \n  class ListNode {\n      int val;\n      ListNode next;\n      ListNode(int x) {\n          val = x;\n          next = null;\n      }\n  }\n\nHow is it possible to create a node that has next different from null? Could someone explain?"
                    },
                    {
                        "username": "aakriti_meh",
                        "content": "it is simply giving the default value for any node .........even if u do not assign any value for val and next then too it will assume the default values as 0 and null [in java it works this way..i am not sure of other languages ]"
                    },
                    {
                        "username": "storzian",
                        "content": "Are all values in the list unique?"
                    },
                    {
                        "username": "vuoxa",
                        "content": "How do I need to understand from the sequences ```[3,2,0,-4]``` and ```[1,2]``` that there\\'s a cycle in them?"
                    },
                    {
                        "username": "Niemand1337",
                        "content": "There is a mistake in this question: In the inputs \\'pos\\' is given, wich is what searched in the code. For the funktion itself it is not given, as this would give the solution away. But with some code it can be read out outside of the solution and the result can be written in the user out.\\nAs this is just reading the \\'pos\\' value it is the fastes way with the least use of memory.\\n\\nI have done this in python in this problem and in the follow-up linked list cycle II, with time beat of 99.9% and memory beat of 100%.\\nThis is unfair and should be fixed in future\\n(If it is not wanted)\\n\\nFor those who want to try this:\\nIn python this can be done with the following:\\n\\'with open(\"user.out\", \"w\") as f\\'\\n\\'__Utils__().read_lines()\\'\\nand\\n\\'f.write()\\'"
                    }
                ]
            },
            {
                "id": 1795810,
                "content": [
                    {
                        "username": "Mukul_reign",
                        "content": "basically if in the traversal of the linked list if we discover NULL that means the linked list is not in a cycle ,... so to check the loop we can use Floyd\\'s Cycle detection algorithm which uses an two pointer,..."
                    },
                    {
                        "username": "cagils",
                        "content": "A simple solution is using the fast-slow pointer comparison approach and doing the iteration entirely in the header of the for() like this:\\nJavascript example:\\n```js\\n    for(let s = head, f = s?.next?.next; f; s = s.next, f=f.next?.next) if (f === s) return true\\n    return false\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lopharb",
                        "content": "so, can someone please explain the 3rd test case to me? the list consists of just a single element, but i\\'m pretty sure it actually has a cycle (my code returns `true` only of we encounter the same element twice, and, well, it does return `true` on the 3rd case). on the other hand, `head.next == next ` returns `false`, which makes sense cause that\\'s the answer. but, what I can\\'t understand is how does it get into a loop then? are there hidden elements or something?\\n\\nfor those who are interested in how my code works\\ni\\'ve actually tried several methods, including relative velocity, marking elements seen by changing their value to \"-\" and simply storing each element into a dictionary and seeing if any of them appears twice\\nso, i think at least one of them should work on that one\\nand each one of this approaches says there\\'s a loop in the 3rd test case\\nidk maybe i did make a mistake somewhere, but i can\\'t seem to figure out where\\n"
                    },
                    {
                        "username": "Vikasreddy369",
                        "content": "I solved by making use of constraints ,suprisingly  my solution got  accepted, but i dont think it is a better solution  , . May be i need to further optimise it"
                    },
                    {
                        "username": "user0949Z",
                        "content": "Idk what happening here. Why \\'Error - Found cycle in the ListNode\\' shows in head.next?"
                    },
                    {
                        "username": "jdsalasca",
                        "content": "Easy using the tortoise and hate algorithm"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This doesn't make sense to me: \n  class ListNode {\n      int val;\n      ListNode next;\n      ListNode(int x) {\n          val = x;\n          next = null;\n      }\n  }\n\nHow is it possible to create a node that has next different from null? Could someone explain?"
                    },
                    {
                        "username": "aakriti_meh",
                        "content": "it is simply giving the default value for any node .........even if u do not assign any value for val and next then too it will assume the default values as 0 and null [in java it works this way..i am not sure of other languages ]"
                    },
                    {
                        "username": "storzian",
                        "content": "Are all values in the list unique?"
                    },
                    {
                        "username": "vuoxa",
                        "content": "How do I need to understand from the sequences ```[3,2,0,-4]``` and ```[1,2]``` that there\\'s a cycle in them?"
                    },
                    {
                        "username": "Niemand1337",
                        "content": "There is a mistake in this question: In the inputs \\'pos\\' is given, wich is what searched in the code. For the funktion itself it is not given, as this would give the solution away. But with some code it can be read out outside of the solution and the result can be written in the user out.\\nAs this is just reading the \\'pos\\' value it is the fastes way with the least use of memory.\\n\\nI have done this in python in this problem and in the follow-up linked list cycle II, with time beat of 99.9% and memory beat of 100%.\\nThis is unfair and should be fixed in future\\n(If it is not wanted)\\n\\nFor those who want to try this:\\nIn python this can be done with the following:\\n\\'with open(\"user.out\", \"w\") as f\\'\\n\\'__Utils__().read_lines()\\'\\nand\\n\\'f.write()\\'"
                    }
                ]
            },
            {
                "id": 1789283,
                "content": [
                    {
                        "username": "Mukul_reign",
                        "content": "basically if in the traversal of the linked list if we discover NULL that means the linked list is not in a cycle ,... so to check the loop we can use Floyd\\'s Cycle detection algorithm which uses an two pointer,..."
                    },
                    {
                        "username": "cagils",
                        "content": "A simple solution is using the fast-slow pointer comparison approach and doing the iteration entirely in the header of the for() like this:\\nJavascript example:\\n```js\\n    for(let s = head, f = s?.next?.next; f; s = s.next, f=f.next?.next) if (f === s) return true\\n    return false\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lopharb",
                        "content": "so, can someone please explain the 3rd test case to me? the list consists of just a single element, but i\\'m pretty sure it actually has a cycle (my code returns `true` only of we encounter the same element twice, and, well, it does return `true` on the 3rd case). on the other hand, `head.next == next ` returns `false`, which makes sense cause that\\'s the answer. but, what I can\\'t understand is how does it get into a loop then? are there hidden elements or something?\\n\\nfor those who are interested in how my code works\\ni\\'ve actually tried several methods, including relative velocity, marking elements seen by changing their value to \"-\" and simply storing each element into a dictionary and seeing if any of them appears twice\\nso, i think at least one of them should work on that one\\nand each one of this approaches says there\\'s a loop in the 3rd test case\\nidk maybe i did make a mistake somewhere, but i can\\'t seem to figure out where\\n"
                    },
                    {
                        "username": "Vikasreddy369",
                        "content": "I solved by making use of constraints ,suprisingly  my solution got  accepted, but i dont think it is a better solution  , . May be i need to further optimise it"
                    },
                    {
                        "username": "user0949Z",
                        "content": "Idk what happening here. Why \\'Error - Found cycle in the ListNode\\' shows in head.next?"
                    },
                    {
                        "username": "jdsalasca",
                        "content": "Easy using the tortoise and hate algorithm"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This doesn't make sense to me: \n  class ListNode {\n      int val;\n      ListNode next;\n      ListNode(int x) {\n          val = x;\n          next = null;\n      }\n  }\n\nHow is it possible to create a node that has next different from null? Could someone explain?"
                    },
                    {
                        "username": "aakriti_meh",
                        "content": "it is simply giving the default value for any node .........even if u do not assign any value for val and next then too it will assume the default values as 0 and null [in java it works this way..i am not sure of other languages ]"
                    },
                    {
                        "username": "storzian",
                        "content": "Are all values in the list unique?"
                    },
                    {
                        "username": "vuoxa",
                        "content": "How do I need to understand from the sequences ```[3,2,0,-4]``` and ```[1,2]``` that there\\'s a cycle in them?"
                    },
                    {
                        "username": "Niemand1337",
                        "content": "There is a mistake in this question: In the inputs \\'pos\\' is given, wich is what searched in the code. For the funktion itself it is not given, as this would give the solution away. But with some code it can be read out outside of the solution and the result can be written in the user out.\\nAs this is just reading the \\'pos\\' value it is the fastes way with the least use of memory.\\n\\nI have done this in python in this problem and in the follow-up linked list cycle II, with time beat of 99.9% and memory beat of 100%.\\nThis is unfair and should be fixed in future\\n(If it is not wanted)\\n\\nFor those who want to try this:\\nIn python this can be done with the following:\\n\\'with open(\"user.out\", \"w\") as f\\'\\n\\'__Utils__().read_lines()\\'\\nand\\n\\'f.write()\\'"
                    }
                ]
            },
            {
                "id": 1786432,
                "content": [
                    {
                        "username": "Mukul_reign",
                        "content": "basically if in the traversal of the linked list if we discover NULL that means the linked list is not in a cycle ,... so to check the loop we can use Floyd\\'s Cycle detection algorithm which uses an two pointer,..."
                    },
                    {
                        "username": "cagils",
                        "content": "A simple solution is using the fast-slow pointer comparison approach and doing the iteration entirely in the header of the for() like this:\\nJavascript example:\\n```js\\n    for(let s = head, f = s?.next?.next; f; s = s.next, f=f.next?.next) if (f === s) return true\\n    return false\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lopharb",
                        "content": "so, can someone please explain the 3rd test case to me? the list consists of just a single element, but i\\'m pretty sure it actually has a cycle (my code returns `true` only of we encounter the same element twice, and, well, it does return `true` on the 3rd case). on the other hand, `head.next == next ` returns `false`, which makes sense cause that\\'s the answer. but, what I can\\'t understand is how does it get into a loop then? are there hidden elements or something?\\n\\nfor those who are interested in how my code works\\ni\\'ve actually tried several methods, including relative velocity, marking elements seen by changing their value to \"-\" and simply storing each element into a dictionary and seeing if any of them appears twice\\nso, i think at least one of them should work on that one\\nand each one of this approaches says there\\'s a loop in the 3rd test case\\nidk maybe i did make a mistake somewhere, but i can\\'t seem to figure out where\\n"
                    },
                    {
                        "username": "Vikasreddy369",
                        "content": "I solved by making use of constraints ,suprisingly  my solution got  accepted, but i dont think it is a better solution  , . May be i need to further optimise it"
                    },
                    {
                        "username": "user0949Z",
                        "content": "Idk what happening here. Why \\'Error - Found cycle in the ListNode\\' shows in head.next?"
                    },
                    {
                        "username": "jdsalasca",
                        "content": "Easy using the tortoise and hate algorithm"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This doesn't make sense to me: \n  class ListNode {\n      int val;\n      ListNode next;\n      ListNode(int x) {\n          val = x;\n          next = null;\n      }\n  }\n\nHow is it possible to create a node that has next different from null? Could someone explain?"
                    },
                    {
                        "username": "aakriti_meh",
                        "content": "it is simply giving the default value for any node .........even if u do not assign any value for val and next then too it will assume the default values as 0 and null [in java it works this way..i am not sure of other languages ]"
                    },
                    {
                        "username": "storzian",
                        "content": "Are all values in the list unique?"
                    },
                    {
                        "username": "vuoxa",
                        "content": "How do I need to understand from the sequences ```[3,2,0,-4]``` and ```[1,2]``` that there\\'s a cycle in them?"
                    },
                    {
                        "username": "Niemand1337",
                        "content": "There is a mistake in this question: In the inputs \\'pos\\' is given, wich is what searched in the code. For the funktion itself it is not given, as this would give the solution away. But with some code it can be read out outside of the solution and the result can be written in the user out.\\nAs this is just reading the \\'pos\\' value it is the fastes way with the least use of memory.\\n\\nI have done this in python in this problem and in the follow-up linked list cycle II, with time beat of 99.9% and memory beat of 100%.\\nThis is unfair and should be fixed in future\\n(If it is not wanted)\\n\\nFor those who want to try this:\\nIn python this can be done with the following:\\n\\'with open(\"user.out\", \"w\") as f\\'\\n\\'__Utils__().read_lines()\\'\\nand\\n\\'f.write()\\'"
                    }
                ]
            },
            {
                "id": 1774539,
                "content": [
                    {
                        "username": "NarinderSingh",
                        "content": "NO NEED TO USE ANY POINTER\\n1) Hint - Take Advantage of what credentials they have given in the que.\\n2) Hint - Try to use recursion.\\n3) Hint - Change linked List Values ( we have to just find whether a cycle is there or not. we can manipulate the list )"
                    },
                    {
                        "username": "icantcodeatall",
                        "content": "For anyone confused about the \"pos\", you can safely ignore it. It\\'s an internal detail, not something to worry about. \\nYou just need to do is detect if there\\'s a cycle in the linked list, that\\'s all."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": " //java code \\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n            if(head == null || head.next == null)\\n            {\\n            return false;\\n            }\\n            ListNode slow = head;\\n            ListNode fast = head.next;\\n        while(slow != fast) {\\n                if(fast == null || fast.next == null)\\n                {\\n                return false;\\n                }\\n        slow = slow.next;\\n        fast = fast.next.next;\\n         }\\n         return true;\\n      }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9131YR",
                        "content": "I don't understand why one would even resort to Floyd's cycle detection. Just iterate 10000 times and see if null pointers are hit, no?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Vishwas_Khanna",
                        "content": "pos as input is confusing."
                    },
                    {
                        "username": "aprilman_j",
                        "content": "In case of java solution I think this is bad idea to let people compare objects with `==`. After looking at solution some people might think this is correct approach."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "kzlatt",
                        "content": "OK.. I am confused. At first I thought \"are all values unique and non-repeating\". Later I just blindly use a continuously appended list of heads (a bit dumb) but it works (with runtime <6%  with >1 sec). \\n\\nPlease someone confirms if my understanding is correct.... (i have no formal CS degree so not sure these link-lists are common things in pro-world)\\n......\\nData structure has two elements [value, memory address] or  [v, add] for short..\\nThese data are stored in the memory with address following :\\n\\nMemory -->  what stored in that place\\nadd_0 --> [ val_1, add_1]\\nadd_1 --> [ val_2, add_2]\\nadd_2 --> [ val_3, add_3]\\nadd_3 --> [ val_4, add_1]    # now this is circulating back to add_1\\n\\n\\'head\\' variable actually stored \\'add_0\\', the memory address of [ val, add]..  and  \\'head.val\\' give the \\'val_1\\' (which never used) and \\'head.next\\' give the memory address \\'add_1\\' stored in the head. So when I use    \\'p = head.next\\'... now \\'p = add_1\\'   and   \\'p.val = val_2\\' and \\'p.next = add_2\\'..\\n\\nis that correct.???? I believe that is why there is no two \\'heads\\' alike without cycling but there may be possible that values are circulating .. eg: [head.next.val for i in range(x)]  could gives  [ 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5, ... so on ]  with repeating pattern of values without \"cycling\" in their sense."
                    }
                ]
            },
            {
                "id": 1768570,
                "content": [
                    {
                        "username": "NarinderSingh",
                        "content": "NO NEED TO USE ANY POINTER\\n1) Hint - Take Advantage of what credentials they have given in the que.\\n2) Hint - Try to use recursion.\\n3) Hint - Change linked List Values ( we have to just find whether a cycle is there or not. we can manipulate the list )"
                    },
                    {
                        "username": "icantcodeatall",
                        "content": "For anyone confused about the \"pos\", you can safely ignore it. It\\'s an internal detail, not something to worry about. \\nYou just need to do is detect if there\\'s a cycle in the linked list, that\\'s all."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": " //java code \\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n            if(head == null || head.next == null)\\n            {\\n            return false;\\n            }\\n            ListNode slow = head;\\n            ListNode fast = head.next;\\n        while(slow != fast) {\\n                if(fast == null || fast.next == null)\\n                {\\n                return false;\\n                }\\n        slow = slow.next;\\n        fast = fast.next.next;\\n         }\\n         return true;\\n      }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9131YR",
                        "content": "I don't understand why one would even resort to Floyd's cycle detection. Just iterate 10000 times and see if null pointers are hit, no?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Vishwas_Khanna",
                        "content": "pos as input is confusing."
                    },
                    {
                        "username": "aprilman_j",
                        "content": "In case of java solution I think this is bad idea to let people compare objects with `==`. After looking at solution some people might think this is correct approach."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "kzlatt",
                        "content": "OK.. I am confused. At first I thought \"are all values unique and non-repeating\". Later I just blindly use a continuously appended list of heads (a bit dumb) but it works (with runtime <6%  with >1 sec). \\n\\nPlease someone confirms if my understanding is correct.... (i have no formal CS degree so not sure these link-lists are common things in pro-world)\\n......\\nData structure has two elements [value, memory address] or  [v, add] for short..\\nThese data are stored in the memory with address following :\\n\\nMemory -->  what stored in that place\\nadd_0 --> [ val_1, add_1]\\nadd_1 --> [ val_2, add_2]\\nadd_2 --> [ val_3, add_3]\\nadd_3 --> [ val_4, add_1]    # now this is circulating back to add_1\\n\\n\\'head\\' variable actually stored \\'add_0\\', the memory address of [ val, add]..  and  \\'head.val\\' give the \\'val_1\\' (which never used) and \\'head.next\\' give the memory address \\'add_1\\' stored in the head. So when I use    \\'p = head.next\\'... now \\'p = add_1\\'   and   \\'p.val = val_2\\' and \\'p.next = add_2\\'..\\n\\nis that correct.???? I believe that is why there is no two \\'heads\\' alike without cycling but there may be possible that values are circulating .. eg: [head.next.val for i in range(x)]  could gives  [ 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5, ... so on ]  with repeating pattern of values without \"cycling\" in their sense."
                    }
                ]
            },
            {
                "id": 1768473,
                "content": [
                    {
                        "username": "NarinderSingh",
                        "content": "NO NEED TO USE ANY POINTER\\n1) Hint - Take Advantage of what credentials they have given in the que.\\n2) Hint - Try to use recursion.\\n3) Hint - Change linked List Values ( we have to just find whether a cycle is there or not. we can manipulate the list )"
                    },
                    {
                        "username": "icantcodeatall",
                        "content": "For anyone confused about the \"pos\", you can safely ignore it. It\\'s an internal detail, not something to worry about. \\nYou just need to do is detect if there\\'s a cycle in the linked list, that\\'s all."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": " //java code \\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n            if(head == null || head.next == null)\\n            {\\n            return false;\\n            }\\n            ListNode slow = head;\\n            ListNode fast = head.next;\\n        while(slow != fast) {\\n                if(fast == null || fast.next == null)\\n                {\\n                return false;\\n                }\\n        slow = slow.next;\\n        fast = fast.next.next;\\n         }\\n         return true;\\n      }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9131YR",
                        "content": "I don't understand why one would even resort to Floyd's cycle detection. Just iterate 10000 times and see if null pointers are hit, no?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Vishwas_Khanna",
                        "content": "pos as input is confusing."
                    },
                    {
                        "username": "aprilman_j",
                        "content": "In case of java solution I think this is bad idea to let people compare objects with `==`. After looking at solution some people might think this is correct approach."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "kzlatt",
                        "content": "OK.. I am confused. At first I thought \"are all values unique and non-repeating\". Later I just blindly use a continuously appended list of heads (a bit dumb) but it works (with runtime <6%  with >1 sec). \\n\\nPlease someone confirms if my understanding is correct.... (i have no formal CS degree so not sure these link-lists are common things in pro-world)\\n......\\nData structure has two elements [value, memory address] or  [v, add] for short..\\nThese data are stored in the memory with address following :\\n\\nMemory -->  what stored in that place\\nadd_0 --> [ val_1, add_1]\\nadd_1 --> [ val_2, add_2]\\nadd_2 --> [ val_3, add_3]\\nadd_3 --> [ val_4, add_1]    # now this is circulating back to add_1\\n\\n\\'head\\' variable actually stored \\'add_0\\', the memory address of [ val, add]..  and  \\'head.val\\' give the \\'val_1\\' (which never used) and \\'head.next\\' give the memory address \\'add_1\\' stored in the head. So when I use    \\'p = head.next\\'... now \\'p = add_1\\'   and   \\'p.val = val_2\\' and \\'p.next = add_2\\'..\\n\\nis that correct.???? I believe that is why there is no two \\'heads\\' alike without cycling but there may be possible that values are circulating .. eg: [head.next.val for i in range(x)]  could gives  [ 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5, ... so on ]  with repeating pattern of values without \"cycling\" in their sense."
                    }
                ]
            },
            {
                "id": 1766243,
                "content": [
                    {
                        "username": "NarinderSingh",
                        "content": "NO NEED TO USE ANY POINTER\\n1) Hint - Take Advantage of what credentials they have given in the que.\\n2) Hint - Try to use recursion.\\n3) Hint - Change linked List Values ( we have to just find whether a cycle is there or not. we can manipulate the list )"
                    },
                    {
                        "username": "icantcodeatall",
                        "content": "For anyone confused about the \"pos\", you can safely ignore it. It\\'s an internal detail, not something to worry about. \\nYou just need to do is detect if there\\'s a cycle in the linked list, that\\'s all."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": " //java code \\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n            if(head == null || head.next == null)\\n            {\\n            return false;\\n            }\\n            ListNode slow = head;\\n            ListNode fast = head.next;\\n        while(slow != fast) {\\n                if(fast == null || fast.next == null)\\n                {\\n                return false;\\n                }\\n        slow = slow.next;\\n        fast = fast.next.next;\\n         }\\n         return true;\\n      }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9131YR",
                        "content": "I don't understand why one would even resort to Floyd's cycle detection. Just iterate 10000 times and see if null pointers are hit, no?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Vishwas_Khanna",
                        "content": "pos as input is confusing."
                    },
                    {
                        "username": "aprilman_j",
                        "content": "In case of java solution I think this is bad idea to let people compare objects with `==`. After looking at solution some people might think this is correct approach."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "kzlatt",
                        "content": "OK.. I am confused. At first I thought \"are all values unique and non-repeating\". Later I just blindly use a continuously appended list of heads (a bit dumb) but it works (with runtime <6%  with >1 sec). \\n\\nPlease someone confirms if my understanding is correct.... (i have no formal CS degree so not sure these link-lists are common things in pro-world)\\n......\\nData structure has two elements [value, memory address] or  [v, add] for short..\\nThese data are stored in the memory with address following :\\n\\nMemory -->  what stored in that place\\nadd_0 --> [ val_1, add_1]\\nadd_1 --> [ val_2, add_2]\\nadd_2 --> [ val_3, add_3]\\nadd_3 --> [ val_4, add_1]    # now this is circulating back to add_1\\n\\n\\'head\\' variable actually stored \\'add_0\\', the memory address of [ val, add]..  and  \\'head.val\\' give the \\'val_1\\' (which never used) and \\'head.next\\' give the memory address \\'add_1\\' stored in the head. So when I use    \\'p = head.next\\'... now \\'p = add_1\\'   and   \\'p.val = val_2\\' and \\'p.next = add_2\\'..\\n\\nis that correct.???? I believe that is why there is no two \\'heads\\' alike without cycling but there may be possible that values are circulating .. eg: [head.next.val for i in range(x)]  could gives  [ 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5, ... so on ]  with repeating pattern of values without \"cycling\" in their sense."
                    }
                ]
            },
            {
                "id": 1762418,
                "content": [
                    {
                        "username": "NarinderSingh",
                        "content": "NO NEED TO USE ANY POINTER\\n1) Hint - Take Advantage of what credentials they have given in the que.\\n2) Hint - Try to use recursion.\\n3) Hint - Change linked List Values ( we have to just find whether a cycle is there or not. we can manipulate the list )"
                    },
                    {
                        "username": "icantcodeatall",
                        "content": "For anyone confused about the \"pos\", you can safely ignore it. It\\'s an internal detail, not something to worry about. \\nYou just need to do is detect if there\\'s a cycle in the linked list, that\\'s all."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": " //java code \\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n            if(head == null || head.next == null)\\n            {\\n            return false;\\n            }\\n            ListNode slow = head;\\n            ListNode fast = head.next;\\n        while(slow != fast) {\\n                if(fast == null || fast.next == null)\\n                {\\n                return false;\\n                }\\n        slow = slow.next;\\n        fast = fast.next.next;\\n         }\\n         return true;\\n      }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9131YR",
                        "content": "I don't understand why one would even resort to Floyd's cycle detection. Just iterate 10000 times and see if null pointers are hit, no?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Vishwas_Khanna",
                        "content": "pos as input is confusing."
                    },
                    {
                        "username": "aprilman_j",
                        "content": "In case of java solution I think this is bad idea to let people compare objects with `==`. After looking at solution some people might think this is correct approach."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "kzlatt",
                        "content": "OK.. I am confused. At first I thought \"are all values unique and non-repeating\". Later I just blindly use a continuously appended list of heads (a bit dumb) but it works (with runtime <6%  with >1 sec). \\n\\nPlease someone confirms if my understanding is correct.... (i have no formal CS degree so not sure these link-lists are common things in pro-world)\\n......\\nData structure has two elements [value, memory address] or  [v, add] for short..\\nThese data are stored in the memory with address following :\\n\\nMemory -->  what stored in that place\\nadd_0 --> [ val_1, add_1]\\nadd_1 --> [ val_2, add_2]\\nadd_2 --> [ val_3, add_3]\\nadd_3 --> [ val_4, add_1]    # now this is circulating back to add_1\\n\\n\\'head\\' variable actually stored \\'add_0\\', the memory address of [ val, add]..  and  \\'head.val\\' give the \\'val_1\\' (which never used) and \\'head.next\\' give the memory address \\'add_1\\' stored in the head. So when I use    \\'p = head.next\\'... now \\'p = add_1\\'   and   \\'p.val = val_2\\' and \\'p.next = add_2\\'..\\n\\nis that correct.???? I believe that is why there is no two \\'heads\\' alike without cycling but there may be possible that values are circulating .. eg: [head.next.val for i in range(x)]  could gives  [ 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5, ... so on ]  with repeating pattern of values without \"cycling\" in their sense."
                    }
                ]
            },
            {
                "id": 1761014,
                "content": [
                    {
                        "username": "NarinderSingh",
                        "content": "NO NEED TO USE ANY POINTER\\n1) Hint - Take Advantage of what credentials they have given in the que.\\n2) Hint - Try to use recursion.\\n3) Hint - Change linked List Values ( we have to just find whether a cycle is there or not. we can manipulate the list )"
                    },
                    {
                        "username": "icantcodeatall",
                        "content": "For anyone confused about the \"pos\", you can safely ignore it. It\\'s an internal detail, not something to worry about. \\nYou just need to do is detect if there\\'s a cycle in the linked list, that\\'s all."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": " //java code \\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n            if(head == null || head.next == null)\\n            {\\n            return false;\\n            }\\n            ListNode slow = head;\\n            ListNode fast = head.next;\\n        while(slow != fast) {\\n                if(fast == null || fast.next == null)\\n                {\\n                return false;\\n                }\\n        slow = slow.next;\\n        fast = fast.next.next;\\n         }\\n         return true;\\n      }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9131YR",
                        "content": "I don't understand why one would even resort to Floyd's cycle detection. Just iterate 10000 times and see if null pointers are hit, no?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Vishwas_Khanna",
                        "content": "pos as input is confusing."
                    },
                    {
                        "username": "aprilman_j",
                        "content": "In case of java solution I think this is bad idea to let people compare objects with `==`. After looking at solution some people might think this is correct approach."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "kzlatt",
                        "content": "OK.. I am confused. At first I thought \"are all values unique and non-repeating\". Later I just blindly use a continuously appended list of heads (a bit dumb) but it works (with runtime <6%  with >1 sec). \\n\\nPlease someone confirms if my understanding is correct.... (i have no formal CS degree so not sure these link-lists are common things in pro-world)\\n......\\nData structure has two elements [value, memory address] or  [v, add] for short..\\nThese data are stored in the memory with address following :\\n\\nMemory -->  what stored in that place\\nadd_0 --> [ val_1, add_1]\\nadd_1 --> [ val_2, add_2]\\nadd_2 --> [ val_3, add_3]\\nadd_3 --> [ val_4, add_1]    # now this is circulating back to add_1\\n\\n\\'head\\' variable actually stored \\'add_0\\', the memory address of [ val, add]..  and  \\'head.val\\' give the \\'val_1\\' (which never used) and \\'head.next\\' give the memory address \\'add_1\\' stored in the head. So when I use    \\'p = head.next\\'... now \\'p = add_1\\'   and   \\'p.val = val_2\\' and \\'p.next = add_2\\'..\\n\\nis that correct.???? I believe that is why there is no two \\'heads\\' alike without cycling but there may be possible that values are circulating .. eg: [head.next.val for i in range(x)]  could gives  [ 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5, ... so on ]  with repeating pattern of values without \"cycling\" in their sense."
                    }
                ]
            },
            {
                "id": 1760670,
                "content": [
                    {
                        "username": "NarinderSingh",
                        "content": "NO NEED TO USE ANY POINTER\\n1) Hint - Take Advantage of what credentials they have given in the que.\\n2) Hint - Try to use recursion.\\n3) Hint - Change linked List Values ( we have to just find whether a cycle is there or not. we can manipulate the list )"
                    },
                    {
                        "username": "icantcodeatall",
                        "content": "For anyone confused about the \"pos\", you can safely ignore it. It\\'s an internal detail, not something to worry about. \\nYou just need to do is detect if there\\'s a cycle in the linked list, that\\'s all."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": " //java code \\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n            if(head == null || head.next == null)\\n            {\\n            return false;\\n            }\\n            ListNode slow = head;\\n            ListNode fast = head.next;\\n        while(slow != fast) {\\n                if(fast == null || fast.next == null)\\n                {\\n                return false;\\n                }\\n        slow = slow.next;\\n        fast = fast.next.next;\\n         }\\n         return true;\\n      }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9131YR",
                        "content": "I don't understand why one would even resort to Floyd's cycle detection. Just iterate 10000 times and see if null pointers are hit, no?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Vishwas_Khanna",
                        "content": "pos as input is confusing."
                    },
                    {
                        "username": "aprilman_j",
                        "content": "In case of java solution I think this is bad idea to let people compare objects with `==`. After looking at solution some people might think this is correct approach."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "kzlatt",
                        "content": "OK.. I am confused. At first I thought \"are all values unique and non-repeating\". Later I just blindly use a continuously appended list of heads (a bit dumb) but it works (with runtime <6%  with >1 sec). \\n\\nPlease someone confirms if my understanding is correct.... (i have no formal CS degree so not sure these link-lists are common things in pro-world)\\n......\\nData structure has two elements [value, memory address] or  [v, add] for short..\\nThese data are stored in the memory with address following :\\n\\nMemory -->  what stored in that place\\nadd_0 --> [ val_1, add_1]\\nadd_1 --> [ val_2, add_2]\\nadd_2 --> [ val_3, add_3]\\nadd_3 --> [ val_4, add_1]    # now this is circulating back to add_1\\n\\n\\'head\\' variable actually stored \\'add_0\\', the memory address of [ val, add]..  and  \\'head.val\\' give the \\'val_1\\' (which never used) and \\'head.next\\' give the memory address \\'add_1\\' stored in the head. So when I use    \\'p = head.next\\'... now \\'p = add_1\\'   and   \\'p.val = val_2\\' and \\'p.next = add_2\\'..\\n\\nis that correct.???? I believe that is why there is no two \\'heads\\' alike without cycling but there may be possible that values are circulating .. eg: [head.next.val for i in range(x)]  could gives  [ 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5, ... so on ]  with repeating pattern of values without \"cycling\" in their sense."
                    }
                ]
            },
            {
                "id": 1752890,
                "content": [
                    {
                        "username": "NarinderSingh",
                        "content": "NO NEED TO USE ANY POINTER\\n1) Hint - Take Advantage of what credentials they have given in the que.\\n2) Hint - Try to use recursion.\\n3) Hint - Change linked List Values ( we have to just find whether a cycle is there or not. we can manipulate the list )"
                    },
                    {
                        "username": "icantcodeatall",
                        "content": "For anyone confused about the \"pos\", you can safely ignore it. It\\'s an internal detail, not something to worry about. \\nYou just need to do is detect if there\\'s a cycle in the linked list, that\\'s all."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": " //java code \\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n            if(head == null || head.next == null)\\n            {\\n            return false;\\n            }\\n            ListNode slow = head;\\n            ListNode fast = head.next;\\n        while(slow != fast) {\\n                if(fast == null || fast.next == null)\\n                {\\n                return false;\\n                }\\n        slow = slow.next;\\n        fast = fast.next.next;\\n         }\\n         return true;\\n      }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9131YR",
                        "content": "I don't understand why one would even resort to Floyd's cycle detection. Just iterate 10000 times and see if null pointers are hit, no?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Vishwas_Khanna",
                        "content": "pos as input is confusing."
                    },
                    {
                        "username": "aprilman_j",
                        "content": "In case of java solution I think this is bad idea to let people compare objects with `==`. After looking at solution some people might think this is correct approach."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "kzlatt",
                        "content": "OK.. I am confused. At first I thought \"are all values unique and non-repeating\". Later I just blindly use a continuously appended list of heads (a bit dumb) but it works (with runtime <6%  with >1 sec). \\n\\nPlease someone confirms if my understanding is correct.... (i have no formal CS degree so not sure these link-lists are common things in pro-world)\\n......\\nData structure has two elements [value, memory address] or  [v, add] for short..\\nThese data are stored in the memory with address following :\\n\\nMemory -->  what stored in that place\\nadd_0 --> [ val_1, add_1]\\nadd_1 --> [ val_2, add_2]\\nadd_2 --> [ val_3, add_3]\\nadd_3 --> [ val_4, add_1]    # now this is circulating back to add_1\\n\\n\\'head\\' variable actually stored \\'add_0\\', the memory address of [ val, add]..  and  \\'head.val\\' give the \\'val_1\\' (which never used) and \\'head.next\\' give the memory address \\'add_1\\' stored in the head. So when I use    \\'p = head.next\\'... now \\'p = add_1\\'   and   \\'p.val = val_2\\' and \\'p.next = add_2\\'..\\n\\nis that correct.???? I believe that is why there is no two \\'heads\\' alike without cycling but there may be possible that values are circulating .. eg: [head.next.val for i in range(x)]  could gives  [ 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5, ... so on ]  with repeating pattern of values without \"cycling\" in their sense."
                    }
                ]
            },
            {
                "id": 1752682,
                "content": [
                    {
                        "username": "NarinderSingh",
                        "content": "NO NEED TO USE ANY POINTER\\n1) Hint - Take Advantage of what credentials they have given in the que.\\n2) Hint - Try to use recursion.\\n3) Hint - Change linked List Values ( we have to just find whether a cycle is there or not. we can manipulate the list )"
                    },
                    {
                        "username": "icantcodeatall",
                        "content": "For anyone confused about the \"pos\", you can safely ignore it. It\\'s an internal detail, not something to worry about. \\nYou just need to do is detect if there\\'s a cycle in the linked list, that\\'s all."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": " //java code \\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n            if(head == null || head.next == null)\\n            {\\n            return false;\\n            }\\n            ListNode slow = head;\\n            ListNode fast = head.next;\\n        while(slow != fast) {\\n                if(fast == null || fast.next == null)\\n                {\\n                return false;\\n                }\\n        slow = slow.next;\\n        fast = fast.next.next;\\n         }\\n         return true;\\n      }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9131YR",
                        "content": "I don't understand why one would even resort to Floyd's cycle detection. Just iterate 10000 times and see if null pointers are hit, no?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Vishwas_Khanna",
                        "content": "pos as input is confusing."
                    },
                    {
                        "username": "aprilman_j",
                        "content": "In case of java solution I think this is bad idea to let people compare objects with `==`. After looking at solution some people might think this is correct approach."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "kzlatt",
                        "content": "OK.. I am confused. At first I thought \"are all values unique and non-repeating\". Later I just blindly use a continuously appended list of heads (a bit dumb) but it works (with runtime <6%  with >1 sec). \\n\\nPlease someone confirms if my understanding is correct.... (i have no formal CS degree so not sure these link-lists are common things in pro-world)\\n......\\nData structure has two elements [value, memory address] or  [v, add] for short..\\nThese data are stored in the memory with address following :\\n\\nMemory -->  what stored in that place\\nadd_0 --> [ val_1, add_1]\\nadd_1 --> [ val_2, add_2]\\nadd_2 --> [ val_3, add_3]\\nadd_3 --> [ val_4, add_1]    # now this is circulating back to add_1\\n\\n\\'head\\' variable actually stored \\'add_0\\', the memory address of [ val, add]..  and  \\'head.val\\' give the \\'val_1\\' (which never used) and \\'head.next\\' give the memory address \\'add_1\\' stored in the head. So when I use    \\'p = head.next\\'... now \\'p = add_1\\'   and   \\'p.val = val_2\\' and \\'p.next = add_2\\'..\\n\\nis that correct.???? I believe that is why there is no two \\'heads\\' alike without cycling but there may be possible that values are circulating .. eg: [head.next.val for i in range(x)]  could gives  [ 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5, ... so on ]  with repeating pattern of values without \"cycling\" in their sense."
                    }
                ]
            },
            {
                "id": 1745923,
                "content": [
                    {
                        "username": "NarinderSingh",
                        "content": "NO NEED TO USE ANY POINTER\\n1) Hint - Take Advantage of what credentials they have given in the que.\\n2) Hint - Try to use recursion.\\n3) Hint - Change linked List Values ( we have to just find whether a cycle is there or not. we can manipulate the list )"
                    },
                    {
                        "username": "icantcodeatall",
                        "content": "For anyone confused about the \"pos\", you can safely ignore it. It\\'s an internal detail, not something to worry about. \\nYou just need to do is detect if there\\'s a cycle in the linked list, that\\'s all."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": " //java code \\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n            if(head == null || head.next == null)\\n            {\\n            return false;\\n            }\\n            ListNode slow = head;\\n            ListNode fast = head.next;\\n        while(slow != fast) {\\n                if(fast == null || fast.next == null)\\n                {\\n                return false;\\n                }\\n        slow = slow.next;\\n        fast = fast.next.next;\\n         }\\n         return true;\\n      }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9131YR",
                        "content": "I don't understand why one would even resort to Floyd's cycle detection. Just iterate 10000 times and see if null pointers are hit, no?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Vishwas_Khanna",
                        "content": "pos as input is confusing."
                    },
                    {
                        "username": "aprilman_j",
                        "content": "In case of java solution I think this is bad idea to let people compare objects with `==`. After looking at solution some people might think this is correct approach."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "kzlatt",
                        "content": "OK.. I am confused. At first I thought \"are all values unique and non-repeating\". Later I just blindly use a continuously appended list of heads (a bit dumb) but it works (with runtime <6%  with >1 sec). \\n\\nPlease someone confirms if my understanding is correct.... (i have no formal CS degree so not sure these link-lists are common things in pro-world)\\n......\\nData structure has two elements [value, memory address] or  [v, add] for short..\\nThese data are stored in the memory with address following :\\n\\nMemory -->  what stored in that place\\nadd_0 --> [ val_1, add_1]\\nadd_1 --> [ val_2, add_2]\\nadd_2 --> [ val_3, add_3]\\nadd_3 --> [ val_4, add_1]    # now this is circulating back to add_1\\n\\n\\'head\\' variable actually stored \\'add_0\\', the memory address of [ val, add]..  and  \\'head.val\\' give the \\'val_1\\' (which never used) and \\'head.next\\' give the memory address \\'add_1\\' stored in the head. So when I use    \\'p = head.next\\'... now \\'p = add_1\\'   and   \\'p.val = val_2\\' and \\'p.next = add_2\\'..\\n\\nis that correct.???? I believe that is why there is no two \\'heads\\' alike without cycling but there may be possible that values are circulating .. eg: [head.next.val for i in range(x)]  could gives  [ 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5, ... so on ]  with repeating pattern of values without \"cycling\" in their sense."
                    }
                ]
            },
            {
                "id": 1730719,
                "content": [
                    {
                        "username": "dariusz007",
                        "content": "A question from a beginner, if I may:\\n\\n1. why can\\'t I print the head? For example:\\n `print(head)`\\nin the Stdout I get:\\n `Error - Found cycle in the ListNode`\\n\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Since the ListNode has a cycle, we can\\'t reach the end. Because of that the ListNode doesn\\'t stop in any node and keep going. It\\'s hard, very hard to print some thing that doesn\\'t has an end. But I think, we can print the val of the head."
                    },
                    {
                        "username": "Akashverma212",
                        "content": "Easy using hare /turtle approach"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "anishkumarsahoo1",
                        "content": "  slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\nwhy do i have to write fast.next in while ?will it not work without it? "
                    },
                    {
                        "username": "District_12",
                        "content": "I don\\'t understand the Description."
                    },
                    {
                        "username": "user4628p",
                        "content": "public class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kasireddy_13177",
                        "content": " @[leetcode](https://leetcode.com)class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        if(head==NULL)\\n        return false;\\n        if(temp->next==head)\\n        return true;\\n        \\n        map<ListNode *,int>mp;\\n        while(1){\\n            auto it=mp.find(temp);\\n            if(it!=mp.end())\\n            return true;\\n            else\\n            mp[temp];\\n            temp=temp->next;\\n            if(temp==NULL)\\n            return false;\\n\\n        }\\n        \\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "__tejas_01",
                        "content": "\\n// EASY SOLUTION IN C\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nbool hasCycle(struct ListNode *head) {\\n    if(head==NULL){return false;}\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        if(slow==fast){return true;}\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "vvvxxx321",
                        "content": "\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n            \\n        while(head.next != null){\\n            if(head.next.val > 100000)\\n                return true;\\n\\n            head = head.next;\\n            head.val = 100001;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harsh_koradiya",
                        "content": "       if(head==null){\\n            return false;\\n        }\\n        ListNode temp =  head;\\n        while(temp!=null){\\n\\n            if(temp.val == 100007){\\n                return true;\\n            }\\n            temp.val = 100007;\\n            temp = temp.next;\\n\\n        }\\n        return false;"
                    }
                ]
            },
            {
                "id": 1729698,
                "content": [
                    {
                        "username": "dariusz007",
                        "content": "A question from a beginner, if I may:\\n\\n1. why can\\'t I print the head? For example:\\n `print(head)`\\nin the Stdout I get:\\n `Error - Found cycle in the ListNode`\\n\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Since the ListNode has a cycle, we can\\'t reach the end. Because of that the ListNode doesn\\'t stop in any node and keep going. It\\'s hard, very hard to print some thing that doesn\\'t has an end. But I think, we can print the val of the head."
                    },
                    {
                        "username": "Akashverma212",
                        "content": "Easy using hare /turtle approach"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "anishkumarsahoo1",
                        "content": "  slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\nwhy do i have to write fast.next in while ?will it not work without it? "
                    },
                    {
                        "username": "District_12",
                        "content": "I don\\'t understand the Description."
                    },
                    {
                        "username": "user4628p",
                        "content": "public class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kasireddy_13177",
                        "content": " @[leetcode](https://leetcode.com)class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        if(head==NULL)\\n        return false;\\n        if(temp->next==head)\\n        return true;\\n        \\n        map<ListNode *,int>mp;\\n        while(1){\\n            auto it=mp.find(temp);\\n            if(it!=mp.end())\\n            return true;\\n            else\\n            mp[temp];\\n            temp=temp->next;\\n            if(temp==NULL)\\n            return false;\\n\\n        }\\n        \\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "__tejas_01",
                        "content": "\\n// EASY SOLUTION IN C\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nbool hasCycle(struct ListNode *head) {\\n    if(head==NULL){return false;}\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        if(slow==fast){return true;}\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "vvvxxx321",
                        "content": "\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n            \\n        while(head.next != null){\\n            if(head.next.val > 100000)\\n                return true;\\n\\n            head = head.next;\\n            head.val = 100001;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harsh_koradiya",
                        "content": "       if(head==null){\\n            return false;\\n        }\\n        ListNode temp =  head;\\n        while(temp!=null){\\n\\n            if(temp.val == 100007){\\n                return true;\\n            }\\n            temp.val = 100007;\\n            temp = temp.next;\\n\\n        }\\n        return false;"
                    }
                ]
            },
            {
                "id": 1729156,
                "content": [
                    {
                        "username": "dariusz007",
                        "content": "A question from a beginner, if I may:\\n\\n1. why can\\'t I print the head? For example:\\n `print(head)`\\nin the Stdout I get:\\n `Error - Found cycle in the ListNode`\\n\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Since the ListNode has a cycle, we can\\'t reach the end. Because of that the ListNode doesn\\'t stop in any node and keep going. It\\'s hard, very hard to print some thing that doesn\\'t has an end. But I think, we can print the val of the head."
                    },
                    {
                        "username": "Akashverma212",
                        "content": "Easy using hare /turtle approach"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "anishkumarsahoo1",
                        "content": "  slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\nwhy do i have to write fast.next in while ?will it not work without it? "
                    },
                    {
                        "username": "District_12",
                        "content": "I don\\'t understand the Description."
                    },
                    {
                        "username": "user4628p",
                        "content": "public class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kasireddy_13177",
                        "content": " @[leetcode](https://leetcode.com)class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        if(head==NULL)\\n        return false;\\n        if(temp->next==head)\\n        return true;\\n        \\n        map<ListNode *,int>mp;\\n        while(1){\\n            auto it=mp.find(temp);\\n            if(it!=mp.end())\\n            return true;\\n            else\\n            mp[temp];\\n            temp=temp->next;\\n            if(temp==NULL)\\n            return false;\\n\\n        }\\n        \\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "__tejas_01",
                        "content": "\\n// EASY SOLUTION IN C\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nbool hasCycle(struct ListNode *head) {\\n    if(head==NULL){return false;}\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        if(slow==fast){return true;}\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "vvvxxx321",
                        "content": "\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n            \\n        while(head.next != null){\\n            if(head.next.val > 100000)\\n                return true;\\n\\n            head = head.next;\\n            head.val = 100001;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harsh_koradiya",
                        "content": "       if(head==null){\\n            return false;\\n        }\\n        ListNode temp =  head;\\n        while(temp!=null){\\n\\n            if(temp.val == 100007){\\n                return true;\\n            }\\n            temp.val = 100007;\\n            temp = temp.next;\\n\\n        }\\n        return false;"
                    }
                ]
            },
            {
                "id": 1725713,
                "content": [
                    {
                        "username": "dariusz007",
                        "content": "A question from a beginner, if I may:\\n\\n1. why can\\'t I print the head? For example:\\n `print(head)`\\nin the Stdout I get:\\n `Error - Found cycle in the ListNode`\\n\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Since the ListNode has a cycle, we can\\'t reach the end. Because of that the ListNode doesn\\'t stop in any node and keep going. It\\'s hard, very hard to print some thing that doesn\\'t has an end. But I think, we can print the val of the head."
                    },
                    {
                        "username": "Akashverma212",
                        "content": "Easy using hare /turtle approach"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "anishkumarsahoo1",
                        "content": "  slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\nwhy do i have to write fast.next in while ?will it not work without it? "
                    },
                    {
                        "username": "District_12",
                        "content": "I don\\'t understand the Description."
                    },
                    {
                        "username": "user4628p",
                        "content": "public class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kasireddy_13177",
                        "content": " @[leetcode](https://leetcode.com)class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        if(head==NULL)\\n        return false;\\n        if(temp->next==head)\\n        return true;\\n        \\n        map<ListNode *,int>mp;\\n        while(1){\\n            auto it=mp.find(temp);\\n            if(it!=mp.end())\\n            return true;\\n            else\\n            mp[temp];\\n            temp=temp->next;\\n            if(temp==NULL)\\n            return false;\\n\\n        }\\n        \\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "__tejas_01",
                        "content": "\\n// EASY SOLUTION IN C\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nbool hasCycle(struct ListNode *head) {\\n    if(head==NULL){return false;}\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        if(slow==fast){return true;}\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "vvvxxx321",
                        "content": "\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n            \\n        while(head.next != null){\\n            if(head.next.val > 100000)\\n                return true;\\n\\n            head = head.next;\\n            head.val = 100001;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harsh_koradiya",
                        "content": "       if(head==null){\\n            return false;\\n        }\\n        ListNode temp =  head;\\n        while(temp!=null){\\n\\n            if(temp.val == 100007){\\n                return true;\\n            }\\n            temp.val = 100007;\\n            temp = temp.next;\\n\\n        }\\n        return false;"
                    }
                ]
            },
            {
                "id": 1724841,
                "content": [
                    {
                        "username": "dariusz007",
                        "content": "A question from a beginner, if I may:\\n\\n1. why can\\'t I print the head? For example:\\n `print(head)`\\nin the Stdout I get:\\n `Error - Found cycle in the ListNode`\\n\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Since the ListNode has a cycle, we can\\'t reach the end. Because of that the ListNode doesn\\'t stop in any node and keep going. It\\'s hard, very hard to print some thing that doesn\\'t has an end. But I think, we can print the val of the head."
                    },
                    {
                        "username": "Akashverma212",
                        "content": "Easy using hare /turtle approach"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "anishkumarsahoo1",
                        "content": "  slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\nwhy do i have to write fast.next in while ?will it not work without it? "
                    },
                    {
                        "username": "District_12",
                        "content": "I don\\'t understand the Description."
                    },
                    {
                        "username": "user4628p",
                        "content": "public class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kasireddy_13177",
                        "content": " @[leetcode](https://leetcode.com)class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        if(head==NULL)\\n        return false;\\n        if(temp->next==head)\\n        return true;\\n        \\n        map<ListNode *,int>mp;\\n        while(1){\\n            auto it=mp.find(temp);\\n            if(it!=mp.end())\\n            return true;\\n            else\\n            mp[temp];\\n            temp=temp->next;\\n            if(temp==NULL)\\n            return false;\\n\\n        }\\n        \\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "__tejas_01",
                        "content": "\\n// EASY SOLUTION IN C\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nbool hasCycle(struct ListNode *head) {\\n    if(head==NULL){return false;}\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        if(slow==fast){return true;}\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "vvvxxx321",
                        "content": "\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n            \\n        while(head.next != null){\\n            if(head.next.val > 100000)\\n                return true;\\n\\n            head = head.next;\\n            head.val = 100001;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harsh_koradiya",
                        "content": "       if(head==null){\\n            return false;\\n        }\\n        ListNode temp =  head;\\n        while(temp!=null){\\n\\n            if(temp.val == 100007){\\n                return true;\\n            }\\n            temp.val = 100007;\\n            temp = temp.next;\\n\\n        }\\n        return false;"
                    }
                ]
            },
            {
                "id": 1722781,
                "content": [
                    {
                        "username": "dariusz007",
                        "content": "A question from a beginner, if I may:\\n\\n1. why can\\'t I print the head? For example:\\n `print(head)`\\nin the Stdout I get:\\n `Error - Found cycle in the ListNode`\\n\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Since the ListNode has a cycle, we can\\'t reach the end. Because of that the ListNode doesn\\'t stop in any node and keep going. It\\'s hard, very hard to print some thing that doesn\\'t has an end. But I think, we can print the val of the head."
                    },
                    {
                        "username": "Akashverma212",
                        "content": "Easy using hare /turtle approach"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "anishkumarsahoo1",
                        "content": "  slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\nwhy do i have to write fast.next in while ?will it not work without it? "
                    },
                    {
                        "username": "District_12",
                        "content": "I don\\'t understand the Description."
                    },
                    {
                        "username": "user4628p",
                        "content": "public class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kasireddy_13177",
                        "content": " @[leetcode](https://leetcode.com)class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        if(head==NULL)\\n        return false;\\n        if(temp->next==head)\\n        return true;\\n        \\n        map<ListNode *,int>mp;\\n        while(1){\\n            auto it=mp.find(temp);\\n            if(it!=mp.end())\\n            return true;\\n            else\\n            mp[temp];\\n            temp=temp->next;\\n            if(temp==NULL)\\n            return false;\\n\\n        }\\n        \\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "__tejas_01",
                        "content": "\\n// EASY SOLUTION IN C\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nbool hasCycle(struct ListNode *head) {\\n    if(head==NULL){return false;}\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        if(slow==fast){return true;}\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "vvvxxx321",
                        "content": "\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n            \\n        while(head.next != null){\\n            if(head.next.val > 100000)\\n                return true;\\n\\n            head = head.next;\\n            head.val = 100001;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harsh_koradiya",
                        "content": "       if(head==null){\\n            return false;\\n        }\\n        ListNode temp =  head;\\n        while(temp!=null){\\n\\n            if(temp.val == 100007){\\n                return true;\\n            }\\n            temp.val = 100007;\\n            temp = temp.next;\\n\\n        }\\n        return false;"
                    }
                ]
            },
            {
                "id": 1719675,
                "content": [
                    {
                        "username": "dariusz007",
                        "content": "A question from a beginner, if I may:\\n\\n1. why can\\'t I print the head? For example:\\n `print(head)`\\nin the Stdout I get:\\n `Error - Found cycle in the ListNode`\\n\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Since the ListNode has a cycle, we can\\'t reach the end. Because of that the ListNode doesn\\'t stop in any node and keep going. It\\'s hard, very hard to print some thing that doesn\\'t has an end. But I think, we can print the val of the head."
                    },
                    {
                        "username": "Akashverma212",
                        "content": "Easy using hare /turtle approach"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "anishkumarsahoo1",
                        "content": "  slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\nwhy do i have to write fast.next in while ?will it not work without it? "
                    },
                    {
                        "username": "District_12",
                        "content": "I don\\'t understand the Description."
                    },
                    {
                        "username": "user4628p",
                        "content": "public class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kasireddy_13177",
                        "content": " @[leetcode](https://leetcode.com)class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        if(head==NULL)\\n        return false;\\n        if(temp->next==head)\\n        return true;\\n        \\n        map<ListNode *,int>mp;\\n        while(1){\\n            auto it=mp.find(temp);\\n            if(it!=mp.end())\\n            return true;\\n            else\\n            mp[temp];\\n            temp=temp->next;\\n            if(temp==NULL)\\n            return false;\\n\\n        }\\n        \\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "__tejas_01",
                        "content": "\\n// EASY SOLUTION IN C\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nbool hasCycle(struct ListNode *head) {\\n    if(head==NULL){return false;}\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        if(slow==fast){return true;}\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "vvvxxx321",
                        "content": "\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n            \\n        while(head.next != null){\\n            if(head.next.val > 100000)\\n                return true;\\n\\n            head = head.next;\\n            head.val = 100001;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harsh_koradiya",
                        "content": "       if(head==null){\\n            return false;\\n        }\\n        ListNode temp =  head;\\n        while(temp!=null){\\n\\n            if(temp.val == 100007){\\n                return true;\\n            }\\n            temp.val = 100007;\\n            temp = temp.next;\\n\\n        }\\n        return false;"
                    }
                ]
            },
            {
                "id": 1713812,
                "content": [
                    {
                        "username": "dariusz007",
                        "content": "A question from a beginner, if I may:\\n\\n1. why can\\'t I print the head? For example:\\n `print(head)`\\nin the Stdout I get:\\n `Error - Found cycle in the ListNode`\\n\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Since the ListNode has a cycle, we can\\'t reach the end. Because of that the ListNode doesn\\'t stop in any node and keep going. It\\'s hard, very hard to print some thing that doesn\\'t has an end. But I think, we can print the val of the head."
                    },
                    {
                        "username": "Akashverma212",
                        "content": "Easy using hare /turtle approach"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "anishkumarsahoo1",
                        "content": "  slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\nwhy do i have to write fast.next in while ?will it not work without it? "
                    },
                    {
                        "username": "District_12",
                        "content": "I don\\'t understand the Description."
                    },
                    {
                        "username": "user4628p",
                        "content": "public class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kasireddy_13177",
                        "content": " @[leetcode](https://leetcode.com)class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        if(head==NULL)\\n        return false;\\n        if(temp->next==head)\\n        return true;\\n        \\n        map<ListNode *,int>mp;\\n        while(1){\\n            auto it=mp.find(temp);\\n            if(it!=mp.end())\\n            return true;\\n            else\\n            mp[temp];\\n            temp=temp->next;\\n            if(temp==NULL)\\n            return false;\\n\\n        }\\n        \\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "__tejas_01",
                        "content": "\\n// EASY SOLUTION IN C\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nbool hasCycle(struct ListNode *head) {\\n    if(head==NULL){return false;}\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        if(slow==fast){return true;}\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "vvvxxx321",
                        "content": "\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n            \\n        while(head.next != null){\\n            if(head.next.val > 100000)\\n                return true;\\n\\n            head = head.next;\\n            head.val = 100001;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harsh_koradiya",
                        "content": "       if(head==null){\\n            return false;\\n        }\\n        ListNode temp =  head;\\n        while(temp!=null){\\n\\n            if(temp.val == 100007){\\n                return true;\\n            }\\n            temp.val = 100007;\\n            temp = temp.next;\\n\\n        }\\n        return false;"
                    }
                ]
            },
            {
                "id": 1713769,
                "content": [
                    {
                        "username": "dariusz007",
                        "content": "A question from a beginner, if I may:\\n\\n1. why can\\'t I print the head? For example:\\n `print(head)`\\nin the Stdout I get:\\n `Error - Found cycle in the ListNode`\\n\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Since the ListNode has a cycle, we can\\'t reach the end. Because of that the ListNode doesn\\'t stop in any node and keep going. It\\'s hard, very hard to print some thing that doesn\\'t has an end. But I think, we can print the val of the head."
                    },
                    {
                        "username": "Akashverma212",
                        "content": "Easy using hare /turtle approach"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "anishkumarsahoo1",
                        "content": "  slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\nwhy do i have to write fast.next in while ?will it not work without it? "
                    },
                    {
                        "username": "District_12",
                        "content": "I don\\'t understand the Description."
                    },
                    {
                        "username": "user4628p",
                        "content": "public class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kasireddy_13177",
                        "content": " @[leetcode](https://leetcode.com)class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        if(head==NULL)\\n        return false;\\n        if(temp->next==head)\\n        return true;\\n        \\n        map<ListNode *,int>mp;\\n        while(1){\\n            auto it=mp.find(temp);\\n            if(it!=mp.end())\\n            return true;\\n            else\\n            mp[temp];\\n            temp=temp->next;\\n            if(temp==NULL)\\n            return false;\\n\\n        }\\n        \\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "__tejas_01",
                        "content": "\\n// EASY SOLUTION IN C\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nbool hasCycle(struct ListNode *head) {\\n    if(head==NULL){return false;}\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        if(slow==fast){return true;}\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "vvvxxx321",
                        "content": "\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n            \\n        while(head.next != null){\\n            if(head.next.val > 100000)\\n                return true;\\n\\n            head = head.next;\\n            head.val = 100001;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harsh_koradiya",
                        "content": "       if(head==null){\\n            return false;\\n        }\\n        ListNode temp =  head;\\n        while(temp!=null){\\n\\n            if(temp.val == 100007){\\n                return true;\\n            }\\n            temp.val = 100007;\\n            temp = temp.next;\\n\\n        }\\n        return false;"
                    }
                ]
            },
            {
                "id": 1710455,
                "content": [
                    {
                        "username": "dariusz007",
                        "content": "A question from a beginner, if I may:\\n\\n1. why can\\'t I print the head? For example:\\n `print(head)`\\nin the Stdout I get:\\n `Error - Found cycle in the ListNode`\\n\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Since the ListNode has a cycle, we can\\'t reach the end. Because of that the ListNode doesn\\'t stop in any node and keep going. It\\'s hard, very hard to print some thing that doesn\\'t has an end. But I think, we can print the val of the head."
                    },
                    {
                        "username": "Akashverma212",
                        "content": "Easy using hare /turtle approach"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "anishkumarsahoo1",
                        "content": "  slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\nwhy do i have to write fast.next in while ?will it not work without it? "
                    },
                    {
                        "username": "District_12",
                        "content": "I don\\'t understand the Description."
                    },
                    {
                        "username": "user4628p",
                        "content": "public class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kasireddy_13177",
                        "content": " @[leetcode](https://leetcode.com)class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        if(head==NULL)\\n        return false;\\n        if(temp->next==head)\\n        return true;\\n        \\n        map<ListNode *,int>mp;\\n        while(1){\\n            auto it=mp.find(temp);\\n            if(it!=mp.end())\\n            return true;\\n            else\\n            mp[temp];\\n            temp=temp->next;\\n            if(temp==NULL)\\n            return false;\\n\\n        }\\n        \\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "__tejas_01",
                        "content": "\\n// EASY SOLUTION IN C\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nbool hasCycle(struct ListNode *head) {\\n    if(head==NULL){return false;}\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        if(slow==fast){return true;}\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "vvvxxx321",
                        "content": "\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n            \\n        while(head.next != null){\\n            if(head.next.val > 100000)\\n                return true;\\n\\n            head = head.next;\\n            head.val = 100001;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harsh_koradiya",
                        "content": "       if(head==null){\\n            return false;\\n        }\\n        ListNode temp =  head;\\n        while(temp!=null){\\n\\n            if(temp.val == 100007){\\n                return true;\\n            }\\n            temp.val = 100007;\\n            temp = temp.next;\\n\\n        }\\n        return false;"
                    }
                ]
            },
            {
                "id": 1708344,
                "content": [
                    {
                        "username": "Sanjeev___Thakur",
                        "content": "\\nclass Solution:\\n    def hasCycle(self, head):\\n        if head == None:\\n            return False\\n        slow = head\\n        fast =  head.next\\n        while fast!= None and slow != None:\\n            slow = head.next\\n            fast = head.next.next\\n            return True\\n\\nWith the above code i am able to pass all test cases but i am unable to submit the code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A1Amazon SDE-1 Interview\\uD83D\\uDCA5\\uD83E\\uDD73 #FAANG\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2875561/amazon-sde-1-interview-faang/?orderBy=most_relevant"
                    },
                    {
                        "username": "aanya_969",
                        "content": "What is the need of pos variable??"
                    },
                    {
                        "username": "AlexTyu",
                        "content": "When I use \\n```\\nfast = fast->next->next;\\n slow = slow->next; \\n```\\nMy program gets accepted, but if I use\\n```\\nslow = slow->next;\\nfast = slow->next;\\n```\\nIt says it is too slow. Anyone mind explaining why it is slower?"
                    },
                    {
                        "username": "ashmitarana616",
                        "content": "Here in this question we just need to check whether the given LL is circular or not .\\nSo to check it we just need tho compare the  head and last node if they are connected to eacthother then the Linked List is circular ...\\nif condition  is true returns true  otherwise false !"
                    },
                    {
                        "username": "shyamimmadi7",
                        "content": "what does pos = -1 mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Anees2778",
                        "content": "Someone please help me out : \\nError msg-\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:21\\n\\nI don\\'t get the point, where is the problem in code? [leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "drumsmanku",
                        "content": "Just use set or map"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "What is the need of `pos`, we don't need it anyways. It just makes the example test cases confusing, it can be a part of the explanation in examples but not the input."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used it to make my own test cases. For example, change pos in the 3 example to 0. The answer will be different."
                    },
                    {
                        "username": "ayushisinghania14",
                        "content": "How can we use \"pos\" for verification?  Since its type is showing a built-in function or method we can\\'t even convert it to integer and use to verify. "
                    }
                ]
            },
            {
                "id": 1704917,
                "content": [
                    {
                        "username": "Sanjeev___Thakur",
                        "content": "\\nclass Solution:\\n    def hasCycle(self, head):\\n        if head == None:\\n            return False\\n        slow = head\\n        fast =  head.next\\n        while fast!= None and slow != None:\\n            slow = head.next\\n            fast = head.next.next\\n            return True\\n\\nWith the above code i am able to pass all test cases but i am unable to submit the code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A1Amazon SDE-1 Interview\\uD83D\\uDCA5\\uD83E\\uDD73 #FAANG\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2875561/amazon-sde-1-interview-faang/?orderBy=most_relevant"
                    },
                    {
                        "username": "aanya_969",
                        "content": "What is the need of pos variable??"
                    },
                    {
                        "username": "AlexTyu",
                        "content": "When I use \\n```\\nfast = fast->next->next;\\n slow = slow->next; \\n```\\nMy program gets accepted, but if I use\\n```\\nslow = slow->next;\\nfast = slow->next;\\n```\\nIt says it is too slow. Anyone mind explaining why it is slower?"
                    },
                    {
                        "username": "ashmitarana616",
                        "content": "Here in this question we just need to check whether the given LL is circular or not .\\nSo to check it we just need tho compare the  head and last node if they are connected to eacthother then the Linked List is circular ...\\nif condition  is true returns true  otherwise false !"
                    },
                    {
                        "username": "shyamimmadi7",
                        "content": "what does pos = -1 mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Anees2778",
                        "content": "Someone please help me out : \\nError msg-\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:21\\n\\nI don\\'t get the point, where is the problem in code? [leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "drumsmanku",
                        "content": "Just use set or map"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "What is the need of `pos`, we don't need it anyways. It just makes the example test cases confusing, it can be a part of the explanation in examples but not the input."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used it to make my own test cases. For example, change pos in the 3 example to 0. The answer will be different."
                    },
                    {
                        "username": "ayushisinghania14",
                        "content": "How can we use \"pos\" for verification?  Since its type is showing a built-in function or method we can\\'t even convert it to integer and use to verify. "
                    }
                ]
            },
            {
                "id": 1701863,
                "content": [
                    {
                        "username": "Sanjeev___Thakur",
                        "content": "\\nclass Solution:\\n    def hasCycle(self, head):\\n        if head == None:\\n            return False\\n        slow = head\\n        fast =  head.next\\n        while fast!= None and slow != None:\\n            slow = head.next\\n            fast = head.next.next\\n            return True\\n\\nWith the above code i am able to pass all test cases but i am unable to submit the code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A1Amazon SDE-1 Interview\\uD83D\\uDCA5\\uD83E\\uDD73 #FAANG\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2875561/amazon-sde-1-interview-faang/?orderBy=most_relevant"
                    },
                    {
                        "username": "aanya_969",
                        "content": "What is the need of pos variable??"
                    },
                    {
                        "username": "AlexTyu",
                        "content": "When I use \\n```\\nfast = fast->next->next;\\n slow = slow->next; \\n```\\nMy program gets accepted, but if I use\\n```\\nslow = slow->next;\\nfast = slow->next;\\n```\\nIt says it is too slow. Anyone mind explaining why it is slower?"
                    },
                    {
                        "username": "ashmitarana616",
                        "content": "Here in this question we just need to check whether the given LL is circular or not .\\nSo to check it we just need tho compare the  head and last node if they are connected to eacthother then the Linked List is circular ...\\nif condition  is true returns true  otherwise false !"
                    },
                    {
                        "username": "shyamimmadi7",
                        "content": "what does pos = -1 mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Anees2778",
                        "content": "Someone please help me out : \\nError msg-\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:21\\n\\nI don\\'t get the point, where is the problem in code? [leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "drumsmanku",
                        "content": "Just use set or map"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "What is the need of `pos`, we don't need it anyways. It just makes the example test cases confusing, it can be a part of the explanation in examples but not the input."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used it to make my own test cases. For example, change pos in the 3 example to 0. The answer will be different."
                    },
                    {
                        "username": "ayushisinghania14",
                        "content": "How can we use \"pos\" for verification?  Since its type is showing a built-in function or method we can\\'t even convert it to integer and use to verify. "
                    }
                ]
            },
            {
                "id": 1699046,
                "content": [
                    {
                        "username": "Sanjeev___Thakur",
                        "content": "\\nclass Solution:\\n    def hasCycle(self, head):\\n        if head == None:\\n            return False\\n        slow = head\\n        fast =  head.next\\n        while fast!= None and slow != None:\\n            slow = head.next\\n            fast = head.next.next\\n            return True\\n\\nWith the above code i am able to pass all test cases but i am unable to submit the code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A1Amazon SDE-1 Interview\\uD83D\\uDCA5\\uD83E\\uDD73 #FAANG\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2875561/amazon-sde-1-interview-faang/?orderBy=most_relevant"
                    },
                    {
                        "username": "aanya_969",
                        "content": "What is the need of pos variable??"
                    },
                    {
                        "username": "AlexTyu",
                        "content": "When I use \\n```\\nfast = fast->next->next;\\n slow = slow->next; \\n```\\nMy program gets accepted, but if I use\\n```\\nslow = slow->next;\\nfast = slow->next;\\n```\\nIt says it is too slow. Anyone mind explaining why it is slower?"
                    },
                    {
                        "username": "ashmitarana616",
                        "content": "Here in this question we just need to check whether the given LL is circular or not .\\nSo to check it we just need tho compare the  head and last node if they are connected to eacthother then the Linked List is circular ...\\nif condition  is true returns true  otherwise false !"
                    },
                    {
                        "username": "shyamimmadi7",
                        "content": "what does pos = -1 mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Anees2778",
                        "content": "Someone please help me out : \\nError msg-\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:21\\n\\nI don\\'t get the point, where is the problem in code? [leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "drumsmanku",
                        "content": "Just use set or map"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "What is the need of `pos`, we don't need it anyways. It just makes the example test cases confusing, it can be a part of the explanation in examples but not the input."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used it to make my own test cases. For example, change pos in the 3 example to 0. The answer will be different."
                    },
                    {
                        "username": "ayushisinghania14",
                        "content": "How can we use \"pos\" for verification?  Since its type is showing a built-in function or method we can\\'t even convert it to integer and use to verify. "
                    }
                ]
            },
            {
                "id": 1696768,
                "content": [
                    {
                        "username": "Sanjeev___Thakur",
                        "content": "\\nclass Solution:\\n    def hasCycle(self, head):\\n        if head == None:\\n            return False\\n        slow = head\\n        fast =  head.next\\n        while fast!= None and slow != None:\\n            slow = head.next\\n            fast = head.next.next\\n            return True\\n\\nWith the above code i am able to pass all test cases but i am unable to submit the code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A1Amazon SDE-1 Interview\\uD83D\\uDCA5\\uD83E\\uDD73 #FAANG\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2875561/amazon-sde-1-interview-faang/?orderBy=most_relevant"
                    },
                    {
                        "username": "aanya_969",
                        "content": "What is the need of pos variable??"
                    },
                    {
                        "username": "AlexTyu",
                        "content": "When I use \\n```\\nfast = fast->next->next;\\n slow = slow->next; \\n```\\nMy program gets accepted, but if I use\\n```\\nslow = slow->next;\\nfast = slow->next;\\n```\\nIt says it is too slow. Anyone mind explaining why it is slower?"
                    },
                    {
                        "username": "ashmitarana616",
                        "content": "Here in this question we just need to check whether the given LL is circular or not .\\nSo to check it we just need tho compare the  head and last node if they are connected to eacthother then the Linked List is circular ...\\nif condition  is true returns true  otherwise false !"
                    },
                    {
                        "username": "shyamimmadi7",
                        "content": "what does pos = -1 mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Anees2778",
                        "content": "Someone please help me out : \\nError msg-\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:21\\n\\nI don\\'t get the point, where is the problem in code? [leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "drumsmanku",
                        "content": "Just use set or map"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "What is the need of `pos`, we don't need it anyways. It just makes the example test cases confusing, it can be a part of the explanation in examples but not the input."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used it to make my own test cases. For example, change pos in the 3 example to 0. The answer will be different."
                    },
                    {
                        "username": "ayushisinghania14",
                        "content": "How can we use \"pos\" for verification?  Since its type is showing a built-in function or method we can\\'t even convert it to integer and use to verify. "
                    }
                ]
            },
            {
                "id": 1696741,
                "content": [
                    {
                        "username": "Sanjeev___Thakur",
                        "content": "\\nclass Solution:\\n    def hasCycle(self, head):\\n        if head == None:\\n            return False\\n        slow = head\\n        fast =  head.next\\n        while fast!= None and slow != None:\\n            slow = head.next\\n            fast = head.next.next\\n            return True\\n\\nWith the above code i am able to pass all test cases but i am unable to submit the code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A1Amazon SDE-1 Interview\\uD83D\\uDCA5\\uD83E\\uDD73 #FAANG\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2875561/amazon-sde-1-interview-faang/?orderBy=most_relevant"
                    },
                    {
                        "username": "aanya_969",
                        "content": "What is the need of pos variable??"
                    },
                    {
                        "username": "AlexTyu",
                        "content": "When I use \\n```\\nfast = fast->next->next;\\n slow = slow->next; \\n```\\nMy program gets accepted, but if I use\\n```\\nslow = slow->next;\\nfast = slow->next;\\n```\\nIt says it is too slow. Anyone mind explaining why it is slower?"
                    },
                    {
                        "username": "ashmitarana616",
                        "content": "Here in this question we just need to check whether the given LL is circular or not .\\nSo to check it we just need tho compare the  head and last node if they are connected to eacthother then the Linked List is circular ...\\nif condition  is true returns true  otherwise false !"
                    },
                    {
                        "username": "shyamimmadi7",
                        "content": "what does pos = -1 mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Anees2778",
                        "content": "Someone please help me out : \\nError msg-\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:21\\n\\nI don\\'t get the point, where is the problem in code? [leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "drumsmanku",
                        "content": "Just use set or map"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "What is the need of `pos`, we don't need it anyways. It just makes the example test cases confusing, it can be a part of the explanation in examples but not the input."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used it to make my own test cases. For example, change pos in the 3 example to 0. The answer will be different."
                    },
                    {
                        "username": "ayushisinghania14",
                        "content": "How can we use \"pos\" for verification?  Since its type is showing a built-in function or method we can\\'t even convert it to integer and use to verify. "
                    }
                ]
            },
            {
                "id": 1694937,
                "content": [
                    {
                        "username": "Sanjeev___Thakur",
                        "content": "\\nclass Solution:\\n    def hasCycle(self, head):\\n        if head == None:\\n            return False\\n        slow = head\\n        fast =  head.next\\n        while fast!= None and slow != None:\\n            slow = head.next\\n            fast = head.next.next\\n            return True\\n\\nWith the above code i am able to pass all test cases but i am unable to submit the code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A1Amazon SDE-1 Interview\\uD83D\\uDCA5\\uD83E\\uDD73 #FAANG\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2875561/amazon-sde-1-interview-faang/?orderBy=most_relevant"
                    },
                    {
                        "username": "aanya_969",
                        "content": "What is the need of pos variable??"
                    },
                    {
                        "username": "AlexTyu",
                        "content": "When I use \\n```\\nfast = fast->next->next;\\n slow = slow->next; \\n```\\nMy program gets accepted, but if I use\\n```\\nslow = slow->next;\\nfast = slow->next;\\n```\\nIt says it is too slow. Anyone mind explaining why it is slower?"
                    },
                    {
                        "username": "ashmitarana616",
                        "content": "Here in this question we just need to check whether the given LL is circular or not .\\nSo to check it we just need tho compare the  head and last node if they are connected to eacthother then the Linked List is circular ...\\nif condition  is true returns true  otherwise false !"
                    },
                    {
                        "username": "shyamimmadi7",
                        "content": "what does pos = -1 mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Anees2778",
                        "content": "Someone please help me out : \\nError msg-\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:21\\n\\nI don\\'t get the point, where is the problem in code? [leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "drumsmanku",
                        "content": "Just use set or map"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "What is the need of `pos`, we don't need it anyways. It just makes the example test cases confusing, it can be a part of the explanation in examples but not the input."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used it to make my own test cases. For example, change pos in the 3 example to 0. The answer will be different."
                    },
                    {
                        "username": "ayushisinghania14",
                        "content": "How can we use \"pos\" for verification?  Since its type is showing a built-in function or method we can\\'t even convert it to integer and use to verify. "
                    }
                ]
            },
            {
                "id": 1691797,
                "content": [
                    {
                        "username": "Sanjeev___Thakur",
                        "content": "\\nclass Solution:\\n    def hasCycle(self, head):\\n        if head == None:\\n            return False\\n        slow = head\\n        fast =  head.next\\n        while fast!= None and slow != None:\\n            slow = head.next\\n            fast = head.next.next\\n            return True\\n\\nWith the above code i am able to pass all test cases but i am unable to submit the code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A1Amazon SDE-1 Interview\\uD83D\\uDCA5\\uD83E\\uDD73 #FAANG\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2875561/amazon-sde-1-interview-faang/?orderBy=most_relevant"
                    },
                    {
                        "username": "aanya_969",
                        "content": "What is the need of pos variable??"
                    },
                    {
                        "username": "AlexTyu",
                        "content": "When I use \\n```\\nfast = fast->next->next;\\n slow = slow->next; \\n```\\nMy program gets accepted, but if I use\\n```\\nslow = slow->next;\\nfast = slow->next;\\n```\\nIt says it is too slow. Anyone mind explaining why it is slower?"
                    },
                    {
                        "username": "ashmitarana616",
                        "content": "Here in this question we just need to check whether the given LL is circular or not .\\nSo to check it we just need tho compare the  head and last node if they are connected to eacthother then the Linked List is circular ...\\nif condition  is true returns true  otherwise false !"
                    },
                    {
                        "username": "shyamimmadi7",
                        "content": "what does pos = -1 mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Anees2778",
                        "content": "Someone please help me out : \\nError msg-\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:21\\n\\nI don\\'t get the point, where is the problem in code? [leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "drumsmanku",
                        "content": "Just use set or map"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "What is the need of `pos`, we don't need it anyways. It just makes the example test cases confusing, it can be a part of the explanation in examples but not the input."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used it to make my own test cases. For example, change pos in the 3 example to 0. The answer will be different."
                    },
                    {
                        "username": "ayushisinghania14",
                        "content": "How can we use \"pos\" for verification?  Since its type is showing a built-in function or method we can\\'t even convert it to integer and use to verify. "
                    }
                ]
            },
            {
                "id": 1687386,
                "content": [
                    {
                        "username": "Sanjeev___Thakur",
                        "content": "\\nclass Solution:\\n    def hasCycle(self, head):\\n        if head == None:\\n            return False\\n        slow = head\\n        fast =  head.next\\n        while fast!= None and slow != None:\\n            slow = head.next\\n            fast = head.next.next\\n            return True\\n\\nWith the above code i am able to pass all test cases but i am unable to submit the code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A1Amazon SDE-1 Interview\\uD83D\\uDCA5\\uD83E\\uDD73 #FAANG\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2875561/amazon-sde-1-interview-faang/?orderBy=most_relevant"
                    },
                    {
                        "username": "aanya_969",
                        "content": "What is the need of pos variable??"
                    },
                    {
                        "username": "AlexTyu",
                        "content": "When I use \\n```\\nfast = fast->next->next;\\n slow = slow->next; \\n```\\nMy program gets accepted, but if I use\\n```\\nslow = slow->next;\\nfast = slow->next;\\n```\\nIt says it is too slow. Anyone mind explaining why it is slower?"
                    },
                    {
                        "username": "ashmitarana616",
                        "content": "Here in this question we just need to check whether the given LL is circular or not .\\nSo to check it we just need tho compare the  head and last node if they are connected to eacthother then the Linked List is circular ...\\nif condition  is true returns true  otherwise false !"
                    },
                    {
                        "username": "shyamimmadi7",
                        "content": "what does pos = -1 mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Anees2778",
                        "content": "Someone please help me out : \\nError msg-\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:21\\n\\nI don\\'t get the point, where is the problem in code? [leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "drumsmanku",
                        "content": "Just use set or map"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "What is the need of `pos`, we don't need it anyways. It just makes the example test cases confusing, it can be a part of the explanation in examples but not the input."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used it to make my own test cases. For example, change pos in the 3 example to 0. The answer will be different."
                    },
                    {
                        "username": "ayushisinghania14",
                        "content": "How can we use \"pos\" for verification?  Since its type is showing a built-in function or method we can\\'t even convert it to integer and use to verify. "
                    }
                ]
            },
            {
                "id": 1668469,
                "content": [
                    {
                        "username": "Sanjeev___Thakur",
                        "content": "\\nclass Solution:\\n    def hasCycle(self, head):\\n        if head == None:\\n            return False\\n        slow = head\\n        fast =  head.next\\n        while fast!= None and slow != None:\\n            slow = head.next\\n            fast = head.next.next\\n            return True\\n\\nWith the above code i am able to pass all test cases but i am unable to submit the code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A1Amazon SDE-1 Interview\\uD83D\\uDCA5\\uD83E\\uDD73 #FAANG\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2875561/amazon-sde-1-interview-faang/?orderBy=most_relevant"
                    },
                    {
                        "username": "aanya_969",
                        "content": "What is the need of pos variable??"
                    },
                    {
                        "username": "AlexTyu",
                        "content": "When I use \\n```\\nfast = fast->next->next;\\n slow = slow->next; \\n```\\nMy program gets accepted, but if I use\\n```\\nslow = slow->next;\\nfast = slow->next;\\n```\\nIt says it is too slow. Anyone mind explaining why it is slower?"
                    },
                    {
                        "username": "ashmitarana616",
                        "content": "Here in this question we just need to check whether the given LL is circular or not .\\nSo to check it we just need tho compare the  head and last node if they are connected to eacthother then the Linked List is circular ...\\nif condition  is true returns true  otherwise false !"
                    },
                    {
                        "username": "shyamimmadi7",
                        "content": "what does pos = -1 mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Anees2778",
                        "content": "Someone please help me out : \\nError msg-\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:21\\n\\nI don\\'t get the point, where is the problem in code? [leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "drumsmanku",
                        "content": "Just use set or map"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "What is the need of `pos`, we don't need it anyways. It just makes the example test cases confusing, it can be a part of the explanation in examples but not the input."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used it to make my own test cases. For example, change pos in the 3 example to 0. The answer will be different."
                    },
                    {
                        "username": "ayushisinghania14",
                        "content": "How can we use \"pos\" for verification?  Since its type is showing a built-in function or method we can\\'t even convert it to integer and use to verify. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Different Ways to Add Parentheses",
        "question_content": "<p>Given a string <code>expression</code> of numbers and operators, return <em>all possible results from computing all the different possible ways to group numbers and operators</em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed <code>10<sup>4</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;2-1-1&quot;\n<strong>Output:</strong> [0,2]\n<strong>Explanation:</strong>\n((2-1)-1) = 0 \n(2-(1-1)) = 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;2*3-4*5&quot;\n<strong>Output:</strong> [-34,-14,-10,-10,10]\n<strong>Explanation:</strong>\n(2*(3-(4*5))) = -34 \n((2*3)-(4*5)) = -14 \n((2*(3-4))*5) = -10 \n(2*((3-4)*5)) = -10 \n(((2*3)-4)*5) = 10\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 20</code></li>\n\t<li><code>expression</code> consists of digits and the operator <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, and <code>&#39;*&#39;</code>.</li>\n\t<li>All the integer values in the input expression are in the range <code>[0, 99]</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 66328,
                "title": "a-recursive-java-solution-284-ms",
                "content": "    public class Solution {\\n        public List<Integer> diffWaysToCompute(String input) {\\n            List<Integer> ret = new LinkedList<Integer>();\\n            for (int i=0; i<input.length(); i++) {\\n                if (input.charAt(i) == '-' ||\\n                    input.charAt(i) == '*' ||\\n                    input.charAt(i) == '+' ) {\\n                    String part1 = input.substring(0, i);\\n                    String part2 = input.substring(i+1);\\n                    List<Integer> part1Ret = diffWaysToCompute(part1);\\n                    List<Integer> part2Ret = diffWaysToCompute(part2);\\n                    for (Integer p1 :   part1Ret) {\\n                        for (Integer p2 :   part2Ret) {\\n                            int c = 0;\\n                            switch (input.charAt(i)) {\\n                                case '+': c = p1+p2;\\n                                    break;\\n                                case '-': c = p1-p2;\\n                                    break;\\n                                case '*': c = p1*p2;\\n                                    break;\\n                            }\\n                            ret.add(c);\\n                        }\\n                    }\\n                }\\n            }\\n            if (ret.size() == 0) {\\n                ret.add(Integer.valueOf(input));\\n            }\\n            return ret;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> diffWaysToCompute(String input) {\\n            List<Integer> ret = new LinkedList<Integer>();\\n            for (int i=0; i<input.length(); i++) {\\n                if (input.charAt(i) == '-' ||\\n                    input.charAt(i) == '*' ||\\n                    input.charAt(i) == '+' ) {\\n                    String part1 = input.substring(0, i);\\n                    String part2 = input.substring(i+1);\\n                    List<Integer> part1Ret = diffWaysToCompute(part1);\\n                    List<Integer> part2Ret = diffWaysToCompute(part2);\\n                    for (Integer p1 :   part1Ret) {\\n                        for (Integer p2 :   part2Ret) {\\n                            int c = 0;\\n                            switch (input.charAt(i)) {\\n                                case '+': c = p1+p2;\\n                                    break;\\n                                case '-': c = p1-p2;\\n                                    break;\\n                                case '*': c = p1*p2;\\n                                    break;\\n                            }",
                "codeTag": "Java"
            },
            {
                "id": 66331,
                "title": "c-4ms-recursive-dp-solution-with-brief-explanation",
                "content": "Here is the basic recursive solution\\n\\n    class Solution {\\n    public:\\n        vector<int> diffWaysToCompute(string input) {\\n            vector<int> result;\\n            int size = input.size();\\n            for (int i = 0; i < size; i++) {\\n                char cur = input[i];\\n                if (cur == '+' || cur == '-' || cur == '*') {\\n                    // Split input string into two parts and solve them recursively\\n                    vector<int> result1 = diffWaysToCompute(input.substr(0, i));\\n                    vector<int> result2 = diffWaysToCompute(input.substr(i+1));\\n                    for (auto n1 : result1) {\\n                        for (auto n2 : result2) {\\n                            if (cur == '+')\\n                                result.push_back(n1 + n2);\\n                            else if (cur == '-')\\n                                result.push_back(n1 - n2);\\n                            else\\n                                result.push_back(n1 * n2);    \\n                        }\\n                    }\\n                }\\n            }\\n            // if the input string contains only number\\n            if (result.empty())\\n                result.push_back(atoi(input.c_str()));\\n            return result;\\n        }\\n    };\\n\\nThere are many repeating subquestions in this recursive method, therefore, we could use dynamic programming to avoid this situation by saving the results for subquestions. Here is the DP solution.\\n\\n    class Solution {\\n    public:\\n    \\tvector<int> diffWaysToCompute(string input) {\\n    \\t\\tunordered_map<string, vector<int>> dpMap;\\n    \\t\\treturn computeWithDP(input, dpMap);\\n    \\t}\\n    \\n    \\tvector<int> computeWithDP(string input, unordered_map<string, vector<int>> &dpMap) {\\n    \\t\\tvector<int> result;\\n    \\t\\tint size = input.size();\\n    \\t\\tfor (int i = 0; i < size; i++) {\\n    \\t\\t\\tchar cur = input[i];\\n    \\t\\t\\tif (cur == '+' || cur == '-' || cur == '*') {\\n    \\t\\t\\t\\t// Split input string into two parts and solve them recursively\\n    \\t\\t\\t\\tvector<int> result1, result2;\\n    \\t\\t\\t\\tstring substr = input.substr(0, i);\\n    \\t\\t\\t\\t// check if dpMap has the result for substr\\n    \\t\\t\\t\\tif (dpMap.find(substr) != dpMap.end())\\n    \\t\\t\\t\\t\\tresult1 = dpMap[substr];\\n    \\t\\t\\t\\telse\\n    \\t\\t\\t\\t\\tresult1 = computeWithDP(substr, dpMap);\\n    \\n    \\t\\t\\t\\tsubstr = input.substr(i + 1);\\n    \\t\\t\\t\\tif (dpMap.find(substr) != dpMap.end())\\n    \\t\\t\\t\\t\\tresult2 = dpMap[substr];\\n    \\t\\t\\t\\telse\\n    \\t\\t\\t\\t\\tresult2 = computeWithDP(substr, dpMap);\\n    \\t\\t\\t\\t\\n    \\t\\t\\t\\tfor (auto n1 : result1) {\\n    \\t\\t\\t\\t\\tfor (auto n2 : result2) {\\n    \\t\\t\\t\\t\\t\\tif (cur == '+')\\n    \\t\\t\\t\\t\\t\\t\\tresult.push_back(n1 + n2);\\n    \\t\\t\\t\\t\\t\\telse if (cur == '-')\\n    \\t\\t\\t\\t\\t\\t\\tresult.push_back(n1 - n2);\\n    \\t\\t\\t\\t\\t\\telse\\n    \\t\\t\\t\\t\\t\\t\\tresult.push_back(n1 * n2);\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t// if the input string contains only number\\n    \\t\\tif (result.empty())\\n    \\t\\t\\tresult.push_back(atoi(input.c_str()));\\n    \\t\\t// save to dpMap\\n    \\t\\tdpMap[input] = result;\\n    \\t\\treturn result;\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> diffWaysToCompute(string input) {\\n            vector<int> result;\\n            int size = input.size();\\n            for (int i = 0; i < size; i++) {\\n                char cur = input[i];\\n                if (cur == '+' || cur == '-' || cur == '*') {\\n                    // Split input string into two parts and solve them recursively\\n                    vector<int> result1 = diffWaysToCompute(input.substr(0, i));\\n                    vector<int> result2 = diffWaysToCompute(input.substr(i+1));\\n                    for (auto n1 : result1) {\\n                        for (auto n2 : result2) {\\n                            if (cur == '+')\\n                                result.push_back(n1 + n2);\\n                            else if (cur == '-')\\n                                result.push_back(n1 - n2);\\n                            else\\n                                result.push_back(n1 * n2);    \\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 1294189,
                "title": "easy-solution-faster-than-100-explained-with-diagrams",
                "content": "* The problem becomes easier when we think about these expressions as expression trees.\\n* We can traverse over the experssion and whenever we encounter an operator, we recursively divide the expression into left and right part and evaluate them seperately until we reach a situation where our expression is purely a number and in this case we can simply return that number.\\n* Since there can be multiple ways to evaluate an expression (depending on which operator you take first) we will get a list of reults from left and the right part.\\n* Now that we have all the possible results from the left and the right part, we can use them to find out all the possible results for the current operator.\\n\\n\\n\\nThe following image shows all the possible expression trees for the expression `\"2*3-4*5\"`\\n\\n![image](https://assets.leetcode.com/users/images/811924c6-d550-4135-909c-e10f7a58af26_1624537462.121658.png)\\n\\n\\n\\nC++ Implementation:\\n```\\nclass Solution {\\npublic:\\n    // function to get the result of the operation\\n    int perform(int x, int y, char op) {\\n        if(op == \\'+\\') return x + y;\\n        if(op == \\'-\\') return x - y;\\n        if(op == \\'*\\') return x * y;\\n        return 0;\\n    }\\n    \\n    vector<int> diffWaysToCompute(string exp) {\\n        \\n        vector<int> results;\\n        bool isNumber = 1;\\n    \\n        for(int i = 0; i < exp.length(); i++) {\\n            // check if current character is an operator\\n            if(!isdigit(exp[i])) {\\n                \\n                // if current character is not a digit then\\n                // exp is not purely a number\\n                isNumber = 0;\\n                \\n                // list of first operands\\n                vector<int> left = diffWaysToCompute(exp.substr(0, i));\\n                \\n                // list of second operands\\n                vector<int> right = diffWaysToCompute(exp.substr(i + 1));\\n                \\n                // performing operations\\n                for(int x : left) {\\n                    for(int y : right) {\\n                        int val = perform(x, y, exp[i]);\\n                        results.push_back(val);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        if(isNumber == 1) results.push_back(stoi(exp));\\n        return results;\\n    }\\n};\\n\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // function to get the result of the operation\\n    int perform(int x, int y, char op) {\\n        if(op == \\'+\\') return x + y;\\n        if(op == \\'-\\') return x - y;\\n        if(op == \\'*\\') return x * y;\\n        return 0;\\n    }\\n    \\n    vector<int> diffWaysToCompute(string exp) {\\n        \\n        vector<int> results;\\n        bool isNumber = 1;\\n    \\n        for(int i = 0; i < exp.length(); i++) {\\n            // check if current character is an operator\\n            if(!isdigit(exp[i])) {\\n                \\n                // if current character is not a digit then\\n                // exp is not purely a number\\n                isNumber = 0;\\n                \\n                // list of first operands\\n                vector<int> left = diffWaysToCompute(exp.substr(0, i));\\n                \\n                // list of second operands\\n                vector<int> right = diffWaysToCompute(exp.substr(i + 1));\\n                \\n                // performing operations\\n                for(int x : left) {\\n                    for(int y : right) {\\n                        int val = perform(x, y, exp[i]);\\n                        results.push_back(val);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        if(isNumber == 1) results.push_back(stoi(exp));\\n        return results;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66419,
                "title": "python-easy-to-understand-concise-solution-with-memorization",
                "content": "```\\nclass Solution(object):\\n    def diffWaysToCompute(self, input):\\n        m = {}\\n        return self.dfs(input, m)\\n        \\n    def dfs(self, input, m):\\n        if input in m:\\n            return m[input]\\n        if input.isdigit():\\n            m[input] = int(input)\\n            return [int(input)]\\n        ret = []\\n        for i, c in enumerate(input):\\n            if c in \"+-*\":\\n                l = self.diffWaysToCompute(input[:i])\\n                r = self.diffWaysToCompute(input[i+1:])\\n                ret.extend(eval(str(x)+c+str(y)) for x in l for y in r)\\n        m[input] = ret\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution(object):\\n    def diffWaysToCompute(self, input):\\n        m = {}\\n        return self.dfs(input, m)\\n        \\n    def dfs(self, input, m):\\n        if input in m:\\n            return m[input]\\n        if input.isdigit():\\n            m[input] = int(input)\\n            return [int(input)]\\n        ret = []\\n        for i, c in enumerate(input):\\n            if c in \"+-*\":\\n                l = self.diffWaysToCompute(input[:i])\\n                r = self.diffWaysToCompute(input[i+1:])\\n                ret.extend(eval(str(x)+c+str(y)) for x in l for y in r)\\n        m[input] = ret\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66342,
                "title": "share-a-clean-and-short-java-solution",
                "content": "    public class Solution {\\n        public List<Integer> diffWaysToCompute(String input) {\\n            List<Integer> res = new ArrayList<Integer>();\\n            for (int i = 0; i < input.length(); i++) {\\n                char c = input.charAt(i);\\n                if (c == '-' || c == '+' || c == '*') {\\n                    String a = input.substring(0, i);\\n                    String b = input.substring(i + 1);\\n                    List<Integer> al = diffWaysToCompute(a);\\n                    List<Integer> bl = diffWaysToCompute(b);\\n                    for (int x : al) {\\n                        for (int y : bl) {\\n                            if (c == '-') {\\n                                res.add(x - y);\\n                            } else if (c == '+') {\\n                                res.add(x + y);\\n                            } else if (c == '*') {\\n                                res.add(x * y);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            if (res.size() == 0) res.add(Integer.valueOf(input));\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> diffWaysToCompute(String input) {\\n            List<Integer> res = new ArrayList<Integer>();\\n            for (int i = 0; i < input.length(); i++) {\\n                char c = input.charAt(i);\\n                if (c == '-' || c == '+' || c == '*') {\\n                    String a = input.substring(0, i);\\n                    String b = input.substring(i + 1);\\n                    List<Integer> al = diffWaysToCompute(a);\\n                    List<Integer> bl = diffWaysToCompute(b);\\n                    for (int x : al) {\\n                        for (int y : bl) {\\n                            if (c == '-') {\\n                                res.add(x - y);\\n                            }",
                "codeTag": "Java"
            },
            {
                "id": 151979,
                "title": "divide-and-conquer-memoization",
                "content": "# Divide and Conquer\\nIf we break down the problem, we can simply observe the recursion formula as follows:\\n\\n```\\nWe will call +/-/* symbols.\\n\\n(base) case 1: if there is 0 symbol, \\n\\te.g. 1, we simply return it as a list, [1].\\n\\ncase 2: if there is 1 symbol, \\n\\te.g., 1 + 2, we divide it by symbol and add parenthesis in both sides: (1) + (2), (1) and (2) reduce to case 1, and we add the results of both sides and return as a list, [3].\\n\\ncase 3: if there are 2 symbols, \\n\\te.g., 1 + 2 + 3, we divide it by symbol and add parenthesis in both sides: (1) + (2 + 3) or (1 + 2) + (3).\\n\\tTake (1) + (2 + 3) for example, (1) reduces to case1, (2 + 3) reduces to case 2 (then case 1), finally we add the results of both sides and add the final ressult to the list, [6].\\n...\\n\\nIf there are n symbols, for each symbol, we divide it into two parts and add parenthesis in both sides, each side is reduced to a subproblem which can be solved recursively, finally we combine the results of both sides by the symbol and add to the final result list.\\n```\\n\\n\\nThe time complexity is `O(2^n)` exponential, for n is the number of operators in the input. That\\'s because each function call calls itself twice.\\n\\n\\n```\\nclass Solution:\\n    def diffWaysToCompute(self, expression: str) -> List[int]:\\n        \\n        if (\\'+\\' not in expression) and (\\'-\\' not in expression) and (\\'*\\' not in expression):\\n            return [int(expression)]\\n        \\n        res = []\\n        \\n        for i, v in enumerate(expression):\\n            if v == \\'+\\' or v == \\'-\\' or v == \\'*\\':\\n                left_res = self.diffWaysToCompute(expression[:i])\\n                right_res = self.diffWaysToCompute(expression[i + 1:])\\n                for left_i, left_v in enumerate(left_res):\\n                    for right_i, right_v in enumerate(right_res):\\n                        if v == \\'+\\':\\n                            res.append(left_v + right_v)\\n                        elif v == \\'-\\':\\n                            res.append(left_v - right_v)\\n                        else:\\n                            res.append(left_v * right_v)\\n        return res\\n        \\n```\\n\\n# Memoization\\nMemoization is a method used to store the results of previous function calls to speed up future calculations.\\n\\n`self.memo` is introduced to store the results of calculated `diffWaysToComputeUtil` with a specific expression.\\n\\nThe time complexity is `O(n)` linear, for n is the number of operators in the input. That\\'s because each function call is calculated once now.\\n\\n```\\nclass Solution:\\n    def diffWaysToCompute(self, expression: str) -> List[int]:\\n        self.memo = defaultdict(list)\\n        return self.diffWaysToComputeUtil(expression)\\n        \\n        \\n    def diffWaysToComputeUtil(self, expression: str) -> List[int]:\\n        if expression in self.memo:\\n            return self.memo[expression]\\n        \\n        if (\\'+\\' not in expression) and (\\'-\\' not in expression) and (\\'*\\' not in expression):\\n            return [int(expression)]\\n        \\n        res = []\\n        \\n        for i, v in enumerate(expression):\\n            if v == \\'+\\' or v == \\'-\\' or v == \\'*\\':\\n                left_res = self.diffWaysToComputeUtil(expression[:i])\\n                right_res = self.diffWaysToComputeUtil(expression[i + 1:])\\n                for left_i, left_v in enumerate(left_res):\\n                    for right_i, right_v in enumerate(right_res):\\n                        if v == \\'+\\':\\n                            res.append(left_v + right_v)\\n                        elif v == \\'-\\':\\n                            res.append(left_v - right_v)\\n                        else:\\n                            res.append(left_v * right_v)\\n        self.memo[expression] = res\\n        return res\\n```\\n",
                "solutionTags": [
                    "Divide and Conquer",
                    "Memoization"
                ],
                "code": "```\\nWe will call +/-/* symbols.\\n\\n(base) case 1: if there is 0 symbol, \\n\\te.g. 1, we simply return it as a list, [1].\\n\\ncase 2: if there is 1 symbol, \\n\\te.g., 1 + 2, we divide it by symbol and add parenthesis in both sides: (1) + (2), (1) and (2) reduce to case 1, and we add the results of both sides and return as a list, [3].\\n\\ncase 3: if there are 2 symbols, \\n\\te.g., 1 + 2 + 3, we divide it by symbol and add parenthesis in both sides: (1) + (2 + 3) or (1 + 2) + (3).\\n\\tTake (1) + (2 + 3) for example, (1) reduces to case1, (2 + 3) reduces to case 2 (then case 1), finally we add the results of both sides and add the final ressult to the list, [6].\\n...\\n\\nIf there are n symbols, for each symbol, we divide it into two parts and add parenthesis in both sides, each side is reduced to a subproblem which can be solved recursively, finally we combine the results of both sides by the symbol and add to the final result list.\\n```\n```\\nclass Solution:\\n    def diffWaysToCompute(self, expression: str) -> List[int]:\\n        \\n        if (\\'+\\' not in expression) and (\\'-\\' not in expression) and (\\'*\\' not in expression):\\n            return [int(expression)]\\n        \\n        res = []\\n        \\n        for i, v in enumerate(expression):\\n            if v == \\'+\\' or v == \\'-\\' or v == \\'*\\':\\n                left_res = self.diffWaysToCompute(expression[:i])\\n                right_res = self.diffWaysToCompute(expression[i + 1:])\\n                for left_i, left_v in enumerate(left_res):\\n                    for right_i, right_v in enumerate(right_res):\\n                        if v == \\'+\\':\\n                            res.append(left_v + right_v)\\n                        elif v == \\'-\\':\\n                            res.append(left_v - right_v)\\n                        else:\\n                            res.append(left_v * right_v)\\n        return res\\n        \\n```\n```\\nclass Solution:\\n    def diffWaysToCompute(self, expression: str) -> List[int]:\\n        self.memo = defaultdict(list)\\n        return self.diffWaysToComputeUtil(expression)\\n        \\n        \\n    def diffWaysToComputeUtil(self, expression: str) -> List[int]:\\n        if expression in self.memo:\\n            return self.memo[expression]\\n        \\n        if (\\'+\\' not in expression) and (\\'-\\' not in expression) and (\\'*\\' not in expression):\\n            return [int(expression)]\\n        \\n        res = []\\n        \\n        for i, v in enumerate(expression):\\n            if v == \\'+\\' or v == \\'-\\' or v == \\'*\\':\\n                left_res = self.diffWaysToComputeUtil(expression[:i])\\n                right_res = self.diffWaysToComputeUtil(expression[i + 1:])\\n                for left_i, left_v in enumerate(left_res):\\n                    for right_i, right_v in enumerate(right_res):\\n                        if v == \\'+\\':\\n                            res.append(left_v + right_v)\\n                        elif v == \\'-\\':\\n                            res.append(left_v - right_v)\\n                        else:\\n                            res.append(left_v * right_v)\\n        self.memo[expression] = res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66333,
                "title": "java-recursive-9ms-and-dp-4ms-solution",
                "content": "I think it's more efficient to pre-parse the string because String.substring() is costly. I store the parsed string in a list, for example, if the string is 1+2+3+4, then the list will contain:\\n\\n    \"1\", \"+\", \"2\", \"+\", \"3\", \"+\", \"4\"\\n\\nPersonally I feel this is also more convenient because all integers occurs at even indices (0, 2, 4, 6) and all operators are at odd indices (1, 3, 5).\\n\\nThen the problem is very similar to \"Unique Binary Search Trees II\". For each operator in the list, we compute all possible results for entries to the left of that operator, which is `List<Integer> left`, and also all possible results for entries to the right of that operator, namely `List<Integer> right`, and combine the results. It can be achieved by recursion or more efficiently by dp.\\n\\nRecursion:\\n\\n    public List<Integer> diffWaysToCompute(String input) {\\n        List<Integer> result=new ArrayList<>();\\n        if(input==null||input.length()==0)  return result;\\n        List<String> ops=new ArrayList<>();\\n        for(int i=0; i<input.length(); i++){\\n            int j=i;\\n            while(j<input.length()&&Character.isDigit(input.charAt(j)))\\n                j++;\\n            String num=input.substring(i, j);\\n            ops.add(num);\\n            if(j!=input.length())   ops.add(input.substring(j, j+1));\\n            i=j;\\n        }\\n        result=compute(ops, 0, ops.size()-1);\\n        return result;\\n    }\\n    private List<Integer> compute(List<String> ops, int lo, int hi){\\n        List<Integer> result=new ArrayList<>();\\n        if(lo==hi){\\n            Integer num=Integer.valueOf(ops.get(lo));\\n            result.add(num);\\n            return result;\\n        }\\n        for(int i=lo+1; i<=hi-1; i=i+2){\\n            String operator=ops.get(i);\\n            List<Integer> left=compute(ops,lo, i-1), right=compute(ops, i+1, hi);\\n            for(int leftNum:left)\\n                for(int rightNum: right){\\n                    if(operator.equals(\"+\"))\\n                        result.add(leftNum+rightNum);\\n                    else if(operator.equals(\"-\"))\\n                        result.add(leftNum-rightNum);\\n                    else\\n                        result.add(leftNum*rightNum);\\n                }\\n        }\\n        return result;\\n    }\\n\\n\\nAnd DP, where dp[i][j] stores all possible results from the i-th integer to the j-th integer (inclusive) in the list.\\n\\n    public List<Integer> diffWaysToCompute(String input) {\\n        List<Integer> result=new ArrayList<>();\\n        if(input==null||input.length()==0)  return result;\\n        List<String> ops=new ArrayList<>();\\n        for(int i=0; i<input.length(); i++){\\n            int j=i;\\n            while(j<input.length()&&Character.isDigit(input.charAt(j)))\\n                j++;\\n            ops.add(input.substring(i, j));\\n            if(j!=input.length())   ops.add(input.substring(j, j+1));\\n            i=j;\\n        }\\n        int N=(ops.size()+1)/2; //num of integers\\n        ArrayList<Integer>[][] dp=(ArrayList<Integer>[][]) new ArrayList[N][N];\\n        for(int d=0; d<N; d++){\\n            if(d==0){\\n                for(int i=0; i<N; i++){\\n                    dp[i][i]=new ArrayList<>();\\n                    dp[i][i].add(Integer.valueOf(ops.get(i*2)));\\n                }\\n                continue;\\n            }\\n            for(int i=0; i<N-d; i++){\\n                dp[i][i+d]=new ArrayList<>();\\n                for(int j=i; j<i+d; j++){\\n                    ArrayList<Integer> left=dp[i][j], right=dp[j+1][i+d];\\n                    String operator=ops.get(j*2+1);\\n                    for(int leftNum:left)\\n                        for(int rightNum:right){\\n                            if(operator.equals(\"+\"))\\n                                dp[i][i+d].add(leftNum+rightNum);\\n                            else if(operator.equals(\"-\"))\\n                                dp[i][i+d].add(leftNum-rightNum);\\n                            else\\n                                dp[i][i+d].add(leftNum*rightNum);\\n                        }\\n                }\\n            }\\n        }\\n        return dp[0][N-1];\\n    }",
                "solutionTags": [],
                "code": "I think it's more efficient to pre-parse the string because String.substring() is costly. I store the parsed string in a list, for example, if the string is 1+2+3+4, then the list will contain:\\n\\n    \"1\", \"+\", \"2\", \"+\", \"3\", \"+\", \"4\"\\n\\nPersonally I feel this is also more convenient because all integers occurs at even indices (0, 2, 4, 6) and all operators are at odd indices (1, 3, 5).\\n\\nThen the problem is very similar to \"Unique Binary Search Trees II\". For each operator in the list, we compute all possible results for entries to the left of that operator, which is `List<Integer> left`, and also all possible results for entries to the right of that operator, namely `List<Integer> right`, and combine the results. It can be achieved by recursion or more efficiently by dp.\\n\\nRecursion:\\n\\n    public List<Integer> diffWaysToCompute(String input) {\\n        List<Integer> result=new ArrayList<>();\\n        if(input==null||input.length()==0)  return result;\\n        List<String> ops=new ArrayList<>();\\n        for(int i=0; i<input.length(); i++){\\n            int j=i;\\n            while(j<input.length()&&Character.isDigit(input.charAt(j)))\\n                j++;\\n            String num=input.substring(i, j);\\n            ops.add(num);\\n            if(j!=input.length())   ops.add(input.substring(j, j+1));\\n            i=j;\\n        }\\n        result=compute(ops, 0, ops.size()-1);\\n        return result;\\n    }\\n    private List<Integer> compute(List<String> ops, int lo, int hi){\\n        List<Integer> result=new ArrayList<>();\\n        if(lo==hi){\\n            Integer num=Integer.valueOf(ops.get(lo));\\n            result.add(num);\\n            return result;\\n        }\\n        for(int i=lo+1; i<=hi-1; i=i+2){\\n            String operator=ops.get(i);\\n            List<Integer> left=compute(ops,lo, i-1), right=compute(ops, i+1, hi);\\n            for(int leftNum:left)\\n                for(int rightNum: right){\\n                    if(operator.equals(\"+\"))\\n                        result.add(leftNum+rightNum);\\n                    else if(operator.equals(\"-\"))\\n                        result.add(leftNum-rightNum);\\n                    else\\n                        result.add(leftNum*rightNum);\\n                }\\n        }\\n        return result;\\n    }\\n\\n\\nAnd DP, where dp[i][j] stores all possible results from the i-th integer to the j-th integer (inclusive) in the list.\\n\\n    public List<Integer> diffWaysToCompute(String input) {\\n        List<Integer> result=new ArrayList<>();\\n        if(input==null||input.length()==0)  return result;\\n        List<String> ops=new ArrayList<>();\\n        for(int i=0; i<input.length(); i++){\\n            int j=i;\\n            while(j<input.length()&&Character.isDigit(input.charAt(j)))\\n                j++;\\n            ops.add(input.substring(i, j));\\n            if(j!=input.length())   ops.add(input.substring(j, j+1));\\n            i=j;\\n        }\\n        int N=(ops.size()+1)/2; //num of integers\\n        ArrayList<Integer>[][] dp=(ArrayList<Integer>[][]) new ArrayList[N][N];\\n        for(int d=0; d<N; d++){\\n            if(d==0){\\n                for(int i=0; i<N; i++){\\n                    dp[i][i]=new ArrayList<>();\\n                    dp[i][i].add(Integer.valueOf(ops.get(i*2)));\\n                }\\n                continue;\\n            }\\n            for(int i=0; i<N-d; i++){\\n                dp[i][i+d]=new ArrayList<>();\\n                for(int j=i; j<i+d; j++){\\n                    ArrayList<Integer> left=dp[i][j], right=dp[j+1][i+d];\\n                    String operator=ops.get(j*2+1);\\n                    for(int leftNum:left)\\n                        for(int rightNum:right){\\n                            if(operator.equals(\"+\"))\\n                                dp[i][i+d].add(leftNum+rightNum);\\n                            else if(operator.equals(\"-\"))\\n                                dp[i][i+d].add(leftNum-rightNum);\\n                            else\\n                                dp[i][i+d].add(leftNum*rightNum);\\n                        }\\n                }\\n            }\\n        }\\n        return dp[0][N-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 520018,
                "title": "easy-understand-d-c-solution-no-helper-function-needed-pattern-example",
                "content": "The most difficult part is finding the pattern\\nI will set example to show the pattern I found:\\nLet\\'s say 2-1-1+1, you can think it like a tree, every time when you read the operator you will split it into left part and right part:\\n\\n```\\niteration 1:\\n\\t\\t\\t2 - 1- 1 + 1\\n\\t\\t   /   \\\\\\n\\t\\t  2 - (1-1+1)\\n\\t\\t /\\t   /  \\\\\\n\\t\\t2\\t- (1 - (1+1))\\n\\t\\t\\n\\t\\tthen\\n\\t\\t\\n\\t\\t\\t2 - 1- 1 + 1\\n\\t\\t   /   \\\\\\n\\t\\t  2 - (1-1+1)\\n\\t\\t /\\t     /  \\\\\\n\\t\\t2 - ((1 -1)+1)\\n\\t\\t\\nThis give us\\n1.  2-(1 - (1+1))=3\\n2.  2 -(1 -1)+1))=1\\n\\n\\niteration 2:\\n\\t\\t2 - 1 - 1 + 1\\n\\t\\t    /   \\\\\\n\\t\\t(2 -1)-(1 + 1)\\nthis give us\\n1. (2-1)-(1+1) = -1\\n\\niteration 3:\\n\\t\\t\\t2 - 1- 1 + 1\\n\\t\\t\\t\\t   /   \\\\\\n\\t\\t   (2 - 1 - 1) + 1\\n\\t\\t\\t / \\\\          \\\\\\n\\t\\t   (2 - (1 -  1)) +  1\\n\\t\\t   \\n\\t\\t   then \\n\\t\\t   \\n\\t\\t   2 - 1- 1 + 1\\n\\t\\t\\t\\t   /   \\\\\\n\\t\\t   (2 - 1 - 1) + 1\\n\\t\\t\\t     / \\\\      \\\\\\n\\t\\t ((2 - 1) -  1) +  1\\nthis give us\\n1. 2 - (1 -  1)) +  1=3\\n2. ((2 - 1) -  1) +  1=1\\n\\nSo the solution is [3,1,-1,3,1]\\n\\n```\\nThe code is below:\\n```\\ndef diffWaysToCompute(self, input: str) -> List[int]:\\n        if input.isdigit():\\n            return [int(input)]\\n        res = []\\n        for i in range(len(input)):\\n            if input[i] in \"-+*\":\\n                left = self.diffWaysToCompute(input[:i])\\n                right = self.diffWaysToCompute(input[i+1:])\\n                for l in left:\\n                    for r in right:\\n                        if input[i] == \\'+\\':\\n                            res.append(l+r)\\n                        elif input[i] == \\'-\\':\\n                            res.append(l-r)\\n                        elif input[i] == \\'*\\':\\n                            res.append(l*r)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer"
                ],
                "code": "```\\niteration 1:\\n\\t\\t\\t2 - 1- 1 + 1\\n\\t\\t   /   \\\\\\n\\t\\t  2 - (1-1+1)\\n\\t\\t /\\t   /  \\\\\\n\\t\\t2\\t- (1 - (1+1))\\n\\t\\t\\n\\t\\tthen\\n\\t\\t\\n\\t\\t\\t2 - 1- 1 + 1\\n\\t\\t   /   \\\\\\n\\t\\t  2 - (1-1+1)\\n\\t\\t /\\t     /  \\\\\\n\\t\\t2 - ((1 -1)+1)\\n\\t\\t\\nThis give us\\n1.  2-(1 - (1+1))=3\\n2.  2 -(1 -1)+1))=1\\n\\n\\niteration 2:\\n\\t\\t2 - 1 - 1 + 1\\n\\t\\t    /   \\\\\\n\\t\\t(2 -1)-(1 + 1)\\nthis give us\\n1. (2-1)-(1+1) = -1\\n\\niteration 3:\\n\\t\\t\\t2 - 1- 1 + 1\\n\\t\\t\\t\\t   /   \\\\\\n\\t\\t   (2 - 1 - 1) + 1\\n\\t\\t\\t / \\\\          \\\\\\n\\t\\t   (2 - (1 -  1)) +  1\\n\\t\\t   \\n\\t\\t   then \\n\\t\\t   \\n\\t\\t   2 - 1- 1 + 1\\n\\t\\t\\t\\t   /   \\\\\\n\\t\\t   (2 - 1 - 1) + 1\\n\\t\\t\\t     / \\\\      \\\\\\n\\t\\t ((2 - 1) -  1) +  1\\nthis give us\\n1. 2 - (1 -  1)) +  1=3\\n2. ((2 - 1) -  1) +  1=1\\n\\nSo the solution is [3,1,-1,3,1]\\n\\n```\n```\\ndef diffWaysToCompute(self, input: str) -> List[int]:\\n        if input.isdigit():\\n            return [int(input)]\\n        res = []\\n        for i in range(len(input)):\\n            if input[i] in \"-+*\":\\n                left = self.diffWaysToCompute(input[:i])\\n                right = self.diffWaysToCompute(input[i+1:])\\n                for l in left:\\n                    for r in right:\\n                        if input[i] == \\'+\\':\\n                            res.append(l+r)\\n                        elif input[i] == \\'-\\':\\n                            res.append(l-r)\\n                        elif input[i] == \\'*\\':\\n                            res.append(l*r)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1416812,
                "title": "java-dfs-memoization-explanation",
                "content": "Idea:\\n* Base case: If the expression has no symbol, i.e. its a number, then there\\'s nothing to do. Just add to result.\\n* Recursive case: Split the expression at every symbol and evaluate the parts recursively. \\n\\t* Why split at every symbol? Because its analogous to adding parantheses. e.g. 1 + 2 * 3 \\n\\t\\t* when split at `+`, parts are 1 and 2 * 3 which can be written as 1 + (2 * 3)\\n\\t\\t* when split at `*`, parts are 1 + 2 and 3 which can be written as (1 + 2) * 3\\n* Its possible to be repeat computing an expression, hence inject memoization into brute force DFS.\\n **T/S:** O(n2\\u207F)/O(2\\u207F) (for interviews). Actual bigOs explained [here](https://leetcode.com/problems/generate-parentheses/discuss/10099/Time-complexity-to-generate-all-combinations-of-well-formed-parentheses.)\\n\\n![image](https://assets.leetcode.com/users/images/8cf76c36-6a05-4eaf-88b5-b0f073a35035_1629583948.022777.png)\\n```\\npublic List<Integer> diffWaysToCompute(String expression) {\\n\\treturn diffWaysToCompute(expression, new HashMap<>());\\n}\\n\\nprivate List<Integer> diffWaysToCompute(String expression, Map<String, List<Integer>> memo) {\\n\\tif (memo.containsKey(expression))\\n\\t\\treturn memo.get(expression);\\n\\tvar values = new ArrayList<Integer>();\\n\\n\\tif (!hasOperator(expression))\\n\\t\\tvalues.add(Integer.parseInt(expression));\\n\\telse\\n\\t\\tfor (var i = 0; i < expression.length(); i++) {\\n\\t\\t\\tvar symbol = expression.charAt(i);\\n\\t\\t\\tif (!Character.isDigit(symbol)) {\\n\\t\\t\\t\\tvar leftParts = diffWaysToCompute(expression.substring(0, i), memo);\\n\\t\\t\\t\\tvar rightParts = diffWaysToCompute(expression.substring(i + 1), memo);\\n\\n\\t\\t\\t\\tfor (var l : leftParts)\\n\\t\\t\\t\\t\\tfor (var r : rightParts)\\n\\t\\t\\t\\t\\t\\tswitch (symbol) {\\n\\t\\t\\t\\t\\t\\t\\tcase \\'+\\' -> values.add(l + r);\\n\\t\\t\\t\\t\\t\\t\\tcase \\'-\\' -> values.add(l - r);\\n\\t\\t\\t\\t\\t\\t\\tcase \\'*\\' -> values.add(l * r);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\treturn memo.compute(expression, (k,v) -> values);\\n}\\n\\nprivate boolean hasOperator(String expression) {\\n\\tfor (var i = 0; i < expression.length(); i++)\\n\\t\\tswitch (expression.charAt(i)) {\\n\\t\\t\\tcase \\'+\\', \\'-\\', \\'*\\' -> {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn false;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\npublic List<Integer> diffWaysToCompute(String expression) {\\n\\treturn diffWaysToCompute(expression, new HashMap<>());\\n}\\n\\nprivate List<Integer> diffWaysToCompute(String expression, Map<String, List<Integer>> memo) {\\n\\tif (memo.containsKey(expression))\\n\\t\\treturn memo.get(expression);\\n\\tvar values = new ArrayList<Integer>();\\n\\n\\tif (!hasOperator(expression))\\n\\t\\tvalues.add(Integer.parseInt(expression));\\n\\telse\\n\\t\\tfor (var i = 0; i < expression.length(); i++) {\\n\\t\\t\\tvar symbol = expression.charAt(i);\\n\\t\\t\\tif (!Character.isDigit(symbol)) {\\n\\t\\t\\t\\tvar leftParts = diffWaysToCompute(expression.substring(0, i), memo);\\n\\t\\t\\t\\tvar rightParts = diffWaysToCompute(expression.substring(i + 1), memo);\\n\\n\\t\\t\\t\\tfor (var l : leftParts)\\n\\t\\t\\t\\t\\tfor (var r : rightParts)\\n\\t\\t\\t\\t\\t\\tswitch (symbol) {\\n\\t\\t\\t\\t\\t\\t\\tcase \\'+\\' -> values.add(l + r);\\n\\t\\t\\t\\t\\t\\t\\tcase \\'-\\' -> values.add(l - r);\\n\\t\\t\\t\\t\\t\\t\\tcase \\'*\\' -> values.add(l * r);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\treturn memo.compute(expression, (k,v) -> values);\\n}\\n\\nprivate boolean hasOperator(String expression) {\\n\\tfor (var i = 0; i < expression.length(); i++)\\n\\t\\tswitch (expression.charAt(i)) {\\n\\t\\t\\tcase \\'+\\', \\'-\\', \\'*\\' -> {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866096,
                "title": "python-divde-and-conquer-memoization-o-n-2-n",
                "content": "Hello,\\n\\nThe time complexity analysis is below.\\n\\n```python\\n\\ndef __init__(self):\\n\\tself.operation = {}\\n\\tself.operation[\\'*\\'] = lambda a, b: a * b\\n\\tself.operation[\\'+\\'] = lambda a, b: a + b\\n\\tself.operation[\\'-\\'] = lambda a, b: a - b\\n\\ndef diffWaysToCompute(self, expression: str) -> List[int]:\\n\\n\\tmemo = {}\\n\\treturn self.evaluate_expression(expression, {})\\n\\ndef evaluate_expression(self, expression: str, memo: dict) -> List[int]:\\n\\n\\tif expression in memo:\\n\\t\\treturn memo[expression]\\n\\n\\telif expression.isnumeric():\\n\\t\\treturn [int(expression)]\\n\\n\\tresults = []\\n\\tfor i in range(len(expression)):\\n\\t\\tif expression[i] not in self.operation:\\n\\t\\t\\tcontinue\\n\\n\\t\\topr = expression[i]\\n\\n\\t\\t# Divide:\\n\\t\\tleft_results = self.diffWaysToCompute(expression[0:i])\\n\\t\\tright_results = self.diffWaysToCompute(expression[i+1:])\\n\\n\\t\\tfor left in left_results: # Conquer:\\n\\t\\t\\tfor right in right_results:\\n\\t\\t\\t\\tresults.append(self.operation[opr](left, right))\\n\\n\\tmemo[expression] = results\\n\\n\\treturn results\\n\\t\\t\\n```\\n\\n- Time Complexity: `O(N * 2^N)`\\n\\t- Let `N` be the length of the expression\\n\\t- In the worst case there are  `N // 2` operations: when all expression numbers are numbers of 1 digits\\n\\t\\t- For example, `expression: 1+2+3+4+5+6`\\n\\t\\t- `len(expression) = 11`\\n\\t\\t- `operations # = 5`\\n\\t- Therefore, our recursion depth is O(`N/2`)\\n\\t```\\n\\t\\t\\tdepth         Nbr of problem           work at corresponding depth\\n\\t\\t\\t0             1                        O(N) #divide expression\\n\\t\\t\\t1             2                        O(1) + O(N - 2) = O(N) * 2\\n\\t\\t\\t...\\n\\t\\t\\ti             2^i                      O(N) * 2^i \\n\\t\\t\\t...\\n\\t\\t\\tN//2          2^N//2                   O(N) * 2^N//2\\n\\n\\t\\t\\tTotal time complexity: O(N) (2^0 + 2^1 + ... + 2^N//2) = O(N * 2^N//2) = O(N * 2^N)\\n\\t\\t    \\n\\t```\\n\\t\\nFinal notes:\\n\\t- This problem is similar to [22. Generate Parentheses](https://leetcode.com/problems/generate-parentheses/) problem\\n\\t- Check its [solution](https://leetcode.com/problems/generate-parentheses/solution/) for more accurate time complexity\\n\\t\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer",
                    "Memoization"
                ],
                "code": "```python\\n\\ndef __init__(self):\\n\\tself.operation = {}\\n\\tself.operation[\\'*\\'] = lambda a, b: a * b\\n\\tself.operation[\\'+\\'] = lambda a, b: a + b\\n\\tself.operation[\\'-\\'] = lambda a, b: a - b\\n\\ndef diffWaysToCompute(self, expression: str) -> List[int]:\\n\\n\\tmemo = {}\\n\\treturn self.evaluate_expression(expression, {})\\n\\ndef evaluate_expression(self, expression: str, memo: dict) -> List[int]:\\n\\n\\tif expression in memo:\\n\\t\\treturn memo[expression]\\n\\n\\telif expression.isnumeric():\\n\\t\\treturn [int(expression)]\\n\\n\\tresults = []\\n\\tfor i in range(len(expression)):\\n\\t\\tif expression[i] not in self.operation:\\n\\t\\t\\tcontinue\\n\\n\\t\\topr = expression[i]\\n\\n\\t\\t# Divide:\\n\\t\\tleft_results = self.diffWaysToCompute(expression[0:i])\\n\\t\\tright_results = self.diffWaysToCompute(expression[i+1:])\\n\\n\\t\\tfor left in left_results: # Conquer:\\n\\t\\t\\tfor right in right_results:\\n\\t\\t\\t\\tresults.append(self.operation[opr](left, right))\\n\\n\\tmemo[expression] = results\\n\\n\\treturn results\\n\\t\\t\\n```\n```\\n\\t\\t\\tdepth         Nbr of problem           work at corresponding depth\\n\\t\\t\\t0             1                        O(N) #divide expression\\n\\t\\t\\t1             2                        O(1) + O(N - 2) = O(N) * 2\\n\\t\\t\\t...\\n\\t\\t\\ti             2^i                      O(N) * 2^i \\n\\t\\t\\t...\\n\\t\\t\\tN//2          2^N//2                   O(N) * 2^N//2\\n\\n\\t\\t\\tTotal time complexity: O(N) (2^0 + 2^1 + ... + 2^N//2) = O(N * 2^N//2) = O(N * 2^N)\\n\\t\\t    \\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 66395,
                "title": "java-recursive-solution-with-memorization",
                "content": "    public class Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        //cache for memorization\\n        HashMap<String,List<Integer>> cache = new HashMap<String,List<Integer>>();\\n        return this.helper(input,cache);\\n    }\\n    \\n    List<Integer>helper(String s, HashMap<String,List<Integer>> cache) {\\n        if (cache.get(s)!=null) {\\n            return cache.get(s);\\n        }\\n        boolean expression = false;\\n        ArrayList<Integer> result = new ArrayList<Integer>();\\n        for(int i=0; i<s.length(); i++) {\\n            if(\"+-*\".indexOf(s.charAt(i))!=-1) {\\n                List<Integer> left = helper(s.substring(0,i),cache);\\n                List<Integer> right = helper(s.substring(i+1),cache);\\n                for(Integer l: left) {\\n                    for(Integer r: right) {\\n                        result.add(cal(l,r,s.charAt(i)));\\n                    }\\n                }\\n                expression = true;\\n            }\\n        }\\n        if (!expression) {\\n            result.add(Integer.parseInt(s));\\n        }\\n        cache.put(s, result);\\n        return result;\\n    }\\n    int cal(int l, int r, char op) {\\n        int result = 0;\\n        switch (op) {\\n            case '+': result= l+r; break;\\n            case '-': result = l-r; break;\\n            case '*': result= l*r; break;\\n            default: break;\\n        }\\n        return result;\\n    }\\n    }\\n\\nWe first split the string by operators and recursively calculate left and right side, then combine the result. The only improvement is to use memorization to cache previously calculated expressions.",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        //cache for memorization\\n        HashMap<String,List<Integer>> cache = new HashMap<String,List<Integer>>();\\n        return this.helper(input,cache);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 66329,
                "title": "java-simple-solution-beats-95",
                "content": "    public class Solution {\\n        Map<String, List<Integer>> map = new HashMap<>();\\n        public List<Integer> diffWaysToCompute(String input) {\\n            if(map.containsKey(input))\\n                return map.get(input);\\n            List<Integer> res = new ArrayList<>();\\n            for(int i=0;i<input.length();++i){\\n                char c=input.charAt(i);\\n                if(c=='+'|| c=='-' || c=='*'){\\n                    List<Integer> list1 = diffWaysToCompute(input.substring(0,i));\\n                    List<Integer> list2 = diffWaysToCompute(input.substring(i+1));\\n                    for(int v1:list1){\\n                        for(int v2: list2){\\n                            if(c=='+')\\n                                res.add(v1+v2);\\n                            if(c=='-')\\n                                res.add(v1-v2);\\n                            if(c=='*')\\n                                res.add(v1*v2);\\n                        }\\n                    }\\n                }\\n            }\\n            if(res.isEmpty())\\n                res.add(Integer.parseInt(input));\\n            map.put(input, res);\\n            return res;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        Map<String, List<Integer>> map = new HashMap<>();\\n        public List<Integer> diffWaysToCompute(String input) {\\n            if(map.containsKey(input))\\n                return map.get(input);\\n            List<Integer> res = new ArrayList<>();\\n            for(int i=0;i<input.length();++i){\\n                char c=input.charAt(i);\\n                if(c=='+'|| c=='-' || c=='*'){\\n                    List<Integer> list1 = diffWaysToCompute(input.substring(0,i));\\n                    List<Integer> list2 = diffWaysToCompute(input.substring(i+1));\\n                    for(int v1:list1){\\n                        for(int v2: list2){\\n                            if(c=='+')\\n                                res.add(v1+v2);\\n                            if(c=='-')\\n                                res.add(v1-v2);\\n                            if(c=='*')\\n                                res.add(v1*v2);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 66396,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "    class Solution {\\n    public:\\n        vector<int> diffWaysToCompute(string input) {\\n            int size=input.size();\\n            vector<int> result;\\n            for(int i=0; i<size; i++){\\n                if(ispunct(input[i])){\\n                    for(int a : diffWaysToCompute(input.substr(0, i)))\\n                        for(int b : diffWaysToCompute(input.substr(i+1))){\\n                            if(input[i]=='+')  result.push_back(a+b);\\n                            if(input[i]=='-')  result.push_back(a-b);\\n                            if(input[i]=='*')  result.push_back(a*b);\\n                        }\\n                }\\n            }\\n            /*** the base case is that there are no operator-char ***/\\n            /*** we return vector<int>{stoi(input)} when this happens ***/\\n            return result.size() ? result : vector<int>{stoi(input)};\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> diffWaysToCompute(string input) {\\n            int size=input.size();\\n            vector<int> result;\\n            for(int i=0; i<size; i++){\\n                if(ispunct(input[i])){\\n                    for(int a : diffWaysToCompute(input.substr(0, i)))\\n                        for(int b : diffWaysToCompute(input.substr(i+1))){\\n                            if(input[i]=='+')  result.push_back(a+b);\\n                            if(input[i]=='-')  result.push_back(a-b);\\n                            if(input[i]=='*')  result.push_back(a*b);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 66351,
                "title": "c-solution-using-dp-easy-understanding",
                "content": "  \\n\\n    vector<int> diffWaysToCompute(string input) {\\n       vector<int> data;\\n       vector<char> ops;\\n      int num = 0;\\n      char op = ' ';\\n       istringstream ss(input + \"+\");\\n       while(ss >> num && ss >> op) {\\n           data.push_back(num);\\n           ops.push_back(op);\\n       }\\n       const int size_i = data.size();\\n        vector<vector<vector<int>>> dp(size_i, vector<vector<int>>(size_i, vector<int>()));\\n        for (int i = 0; i < size_i; i += 1)\\n         for (int j = i; j >= 0; j -= 1) {\\n             if (i == j) {dp[j][i].push_back(data[i]); continue;}\\n             for (int k = j; k < i; k += 1) {\\n                 for (auto left : dp[j][k]) \\n                   for (auto right : dp[k+1][i]) {\\n                       int val = 0;\\n                       switch(ops[k]) {\\n                           case '+': val = left + right; break;\\n                           case '-': val = left - right; break;\\n                           case '*': val = left * right; break;\\n                       }\\n                       dp[j][i].push_back(val);\\n                   }\\n             }\\n         }\\n       return dp[0][size_i-1];\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "  \\n\\n    vector<int> diffWaysToCompute(string input) {\\n       vector<int> data;\\n       vector<char> ops;\\n      int num = 0;\\n      char op = ' ';\\n       istringstream ss(input + \"+\");\\n       while(ss >> num && ss >> op) {\\n           data.push_back(num);\\n           ops.push_back(op);\\n       }\\n       const int size_i = data.size();\\n        vector<vector<vector<int>>> dp(size_i, vector<vector<int>>(size_i, vector<int>()));\\n        for (int i = 0; i < size_i; i += 1)\\n         for (int j = i; j >= 0; j -= 1) {\\n             if (i == j) {dp[j][i].push_back(data[i]); continue;}\\n             for (int k = j; k < i; k += 1) {\\n                 for (auto left : dp[j][k]) \\n                   for (auto right : dp[k+1][i]) {\\n                       int val = 0;\\n                       switch(ops[k]) {\\n                           case '+': val = left + right; break;\\n                           case '-': val = left - right; break;\\n                           case '*': val = left * right; break;\\n                       }\\n                       dp[j][i].push_back(val);\\n                   }\\n             }\\n         }\\n       return dp[0][size_i-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2369098,
                "title": "divide-and-conquer-solution-with-image-explanation-illustration-in-c",
                "content": "For explanation to a bunch of selected leetcode problems - https://github.com/vaibhavpandeyprayag/cp-dsa (work in progress)\\n\\n# 241. Different Ways To Add Parentheses (medium)\\n\\n_Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\\nThe test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 10<sup>4</sup>._\\n\\n### **Constraints:**\\n\\n_1 <= expression.length <= 20  \\nExpression consists of digits and the operator \\'+\\', \\'-\\', and \\'\\\\*\\'.  \\nAll the integer values in the input expression are in the range [0, 99]._\\n\\n### **Testcases:**\\n\\nExample 1:\\n\\n- Input: expression = \"2-1-1\"  \\n  Output: [0,2]  \\n  Explanation:  \\n  ((2-1)-1) = 0  \\n  (2-(1-1)) = 2\\n\\nExample 2:\\n\\n- Input: expression = \"2\\\\*3-4\\\\*5\"  \\n  Output: [-34,-14,-10,-10,10]  \\n  Explanation:  \\n  (2*(3-(4\\\\*5))) = -34  \\n  ((2*3)-(4\\\\*5)) = -14  \\n  ((2\\\\*(3-4))\\\\*5) = -10  \\n  (2\\\\*((3-4)\\\\*5)) = -10  \\n  (((2\\\\*3)-4)\\\\*5) = 10\\n\\n## Approach:\\n\\nAccording to _BODMAS_, parentheses (or brackets) mean that some operations have higher priority than others. e.g. **_(a \\\\* (b - c))_** implies that subtraction needs to be done first and then the difference is multiplied with **_a_**. Whereas **_((a \\\\* b) - c)_** implies that the multiplication will take place first and then **_c_** will be subtracted from the product. Different occurrences of parentheses can set different priorities.\\n\\nAn important observation here is that parentheses can change priorities only when used around operators. If we have a simple expression like **(2 - 4 \\\\* 1 + 8)**. Iterating from the beginning ->\\n\\n**(2 - (4 \\\\* 1 + 8))** is now serated into 2 parts around minus sign. We can recursively iterate over both the separated part two set parentheses.\\n\\n**(2 - ((4 \\\\* 1) + 8))** gives ans = **-10**  \\nreturning to previous recursion call and setting parentheses around another operator  \\n**(2 - (4 \\\\* (1 + 8)))** gives ans = **-34**  \\nreturning to previous recursion call and doing the same thing  \\n**((2 - 4) \\\\* (1 + 8))** ...  \\n**((2 - 4 \\\\* 1) + 8)** ...\\n\\nSo we iterate the expression from left side  \\nwhenever an operator is encountered, the expression is recusively divided around the operator into 2 sub-expressions (sub-expression **left** and sub-expression **right**). This recursive division occurs until **left** and **right** both have only single number (i.e. no operator). All answers from a particular sub-expressions are returned in a list called **result**. The **result** of left sub-expression is returned in **left** and so is the case with **right**. Then all the answers from **left** and **right** are iterated and are operated upon.\\n\\nThe approach is known as **_\"Divide and Conquer\"_**. The problem is divided into subproblems, and those subproblems are further divided into sub-problems. The solution to subproblems helps to find solution for parent problem. If some subproblems are repeated, we can memoize solution to every subproblem and use it whenever the same subproblem reoccurs. This method is called **_Dynamic Programming_**.\\n\\n![image](https://assets.leetcode.com/users/images/e4b07063-d5b7-4244-b972-b62684c058b2_1659440138.4830947.jpeg)\\n\\n\\n## Code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int operate(int x, int y, char op) {\\n        if(op == \\'+\\') return x + y;\\n        if(op == \\'-\\') return x - y;\\n        if(op == \\'*\\') return x * y;\\n        return 0;\\n    }\\n\\n    vector<int> diffWaysToCompute(string expression) {\\n        vector<int> results;\\n        bool isEntirelyNumber = true;\\n\\n        for (int i = 0; i < expression.length(); i++) {\\n            if (!isdigit(expression[i])) {\\n                isEntirelyNumber = false;\\n\\n                vector<int> left = diffWaysToCompute(expression.substr(0, i));\\n                vector<int> right = diffWaysToCompute(expression.substr(i + 1, expression.length()));\\n\\n                for (int x: left) {\\n                    for (int y: right) results.push_back(operate(x, y, expression[i]));\\n                }\\n            }\\n        }\\n\\n        if (isEntirelyNumber) results.push_back(stoi(expression));\\n        return results;\\n    }\\n};\\n```\\n\\n##### ***Kindly upvote the post if you found it useful. Thanks!***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int operate(int x, int y, char op) {\\n        if(op == \\'+\\') return x + y;\\n        if(op == \\'-\\') return x - y;\\n        if(op == \\'*\\') return x * y;\\n        return 0;\\n    }\\n\\n    vector<int> diffWaysToCompute(string expression) {\\n        vector<int> results;\\n        bool isEntirelyNumber = true;\\n\\n        for (int i = 0; i < expression.length(); i++) {\\n            if (!isdigit(expression[i])) {\\n                isEntirelyNumber = false;\\n\\n                vector<int> left = diffWaysToCompute(expression.substr(0, i));\\n                vector<int> right = diffWaysToCompute(expression.substr(i + 1, expression.length()));\\n\\n                for (int x: left) {\\n                    for (int y: right) results.push_back(operate(x, y, expression[i]));\\n                }\\n            }\\n        }\\n\\n        if (isEntirelyNumber) results.push_back(stoi(expression));\\n        return results;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953893,
                "title": "c-100-divide-conquer-dp-simplified-fast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    map<string,vector<int>> memo;\\n    vector<int> diffWaysToCompute(string input) {\\n        if(memo.find(input) != memo.end()) return memo[input]; \\n        vector<int> left, right, res;\\n        for(int i=0;i<input.size();++i){\\n            if(input[i] == \\'+\\' || input[i] == \\'-\\' || input[i] == \\'*\\'){\\n                string inl = input.substr(0,i);\\n                string inr = input.substr(i+1);\\n                left = diffWaysToCompute(inl);\\n                right = diffWaysToCompute(inr);\\n            }\\n            for(int a:left){\\n                for(int b:right){\\n                    if(input[i] == \\'+\\')\\n                        res.push_back(a+b);\\n                    else if(input[i] == \\'-\\')\\n                        res.push_back(a-b);\\n                    else if(input[i] == \\'*\\')\\n                        res.push_back(a*b);\\n                }\\n            }\\n        }\\n        if(!res.size()) res.push_back(stoi(input));\\n        return memo[input] = res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Divide and Conquer",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<string,vector<int>> memo;\\n    vector<int> diffWaysToCompute(string input) {\\n        if(memo.find(input) != memo.end()) return memo[input]; \\n        vector<int> left, right, res;\\n        for(int i=0;i<input.size();++i){\\n            if(input[i] == \\'+\\' || input[i] == \\'-\\' || input[i] == \\'*\\'){\\n                string inl = input.substr(0,i);\\n                string inr = input.substr(i+1);\\n                left = diffWaysToCompute(inl);\\n                right = diffWaysToCompute(inr);\\n            }\\n            for(int a:left){\\n                for(int b:right){\\n                    if(input[i] == \\'+\\')\\n                        res.push_back(a+b);\\n                    else if(input[i] == \\'-\\')\\n                        res.push_back(a-b);\\n                    else if(input[i] == \\'*\\')\\n                        res.push_back(a*b);\\n                }\\n            }\\n        }\\n        if(!res.size()) res.push_back(stoi(input));\\n        return memo[input] = res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66415,
                "title": "14-line-c-solution",
                "content": "    class Solution {\\n    public:\\n        \\n        vector<int> diffWaysToCompute(string input) {\\n            vector<int> ans;\\n            bool pureNum=true;\\n            for (int i=0; i<input.length(); i++) \\n                if (input[i]<'0' || input[i]>'9') {\\n                    pureNum=false;\\n                    vector<int> L=diffWaysToCompute(input.substr(0, i)), R=diffWaysToCompute(input.substr(i+1, input.length()-i-1));\\n                    for (auto l : L)\\n                        for (auto r : R)\\n                            if (input[i]=='+') ans.push_back(l+r);\\n                            else if (input[i]=='-') ans.push_back(l-r);\\n                            else if (input[i]=='*') ans.push_back(l*r);\\n                }\\n            \\n            if (pureNum)\\n                ans.push_back(atoi(input.c_str()));\\n            return ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        \\n        vector<int> diffWaysToCompute(string input) {\\n            vector<int> ans;\\n            bool pureNum=true;\\n            for (int i=0; i<input.length(); i++) \\n                if (input[i]<'0' || input[i]>'9') {\\n                    pureNum=false;\\n                    vector<int> L=diffWaysToCompute(input.substr(0, i)), R=diffWaysToCompute(input.substr(i+1, input.length()-i-1));\\n                    for (auto l : L)\\n                        for (auto r : R)\\n                            if (input[i]=='+') ans.push_back(l+r);\\n                            else if (input[i]=='-') ans.push_back(l-r);\\n                            else if (input[i]=='*') ans.push_back(l*r);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1191840,
                "title": "java-recursion-visualization",
                "content": "This problem can be solved using divide and conquer stratergy ,\\n\\nAlgorithm- \\n* Traverse the expression \\n* If at index i , expression contains one of the operators (*,-,+) then\\n* divide into two parts \\n\\tResult left = left(0....i-1 ) and,\\n\\tResult right = right(i+1...end)\\nthese two parts will return results of sub-expression i.e results from substring(0,i-1) and (i+1,end ) respectively\\n* Since at index i we have an operator , we apply that operation for each element in left to each element in right\\n\\nreturn the result\\n\\nRecursion Virtualization\\n![image](https://assets.leetcode.com/users/images/8ba79438-3cc4-4cc2-9140-ecff38e880bf_1620249071.8789997.gif)\\n\\n\\nRecursion Tree with returned values\\n![image](https://assets.leetcode.com/users/images/037c58f6-01ed-449b-b5ae-d1d13afaa442_1620249065.3851764.png)\\n\\n```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String expression) {\\n        List<Integer> result = new ArrayList();\\n        for( int i = 0 ; i< expression.length() ;i++ )\\n        {\\n            char ch = expression.charAt(i);\\n            if( ch == \\'*\\' || ch ==\\'+\\' || ch ==\\'-\\')\\n            {\\n                List<Integer> left = diffWaysToCompute( expression.substring(0,i));\\n                List<Integer> right = diffWaysToCompute( expression.substring(i+1));\\n                for( int l :  left )\\n                {\\n                    for( int r : right )\\n                    {\\n                        switch( ch )\\n                        {\\n                            case \\'+\\':result.add( l + r);\\n                                    break;\\n                            case \\'-\\':result.add( l-r);\\n                                    break;\\n                            case \\'*\\':result.add(l*r);\\n                                    break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    if( result.size() == 0 )\\n         result.add( Integer.parseInt( expression ) );\\n    //System.out.println( expression + \" \" + result.toString    () );\\n    return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String expression) {\\n        List<Integer> result = new ArrayList();\\n        for( int i = 0 ; i< expression.length() ;i++ )\\n        {\\n            char ch = expression.charAt(i);\\n            if( ch == \\'*\\' || ch ==\\'+\\' || ch ==\\'-\\')\\n            {\\n                List<Integer> left = diffWaysToCompute( expression.substring(0,i));\\n                List<Integer> right = diffWaysToCompute( expression.substring(i+1));\\n                for( int l :  left )\\n                {\\n                    for( int r : right )\\n                    {\\n                        switch( ch )\\n                        {\\n                            case \\'+\\':result.add( l + r);\\n                                    break;\\n                            case \\'-\\':result.add( l-r);\\n                                    break;\\n                            case \\'*\\':result.add(l*r);\\n                                    break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    if( result.size() == 0 )\\n         result.add( Integer.parseInt( expression ) );\\n    //System.out.println( expression + \" \" + result.toString    () );\\n    return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857957,
                "title": "c-clean-code-with-explanation",
                "content": "Example:2x3-4x5 can be divide into left and right two parts:\\nfunction f = diffWaysToCompute\\n***This is how this program compute final result!***\\n f(2) x f(3-4x5) **U** f(2x3) - f(4x5) **U** f(2x3-4) x f(5)\\n however, f(3-4x5) = f(3) - f(4x5) **U** f(3-4) x f(5) = {-17,-5}\\n                f(2x3-4) = f(2) x f(3-4) **U** f(2x3) - f(4) = {-2,2}\\n so we can get\\n f(2) x f(3-4x5) **U** f(2x3) - f(4x5) **U** f(2x3-4) x f(5) equal\\n {2}x{-17,-5} **U** {6} - {20} **U** {-2,2} x {5} = {-34, -10, -14, -10, 10}\\n \\n```\\nclass Solution{\\npublic:\\n    vector<int> diffWaysToCompute(string input) {\\n        vector<int> res;  // equal to this { } symbol functionality\\n        for(int i=0; i<input.length(); i++){\\n            if(input[i]==\\'+\\'||input[i]==\\'-\\'||input[i]==\\'*\\'){\\n                vector<int> left = diffWaysToCompute(input.substr(0,i));    //divide to two parts \\n                vector<int> right = diffWaysToCompute(input.substr(i+1));\\n                for(int j=0; j<left.size(); j++){\\n                    for(int k=0; k<right.size(); k++){\\n                        if(input[i] == \\'+\\'){\\n                            res.push_back(left[j]+right[k]);\\n                        }\\n                        else if(input[i] == \\'-\\'){\\n                            res.push_back(left[j]-right[k]);\\n                        }\\n                        else{\\n                            res.push_back(left[j]*right[k]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(res.empty()){  //if input only has one number character ex. f(5)\\n            res.push_back(stoi(input));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    vector<int> diffWaysToCompute(string input) {\\n        vector<int> res;  // equal to this { } symbol functionality\\n        for(int i=0; i<input.length(); i++){\\n            if(input[i]==\\'+\\'||input[i]==\\'-\\'||input[i]==\\'*\\'){\\n                vector<int> left = diffWaysToCompute(input.substr(0,i));    //divide to two parts \\n                vector<int> right = diffWaysToCompute(input.substr(i+1));\\n                for(int j=0; j<left.size(); j++){\\n                    for(int k=0; k<right.size(); k++){\\n                        if(input[i] == \\'+\\'){\\n                            res.push_back(left[j]+right[k]);\\n                        }\\n                        else if(input[i] == \\'-\\'){\\n                            res.push_back(left[j]-right[k]);\\n                        }\\n                        else{\\n                            res.push_back(left[j]*right[k]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(res.empty()){  //if input only has one number character ex. f(5)\\n            res.push_back(stoi(input));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 718559,
                "title": "python3-solution-with-detailed-explanation",
                "content": "First note: When students are learning to code in early days, you know what instructors tell them??? To add comments to your code so that it\\'s easier for others to read/follow. I think a lot of people here missed that session of  coding 101 class!!! :D :D \\n\\nI\\'m using [@caikehe](https://leetcode.com/problems/different-ways-to-add-parentheses/discuss/66419/Python-easy-to-understand-solution-(divide-and-conquer).) code. \\n\\nYou might ask what is the high level idea? Let\\' check some cases first to see if they\\'re valid operations! can we do `5 - - 1` or `5 - 1 + + 3` or `4 + 4 - * 3`? No, right? We need to have something like ` 5  + 5` or ` 5 - 3` or `3 * 5` in the most basic cases, true? That\\'s what we\\'ll do. We try to break down the string to building components and build our way up to get to the final result. This is what the `helper` function is trying to do. If you check this function, you\\'ll see it\\'s doing the most basic operations (meaning `-` or `+` or `*`) given two numbers `m` and `n`. Can you do any other operation than ` m + n` if you\\'re given `m`, `n`, `+`? or other than `m * n` if you\\'re given `m`, `n` and `*`? No, right? You get the idea. So if we knew two numbers and one operator, `helper` function would give us the only possible operation. \\n\\nHowever, we are given a string of numbers and operators, something like `input = \\'2-1-1\\'` (example provided in the problem statement).  The combinations are `((2-1)-1) = 0 ` and `(2-(1-1)) = 2`. Let\\'s focus on the first combination.  `((2-1)-1) = 0 `  has two components `a = (2-1)` and  `(a - 1)`. `a` is a number, 1. If you check the first component (`(2-1)`), this is a base case that can be handled by `helper` function, right? If you get this, what will remain? The second component which is the first one minus `1`, right? What is this now? Another base component, true? Again, `helper` will be able to handle it. Do you see where I\\'m going with this? Let\\'s say you have `input =  \"2*3-4*5\"`. If you could break it to a base case (meaning `m`, `n` and and operator), then you\\'re done. Does this make sense? \\n\\nWhatever I mentioned in the previous paragraph was for a specific arrangement of parantheses, right? For example if we had `(2*(3-(4*5)))`, we would first go and take care of `(4*5)` using `helper` function. Let\\'s call it `a` again. `a = (4*5) = 20`. Now, `(2(3-(4*5))) = (2(3-a))`. Then, let\\'s take care of `(3-a)` using `helper` function because it\\'s two numbers and one operator. Let\\'s call it `b`. So, `b = (3-a) = -17`. Finally, `(2*b)`!!! Again, a base case  that can be handled by `helper` function. You got it, right? Good!\\n\\nNow, we could generate all valid arrangement of parantheses (come up with multiple equations) and break each equation to base cases and we\\'ll be done. Here comes the divide and conquer-style part of the solution, where you traverse through the input (`#4`) and do some stuff whenever you reach to an operator (`+-*`, line `#5`). This is the place that we\\'re putting virtual paranthesis (we don\\'t need to actually add paranthesis to string or anything like that) to do the grouping of numbers and operators. The **key point** of this solution is that operators are the places you want have a `)` before and a `(` after. Think about it!!! If `input = \"(2*3-4*5)\"`, you traverse in the string, you get to the first `*`. What do you do? You add one paranthesis before `)*` and one paranthesis after `*(`, which gives you `\"(2)*(3-4*5)\"`. Lines `#6` and `#7` take care of each part separately, namely line `#6` takes `(2)` and line `#7` takes `(3-4*5)`. Note than index `i` in the `for` loop corresponds to the operator (here `*`) and we don\\'t include the operator itself since an operator cannot be the first element of a string nor can it be the last element of the string, i.e. having `(2*)` or `*(3-4*5)` is not valid. What happens next? The first component (`(2)`) doesn\\'t need any extra calculation and it can be a `m` for `helper` function. So, it will need a `n` and an operator. However, second component (`(3-4*5)`) (I call these two first level components)  is not totally broken down yet, that\\'s why we cannot move to line `#8`, YET!\\n\\n\\nTo wrap up so far in case it\\'s not fully clear! First component (`(2)`) is taken by line `#6` which runs the `diffWaysToCompute` function again from start. What is line `#1`? It asks if the input is all digits, which is the case for the rhis component (`(2)`), right? Therefore, it returns `2` in line `#2`, correct? This makes `res1` to be `2`. For the second components, however, line `#7` takes `(3-4*5)` as `input`. This causes to run `diffWaysToCompute` function again, this time line `#1` condition is not satisfied since the string include operators and not just digits. So, it goes to line `#4` to traverse through the string and get stuck again in an operator, this time at `-`. The new two components (*I call these two second level components*) would be `(3)` and `(4*5)`. First one would be similar to `(2)` as explained before. The second component is a base case that can be handled by  `helper` function and is taken to the function of line `#7` for further process. Line `#7` executes the `diffWaysToCompute` for `input = (4*5)`, which results in `res1 = 4` and `res2 = 5`, right? (We\\'re on the third level now). \\n\\n\\n```\\nclass Solution(object):\\n\\n    def diffWaysToCompute(self, input):\\n        \"\"\"\\n        :type input: str\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        if input.isdigit(): #1\\n            return [int(input)] #2\\n        res = [] #3\\n        for i in xrange(len(input)): #4\\n            if input[i] in \"-+*\": #5\\n                res1 = self.diffWaysToCompute(input[:i]) #6\\n                res2 = self.diffWaysToCompute(input[i+1:]) #7\\n                for j in res1:#8\\n                    for k in res2: #9\\n                        res.append(self.helper(j, k, input[i])) #10\\n        return res #11\\n    \\n    def helper(self, m, n, op): #12\\n        if op == \"+\": #13\\n            return m+n #14\\n        elif op == \"-\": #15\\n            return m-n #16\\n        else: #17\\n            return m*n #18\\n```\\n\\n\\n\\nNow, after breaking down to the lowest level (in this case third level components), we move forward with the code to line `#8`. Remember that for the third level components, `res1 = 4` and `res2 = 5`, right? We do two nested loops in lines `#8` and `#9` to traverse through both `res1` and `res2` (remember that each level has its own `res1` and `res2`. Now we\\'re at level three). After the nested loops, we go to line `#10` where we call the `helper` function. This function needs three inputs. First one is the number  of `res1`, the second is the number of `res2` and the third is the operator that helped us to break the input into two components to pass to line `#6` and `#7`, right? The operator is `*` in this level. Therefore, the `helper` function is called in line `#10` with `j = 4`, `k = 5`, and `input[i] = *`. Lines `#12` to `#18` take care of this. Here, it\\'s a `*` which is handled by line `#17` and `#18`. So, this function returns 20. This is the ouput of level three. We go one level up to level two. With `res1 = 3` and `res2 = 20` (remember `res2` comes from third level). We call the `helper` function again with these values and the operator to be `-`, right? This gives up `-17` as the output of level two. We go one level up to level one where `res1 = 2` and `res2 = -17` with `*` as operator. `helper` function would return `-34` for this case. Makes sense? No? Please read again and if it\\'s still not clear, let me know if the comments which part is not clear. \\n\\n\\nWe covered just one case of parantheses arrangement, `(2*(3-(4*5)))`. Now what? We covered the first encounter of an operator in line `#4`, the `for` loop would move forward to until it gets to the next operator. Remember that whatever we\\'ve talked about so far was for the case where the `for` loop arrived at the first operator `*`, and in the second level, got stuck at `-` operator. Now, if in the second level, it arrives to the second `*`, we recover the case of `(2*((3-4)*5)) = -10 `. Note that both of these cases have the number `2` separated from the rest of the string. Next, the `for` loop moves back to level one and goes on and it arrive to `-` operator. Splits the string to `(2*3)` and `(4*5)! We get to `res1 = 6` and `res2 = 20` after doing to level two and coming back. So, the result of this case is `-14`.  And so one for to cover all cases. \\n\\nNote: Someone might wonder why the `res = []` is defined initially and gets updated within the nested `for` loop, how it keeps track of everything? Good question. Since we\\'re moving downward to lower levels, `res` keeps track of values of that particular level which it will return to be either `res1` or `res2` for upper level. When the code is executing the upper level, `res` gets initialized again and this process goes one. So, `res` does not keep track of every level, just the level we\\'re dealing with. Now, this causes extra calculations since for example if we had something line `(4*5) - (4*5)`, it would calculate each of the `4*5` separately which is not efficient. That\\'s why we can do memoization (keeping track of level so we prevent excessive calculations) as you may have seen in some solutions. Including this is not difficulat. You just need to re-arrange your function a little bit! [This](https://leetcode.com/problems/different-ways-to-add-parentheses/discuss/66438/Divide-and-Conquer-%2B-Memorization-Python) shows such a solution. Note that nothing has really changed from above solution except that [@orbuluh](https://leetcode.com/problems/different-ways-to-add-parentheses/discuss/66438/Divide-and-Conquer-%2B-Memorization-Python) moved everything to a helper function. This helper function is our `diffWaysToCompute` function in addition to a `seen = {}` dictionary which can keep track of results. When you have your two numbers and one operator and want to call the `helper` function that we used, it first checks to see if it has already seen these numbers and operator. If yes, it just calls it from hashtable which is `O(1)` and you can save some time this way. \\n\\n\\nYou\\'re done! Good job. \\n\\n\\n\\n======================================================================\\nFinal note: Please let me know if you found any type/error, etc. I\\'ll try to fix it. \\n\\nFinal note 2: I believe explaining something for other in a simplest possible manner would help me to learn better a subject. So, thanks for reading. I suggest you to do the same in case you didn\\'t fully understand the solution. \\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\n    def diffWaysToCompute(self, input):\\n        \"\"\"\\n        :type input: str\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        if input.isdigit(): #1\\n            return [int(input)] #2\\n        res = [] #3\\n        for i in xrange(len(input)): #4\\n            if input[i] in \"-+*\": #5\\n                res1 = self.diffWaysToCompute(input[:i]) #6\\n                res2 = self.diffWaysToCompute(input[i+1:]) #7\\n                for j in res1:#8\\n                    for k in res2: #9\\n                        res.append(self.helper(j, k, input[i])) #10\\n        return res #11\\n    \\n    def helper(self, m, n, op): #12\\n        if op == \"+\": #13\\n            return m+n #14\\n        elif op == \"-\": #15\\n            return m-n #16\\n        else: #17\\n            return m*n #18\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66372,
                "title": "my-recursive-java-solution",
                "content": "    public class Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        List<Integer> list=new ArrayList();\\n        if(input==null||input.length()==0) return list;\\n        if(!input.contains(\"+\")&&!input.contains(\"-\")&&!input.contains(\"*\")) {\\n            list.add(Integer.valueOf(input));\\n            return list;\\n        }\\n        for(int i=0;i<input.length();i++){\\n             char ops=input.charAt(i);\\n             if(ops=='+'||ops=='-'||ops=='*'){\\n                List<Integer> leftList=diffWaysToCompute(input.substring(0,i));\\n                List<Integer> rightList=diffWaysToCompute(input.substring(i+1,input.length()));\\n                for(int leftValue:leftList){\\n                    for(int rightValue:rightList){\\n                        switch(ops){\\n                            case '+': list.add(leftValue+rightValue); break;\\n                            case '-': list.add(leftValue-rightValue); break;\\n                            case '*': list.add(leftValue*rightValue); break;\\n                        }\\n                    }\\n                }\\n             }\\n          }\\n        return list;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        List<Integer> list=new ArrayList();\\n        if(input==null||input.length()==0) return list;\\n        if(!input.contains(\"+\")&&!input.contains(\"-\")&&!input.contains(\"*\")) {\\n            list.add(Integer.valueOf(input));\\n            return list;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3927067,
                "title": "recursion-memoization-tabulation-partition-dp-c-java-python-with-explanation",
                "content": "# Intuition\\nWhen we try to evaluate a operator, we again encounter the same problem on the left & right substring of the operator & as we have to calculate all possible ways, that\\'s where recursion comes in picture.\\n\\n# Recursion\\nWe define a recursive function `getDiffWays` where, `getDiffWays(i, j)` returns us number of ways to evaluate `expression[i...j]`. therefore our answer will be `getDiffWays(0, n - 1)`. where, `n` is the length of string `expression`.\\n\\n## Code\\n```C++ []\\nclass Solution {\\n    bool isOperator(char ch) {\\n        return (ch == \\'+\\' || ch == \\'-\\' || ch == \\'*\\');\\n    }\\n\\n    vector<int> getDiffWays(int i, int j, string& expression) {\\n        \\n        // If length of the substring is 1 or 2\\n        // we encounter our base case i.e. a number found.\\n        int len = j - i + 1;\\n        if(len <= 2) {\\n            return { stoi(expression.substr(i, len)) };\\n        }\\n\\n        // If it is not a number then it is an expression\\n        // now we try to evaluate every opertor present in it\\n        vector<int> res;\\n        for(int ind = i; ind <= j; ind++) {\\n            if(isOperator(expression[ind])) {\\n                char op = expression[ind];\\n\\n                // if char at ind is operator \\n                // get all results for its left and right substring using recursion\\n                vector<int> left = getDiffWays(i, ind - 1, expression);\\n                vector<int> right = getDiffWays(ind + 1, j, expression);\\n\\n                // try all options for left & right operand\\n                // and push all results to the answer\\n                for(int l : left) {\\n                    for(int r : right) {\\n                        if(op == \\'+\\') {\\n                            res.push_back(l + r);\\n                        }\\n                        else if(op == \\'-\\') {\\n                            res.push_back(l - r);\\n                        }\\n                        else if(op == \\'*\\') {\\n                            res.push_back(l * r);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\npublic:\\n    vector<int> diffWaysToCompute(string expression) {\\n        int n = expression.size();\\n        return getDiffWays(0, n - 1, expression);\\n    }\\n};\\n\\n```\\n```Java []\\nclass Solution {\\n    private boolean isOperator(char ch) {\\n        return (ch == \\'+\\' || ch == \\'-\\' || ch == \\'*\\');\\n    }\\n\\n    private List<Integer> getDiffWays(int i, int j, String expression) {\\n        int len = j - i + 1;\\n        List<Integer> res = new ArrayList<>();\\n\\n        // If length of the substring is 1 or 2\\n        // we encounter our base case i.e. a number found.\\n        if (len <= 2) {\\n            res.add(Integer.parseInt(expression.substring(i, i + len)));\\n            return res;\\n        }\\n\\n        // If it is not a number then it is an expression\\n        // now we try to evaluate every opertor present in it\\n        for (int ind = i; ind <= j; ind++) {\\n            if (isOperator(expression.charAt(ind))) {\\n                char op = expression.charAt(ind);\\n\\n                // if char at ind is operator \\n                // get all results for its left and right substring using recursion\\n                List<Integer> left = getDiffWays(i, ind - 1, expression);\\n                List<Integer> right = getDiffWays(ind + 1, j, expression);\\n\\n                // try all options for left & right operand\\n                // and push all results to the answer\\n                for (int l : left) {\\n                    for (int r : right) {\\n                        if (op == \\'+\\') {\\n                            res.add(l + r);\\n                        } else if (op == \\'-\\') {\\n                            res.add(l - r);\\n                        } else if (op == \\'*\\') {\\n                            res.add(l * r);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public List<Integer> diffWaysToCompute(String expression) {\\n        int n = expression.length();\\n        return getDiffWays(0, n - 1, expression);\\n    }\\n}\\n\\n```\\n``` Python3 []\\nclass Solution:\\n    def isOperator(self, ch):\\n        return ch == \\'+\\' or ch == \\'-\\' or ch == \\'*\\'\\n\\n    def getDiffWays(self, i, j, expression):\\n        res = []\\n\\n        # If length of the substring is 1 or 2\\n        # we encounter our base case i.e. a number found.\\n        if j - i + 1 <= 2:\\n            res.append(int(expression[i:j + 1]))\\n            return res\\n\\n        # If it is not a number then it is an expression\\n        # now we try to evaluate every opertor present in it\\n        for ind in range(i, j + 1):\\n            if self.isOperator(expression[ind]):\\n                op = expression[ind]\\n                \\n                # if char at ind is operator \\n                # get all results for its left and right substring using recursion\\n                left = self.getDiffWays(i, ind - 1, expression)\\n                right = self.getDiffWays(ind + 1, j, expression)\\n\\n                # try all options for left & right operand\\n                # and push all results to the answer\\n                for l in left:\\n                    for r in right:\\n                        if op == \\'+\\':\\n                            res.append(l + r)\\n                        elif op == \\'-\\':\\n                            res.append(l - r)\\n                        elif op == \\'*\\':\\n                            res.append(l * r)\\n\\n        return res\\n\\n    def diffWaysToCompute(self, expression: str):\\n        n = len(expression)\\n        return self.getDiffWays(0, n - 1, expression)\\n\\n```\\n\\n## Complexity\\n- Time complexity:\\n$$Exponential$$, it\\'s very hard to derive exact Time complexity of the solution but it will be definitely exponential in nature.\\n\\n- Space complexity:\\n$$O(n * x)$$ for recursion stack. where, `x` is the number of ways to calcuate the expression which is $operators!$\\n\\n# Memoization\\nIf we dry run a example, we observe overalapping subproblems that gets calculated again & again. We can avoid this by introducing a 3D DP array / cache & storing the results we calculate so that we don\\'t need to process same stuff again & again.\\n\\n## Code\\n```C++ []\\nclass Solution {\\n    bool isOperator(char ch) {\\n        return (ch == \\'+\\' || ch == \\'-\\' || ch == \\'*\\');\\n    }\\n\\n    vector<int> getDiffWays(int i, int j, vector<vector<vector<int>>>& dp, string& expression) {\\n\\n        // Return cached result if already calculated\\n        if(!dp[i][j].empty()) {\\n            return dp[i][j];\\n        }\\n        \\n        // If length of the substring is 1 or 2\\n        // we encounter our base case i.e. a number found.\\n        int len = j - i + 1;\\n        if(len <= 2) {\\n            return dp[i][j] = { stoi(expression.substr(i, len)) };\\n        }\\n\\n        // If it is not a number then it is an expression\\n        // now we try to evaluate every opertor present in it\\n        vector<int> res;\\n        for(int ind = i; ind <= j; ind++) {\\n            if(isOperator(expression[ind])) {\\n                char op = expression[ind];\\n\\n                // if char at ind is operator \\n                // get all results for its left and right substring using recursion\\n                vector<int> left = getDiffWays(i, ind - 1, dp, expression);\\n                vector<int> right = getDiffWays(ind + 1, j, dp, expression);\\n\\n                // try all options for left & right operand\\n                // and push all results to the answer\\n                for(int l : left) {\\n                    for(int r : right) {\\n                        if(op == \\'+\\') {\\n                            res.push_back(l + r);\\n                        }\\n                        else if(op == \\'-\\') {\\n                            res.push_back(l - r);\\n                        }\\n                        else if(op == \\'*\\') {\\n                            res.push_back(l * r);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[i][j] = res;\\n    }\\n\\npublic:\\n    vector<int> diffWaysToCompute(string expression) {\\n        int n = expression.size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n));\\n        return getDiffWays(0, n - 1, dp, expression);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    private boolean isOperator(char ch) {\\n        return (ch == \\'+\\' || ch == \\'-\\' || ch == \\'*\\');\\n    }\\n\\n    private List<Integer> getDiffWays(int i, int j, Map<String, List<Integer>> dp, String expression) {\\n        String key = i + \"-\" + j;\\n\\n        // Return cached result if already calculated\\n        if (dp.containsKey(key)) {\\n            return dp.get(key);\\n        }\\n\\n        // If length of the substring is 1 or 2\\n        // we encounter our base case i.e. a number found.\\n        int len = j - i + 1;\\n        if (len <= 2) {\\n            List<Integer> result = new ArrayList<>();\\n            result.add(Integer.parseInt(expression.substring(i, j + 1)));\\n            dp.put(key, result);\\n            return result;\\n        }\\n\\n        // If it is not a number then it is an expression\\n        // now we try to evaluate every operator present in it\\n        List<Integer> res = new ArrayList<>();\\n        for (int ind = i; ind <= j; ind++) {\\n            if (isOperator(expression.charAt(ind))) {\\n                char op = expression.charAt(ind);\\n\\n                // if char at ind is an operator \\n                // get all results for its left and right substring using recursion\\n                List<Integer> left = getDiffWays(i, ind - 1, dp, expression);\\n                List<Integer> right = getDiffWays(ind + 1, j, dp, expression);\\n\\n                // try all options for left & right operand\\n                // and push all results to the answer\\n                for (int l : left) {\\n                    for (int r : right) {\\n                        if (op == \\'+\\') {\\n                            res.add(l + r);\\n                        } else if (op == \\'-\\') {\\n                            res.add(l - r);\\n                        } else if (op == \\'*\\') {\\n                            res.add(l * r);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        dp.put(key, res);\\n        return res;\\n    }\\n\\n    public List<Integer> diffWaysToCompute(String expression) {\\n        Map<String, List<Integer>> dp = new HashMap<>();\\n        return getDiffWays(0, expression.length() - 1, dp, expression);\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def isOperator(self, ch):\\n        return ch == \\'+\\' or ch == \\'-\\' or ch == \\'*\\'\\n\\n    def getDiffWays(self, i, j, dp, expression):\\n\\n        # Return cached result if already calculated\\n        if (i, j) in dp:\\n            return dp[(i, j)]\\n\\n        # If length of the substring is 1 or 2\\n        # we encounter our base case i.e. a number found.\\n        len_substring = j - i + 1\\n        if len_substring <= 2:\\n            result = [int(expression[i:j+1])]\\n            dp[(i, j)] = result\\n            return result\\n\\n        # If it is not a number then it is an expression\\n        # now we try to evaluate every operator present in it\\n        res = []\\n        for ind in range(i, j + 1):\\n            if self.isOperator(expression[ind]):\\n                op = expression[ind]\\n\\n                # if char at ind is an operator \\n                # get all results for its left and right substring using recursion\\n                left = self.getDiffWays(i, ind - 1, dp, expression)\\n                right = self.getDiffWays(ind + 1, j, dp, expression)\\n\\n                # try all options for left & right operand\\n                # and push all results to the answer\\n                for l in left:\\n                    for r in right:\\n                        if op == \\'+\\':\\n                            res.append(l + r)\\n                        elif op == \\'-\\':\\n                            res.append(l - r)\\n                        elif op == \\'*\\':\\n                            res.append(l * r)\\n\\n        dp[(i, j)] = res\\n        return res\\n\\n    def diffWaysToCompute(self, expression: str):\\n        dp = {}\\n        return self.getDiffWays(0, len(expression) - 1, dp, expression)\\n```\\n\\n## Complexity\\n- Time complexity:\\n$$O(n^2 * (n * x^2))$$, as there are approx. $n^2$ states and to calculate these states 3 nested loops in recursive function take $O(n * x^2)$ time.\\n\\n- Space complexity:\\n$$O(n * x) + O(n^2 * x)$$ for recursion stack & dp array. where, `x` is the number of ways to calcuate the expression which is $operators!$\\n\\n# Tabulation\\nWe can eliminate the recursion stack space used in memoization solution by just calculating result for every valid expression substring in bottom up manner i.e. Tabulation.\\n\\nIn memoization, every substring which gets called recursively is valid but in this solution we need to check if given substring is a valid arithemetic expression or not.\\n\\n## Code\\n``` C++ []\\nclass Solution {\\n    bool isOperator(char ch) {\\n        return (ch == \\'+\\' || ch == \\'-\\' || ch == \\'*\\');\\n    }\\n\\npublic:\\n    vector<int> diffWaysToCompute(string expression) {\\n        int n = expression.size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n));\\n\\n        // Function to check if given substring of expression\\n        // is a valid expression\\n        auto isValidExpression = [&](int i, int j) -> bool {\\n            return (i == 0 || isOperator(expression[i - 1])) && (j == n - 1 || isOperator(expression[j + 1]));\\n        };\\n\\n        // get answer for all single digit numbers\\n        for(int i = 0; i < n; i++) {\\n            if(isValidExpression(i, i)) {\\n                dp[i][i] = { stoi(expression.substr(i, 1)) };\\n            }\\n        }\\n\\n        // get answer for all 2 digit numbers\\n        for(int i = 0, j = 1; j < n; i++, j++) {\\n            if(isValidExpression(i, j)) {\\n                dp[i][j] = { stoi(expression.substr(i, 2)) };\\n            }\\n        }\\n\\n        // get answer for all valid expression substrings in bottom up manner\\n        for(int len = 3; len <= n; len++) {\\n            for(int i = 0, j = i + len - 1; j < n; i++, j++) {\\n                if(!isValidExpression(i, j))\\n                    continue;\\n\\n                // Try to evaluate every operator\\n                for(int ind = i; ind <= j; ind++) {\\n                    if(isOperator(expression[ind])) {\\n                        char op = expression[ind];\\n\\n                        // if char at ind is operator \\n                        // get all results for its left and right substring\\n                        vector<int> left = dp[i][ind - 1];\\n                        vector<int> right = dp[ind + 1][j];\\n\\n                        // try all options for left & right operand\\n                        // and push all results to the answer\\n                        for(int l : left) {\\n                            for(int r : right) {\\n                                if(op == \\'+\\') {\\n                                    dp[i][j].push_back(l + r);\\n                                }\\n                                else if(op == \\'-\\') {\\n                                    dp[i][j].push_back(l - r);\\n                                }\\n                                else if(op == \\'*\\') {\\n                                    dp[i][j].push_back(l * r);\\n                                }\\n                            }\\n                        }\\n                    }\\n                }         \\n            }\\n        }\\n\\n        return dp[0][n - 1];\\n    }\\n};\\n```\\n``` Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    private boolean isOperator(char ch) {\\n        return (ch == \\'+\\' || ch == \\'-\\' || ch == \\'*\\');\\n    }\\n\\n    public List<Integer> diffWaysToCompute(String expression) {\\n        int n = expression.length();\\n        List<Integer>[][] dp = new ArrayList[n][n];\\n\\n        // Function to check if given substring of expression\\n        // is a valid expression\\n        BiFunction<Integer, Integer, Boolean> isValidExpression = (i, j) -> \\n            (i == 0 || isOperator(expression.charAt(i - 1))) && \\n            (j == n - 1 || isOperator(expression.charAt(j + 1)));\\n\\n        // Get answer for all single digit numbers\\n        for (int i = 0; i < n; i++) {\\n            if (isValidExpression.apply(i, i)) {\\n                dp[i][i] = new ArrayList<>();\\n                dp[i][i].add(Integer.parseInt(expression.substring(i, i + 1)));\\n            }\\n        }\\n\\n        // Get answer for all 2 digit numbers\\n        for (int i = 0, j = 1; j < n; i++, j++) {\\n            if (isValidExpression.apply(i, j)) {\\n                dp[i][j] = new ArrayList<>();\\n                dp[i][j].add(Integer.parseInt(expression.substring(i, i + 2)));\\n            }\\n        }\\n\\n        // Get answer for all valid expression substrings in bottom up manner\\n        for (int len = 3; len <= n; len++) {\\n            for (int i = 0, j = i + len - 1; j < n; i++, j++) {\\n                if (!isValidExpression.apply(i, j)) {\\n                    continue;\\n                }\\n\\n                dp[i][j] = new ArrayList<>();\\n                // Try to evaluate every operator\\n                for (int ind = i; ind <= j; ind++) {\\n                    if (isOperator(expression.charAt(ind))) {\\n                        char op = expression.charAt(ind);\\n\\n                        // If char at ind is operator, get all results for its left and right substrings\\n                        List<Integer> left = dp[i][ind - 1];\\n                        List<Integer> right = dp[ind + 1][j];\\n\\n                        // Try all options for left & right operands and add all results to the answer\\n                        for (int l : left) {\\n                            for (int r : right) {\\n                                if (op == \\'+\\') {\\n                                    dp[i][j].add(l + r);\\n                                } else if (op == \\'-\\') {\\n                                    dp[i][j].add(l - r);\\n                                } else if (op == \\'*\\') {\\n                                    dp[i][j].add(l * r);\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[0][n - 1];\\n    }\\n}\\n```\\n``` Python3 []\\nclass Solution:\\n    def isOperator(self, ch):\\n        return ch == \\'+\\' or ch == \\'-\\' or ch == \\'*\\'\\n\\n    def diffWaysToCompute(self, expression: str) -> List[int]:\\n        n = len(expression)\\n        dp = [[[] for _ in range(n)] for _ in range(n)]\\n\\n        def isValidExpression(i, j):\\n            return (i == 0 or self.isOperator(expression[i - 1])) and (j == n - 1 or self.isOperator(expression[j + 1]))\\n\\n        # Get answer for all single digit numbers\\n        for i in range(n):\\n            if isValidExpression(i, i):\\n                dp[i][i] = [int(expression[i])]\\n\\n        # Get answer for all 2 digit numbers\\n        for i in range(n - 1):\\n            if isValidExpression(i, i + 1):\\n                dp[i][i + 1] = [int(expression[i:i + 2])]\\n\\n        # Get answer for all valid expression substrings in bottom-up manner\\n        for length in range(3, n + 1):\\n            for i in range(n - length + 1):\\n                j = i + length - 1\\n                if not isValidExpression(i, j):\\n                    continue\\n\\n                dp[i][j] = []\\n                # Try to evaluate every operator\\n                for ind in range(i, j + 1):\\n                    if self.isOperator(expression[ind]):\\n                        op = expression[ind]\\n\\n                        # If char at ind is operator, get all results for its left and right substrings\\n                        left = dp[i][ind - 1]\\n                        right = dp[ind + 1][j]\\n\\n                        # Try all options for left & right operands and add all results to the answer\\n                        for l in left:\\n                            for r in right:\\n                                if op == \\'+\\':\\n                                    dp[i][j].append(l + r)\\n                                elif op == \\'-\\':\\n                                    dp[i][j].append(l - r)\\n                                elif op == \\'*\\':\\n                                    dp[i][j].append(l * r)\\n\\n        return dp[0][n - 1]\\n```\\n\\n## Complexity\\n- Time complexity:\\n$$O(n^3 * x^2)$$, same as memoization solution.\\n\\n- Space complexity:\\n$$O(n^2 * x)$$ for dp array. where, `x` is the number of ways to calcuate the expression which is `operators!`\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Divide and Conquer",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```C++ []\\nclass Solution {\\n    bool isOperator(char ch) {\\n        return (ch == \\'+\\' || ch == \\'-\\' || ch == \\'*\\');\\n    }\\n\\n    vector<int> getDiffWays(int i, int j, string& expression) {\\n        \\n        // If length of the substring is 1 or 2\\n        // we encounter our base case i.e. a number found.\\n        int len = j - i + 1;\\n        if(len <= 2) {\\n            return { stoi(expression.substr(i, len)) };\\n        }\\n\\n        // If it is not a number then it is an expression\\n        // now we try to evaluate every opertor present in it\\n        vector<int> res;\\n        for(int ind = i; ind <= j; ind++) {\\n            if(isOperator(expression[ind])) {\\n                char op = expression[ind];\\n\\n                // if char at ind is operator \\n                // get all results for its left and right substring using recursion\\n                vector<int> left = getDiffWays(i, ind - 1, expression);\\n                vector<int> right = getDiffWays(ind + 1, j, expression);\\n\\n                // try all options for left & right operand\\n                // and push all results to the answer\\n                for(int l : left) {\\n                    for(int r : right) {\\n                        if(op == \\'+\\') {\\n                            res.push_back(l + r);\\n                        }\\n                        else if(op == \\'-\\') {\\n                            res.push_back(l - r);\\n                        }\\n                        else if(op == \\'*\\') {\\n                            res.push_back(l * r);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\npublic:\\n    vector<int> diffWaysToCompute(string expression) {\\n        int n = expression.size();\\n        return getDiffWays(0, n - 1, expression);\\n    }\\n};\\n\\n```\n```Java []\\nclass Solution {\\n    private boolean isOperator(char ch) {\\n        return (ch == \\'+\\' || ch == \\'-\\' || ch == \\'*\\');\\n    }\\n\\n    private List<Integer> getDiffWays(int i, int j, String expression) {\\n        int len = j - i + 1;\\n        List<Integer> res = new ArrayList<>();\\n\\n        // If length of the substring is 1 or 2\\n        // we encounter our base case i.e. a number found.\\n        if (len <= 2) {\\n            res.add(Integer.parseInt(expression.substring(i, i + len)));\\n            return res;\\n        }\\n\\n        // If it is not a number then it is an expression\\n        // now we try to evaluate every opertor present in it\\n        for (int ind = i; ind <= j; ind++) {\\n            if (isOperator(expression.charAt(ind))) {\\n                char op = expression.charAt(ind);\\n\\n                // if char at ind is operator \\n                // get all results for its left and right substring using recursion\\n                List<Integer> left = getDiffWays(i, ind - 1, expression);\\n                List<Integer> right = getDiffWays(ind + 1, j, expression);\\n\\n                // try all options for left & right operand\\n                // and push all results to the answer\\n                for (int l : left) {\\n                    for (int r : right) {\\n                        if (op == \\'+\\') {\\n                            res.add(l + r);\\n                        } else if (op == \\'-\\') {\\n                            res.add(l - r);\\n                        } else if (op == \\'*\\') {\\n                            res.add(l * r);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public List<Integer> diffWaysToCompute(String expression) {\\n        int n = expression.length();\\n        return getDiffWays(0, n - 1, expression);\\n    }\\n}\\n\\n```\n``` Python3 []\\nclass Solution:\\n    def isOperator(self, ch):\\n        return ch == \\'+\\' or ch == \\'-\\' or ch == \\'*\\'\\n\\n    def getDiffWays(self, i, j, expression):\\n        res = []\\n\\n        # If length of the substring is 1 or 2\\n        # we encounter our base case i.e. a number found.\\n        if j - i + 1 <= 2:\\n            res.append(int(expression[i:j + 1]))\\n            return res\\n\\n        # If it is not a number then it is an expression\\n        # now we try to evaluate every opertor present in it\\n        for ind in range(i, j + 1):\\n            if self.isOperator(expression[ind]):\\n                op = expression[ind]\\n                \\n                # if char at ind is operator \\n                # get all results for its left and right substring using recursion\\n                left = self.getDiffWays(i, ind - 1, expression)\\n                right = self.getDiffWays(ind + 1, j, expression)\\n\\n                # try all options for left & right operand\\n                # and push all results to the answer\\n                for l in left:\\n                    for r in right:\\n                        if op == \\'+\\':\\n                            res.append(l + r)\\n                        elif op == \\'-\\':\\n                            res.append(l - r)\\n                        elif op == \\'*\\':\\n                            res.append(l * r)\\n\\n        return res\\n\\n    def diffWaysToCompute(self, expression: str):\\n        n = len(expression)\\n        return self.getDiffWays(0, n - 1, expression)\\n\\n```\n```C++ []\\nclass Solution {\\n    bool isOperator(char ch) {\\n        return (ch == \\'+\\' || ch == \\'-\\' || ch == \\'*\\');\\n    }\\n\\n    vector<int> getDiffWays(int i, int j, vector<vector<vector<int>>>& dp, string& expression) {\\n\\n        // Return cached result if already calculated\\n        if(!dp[i][j].empty()) {\\n            return dp[i][j];\\n        }\\n        \\n        // If length of the substring is 1 or 2\\n        // we encounter our base case i.e. a number found.\\n        int len = j - i + 1;\\n        if(len <= 2) {\\n            return dp[i][j] = { stoi(expression.substr(i, len)) };\\n        }\\n\\n        // If it is not a number then it is an expression\\n        // now we try to evaluate every opertor present in it\\n        vector<int> res;\\n        for(int ind = i; ind <= j; ind++) {\\n            if(isOperator(expression[ind])) {\\n                char op = expression[ind];\\n\\n                // if char at ind is operator \\n                // get all results for its left and right substring using recursion\\n                vector<int> left = getDiffWays(i, ind - 1, dp, expression);\\n                vector<int> right = getDiffWays(ind + 1, j, dp, expression);\\n\\n                // try all options for left & right operand\\n                // and push all results to the answer\\n                for(int l : left) {\\n                    for(int r : right) {\\n                        if(op == \\'+\\') {\\n                            res.push_back(l + r);\\n                        }\\n                        else if(op == \\'-\\') {\\n                            res.push_back(l - r);\\n                        }\\n                        else if(op == \\'*\\') {\\n                            res.push_back(l * r);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[i][j] = res;\\n    }\\n\\npublic:\\n    vector<int> diffWaysToCompute(string expression) {\\n        int n = expression.size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n));\\n        return getDiffWays(0, n - 1, dp, expression);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    private boolean isOperator(char ch) {\\n        return (ch == \\'+\\' || ch == \\'-\\' || ch == \\'*\\');\\n    }\\n\\n    private List<Integer> getDiffWays(int i, int j, Map<String, List<Integer>> dp, String expression) {\\n        String key = i + \"-\" + j;\\n\\n        // Return cached result if already calculated\\n        if (dp.containsKey(key)) {\\n            return dp.get(key);\\n        }\\n\\n        // If length of the substring is 1 or 2\\n        // we encounter our base case i.e. a number found.\\n        int len = j - i + 1;\\n        if (len <= 2) {\\n            List<Integer> result = new ArrayList<>();\\n            result.add(Integer.parseInt(expression.substring(i, j + 1)));\\n            dp.put(key, result);\\n            return result;\\n        }\\n\\n        // If it is not a number then it is an expression\\n        // now we try to evaluate every operator present in it\\n        List<Integer> res = new ArrayList<>();\\n        for (int ind = i; ind <= j; ind++) {\\n            if (isOperator(expression.charAt(ind))) {\\n                char op = expression.charAt(ind);\\n\\n                // if char at ind is an operator \\n                // get all results for its left and right substring using recursion\\n                List<Integer> left = getDiffWays(i, ind - 1, dp, expression);\\n                List<Integer> right = getDiffWays(ind + 1, j, dp, expression);\\n\\n                // try all options for left & right operand\\n                // and push all results to the answer\\n                for (int l : left) {\\n                    for (int r : right) {\\n                        if (op == \\'+\\') {\\n                            res.add(l + r);\\n                        } else if (op == \\'-\\') {\\n                            res.add(l - r);\\n                        } else if (op == \\'*\\') {\\n                            res.add(l * r);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        dp.put(key, res);\\n        return res;\\n    }\\n\\n    public List<Integer> diffWaysToCompute(String expression) {\\n        Map<String, List<Integer>> dp = new HashMap<>();\\n        return getDiffWays(0, expression.length() - 1, dp, expression);\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def isOperator(self, ch):\\n        return ch == \\'+\\' or ch == \\'-\\' or ch == \\'*\\'\\n\\n    def getDiffWays(self, i, j, dp, expression):\\n\\n        # Return cached result if already calculated\\n        if (i, j) in dp:\\n            return dp[(i, j)]\\n\\n        # If length of the substring is 1 or 2\\n        # we encounter our base case i.e. a number found.\\n        len_substring = j - i + 1\\n        if len_substring <= 2:\\n            result = [int(expression[i:j+1])]\\n            dp[(i, j)] = result\\n            return result\\n\\n        # If it is not a number then it is an expression\\n        # now we try to evaluate every operator present in it\\n        res = []\\n        for ind in range(i, j + 1):\\n            if self.isOperator(expression[ind]):\\n                op = expression[ind]\\n\\n                # if char at ind is an operator \\n                # get all results for its left and right substring using recursion\\n                left = self.getDiffWays(i, ind - 1, dp, expression)\\n                right = self.getDiffWays(ind + 1, j, dp, expression)\\n\\n                # try all options for left & right operand\\n                # and push all results to the answer\\n                for l in left:\\n                    for r in right:\\n                        if op == \\'+\\':\\n                            res.append(l + r)\\n                        elif op == \\'-\\':\\n                            res.append(l - r)\\n                        elif op == \\'*\\':\\n                            res.append(l * r)\\n\\n        dp[(i, j)] = res\\n        return res\\n\\n    def diffWaysToCompute(self, expression: str):\\n        dp = {}\\n        return self.getDiffWays(0, len(expression) - 1, dp, expression)\\n```\n``` C++ []\\nclass Solution {\\n    bool isOperator(char ch) {\\n        return (ch == \\'+\\' || ch == \\'-\\' || ch == \\'*\\');\\n    }\\n\\npublic:\\n    vector<int> diffWaysToCompute(string expression) {\\n        int n = expression.size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n));\\n\\n        // Function to check if given substring of expression\\n        // is a valid expression\\n        auto isValidExpression = [&](int i, int j) -> bool {\\n            return (i == 0 || isOperator(expression[i - 1])) && (j == n - 1 || isOperator(expression[j + 1]));\\n        };\\n\\n        // get answer for all single digit numbers\\n        for(int i = 0; i < n; i++) {\\n            if(isValidExpression(i, i)) {\\n                dp[i][i] = { stoi(expression.substr(i, 1)) };\\n            }\\n        }\\n\\n        // get answer for all 2 digit numbers\\n        for(int i = 0, j = 1; j < n; i++, j++) {\\n            if(isValidExpression(i, j)) {\\n                dp[i][j] = { stoi(expression.substr(i, 2)) };\\n            }\\n        }\\n\\n        // get answer for all valid expression substrings in bottom up manner\\n        for(int len = 3; len <= n; len++) {\\n            for(int i = 0, j = i + len - 1; j < n; i++, j++) {\\n                if(!isValidExpression(i, j))\\n                    continue;\\n\\n                // Try to evaluate every operator\\n                for(int ind = i; ind <= j; ind++) {\\n                    if(isOperator(expression[ind])) {\\n                        char op = expression[ind];\\n\\n                        // if char at ind is operator \\n                        // get all results for its left and right substring\\n                        vector<int> left = dp[i][ind - 1];\\n                        vector<int> right = dp[ind + 1][j];\\n\\n                        // try all options for left & right operand\\n                        // and push all results to the answer\\n                        for(int l : left) {\\n                            for(int r : right) {\\n                                if(op == \\'+\\') {\\n                                    dp[i][j].push_back(l + r);\\n                                }\\n                                else if(op == \\'-\\') {\\n                                    dp[i][j].push_back(l - r);\\n                                }\\n                                else if(op == \\'*\\') {\\n                                    dp[i][j].push_back(l * r);\\n                                }\\n                            }\\n                        }\\n                    }\\n                }         \\n            }\\n        }\\n\\n        return dp[0][n - 1];\\n    }\\n};\\n```\n``` Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    private boolean isOperator(char ch) {\\n        return (ch == \\'+\\' || ch == \\'-\\' || ch == \\'*\\');\\n    }\\n\\n    public List<Integer> diffWaysToCompute(String expression) {\\n        int n = expression.length();\\n        List<Integer>[][] dp = new ArrayList[n][n];\\n\\n        // Function to check if given substring of expression\\n        // is a valid expression\\n        BiFunction<Integer, Integer, Boolean> isValidExpression = (i, j) -> \\n            (i == 0 || isOperator(expression.charAt(i - 1))) && \\n            (j == n - 1 || isOperator(expression.charAt(j + 1)));\\n\\n        // Get answer for all single digit numbers\\n        for (int i = 0; i < n; i++) {\\n            if (isValidExpression.apply(i, i)) {\\n                dp[i][i] = new ArrayList<>();\\n                dp[i][i].add(Integer.parseInt(expression.substring(i, i + 1)));\\n            }\\n        }\\n\\n        // Get answer for all 2 digit numbers\\n        for (int i = 0, j = 1; j < n; i++, j++) {\\n            if (isValidExpression.apply(i, j)) {\\n                dp[i][j] = new ArrayList<>();\\n                dp[i][j].add(Integer.parseInt(expression.substring(i, i + 2)));\\n            }\\n        }\\n\\n        // Get answer for all valid expression substrings in bottom up manner\\n        for (int len = 3; len <= n; len++) {\\n            for (int i = 0, j = i + len - 1; j < n; i++, j++) {\\n                if (!isValidExpression.apply(i, j)) {\\n                    continue;\\n                }\\n\\n                dp[i][j] = new ArrayList<>();\\n                // Try to evaluate every operator\\n                for (int ind = i; ind <= j; ind++) {\\n                    if (isOperator(expression.charAt(ind))) {\\n                        char op = expression.charAt(ind);\\n\\n                        // If char at ind is operator, get all results for its left and right substrings\\n                        List<Integer> left = dp[i][ind - 1];\\n                        List<Integer> right = dp[ind + 1][j];\\n\\n                        // Try all options for left & right operands and add all results to the answer\\n                        for (int l : left) {\\n                            for (int r : right) {\\n                                if (op == \\'+\\') {\\n                                    dp[i][j].add(l + r);\\n                                } else if (op == \\'-\\') {\\n                                    dp[i][j].add(l - r);\\n                                } else if (op == \\'*\\') {\\n                                    dp[i][j].add(l * r);\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[0][n - 1];\\n    }\\n}\\n```\n``` Python3 []\\nclass Solution:\\n    def isOperator(self, ch):\\n        return ch == \\'+\\' or ch == \\'-\\' or ch == \\'*\\'\\n\\n    def diffWaysToCompute(self, expression: str) -> List[int]:\\n        n = len(expression)\\n        dp = [[[] for _ in range(n)] for _ in range(n)]\\n\\n        def isValidExpression(i, j):\\n            return (i == 0 or self.isOperator(expression[i - 1])) and (j == n - 1 or self.isOperator(expression[j + 1]))\\n\\n        # Get answer for all single digit numbers\\n        for i in range(n):\\n            if isValidExpression(i, i):\\n                dp[i][i] = [int(expression[i])]\\n\\n        # Get answer for all 2 digit numbers\\n        for i in range(n - 1):\\n            if isValidExpression(i, i + 1):\\n                dp[i][i + 1] = [int(expression[i:i + 2])]\\n\\n        # Get answer for all valid expression substrings in bottom-up manner\\n        for length in range(3, n + 1):\\n            for i in range(n - length + 1):\\n                j = i + length - 1\\n                if not isValidExpression(i, j):\\n                    continue\\n\\n                dp[i][j] = []\\n                # Try to evaluate every operator\\n                for ind in range(i, j + 1):\\n                    if self.isOperator(expression[ind]):\\n                        op = expression[ind]\\n\\n                        # If char at ind is operator, get all results for its left and right substrings\\n                        left = dp[i][ind - 1]\\n                        right = dp[ind + 1][j]\\n\\n                        # Try all options for left & right operands and add all results to the answer\\n                        for l in left:\\n                            for r in right:\\n                                if op == \\'+\\':\\n                                    dp[i][j].append(l + r)\\n                                elif op == \\'-\\':\\n                                    dp[i][j].append(l - r)\\n                                elif op == \\'*\\':\\n                                    dp[i][j].append(l * r)\\n\\n        return dp[0][n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832303,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> diffWaysToCompute(string input) {\\n        vector<int> ans;\\n        bool pureNum=true;\\n        for (int i=0; i<input.length(); i++) \\n            if (input[i]<\\'0\\' || input[i]>\\'9\\') {\\n                pureNum=false;\\n                vector<int> L=diffWaysToCompute(input.substr(0, i)), R=diffWaysToCompute(input.substr(i+1, input.length()-i-1));\\n                for (auto l : L)\\n                    for (auto r : R)\\n                        if (input[i]==\\'+\\') ans.push_back(l+r);\\n                        else if (input[i]==\\'-\\') ans.push_back(l-r);\\n                        else if (input[i]==\\'*\\') ans.push_back(l*r);\\n            }\\n        \\n        if (pureNum)\\n            ans.push_back(atoi(input.c_str()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> diffWaysToCompute(string input) {\\n        vector<int> ans;\\n        bool pureNum=true;\\n        for (int i=0; i<input.length(); i++) \\n            if (input[i]<\\'0\\' || input[i]>\\'9\\') {\\n                pureNum=false;\\n                vector<int> L=diffWaysToCompute(input.substr(0, i)), R=diffWaysToCompute(input.substr(i+1, input.length()-i-1));\\n                for (auto l : L)\\n                    for (auto r : R)\\n                        if (input[i]==\\'+\\') ans.push_back(l+r);\\n                        else if (input[i]==\\'-\\') ans.push_back(l-r);\\n                        else if (input[i]==\\'*\\') ans.push_back(l*r);\\n            }\\n        \\n        if (pureNum)\\n            ans.push_back(atoi(input.c_str()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66402,
                "title": "bottom-up-dp-solution-in-python-beats-98",
                "content": "    import operator, re\\n    ops = {'+': operator.add, '-': operator.sub, '*': operator.mul}\\n    \\n    class Solution(object):\\n        def diffWaysToCompute(self, s):\\n            nums = [int(x) for x in re.findall(r'[0-9]+', s)]\\n            opers = re.findall(r'\\\\+|\\\\-|\\\\*', s)\\n            n, DP = len(nums), {}\\n            for i in range(n):\\n                DP[i, i] = [nums[i]]\\n            for i in range(n - 1):\\n                DP[i, i+1] = [ops[opers[i]](nums[i], nums[i + 1])]\\n            for k in range(3, n + 1):\\n                for i in range(n - k + 1):\\n                    j = i + k - 1\\n                    DP[i, j] = []\\n                    for v in range(i, j):\\n                        left = DP[i, v]\\n                        right = DP[v + 1, j]\\n                        for e1 in left:\\n                            for e2 in right:\\n                                DP[i, j].append(ops[opers[v]](e1, e2))\\n            return DP[0, n - 1]\\nWe can't do better than exponential time because the size of the result is the Catalan number. But we can solve recursively and store partial results in order to not recompute results that we already know. \\n\\nThis problem is very similar to Different Number of BSTs that you can build from 1 to n (same thing, it's the Catalan number)",
                "solutionTags": [],
                "code": "class Solution(object):\\n        def diffWaysToCompute(self, s):\\n            nums = [int(x) for x in re.findall(r'[0-9]+', s)]\\n            opers = re.findall(r'\\\\+|\\\\-|\\\\*', s)\\n            n, DP = len(nums), {}",
                "codeTag": "Java"
            },
            {
                "id": 2104031,
                "title": "c-easy-to-understand-recursive-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> recurse(string s)\\n    {\\n        vector<int> ans;\\n        \\n        for(int k=0;k<s.length();k++)\\n        {\\n            if(s[k]==\\'+\\'||s[k]==\\'-\\'||s[k]==\\'*\\')\\n            {\\n                vector<int> v1,v2;\\n                v1=recurse(s.substr(0,k));\\n                v2=recurse(s.substr(k+1));\\n            \\n                for(int i2=0;i2<v1.size();i2++)\\n                {\\n                    for(int j2=0;j2<v2.size();j2++)\\n                    {\\n                        if(s[k]==\\'+\\')\\n                        {\\n                            ans.push_back(v1[i2]+v2[j2]);\\n                        }\\n                        if(s[k]==\\'-\\')\\n                        {\\n                            ans.push_back(v1[i2]-v2[j2]);\\n                        }\\n                        if(s[k]==\\'*\\')\\n                        {\\n                            ans.push_back(v1[i2]*v2[j2]);\\n                        }\\n                        //cout<<v1[i2]<<s[k]<<v2[j2]<<endl;\\n                    }\\n                }\\n            }\\n        }\\n        if(ans.size()==0)\\n        {\\n            ans.push_back(stoi(s));\\n        }\\n        return ans;\\n    }\\n    vector<int> diffWaysToCompute(string s){\\n      int n=s.length();\\n      return recurse(s);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> recurse(string s)\\n    {\\n        vector<int> ans;\\n        \\n        for(int k=0;k<s.length();k++)\\n        {\\n            if(s[k]==\\'+\\'||s[k]==\\'-\\'||s[k]==\\'*\\')\\n            {\\n                vector<int> v1,v2;\\n                v1=recurse(s.substr(0,k));\\n                v2=recurse(s.substr(k+1));\\n            \\n                for(int i2=0;i2<v1.size();i2++)\\n                {\\n                    for(int j2=0;j2<v2.size();j2++)\\n                    {\\n                        if(s[k]==\\'+\\')\\n                        {\\n                            ans.push_back(v1[i2]+v2[j2]);\\n                        }\\n                        if(s[k]==\\'-\\')\\n                        {\\n                            ans.push_back(v1[i2]-v2[j2]);\\n                        }\\n                        if(s[k]==\\'*\\')\\n                        {\\n                            ans.push_back(v1[i2]*v2[j2]);\\n                        }\\n                        //cout<<v1[i2]<<s[k]<<v2[j2]<<endl;\\n                    }\\n                }\\n            }\\n        }\\n        if(ans.size()==0)\\n        {\\n            ans.push_back(stoi(s));\\n        }\\n        return ans;\\n    }\\n    vector<int> diffWaysToCompute(string s){\\n      int n=s.length();\\n      return recurse(s);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 66352,
                "title": "extreme-concise-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> diffWaysToCompute(string input) {\\n            if(input.size() ==0) return {};\\n            vector<int> result;\\n            for(int i = 0; i < input.size(); i++)\\n            {\\n                if(input[i]!='+' &&input[i]!= '-' &&input[i]!= '*') continue;\\n                auto vec1 = diffWaysToCompute(input.substr(0, i));\\n                auto vec2 = diffWaysToCompute(input.substr(i+1));\\n                for(auto val1: vec1)\\n                {\\n                    for(auto val2: vec2)\\n                    {\\n                        if(input[i]=='+') result.push_back(val1+ val2);\\n                        else if(input[i]=='-') result.push_back(val1 - val2);\\n                        else if(input[i]== '*') result.push_back(val1 * val2);\\n                    }\\n                }\\n            }\\n            return result.empty()?vector<int>{stoi(input)}:result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> diffWaysToCompute(string input) {\\n            if(input.size() ==0) return {}",
                "codeTag": "Java"
            },
            {
                "id": 66435,
                "title": "clean-c-solution-with-explanation",
                "content": " The problem can be visualized as a binary tree and the problem is equivalent to finding all possible different binary trees with all values as leaves and operators as non-leaf nodes. As a example 1*3-4 can be visualized as following:\\n\\n          *                                  -\\n        /   \\\\                              /   \\\\\\n       1     -                or          *     4\\n           /   \\\\                        /   \\\\\\n           3    4                       1    3\\n\\nTherefore,  we can write out an recursive solution as follows.\\n\\n    class Solution {\\n    public:\\n        vector<int> diffWaysToCompute(string input) {\\n            if (input.empty()) return vector<int>();\\n            return helper(input, 0, input.size() -1);\\n        }\\n        \\n        vector<int> helper(string& input, int startIdx, int endIdx) {\\n            vector<int> result;\\n            for (int i = startIdx; i < endIdx; i++) {\\n                if (input[i] =='+'|| input[i] == '-' || input[i] == '*') {\\n                    vector<int> left = helper(input, startIdx, i-1);\\n                    vector<int> right = helper(input, i+1, endIdx);\\n                    for (int val1 : left) {\\n                        for (int val2 : right) {\\n                            switch(input[i]) {\\n                                case '+': result.push_back(val1 + val2); break;\\n                                case '-': result.push_back(val1 - val2); break;\\n                                case '*': result.push_back(val1 * val2); break;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            if (result.empty()){\\n                int operand = 0;\\n                int i = startIdx;\\n                while(i < input.size() && isdigit(input[i])) {\\n                    operand = 10 * operand + (input[i]-'0');\\n                    i++;\\n                }\\n                result.push_back(operand);\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> diffWaysToCompute(string input) {\\n            if (input.empty()) return vector<int>();\\n            return helper(input, 0, input.size() -1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 66438,
                "title": "divide-and-conquer-memorization-python",
                "content": "There are two factors I modified to speedup the process, one would be memorization/DP-like techniques, the other is directly compute instead of using `eval()` to compute string.\\n\\n    \\n\\n    def diffWaysToCompute(self, input):\\n        return self.helper(input, {})\\n        \\n    def helper(self, input, seen):\\n        if input in seen:\\n            return seen[input]\\n        if input.isnumeric():\\n            return [int(input)]\\n        res = []\\n        for i, c in enumerate(input):\\n            if c in \"+-*\":\\n                res += [l+r if c == \"+\" else l-r if c == \"-\" else l*r \\n                            for l in self.helper(input[:i], seen) \\n                            for r in self.helper(input[i+1:], seen)]\\n        seen[input] = res\\n        return res",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer",
                    "Memoization"
                ],
                "code": "There are two factors I modified to speedup the process, one would be memorization/DP-like techniques, the other is directly compute instead of using `eval()` to compute string.\\n\\n    \\n\\n    def diffWaysToCompute(self, input):\\n        return self.helper(input, {})\\n        \\n    def helper(self, input, seen):\\n        if input in seen:\\n            return seen[input]\\n        if input.isnumeric():\\n            return [int(input)]\\n        res = []\\n        for i, c in enumerate(input):\\n            if c in \"+-*\":\\n                res += [l+r if c == \"+\" else l-r if c == \"-\" else l*r \\n                            for l in self.helper(input[:i], seen) \\n                            for r in self.helper(input[i+1:], seen)]\\n        seen[input] = res\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3231810,
                "title": "241-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can use divide and conquer approach to solve this problem. We can divide the given expression into two parts at each operator, and recursively calculate the results for each part. Finally, we can combine the results using the given operator to get the final result.\\n\\nFor example, for the expression \"23-45\", we can split it into two parts at the operator \\'-\\': \"23\" and \"45\". Then we can split each part at the operator \\'\\', and calculate the results for each sub-expression: \"23\" can be split into \"2\" and \"3\", and we can calculate the results for them as [2] and [3], respectively. Similarly, \"4*5\" can be split into \"4\" and \"5\", and we can calculate the results for them as [4] and [5], respectively.\\n\\nNext, we can combine the results for each sub-expression using the operator \\'-\\', which gives us the following possibilities: [2-4, 2-5, 3-4, 3-5]. Similarly, we can combine the results for each sub-expression using the operator \\'\\', which gives us the following possibilities: [24, 25, 34, 3*5].\\n\\nFinally, we can combine the results using the operator \\'-\\', which gives us the final results: [-34, -10, -14, -10, 10].\\n\\nAlgorithm:\\n\\n1. Define a function diffWaysToCompute() which accepts the input expression string inputStr.\\n2. If the input string only has digits, return a list with that number.\\n3. Iterate through each character of the input string inputStr and check if it is an operator or not.\\n4. If the character is an operator, recursively call the diffWaysToCompute() function for the left and right substrings of the operator, and combine the results using the operator.\\n5. Append the result to the output list outputList.\\n6. Return the outputList.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def diffWaysToCompute(self, inputStr: str) -> List[int]:\\n        \\n        # Define a function to calculate the result of the given operator between two numbers\\n        def calc(left, right, operator):\\n            if operator == \\'+\\':\\n                return left + right\\n            elif operator == \\'-\\':\\n                return left - right\\n            elif operator == \\'*\\':\\n                return left * right\\n        \\n        # Define the main function to calculate all possible results\\n        def diffWaysToComputeHelper(inputStr):\\n            \\n            # If the input string only has digits, return a list with that number\\n            if inputStr.isdigit():\\n                return [int(inputStr)]\\n            \\n            # Initialize the output list\\n            outputList = []\\n            \\n            # Iterate through each character of the input string and check if it is an operator or not\\n            for i in range(len(inputStr)):\\n                if inputStr[i] in [\\'+\\', \\'-\\', \\'*\\']:\\n                    \\n                    # Recursively call the `diffWaysToCompute()` function for the left and right substrings of the operator\\n                    leftResults = diffWaysToComputeHelper(inputStr[:i])\\n                    rightResults = diffWaysToComputeHelper(inputStr[i+1:])\\n                    \\n                    # Combine the results using the operator\\n                    for left in leftResults:\\n                        for right in rightResults:\\n                            outputList.append(calc(left, right, inputStr[i]))\\n            \\n            # Return the output list\\n            return outputList\\n        \\n        # Call the helper function\\n        return diffWaysToComputeHelper(inputStr)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def diffWaysToCompute(self, inputStr: str) -> List[int]:\\n        \\n        # Define a function to calculate the result of the given operator between two numbers\\n        def calc(left, right, operator):\\n            if operator == \\'+\\':\\n                return left + right\\n            elif operator == \\'-\\':\\n                return left - right\\n            elif operator == \\'*\\':\\n                return left * right\\n        \\n        # Define the main function to calculate all possible results\\n        def diffWaysToComputeHelper(inputStr):\\n            \\n            # If the input string only has digits, return a list with that number\\n            if inputStr.isdigit():\\n                return [int(inputStr)]\\n            \\n            # Initialize the output list\\n            outputList = []\\n            \\n            # Iterate through each character of the input string and check if it is an operator or not\\n            for i in range(len(inputStr)):\\n                if inputStr[i] in [\\'+\\', \\'-\\', \\'*\\']:\\n                    \\n                    # Recursively call the `diffWaysToCompute()` function for the left and right substrings of the operator\\n                    leftResults = diffWaysToComputeHelper(inputStr[:i])\\n                    rightResults = diffWaysToComputeHelper(inputStr[i+1:])\\n                    \\n                    # Combine the results using the operator\\n                    for left in leftResults:\\n                        for right in rightResults:\\n                            outputList.append(calc(left, right, inputStr[i]))\\n            \\n            # Return the output list\\n            return outputList\\n        \\n        # Call the helper function\\n        return diffWaysToComputeHelper(inputStr)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312433,
                "title": "c-faster-than-100-using-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> df(vector<string> &v,int l,int h)\\n    {\\n        //cout<<l<<\" \"<<h<<endl;\\n        vector<int> a;\\n        if(l==h)\\n        {\\n            a.push_back(stoi(v[l]));\\n            return a;\\n        }\\n        for(int i=l;i<=h;i++)\\n        {\\n            if(v[i]==\"+\")\\n            {\\n                vector<int> x=df(v,l,i-1);\\n                vector<int> y=df(v,i+1,h);\\n                for(int j=0;j<x.size();j++)\\n                {\\n                    for(int k=0;k<y.size();k++)\\n                    {\\n                        a.push_back(x[j]+y[k]);\\n                    }\\n                }\\n            }\\n            else if(v[i]==\"-\")\\n            {\\n                vector<int> x=df(v,l,i-1);\\n                vector<int> y=df(v,i+1,h);\\n                for(int j=0;j<x.size();j++)\\n                {\\n                    for(int k=0;k<y.size();k++)\\n                    {\\n                        a.push_back(x[j]-y[k]);\\n                    }\\n                }\\n            }\\n            else if(v[i]==\"*\")\\n            {\\n                vector<int> x=df(v,l,i-1);\\n                vector<int> y=df(v,i+1,h);\\n                for(int j=0;j<x.size();j++)\\n                {\\n                    for(int k=0;k<y.size();k++)\\n                    {\\n                        a.push_back(x[j]*y[k]);\\n                    }\\n                }\\n            }\\n        }\\n        return a;\\n    }\\n    vector<int> diffWaysToCompute(string s) {\\n        vector<string> v;\\n        string x;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'+\\' || s[i]==\\'-\\' || s[i]==\\'*\\')\\n            {\\n                v.push_back(x);\\n                x.clear();\\n                x+=s[i];\\n                v.push_back(x);\\n                x.clear();\\n            }\\n            else\\n            {\\n                x+=s[i];\\n            }\\n        }\\n        v.push_back(x);\\n        vector<int> ans=df(v,0,v.size()-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> df(vector<string> &v,int l,int h)\\n    {\\n        //cout<<l<<\" \"<<h<<endl;\\n        vector<int> a;\\n        if(l==h)\\n        {\\n            a.push_back(stoi(v[l]));\\n            return a;\\n        }\\n        for(int i=l;i<=h;i++)\\n        {\\n            if(v[i]==\"+\")\\n            {\\n                vector<int> x=df(v,l,i-1);\\n                vector<int> y=df(v,i+1,h);\\n                for(int j=0;j<x.size();j++)\\n                {\\n                    for(int k=0;k<y.size();k++)\\n                    {\\n                        a.push_back(x[j]+y[k]);\\n                    }\\n                }\\n            }\\n            else if(v[i]==\"-\")\\n            {\\n                vector<int> x=df(v,l,i-1);\\n                vector<int> y=df(v,i+1,h);\\n                for(int j=0;j<x.size();j++)\\n                {\\n                    for(int k=0;k<y.size();k++)\\n                    {\\n                        a.push_back(x[j]-y[k]);\\n                    }\\n                }\\n            }\\n            else if(v[i]==\"*\")\\n            {\\n                vector<int> x=df(v,l,i-1);\\n                vector<int> y=df(v,i+1,h);\\n                for(int j=0;j<x.size();j++)\\n                {\\n                    for(int k=0;k<y.size();k++)\\n                    {\\n                        a.push_back(x[j]*y[k]);\\n                    }\\n                }\\n            }\\n        }\\n        return a;\\n    }\\n    vector<int> diffWaysToCompute(string s) {\\n        vector<string> v;\\n        string x;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'+\\' || s[i]==\\'-\\' || s[i]==\\'*\\')\\n            {\\n                v.push_back(x);\\n                x.clear();\\n                x+=s[i];\\n                v.push_back(x);\\n                x.clear();\\n            }\\n            else\\n            {\\n                x+=s[i];\\n            }\\n        }\\n        v.push_back(x);\\n        vector<int> ans=df(v,0,v.size()-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1130825,
                "title": "recursive-solution-in-c",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    // This function tests whether the string contains any opeartor in index between start and end\\n    bool has_operator(string s,int start,int end)\\n    {\\n        for(int i=start;i<=end;i++)\\n        {\\n            if(s[i]==\\'+\\' || s[i]==\\'-\\' || s[i]==\\'*\\')\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    // This is the helper function to generate all the valid results \\n    vector<int> helper(string &s,int start,int end)\\n    {\\n        // Base case\\n        if(!has_operator(s,start,end))\\n        {\\n            return {stoi(s.substr(start,end+1))};\\n        }\\n        // Recursive case\\n        vector<int>ans;\\n        for(int i=start;i<=end;i++)\\n        {\\n            if(s[i]==\\'+\\' || s[i]==\\'-\\' || s[i]==\\'*\\')\\n            {   // If we have found an operator then get the result vector from the left side and from the right side of the string and combine each result of left side to each result of right side and store the results in the answer vector\\n                vector<int>first=helper(s,start,i-1);\\n                vector<int>second=helper(s,i+1,end);\\n                for(auto x:first)\\n                {\\n                    for(auto y:second)\\n                    {\\n                        int res;\\n                        if(s[i]==\\'+\\')\\n                        {\\n                            res=x+y;\\n                        }\\n                        else if(s[i]==\\'-\\')\\n                        {\\n                            res=x-y;\\n                        }\\n                        else if(s[i]==\\'*\\')\\n                        {\\n                            res=x*y;\\n                        }\\n                        ans.push_back(res);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> diffWaysToCompute(string expression) \\n    {\\n        return helper(expression,0,expression.length()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    // This function tests whether the string contains any opeartor in index between start and end\\n    bool has_operator(string s,int start,int end)\\n    {\\n        for(int i=start;i<=end;i++)\\n        {\\n            if(s[i]==\\'+\\' || s[i]==\\'-\\' || s[i]==\\'*\\')\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    // This is the helper function to generate all the valid results \\n    vector<int> helper(string &s,int start,int end)\\n    {\\n        // Base case\\n        if(!has_operator(s,start,end))\\n        {\\n            return {stoi(s.substr(start,end+1))};\\n        }\\n        // Recursive case\\n        vector<int>ans;\\n        for(int i=start;i<=end;i++)\\n        {\\n            if(s[i]==\\'+\\' || s[i]==\\'-\\' || s[i]==\\'*\\')\\n            {   // If we have found an operator then get the result vector from the left side and from the right side of the string and combine each result of left side to each result of right side and store the results in the answer vector\\n                vector<int>first=helper(s,start,i-1);\\n                vector<int>second=helper(s,i+1,end);\\n                for(auto x:first)\\n                {\\n                    for(auto y:second)\\n                    {\\n                        int res;\\n                        if(s[i]==\\'+\\')\\n                        {\\n                            res=x+y;\\n                        }\\n                        else if(s[i]==\\'-\\')\\n                        {\\n                            res=x-y;\\n                        }\\n                        else if(s[i]==\\'*\\')\\n                        {\\n                            res=x*y;\\n                        }\\n                        ans.push_back(res);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> diffWaysToCompute(string expression) \\n    {\\n        return helper(expression,0,expression.length()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 677792,
                "title": "javascript-solution",
                "content": "### The idea\\n1. `diffWaysToCompute` will always return an array of results from the different ways to compute an input\\n2. Whenever we meet an operator, we can recursively apply `diffWaysToCompute` on its left part and right part, and mix & match those results\\n3. The base case is where there is no operator in the input, which we ll always return `[input]`\\n\\n```\\n/**\\n * @param {string} input\\n * @return {number[]}\\n */\\nvar diffWaysToCompute = function(input) {    \\n    let res = [];\\n    for (let i = 0; i < input.length; i++) {\\n        if (isNaN(input[i])) {\\n            let left = diffWaysToCompute(input.slice(0, i));\\n            let right = diffWaysToCompute(input.slice(i+1));\\n            for (let l of left) {\\n                for (let r of right) {\\n                    l = Number(l);\\n                    r = Number(r);\\n                    \\n                    if (input[i]==\\'+\\') {\\n                        res.push(l + r);       \\n                    } else if (input[i]==\\'-\\') {\\n                        res.push(l - r);\\n                    } else {\\n                        res.push(l * r);\\n                    }\\n\\n                }\\n            }\\n        }\\n    }\\n    \\n    if (res.length!=0) return res;\\n    return [input];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} input\\n * @return {number[]}\\n */\\nvar diffWaysToCompute = function(input) {    \\n    let res = [];\\n    for (let i = 0; i < input.length; i++) {\\n        if (isNaN(input[i])) {\\n            let left = diffWaysToCompute(input.slice(0, i));\\n            let right = diffWaysToCompute(input.slice(i+1));\\n            for (let l of left) {\\n                for (let r of right) {\\n                    l = Number(l);\\n                    r = Number(r);\\n                    \\n                    if (input[i]==\\'+\\') {\\n                        res.push(l + r);       \\n                    } else if (input[i]==\\'-\\') {\\n                        res.push(l - r);\\n                    } else {\\n                        res.push(l * r);\\n                    }\\n\\n                }\\n            }\\n        }\\n    }\\n    \\n    if (res.length!=0) return res;\\n    return [input];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 66341,
                "title": "an-intuitive-solution-accepted-as-best-in-c-along-with-detailed-explanation",
                "content": "A recursive solution is quite straight-forward for this kind of problem; then find the recursive equation is the first thing we should do:\\n\\n- according to the string we need to return an array of the different results from diverse parentheses adding;\\n- the parentheses actually changed the operators' execution sequence;\\n- traverse the string and once we found an operator then we can just split the string into left and right; as a result we will execute this operator in the last calculation operation -> as for the left and the right string we can just use this same method selecting each operator as the last recursively and so on till no operator -> when there is no operator in the string, we should just return the number via the string.\\n\\nBang! End of Story!\\n\\n> time and space complexity is determined by the amount of operators in the string\\n\\nSuppose there are k operators in the string, then the time and space cost will approximately be \\n\\n    k*(k/2)^2*(k/4)^4...1 which is derived from this equation T(k)=k*T(k/2)*T(k/2) \\n\\nSimple and intuitive enough along with nice space and time cost just used for searching the results, though some repeated search does happen but that's not a burden compared with the conciseness of this kind of method. So DP or Memoization might not be a good choice if you want to keep it simple and clean.\\n\\n\\n----------\\n\\n\\n    int* compute(char* s, int len, int* size)\\n    {\\n        int *arr = (int*)malloc(sizeof(int));\\n        *size = 0;\\n        int *arr0, *arr1; //prepared for storing the array of different results from left and right side of a operator;\\n        int size0=0, size1=0; //used to cooperate with arr0 and arr1 respectively;\\n        for(int i = 0; i < len; i++)\\n        {\\n            if(!isdigit(s[i]))\\n            {\\n                arr0 = compute(s, i, &size0); //compute the left part of the string and store it in arr0;\\n                arr1 = compute(s+i+1, len-i-1, &size1); //compute the right part;\\n                for(int j = 0; j < size0; j++)\\n                {\\n                    for(int k = 0; k < size1; k++)\\n                    {\\n                        switch(s[i])\\n                        {\\n                            case '-': arr[*size] = arr0[j]-arr1[k]; break;\\n                            case '+': arr[*size] = arr0[j]+arr1[k]; break;\\n                            case '*': arr[*size] = arr0[j]*arr1[k]; break;\\n                            default: break;\\n                        }\\n                        *size += 1;\\n                        arr = (int*)realloc(arr, sizeof(int)*(*size+1)); //dynamically allocate space for arr;\\n                    }//end of arr1\\n                }//end of arr0;\\n            }\\n        }\\n        if(*size == 0) //there is no operator in s[0] - s[len-1], so just collect the number;\\n        {\\n            int t = 0;\\n            for(int i = 0; i < len; i++)\\n                t = 10*t + (s[i]-'0');\\n            arr[*size] = t;\\n            *size += 1;\\n        }\\n        return arr;\\n    }\\n    int* diffWaysToCompute(char* s, int* returnSize)\\n    {\\n        return compute(s, strlen(s), returnSize);\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "A recursive solution is quite straight-forward for this kind of problem; then find the recursive equation is the first thing we should do:\\n\\n- according to the string we need to return an array of the different results from diverse parentheses adding;\\n- the parentheses actually changed the operators' execution sequence;\\n- traverse the string and once we found an operator then we can just split the string into left and right; as a result we will execute this operator in the last calculation operation -> as for the left and the right string we can just use this same method selecting each operator as the last recursively and so on till no operator -> when there is no operator in the string, we should just return the number via the string.\\n\\nBang! End of Story!\\n\\n> time and space complexity is determined by the amount of operators in the string\\n\\nSuppose there are k operators in the string, then the time and space cost will approximately be \\n\\n    k*(k/2)^2*(k/4)^4...1 which is derived from this equation T(k)=k*T(k/2)*T(k/2) \\n\\nSimple and intuitive enough along with nice space and time cost just used for searching the results, though some repeated search does happen but that's not a burden compared with the conciseness of this kind of method. So DP or Memoization might not be a good choice if you want to keep it simple and clean.\\n\\n\\n----------\\n\\n\\n    int* compute(char* s, int len, int* size)\\n    {\\n        int *arr = (int*)malloc(sizeof(int));\\n        *size = 0;\\n        int *arr0, *arr1; //prepared for storing the array of different results from left and right side of a operator;\\n        int size0=0, size1=0; //used to cooperate with arr0 and arr1 respectively;\\n        for(int i = 0; i < len; i++)\\n        {\\n            if(!isdigit(s[i]))\\n            {\\n                arr0 = compute(s, i, &size0); //compute the left part of the string and store it in arr0;\\n                arr1 = compute(s+i+1, len-i-1, &size1); //compute the right part;\\n                for(int j = 0; j < size0; j++)\\n                {\\n                    for(int k = 0; k < size1; k++)\\n                    {\\n                        switch(s[i])\\n                        {\\n                            case '-': arr[*size] = arr0[j]-arr1[k]; break;\\n                            case '+': arr[*size] = arr0[j]+arr1[k]; break;\\n                            case '*': arr[*size] = arr0[j]*arr1[k]; break;\\n                            default: break;\\n                        }\\n                        *size += 1;\\n                        arr = (int*)realloc(arr, sizeof(int)*(*size+1)); //dynamically allocate space for arr;\\n                    }//end of arr1\\n                }//end of arr0;\\n            }\\n        }\\n        if(*size == 0) //there is no operator in s[0] - s[len-1], so just collect the number;\\n        {\\n            int t = 0;\\n            for(int i = 0; i < len; i++)\\n                t = 10*t + (s[i]-'0');\\n            arr[*size] = t;\\n            *size += 1;\\n        }\\n        return arr;\\n    }\\n    int* diffWaysToCompute(char* s, int* returnSize)\\n    {\\n        return compute(s, strlen(s), returnSize);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 66428,
                "title": "python-recursive-solution-easy-understand",
                "content": "    def diffWaysToCompute(self, inp):\\n        def helper(l, r):\\n            ans = []\\n            for i in range(l, r):\\n                if inp[i] not in ops:\\n                    continue\\n                ans += [ops[inp[i]](le, ri) for le in helper(l, i)\\n                                            for ri in helper(i + 1, r)]\\n            return ans if len(ans) != 0 else [int(inp[l:r])]\\n        ops = {\\n                '-': lambda x, y: x - y,\\n                '+': lambda x, y: x + y,\\n                '*': lambda x, y: x * y,\\n                }\\n        return helper(0, len(inp))",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "    def diffWaysToCompute(self, inp):\\n        def helper(l, r):\\n            ans = []\\n            for i in range(l, r):\\n                if inp[i] not in ops:\\n                    continue\\n                ans += [ops[inp[i]](le, ri) for le in helper(l, i)\\n                                            for ri in helper(i + 1, r)]\\n            return ans if len(ans) != 0 else [int(inp[l:r])]\\n        ops = {\\n                '-': lambda x, y: x - y,\\n                '+': lambda x, y: x + y,\\n                '*': lambda x, y: x * y,\\n                }\\n        return helper(0, len(inp))",
                "codeTag": "Python3"
            },
            {
                "id": 66457,
                "title": "python-solution-use-dp",
                "content": "First I extracted the numbers and operators in the expression. Assume there are d numbers and d-1 operators.\\ndp[ i ][ j ] is all possible results of expression contains num[ i : j+1 ].\\nSo the first loop we calculate expressions only have 2 numbers, then 3 numbers, then 4 numbers....\\nLet's say we want to get the result of expression contains L numbers started from num[ j ] , we divide it by two half, the first one contains k numbers, and the second half contains L-k numbers. The result of the first half is dp[ j ][ j+k-1 ] and the second half is dp[j+k-1][ j+l-1]. dp[ i ][ j ] contains all combinations of x from dp[ j ][ j+k-1 ] and y from dp[ j+k-1: j+l-1 ], and k is from 1 to l-1.\\n\\n\\n    import re\\n    class Solution:\\n        # @param {string} input\\n        # @return {integer[]}\\n        def diffWaysToCompute(self, input):\\n            num=re.split('\\\\+|-|\\\\*',input)\\n            opr=re.findall(r'\\\\+|-|\\\\*',input)\\n            d=len(num)\\n            dp=[[[]for i in range(d)] for j in range(d)]\\n            op={'+':lambda x,y:x+y, '-':lambda x,y:x-y, '*':lambda x,y:x*y}\\n            for i in range(d):\\n                dp[i][i].append(int(num[i]))\\n            for l in range(2,d+1):\\n                for j in range(d+1-l):\\n                        dp[j][j+l-1]=[op[opr[j+k-1]](x,y)\\n                                          for k in range(1,l) for x in dp[j][j+k-1] for y in dp[j+k][j+l-1]]\\n            return dp[0][d-1]",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n        # @param {string}",
                "codeTag": "Java"
            },
            {
                "id": 2565834,
                "title": "python-backtracking-recursive-faster-than-84-92",
                "content": "```\\nclass Solution:\\n    def diffWaysToCompute(self, expression: str) -> List[int]:\\n        #base case: if it\\'s a number, return it\\n        if expression.isnumeric():\\n            return [int(expression)]\\n        \\n        #general case\\n        res = []\\n        for i, char in enumerate(expression):\\n            if char in [\\'+\\', \\'-\\', \\'*\\']:\\n                left = self.diffWaysToCompute(expression[:i])\\n                right = self.diffWaysToCompute(expression[i+1:])\\n                \\n                for le in left:\\n                    for ri in right:\\n                        if char == \\'+\\':\\n                            res.append(le + ri)\\n                        elif char == \\'-\\':\\n                            res.append(le - ri)\\n                        else: # char == \\'*\\'\\n                            res.append(le * ri)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def diffWaysToCompute(self, expression: str) -> List[int]:\\n        #base case: if it\\'s a number, return it\\n        if expression.isnumeric():\\n            return [int(expression)]\\n        \\n        #general case\\n        res = []\\n        for i, char in enumerate(expression):\\n            if char in [\\'+\\', \\'-\\', \\'*\\']:\\n                left = self.diffWaysToCompute(expression[:i])\\n                right = self.diffWaysToCompute(expression[i+1:])\\n                \\n                for le in left:\\n                    for ri in right:\\n                        if char == \\'+\\':\\n                            res.append(le + ri)\\n                        elif char == \\'-\\':\\n                            res.append(le - ri)\\n                        else: # char == \\'*\\'\\n                            res.append(le * ri)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299887,
                "title": "java-divide-conquer-with-intuition",
                "content": "**Intuition:**\\n\\nAs the problem states to return the different possible answers if we place parentheses at different places to the given expression, we can try breaking the problem around the operands. \\n- Intuitively we can solve this problem using Divide and Conquer Algorithm by breaking the problem into 2 halves from every operand (`+`,`-`,`*`), the left half and the right half and then evaluate the left and right halves separately. \\n- The left and right halves can again be recursively divided into smaller left and right parts until we are left with no operands, i.e. having only numeric value in each part. \\n- Each recursive call of the left half and the right half can evaluate to one ore more values, and each of these evaluated value is a potential intermediate result to calculate the final result.\\n\\n**Code:**\\n\\n```\\nclass Solution {    \\n    public List<Integer> diffWaysToCompute(String expression) {        \\n        List<Integer> result = new ArrayList<>();\\n        for(int i=0; i < expression.length(); i++){\\n            char curr = expression.charAt(i);\\n            if (!Character.isDigit(curr)){\\n                List<Integer> leftParts = diffWaysToCompute(expression.substring(0, i));\\n                List<Integer> rightParts = diffWaysToCompute(expression.substring(i+1));\\n                evaluate(leftParts, rightParts, curr, result);\\n            }\\n        }\\n        if(isNumeric(expression)) result.add(Integer.valueOf(expression));\\n        return result;\\n    }\\n    \\n    private boolean isNumeric(String s){\\n        for(char c : s.toCharArray()) \\n            if(!Character.isDigit(c)) return false;\\n        return true;\\n    }\\n    \\n    private void evaluate(List<Integer> leftParts, List<Integer> rightParts, char operand, List<Integer> result){\\n        for(Integer left : leftParts){\\n            for(Integer right : rightParts){\\n                if(operand == \\'+\\') result.add(left + right);\\n                else if(operand == \\'-\\') result.add(left - right);\\n                else result.add(left * right);\\n            }\\n        }        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {    \\n    public List<Integer> diffWaysToCompute(String expression) {        \\n        List<Integer> result = new ArrayList<>();\\n        for(int i=0; i < expression.length(); i++){\\n            char curr = expression.charAt(i);\\n            if (!Character.isDigit(curr)){\\n                List<Integer> leftParts = diffWaysToCompute(expression.substring(0, i));\\n                List<Integer> rightParts = diffWaysToCompute(expression.substring(i+1));\\n                evaluate(leftParts, rightParts, curr, result);\\n            }\\n        }\\n        if(isNumeric(expression)) result.add(Integer.valueOf(expression));\\n        return result;\\n    }\\n    \\n    private boolean isNumeric(String s){\\n        for(char c : s.toCharArray()) \\n            if(!Character.isDigit(c)) return false;\\n        return true;\\n    }\\n    \\n    private void evaluate(List<Integer> leftParts, List<Integer> rightParts, char operand, List<Integer> result){\\n        for(Integer left : leftParts){\\n            for(Integer right : rightParts){\\n                if(operand == \\'+\\') result.add(left + right);\\n                else if(operand == \\'-\\') result.add(left - right);\\n                else result.add(left * right);\\n            }\\n        }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392799,
                "title": "python3-divide-and-conquer-recursion-memoization",
                "content": "```\\nclass Solution(object):\\n    def diffWaysToCompute(self, s, memo=dict()):\\n        if s in memo:\\n            return memo[s]\\n        if s.isdigit(): # base case\\n            return [int(s)]\\n        calculate = {\\'*\\': lambda x, y: x * y,\\n                     \\'+\\': lambda x, y: x + y,\\n                     \\'-\\': lambda x, y: x - y\\n                    }\\n        result = []\\n        for i, c in enumerate(s):\\n            if c in \\'+-*\\':\\n                left = self.diffWaysToCompute(s[:i], memo)\\n                right = self.diffWaysToCompute(s[i+1:], memo)\\n                for l in left:\\n                    for r in right:\\n                        result.append(calculate[c](l, r))\\n        memo[s] = result\\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution(object):\\n    def diffWaysToCompute(self, s, memo=dict()):\\n        if s in memo:\\n            return memo[s]\\n        if s.isdigit(): # base case\\n            return [int(s)]\\n        calculate = {\\'*\\': lambda x, y: x * y,\\n                     \\'+\\': lambda x, y: x + y,\\n                     \\'-\\': lambda x, y: x - y\\n                    }\\n        result = []\\n        for i, c in enumerate(s):\\n            if c in \\'+-*\\':\\n                left = self.diffWaysToCompute(s[:i], memo)\\n                right = self.diffWaysToCompute(s[i+1:], memo)\\n                for l in left:\\n                    for r in right:\\n                        result.append(calculate[c](l, r))\\n        memo[s] = result\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889964,
                "title": "java-1ms-code",
                "content": "* The Simple Idea is to spilt the expression at every operator and solve the splited expression.\\n* After attaining every possible value combine left and right.\\n```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String str) { \\n        HashMap<String,List<Integer>> map = new HashMap<>();\\n        List<Integer> res = new ArrayList<>();\\n        for(int i=0;i<str.length();i++){\\n            char ch = str.charAt(i);\\n            if(ch==\\'+\\'||ch==\\'-\\'||ch==\\'*\\'){\\n                List<Integer> left = map.getOrDefault(str,diffWaysToCompute(str.substring(0,i)));\\n                List<Integer> right = map.getOrDefault(str,diffWaysToCompute(str.substring(i+1)));\\n                for(Integer c1 : left){\\n                    for(Integer c2 : right){\\n                        if(ch == \\'+\\'){\\n                            res.add(c1+c2);\\n                        }\\n                        else if(ch == \\'-\\'){\\n                            res.add(c1-c2);\\n                        }\\n                        else if(ch == \\'*\\'){\\n                            res.add(c1*c2);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(res.size()==0)res.add(Integer.parseInt(str));\\n        map.put(str,res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String str) { \\n        HashMap<String,List<Integer>> map = new HashMap<>();\\n        List<Integer> res = new ArrayList<>();\\n        for(int i=0;i<str.length();i++){\\n            char ch = str.charAt(i);\\n            if(ch==\\'+\\'||ch==\\'-\\'||ch==\\'*\\'){\\n                List<Integer> left = map.getOrDefault(str,diffWaysToCompute(str.substring(0,i)));\\n                List<Integer> right = map.getOrDefault(str,diffWaysToCompute(str.substring(i+1)));\\n                for(Integer c1 : left){\\n                    for(Integer c2 : right){\\n                        if(ch == \\'+\\'){\\n                            res.add(c1+c2);\\n                        }\\n                        else if(ch == \\'-\\'){\\n                            res.add(c1-c2);\\n                        }\\n                        else if(ch == \\'*\\'){\\n                            res.add(c1*c2);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(res.size()==0)res.add(Integer.parseInt(str));\\n        map.put(str,res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402775,
                "title": "c-aditya-verma-mcm-pattern-recursion-memoization",
                "content": "```\\nclass Solution {\\nprivate:\\n    map<string, vector<int>>M;\\n\\npublic:\\n    vector<string> help(string &s)\\n    {\\n        vector<string> V;\\n        string t;\\n        \\n        for(auto c:s)\\n        {\\n            if(c == \\'+\\' or c == \\'-\\' or c == \\'*\\')\\n            {\\n                V.push_back(t);\\n                t = \"\";\\n                V.push_back(string(1, c));\\n            }\\n            else\\n                t += c;\\n        }\\n        \\n        if(t.size())\\n            V.push_back(t);\\n        \\n        return V;\\n    }\\n    \\n    vector<int> solve(vector<string>&s, int i, int j)\\n    {\\n        if(i == j)\\n            return vector<int>(1, stoi(s[i]));\\n        \\n        string key = to_string(i) + \"#\" + to_string(j);\\n        \\n        if(M.find(key) != M.end())\\n            return M[key];\\n        \\n        vector<int> ansInter;\\n        for(int k=i+1; k<j; k+=2)\\n        {\\n            vector<int> left = solve(s, i, k-1);\\n            vector<int> right = solve(s, k+1, j);\\n            \\n            for(auto l:left)\\n            {\\n                for(auto r:right)\\n                {\\n                    int ans;\\n                    if(s[k] == \"+\")\\n                        ans = l + r;\\n            \\n                    else if(s[k] == \"-\")\\n                        ans = l - r;\\n                    else\\n                        ans = l * r; \\n                    \\n                    ansInter.push_back(ans);\\n                }\\n            }\\n            \\n        }\\n        \\n        return M[key] = ansInter;\\n    }\\n    \\n    vector<int> diffWaysToCompute(string s) {\\n        \\n        vector<string> V = help(s);\\n        return solve(V, 0, V.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    map<string, vector<int>>M;\\n\\npublic:\\n    vector<string> help(string &s)\\n    {\\n        vector<string> V;\\n        string t;\\n        \\n        for(auto c:s)\\n        {\\n            if(c == \\'+\\' or c == \\'-\\' or c == \\'*\\')\\n            {\\n                V.push_back(t);\\n                t = \"\";\\n                V.push_back(string(1, c));\\n            }\\n            else\\n                t += c;\\n        }\\n        \\n        if(t.size())\\n            V.push_back(t);\\n        \\n        return V;\\n    }\\n    \\n    vector<int> solve(vector<string>&s, int i, int j)\\n    {\\n        if(i == j)\\n            return vector<int>(1, stoi(s[i]));\\n        \\n        string key = to_string(i) + \"#\" + to_string(j);\\n        \\n        if(M.find(key) != M.end())\\n            return M[key];\\n        \\n        vector<int> ansInter;\\n        for(int k=i+1; k<j; k+=2)\\n        {\\n            vector<int> left = solve(s, i, k-1);\\n            vector<int> right = solve(s, k+1, j);\\n            \\n            for(auto l:left)\\n            {\\n                for(auto r:right)\\n                {\\n                    int ans;\\n                    if(s[k] == \"+\")\\n                        ans = l + r;\\n            \\n                    else if(s[k] == \"-\")\\n                        ans = l - r;\\n                    else\\n                        ans = l * r; \\n                    \\n                    ansInter.push_back(ans);\\n                }\\n            }\\n            \\n        }\\n        \\n        return M[key] = ansInter;\\n    }\\n    \\n    vector<int> diffWaysToCompute(string s) {\\n        \\n        vector<string> V = help(s);\\n        return solve(V, 0, V.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66431,
                "title": "clean-ac-c-solution-with-explanation",
                "content": "The idea is that you just search through the string, and find the operators position, then recursively solve the results of the left and right of the operator, and once having the left and right results, compute the final result with the operator.\\n\\n    class Solution {\\n    public:\\n        vector<int> diffWaysToCompute(string input) {\\n            map<string, vector<int>> cache;\\n            return diffWaysToCompute(input, 0, input.size()-1, cache);\\n        }\\n    private:\\n        vector<int> diffWaysToCompute(string& input, int start, int end, map<string, vector<int>>& cache) {\\n            string key=to_string(start)+to_string(end);\\n            if(cache.count(key)) return cache[key];\\n            vector<int> result;\\n            int num=0;\\n    \\t    for(int i=start; i<=end; ++i) {\\n    \\t        if(input[i]!='+' && input[i]!='-' && input[i]!='*')\\n    \\t            num=num*10+(input[i]-'0');\\n    \\t\\t    else{ \\n        \\t\\t    vector<int> left=diffWaysToCompute(input, start, i-1, cache);\\n        \\t\\t    vector<int> right=diffWaysToCompute(input, i+1, end, cache);\\n        \\t\\t    for(int l=0; l<left.size(); ++l){\\n        \\t\\t        for(int r=0; r<right.size(); ++r){\\n        \\t\\t            if(input[i]=='+'){\\n        \\t\\t                result.push_back(left[l]+right[r]);\\n        \\t\\t            }else if(input[i]=='-'){\\n        \\t\\t                result.push_back(left[l]-right[r]);\\n        \\t\\t            }else if(input[i]=='*'){\\n        \\t\\t                result.push_back(left[l]*right[r]);\\n        \\t\\t            }               \\n        \\t\\t        }\\n        \\t\\t    }\\n    \\t\\t    }    \\n            }\\n            if(result.size()==0) result.push_back(num); //only single number\\n            return cache[key]=result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> diffWaysToCompute(string input) {\\n            map<string, vector<int>> cache;\\n            return diffWaysToCompute(input, 0, input.size()-1, cache);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1836822,
                "title": "java-1-ms-solution-easy-to-understand-beginner-friendly-recursion",
                "content": "```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String exp) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(int i=0;i<exp.length();i++)\\n        {\\n            char ch = exp.charAt(i);\\n            if(ch == \\'-\\' || ch == \\'+\\' || ch == \\'*\\')\\n            {\\n                List<Integer> left = diffWaysToCompute(exp.substring(0,i));\\n                List<Integer> right = diffWaysToCompute(exp.substring(i+1));\\n                for(int m : left)\\n                {\\n                    for(int n : right)\\n                    {\\n                        if(ch == \\'-\\')\\n                            list.add(m-n);\\n                        else if(ch == \\'+\\')\\n                            list.add(m+n);\\n                        else list.add(m*n);\\n                    }\\n                }\\n            }\\n        }\\n        if(list.size() == 0)\\n            list.add(Integer.valueOf(exp));\\n        return list;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String exp) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(int i=0;i<exp.length();i++)\\n        {\\n            char ch = exp.charAt(i);\\n            if(ch == \\'-\\' || ch == \\'+\\' || ch == \\'*\\')\\n            {\\n                List<Integer> left = diffWaysToCompute(exp.substring(0,i));\\n                List<Integer> right = diffWaysToCompute(exp.substring(i+1));\\n                for(int m : left)\\n                {\\n                    for(int n : right)\\n                    {\\n                        if(ch == \\'-\\')\\n                            list.add(m-n);\\n                        else if(ch == \\'+\\')\\n                            list.add(m+n);\\n                        else list.add(m*n);\\n                    }\\n                }\\n            }\\n        }\\n        if(list.size() == 0)\\n            list.add(Integer.valueOf(exp));\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184602,
                "title": "java-easy-recursive-memorization-beats-100",
                "content": "This solution uses memorization, it\\'s very similar to other top solutions but as opposed to using substring I broke it out into a seperate method and only used substring when actually getting the integer values. Other than that since we really only have the start, and ending index as unique parts of our recursive calls we can store that in a memorization array, in this case our code returns lists, no problem simply make that what we store.\\n\\n```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String expression) {\\n      \\n        List[][] memo = new List[expression.length() + 1][expression.length() + 1];  \\n        return ways(expression,0,expression.length(),memo);\\n        \\n    }\\n    \\n    private List<Integer> ways(String expression, int start, int end, List[][] memo){\\n\\n        if(memo[start][end] != null) return memo[start][end];\\n         \\n        List<Integer> res = new ArrayList<>();\\n        \\n        for(int i=start; i < end; i++){\\n            char curr = expression.charAt(i);\\n            \\n            if(curr != \\'+\\' && curr != \\'-\\' && curr != \\'*\\')\\n                continue;\\n\\n            List<Integer> leftVals = ways(expression,start,i,memo);\\n            List<Integer> rightVals = ways(expression,i+1,end,memo);\\n            \\n            for(int leftVal: leftVals){\\n                for(int rightVal: rightVals){\\n                    \\n                    if(curr == \\'+\\'){\\n                        //System.out.println(expression.substring(0,i) + \" + \" + expression.substring(i+1));\\n                        res.add(leftVal + rightVal);\\n                    }\\n                    if(curr == \\'-\\'){\\n                       // System.out.println(expression.substring(0,i) + \" - \" + expression.substring(i+1));\\n                        res.add(leftVal - rightVal);\\n                    }\\n                    if(curr == \\'*\\'){\\n                       // System.out.println(expression.substring(0,i) + \" * \" + expression.substring(i+1));\\n                        res.add(leftVal * rightVal);\\n                    }\\n                }\\n            }\\n           \\n            \\n        }\\n        \\n        // integer\\n        if(res.size() == 0) res.add(Integer.valueOf(expression.substring(start,end)));\\n        \\n        memo[start][end] = res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String expression) {\\n      \\n        List[][] memo = new List[expression.length() + 1][expression.length() + 1];  \\n        return ways(expression,0,expression.length(),memo);\\n        \\n    }\\n    \\n    private List<Integer> ways(String expression, int start, int end, List[][] memo){\\n\\n        if(memo[start][end] != null) return memo[start][end];\\n         \\n        List<Integer> res = new ArrayList<>();\\n        \\n        for(int i=start; i < end; i++){\\n            char curr = expression.charAt(i);\\n            \\n            if(curr != \\'+\\' && curr != \\'-\\' && curr != \\'*\\')\\n                continue;\\n\\n            List<Integer> leftVals = ways(expression,start,i,memo);\\n            List<Integer> rightVals = ways(expression,i+1,end,memo);\\n            \\n            for(int leftVal: leftVals){\\n                for(int rightVal: rightVals){\\n                    \\n                    if(curr == \\'+\\'){\\n                        //System.out.println(expression.substring(0,i) + \" + \" + expression.substring(i+1));\\n                        res.add(leftVal + rightVal);\\n                    }\\n                    if(curr == \\'-\\'){\\n                       // System.out.println(expression.substring(0,i) + \" - \" + expression.substring(i+1));\\n                        res.add(leftVal - rightVal);\\n                    }\\n                    if(curr == \\'*\\'){\\n                       // System.out.println(expression.substring(0,i) + \" * \" + expression.substring(i+1));\\n                        res.add(leftVal * rightVal);\\n                    }\\n                }\\n            }\\n           \\n            \\n        }\\n        \\n        // integer\\n        if(res.size() == 0) res.add(Integer.valueOf(expression.substring(start,end)));\\n        \\n        memo[start][end] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184505,
                "title": "java-clean-concise-code-divide-conquer-technique-100-optimal-code",
                "content": "```\\nclass Solution {\\n    \\n    private boolean isOperator (char operator) {\\n        \\n        return operator == \\'+\\' || operator == \\'-\\' || operator == \\'*\\' || operator == \\'/\\';\\n    }\\n    \\n    private int calculateValue (int a, int b, char operator) {\\n        \\n        if (operator == \\'+\\') {\\n            return a + b;\\n        }\\n        else if (operator == \\'-\\') {\\n            return a - b;\\n        }\\n        else if (operator == \\'*\\') {\\n            return a * b;\\n        }\\n        else {\\n            return a / b;\\n        }\\n    }\\n    \\n    public List<Integer> diffWaysToCompute(String expression) {\\n        \\n        List<Integer> answer = new ArrayList<> ();\\n        \\n        for (int i = 0; i < expression.length (); i++) {\\n            char operator = expression.charAt (i);\\n            if (isOperator (operator)) {\\n                List<Integer> list1 = diffWaysToCompute (expression.substring (0, i));\\n                List<Integer> list2 = diffWaysToCompute (expression.substring (i + 1));\\n                \\n                for (int j = 0; j < list1.size (); j++) {\\n                    for (int k = 0; k < list2.size (); k++) {\\n                        answer.add (calculateValue (list1.get (j), list2.get (k), operator));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (answer.size () == 0) {\\n            answer.add (Integer.valueOf (expression));\\n            return answer;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private boolean isOperator (char operator) {\\n        \\n        return operator == \\'+\\' || operator == \\'-\\' || operator == \\'*\\' || operator == \\'/\\';\\n    }\\n    \\n    private int calculateValue (int a, int b, char operator) {\\n        \\n        if (operator == \\'+\\') {\\n            return a + b;\\n        }\\n        else if (operator == \\'-\\') {\\n            return a - b;\\n        }\\n        else if (operator == \\'*\\') {\\n            return a * b;\\n        }\\n        else {\\n            return a / b;\\n        }\\n    }\\n    \\n    public List<Integer> diffWaysToCompute(String expression) {\\n        \\n        List<Integer> answer = new ArrayList<> ();\\n        \\n        for (int i = 0; i < expression.length (); i++) {\\n            char operator = expression.charAt (i);\\n            if (isOperator (operator)) {\\n                List<Integer> list1 = diffWaysToCompute (expression.substring (0, i));\\n                List<Integer> list2 = diffWaysToCompute (expression.substring (i + 1));\\n                \\n                for (int j = 0; j < list1.size (); j++) {\\n                    for (int k = 0; k < list2.size (); k++) {\\n                        answer.add (calculateValue (list1.get (j), list2.get (k), operator));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (answer.size () == 0) {\\n            answer.add (Integer.valueOf (expression));\\n            return answer;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629328,
                "title": "python-elegant-divide-and-conquer-recursive-solution",
                "content": "```python\\nclass Solution:\\n    def diffWaysToCompute(self, input: str) -> List[int]:\\n        if input.isdigit():\\n            return [int(input)]\\n        \\n        res = []\\n        for i in range(len(input)):\\n            if input[i] in \\'+-*/\\':\\n                left = self.diffWaysToCompute(input[:i])\\n                right = self.diffWaysToCompute(input[i + 1:])\\n                res.extend(eval(f\"{l}{input[i]}{r}\") for l in left for r in right)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def diffWaysToCompute(self, input: str) -> List[int]:\\n        if input.isdigit():\\n            return [int(input)]\\n        \\n        res = []\\n        for i in range(len(input)):\\n            if input[i] in \\'+-*/\\':\\n                left = self.diffWaysToCompute(input[:i])\\n                right = self.diffWaysToCompute(input[i + 1:])\\n                res.extend(eval(f\"{l}{input[i]}{r}\") for l in left for r in right)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 318396,
                "title": "java-dp-solution-beats-100",
                "content": "\\n\\nJava DP version based on a solution posted by @todor91 in one thread\\n\\n```\\nclass Solution {\\n    private Map<String, List> map = new HashMap<>();\\n    \\n    public List<Integer> diffWaysToCompute(String input) {\\n        if (map.containsKey(input)) return map.get(input);\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < input.length(); ++i) {\\n            if (input.charAt(i) < \\'0\\') {\\n                List<Integer> v1 = diffWaysToCompute(input.substring(0, i));\\n                List<Integer> v2 = diffWaysToCompute(input.substring(i + 1));\\n                for (int i1 : v1) for (int i2 : v2) switch (input.charAt(i)) {\\n                    case \\'+\\': res.add(i1 + i2); break;\\n                    case \\'-\\': res.add(i1 - i2); break;\\n                    case \\'*\\': res.add(i1 * i2);\\n                }\\n            }\\n        }\\n        if (res.isEmpty()) res.add(Integer.parseInt(input));\\n        map.put(input, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private Map<String, List> map = new HashMap<>();\\n    \\n    public List<Integer> diffWaysToCompute(String input) {\\n        if (map.containsKey(input)) return map.get(input);\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < input.length(); ++i) {\\n            if (input.charAt(i) < \\'0\\') {\\n                List<Integer> v1 = diffWaysToCompute(input.substring(0, i));\\n                List<Integer> v2 = diffWaysToCompute(input.substring(i + 1));\\n                for (int i1 : v1) for (int i2 : v2) switch (input.charAt(i)) {\\n                    case \\'+\\': res.add(i1 + i2); break;\\n                    case \\'-\\': res.add(i1 - i2); break;\\n                    case \\'*\\': res.add(i1 * i2);\\n                }\\n            }\\n        }\\n        if (res.isEmpty()) res.add(Integer.parseInt(input));\\n        map.put(input, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66452,
                "title": "divide-and-conquer-cache-java-260ms",
                "content": "Thanks @2guotou , he is really a smart guy who shared the elegant solution. I have some improvements based on his idea.\\nhttps://leetcode.com/discuss/48477/a-recursive-java-solution-284-ms\\n\\n    // Divide and conquer + cache, recursive\\n    public class Solution {\\n        private static Map<String, List<Integer>> cache = new HashMap<>();\\n        private static Set<Character> operators = new HashSet<>();\\n        static { operators.add('+');  operators.add('-');  operators.add('*'); }\\n        \\n        public List<Integer> diffWaysToCompute(String input) {\\n            if (cache.containsKey(input))  return cache.get(input);\\n            \\n            List<Integer> res = new LinkedList<>();\\n            int N = input.length();\\n            \\n            // general case\\n            for (int i = 0; i < N; i++) {\\n                char c = input.charAt(i);\\n                if (operators.contains(c)) {\\n                    // divide into two parts\\n                    String leftPart  = input.substring(0, i);\\n                    String rightPart = input.substring(i + 1);\\n                    List<Integer> leftList  = diffWaysToCompute(leftPart);\\n                    List<Integer> rightList = diffWaysToCompute(rightPart);\\n                    \\n                    // merge the result\\n                    int sum = 0;\\n                    for (int le : leftList) {\\n                        for (int ri : rightList) {\\n                            switch (c) {\\n                                case '+': sum = le + ri; break;\\n                                case '-': sum = le - ri; break;\\n                                case '*': sum = le * ri; break;\\n                            }\\n                            res.add(sum);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            // base case\\n            if (res.isEmpty()) res.add(Integer.valueOf(input));\\n            \\n            cache.put(input, res);\\n            return res;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        private static Map<String, List<Integer>> cache = new HashMap<>();\\n        private static Set<Character> operators = new HashSet<>();\\n        static { operators.add('+');  operators.add('-');  operators.add('*'); }",
                "codeTag": "Java"
            },
            {
                "id": 2340077,
                "title": "python-partition-dp-aka-mcm-like-approach",
                "content": "1. Recursively split by op in a loop\\n```\\n       (2 * 3 - 4 * 5)\\n          |\\n       [2] (3 - 4 * 5) <-- recursively split by op in a loop\\n\\t          |\\n\\t          |-------------------------------------------------- <-- we have 2 branches here!!!\\n\\t          |                                                 |\\n           [3] (4 * 5) <-- recursively split by op in a loop   (3 - 4) * [5] <-- recursively split by op in a loop\\n\\t\\t          |                                               |\\n\\t\\t       [4] [5] <-- return *tokenized* values           [3] [4] <-- return *tokenized* values\\n\\t\\t\\t   ^\\n\\t\\t\\t   |\\n\\t\\t\\t   pay attention that you return an array of values all the time, I\\'ll explain\\n```\\nYour inner calls `solve((4*5))` function returns: `left = 4`, `right = 5`, `op = *`. You do `op` and return `20`\\nNow outer call to `solve((3-(4*5))` function returns `-17`\\nYour inner calls `solve((3-4))` function returns: `left = 3`, `right = 4`, `op = -`. You do `op` and return `-1`\\nNow outer call to `solve((3-4)*5))` function returns `-5`\\n\\nIt might seem that you would be good with just 3 vars `left, right, and op` and return **a single value**.\\n**!!! BUT !!!**\\nYou see there\\'s `we have 2 branches here!!!` ???\\n!!! This is where we figure out that **we need to return an array for `left` and `right` parts** after the expression split. !!!\\n\\nThus the pseudo code for the solve function is:\\n```\\nres = []\\nfor k in range(left, right + 1):\\n  left = solve(left, k - 1)\\n  right = solve(k + 1, right)\\n  for l in left:\\n    for r in right:\\n      if op = \\'+\\':\\n        res.append(l + r)  \\n\\t\\t...\\nif len(res) == 0: # could not process any signs, means we\\'re dealing with a number\\n  res.append(parse_number(left, right))\\n```\\nDivide & concur in action. Then do `op` on all left and right value combinations.\\n\\n---\\n\\nThe approach is quite similar to a partition dp type problems aka [Matrix chain multiplication](https://en.wikipedia.org/wiki/Matrix_chain_multiplication) variation (MCM).\\n\\nHere are similar problems. Most of these are hard and true DP.\\n* 312. Burst Balloons (partition based on inflating a ballon, instead of popping them)\\n* 1547. Minimum Cost to Cut a Stick (partition on a cut)\\n* 1000. Minimum Cost to Merge Stones ...\\n* 1039. Minimum Score Triangulation of Polygon ...\\n* 1130. Minimum Cost Tree From Leaf Values ...\\n\\nThe idea:\\n\\nYou \"partition\" (read as split into 2 parts, thus it\\'s D&C approach too) an expression in 2 parts by **operation**. Let\\'s look at the provided example:\\n\\nExample: `2 * 3 - 4 * 5`\\n\\n*Here, in the examples, I will use \"**) operation (**\" as a partition point*\\n\\n\"1st-level\" partitions:\\n\\n1st partition point: `(2) * (3-4*5)`\\n2nd partition point: `(2*3) - (4*5)`\\n3rd partition point: `(2*3-4) * (5)`\\n\\n\"2nd-level\" partitions:\\n* `(3-4*5)`\\n1st partition point: `(3) - (4*5)`\\n2nd partition point: `(3-4) * (5)`\\n* `(2*3-4)`\\n1st partition point: `(2) * (3-4)`\\n2nd partition point: `(2*3) - (4)`\\n\\n**The following is the most important part:**\\n\\n\"1st-level\" + 2 x \"2nd-level\" partitions will result in:\\n\\n`(2) * ((3) - (4*5))` and `(2) * ((3-4) * (5))`\\n\\nAs we can see from the expressions above in order to get the final result, **we will have 2 outputs from the above expressions,** we need to peform **left partition (2)** operation \"-\" **each of right partition cases `(3) - (4*5)`, `(3-4) * (5)`**.\\n\\nWhat if we have `(a * b + c) - (d * e - f)` ???\\n\\nWe will have to calc on the left side: `[\"(a) * (b + c)\", \"(a * b) + (c)\"]` and on the right side: `[\"(d) * (e - f)\", \"(d * e) - (f)\"]`. Let\\'s define previous expressions as `[A,B]` and `[C,D]`\\n\\nThe product of left partitioning and right partitioning will be: `[A - C], [A - D], [B - C], [B - D]`\\n\\n---\\n\\nHere is the longer version, but more readable:\\n\\n**Top-down approach (recursive):**\\n```\\nclass Solution:\\n    def diffWaysToCompute(self, s: str) -> List[int]:\\n        def solve(start, end):\\n            out = []\\n\\t\\t\\t# if the range is number - return number (as expressions look like \\'num operation num\\', so start and end are nums)\\n            if start == end:\\n                return [ops[start]]\\n            \\n\\t\\t\\t# split the list by each operation into left and right expressions\\n            for k in range(start + 1, end, 2): # operation is +2 away from another operation\\n                left = solve(start, k - 1) # up to operation char\\n                right = solve(k + 1, end) # right next after the operation char\\n\\n\\t\\t\\t\\t# product of left results \\'operation\\' right results\\n                for l in left:\\n                    for r in right:\\n                        if ops[k] == \"+\":\\n                            out.append(l + r)\\n                        elif ops[k] == \"-\":\\n                            out.append(l - r)\\n                        else:\\n                            out.append(l * r)\\n            \\n            return out\\n        \\n\\t\\t# convert string \"55*2+34\" to [55,\"*\",2,\"+\",34]\\n        ops = []\\n        for c in s:\\n            if not c.isnumeric():\\n                ops.append(c)\\n            else:\\n                if not ops or ops and type(ops[-1]) == type(\"\"):\\n                    ops.append(0)\\n                ops[-1] *= 10\\n                ops[-1] += int(c)\\n        \\n        N = len(ops)\\n        return solve(0, N - 1)\\n```\\n\\n**Recursive + memoization:**\\n```\\nclass Solution:\\n    def diffWaysToCompute(self, s: str) -> List[int]:\\n        @cache\\n        def solve(start, end):\\n            out = []\\n            for k in range(start, end + 1):\\n                c = s[k]\\n\\t\\t\\t\\t\\n                if c in (\"+\",\"-\",\"*\"):\\n                    left = solve(start, k - 1)\\n                    right = solve(k + 1, end)\\n\\t\\t\\t\\t\\t\\n                    for l in left:\\n                        for r in right:\\n                            if c == \"+\":\\n                                out.append(l + r)\\n                            elif c == \"-\":\\n                                out.append(l - r)\\n                            else:\\n                                out.append(l * r)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n            if not out: # nothing was split, must be a number\\n                out.append(int(s[start: end + 1]))\\n\\n            return out\\n\\n        N = len(s)\\n        return solve(0, N - 1)\\n```\\n\\n**Iterative approach:**\\n```\\nclass Solution:\\n    def diffWaysToCompute(self, s: str) -> List[int]:\\n        N = len(s)\\n        dp = [[[0]] * (N + 1) for _ in range(N + 1)]\\n        \\n        for start in reversed(range(N)):\\n            for end in range(start, N):\\n                out = []\\n                for k in range(start, end + 1):\\n                    c = s[k]\\n\\n                    if c in \"+-*\":\\n                        left = dp[start][k - 1]\\n                        right = dp[k + 1][end]\\n\\n                        if left and right:\\n                            for l,r in product(left, right):\\n                                if c == \"+\": out.append(l + r)\\n                                elif c == \"-\": out.append(l - r)\\n                                else: out.append(l * r)\\n\\n                if not out: out.append(int(s[start: end + 1]))\\n                dp[start][end] = out\\n\\n        return dp[0][N - 1]\\n```\\n\\nP.S. Regarding DP. Yes there are subproblems. Some are independent. Some are repeatable (overlapping). But there is no optimal substructure (at least in the case). So technically we are not optimizing anything here (the core of dp). This one will be a DP if you add some min/max/optimize (like in cut the stick or burst balloons problems). Here we used the same idea to **enumerate all possible** parenthesis placement + memo. Maybe iterative D&C.",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\n       (2 * 3 - 4 * 5)\\n          |\\n       [2] (3 - 4 * 5) <-- recursively split by op in a loop\\n\\t          |\\n\\t          |-------------------------------------------------- <-- we have 2 branches here!!!\\n\\t          |                                                 |\\n           [3] (4 * 5) <-- recursively split by op in a loop   (3 - 4) * [5] <-- recursively split by op in a loop\\n\\t\\t          |                                               |\\n\\t\\t       [4] [5] <-- return *tokenized* values           [3] [4] <-- return *tokenized* values\\n\\t\\t\\t   ^\\n\\t\\t\\t   |\\n\\t\\t\\t   pay attention that you return an array of values all the time, I\\'ll explain\\n```\n```\\nres = []\\nfor k in range(left, right + 1):\\n  left = solve(left, k - 1)\\n  right = solve(k + 1, right)\\n  for l in left:\\n    for r in right:\\n      if op = \\'+\\':\\n        res.append(l + r)  \\n\\t\\t...\\nif len(res) == 0: # could not process any signs, means we\\'re dealing with a number\\n  res.append(parse_number(left, right))\\n```\n```\\nclass Solution:\\n    def diffWaysToCompute(self, s: str) -> List[int]:\\n        def solve(start, end):\\n            out = []\\n\\t\\t\\t# if the range is number - return number (as expressions look like \\'num operation num\\', so start and end are nums)\\n            if start == end:\\n                return [ops[start]]\\n            \\n\\t\\t\\t# split the list by each operation into left and right expressions\\n            for k in range(start + 1, end, 2): # operation is +2 away from another operation\\n                left = solve(start, k - 1) # up to operation char\\n                right = solve(k + 1, end) # right next after the operation char\\n\\n\\t\\t\\t\\t# product of left results \\'operation\\' right results\\n                for l in left:\\n                    for r in right:\\n                        if ops[k] == \"+\":\\n                            out.append(l + r)\\n                        elif ops[k] == \"-\":\\n                            out.append(l - r)\\n                        else:\\n                            out.append(l * r)\\n            \\n            return out\\n        \\n\\t\\t# convert string \"55*2+34\" to [55,\"*\",2,\"+\",34]\\n        ops = []\\n        for c in s:\\n            if not c.isnumeric():\\n                ops.append(c)\\n            else:\\n                if not ops or ops and type(ops[-1]) == type(\"\"):\\n                    ops.append(0)\\n                ops[-1] *= 10\\n                ops[-1] += int(c)\\n        \\n        N = len(ops)\\n        return solve(0, N - 1)\\n```\n```\\nclass Solution:\\n    def diffWaysToCompute(self, s: str) -> List[int]:\\n        @cache\\n        def solve(start, end):\\n            out = []\\n            for k in range(start, end + 1):\\n                c = s[k]\\n\\t\\t\\t\\t\\n                if c in (\"+\",\"-\",\"*\"):\\n                    left = solve(start, k - 1)\\n                    right = solve(k + 1, end)\\n\\t\\t\\t\\t\\t\\n                    for l in left:\\n                        for r in right:\\n                            if c == \"+\":\\n                                out.append(l + r)\\n                            elif c == \"-\":\\n                                out.append(l - r)\\n                            else:\\n                                out.append(l * r)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n            if not out: # nothing was split, must be a number\\n                out.append(int(s[start: end + 1]))\\n\\n            return out\\n\\n        N = len(s)\\n        return solve(0, N - 1)\\n```\n```\\nclass Solution:\\n    def diffWaysToCompute(self, s: str) -> List[int]:\\n        N = len(s)\\n        dp = [[[0]] * (N + 1) for _ in range(N + 1)]\\n        \\n        for start in reversed(range(N)):\\n            for end in range(start, N):\\n                out = []\\n                for k in range(start, end + 1):\\n                    c = s[k]\\n\\n                    if c in \"+-*\":\\n                        left = dp[start][k - 1]\\n                        right = dp[k + 1][end]\\n\\n                        if left and right:\\n                            for l,r in product(left, right):\\n                                if c == \"+\": out.append(l + r)\\n                                elif c == \"-\": out.append(l - r)\\n                                else: out.append(l * r)\\n\\n                if not out: out.append(int(s[start: end + 1]))\\n                dp[start][end] = out\\n\\n        return dp[0][N - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899164,
                "title": "c-recursive-divide-and-conquer-with-comment",
                "content": "```c++\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string expression) {\\n        // idea: use the operator to tear the expression apart and recursively do this. \\n        vector<int> res;\\n        for (int i = 0; i < expression.size(); i++) {\\n            if (expression[i] == \\'+\\' || expression[i] ==\\'-\\' || expression[i] == \\'*\\') {\\n                // tear the expression apart -> left expression and right expression\\n                string left = expression.substr(0, i);\\n                string right = expression.substr(i+1, expression.size()-i-1);\\n                // cout << \"left: \" << left << \", operator: \" << expression[i] << \", right: \" << right << endl;\\n                vector<int> l = diffWaysToCompute(left);\\n                vector<int> r = diffWaysToCompute(right);\\n                \\n                // merge and get the combination of answers by two for loops according to the operator\\n                for (int j = 0; j < l.size(); j++) {\\n                    for (int k = 0; k < r.size(); k++) {\\n                        if (expression[i] == \\'+\\')\\n                            res.push_back(l[j] + r[k]);\\n                        if (expression[i] == \\'-\\')\\n                            res.push_back(l[j] - r[k]);\\n                        if (expression[i] == \\'*\\')\\n                            res.push_back(l[j] * r[k]);\\n                    }\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// the expression only contains the number, otherwise, the res definitely contains at least a number from the above for loop.\\n        if (res.empty()){\\n            int sum = stoi(expression);\\n            res.push_back(sum);\\n        }\\n        return res;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string expression) {\\n        // idea: use the operator to tear the expression apart and recursively do this. \\n        vector<int> res;\\n        for (int i = 0; i < expression.size(); i++) {\\n            if (expression[i] == \\'+\\' || expression[i] ==\\'-\\' || expression[i] == \\'*\\') {\\n                // tear the expression apart -> left expression and right expression\\n                string left = expression.substr(0, i);\\n                string right = expression.substr(i+1, expression.size()-i-1);\\n                // cout << \"left: \" << left << \", operator: \" << expression[i] << \", right: \" << right << endl;\\n                vector<int> l = diffWaysToCompute(left);\\n                vector<int> r = diffWaysToCompute(right);\\n                \\n                // merge and get the combination of answers by two for loops according to the operator\\n                for (int j = 0; j < l.size(); j++) {\\n                    for (int k = 0; k < r.size(); k++) {\\n                        if (expression[i] == \\'+\\')\\n                            res.push_back(l[j] + r[k]);\\n                        if (expression[i] == \\'-\\')\\n                            res.push_back(l[j] - r[k]);\\n                        if (expression[i] == \\'*\\')\\n                            res.push_back(l[j] * r[k]);\\n                    }\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// the expression only contains the number, otherwise, the res definitely contains at least a number from the above for loop.\\n        if (res.empty()){\\n            int sum = stoi(expression);\\n            res.push_back(sum);\\n        }\\n        return res;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1797052,
                "title": "java-recursive-solution",
                "content": "The problem becomes easier when we think about these expressions as expression trees.\\nWe can traverse over the experssion and whenever we encounter an operator, we recursively divide the expression into left and right part and evaluate them seperately until we reach a situation where our expression is purely a number and in this case we can simply return that number.\\nSince there can be multiple ways to evaluate an expression (depending on which operator you take first) we will get a list of reults from left and the right part.\\nNow that we have all the possible results from the left and the right part, we can use them to find out all the possible results for the current operator.\\n![](https://assets.leetcode.com/users/images/811924c6-d550-4135-909c-e10f7a58af26_1624537462.121658.png)\\n\\n```\\nclass Solution {\\n    private int perform(int a, int b, char c){\\n        if(c==\\'+\\'){\\n            return a+b;\\n        }else if(c==\\'-\\'){\\n            return a-b;\\n        }else if(c==\\'*\\'){\\n            return a*b;\\n        }\\n        return 0;\\n    }\\n    public List<Integer> diffWaysToCompute(String expression) {\\n        boolean isNumeric=true;\\n        List<Integer> dp = new ArrayList<Integer>();\\n        for(int i=0; i<expression.length(); i++){\\n            char c = expression.charAt(i);\\n            if(c == \\'*\\' || c == \\'-\\' || c == \\'+\\'){\\n                isNumeric = false;\\n                List<Integer> left = diffWaysToCompute(expression.substring(0, i));\\n                List<Integer> right = diffWaysToCompute(expression.substring(i+1, expression.length()));\\n                for(int l=0; l<left.size(); l++){\\n                    for(int r=0; r<right.size(); r++){\\n                        dp.add(perform(left.get(l), right.get(r), c));\\n                    }   \\n                }\\n            }\\n        }\\n        if(isNumeric){\\n            dp.add(Integer.parseInt(expression));\\n        }\\n        return dp;\\n    }\\n}\\n```\\n\\nPlease upvote if it was helpful.",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private int perform(int a, int b, char c){\\n        if(c==\\'+\\'){\\n            return a+b;\\n        }else if(c==\\'-\\'){\\n            return a-b;\\n        }else if(c==\\'*\\'){\\n            return a*b;\\n        }\\n        return 0;\\n    }\\n    public List<Integer> diffWaysToCompute(String expression) {\\n        boolean isNumeric=true;\\n        List<Integer> dp = new ArrayList<Integer>();\\n        for(int i=0; i<expression.length(); i++){\\n            char c = expression.charAt(i);\\n            if(c == \\'*\\' || c == \\'-\\' || c == \\'+\\'){\\n                isNumeric = false;\\n                List<Integer> left = diffWaysToCompute(expression.substring(0, i));\\n                List<Integer> right = diffWaysToCompute(expression.substring(i+1, expression.length()));\\n                for(int l=0; l<left.size(); l++){\\n                    for(int r=0; r<right.size(); r++){\\n                        dp.add(perform(left.get(l), right.get(r), c));\\n                    }   \\n                }\\n            }\\n        }\\n        if(isNumeric){\\n            dp.add(Integer.parseInt(expression));\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777519,
                "title": "c-100-faster-recursion",
                "content": "class Solution {\\npublic:\\n    \\n\\tvector<int> diffWaysToCompute(string s) {\\n        vector<int>c;\\n        for(int i=0;i<s.size();i++){\\n            char ch = s[i];\\n            if(ch==\\'-\\' || ch==\\'+\\' || ch==\\'*\\'){\\n                string c1 = s.substr(0,i);\\n                string c2 = s.substr(i+1);\\n                vector<int>v1 = diffWaysToCompute(c1);\\n                vector<int>v2 = diffWaysToCompute(c2);\\n                for(auto x:v1){\\n                    for(auto y:v2){\\n                        if(ch==\\'-\\'){\\n                            c.push_back(x-y);\\n                        }else if(ch==\\'+\\'){\\n                            c.push_back(x+y);\\n                        }else if(ch==\\'*\\'){\\n                            c.push_back(x*y);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(c.size()==0) c.push_back(stoi(s));\\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n\\tvector<int> diffWaysToCompute(string s) {\\n        vector<int>c;\\n        for(int i=0;i<s.size();i++){\\n            char ch = s[i];\\n            if(ch==\\'-\\' || ch==\\'+\\' || ch==\\'*\\'){\\n                string c1 = s.substr(0,i);\\n                string c2 = s.substr(i+1);\\n                vector<int>v1 = diffWaysToCompute(c1);\\n                vector<int>v2 = diffWaysToCompute(c2);\\n                for(auto x:v1){\\n                    for(auto y:v2){\\n                        if(ch==\\'-\\'){\\n                            c.push_back(x-y);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 1719419,
                "title": "python-recursive-concise-solution",
                "content": "```\\nclass Solution:\\n    def diffWaysToCompute(self, expression: str) -> List[int]:\\n        ops = {\\n            \"+\": lambda x, y : x + y,\\n            \"-\": lambda x, y : x - y,\\n            \"*\": lambda x, y : x * y\\n        }\\n        res = []\\n        for x, char in enumerate(expression):\\n            if char in ops:\\n                leftResults = self.diffWaysToCompute(expression[:x])\\n                rightResults = self.diffWaysToCompute(expression[x + 1:])\\n                \\n                for leftNum in leftResults:\\n                    for rightNum in rightResults:\\n                        res.append(ops[char](leftNum, rightNum))\\n        \\n        # no operations means expression is a sole number\\n        if not res:\\n            res.append(int(expression))\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def diffWaysToCompute(self, expression: str) -> List[int]:\\n        ops = {\\n            \"+\": lambda x, y : x + y,\\n            \"-\": lambda x, y : x - y,\\n            \"*\": lambda x, y : x * y\\n        }\\n        res = []\\n        for x, char in enumerate(expression):\\n            if char in ops:\\n                leftResults = self.diffWaysToCompute(expression[:x])\\n                rightResults = self.diffWaysToCompute(expression[x + 1:])\\n                \\n                for leftNum in leftResults:\\n                    for rightNum in rightResults:\\n                        res.append(ops[char](leftNum, rightNum))\\n        \\n        # no operations means expression is a sole number\\n        if not res:\\n            res.append(int(expression))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484937,
                "title": "c-recursion-commented-line-by-line-beginner-friendly",
                "content": "```\\n//https://leetcode.com/problems/different-ways-to-add-parentheses/\\nvector<int> helper(string str)\\n    {\\n        int n=str.size();\\n        vector<int>op;\\n        //start traversing\\n        for(int i=0;i<n;i++)\\n        {\\n            //check if upcoming character is operator\\n            if(str[i]==\\'+\\' || str[i]==\\'-\\' || str[i]==\\'*\\')\\n            {\\n                //divide into two part ,one part before operator,another is after operator\\n                string op1=str.substr(0,i);\\n                string op2=str.substr(i+1);\\n                //solve the subproblems\\n                vector<int>ans1=helper(op1);\\n                vector<int>ans2=helper(op2);\\n                \\n                //now you have two vectors of numbers ,perform the mathematical operation according the \\n                //opertor at which you have divided your problem.\\n                for(auto x:ans1)\\n                {\\n                    for(auto y:ans2)\\n                    {\\n                        if(str[i]==\\'+\\')\\n                            op.push_back(x+y);\\n                        else if(str[i]==\\'-\\')\\n                            op.push_back(x-y);\\n                        else if(str[i]==\\'*\\')\\n                            op.push_back(x*y);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        //this is the case when you dont have any operator in your string ,in such case res will be empty\\n        //according to previous logic\\n        //but here we dont have any calculations,so just convert into string and return\\n        if(op.size()==0)\\n        {\\n            int a=stoi(str);\\n            op.push_back(a);\\n        }\\n        //yes you are done \\n        return op;\\n    }\\n    vector<int> diffWaysToCompute(string expression) {\\n        return helper(expression);\\n    }\\n    //by by\\n\\t//If you want its tree diagram,just comment ,I will provide for ease of undernstading.\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n//https://leetcode.com/problems/different-ways-to-add-parentheses/\\nvector<int> helper(string str)\\n    {\\n        int n=str.size();\\n        vector<int>op;\\n        //start traversing\\n        for(int i=0;i<n;i++)\\n        {\\n            //check if upcoming character is operator\\n            if(str[i]==\\'+\\' || str[i]==\\'-\\' || str[i]==\\'*\\')\\n            {\\n                //divide into two part ,one part before operator,another is after operator\\n                string op1=str.substr(0,i);\\n                string op2=str.substr(i+1);\\n                //solve the subproblems\\n                vector<int>ans1=helper(op1);\\n                vector<int>ans2=helper(op2);\\n                \\n                //now you have two vectors of numbers ,perform the mathematical operation according the \\n                //opertor at which you have divided your problem.\\n                for(auto x:ans1)\\n                {\\n                    for(auto y:ans2)\\n                    {\\n                        if(str[i]==\\'+\\')\\n                            op.push_back(x+y);\\n                        else if(str[i]==\\'-\\')\\n                            op.push_back(x-y);\\n                        else if(str[i]==\\'*\\')\\n                            op.push_back(x*y);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        //this is the case when you dont have any operator in your string ,in such case res will be empty\\n        //according to previous logic\\n        //but here we dont have any calculations,so just convert into string and return\\n        if(op.size()==0)\\n        {\\n            int a=stoi(str);\\n            op.push_back(a);\\n        }\\n        //yes you are done \\n        return op;\\n    }\\n    vector<int> diffWaysToCompute(string expression) {\\n        return helper(expression);\\n    }\\n    //by by\\n\\t//If you want its tree diagram,just comment ,I will provide for ease of undernstading.\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1469756,
                "title": "python-99-7-20ms-recursion-memo-clean-and-concise",
                "content": "* Split the string at index i such that exp[i] is an operator. Now recursively calculate all possible values in left string exp[:i] and right string exp[i + 1:]. Using nested for loops, calculate all possible combinations of left and right values applying exp[i] operator.\\n* If our string contains only digits, return that number in a list.\\n```\\nclass Solution:\\n    def diffWaysToCompute(self, expression: str) -> List[int]:\\n        nums = \\'0123456789\\'\\n        \\n        def op(a, b, c):\\n            if c == \\'+\\':\\n                return a + b\\n            elif c == \\'-\\':\\n                return a - b\\n            else:\\n                return a * b\\n        \\n        @lru_cache(None)\\n        def func(l, r):\\n            if l == r:\\n                return [expression[l]]\\n            elif l > r:\\n                return []\\n            \\n            this = []\\n            went = 0\\n            for i in range(l, r + 1):\\n                if expression[i] not in nums:\\n                    went = 1\\n                    left = func(l, i - 1)\\n                    right = func(i + 1, r)\\n                    for leftvals in left:\\n                        for rightvals in right:\\n                            temp = op(int(leftvals), int(rightvals), expression[i])\\n                            #print(temp)\\n                            this.append(temp)\\n            \\n            if went:\\n                return this\\n            else:\\n                return [expression[l: r + 1]]\\n        \\n        arr = func(0, len(expression) - 1)\\n        #print(arr)\\n        return arr",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "* Split the string at index i such that exp[i] is an operator. Now recursively calculate all possible values in left string exp[:i] and right string exp[i + 1:]. Using nested for loops, calculate all possible combinations of left and right values applying exp[i] operator.\\n* If our string contains only digits, return that number in a list.\\n```\\nclass Solution:\\n    def diffWaysToCompute(self, expression: str) -> List[int]:\\n        nums = \\'0123456789\\'\\n        \\n        def op(a, b, c):\\n            if c == \\'+\\':\\n                return a + b\\n            elif c == \\'-\\':\\n                return a - b\\n            else:\\n                return a * b\\n        \\n        @lru_cache(None)\\n        def func(l, r):\\n            if l == r:\\n                return [expression[l]]\\n            elif l > r:\\n                return []\\n            \\n            this = []\\n            went = 0\\n            for i in range(l, r + 1):\\n                if expression[i] not in nums:\\n                    went = 1\\n                    left = func(l, i - 1)\\n                    right = func(i + 1, r)\\n                    for leftvals in left:\\n                        for rightvals in right:\\n                            temp = op(int(leftvals), int(rightvals), expression[i])\\n                            #print(temp)\\n                            this.append(temp)\\n            \\n            if went:\\n                return this\\n            else:\\n                return [expression[l: r + 1]]\\n        \\n        arr = func(0, len(expression) - 1)\\n        #print(arr)\\n        return arr",
                "codeTag": "Java"
            },
            {
                "id": 1377937,
                "title": "c-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    unordered_map<string,vector<int>>dp;\\n    \\n    \\n    int calc(int a,char op,int b)\\n    {\\n        if(op==\\'+\\')\\n             return a+b;\\n        else if(op==\\'-\\')\\n             return a-b;\\n        else\\n             return a*b;\\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    vector<int> diffWaysToCompute(string s) {\\n        \\n        vector<int>res;\\n        bool mark=1;\\n        \\n        if(dp.find(s)!=dp.end())\\n            return dp[s];\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'+\\'||s[i]==\\'-\\'||s[i]==\\'*\\')\\n            {\\n                string k=s.substr(0,i);\\n                vector<int>l=diffWaysToCompute(k);\\n                k=s.substr(i+1,s.size()-i);\\n                vector<int>r=diffWaysToCompute(k);\\n            \\n            \\n              for(auto x:l)\\n              {\\n                for(auto y:r)\\n                {\\n                    mark=0;\\n                    res.push_back(calc(x,s[i],y));\\n                }\\n              }\\n\\n            }\\n        }\\n        \\n        \\n        if(mark)\\n            res.push_back(stoi(s));\\n        \\n        return dp[s]=res;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    unordered_map<string,vector<int>>dp;\\n    \\n    \\n    int calc(int a,char op,int b)\\n    {\\n        if(op==\\'+\\')\\n             return a+b;\\n        else if(op==\\'-\\')\\n             return a-b;\\n        else\\n             return a*b;\\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    vector<int> diffWaysToCompute(string s) {\\n        \\n        vector<int>res;\\n        bool mark=1;\\n        \\n        if(dp.find(s)!=dp.end())\\n            return dp[s];\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'+\\'||s[i]==\\'-\\'||s[i]==\\'*\\')\\n            {\\n                string k=s.substr(0,i);\\n                vector<int>l=diffWaysToCompute(k);\\n                k=s.substr(i+1,s.size()-i);\\n                vector<int>r=diffWaysToCompute(k);\\n            \\n            \\n              for(auto x:l)\\n              {\\n                for(auto y:r)\\n                {\\n                    mark=0;\\n                    res.push_back(calc(x,s[i],y));\\n                }\\n              }\\n\\n            }\\n        }\\n        \\n        \\n        if(mark)\\n            res.push_back(stoi(s));\\n        \\n        return dp[s]=res;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896751,
                "title": "java-short-and-crisp-recursion-beats-99",
                "content": "```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        return recur(input);\\n    }\\n    private List<Integer> recur(String in){\\n        List<Integer> res=new ArrayList();\\n        for(int k=0;k<in.length()-1;k++){\\n            if(in.charAt(k)>=\\'0\\' && in.charAt(k)<=\\'9\\') continue;\\n            List<Integer> left=recur(in.substring(0,k));\\n            List<Integer> right=recur(in.substring(k+1));\\n            for(int l : left)\\n                for(int r : right)\\n                    res.add(evaluate(l,r,in.charAt(k)));\\n        }\\n        if(res.size()==0) res.add(Integer.parseInt(in));\\n        return res;\\n    }\\n    private int evaluate(int v1,int v2,char o){\\n        if(o==\\'+\\') return v1+v2;\\n        else if(o==\\'-\\') return v1-v2;\\n        else return v1*v2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        return recur(input);\\n    }\\n    private List<Integer> recur(String in){\\n        List<Integer> res=new ArrayList();\\n        for(int k=0;k<in.length()-1;k++){\\n            if(in.charAt(k)>=\\'0\\' && in.charAt(k)<=\\'9\\') continue;\\n            List<Integer> left=recur(in.substring(0,k));\\n            List<Integer> right=recur(in.substring(k+1));\\n            for(int l : left)\\n                for(int r : right)\\n                    res.add(evaluate(l,r,in.charAt(k)));\\n        }\\n        if(res.size()==0) res.add(Integer.parseInt(in));\\n        return res;\\n    }\\n    private int evaluate(int v1,int v2,char o){\\n        if(o==\\'+\\') return v1+v2;\\n        else if(o==\\'-\\') return v1-v2;\\n        else return v1*v2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 673038,
                "title": "java-high-readable-java-code-divide-and-conquer-memoization",
                "content": "It\\'s a good question to test divide-and-conquer. The code is highly readable, so I don\\'t have to explain any thoughts here.\\n\\n```java\\nclass Solution {\\n    // without cache - accepted 2 ms, faster than 40.52%\\n    // with cache - accepted 1 ms, faster than 98.60%\\n    public List<Integer> diffWaysToCompute(String input) {\\n        Map<String, List<Integer>> cache = new HashMap<>();\\n        return solve(input, 0, input.length()-1, cache);\\n    }\\n    \\n    private List<Integer> solve(String input, int left, int right, Map<String, List<Integer>> cache) {\\n        List<Integer> res = new ArrayList<>();\\n        if (left > right) {\\n            return res;\\n        }\\n        \\n        // check cache\\n        String substring = input.substring(left, right+1);\\n        if (cache.containsKey(substring)) {\\n            return cache.get(substring);\\n        }\\n        \\n        // base case, it\\'s just a number\\n        if (!substring.contains(\"-\") && !substring.contains(\"+\") && !substring.contains(\"*\")) {\\n            res.add(Integer.valueOf(substring));\\n            return res;\\n        }\\n        \\n        // break the expression when it meets an operator\\n        for(int i = left; i <= right; i++) {\\n            Character curChar = input.charAt(i);\\n            if (curChar == \\'-\\' || curChar == \\'+\\' || curChar == \\'*\\') {\\n                List<Integer> leftResult = solve(input, left, i-1, cache);\\n                List<Integer> rightResult = solve(input, i+1, right, cache);\\n\\n                for(Integer leftOp : leftResult) {\\n                    for(Integer rightOp : rightResult) {\\n                        if (curChar == \\'-\\') {\\n                            res.add(leftOp-rightOp);\\n                        } else if (curChar == \\'+\\') {\\n                            res.add(leftOp+rightOp);\\n                        } else {\\n                            res.add(leftOp*rightOp);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // memoization\\n        cache.put(substring, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    // without cache - accepted 2 ms, faster than 40.52%\\n    // with cache - accepted 1 ms, faster than 98.60%\\n    public List<Integer> diffWaysToCompute(String input) {\\n        Map<String, List<Integer>> cache = new HashMap<>();\\n        return solve(input, 0, input.length()-1, cache);\\n    }\\n    \\n    private List<Integer> solve(String input, int left, int right, Map<String, List<Integer>> cache) {\\n        List<Integer> res = new ArrayList<>();\\n        if (left > right) {\\n            return res;\\n        }\\n        \\n        // check cache\\n        String substring = input.substring(left, right+1);\\n        if (cache.containsKey(substring)) {\\n            return cache.get(substring);\\n        }\\n        \\n        // base case, it\\'s just a number\\n        if (!substring.contains(\"-\") && !substring.contains(\"+\") && !substring.contains(\"*\")) {\\n            res.add(Integer.valueOf(substring));\\n            return res;\\n        }\\n        \\n        // break the expression when it meets an operator\\n        for(int i = left; i <= right; i++) {\\n            Character curChar = input.charAt(i);\\n            if (curChar == \\'-\\' || curChar == \\'+\\' || curChar == \\'*\\') {\\n                List<Integer> leftResult = solve(input, left, i-1, cache);\\n                List<Integer> rightResult = solve(input, i+1, right, cache);\\n\\n                for(Integer leftOp : leftResult) {\\n                    for(Integer rightOp : rightResult) {\\n                        if (curChar == \\'-\\') {\\n                            res.add(leftOp-rightOp);\\n                        } else if (curChar == \\'+\\') {\\n                            res.add(leftOp+rightOp);\\n                        } else {\\n                            res.add(leftOp*rightOp);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // memoization\\n        cache.put(substring, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 644537,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        return ways(input); \\n    }\\n    private List<Integer> ways(String input){\\n        if(map.containsKey(input)) return map.get(input); \\n        List<Integer> output = new ArrayList<>(); \\n        for(int i = 0; i < input.length(); i++){\\n            char ch = input.charAt(i); \\n            \\n            if(ch == \\'+\\' || ch == \\'-\\' || ch == \\'*\\'){\\n                String left = input.substring(0, i); \\n                String right = input.substring(i + 1, input.length()); \\n                List<Integer> leftList = ways(left); \\n                List<Integer> rightList = ways(right); \\n                \\n                switch(ch){\\n                    case \\'+\\':\\n                        for(Integer l : leftList){\\n                            for(Integer r : rightList){\\n                                output.add(l + r); \\n                            }\\n                        }\\n                        break; \\n                    case \\'-\\':\\n                        for(Integer l : leftList){\\n                            for(Integer r : rightList){\\n                                output.add(l - r); \\n                            }\\n                        }\\n                        break; \\n                    case \\'*\\':\\n                        for(Integer l : leftList){\\n                            for(Integer r : rightList){\\n                                output.add(l * r); \\n                            }\\n                        }\\n                        break; \\n                }\\n            }\\n        }\\n        if(output.isEmpty()){\\n            output.add(Integer.valueOf(input)); \\n        }\\n        map.put(input, output); \\n        return output; \\n    }\\n    private Map<String, List<Integer>> map = new HashMap<>(); \\n}\\n```",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        return ways(input); \\n    }\\n    private List<Integer> ways(String input){\\n        if(map.containsKey(input)) return map.get(input); \\n        List<Integer> output = new ArrayList<>(); \\n        for(int i = 0; i < input.length(); i++){\\n            char ch = input.charAt(i); \\n            \\n            if(ch == \\'+\\' || ch == \\'-\\' || ch == \\'*\\'){\\n                String left = input.substring(0, i); \\n                String right = input.substring(i + 1, input.length()); \\n                List<Integer> leftList = ways(left); \\n                List<Integer> rightList = ways(right); \\n                \\n                switch(ch){\\n                    case \\'+\\':\\n                        for(Integer l : leftList){\\n                            for(Integer r : rightList){\\n                                output.add(l + r); \\n                            }\\n                        }\\n                        break; \\n                    case \\'-\\':\\n                        for(Integer l : leftList){\\n                            for(Integer r : rightList){\\n                                output.add(l - r); \\n                            }\\n                        }\\n                        break; \\n                    case \\'*\\':\\n                        for(Integer l : leftList){\\n                            for(Integer r : rightList){\\n                                output.add(l * r); \\n                            }\\n                        }\\n                        break; \\n                }\\n            }\\n        }\\n        if(output.isEmpty()){\\n            output.add(Integer.valueOf(input)); \\n        }\\n        map.put(input, output); \\n        return output; \\n    }\\n    private Map<String, List<Integer>> map = new HashMap<>(); \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494338,
                "title": "c-recursion-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> diffWaysToCompute(string input) {\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tfor(int i=0;i<input.size();i++){\\n\\t\\t\\t\\tchar op=input[i];\\n\\t\\t\\t\\tif(op==\\'+\\' || op==\\'-\\' || op==\\'*\\'){\\n\\t\\t\\t\\t\\tstring l=input.substr(0,i);\\n\\t\\t\\t\\t\\tstring r=input.substr(i+1);\\n\\t\\t\\t\\t\\tvector<int> left=diffWaysToCompute(l);\\n\\t\\t\\t\\t\\tvector<int> right=diffWaysToCompute(r);\\n\\n\\t\\t\\t\\t\\t\\tfor(int i=0;i<left.size();i++)\\n\\t\\t\\t\\t\\t\\t\\tfor(int j=0;j<right.size();j++){\\n\\t\\t\\t\\t\\t\\t\\t\\tif(op==\\'+\\'){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tans.push_back(left[i]+right[j]);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\telse if(op==\\'*\\'){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tans.push_back(left[i]*right[j]);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tans.push_back(left[i]-right[j]);\\n\\t\\t\\t\\t\\t\\t\\t\\t}     \\n\\t\\t\\t\\t\\t }\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(ans.empty()){\\n\\t\\t\\t\\tans.push_back(stoi(input));\\n\\t\\t\\t}\\n\\n\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> diffWaysToCompute(string input) {\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tfor(int i=0;i<input.size();i++){\\n\\t\\t\\t\\tchar op=input[i];\\n\\t\\t\\t\\tif(op==\\'+\\' || op==\\'-\\' || op==\\'*\\'){\\n\\t\\t\\t\\t\\tstring l=input.substr(0,i);\\n\\t\\t\\t\\t\\tstring r=input.substr(i+1);\\n\\t\\t\\t\\t\\tvector<int> left=diffWaysToCompute(l);\\n\\t\\t\\t\\t\\tvector<int> right=diffWaysToCompute(r);\\n\\n\\t\\t\\t\\t\\t\\tfor(int i=0;i<left.size();i++)\\n\\t\\t\\t\\t\\t\\t\\tfor(int j=0;j<right.size();j++){\\n\\t\\t\\t\\t\\t\\t\\t\\tif(op==\\'+\\'){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tans.push_back(left[i]+right[j]);\\n\\t\\t\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 443631,
                "title": "dfs-memo-beat-100-submition-in-time-and-space-complexity",
                "content": "```\\n\\nclass Solution {\\npublic:   \\n    vector<int> diffWaysToCompute(string input) {\\n        if(memo.count(input))\\n            return memo[input];\\n        vector<int> ret;\\n        for(int i = 0; i < input.size(); i++) {\\n            if (input[i] == \\'+\\' || input[i] == \\'-\\' || input[i] == \\'*\\') {\\n                vector<int> pre; vector<int> post;\\n                pre = diffWaysToCompute(input.substr(0, i));\\n                post = diffWaysToCompute(input.substr(i + 1));\\n                for(int e: pre)\\n                    for(int ee: post)\\n                        if(input[i] == \\'+\\')        \\n                            ret.push_back(e + ee);\\n                        else if(input[i] == \\'-\\')  \\n                            ret.push_back(e - ee);\\n                        else if(input[i] == \\'*\\')  \\n                            ret.push_back(e * ee);\\n            }\\n        }\\n        if(ret.empty())\\n            ret.push_back(stoi(input));\\n        memo[input] = ret;\\n        return ret;\\n    }\\nprivate:\\n     unordered_map<string, vector<int>> memo;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:   \\n    vector<int> diffWaysToCompute(string input) {\\n        if(memo.count(input))\\n            return memo[input];\\n        vector<int> ret;\\n        for(int i = 0; i < input.size(); i++) {\\n            if (input[i] == \\'+\\' || input[i] == \\'-\\' || input[i] == \\'*\\') {\\n                vector<int> pre; vector<int> post;\\n                pre = diffWaysToCompute(input.substr(0, i));\\n                post = diffWaysToCompute(input.substr(i + 1));\\n                for(int e: pre)\\n                    for(int ee: post)\\n                        if(input[i] == \\'+\\')        \\n                            ret.push_back(e + ee);\\n                        else if(input[i] == \\'-\\')  \\n                            ret.push_back(e - ee);\\n                        else if(input[i] == \\'*\\')  \\n                            ret.push_back(e * ee);\\n            }\\n        }\\n        if(ret.empty())\\n            ret.push_back(stoi(input));\\n        memo[input] = ret;\\n        return ret;\\n    }\\nprivate:\\n     unordered_map<string, vector<int>> memo;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396085,
                "title": "recursive-python",
                "content": "For the current input, try to group it to two parts, then recursively do that on the grouped two parts it\\'s all digit.\\nFor example input `1+2-3*4+5`, \\n`group(1+2-3*4+5)` = \\n`group(1)` + `group(2-3*4+5)`\\n`group(1+2)` - `group(3*4+5)`\\n`group(1+2-3)` * `group(4+5)`\\n`group(1+2-3*4)` + `group(+5)`\\n\\n```\\n    def diffWaysToCompute(self, input: str) -> List[int]:\\n        ops = {\\'+\\': operator.add, \\'-\\': operator.sub, \\'*\\': operator.mul}\\n        def dfs(s):\\n            if s.isdigit():\\n                return [int(s)]\\n            res = []\\n            for i in range(len(s)):\\n                if s[i] in [\\'+\\', \\'-\\', \\'*\\']:\\n                    nums1 = dfs(s[:i])\\n                    nums2 = dfs(s[i+1:])\\n                    res += [ops[s[i]](num1, num2) for num1 in nums1 for num2 in nums2]\\n            return res\\n        return dfs(input)\\n```",
                "solutionTags": [],
                "code": "```\\n    def diffWaysToCompute(self, input: str) -> List[int]:\\n        ops = {\\'+\\': operator.add, \\'-\\': operator.sub, \\'*\\': operator.mul}\\n        def dfs(s):\\n            if s.isdigit():\\n                return [int(s)]\\n            res = []\\n            for i in range(len(s)):\\n                if s[i] in [\\'+\\', \\'-\\', \\'*\\']:\\n                    nums1 = dfs(s[:i])\\n                    nums2 = dfs(s[i+1:])\\n                    res += [ops[s[i]](num1, num2) for num1 in nums1 for num2 in nums2]\\n            return res\\n        return dfs(input)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 66384,
                "title": "simple-java-recursive-solution-with-memoization-beat-82",
                "content": "First of all, I noticed that many people confuse \"memoization\" with \"memorization\". \\nhttps://en.wikipedia.org/wiki/Memoization\\n\"In computing, memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. \"\\nhttps://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-recursion-part-2/\\n\\nThe reason to use memo is we don't want to solve the same subproblem over and over again. For example, if input is \"2 * 3+7-1\". \"2 * 3\" will be calculated twice when we break input at \"+\" and \"-\". When using memoization, the recursive method is always bottom to top, so that you can store the solutions to smaller problems and reuse them.\\n\\n```\\npublic class Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        Map<String, List<Integer>> memo = new HashMap<>();\\n        return search(input, memo);\\n    }\\n    \\n    private List<Integer> search(String input, Map<String, List<Integer>> memo) {\\n        if (memo.containsKey(input)) {\\n            return memo.get(input);\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        \\n        char[] chrs = input.toCharArray();\\n        for (int i = 0; i < chrs.length; i++) {\\n            char chr = chrs[i];\\n            if (!Character.isDigit(chr)) {\\n                for (int l : search(input.substring(0, i), memo)) {\\n                    for (int r : search(input.substring(i + 1), memo)) {\\n                        res.add(chr == '+' ? l + r : chr == '-' ? l - r : l * r);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (res.isEmpty()) {\\n            res.add(Integer.parseInt(input));\\n        }\\n        \\n        memo.put(input, res);\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        Map<String, List<Integer>> memo = new HashMap<>();\\n        return search(input, memo);\\n    }\\n    \\n    private List<Integer> search(String input, Map<String, List<Integer>> memo) {\\n        if (memo.containsKey(input)) {\\n            return memo.get(input);\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        \\n        char[] chrs = input.toCharArray();\\n        for (int i = 0; i < chrs.length; i++) {\\n            char chr = chrs[i];\\n            if (!Character.isDigit(chr)) {\\n                for (int l : search(input.substring(0, i), memo)) {\\n                    for (int r : search(input.substring(i + 1), memo)) {\\n                        res.add(chr == '+' ? l + r : chr == '-' ? l - r : l * r);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (res.isEmpty()) {\\n            res.add(Integer.parseInt(input));\\n        }\\n        \\n        memo.put(input, res);\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66388,
                "title": "solutions-in-c-check-it-and-you-will-get-it",
                "content": "### Solution\\n\\n#### Analysis\\nAdding parentheses here is actually changing the calculation order and intuitively we can come up with a solution using recursion which via a calculation string and output the different results for different parentheses. Recursion can be solved by itself in limited range, which is the core of it. \\n\\n- to avoid further modifying the input string, we use begin and end to limit the range and in each invoking we create a new vector to store the results, then we return the vector;\\n- the last calculation which can happen in all the operators, so we split the string by the different operators (sometimes we have to think in a reverse opposite way to ease the difficulty, so here we care about the last) so as the recursion rule goes, the left and right substring will also have different results themselves and now what we need to do is combine them with the last operator one by one;\\n- as for termination condition: there is no operator between begin and end position, so we then can just convert the string to an integer and return.\\n\\n#### Pure recursive\\nThe recursive solution in C++ is as follows:\\n\\n```\\nclass Solution {\\nprivate:\\n    int sLen;\\n    vector<int> helper(const string& s, int begin, int end)\\n    {\\n        vector<int> v;\\n        if(begin > end) return v; \\n        for(int i = begin; i <= end; ++i)\\n        {\\n            if(!isdigit(s[i]))\\n            {\\n                vector<int> l = helper(s, begin, i-1), r = helper(s, i+1, end);\\n                for(int j = 0; j < l.size(); ++j)\\n                {\\n                    for(int k = 0; k < r.size(); ++k)\\n                    {\\n                        switch(s[i])\\n                        {\\n                            case '-': v.push_back(l[j]-r[k]); break;\\n                            case '+': v.push_back(l[j]+r[k]); break;\\n                            case '*': v.push_back(l[j]*r[k]); break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(v.empty()) v.push_back(stoi(s.substr(begin, end-begin+1)));\\n        return v;\\n    }\\npublic:\\n    vector<int> diffWaysToCompute(string input) {\\n        sLen = input.length();\\n        return helper(input, 0, sLen-1);\\n    }\\n};\\n```\\n\\nThere is a more terse solution in C++, though less efficient.\\n\\n```\\nvector<int> diffWaysToCompute(string s) \\n{\\n\\tif(s.empty()) return vector<int>();\\n\\tvector<int> v;\\n\\tfor(int i = 0; s[i]; ++i)\\n\\t{\\n\\t\\tif(!isdigit(s[i]))\\n\\t\\t{\\n\\t\\t\\tfor(int a: diffWaysToCompute(s.substr(0, i)))\\n\\t\\t\\t\\tfor(int b: diffWaysToCompute(s.substr(i+1)))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(s[i] == '-') v.push_back(a-b);\\n\\t\\t\\t\\t\\tif(s[i] == '+') v.push_back(a+b);\\n\\t\\t\\t\\t\\tif(s[i] == '*') v.push_back(a*b);\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn v.size()? v : vector<int>{stoi(s)};\\n}\\n```\\n\\n#### Memoization\\n\\nOf course, there should be a DP or Memoization solution, since there are lots of overlapping sub-problems and when the string becomes large, its performance will be definitely a problem. So here is a Memoization solution in C++. DP can do also do but that will be wanting in simplicity here. But so notoriuos as Momoization always is, the space it's to cost is rather costly here. Balance it in different cases is what we should always care about.\\n\\n```\\nclass Solution {\\nprivate:\\n    int sLen;\\n    vector<int> helper(const string& s, int begin, int end, vector<vector<vector<int>>>& matrix)\\n    {\\n        vector<int> v;\\n        if(begin > end) return v; \\n        if(matrix[begin][end].size()) return matrix[begin][end];\\n        for(int i = begin; i <= end; ++i)\\n        {\\n            if(!isdigit(s[i]))\\n            {\\n                vector<int> l = helper(s, begin, i-1, matrix), r = helper(s, i+1, end, matrix);\\n                for(int j = 0; j < l.size(); ++j)\\n                {\\n                    for(int k = 0; k < r.size(); ++k)\\n                    {\\n                        switch(s[i])\\n                        {\\n                            case '-': v.push_back(l[j]-r[k]); break;\\n                            case '+': v.push_back(l[j]+r[k]); break;\\n                            case '*': v.push_back(l[j]*r[k]); break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        matrix[begin][end] = v.size()? v : vector<int>{stoi(s.substr(begin, end-begin+1))};\\n        return matrix[begin][end];\\n    }\\npublic:\\n    vector<int> diffWaysToCompute(string input) {\\n        sLen = input.length();\\n        vector<vector<vector<int>>> matrix(sLen, vector<vector<int>>(sLen));\\n        return helper(input, 0, sLen-1, matrix);\\n    }\\n};\\n```\\n\\n#### DP\\nIt's not good to leave the DP alone. So here it is, the DP solution though it's not that intuitive and easy to accomplish as Memoization.\\n\\n- split the input string into number strings and operator strings\\n- start to calculate from one string till all of them including numbers and operators\\n- move 2 steps forward each time since there are operators among numbers, while we only care about numbers\\n- in each range, we only calculate when encountering operators and as before we combine the results from left side and right side using the current operator\\n\\nThe whole solution in C++ is as follows. In summary, though it's not that intuitive to achieve a DP solution here, but it's quite a balance between performance and space cost between recursive (which re-calculates lots of over-lapping sub-problems) and Memoizationet (which costs lots of redundant space not only in storing but recursive function invoking).\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string input) \\n    {\\n        vector<string> parts;\\n        string s;\\n        for(int i = 0; i <= input.length(); ++i)\\n        {\\n            if(isdigit(input[i])) s += input[i];\\n            else\\n            {\\n                parts.push_back(s);\\n                s.clear();\\n                if(input[i] != '\\\\0') parts.push_back(string(1, input[i]));\\n            }\\n        }\\n        int size = parts.size();\\n        vector<vector<vector<int>>> matrix(size, vector<vector<int>>(size));\\n        for(int d = 0; d < size; d += 2)\\n        {\\n            for(int l = 0; l < size-d; ++l)\\n            {\\n                if(!isdigit(parts[l][0])) continue;\\n                if(d == 0) matrix[l][l].push_back(stoi(parts[l]));\\n                int r = l+d;\\n                for(int k = l; k <= r; ++k)\\n                {\\n                    if(!isdigit(parts[k][0]))\\n                    {\\n                        for(auto a: matrix[l][k-1])\\n                            for(auto b: matrix[k+1][r])\\n                            {\\n                                if(parts[k] == \"-\") matrix[l][r].push_back(a-b);\\n                                if(parts[k] == \"+\") matrix[l][r].push_back(a+b);\\n                                if(parts[k] == \"*\") matrix[l][r].push_back(a*b);\\n                            }\\n                    }\\n                }\\n            }\\n        }\\n        return matrix[0][size-1];\\n    }\\n};\\n```\\nAlways welcome new ideas and `practical` tricks, just leave them in the comments!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int sLen;\\n    vector<int> helper(const string& s, int begin, int end)\\n    {\\n        vector<int> v;\\n        if(begin > end) return v; \\n        for(int i = begin; i <= end; ++i)\\n        {\\n            if(!isdigit(s[i]))\\n            {\\n                vector<int> l = helper(s, begin, i-1), r = helper(s, i+1, end);\\n                for(int j = 0; j < l.size(); ++j)\\n                {\\n                    for(int k = 0; k < r.size(); ++k)\\n                    {\\n                        switch(s[i])\\n                        {\\n                            case '-': v.push_back(l[j]-r[k]); break;\\n                            case '+': v.push_back(l[j]+r[k]); break;\\n                            case '*': v.push_back(l[j]*r[k]); break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(v.empty()) v.push_back(stoi(s.substr(begin, end-begin+1)));\\n        return v;\\n    }\\npublic:\\n    vector<int> diffWaysToCompute(string input) {\\n        sLen = input.length();\\n        return helper(input, 0, sLen-1);\\n    }\\n};\\n```\n```\\nvector<int> diffWaysToCompute(string s) \\n{\\n\\tif(s.empty()) return vector<int>();\\n\\tvector<int> v;\\n\\tfor(int i = 0; s[i]; ++i)\\n\\t{\\n\\t\\tif(!isdigit(s[i]))\\n\\t\\t{\\n\\t\\t\\tfor(int a: diffWaysToCompute(s.substr(0, i)))\\n\\t\\t\\t\\tfor(int b: diffWaysToCompute(s.substr(i+1)))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(s[i] == '-') v.push_back(a-b);\\n\\t\\t\\t\\t\\tif(s[i] == '+') v.push_back(a+b);\\n\\t\\t\\t\\t\\tif(s[i] == '*') v.push_back(a*b);\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn v.size()? v : vector<int>{stoi(s)};\\n}\\n```\n```\\nclass Solution {\\nprivate:\\n    int sLen;\\n    vector<int> helper(const string& s, int begin, int end, vector<vector<vector<int>>>& matrix)\\n    {\\n        vector<int> v;\\n        if(begin > end) return v; \\n        if(matrix[begin][end].size()) return matrix[begin][end];\\n        for(int i = begin; i <= end; ++i)\\n        {\\n            if(!isdigit(s[i]))\\n            {\\n                vector<int> l = helper(s, begin, i-1, matrix), r = helper(s, i+1, end, matrix);\\n                for(int j = 0; j < l.size(); ++j)\\n                {\\n                    for(int k = 0; k < r.size(); ++k)\\n                    {\\n                        switch(s[i])\\n                        {\\n                            case '-': v.push_back(l[j]-r[k]); break;\\n                            case '+': v.push_back(l[j]+r[k]); break;\\n                            case '*': v.push_back(l[j]*r[k]); break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        matrix[begin][end] = v.size()? v : vector<int>{stoi(s.substr(begin, end-begin+1))};\\n        return matrix[begin][end];\\n    }\\npublic:\\n    vector<int> diffWaysToCompute(string input) {\\n        sLen = input.length();\\n        vector<vector<vector<int>>> matrix(sLen, vector<vector<int>>(sLen));\\n        return helper(input, 0, sLen-1, matrix);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string input) \\n    {\\n        vector<string> parts;\\n        string s;\\n        for(int i = 0; i <= input.length(); ++i)\\n        {\\n            if(isdigit(input[i])) s += input[i];\\n            else\\n            {\\n                parts.push_back(s);\\n                s.clear();\\n                if(input[i] != '\\\\0') parts.push_back(string(1, input[i]));\\n            }\\n        }\\n        int size = parts.size();\\n        vector<vector<vector<int>>> matrix(size, vector<vector<int>>(size));\\n        for(int d = 0; d < size; d += 2)\\n        {\\n            for(int l = 0; l < size-d; ++l)\\n            {\\n                if(!isdigit(parts[l][0])) continue;\\n                if(d == 0) matrix[l][l].push_back(stoi(parts[l]));\\n                int r = l+d;\\n                for(int k = l; k <= r; ++k)\\n                {\\n                    if(!isdigit(parts[k][0]))\\n                    {\\n                        for(auto a: matrix[l][k-1])\\n                            for(auto b: matrix[k+1][r])\\n                            {\\n                                if(parts[k] == \"-\") matrix[l][r].push_back(a-b);\\n                                if(parts[k] == \"+\") matrix[l][r].push_back(a+b);\\n                                if(parts[k] == \"*\") matrix[l][r].push_back(a*b);\\n                            }\\n                    }\\n                }\\n            }\\n        }\\n        return matrix[0][size-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66427,
                "title": "easy-to-understand-java-solution-using-divide-and-conquer",
                "content": "    public class Solution {\\n        public List<Integer> diffWaysToCompute(String input) {\\n           if (input == null) {\\n               return new ArrayList<Integer>();\\n           }\\n           \\n           return helper(input, 0, input.length() - 1);\\n        }\\n        \\n        \\n        private List<Integer> helper(String input, int start, int end) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            \\n            //if the currrent substring is a number, return\\n            try {\\n                    result.add(Integer.parseInt(input.substring(start, end + 1)));\\n                    return result;\\n            }\\n            //if not, do the parsing by the following\\n            catch (NumberFormatException e) {\\n                \\n            }\\n            \\n            for (int operatorIndex = start; operatorIndex <= end; operatorIndex++) {\\n                char currChar = input.charAt(operatorIndex);\\n                if (currChar == '+' || currChar == '-' || currChar == '*') {\\n                    //recursively compute all possible results from other sides of current operator\\n                    List<Integer> left = helper(input, start, operatorIndex - 1);\\n                    List<Integer> right = helper(input, operatorIndex + 1, end);\\n                    \\n                    //combine all possible results\\n                    for (int leftValue : left) {\\n                        for (int rightValue : right) {\\n                            int newValue;\\n                            char operator = input.charAt(operatorIndex);\\n                            if (operator == '+') {\\n                                newValue = leftValue + rightValue;\\n                            }\\n                            else if (operator == '-') {\\n                                newValue = leftValue - rightValue;\\n                            }\\n                            else {\\n                                newValue = leftValue * rightValue;\\n                            }\\n                            result.add(newValue);\\n                        }\\n                    }\\n                }\\n            }\\n            return result;\\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "class Solution {\\n        public List<Integer> diffWaysToCompute(String input) {\\n           if (input == null) {\\n               return new ArrayList<Integer>();\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2782126,
                "title": "python-clear-and-easy-way",
                "content": "\\n\\n example: 2*3 - 4\\\\*5\\n\\nall combo from 2  *   all combo from 3-4*5\\nall combo from 2*3  -   all combo from 4*5\\nall combo from 2*3-4  *   all combo from 5\\n\\n```\\nclass Solution:\\n    def diffWaysToCompute(self, expression: str) -> List[int]:\\n        # base case: zero or one operator, just output the result\\n        if expression.count(\"+\")+expression.count(\"-\")+expression.count(\"*\")<2:\\n            return [eval(expression)]\\n        \\n        res=[]\\n        # when see a operator, calculate all the combinations that can happen before the operator, and after the operator\\n        for i in range(len(expression)):\\n            if expression[i] in [\"+\",\"-\",\"*\"]:\\n                left=self.diffWaysToCompute(expression[:i])\\n                right=self.diffWaysToCompute(expression[i+1:])\\n                for x in left:\\n                    for y in right:\\n                        res.append(eval(str(x)+expression[i]+str(y)))\\n        return res\\n```\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def diffWaysToCompute(self, expression: str) -> List[int]:\\n        # base case: zero or one operator, just output the result\\n        if expression.count(\"+\")+expression.count(\"-\")+expression.count(\"*\")<2:\\n            return [eval(expression)]\\n        \\n        res=[]\\n        # when see a operator, calculate all the combinations that can happen before the operator, and after the operator\\n        for i in range(len(expression)):\\n            if expression[i] in [\"+\",\"-\",\"*\"]:\\n                left=self.diffWaysToCompute(expression[:i])\\n                right=self.diffWaysToCompute(expression[i+1:])\\n                for x in left:\\n                    for y in right:\\n                        res.append(eval(str(x)+expression[i]+str(y)))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577672,
                "title": "c-100-faster-dp-divide-and-conquer-easy-code",
                "content": "**If you think the solution is helpful, a simple hit of upvote is highly appreciated.**\\nI have tried 2 methods in this problem, and both of their runtime are 0ms!!!\\n**Method 1:partition+recursion(divide and conquer)**\\na top-down angle\\n```\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string expression) {\\n        vector<int>ans;\\n        int n=expression.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            char c=expression[i];\\n            if(c==\\'+\\'||c==\\'-\\'||c==\\'*\\')\\n            {\\n                vector<int> L=diffWaysToCompute(expression.substr(0,i)),R=diffWaysToCompute(expression.substr(i+1,n-i-1));\\n                for(int l:L)\\n                    for(int r:R)\\n                        switch(c)\\n                        {\\n                            case \\'+\\':ans.push_back(l+r);break;\\n                            case \\'-\\':ans.push_back(l-r);break;  \\n                            case \\'*\\':ans.push_back(l*r);break;\\n                        }\\n            }\\n        }\\n        if(ans.empty()) ans.push_back(stoi(expression));\\n        return ans;\\n    }\\n};\\n```\\n**Method 2:(partition) dp**\\na bottom-up angle\\n```\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string expression) {\\n        int n=expression.size();\\n        vector<int>num,op;\\n        for(int i=0;i<n;i++)\\n        {\\n            int nw=expression[i++]-\\'0\\';\\n            while(i<n&&expression[i]>=\\'0\\'&&expression[i]<=\\'9\\')\\n                nw=nw*10+expression[i++]-\\'0\\';\\n            num.push_back(nw);\\n            if(i<n) op.push_back(expression[i]);\\n        }\\n        n=num.size();\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(n,vector<int>()));\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][i].push_back(num[i]);\\n            for(int j=i-1;j>=0;j--)\\n                for(int k=i-1;k>=j;k--)\\n                    for(int x:dp[j][k])\\n                        for(int y:dp[k+1][i])\\n                            switch(op[k])\\n                            {\\n                                case \\'+\\':dp[j][i].push_back(x+y);break;\\n                                case \\'-\\':dp[j][i].push_back(x-y);break;\\n                                case \\'*\\':dp[j][i].push_back(x*y);break;\\n                            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Divide and Conquer",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string expression) {\\n        vector<int>ans;\\n        int n=expression.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            char c=expression[i];\\n            if(c==\\'+\\'||c==\\'-\\'||c==\\'*\\')\\n            {\\n                vector<int> L=diffWaysToCompute(expression.substr(0,i)),R=diffWaysToCompute(expression.substr(i+1,n-i-1));\\n                for(int l:L)\\n                    for(int r:R)\\n                        switch(c)\\n                        {\\n                            case \\'+\\':ans.push_back(l+r);break;\\n                            case \\'-\\':ans.push_back(l-r);break;  \\n                            case \\'*\\':ans.push_back(l*r);break;\\n                        }\\n            }\\n        }\\n        if(ans.empty()) ans.push_back(stoi(expression));\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string expression) {\\n        int n=expression.size();\\n        vector<int>num,op;\\n        for(int i=0;i<n;i++)\\n        {\\n            int nw=expression[i++]-\\'0\\';\\n            while(i<n&&expression[i]>=\\'0\\'&&expression[i]<=\\'9\\')\\n                nw=nw*10+expression[i++]-\\'0\\';\\n            num.push_back(nw);\\n            if(i<n) op.push_back(expression[i]);\\n        }\\n        n=num.size();\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(n,vector<int>()));\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][i].push_back(num[i]);\\n            for(int j=i-1;j>=0;j--)\\n                for(int k=i-1;k>=j;k--)\\n                    for(int x:dp[j][k])\\n                        for(int y:dp[k+1][i])\\n                            switch(op[k])\\n                            {\\n                                case \\'+\\':dp[j][i].push_back(x+y);break;\\n                                case \\'-\\':dp[j][i].push_back(x-y);break;\\n                                case \\'*\\':dp[j][i].push_back(x*y);break;\\n                            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521909,
                "title": "clear-recursive-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    vector<int>rec(string s){\\n        //understand the signature and returning value of this recursive function \\n        \\n        \\n        //har recursive function me given expression ke all possible evaluation result store karke return karne h \\n        \\n        vector<int>ans;\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'+\\'||s[i]==\\'-\\'||s[i]==\\'*\\'){\\n                vector<int>ans1=rec(s.substr(0,i));\\n                vector<int>ans2=rec(s.substr(i+1));\\n                //last argument nhi doge substr function ko then it will \\n                //give the substring till the last \\n                \\n                \\n                for(int k=0;k<ans1.size();k++){\\n                    for(int j=0;j<ans2.size();j++){\\n                        if(s[i]==\\'+\\'){\\n                            ans.push_back(ans1[k]+ans2[j]);\\n                            \\n                        }else if(s[i]==\\'-\\'){\\n                            ans.push_back(ans1[k]-ans2[j]);\\n                            \\n                        }else if(s[i]==\\'*\\'){\\n                            ans.push_back(ans1[k]*ans2[j]);\\n                            \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(ans.size()==0){\\n            //matlab koi operatoe aya hi nhi inside the string considered for evaluation \\n            ans.push_back(stoi(s));\\n            \\n        }\\n        //cause it is a recursive function \\n        //we need to determine the base case \\n        \\n        //finally return the the vector with all possible evaluation in the current recursive call\\n        return ans;\\n    }\\n    vector<int> diffWaysToCompute(string s) {\\n        //this question is also of recursion \\n        //so recursion ke question me \\n        //recursion tree banake solve kara karo\\n        //we will follow here pmi based approach \\n        \\n        //here operator pe break karke \\n        //left and right parts se possible answer ko collect karo \\n        //aur us operato ke accoording all possible answer generate karo \\n        //left and right me all possible ans ke liye we need tro do recursive call\\n        //of the same functions\\n        // vector<int>ans;\\n        return rec( s);\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    vector<int>rec(string s){\\n        //understand the signature and returning value of this recursive function \\n        \\n        \\n        //har recursive function me given expression ke all possible evaluation result store karke return karne h \\n        \\n        vector<int>ans;\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'+\\'||s[i]==\\'-\\'||s[i]==\\'*\\'){\\n                vector<int>ans1=rec(s.substr(0,i));\\n                vector<int>ans2=rec(s.substr(i+1));\\n                //last argument nhi doge substr function ko then it will \\n                //give the substring till the last \\n                \\n                \\n                for(int k=0;k<ans1.size();k++){\\n                    for(int j=0;j<ans2.size();j++){\\n                        if(s[i]==\\'+\\'){\\n                            ans.push_back(ans1[k]+ans2[j]);\\n                            \\n                        }else if(s[i]==\\'-\\'){\\n                            ans.push_back(ans1[k]-ans2[j]);\\n                            \\n                        }else if(s[i]==\\'*\\'){\\n                            ans.push_back(ans1[k]*ans2[j]);\\n                            \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(ans.size()==0){\\n            //matlab koi operatoe aya hi nhi inside the string considered for evaluation \\n            ans.push_back(stoi(s));\\n            \\n        }\\n        //cause it is a recursive function \\n        //we need to determine the base case \\n        \\n        //finally return the the vector with all possible evaluation in the current recursive call\\n        return ans;\\n    }\\n    vector<int> diffWaysToCompute(string s) {\\n        //this question is also of recursion \\n        //so recursion ke question me \\n        //recursion tree banake solve kara karo\\n        //we will follow here pmi based approach \\n        \\n        //here operator pe break karke \\n        //left and right parts se possible answer ko collect karo \\n        //aur us operato ke accoording all possible answer generate karo \\n        //left and right me all possible ans ke liye we need tro do recursive call\\n        //of the same functions\\n        // vector<int>ans;\\n        return rec( s);\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205229,
                "title": "c-0ms-dp-solution-with-brief-explanation",
                "content": "**Runtime: 0 ms**, faster than 100.00% of C++ online submissions for Different Ways to Add Parentheses.\\n**Memory Usage:** 7.4 MB, less than 87.06% of C++ online submissions for Different Ways to Add Parentheses.\\n\\nThere are many repeating subquestions in this recursive method, therefore, we could use dynamic programming to avoid this situation by saving the results for subquestions. Here is the DP solution.\\n```\\nclass Solution {\\n    vector<int> computeWithDP(string& str,unordered_map<string,vector<int>>& dpMap){\\n        int size=str.size();\\n        vector<int>result;\\n        for(int i=0;i<size;++i){\\n            char input=str[i];\\n            if(input==\\'+\\' || input==\\'-\\' || input==\\'*\\'){\\n                \\n                // Split input string into two parts and solve them recursively\\n                vector<int> result1, result2;\\n                string substr=str.substr(0,i);\\n                \\n                // check if dpMap has the result for substr\\n                if(dpMap.find(substr)!=dpMap.end())\\n                    result1=dpMap[substr];\\n                else\\n                    result1=computeWithDP(substr,dpMap);\\n                \\n                substr=str.substr(i+1);\\n                if(dpMap.find(substr)!=dpMap.end())\\n                    result2=dpMap[substr];\\n                else\\n                    result2=computeWithDP(substr,dpMap);\\n                \\n                for(auto &x: result1){\\n                    for(auto &y: result2){\\n                        if(input==\\'+\\') \\n                            result.push_back(x+y);\\n                        else if(input==\\'-\\')\\n                            result.push_back(x-y);\\n                        else\\n                            result.push_back(x*y);\\n                    }\\n                }\\n            }\\n        }\\n        // if the input string contains only number\\n        if(result.empty()) \\n            result.push_back(std::atoi(str.c_str()));\\n        \\n        // save to dpMap\\n        return dpMap[str]=result;\\n    }\\npublic:\\n    vector<int> diffWaysToCompute(string expression) {\\n        unordered_map<string, vector<int>> dpMap;\\n        return computeWithDP(expression,dpMap);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> computeWithDP(string& str,unordered_map<string,vector<int>>& dpMap){\\n        int size=str.size();\\n        vector<int>result;\\n        for(int i=0;i<size;++i){\\n            char input=str[i];\\n            if(input==\\'+\\' || input==\\'-\\' || input==\\'*\\'){\\n                \\n                // Split input string into two parts and solve them recursively\\n                vector<int> result1, result2;\\n                string substr=str.substr(0,i);\\n                \\n                // check if dpMap has the result for substr\\n                if(dpMap.find(substr)!=dpMap.end())\\n                    result1=dpMap[substr];\\n                else\\n                    result1=computeWithDP(substr,dpMap);\\n                \\n                substr=str.substr(i+1);\\n                if(dpMap.find(substr)!=dpMap.end())\\n                    result2=dpMap[substr];\\n                else\\n                    result2=computeWithDP(substr,dpMap);\\n                \\n                for(auto &x: result1){\\n                    for(auto &y: result2){\\n                        if(input==\\'+\\') \\n                            result.push_back(x+y);\\n                        else if(input==\\'-\\')\\n                            result.push_back(x-y);\\n                        else\\n                            result.push_back(x*y);\\n                    }\\n                }\\n            }\\n        }\\n        // if the input string contains only number\\n        if(result.empty()) \\n            result.push_back(std::atoi(str.c_str()));\\n        \\n        // save to dpMap\\n        return dpMap[str]=result;\\n    }\\npublic:\\n    vector<int> diffWaysToCompute(string expression) {\\n        unordered_map<string, vector<int>> dpMap;\\n        return computeWithDP(expression,dpMap);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155130,
                "title": "100-faster-c-memoization-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool isNumber(const string& str)\\n    {\\n        for (char const &c : str) {\\n            if (std::isdigit(c) == 0) return false;\\n        }\\n        return true;\\n    }\\n    map<pair<int,int>,vector<int>> mp;\\n    vector<int> rec(string s,int i,int j)\\n    {\\n        if(i == j || i+1 == j){\\n            return {stoi(s.substr(i,j+1-i))};\\n        }\\n        if(mp[{i,j}].size() != 0){\\n            return mp[{i,j}];\\n        }\\n        vector<int> ans;\\n        int k = i+1;\\n        while(k<j){\\n            if(!isdigit(s[k]))\\n            {\\n                vector<int> a = rec(s,i,k-1),b = rec(s,k+1,j);\\n                for(auto x:a){\\n                    for(auto y:b){\\n                        switch(s[k]){\\n                            case \\'+\\':\\n                                ans.push_back(x+y);\\n                                break;\\n                            case \\'-\\':\\n                                ans.push_back(x-y);\\n                                break;\\n                            case \\'*\\':\\n                                ans.push_back(x*y);\\n                                break;\\n                        }\\n                    }\\n                }\\n                \\n            }\\n            k++;\\n        }\\n        return mp[{i,j}] = ans;\\n    }\\n    vector<int> diffWaysToCompute(string s) {\\n        return rec(s,0,s.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isNumber(const string& str)\\n    {\\n        for (char const &c : str) {\\n            if (std::isdigit(c) == 0) return false;\\n        }\\n        return true;\\n    }\\n    map<pair<int,int>,vector<int>> mp;\\n    vector<int> rec(string s,int i,int j)\\n    {\\n        if(i == j || i+1 == j){\\n            return {stoi(s.substr(i,j+1-i))};\\n        }\\n        if(mp[{i,j}].size() != 0){\\n            return mp[{i,j}];\\n        }\\n        vector<int> ans;\\n        int k = i+1;\\n        while(k<j){\\n            if(!isdigit(s[k]))\\n            {\\n                vector<int> a = rec(s,i,k-1),b = rec(s,k+1,j);\\n                for(auto x:a){\\n                    for(auto y:b){\\n                        switch(s[k]){\\n                            case \\'+\\':\\n                                ans.push_back(x+y);\\n                                break;\\n                            case \\'-\\':\\n                                ans.push_back(x-y);\\n                                break;\\n                            case \\'*\\':\\n                                ans.push_back(x*y);\\n                                break;\\n                        }\\n                    }\\n                }\\n                \\n            }\\n            k++;\\n        }\\n        return mp[{i,j}] = ans;\\n    }\\n    vector<int> diffWaysToCompute(string s) {\\n        return rec(s,0,s.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034172,
                "title": "java-recursion-dfs-break-down-by-operator-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String expression) {\\n        if (expression.length() > 2){\\n            ArrayList<Integer> ls = new ArrayList<Integer>();\\n            for (int i = 0; i < expression.length(); i++){\\n                if (expression.charAt(i) < \\'0\\'){\\n                    Character operator = expression.charAt(i);\\n                    var left = diffWaysToCompute(expression.substring(0, i));\\n                    var right = diffWaysToCompute(expression.substring(i+1, expression.length()));\\n                    \\n                    for (var l : left){\\n                        for (var r:right){\\n                            if (operator == \\'+\\'){\\n                                ls.add(l+r);\\n                            } else if (operator == \\'-\\'){\\n                                ls.add(l-r);\\n                            } else {\\n                                ls.add(l*r);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            return ls;\\n        } else {\\n            return Arrays.asList(Integer.parseInt(expression));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String expression) {\\n        if (expression.length() > 2){\\n            ArrayList<Integer> ls = new ArrayList<Integer>();\\n            for (int i = 0; i < expression.length(); i++){\\n                if (expression.charAt(i) < \\'0\\'){\\n                    Character operator = expression.charAt(i);\\n                    var left = diffWaysToCompute(expression.substring(0, i));\\n                    var right = diffWaysToCompute(expression.substring(i+1, expression.length()));\\n                    \\n                    for (var l : left){\\n                        for (var r:right){\\n                            if (operator == \\'+\\'){\\n                                ls.add(l+r);\\n                            } else if (operator == \\'-\\'){\\n                                ls.add(l-r);\\n                            } else {\\n                                ls.add(l*r);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            return ls;\\n        } else {\\n            return Arrays.asList(Integer.parseInt(expression));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968886,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public List<Integer> diffWaysToCompute(String expression) {\\n\\treturn diffWaysToCompute(expression, new HashMap<>());}\\n\\n    private List<Integer> diffWaysToCompute(String expression, Map<String, List<Integer>> map) {\\n\\tif (map.containsKey(expression))\\n\\t\\treturn map.get(expression);\\n\\t\\t\\n\\tvar values = new ArrayList<Integer>();\\n\\tif (!hasOperator(expression)) {\\n\\t\\t// base case\\n\\t\\tvalues.add(Integer.parseInt(expression));\\n\\t} else {\\n\\t\\t// Recursive case. DFS\\n\\t\\tfor (var i = 0; i < expression.length(); i++) {\\n\\t\\t\\tvar symbol = expression.charAt(i);\\n\\t\\t\\n\\t\\t\\tif (!Character.isDigit(symbol)) {\\n\\t\\t\\t\\tvar left = diffWaysToCompute(expression.substring(0, i), map);\\n\\t\\t\\t\\tvar right = diffWaysToCompute(expression.substring(i + 1), map);\\n\\t\\t\\t\\tfor (var l : left) {\\n\\t\\t\\t\\t\\tfor (var r : right) {\\n\\t\\t\\t\\t\\t\\tswitch (symbol) {\\n\\t\\t\\t\\t\\t\\t\\tcase \\'+\\' -> values.add(l + r);\\n\\t\\t\\t\\t\\t\\t\\tcase \\'-\\' -> values.add(l - r);\\n\\t\\t\\t\\t\\t\\t\\tcase \\'*\\' -> values.add(l * r);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\tmap.put(expression, values);\\n\\treturn values;}\\n\\n    private boolean hasOperator(String expression) {\\n\\tfor (var i = 0; i < expression.length(); i++)\\n\\t\\tswitch (expression.charAt(i)) {\\n\\t\\t\\tcase \\'+\\', \\'-\\', \\'*\\' -> {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn false;\\n\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public List<Integer> diffWaysToCompute(String expression) {\\n\\treturn diffWaysToCompute(expression, new HashMap<>());}",
                "codeTag": "Java"
            },
            {
                "id": 1966802,
                "title": "simple-python",
                "content": "```\\nclass Solution:\\n    def diffWaysToCompute(self, exp: str) -> List[int]:\\n        res=[]\\n        for i,v in enumerate(exp):\\n            if v==\\'*\\' or v==\\'+\\' or v==\\'-\\':\\n                left = self.diffWaysToCompute(exp[:i])\\n                right = self.diffWaysToCompute(exp[i+1:])\\n                \\n                for i in left:\\n                    for j in right:\\n                        if v==\\'*\\':\\n                            res.append(i*j)\\n                        elif v==\\'-\\':\\n                            res.append(i-j)\\n                        else:\\n                            res.append(i+j)\\n                    \\n        return res or [int(exp)]",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def diffWaysToCompute(self, exp: str) -> List[int]:\\n        res=[]\\n        for i,v in enumerate(exp):\\n            if v==\\'*\\' or v==\\'+\\' or v==\\'-\\':\\n                left = self.diffWaysToCompute(exp[:i])\\n                right = self.diffWaysToCompute(exp[i+1:])\\n                \\n                for i in left:\\n                    for j in right:\\n                        if v==\\'*\\':\\n                            res.append(i*j)\\n                        elif v==\\'-\\':\\n                            res.append(i-j)\\n                        else:\\n                            res.append(i+j)\\n                    \\n        return res or [int(exp)]",
                "codeTag": "Java"
            },
            {
                "id": 1545187,
                "title": "python-dc-solution-intutive-and-easy",
                "content": "the main idea is when occurs to `-+*`, you can divide the expression into `left` and `right` part.\\nLeft and right mean that you have computed the left and right part, just combine them into the whole expression.\\n```\\nclass Solution:\\n    def diffWaysToCompute(self, expression: str):\\n        if expression.isdigit():\\n            return [int(expression)]\\n        res = []\\n        for i in range(len(expression)):\\n            if expression[i] in \"-+*\":\\n                left = self.diffWaysToCompute(expression[:i])\\n                right = self.diffWaysToCompute(expression[i + 1 :])\\n                for l in left:\\n                    for r in right:\\n                        if expression[i] == \"-\":\\n                            res.append(l - r)\\n                        elif expression[i] == \"+\":\\n                            res.append(l + r)\\n                        else:\\n                            res.append(l * r)\\n        return res\\n",
                "solutionTags": [],
                "code": "the main idea is when occurs to `-+*`, you can divide the expression into `left` and `right` part.\\nLeft and right mean that you have computed the left and right part, just combine them into the whole expression.\\n```\\nclass Solution:\\n    def diffWaysToCompute(self, expression: str):\\n        if expression.isdigit():\\n            return [int(expression)]\\n        res = []\\n        for i in range(len(expression)):\\n            if expression[i] in \"-+*\":\\n                left = self.diffWaysToCompute(expression[:i])\\n                right = self.diffWaysToCompute(expression[i + 1 :])\\n                for l in left:\\n                    for r in right:\\n                        if expression[i] == \"-\":\\n                            res.append(l - r)\\n                        elif expression[i] == \"+\":\\n                            res.append(l + r)\\n                        else:\\n                            res.append(l * r)\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 1463185,
                "title": "recursive-dp-java-solution-0ms-98-51-memory",
                "content": "Iterate over all characters.\\nWhen you encounter an operation, perform the method(recursion) on the left side, then perform on the right side as well(recursion).\\nCombine the each value from the left list to each value of the right list using the operation encountered before.\\nreturn the collected values.\\nBase case: there is no operation detected in the provided substring, return the number.\\nMemo: save the lists on the memo before returning and check before doing the recursion.\\n```\\nclass Solution {\\n\\n    List<Integer>[][] memo;\\n    public List<Integer> diffWaysToCompute(String expression) {\\n        memo = new List[expression.length()][expression.length()];\\n        return diffWaysToCompute(0,expression.length()-1,expression);\\n    }\\n    public List<Integer> diffWaysToCompute(int index1, int index2, String expression){\\n        if(memo[index1][index2]!=null) return memo[index1][index2];\\n        ArrayList<Integer> answers = new ArrayList<>();\\n        boolean hasOperation = false;\\n        for(int i = index1; i <=index2; i++){\\n            char c = expression.charAt(i);\\n            if(c<48){\\n                hasOperation=true;\\n                List<Integer> left = diffWaysToCompute(index1,i-1,expression);\\n                List<Integer> right = diffWaysToCompute(i+1,index2,expression);\\n                for(int l: left){\\n                    for(int r: right){\\n//                        System.out.format(\"%d, %d %n\",l,r);\\n                        switch(c){\\n                            case \\'+\\'-> answers.add(l+r);\\n                            case \\'*\\'-> answers.add(l*r);\\n                            case \\'-\\'-> answers.add(l-r);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(!hasOperation){\\n            int num = 0;\\n            for(int i = index1; i<=index2; i++){\\n                num = num*10+(expression.charAt(i)-48);\\n            }\\n            answers.add(num);\\n        }\\n        memo[index1][index2] = answers;\\n        return answers;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    List<Integer>[][] memo;\\n    public List<Integer> diffWaysToCompute(String expression) {\\n        memo = new List[expression.length()][expression.length()];\\n        return diffWaysToCompute(0,expression.length()-1,expression);\\n    }\\n    public List<Integer> diffWaysToCompute(int index1, int index2, String expression){\\n        if(memo[index1][index2]!=null) return memo[index1][index2];\\n        ArrayList<Integer> answers = new ArrayList<>();\\n        boolean hasOperation = false;\\n        for(int i = index1; i <=index2; i++){\\n            char c = expression.charAt(i);\\n            if(c<48){\\n                hasOperation=true;\\n                List<Integer> left = diffWaysToCompute(index1,i-1,expression);\\n                List<Integer> right = diffWaysToCompute(i+1,index2,expression);\\n                for(int l: left){\\n                    for(int r: right){\\n//                        System.out.format(\"%d, %d %n\",l,r);\\n                        switch(c){\\n                            case \\'+\\'-> answers.add(l+r);\\n                            case \\'*\\'-> answers.add(l*r);\\n                            case \\'-\\'-> answers.add(l-r);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(!hasOperation){\\n            int num = 0;\\n            for(int i = index1; i<=index2; i++){\\n                num = num*10+(expression.charAt(i)-48);\\n            }\\n            answers.add(num);\\n        }\\n        memo[index1][index2] = answers;\\n        return answers;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350070,
                "title": "short-and-simple-recursion-memoization-100-time-efficient",
                "content": "```\\n\\tunordered_map<string, vector<int>> m;\\n    \\n    vector<int> diffWaysToCompute(string str) {\\n        if(m.count(str)) return m[str];\\n        vector<int> ans;\\n        int n = str.size();\\n        for(int i=0; i<n; i++) {\\n            if(str[i]==\\'+\\' || str[i]==\\'-\\' || str[i]==\\'*\\') {\\n                vector<int> left = diffWaysToCompute(str.substr(0, i));\\n                vector<int> right = diffWaysToCompute(str.substr(i+1));\\n                for(auto &num1 : left) {\\n                    for(auto &num2 : right) {\\n                        if(str[i]==\\'+\\') ans.push_back(num1+num2);\\n                        if(str[i]==\\'-\\') ans.push_back(num1-num2);\\n                        if(str[i]==\\'*\\') ans.push_back(num1*num2);\\n                    }\\n                }\\n            }\\n        }\\n        if(ans.empty()) ans.push_back(stoi(str));\\n        return m[str] = ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tunordered_map<string, vector<int>> m;\\n    \\n    vector<int> diffWaysToCompute(string str) {\\n        if(m.count(str)) return m[str];\\n        vector<int> ans;\\n        int n = str.size();\\n        for(int i=0; i<n; i++) {\\n            if(str[i]==\\'+\\' || str[i]==\\'-\\' || str[i]==\\'*\\') {\\n                vector<int> left = diffWaysToCompute(str.substr(0, i));\\n                vector<int> right = diffWaysToCompute(str.substr(i+1));\\n                for(auto &num1 : left) {\\n                    for(auto &num2 : right) {\\n                        if(str[i]==\\'+\\') ans.push_back(num1+num2);\\n                        if(str[i]==\\'-\\') ans.push_back(num1-num2);\\n                        if(str[i]==\\'*\\') ans.push_back(num1*num2);\\n                    }\\n                }\\n            }\\n        }\\n        if(ans.empty()) ans.push_back(stoi(str));\\n        return m[str] = ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1312514,
                "title": "c-bottom-up-dp-faster-than-100",
                "content": "```\\nint expsolve(int x,int y,char c)\\n{\\n    if(c==\\'+\\')\\n        return x+y;\\n    if(c==\\'-\\')\\n        return x-y;\\n    if(c==\\'*\\')\\n        return x*y;\\n    return x/y;\\n}\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string s) {\\n        string x=\"0\";\\n        vector<int>v;\\n        vector<char>v1;\\n        for(auto it:s)\\n        {\\n            if(!(it>=\\'0\\'&&it<=\\'9\\'))\\n            {\\n                v.push_back(stoi(x));\\n                v1.push_back(it);\\n                x=\"0\";\\n                continue;\\n            }\\n            x+=it;\\n        }\\n        v.push_back(stoi(x));\\n        int n=v.size();\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(n));\\n        for(int k=0;k<n;k++)\\n        {\\n            for(int i=0;i+k<n;i++)\\n            {\\n                if(k==0)\\n                    dp[i][i].push_back(v[i]);\\n                else\\n                {\\n                    for(int j=i;j<i+k;j++)\\n                    {\\n                        for(auto it:dp[i][j])\\n                        {\\n                            for(auto it1:dp[j+1][i+k])\\n                                dp[i][i+k].push_back(expsolve(it,it1,v1[j]));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint expsolve(int x,int y,char c)\\n{\\n    if(c==\\'+\\')\\n        return x+y;\\n    if(c==\\'-\\')\\n        return x-y;\\n    if(c==\\'*\\')\\n        return x*y;\\n    return x/y;\\n}\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string s) {\\n        string x=\"0\";\\n        vector<int>v;\\n        vector<char>v1;\\n        for(auto it:s)\\n        {\\n            if(!(it>=\\'0\\'&&it<=\\'9\\'))\\n            {\\n                v.push_back(stoi(x));\\n                v1.push_back(it);\\n                x=\"0\";\\n                continue;\\n            }\\n            x+=it;\\n        }\\n        v.push_back(stoi(x));\\n        int n=v.size();\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(n));\\n        for(int k=0;k<n;k++)\\n        {\\n            for(int i=0;i+k<n;i++)\\n            {\\n                if(k==0)\\n                    dp[i][i].push_back(v[i]);\\n                else\\n                {\\n                    for(int j=i;j<i+k;j++)\\n                    {\\n                        for(auto it:dp[i][j])\\n                        {\\n                            for(auto it1:dp[j+1][i+k])\\n                                dp[i][i+k].push_back(expsolve(it,it1,v1[j]));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997709,
                "title": "java-solution-explained-recursion-1-ms",
                "content": "**Idea** : Idea is to partition the string into two parts whenever we find binary operator and now solve the question for smaller problem, that is Greedy approach . This process keep going until we hit a string of length = 1, our base case. \\n![image](https://assets.leetcode.com/users/images/32044bb6-bdcb-4dab-b30f-39702f7a73a3_1609571948.149371.png)\\nImage credit goes to [Codebix](https://www.youtube.com/channel/UCZJRtZh8O6FKWH49YLapAbQ)\\n\\n```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        \\n        //Base case\\n        if(input.length()==1){\\n            List<Integer>temp = new ArrayList<>();\\n            int num = input.charAt(0)-\\'0\\';\\n            temp.add(num);\\n            return temp;\\n        }\\n        List<Integer>ans = new ArrayList<>();\\n        for(int i=0;i<input.length();i++){\\n            \\n            //If there is a binary operator, then partition\\n            if(input.charAt(i)==\\'+\\'||input.charAt(i)==\\'-\\'||input.charAt(i)==\\'*\\'){\\n                String p1 = input.substring(0,i);\\n                String p2 = input.substring(i+1);\\n                \\n                List<Integer>res1 = diffWaysToCompute(p1);\\n                List<Integer>res2 = diffWaysToCompute(p2);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//Now compute values using both parts\\n                for(int t1 : res1){\\n                    for(int t2 : res2){\\n                        if(input.charAt(i)==\\'+\\'){\\n                            ans.add(t1+t2);\\n                        }else if(input.charAt(i)==\\'-\\'){\\n                            ans.add(t1-t2);\\n                        }else {\\n                            ans.add(t1*t2);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //Means there is no operator in Input string, that\\'s why ans list is empty\\n        if(ans.size()==0)ans.add(Integer.valueOf(input));\\n        return ans;\\n        \\n    }\\n}\\n```\\n\\n**Note** : I didn\\'t use DP because it was already showing 99% faster solution, so, I didn\\'t apply DP. Though DP can be applied using HashMap and then it will become more faster.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        \\n        //Base case\\n        if(input.length()==1){\\n            List<Integer>temp = new ArrayList<>();\\n            int num = input.charAt(0)-\\'0\\';\\n            temp.add(num);\\n            return temp;\\n        }\\n        List<Integer>ans = new ArrayList<>();\\n        for(int i=0;i<input.length();i++){\\n            \\n            //If there is a binary operator, then partition\\n            if(input.charAt(i)==\\'+\\'||input.charAt(i)==\\'-\\'||input.charAt(i)==\\'*\\'){\\n                String p1 = input.substring(0,i);\\n                String p2 = input.substring(i+1);\\n                \\n                List<Integer>res1 = diffWaysToCompute(p1);\\n                List<Integer>res2 = diffWaysToCompute(p2);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//Now compute values using both parts\\n                for(int t1 : res1){\\n                    for(int t2 : res2){\\n                        if(input.charAt(i)==\\'+\\'){\\n                            ans.add(t1+t2);\\n                        }else if(input.charAt(i)==\\'-\\'){\\n                            ans.add(t1-t2);\\n                        }else {\\n                            ans.add(t1*t2);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //Means there is no operator in Input string, that\\'s why ans list is empty\\n        if(ans.size()==0)ans.add(Integer.valueOf(input));\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847165,
                "title": "java-divide-and-conquer-soltion-easy-to-understand",
                "content": "```\\nclass Solution {\\n    Map<String, List<Integer>> memo = new HashMap<>();\\n    public List<Integer> diffWaysToCompute(String input) {\\n        if (memo.containsKey(input)) {\\n            return memo.get(input);\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < input.length(); ++i) {\\n            char c = input.charAt(i);\\n            if (c == \\'+\\' || c == \\'-\\' || c == \\'*\\') {\\n                List<Integer> left = diffWaysToCompute(input.substring(0, i));\\n                List<Integer> right = diffWaysToCompute(input.substring(i + 1));\\n                for (int j = 0; j < left.size(); ++j) {\\n                    for (int k = 0; k < right.size(); ++k) {\\n                        if (c == \\'+\\') {\\n                            res.add(left.get(j) + right.get(k));\\n                        } else if (c == \\'-\\') {\\n                            res.add(left.get(j) - right.get(k));\\n                        } else {\\n                            res.add(left.get(j) * right.get(k));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if (input.matches(\"[0-9]+\")) {\\n            res.add(Integer.valueOf(input));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, List<Integer>> memo = new HashMap<>();\\n    public List<Integer> diffWaysToCompute(String input) {\\n        if (memo.containsKey(input)) {\\n            return memo.get(input);\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < input.length(); ++i) {\\n            char c = input.charAt(i);\\n            if (c == \\'+\\' || c == \\'-\\' || c == \\'*\\') {\\n                List<Integer> left = diffWaysToCompute(input.substring(0, i));\\n                List<Integer> right = diffWaysToCompute(input.substring(i + 1));\\n                for (int j = 0; j < left.size(); ++j) {\\n                    for (int k = 0; k < right.size(); ++k) {\\n                        if (c == \\'+\\') {\\n                            res.add(left.get(j) + right.get(k));\\n                        } else if (c == \\'-\\') {\\n                            res.add(left.get(j) - right.get(k));\\n                        } else {\\n                            res.add(left.get(j) * right.get(k));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if (input.matches(\"[0-9]+\")) {\\n            res.add(Integer.valueOf(input));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 611789,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        List<Integer>res=new ArrayList<>();\\n        for(int i=0;i<input.length();i++){\\n            char c=input.charAt(i);\\n            if(c!=\\'+\\'&&c!=\\'-\\'&&c!=\\'*\\')continue;\\n            List<Integer>list1=diffWaysToCompute(input.substring(0,i));\\n            List<Integer>list2=diffWaysToCompute(input.substring(i+1,input.length()));\\n            if(c==\\'+\\'){\\n                 for(int j=0;j<list1.size();j++){\\n                    for(int k=0;k<list2.size();k++){\\n                            res.add(list1.get(j)+list2.get(k));\\n                    }\\n                }\\n            }\\n            else if(c==\\'-\\'){\\n                 for(int j=0;j<list1.size();j++){\\n                    for(int k=0;k<list2.size();k++){\\n                            res.add(list1.get(j)-list2.get(k));\\n                    }\\n                }\\n            }\\n            else if(c==\\'*\\'){\\n                for(int j=0;j<list1.size();j++){\\n                    for(int k=0;k<list2.size();k++){\\n                            res.add(list1.get(j)*list2.get(k));\\n                    }\\n                }\\n            }\\n        }\\n        if(res.size()==0){\\n            res.add(Integer.parseInt(input));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        List<Integer>res=new ArrayList<>();\\n        for(int i=0;i<input.length();i++){\\n            char c=input.charAt(i);\\n            if(c!=\\'+\\'&&c!=\\'-\\'&&c!=\\'*\\')continue;\\n            List<Integer>list1=diffWaysToCompute(input.substring(0,i));\\n            List<Integer>list2=diffWaysToCompute(input.substring(i+1,input.length()));\\n            if(c==\\'+\\'){\\n                 for(int j=0;j<list1.size();j++){\\n                    for(int k=0;k<list2.size();k++){\\n                            res.add(list1.get(j)+list2.get(k));\\n                    }\\n                }\\n            }\\n            else if(c==\\'-\\'){\\n                 for(int j=0;j<list1.size();j++){\\n                    for(int k=0;k<list2.size();k++){\\n                            res.add(list1.get(j)-list2.get(k));\\n                    }\\n                }\\n            }\\n            else if(c==\\'*\\'){\\n                for(int j=0;j<list1.size();j++){\\n                    for(int k=0;k<list2.size();k++){\\n                            res.add(list1.get(j)*list2.get(k));\\n                    }\\n                }\\n            }\\n        }\\n        if(res.size()==0){\\n            res.add(Integer.parseInt(input));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 605583,
                "title": "simple-divide-and-conquer-solution-python",
                "content": "```\\nclass Solution:\\n    def diffWaysToCompute(self, input: str) -> List[int]:\\n        \\n        \\n        def helper(string):\\n            \\n            result=[]\\n            \\n            for i, c in enumerate(string):\\n                \\n                if c in \"+-*\":\\n                    x=helper(string[:i])\\n                    y=helper(string[i+1:])\\n                    \\n                    for a in x:\\n                        for b in y:\\n                            \\n                            if c==\\'+\\':\\n                                result.append(a+b)\\n                            elif c==\\'-\\':\\n                                result.append(a-b)\\n                            else:\\n                                result.append(a*b)\\n                                \\n            if not result:\\n                return [int(string)]\\n            \\n            return result\\n        \\n        return helper(input)\\n            \\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def diffWaysToCompute(self, input: str) -> List[int]:\\n        \\n        \\n        def helper(string):\\n            \\n            result=[]\\n            \\n            for i, c in enumerate(string):\\n                \\n                if c in \"+-*\":\\n                    x=helper(string[:i])\\n                    y=helper(string[i+1:])\\n                    \\n                    for a in x:\\n                        for b in y:\\n                            \\n                            if c==\\'+\\':\\n                                result.append(a+b)\\n                            elif c==\\'-\\':\\n                                result.append(a-b)\\n                            else:\\n                                result.append(a*b)\\n                                \\n            if not result:\\n                return [int(string)]\\n            \\n            return result\\n        \\n        return helper(input)\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 541538,
                "title": "c-divideconquer-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string input) {\\n        return divideConquer(input, 0, input.size() - 1);\\n    }\\n    vector<int> divideConquer(const string& input, int left, int right)\\n    {\\n        vector<int> res;\\n        for (int i = left; i <= right; ++i) {\\n            if (input[i] == \\'+\\' || input[i] == \\'-\\' || input[i] == \\'*\\') {\\n                vector<int> leftVec =  divideConquer(input, left, i - 1);\\n                vector<int> rightVec =  divideConquer(input, i + 1, right);\\n                for (int j = 0; j < leftVec.size(); ++j) {\\n                    for (int k = 0; k < rightVec.size(); ++k) {\\n                        res.push_back(help(leftVec[j], rightVec[k], input[i]));\\n                    }\\n                }\\n            }\\n        }\\n        if (res.size() == 0) {\\n            res.push_back(stoi(input.substr(left, right - left + 1)));\\n        }\\n        return res;\\n    }\\n    int help(int l, int r, char op)\\n    {\\n        int ret = 0;\\n        \\n        switch(op) {\\n            case \\'+\\':\\n                ret = l + r;\\n                break;\\n            case \\'-\\':\\n                ret = l - r;\\n                break;\\n            case \\'*\\':\\n                ret = l * r;\\n                break;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string input) {\\n        return divideConquer(input, 0, input.size() - 1);\\n    }\\n    vector<int> divideConquer(const string& input, int left, int right)\\n    {\\n        vector<int> res;\\n        for (int i = left; i <= right; ++i) {\\n            if (input[i] == \\'+\\' || input[i] == \\'-\\' || input[i] == \\'*\\') {\\n                vector<int> leftVec =  divideConquer(input, left, i - 1);\\n                vector<int> rightVec =  divideConquer(input, i + 1, right);\\n                for (int j = 0; j < leftVec.size(); ++j) {\\n                    for (int k = 0; k < rightVec.size(); ++k) {\\n                        res.push_back(help(leftVec[j], rightVec[k], input[i]));\\n                    }\\n                }\\n            }\\n        }\\n        if (res.size() == 0) {\\n            res.push_back(stoi(input.substr(left, right - left + 1)));\\n        }\\n        return res;\\n    }\\n    int help(int l, int r, char op)\\n    {\\n        int ret = 0;\\n        \\n        switch(op) {\\n            case \\'+\\':\\n                ret = l + r;\\n                break;\\n            case \\'-\\':\\n                ret = l - r;\\n                break;\\n            case \\'*\\':\\n                ret = l * r;\\n                break;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538042,
                "title": "python-3-divide-and-conquer",
                "content": "```\\nclass Solution:\\n    def diffWaysToCompute(self, input: str) -> List[int]:\\n        res = []\\n        for i in range(len(input)):\\n            if input[i] in \\'+-*\\':\\n                left = self.diffWaysToCompute(input[:i])\\n                right = self.diffWaysToCompute(input[i+1:])\\n                for l in left:\\n                    for r in right:\\n                        if input[i]==\\'+\\':\\n                            res.append(l+r)\\n                        elif input[i]==\\'-\\':\\n                            res.append(l-r)\\n                        elif input[i]==\\'*\\':\\n                            res.append(l*r)\\n        if not res:\\n            return [int(input)]\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diffWaysToCompute(self, input: str) -> List[int]:\\n        res = []\\n        for i in range(len(input)):\\n            if input[i] in \\'+-*\\':\\n                left = self.diffWaysToCompute(input[:i])\\n                right = self.diffWaysToCompute(input[i+1:])\\n                for l in left:\\n                    for r in right:\\n                        if input[i]==\\'+\\':\\n                            res.append(l+r)\\n                        elif input[i]==\\'-\\':\\n                            res.append(l-r)\\n                        elif input[i]==\\'*\\':\\n                            res.append(l*r)\\n        if not res:\\n            return [int(input)]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348232,
                "title": "python-divide-and-conquer",
                "content": "```\\nfrom operator import mul, add, sub\\nclass Solution:\\n    \\n    OP = {\\'*\\':mul,\\'+\\':add,\\'-\\':sub}\\n    op_set = set([\\'+\\',\\'*\\',\\'-\\'])\\n    \\n    def diffWaysToCompute(self, S: str) -> List[int]:\\n        if S.isdigit():\\n            return [int(S)]\\n        else:\\n            res = []\\n            for i,s in enumerate(S):\\n                if s in Solution.op_set:\\n                    L = self.diffWaysToCompute(S[:i])\\n                    R = self.diffWaysToCompute(S[i+1:])\\n                    for l in L:\\n                        for r in R:\\n                            res.append(Solution.OP[s](l,r))\\n            return res                           \\n```",
                "solutionTags": [],
                "code": "```\\nfrom operator import mul, add, sub\\nclass Solution:\\n    \\n    OP = {\\'*\\':mul,\\'+\\':add,\\'-\\':sub}\\n    op_set = set([\\'+\\',\\'*\\',\\'-\\'])\\n    \\n    def diffWaysToCompute(self, S: str) -> List[int]:\\n        if S.isdigit():\\n            return [int(S)]\\n        else:\\n            res = []\\n            for i,s in enumerate(S):\\n                if s in Solution.op_set:\\n                    L = self.diffWaysToCompute(S[:i])\\n                    R = self.diffWaysToCompute(S[i+1:])\\n                    for l in L:\\n                        for r in R:\\n                            res.append(Solution.OP[s](l,r))\\n            return res                           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 327136,
                "title": "dynamic-programming-solution-with-explanation",
                "content": "**Intuition**: We just need to store the `left_val` and `right_val` in the DP table when we are evaluating `\"<left_val> + <right_val>\"`. However, we cannot access the `right_val` when we are iterating from left to right. \\n\\n**Non-intuitive**: \\n1. Use the DP iteration technique **extend-right-then-reverse-extend-left** (I coined the term) when iterating through the string. In other words, for a string like this `a + b - c * d`, our operations are `\"<<a + b>> - c * d\"  ->  \"<a + <b - c>> * d\" -> \"<<a + b - c>> * d\" -> \"<a + b - <c * d>>\" -> \"<a + <b - c * d>>\" -> \"<<a + b - c * d>>\"` \\n2. Store the integers and operational characters in two different arrays. To find the result of `integers[start:end+1]`, the operational characters between them are `ops[start:end]`. E.g. `s = \"6 - 3 + 1\" ==> integers = [6, 3, 1]; ops = [-, +]`\\n\\n```python\\nclass Solution:\\n    def diffWaysToCompute(self, input: str) -> List[int]:\\n        nums = []\\n        ops = []\\n        \\n        num = 0\\n        for i in range(len(input)):\\n            if input[i] in \\'+-*\\':\\n                nums.append(num)\\n                num = 0\\n                ops.append(input[i])\\n            else:\\n                num = num * 10 + int(input[i])\\n        nums.append(num)\\n        \\n        dp = [[[] for _ in range(len(nums))] for _ in range(len(nums))] \\n        for end in range(len(nums)):\\n            for start in reversed(range(end + 1)):\\n                if start == end:\\n                    dp[start][end].append(nums[start])\\n                else:\\n                    for op in range(start, end):\\n                        for lval in dp[start][op]:\\n                            for rval in dp[op+1][end]:\\n                                if ops[op] == \\'+\\':\\n                                    dp[start][end].append(lval + rval)\\n                                elif ops[op] == \\'-\\':\\n                                    dp[start][end].append(lval - rval)\\n                                else:\\n                                    dp[start][end].append(lval * rval)\\n\\n        return dp[0][-1]\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def diffWaysToCompute(self, input: str) -> List[int]:\\n        nums = []\\n        ops = []\\n        \\n        num = 0\\n        for i in range(len(input)):\\n            if input[i] in \\'+-*\\':\\n                nums.append(num)\\n                num = 0\\n                ops.append(input[i])\\n            else:\\n                num = num * 10 + int(input[i])\\n        nums.append(num)\\n        \\n        dp = [[[] for _ in range(len(nums))] for _ in range(len(nums))] \\n        for end in range(len(nums)):\\n            for start in reversed(range(end + 1)):\\n                if start == end:\\n                    dp[start][end].append(nums[start])\\n                else:\\n                    for op in range(start, end):\\n                        for lval in dp[start][op]:\\n                            for rval in dp[op+1][end]:\\n                                if ops[op] == \\'+\\':\\n                                    dp[start][end].append(lval + rval)\\n                                elif ops[op] == \\'-\\':\\n                                    dp[start][end].append(lval - rval)\\n                                else:\\n                                    dp[start][end].append(lval * rval)\\n\\n        return dp[0][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 297543,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public IList<int> DiffWaysToCompute(string input) {\\n        var result = new List<int>();\\n\\n        var isNumber = true;\\n        for (int i = 0; i < input.Length; i++) {\\n            var cur = input[i];\\n            if (cur == \\'-\\' || cur == \\'+\\' || cur == \\'*\\') {\\n                isNumber = false;\\n                var leftList = DiffWaysToCompute(input.Substring(0, i));\\n                var rightList = DiffWaysToCompute(input.Substring(i + 1));\\n\\n                foreach (var left in leftList) {\\n                    foreach (var right in rightList) {\\n                        if (cur == \\'-\\') {\\n                            result.Add(left - right);\\n                        } else if (cur == \\'+\\') {\\n                            result.Add(left + right);\\n                        } else\\n                            // if (cur == \\'*\\') {\\n                            result.Add(left * right);\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (isNumber) {\\n            result.Add(int.Parse(input));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<int> DiffWaysToCompute(string input) {\\n        var result = new List<int>();\\n\\n        var isNumber = true;\\n        for (int i = 0; i < input.Length; i++) {\\n            var cur = input[i];\\n            if (cur == \\'-\\' || cur == \\'+\\' || cur == \\'*\\') {\\n                isNumber = false;\\n                var leftList = DiffWaysToCompute(input.Substring(0, i));\\n                var rightList = DiffWaysToCompute(input.Substring(i + 1));\\n\\n                foreach (var left in leftList) {\\n                    foreach (var right in rightList) {\\n                        if (cur == \\'-\\') {\\n                            result.Add(left - right);\\n                        } else if (cur == \\'+\\') {\\n                            result.Add(left + right);\\n                        } else\\n                            // if (cur == \\'*\\') {\\n                            result.Add(left * right);\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (isNumber) {\\n            result.Add(int.Parse(input));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 145156,
                "title": "python-beat-100",
                "content": "28 ms beat 100%\\n```\\ndef diffWaysToCompute(self, input):\\n        \"\"\"\\n        :type input: str\\n        :rtype: List[int]\\n        \"\"\"\\n        def helper(m, n, op):\\n            if op == \"+\":\\n                return m + n\\n            elif op == \"-\":\\n                return m - n\\n            else:\\n                return m * n\\n        if input.isdigit():\\n            return [int(input)]\\n        ans = []\\n        for i in xrange(len(input)):\\n            if input[i] in \"+-*\":\\n                left = self.diffWaysToCompute(input[:i])\\n                right = self.diffWaysToCompute(input[i + 1:])\\n                ans.extend([helper(l, r, input[i]) for l in left for r in right])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef diffWaysToCompute(self, input):\\n        \"\"\"\\n        :type input: str\\n        :rtype: List[int]\\n        \"\"\"\\n        def helper(m, n, op):\\n            if op == \"+\":\\n                return m + n\\n            elif op == \"-\":\\n                return m - n\\n            else:\\n                return m * n\\n        if input.isdigit():\\n            return [int(input)]\\n        ans = []\\n        for i in xrange(len(input)):\\n            if input[i] in \"+-*\":\\n                left = self.diffWaysToCompute(input[:i])\\n                right = self.diffWaysToCompute(input[i + 1:])\\n                ans.extend([helper(l, r, input[i]) for l in left for r in right])\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 66335,
                "title": "c-recursion-solution",
                "content": "    vector<int> diffWaysToCompute(string input) \\n    {\\n        vector<int> result;\\n        \\n        for (int k = 0; k < input.size(); k++)\\n        {\\n            if (input[k] == '*' || input[k] == '-' || input[k] == '+')\\n            {\\n                vector<int> left = diffWaysToCompute(input.substr(0, k));\\n                vector<int> right = diffWaysToCompute(input.substr(k + 1));\\n                for (int i = 0; i < left.size(); i++)\\n                {\\n                    for (int j = 0; j < right.size(); j++)\\n                    {\\n                        if (input[k] == '*')\\n                            result.push_back(left[i] * right[j]);\\n                        else if (input[k] == '-')\\n                            result.push_back(left[i] - right[j]);\\n                        else\\n                          result.push_back(left[i] + right[j]);  \\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (result.empty())\\n            result.push_back((int)atoi(input.c_str()));\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    vector<int> diffWaysToCompute(string input) \\n    {\\n        vector<int> result;\\n        \\n        for (int k = 0; k < input.size(); k++)\\n        {\\n            if (input[k] == '*' || input[k] == '-' || input[k] == '+')\\n            {\\n                vector<int> left = diffWaysToCompute(input.substr(0, k));\\n                vector<int> right = diffWaysToCompute(input.substr(k + 1));\\n                for (int i = 0; i < left.size(); i++)\\n                {\\n                    for (int j = 0; j < right.size(); j++)\\n                    {\\n                        if (input[k] == '*')\\n                            result.push_back(left[i] * right[j]);\\n                        else if (input[k] == '-')\\n                            result.push_back(left[i] - right[j]);\\n                        else\\n                          result.push_back(left[i] + right[j]);  \\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (result.empty())\\n            result.push_back((int)atoi(input.c_str()));\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 66345,
                "title": "swift-solution-divide-and-conquer",
                "content": "```\\nclass Solution {\\n    func diffWaysToCompute(_ input: String) -> [Int] {\\n        let characters = Array(input.characters)\\n        var result = [Int]()\\n        \\n        for i in 0..<characters.count {\\n            if characters[i] == \"-\" || characters[i] == \"*\" || characters[i] == \"+\" {\\n                let part1 = String(characters[0...(i - 1)])\\n                let part2 = String(characters[(i + 1)...(characters.count - 1)])\\n                let part1Result = diffWaysToCompute(part1)\\n                let part2Result = diffWaysToCompute(part2)\\n                for p1 in part1Result {\\n                    for p2 in part2Result {\\n                        var sum = 0\\n                        if characters[i] == \"+\" {\\n                            sum = p1 + p2\\n                        } else if characters[i] == \"-\" {\\n                            sum = p1 - p2\\n                        } else if characters[i] == \"*\" {\\n                            sum = p1 * p2\\n                        }\\n                        result.append(sum)\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result.count == 0 ? [Int(input)!] : result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func diffWaysToCompute(_ input: String) -> [Int] {\\n        let characters = Array(input.characters)\\n        var result = [Int]()\\n        \\n        for i in 0..<characters.count {\\n            if characters[i] == \"-\" || characters[i] == \"*\" || characters[i] == \"+\" {\\n                let part1 = String(characters[0...(i - 1)])\\n                let part2 = String(characters[(i + 1)...(characters.count - 1)])\\n                let part1Result = diffWaysToCompute(part1)\\n                let part2Result = diffWaysToCompute(part2)\\n                for p1 in part1Result {\\n                    for p2 in part2Result {\\n                        var sum = 0\\n                        if characters[i] == \"+\" {\\n                            sum = p1 + p2\\n                        } else if characters[i] == \"-\" {\\n                            sum = p1 - p2\\n                        } else if characters[i] == \"*\" {\\n                            sum = p1 * p2\\n                        }\\n                        result.append(sum)\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result.count == 0 ? [Int(input)!] : result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66365,
                "title": "what-is-the-time-complexity-for-the-dp-version",
                "content": "I think it is O(n^5). Let me explain:\\n\\nthere are n^2 subproblems, since each subproblem is defined by a start and end index (at least how i did it. \\nNow for each subproblem, u have to loop from the start to the end index, and then evaluate everything to the left of the operator, and to the right of the operator. so for example if you have \"2*3+5*7\", and you are at the \"+\", you get all the ways to evaluate 2*3, and all the ways to evaluate 5*7, then you go through all the pairings of those and evaluate, so this takes n^2 work, \\nso therefore each subproblem takes n^3 non recursive work to do, and there are n^2 subproblems, so the total time complexity is O(n^5). Is this correct analysis? My code is below btw.\\n\\n\\n```\\nclass Solution(object):\\n    def calculate_util(self, left_op, right_op, operand):\\n        if operand == '+':\\n            return left_op + right_op\\n        if operand == '-':\\n            return left_op - right_op\\n        return left_op * right_op\\n    \\n    def evaluate_util(self, start, end, exp, cache):\\n        if (start,end) in cache:\\n            return cache[(start,end)]\\n        \\n        cache[(start,end)] = []\\n        op_found = False\\n        for i in xrange(start, end+1):\\n            if exp[i] in ['+','-','*']:\\n                op_found = True\\n                left_results = self.evaluate_util(start, i-1, exp, cache)\\n                right_results = self.evaluate_util(i+1, end, exp, cache)\\n                for left_result in left_results:\\n                    for right_result in right_results:\\n                        calculation = self.calculate_util(left_result, right_result, exp[i])\\n                        cache[(start,end)].append(calculation)\\n                      \\n        if not op_found:\\n            cache[(start,end)] = [int(exp[start:end+1])]\\n        return cache[(start,end)]\\n    \\n    def diffWaysToCompute(self, input):\\n        \"\"\"\\n        :type input: str\\n        :rtype: List[int]\\n        \"\"\"\\n        cache = {}\\n        return self.evaluate_util(0, len(input) - 1, input, cache)",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def calculate_util(self, left_op, right_op, operand):\\n        if operand == '+':\\n            return left_op + right_op\\n        if operand == '-':\\n            return left_op - right_op\\n        return left_op * right_op\\n    \\n    def evaluate_util(self, start, end, exp, cache):\\n        if (start,end) in cache:\\n            return cache[(start,end)]\\n        \\n        cache[(start,end)] = []\\n        op_found = False\\n        for i in xrange(start, end+1):\\n            if exp[i] in ['+','-','*']:\\n                op_found = True\\n                left_results = self.evaluate_util(start, i-1, exp, cache)\\n                right_results = self.evaluate_util(i+1, end, exp, cache)\\n                for left_result in left_results:\\n                    for right_result in right_results:\\n                        calculation = self.calculate_util(left_result, right_result, exp[i])\\n                        cache[(start,end)].append(calculation)\\n                      \\n        if not op_found:\\n            cache[(start,end)] = [int(exp[start:end+1])]\\n        return cache[(start,end)]\\n    \\n    def diffWaysToCompute(self, input):\\n        \"\"\"\\n        :type input: str\\n        :rtype: List[int]\\n        \"\"\"\\n        cache = {}",
                "codeTag": "Java"
            },
            {
                "id": 66418,
                "title": "share-my-22-line-commented-java-code",
                "content": "    public class Solution {\\n        public List<Integer> diffWaysToCompute(String input) {\\n            List<Integer> curResults = new ArrayList<>();  // current level results\\n            for (int i=0; i<input.length(); ++i) {\\n                char c = input.charAt(i);\\n                if (c=='+' || c=='-' || c=='*') {  // \\u4ee5\\u6bcf\\u4e00\\u4e2a\\u7b97\\u7b26\\u4e3a\\u5206\\u5272, \\u5206\\u5272\\u4e3a[\\u5de6\\u8fb9\\u6240\\u6709\\u53ef\\u80fd\\u7ed3\\u679c] + \\u8fd9\\u4e2a\\u7b97\\u7b26 + [\\u53f3\\u8fb9\\u6240\\u6709\\u53ef\\u80fd\\u7ed3\\u679c]\\n                    List<Integer> leftResults = diffWaysToCompute(input.substring(0, i));\\n                    List<Integer> rightResults = diffWaysToCompute(input.substring(i+1));\\n                    for (Integer left: leftResults) {\\n                        for (Integer right: rightResults) {\\n                            int result = 0;\\n                            if (c == '+') { result = left + right; }\\n                            else if (c == '-') { result = left - right; }\\n                            else { result = left * right; }\\n                            curResults.add(result);\\n                        }\\n                    }\\n                }\\n            }\\n            if (curResults.size() == 0) { \\n                curResults.add(Integer.parseInt(input));  // base case, a single number\\n                return curResults;\\n            }\\n            return curResults;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> diffWaysToCompute(String input) {\\n            List<Integer> curResults = new ArrayList<>();  // current level results\\n            for (int i=0; i<input.length(); ++i) {\\n                char c = input.charAt(i);\\n                if (c=='+' || c=='-' || c=='*') {  // \\u4ee5\\u6bcf\\u4e00\\u4e2a\\u7b97\\u7b26\\u4e3a\\u5206\\u5272, \\u5206\\u5272\\u4e3a[\\u5de6\\u8fb9\\u6240\\u6709\\u53ef\\u80fd\\u7ed3\\u679c] + \\u8fd9\\u4e2a\\u7b97\\u7b26 + [\\u53f3\\u8fb9\\u6240\\u6709\\u53ef\\u80fd\\u7ed3\\u679c]\\n                    List<Integer> leftResults = diffWaysToCompute(input.substring(0, i));\\n                    List<Integer> rightResults = diffWaysToCompute(input.substring(i+1));\\n                    for (Integer left: leftResults) {\\n                        for (Integer right: rightResults) {\\n                            int result = 0;\\n                            if (c == '+') { result = left + right; }",
                "codeTag": "Java"
            },
            {
                "id": 66421,
                "title": "a-much-faster-python-backtracking-solution-with-cache",
                "content": "I did a test for my code, it takes 84ms to finish without cache while it only takes 44ms with it.\\nHaven't seen anyone else uses cache to solve this problem yet, I think it's good to share my solution here:)\\n\\n    def diffWaysToCompute(input):\\n        def collect(s, cache):\\n            ops = {'+':lambda x, y:x+y, '-':lambda x, y:x-y, '*':lambda x, y:x*y}\\n            if not cache.has_key(s):\\n                ret = []\\n                for i, c in enumerate(s):\\n                    if c in '+-*':\\n                        for p in collect(s[:i], cache):\\n                            for n in collect(s[i+1:], cache):\\n                                ret.append(ops[c](p, n))\\n                            \\n                if not ret:\\n                    ret.append(int(s))\\n                \\n                cache[s] = ret\\n                \\n            return cache[s]\\n            \\n        return collect(input, {})",
                "solutionTags": [],
                "code": "I did a test for my code, it takes 84ms to finish without cache while it only takes 44ms with it.\\nHaven't seen anyone else uses cache to solve this problem yet, I think it's good to share my solution here:)\\n\\n    def diffWaysToCompute(input):\\n        def collect(s, cache):\\n            ops = {'+':lambda x, y:x+y, '-':lambda x, y:x-y, '*':lambda x, y:x*y}\\n            if not cache.has_key(s):\\n                ret = []\\n                for i, c in enumerate(s):\\n                    if c in '+-*':\\n                        for p in collect(s[:i], cache):\\n                            for n in collect(s[i+1:], cache):\\n                                ret.append(ops[c](p, n))\\n                            \\n                if not ret:\\n                    ret.append(int(s))\\n                \\n                cache[s] = ret\\n                \\n            return cache[s]\\n            \\n        return collect(input, {})",
                "codeTag": "Python3"
            },
            {
                "id": 66462,
                "title": "c-4ms-dp-solution",
                "content": "The recursive solution is not so efficient since it computes the possible results of the same substrings many times. To improve the time complexity, we can use dp which stores the intermediate results of the substrings. Define a two-dimensional array \\n\\ndp[i][j] = vector of all possible results computed from the substring starting from operand i and \\n             including the subsequent j operators and operands. \\n\\nLet cntOperators be the count of operators in the input string. Note that the count of operands is cntOperators + 1. The range of i is [0, cntOperators + 1) and the range of j is [0, cntOperators).\\n\\n    class Solution \\n    {\\n        // Separate the operands and the operators ('+', '-', '*')\\n        // in the input string.\\n        void GetOperandsAndOperatorsFromString(\\n            string &input,\\n            vector<int> &operands,\\n            vector<char> &operators)\\n        {\\n            int number = 0;\\n            for (int i = 0; i <= input.length(); i++)\\n            {\\n                if ((input[i] >= '0') && (input[i] <= '9'))\\n                {\\n                    // This character is a digit and add it to \\n                    // the number.\\n                    number = 10*number + (input[i] - '0');\\n                }\\n                else if ((input[i] == '+') || \\n                    (input[i] == '-') || \\n                    (input[i] == '*'))\\n                {\\n                    // This character is an operator and it implies \\n                    // the end of the previous number. Add the number \\n                    // to the operand vector and reset the number. Also \\n                    // add the operator to the operator vector.\\n                    operands.push_back(number);\\n                    number = 0;\\n                    \\n                    operators.push_back(input[i]);\\n                }\\n                else if (input[i] == '\\\\0')\\n                {\\n                    // This is the end of the input string. Add the \\n                    // last number to the operand vector.\\n                    operands.push_back(number);\\n                }\\n            }\\n        }\\n        \\n    public:\\n        vector<int> diffWaysToCompute(string input) \\n        {\\n            vector<int> operands;\\n            vector<char> operators;\\n            \\n            // Get the operands and operators from the input string.\\n            GetOperandsAndOperatorsFromString(input, operands, operators);\\n            \\n            // Note that count of operands = cnt of operators + 1.\\n            int cntOperators = operators.size();\\n            \\n            // dp[operandIndex][cntUsedOperators] = vector of all possible results \\n            // computed from the substring starting from operand \"operandIndex\" and \\n            // including the subsequent \"cntUsedOperators\" operators and operands.\\n            vector<vector<vector<int>>> dp(cntOperators + 1, vector<vector<int>>());\\n            \\n            // When cntUsedOperators = 0, dp[operandIndex][0] = operands[operandIndex].\\n            for (int operandIndex = 0; operandIndex < cntOperators + 1; operandIndex++)\\n            {\\n                dp[operandIndex].push_back(vector<int>{operands[operandIndex]});\\n            }\\n            \\n            // cntUsedOperators = 1,...,cntOperators.\\n            for (int cntUsedOperators = 1; cntUsedOperators <= cntOperators; cntUsedOperators++)\\n            {\\n                // Note that operandIndex starts from 0 and ends at the last operand which \\n                // is followed by \"cntUsedOperators\" operators and operands.\\n                for (int operandIndex = 0; \\n                    operandIndex < cntOperators + 1 - cntUsedOperators; \\n                    operandIndex++)\\n                {\\n                    // dp[operandIndex][cntUsedOperators] = the union of all outcomes for each \\n                    // possible last operator.\\n                    vector<int> tmpRes;\\n                    for (int lastOperatorIndex = operandIndex; lastOperatorIndex < operandIndex + cntUsedOperators; lastOperatorIndex++)\\n                    {\\n                        // The last operator breaks the substring into two halves. \\n                        // dp[operandIndex][lastOperatorIndex - operandIndex] = \\n                        //  all the outcomes of the first half.\\n                        // dp[lastOperatorIndex + 1][cntUsedOperators - 1 - (lastOperatorIndex - operandIndex)] = \\n                        //  all the outcomes of the second half.\\n                        for (auto &x : dp[operandIndex][lastOperatorIndex - operandIndex])\\n                        {\\n                            for (auto &y : dp[lastOperatorIndex + 1][cntUsedOperators - 1 - (lastOperatorIndex - operandIndex)])\\n                            {\\n                                if (operators[lastOperatorIndex] == '+')\\n                                {\\n                                    tmpRes.push_back(x + y);\\n                                }\\n                                else if (operators[lastOperatorIndex] == '-')\\n                                {\\n                                    tmpRes.push_back(x - y);\\n                                }\\n                                else\\n                                {\\n                                    tmpRes.push_back(x * y);\\n                                }\\n                            }\\n                        }\\n                    }\\n                    \\n                    dp[operandIndex].push_back(tmpRes);\\n                }\\n            }\\n            \\n            // The final result is all possible outcomes starting from operand 0 and including all operators.\\n            return dp[0][cntOperators];\\n        }\\n    };",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution \\n    {\\n        // Separate the operands and the operators ('+', '-', '*')\\n        // in the input string.\\n        void GetOperandsAndOperatorsFromString(\\n            string &input,\\n            vector<int> &operands,\\n            vector<char> &operators)\\n        {\\n            int number = 0;\\n            for (int i = 0; i <= input.length(); i++)\\n            {\\n                if ((input[i] >= '0') && (input[i] <= '9'))\\n                {\\n                    // This character is a digit and add it to \\n                    // the number.\\n                    number = 10*number + (input[i] - '0');\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 66459,
                "title": "what-is-the-time-complexity-of-divide-and-conquer-method",
                "content": "For divide and conquer solution of this problem:\\n\\n    def solve(input):\\n      if input is digit:\\n        return [input]\\n      ans = [ ]\\n      for x in input:\\n        if x is operator:\\n          left = solve(input[0 ~ x])\\n          right = solve(input[x + 1 ~ len])\\n          for l in left:\\n            for r in right:\\n              ans += [ calc(l, r, x) ]\\n      return ans\\n\\nWhat is the time complexity of it?",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "For divide and conquer solution of this problem:\\n\\n    def solve(input):\\n      if input is digit:\\n        return [input]\\n      ans = [ ]\\n      for x in input:\\n        if x is operator:\\n          left = solve(input[0 ~ x])\\n          right = solve(input[x + 1 ~ len])\\n          for l in left:\\n            for r in right:\\n              ans += [ calc(l, r, x) ]\\n      return ans\\n\\nWhat is the time complexity of it?",
                "codeTag": "Python3"
            },
            {
                "id": 4065987,
                "title": "recursive-python-solution-using-eval",
                "content": "# Code\\n```\\nclass Solution:\\n    def diffWaysToCompute(self, expression: str) -> List[int]:\\n        result = []\\n        operators = \"*-+\"\\n        isNumber = True\\n        for op in operators:\\n            if op in expression:\\n                isNumber = False\\n        if isNumber:\\n            return [int(expression)]\\n        for i,c in enumerate(expression):\\n            if c in operators:\\n                res1 = self.diffWaysToCompute(expression[:i])\\n                res2 = self.diffWaysToCompute(expression[i + 1:])\\n                for r1 in res1:\\n                    for r2 in res2:\\n                        result.append(eval(str(r1) + c + str(r2)))\\n        return result\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diffWaysToCompute(self, expression: str) -> List[int]:\\n        result = []\\n        operators = \"*-+\"\\n        isNumber = True\\n        for op in operators:\\n            if op in expression:\\n                isNumber = False\\n        if isNumber:\\n            return [int(expression)]\\n        for i,c in enumerate(expression):\\n            if c in operators:\\n                res1 = self.diffWaysToCompute(expression[:i])\\n                res2 = self.diffWaysToCompute(expression[i + 1:])\\n                for r1 in res1:\\n                    for r2 in res2:\\n                        result.append(eval(str(r1) + c + str(r2)))\\n        return result\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727401,
                "title": "easy-to-understand-c-solution-using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,vector<int>>dp;\\n    vector<int> solve(int i, int j, string &s){\\n        if(j-i+1 <= 2) return {stoi(s.substr(i,j-i+1))};\\n\\n        if(dp.find({i,j}) != dp.end()) return dp[{i,j}];\\n        vector<int> v;\\n        for(int k=i; k<=j; k++){\\n            if(!(s[k] >= \\'0\\' && s[k] <= \\'9\\')){\\n                vector<int> temp1 = solve(i,k-1,s);\\n                vector<int> temp2 = solve(k+1,j,s);\\n                if(s[k] == \\'+\\'){\\n                    for(int x = 0; x<temp1.size(); x++){\\n                        for(int y=0; y<temp2.size(); y++){\\n                            v.push_back(temp1[x] + temp2[y]);\\n                        }\\n                    }\\n                }\\n                else if(s[k] == \\'-\\'){\\n                    for(int x = 0; x<temp1.size(); x++){\\n                        for(int y=0; y<temp2.size(); y++){\\n                            v.push_back(temp1[x] - temp2[y]);\\n                        }\\n                    }\\n                }\\n                else if(s[k] == \\'*\\'){\\n                    for(int x = 0; x<temp1.size(); x++){\\n                        for(int y=0; y<temp2.size(); y++){\\n                            v.push_back(temp1[x] * temp2[y]);\\n                        }\\n                    }\\n                }\\n            }\\n\\n        } \\n        return dp[{i,j}] = v;\\n    }\\n    vector<int> diffWaysToCompute(string s) {\\n        return solve(0,s.length()-1,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,vector<int>>dp;\\n    vector<int> solve(int i, int j, string &s){\\n        if(j-i+1 <= 2) return {stoi(s.substr(i,j-i+1))};\\n\\n        if(dp.find({i,j}) != dp.end()) return dp[{i,j}];\\n        vector<int> v;\\n        for(int k=i; k<=j; k++){\\n            if(!(s[k] >= \\'0\\' && s[k] <= \\'9\\')){\\n                vector<int> temp1 = solve(i,k-1,s);\\n                vector<int> temp2 = solve(k+1,j,s);\\n                if(s[k] == \\'+\\'){\\n                    for(int x = 0; x<temp1.size(); x++){\\n                        for(int y=0; y<temp2.size(); y++){\\n                            v.push_back(temp1[x] + temp2[y]);\\n                        }\\n                    }\\n                }\\n                else if(s[k] == \\'-\\'){\\n                    for(int x = 0; x<temp1.size(); x++){\\n                        for(int y=0; y<temp2.size(); y++){\\n                            v.push_back(temp1[x] - temp2[y]);\\n                        }\\n                    }\\n                }\\n                else if(s[k] == \\'*\\'){\\n                    for(int x = 0; x<temp1.size(); x++){\\n                        for(int y=0; y<temp2.size(); y++){\\n                            v.push_back(temp1[x] * temp2[y]);\\n                        }\\n                    }\\n                }\\n            }\\n\\n        } \\n        return dp[{i,j}] = v;\\n    }\\n    vector<int> diffWaysToCompute(string s) {\\n        return solve(0,s.length()-1,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301029,
                "title": "241-different-ways-to-add-parentheses-java-recursion",
                "content": "```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String expression) {\\n       ArrayList<Integer> ans = new ArrayList<Integer>();\\n        for(int i=0;i<expression.length();i++)\\n        {\\n            if(expression.charAt(i)==\\'+\\'||expression.charAt(i)==\\'*\\'||expression.charAt(i)==\\'-\\')\\n            {\\n                List<Integer> ans1 =  diffWaysToCompute(expression.substring(0,i));\\n                List<Integer> ans2 =  diffWaysToCompute(expression.substring(i+1));\\n                for(int j=0;j<ans1.size();j++)\\n                {\\n                    for(int k=0;k<ans2.size();k++)\\n                    {\\n                        if(expression.charAt(i)==\\'+\\')\\n                            ans.add(ans1.get(j)+ans2.get(k));\\n                       else  if(expression.charAt(i)==\\'*\\')\\n                            ans.add(ans1.get(j)*ans2.get(k));\\n                        else\\n                            ans.add(ans1.get(j)-ans2.get(k));\\n                    }\\n                }\\n                \\n            }   \\n        }\\n        if(ans.size()==0)\\n            ans.add(Integer.parseInt(expression));\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String expression) {\\n       ArrayList<Integer> ans = new ArrayList<Integer>();\\n        for(int i=0;i<expression.length();i++)\\n        {\\n            if(expression.charAt(i)==\\'+\\'||expression.charAt(i)==\\'*\\'||expression.charAt(i)==\\'-\\')\\n            {\\n                List<Integer> ans1 =  diffWaysToCompute(expression.substring(0,i));\\n                List<Integer> ans2 =  diffWaysToCompute(expression.substring(i+1));\\n                for(int j=0;j<ans1.size();j++)\\n                {\\n                    for(int k=0;k<ans2.size();k++)\\n                    {\\n                        if(expression.charAt(i)==\\'+\\')\\n                            ans.add(ans1.get(j)+ans2.get(k));\\n                       else  if(expression.charAt(i)==\\'*\\')\\n                            ans.add(ans1.get(j)*ans2.get(k));\\n                        else\\n                            ans.add(ans1.get(j)-ans2.get(k));\\n                    }\\n                }\\n                \\n            }   \\n        }\\n        if(ans.size()==0)\\n            ans.add(Integer.parseInt(expression));\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107987,
                "title": "c-recursive-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    vector<int> solve(string s,int i,int j){\\n        if(i>j){\\n            return {};\\n        }\\n        if(j-i <=1){\\n           string num = s.substr(i, j + 1); \\n           return  {stoi(num)};\\n        }\\n        vector<int>ans;\\n        for(int k=i; k<j; k++){\\n            if(s[k] == \\'+\\' || s[k] == \\'-\\' || s[k] == \\'*\\'){\\n                vector<int> a=solve(s,i,k-1);\\n                vector<int> b=solve(s,k+1,j);\\n                for(int p=0; p< a.size(); p++){\\n                    for(int q=0; q< b.size(); q++){\\n                        if(s[k]==\\'+\\'){\\n                            ans.push_back(a[p]+b[q]);\\n                        }\\n                        else if(s[k]==\\'-\\'){\\n                            ans.push_back(a[p]-b[q]);\\n                        }\\n                        else{\\n                            ans.push_back(a[p]*b[q]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    vector<int> diffWaysToCompute(string expression) {\\n        return solve(expression,0,expression.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> solve(string s,int i,int j){\\n        if(i>j){\\n            return {};\\n        }\\n        if(j-i <=1){\\n           string num = s.substr(i, j + 1); \\n           return  {stoi(num)};\\n        }\\n        vector<int>ans;\\n        for(int k=i; k<j; k++){\\n            if(s[k] == \\'+\\' || s[k] == \\'-\\' || s[k] == \\'*\\'){\\n                vector<int> a=solve(s,i,k-1);\\n                vector<int> b=solve(s,k+1,j);\\n                for(int p=0; p< a.size(); p++){\\n                    for(int q=0; q< b.size(); q++){\\n                        if(s[k]==\\'+\\'){\\n                            ans.push_back(a[p]+b[q]);\\n                        }\\n                        else if(s[k]==\\'-\\'){\\n                            ans.push_back(a[p]-b[q]);\\n                        }\\n                        else{\\n                            ans.push_back(a[p]*b[q]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    vector<int> diffWaysToCompute(string expression) {\\n        return solve(expression,0,expression.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664634,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions-for-different-ways-to-add-parentheses",
                "content": "**Hint:-** solve  recursively and memovise  it\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<int>>mp;\\n    int comp(int a,int b,char op){\\n        if(op==\\'+\\')\\n            return a+b;\\n        else if(op==\\'-\\')\\n            return a-b;\\n        else if(op==\\'*\\')\\n            return  a*b;\\n        else\\n            return a/b;\\n    }\\n    bool isOperator(char ch){\\n        if(ch==\\'-\\'||ch==\\'+\\'||ch==\\'*\\'||ch==\\'/\\')\\n            return true;\\n        else\\n            return false;\\n    }\\n    vector<int> diffWaysToCompute(string expression) {\\n        vector<int>ans;\\n        if(mp.find(expression)!=mp.end())\\n            return mp[expression];\\n        for(int i=0;i<expression.size();i++){\\n            if(isOperator(expression[i])==true){\\n                vector<int>v1=diffWaysToCompute(expression.substr(0,i));\\n                vector<int>v2=diffWaysToCompute(expression.substr(i+1));\\n                for(int j=0;j<v1.size();j++){\\n                    for(int k=0;k<v2.size();k++){\\n                        ans.push_back(comp(v1[j],v2[k],expression[i]));\\n                    }\\n                }\\n            }\\n        }\\n        if(ans.size()==0)\\n            return {stoi(expression)};\\n     return mp[expression]=ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    unordered_map<string,vector<int>>mp;\\n    int comp(int a,int b,char op){\\n        if(op==\\'+\\')\\n            return a+b;\\n        else if(op==\\'-\\')\\n            return a-b;\\n        else if(op==\\'*\\')\\n            return  a*b;\\n        else\\n            return a/b;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2523137,
                "title": "c-recursion-memorization-solution-with-explanation-with-comment-0ms-7mb",
                "content": "- partition the expression by operators \\n- solve the left and right by recursive function which will return all possible value from left and right part\\n- merge them\\n-  `dp[i][j]` means number of possible values of expression[i...j]\\n```\\nvector<int> dp[22][22]; //for memorization\\nint visited[22][22]; ; //to check if current portion is calculated\\nint cas; //to avoid clearing the memory before each run and clear on demand\\nclass Solution {\\npublic:\\n//getting the number in `l-r` part \\n    int getNumber(int l,int r,string &s){\\n        int ans = 0;\\n        for(int i=l;i<=r;i++){\\n            ans = ans * 10 + (s[i]-\\'0\\');\\n        }\\n        return ans;\\n    }\\n\\t//finds the all possible value in `l-r` part and returns them in array\\n    vector<int> recur(int l,int r,string &s){\\n       int &visi = visited[l][r]; \\n        vector<int>&ans = dp[l][r];\\n        if(visi==cas)return ans; //if this portion already calculated return it\\n        ans.clear(); //calculate this portion, so clear previous values\\n        visi = cas; //marking this portion is visited\\n        for(int i=l;i<=r;i++){\\n            if(s[i]>=\\'0\\' && s[i]<=\\'9\\')continue; \\n\\t\\t\\t//s[i] is an operator\\n             vector<int> x = recur(l,i-1,s); //recursively calculate left and right portion\\n             vector<int> y = recur(i+1,r,s);\\n\\t\\t\\t//merging\\n            for(int p:x){\\n                for(int q:y){\\n                    if(s[i]==\\'+\\')ans.push_back(p+q);\\n                    if(s[i]==\\'-\\')ans.push_back(p-q);\\n                    if(s[i]==\\'*\\')ans.push_back(p*q);\\n                }\\n            }\\n        }\\n\\t\\t//no operator found, so current portion is just a number\\n        if(ans.empty()){\\n            ans.push_back(getNumber(l,r,s));\\n        }\\n        return ans; //return the ans\\n    }\\n    vector<int> diffWaysToCompute(string expression) {\\n        cas++;\\n        return recur(0,expression.size()-1,expression);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nvector<int> dp[22][22]; //for memorization\\nint visited[22][22]; ; //to check if current portion is calculated\\nint cas; //to avoid clearing the memory before each run and clear on demand\\nclass Solution {\\npublic:\\n//getting the number in `l-r` part \\n    int getNumber(int l,int r,string &s){\\n        int ans = 0;\\n        for(int i=l;i<=r;i++){\\n            ans = ans * 10 + (s[i]-\\'0\\');\\n        }\\n        return ans;\\n    }\\n\\t//finds the all possible value in `l-r` part and returns them in array\\n    vector<int> recur(int l,int r,string &s){\\n       int &visi = visited[l][r]; \\n        vector<int>&ans = dp[l][r];\\n        if(visi==cas)return ans; //if this portion already calculated return it\\n        ans.clear(); //calculate this portion, so clear previous values\\n        visi = cas; //marking this portion is visited\\n        for(int i=l;i<=r;i++){\\n            if(s[i]>=\\'0\\' && s[i]<=\\'9\\')continue; \\n\\t\\t\\t//s[i] is an operator\\n             vector<int> x = recur(l,i-1,s); //recursively calculate left and right portion\\n             vector<int> y = recur(i+1,r,s);\\n\\t\\t\\t//merging\\n            for(int p:x){\\n                for(int q:y){\\n                    if(s[i]==\\'+\\')ans.push_back(p+q);\\n                    if(s[i]==\\'-\\')ans.push_back(p-q);\\n                    if(s[i]==\\'*\\')ans.push_back(p*q);\\n                }\\n            }\\n        }\\n\\t\\t//no operator found, so current portion is just a number\\n        if(ans.empty()){\\n            ans.push_back(getNumber(l,r,s));\\n        }\\n        return ans; //return the ans\\n    }\\n    vector<int> diffWaysToCompute(string expression) {\\n        cas++;\\n        return recur(0,expression.size()-1,expression);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430824,
                "title": "c-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,vector<int>>mp;\\n    vector<int> diffWaysToCompute(string str) \\n    {\\n        int i=0;\\n        int j=str.length()-1;\\n        \\n        return fun(str,i,j);\\n    }\\n    vector<int> fun(string &str,int i,int j)\\n    {\\n        if(i>j)\\n        {\\n            return {0};\\n        }\\n        else if(i==j)\\n        {\\n            // return str[i]-\\'0\\';  //return the digit \\n            return {str[i]-\\'0\\'};\\n        }\\n        else if(j==i+1 and (str[i]>=\\'0\\' and str[i]<=\\'9\\') and (str[j]>=\\'0\\' and str[j]<=\\'9\\'))\\n        {\\n            int num=0;\\n            num=(num*10)+str[i]-\\'0\\';\\n            num=(num*10)+str[j]-\\'0\\';\\n    \\n            return {num};\\n        }\\n        if(mp.find({i,j})!=mp.end())\\n        {\\n            return mp[{i,j}];\\n        }\\n        vector<int>ans;\\n        for(int k=i;k<=j;k++)\\n        {\\n            vector<int>left_ans=fun(str,i,k-1);\\n            vector<int>right_ans=fun(str,k+1,j);\\n            \\n                for(int x=0;x<left_ans.size();x++)\\n                {\\n                    for(int z=0;z<right_ans.size();z++)\\n                    {\\n                        int val1=left_ans[x];\\n                        int val2=right_ans[z];\\n                        \\n                        if(str[k]==\\'+\\' and (left_ans.size()>0 and right_ans.size()>0))\\n                        {\\n                           ans.push_back(val1+val2);                   \\n                        }\\n                        else if(str[k]==\\'-\\' and left_ans.size()>0 and right_ans.size()>0)\\n                        {\\n                            ans.push_back(val1-val2);                   \\n                        }\\n                        else if(str[k]==\\'*\\' and left_ans.size()>0 and right_ans.size()>0)\\n                        {\\n                            ans.push_back(val1*val2);                   \\n                        }\\n\\n                    }\\n                }\\n            }\\n         return mp[{i,j}]=ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,vector<int>>mp;\\n    vector<int> diffWaysToCompute(string str) \\n    {\\n        int i=0;\\n        int j=str.length()-1;\\n        \\n        return fun(str,i,j);\\n    }\\n    vector<int> fun(string &str,int i,int j)\\n    {\\n        if(i>j)\\n        {\\n            return {0};\\n        }\\n        else if(i==j)\\n        {\\n            // return str[i]-\\'0\\';  //return the digit \\n            return {str[i]-\\'0\\'};\\n        }\\n        else if(j==i+1 and (str[i]>=\\'0\\' and str[i]<=\\'9\\') and (str[j]>=\\'0\\' and str[j]<=\\'9\\'))\\n        {\\n            int num=0;\\n            num=(num*10)+str[i]-\\'0\\';\\n            num=(num*10)+str[j]-\\'0\\';\\n    \\n            return {num};\\n        }\\n        if(mp.find({i,j})!=mp.end())\\n        {\\n            return mp[{i,j}];\\n        }\\n        vector<int>ans;\\n        for(int k=i;k<=j;k++)\\n        {\\n            vector<int>left_ans=fun(str,i,k-1);\\n            vector<int>right_ans=fun(str,k+1,j);\\n            \\n                for(int x=0;x<left_ans.size();x++)\\n                {\\n                    for(int z=0;z<right_ans.size();z++)\\n                    {\\n                        int val1=left_ans[x];\\n                        int val2=right_ans[z];\\n                        \\n                        if(str[k]==\\'+\\' and (left_ans.size()>0 and right_ans.size()>0))\\n                        {\\n                           ans.push_back(val1+val2);                   \\n                        }\\n                        else if(str[k]==\\'-\\' and left_ans.size()>0 and right_ans.size()>0)\\n                        {\\n                            ans.push_back(val1-val2);                   \\n                        }\\n                        else if(str[k]==\\'*\\' and left_ans.size()>0 and right_ans.size()>0)\\n                        {\\n                            ans.push_back(val1*val2);                   \\n                        }\\n\\n                    }\\n                }\\n            }\\n         return mp[{i,j}]=ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331975,
                "title": "c-clean-and-clear-codes-dfs",
                "content": "Thanks for the kind reminder from @ngjuping, this is just dfs.\\n```\\nclass Solution {\\npublic:\\n    vector<int> dfs(int l, int r, string s) {\\n        vector<int> res;\\n        for (int i = l; i <= r; i++) {\\n            if (isdigit(s[i]))\\n                continue;\\n            vector<int> left = dfs(l, i - 1, s);\\n            vector<int> right = dfs(i + 1, r, s);\\n            for (auto& ln : left) {\\n                for (auto& rn: right) {\\n                    switch (s[i]) {\\n                        case \\'+\\':\\n                            res.emplace_back(ln + rn);\\n                            break;\\n                        case \\'-\\':\\n                            res.emplace_back(ln - rn);\\n                            break;\\n                        case \\'*\\':\\n                            res.emplace_back(ln * rn);\\n                            break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (res.size() == 0) {\\n            int cus = 0;\\n            for (int i = l; i <= r; i++)\\n                cus = cus * 10 + s[i] - \\'0\\';\\n            res.emplace_back(cus);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    vector<int> diffWaysToCompute(string expression) {\\n        return dfs(0, expression.size() - 1, expression);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dfs(int l, int r, string s) {\\n        vector<int> res;\\n        for (int i = l; i <= r; i++) {\\n            if (isdigit(s[i]))\\n                continue;\\n            vector<int> left = dfs(l, i - 1, s);\\n            vector<int> right = dfs(i + 1, r, s);\\n            for (auto& ln : left) {\\n                for (auto& rn: right) {\\n                    switch (s[i]) {\\n                        case \\'+\\':\\n                            res.emplace_back(ln + rn);\\n                            break;\\n                        case \\'-\\':\\n                            res.emplace_back(ln - rn);\\n                            break;\\n                        case \\'*\\':\\n                            res.emplace_back(ln * rn);\\n                            break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (res.size() == 0) {\\n            int cus = 0;\\n            for (int i = l; i <= r; i++)\\n                cus = cus * 10 + s[i] - \\'0\\';\\n            res.emplace_back(cus);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    vector<int> diffWaysToCompute(string expression) {\\n        return dfs(0, expression.size() - 1, expression);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2307156,
                "title": "funny-recursion-hihi",
                "content": "```\\nfunc diffWaysToCompute(expression string) []int {\\n    var isOperator func(byte) bool \\n    isOperator = func(str byte) bool {\\n        return str == \\'+\\' || str == \\'-\\' || str == \\'*\\'\\n    }\\n    \\n    var containAnyOperator func(string) bool\\n    containAnyOperator = func(ex string) bool {\\n        for i := 0; i < len(ex); i++ {\\n            if isOperator(ex[i]) {\\n                return true\\n            }\\n        }\\n        \\n        return false\\n    }\\n    \\n    var toInt func(string) int\\n    toInt = func(str string) int {\\n        val, err := strconv.Atoi(str)\\n        \\n        if err != nil {\\n            panic(err)\\n        }\\n        \\n        return val\\n    }\\n    \\n    var dfs func(string) []int\\n    dfs = func(expression string) []int {\\n        if len(expression) == 0 {\\n            return []int{}\\n        }\\n        \\n        if !containAnyOperator(expression) {\\n            return []int{ toInt(expression) }\\n        }\\n        \\n        var result []int\\n        \\n        for i := 0; i < len(expression); i++ {\\n            if isOperator(expression[i]) {\\n                leftPart := dfs(expression[:i])\\n                rightPart := dfs(expression[i+1:])\\n\\n                for _, leftVal := range leftPart {\\n                    for _, rightVal := range rightPart {\\n                        if expression[i] == \\'+\\' {\\n                            result = append(result, leftVal + rightVal)\\n                        } else if expression[i] == \\'-\\' {\\n                            result = append(result, leftVal - rightVal)\\n                        } else {\\n                            result = append(result, leftVal * rightVal)\\n                        }\\n                    }\\n                }\\n            }\\n        }  \\n        \\n        return result\\n    }\\n    \\n    return dfs(expression)\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Divide and Conquer"
                ],
                "code": "```\\nfunc diffWaysToCompute(expression string) []int {\\n    var isOperator func(byte) bool \\n    isOperator = func(str byte) bool {\\n        return str == \\'+\\' || str == \\'-\\' || str == \\'*\\'\\n    }\\n    \\n    var containAnyOperator func(string) bool\\n    containAnyOperator = func(ex string) bool {\\n        for i := 0; i < len(ex); i++ {\\n            if isOperator(ex[i]) {\\n                return true\\n            }\\n        }\\n        \\n        return false\\n    }\\n    \\n    var toInt func(string) int\\n    toInt = func(str string) int {\\n        val, err := strconv.Atoi(str)\\n        \\n        if err != nil {\\n            panic(err)\\n        }\\n        \\n        return val\\n    }\\n    \\n    var dfs func(string) []int\\n    dfs = func(expression string) []int {\\n        if len(expression) == 0 {\\n            return []int{}\\n        }\\n        \\n        if !containAnyOperator(expression) {\\n            return []int{ toInt(expression) }\\n        }\\n        \\n        var result []int\\n        \\n        for i := 0; i < len(expression); i++ {\\n            if isOperator(expression[i]) {\\n                leftPart := dfs(expression[:i])\\n                rightPart := dfs(expression[i+1:])\\n\\n                for _, leftVal := range leftPart {\\n                    for _, rightVal := range rightPart {\\n                        if expression[i] == \\'+\\' {\\n                            result = append(result, leftVal + rightVal)\\n                        } else if expression[i] == \\'-\\' {\\n                            result = append(result, leftVal - rightVal)\\n                        } else {\\n                            result = append(result, leftVal * rightVal)\\n                        }\\n                    }\\n                }\\n            }\\n        }  \\n        \\n        return result\\n    }\\n    \\n    return dfs(expression)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2176974,
                "title": "shortest-cleanest-solution-you-ll-see",
                "content": "# Recursion with memoization\\n- Let me demonstrate the key idea to solve this problem with an example. Let `expression = \"2+2*2\"`\\n- It\\'s easy to see that the answer should be `2 + (2*2) = 6` and `(2+2) * 2 = 8`\\n- In the above step what we are doing is, everytime we encounter an operator in `-+*`, we will split the expression into two parts - Left and Right.\\n- Solve the left and right part recursively. \\n- Base case : if length of the expression is 1 or 2, that means the expression is a digit, return that digit.\\n- Finally, memoize the recursive function to make it faster.\\n\\n```\\nclass Solution:    \\n    @functools.lru_cache(None)\\n    def diffWaysToCompute(self, s: str) -> List[int]:\\n        if len(s) <= 2: return [int(s)]\\n        vals = []\\n        for i,x in enumerate(s):\\n            if x in \\'+-*\\':\\n                vals += [eval(f\"{left}{x}{right}\") for left in self.diffWaysToCompute(s[:i]) \\n                         for right in self.diffWaysToCompute(s[i+1:])]\\n        return vals\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:    \\n    @functools.lru_cache(None)\\n    def diffWaysToCompute(self, s: str) -> List[int]:\\n        if len(s) <= 2: return [int(s)]\\n        vals = []\\n        for i,x in enumerate(s):\\n            if x in \\'+-*\\':\\n                vals += [eval(f\"{left}{x}{right}\") for left in self.diffWaysToCompute(s[:i]) \\n                         for right in self.diffWaysToCompute(s[i+1:])]\\n        return vals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165351,
                "title": "c-recursion-memoize-aditya-verma-mcm-variation",
                "content": "recursion:\\nalthough u will not get TLE for it\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int>  solve(string s, int i , int j){\\n        if(i>j)\\n        {\\n            return { };\\n        }\\n        \\n        if(j-i<=1)\\n        {\\n             string num = s.substr(i, j + 1);\\n            \\n           return  {stoi(num)};\\n        }\\n        \\n        vector<int>  ans;\\n       \\n        for(int k=i;k<=j-1;k++){\\n              if(s[k] == \\'+\\' || s[k] == \\'-\\' || s[k] == \\'*\\')\\n              {\\n                vector<int>  left=solve(s,i,k-1);\\n                vector<int>  right=solve(s,k+1,j);\\n\\n                  char ch = s[k];\\n                for (auto l : left) {\\n                    for (auto r : right) {\\n                        switch (ch) {\\n                            case \\'+\\':\\n                                ans.push_back(l + r);\\n                                break;\\n                            case \\'-\\':\\n                                ans.push_back(l - r);\\n                                break;\\n                            case \\'*\\':\\n                                ans.push_back(l * r);\\n                                break;\\n                            case \\'/\\':\\n                                ans.push_back(l / r);\\n                                break;\\n                        }\\n                    }\\n                }\\n              }\\n            \\n        }\\n       \\n       return ans;\\n        \\n    }\\n    vector<int> diffWaysToCompute(string expression) {\\n          return solve(expression, 0 , expression.size()-1);\\n    }\\n};\\n\\n\\nmemoize :\\n```\\nclass Solution {\\npublic:\\n     unordered_map<string, vector<int>> dp;\\n    vector<int>  solve(string s, int i , int j){\\n        if(i>j)\\n        {\\n            return { };\\n        }\\n        string key = to_string(i) + \",\" + to_string(j);\\n        \\n        if(dp.count(key))\\n        {\\n            return dp[key];\\n        }\\n        if(j-i<=1)\\n        {\\n             string num = s.substr(i, j + 1);\\n            \\n            return dp[key] = {stoi(num)};\\n        }\\n        \\n        vector<int>  ans;\\n       \\n        for(int k=i;k<=j-1;k++){\\n              if(s[k] == \\'+\\' || s[k] == \\'-\\' || s[k] == \\'*\\')\\n              {\\n                vector<int>  left=solve(s,i,k-1);\\n                vector<int>  right=solve(s,k+1,j);\\n\\n                  char ch = s[k];\\n                for (auto l : left) {\\n                    for (auto r : right) {\\n                        switch (ch) {\\n                            case \\'+\\':\\n                                ans.push_back(l + r);\\n                                break;\\n                            case \\'-\\':\\n                                ans.push_back(l - r);\\n                                break;\\n                            case \\'*\\':\\n                                ans.push_back(l * r);\\n                                break;\\n                            case \\'/\\':\\n                                ans.push_back(l / r);\\n                                break;\\n                        }\\n                    }\\n                }\\n              }\\n            \\n        }\\n       \\n      return dp[key] = ans;\\n        \\n    }\\n    vector<int> diffWaysToCompute(string expression) {\\n          return solve(expression, 0 , expression.size()-1);\\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int>  solve(string s, int i , int j){\\n        if(i>j)\\n        {\\n            return { };\\n        }\\n        \\n        if(j-i<=1)\\n        {\\n             string num = s.substr(i, j + 1);\\n            \\n           return  {stoi(num)};\\n        }\\n        \\n        vector<int>  ans;\\n       \\n        for(int k=i;k<=j-1;k++){\\n              if(s[k] == \\'+\\' || s[k] == \\'-\\' || s[k] == \\'*\\')\\n              {\\n                vector<int>  left=solve(s,i,k-1);\\n                vector<int>  right=solve(s,k+1,j);\\n\\n                  char ch = s[k];\\n                for (auto l : left) {\\n                    for (auto r : right) {\\n                        switch (ch) {\\n                            case \\'+\\':\\n                                ans.push_back(l + r);\\n                                break;\\n                            case \\'-\\':\\n                                ans.push_back(l - r);\\n                                break;\\n                            case \\'*\\':\\n                                ans.push_back(l * r);\\n                                break;\\n                            case \\'/\\':\\n                                ans.push_back(l / r);\\n                                break;\\n                        }\\n                    }\\n                }\\n              }\\n            \\n        }\\n       \\n       return ans;\\n        \\n    }\\n    vector<int> diffWaysToCompute(string expression) {\\n          return solve(expression, 0 , expression.size()-1);\\n    }\\n};\\n\\n\\nmemoize :\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092129,
                "title": "java-recursive-divide-and-conquer-fast",
                "content": "## **Please Upvote if you understood this** (\\uFF5E\\uFFE3\\u25BD\\uFFE3)\\uFF5E\\n\\n```\\nclass Solution {\\n    Map<String,List<Integer>> mpp = new HashMap<>();\\n    \\n    public List<Integer> diffWaysToCompute(String expression) {\\n        int len = expression.length();\\n        List<Integer> result = new ArrayList<>();\\n\\n        if(mpp.containsKey(expression)) return mpp.get(expression);\\n        \\n        if(expression.length()==1){\\n            result.add(Integer.parseInt(expression));\\n            return result;\\n        }\\n\\n        for(int i=0;i<len;i++){\\n            char symbol = expression.charAt(i);\\n            if(isOperator(symbol)) {\\n                List<Integer> left = diffWaysToCompute(expression.substring(0, i));\\n                List<Integer> right = diffWaysToCompute(expression.substring(i + 1));\\n\\n                for(int l: left){\\n                    for(int r: right){\\n                        result.add(calc(l,symbol,r));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(result.isEmpty()){\\n            result.add(Integer.parseInt(expression));\\n            mpp.put(expression,result);\\n            return result;\\n        }\\n\\n        mpp.put(expression,result);\\n        return result;\\n    }\\n\\n    public boolean isOperator(char op){\\n        return switch (op) {\\n            case \\'-\\', \\'+\\', \\'*\\' -> true;\\n            default -> false;\\n        };\\n    }\\n\\n    public int calc(int l, char c, int r){\\n        return switch (c){\\n            case \\'+\\' -> l+r;\\n            case \\'-\\' -> l-r;\\n            case \\'*\\' -> l*r;\\n            default -> -1;\\n        };\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Map<String,List<Integer>> mpp = new HashMap<>();\\n    \\n    public List<Integer> diffWaysToCompute(String expression) {\\n        int len = expression.length();\\n        List<Integer> result = new ArrayList<>();\\n\\n        if(mpp.containsKey(expression)) return mpp.get(expression);\\n        \\n        if(expression.length()==1){\\n            result.add(Integer.parseInt(expression));\\n            return result;\\n        }\\n\\n        for(int i=0;i<len;i++){\\n            char symbol = expression.charAt(i);\\n            if(isOperator(symbol)) {\\n                List<Integer> left = diffWaysToCompute(expression.substring(0, i));\\n                List<Integer> right = diffWaysToCompute(expression.substring(i + 1));\\n\\n                for(int l: left){\\n                    for(int r: right){\\n                        result.add(calc(l,symbol,r));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(result.isEmpty()){\\n            result.add(Integer.parseInt(expression));\\n            mpp.put(expression,result);\\n            return result;\\n        }\\n\\n        mpp.put(expression,result);\\n        return result;\\n    }\\n\\n    public boolean isOperator(char op){\\n        return switch (op) {\\n            case \\'-\\', \\'+\\', \\'*\\' -> true;\\n            default -> false;\\n        };\\n    }\\n\\n    public int calc(int l, char c, int r){\\n        return switch (c){\\n            case \\'+\\' -> l+r;\\n            case \\'-\\' -> l-r;\\n            case \\'*\\' -> l*r;\\n            default -> -1;\\n        };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050662,
                "title": "c-simple-recursion-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> solve(string s){\\n        if(s.length()==0){\\n            return {};\\n        }\\n        if(s.length()==1){\\n            return {(s[0]-\\'0\\')};\\n        }\\n        if(s.length()==3){\\n            int f = s[0]-\\'0\\';\\n            int t = s[2]-\\'0\\';\\n            char c = s[1];\\n            if(c==\\'+\\'){\\n                return {f+t};\\n            }else if(c==\\'-\\'){\\n                return {f-t};\\n            }else{\\n                return {f*t};\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                continue;\\n            }else{\\n                string s1 = s.substr(0,i);\\n                string s2 = s.substr(i+1,s.length()-i-1);\\n                vector<int> left = solve(s1);\\n                vector<int> right = solve(s2);\\n                for(auto x: left){\\n                    for(auto y:right){\\n                        if(s[i]==\\'+\\'){\\n                            ans.push_back(x+y);\\n                        }else if(s[i]==\\'-\\'){\\n                            ans.push_back(x-y);\\n                        }else{\\n                            ans.push_back(x*y);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(ans.size()==0){\\n            return {stoi(s)};\\n        }\\n        return ans;\\n    }\\n    vector<int> diffWaysToCompute(string s) {\\n        vector<int> ans = solve(s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> solve(string s){\\n        if(s.length()==0){\\n            return {};\\n        }\\n        if(s.length()==1){\\n            return {(s[0]-\\'0\\')};\\n        }\\n        if(s.length()==3){\\n            int f = s[0]-\\'0\\';\\n            int t = s[2]-\\'0\\';\\n            char c = s[1];\\n            if(c==\\'+\\'){\\n                return {f+t};\\n            }else if(c==\\'-\\'){\\n                return {f-t};\\n            }else{\\n                return {f*t};\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                continue;\\n            }else{\\n                string s1 = s.substr(0,i);\\n                string s2 = s.substr(i+1,s.length()-i-1);\\n                vector<int> left = solve(s1);\\n                vector<int> right = solve(s2);\\n                for(auto x: left){\\n                    for(auto y:right){\\n                        if(s[i]==\\'+\\'){\\n                            ans.push_back(x+y);\\n                        }else if(s[i]==\\'-\\'){\\n                            ans.push_back(x-y);\\n                        }else{\\n                            ans.push_back(x*y);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(ans.size()==0){\\n            return {stoi(s)};\\n        }\\n        return ans;\\n    }\\n    vector<int> diffWaysToCompute(string s) {\\n        vector<int> ans = solve(s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963044,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Recursion && Memoization***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string, vector<int>> dp;\\n    \\n    vector<int> helper(string expression, int start, int end)\\n    {\\n        if(start > end)\\n            return {};\\n        \\n        string key = to_string(start) + \",\" + to_string(end);\\n        \\n        if(dp.count(key))\\n        {\\n            return dp[key];\\n        }\\n        \\n        if(end - start <= 1)\\n        {\\n            string num = expression.substr(start, end + 1);\\n            \\n            return dp[key] = {stoi(num)};\\n        }\\n        \\n        vector<int> left;\\n        \\n        vector<int> right;\\n        \\n        vector<int> curr;\\n        \\n        for(int k = start; k <= end; k++)\\n        {\\n            if(expression[k] == \\'+\\' || expression[k] == \\'-\\' || expression[k] == \\'*\\')\\n            {\\n                left = helper(expression, start, k - 1);\\n                \\n                right = helper(expression, k + 1, end);\\n                \\n                for(auto l : left)\\n                {\\n                    for(auto r : right)\\n                    {\\n                        if(expression[k] == \\'+\\')\\n                        {\\n                            curr.push_back(l + r);\\n                        }\\n                        \\n                        else if(expression[k] == \\'-\\')\\n                        {\\n                            curr.push_back(l - r);\\n                        }\\n                        \\n                        else if(expression[k] == \\'*\\')\\n                        {\\n                            curr.push_back(l * r);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[key] = curr;\\n    }\\n    \\n    vector<int> diffWaysToCompute(string expression) {\\n        \\n        int n = expression .size();\\n        \\n        return helper(expression, 0, n - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string, vector<int>> dp;\\n    \\n    vector<int> helper(string expression, int start, int end)\\n    {\\n        if(start > end)\\n            return {};\\n        \\n        string key = to_string(start) + \",\" + to_string(end);\\n        \\n        if(dp.count(key))\\n        {\\n            return dp[key];\\n        }\\n        \\n        if(end - start <= 1)\\n        {\\n            string num = expression.substr(start, end + 1);\\n            \\n            return dp[key] = {stoi(num)};\\n        }\\n        \\n        vector<int> left;\\n        \\n        vector<int> right;\\n        \\n        vector<int> curr;\\n        \\n        for(int k = start; k <= end; k++)\\n        {\\n            if(expression[k] == \\'+\\' || expression[k] == \\'-\\' || expression[k] == \\'*\\')\\n            {\\n                left = helper(expression, start, k - 1);\\n                \\n                right = helper(expression, k + 1, end);\\n                \\n                for(auto l : left)\\n                {\\n                    for(auto r : right)\\n                    {\\n                        if(expression[k] == \\'+\\')\\n                        {\\n                            curr.push_back(l + r);\\n                        }\\n                        \\n                        else if(expression[k] == \\'-\\')\\n                        {\\n                            curr.push_back(l - r);\\n                        }\\n                        \\n                        else if(expression[k] == \\'*\\')\\n                        {\\n                            curr.push_back(l * r);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[key] = curr;\\n    }\\n    \\n    vector<int> diffWaysToCompute(string expression) {\\n        \\n        int n = expression .size();\\n        \\n        return helper(expression, 0, n - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945507,
                "title": "c-0-ms-google-interview-function-pointer-dp-rescursion-with-comments",
                "content": "```\\n/// siquan 04/13/2022\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> n; // number\\n    vector<char> c; //  + - *\\n    \\n    vector<int> diffWaysToCompute(string e) {\\n        int csize = e.size();\\n        int num = 0;\\n        \\n        for(int i = 0; i < csize; ++i) {\\n            if(e[i] >= \\'0\\' && e[i] <= \\'9\\') {\\n                num *= 10;\\n                num += e[i] - \\'0\\';\\n            } else {\\n                n.push_back(num);\\n                num = 0;\\n                c.push_back(e[i]);\\n            }\\n        }\\n        n.push_back(num);\\n        \\n        int size = n.size();\\n        \\n        // dp[a][b] means what is the result vector for #a to #b \\n        vector<vector<vector<int>>> dp(size, vector<vector<int>>(size, vector<int>()));\\n        \\n        for(int i = 0; i < size; ++i) {\\n            dp[i][i].push_back(n[i]); // add the number itself\\n        }\\n        \\n        helper(dp, 0, size - 1);\\n\\n        return dp[0][size - 1];\\n    }\\n    \\n    void helper(vector<vector<vector<int>>>& dp, int a, int b) {\\n        if(dp[a][b].size() != 0) {\\n            return;\\n        }\\n     \\n        for(int i = a; i < b; ++i) {\\n            helper(dp, a, i);\\n            helper(dp, i + 1, b);\\n        }\\n        \\n        for(int i = a; i < b; ++i) {\\n            for(int& t1 : dp[a][i]) {\\n                for(int& t2 : dp[i + 1][b]) {\\n                    // combine each result in two vectors\\n                    if(c[i] == \\'+\\') {\\n                        dp[a][b].push_back(t1 + t2);\\n                    } else if(c[i] == \\'-\\') {\\n                        dp[a][b].push_back(t1 - t2);\\n                    } else if(c[i] == \\'*\\') {\\n                        dp[a][b].push_back(t1 * t2);\\n                    }\\n                }\\n            }\\n        }   \\n    }\\n    \\n};\\n```\\n\\n\\nupdate  a new solution with function pointer, it should be faster.\\n\\n```\\n/// siquan 04/14/2022\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> n; // number\\n    vector<char> c; //  + - *\\n    \\n    static int addfp(int& a, int& b) {\\n        return a + b;\\n    }\\n    \\n    static int minusfp(int& a, int& b) {\\n        return a - b;\\n    }\\n    \\n    static int multifp(int& a, int& b) {\\n        return a * b;\\n    }\\n    \\n    vector<int> diffWaysToCompute(string e) {\\n        int csize = e.size();\\n        int num = 0;\\n        \\n        for(int i = 0; i < csize; ++i) {\\n            if(e[i] >= \\'0\\' && e[i] <= \\'9\\') {\\n                num *= 10;\\n                num += e[i] - \\'0\\';\\n            } else {\\n                n.push_back(num);\\n                num = 0;\\n                c.push_back(e[i]);\\n            }\\n        }\\n        n.push_back(num);\\n        \\n        int size = n.size();\\n        \\n        // dp[a][b] means what is the result vector for #a to #b \\n        vector<vector<vector<int>>> dp(size, vector<vector<int>>(size, vector<int>()));\\n        \\n        for(int i = 0; i < size; ++i) {\\n            dp[i][i].push_back(n[i]); // add the number itself\\n        }\\n        \\n        helper(dp, 0, size - 1);\\n\\n        return dp[0][size - 1];\\n    }\\n    \\n    void helper(vector<vector<vector<int>>>& dp, int a, int b) {\\n        if(dp[a][b].size() != 0) {\\n            return;\\n        }\\n     \\n        for(int i = a; i < b; ++i) {\\n            helper(dp, a, i);\\n            helper(dp, i + 1, b);\\n        }\\n        \\n        int (* p)(int&, int&);\\n        \\n        for(int i = a; i < b; ++i) {\\n            if(c[i] == \\'+\\') {\\n                p = &addfp;\\n            } else if(c[i] == \\'-\\') {\\n                p = &minusfp;\\n            } else if(c[i] == \\'*\\') {\\n                p = &multifp;\\n            }\\n            for(int& t1 : dp[a][i]) {\\n                for(int& t2 : dp[i + 1][b]) {\\n                    dp[a][b].push_back(p(t1, t2));\\n                    \\n                    // combine each result in two vectors\\n                    // if(c[i] == \\'+\\') {\\n                    //     dp[a][b].push_back(t1 + t2);\\n                    // } else if(c[i] == \\'-\\') {\\n                    //     dp[a][b].push_back(t1 - t2);\\n                    // } else if(c[i] == \\'*\\') {\\n                    //     dp[a][b].push_back(t1 * t2);\\n                    // }\\n                }\\n            }\\n        }   \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n/// siquan 04/13/2022\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> n; // number\\n    vector<char> c; //  + - *\\n    \\n    vector<int> diffWaysToCompute(string e) {\\n        int csize = e.size();\\n        int num = 0;\\n        \\n        for(int i = 0; i < csize; ++i) {\\n            if(e[i] >= \\'0\\' && e[i] <= \\'9\\') {\\n                num *= 10;\\n                num += e[i] - \\'0\\';\\n            } else {\\n                n.push_back(num);\\n                num = 0;\\n                c.push_back(e[i]);\\n            }\\n        }\\n        n.push_back(num);\\n        \\n        int size = n.size();\\n        \\n        // dp[a][b] means what is the result vector for #a to #b \\n        vector<vector<vector<int>>> dp(size, vector<vector<int>>(size, vector<int>()));\\n        \\n        for(int i = 0; i < size; ++i) {\\n            dp[i][i].push_back(n[i]); // add the number itself\\n        }\\n        \\n        helper(dp, 0, size - 1);\\n\\n        return dp[0][size - 1];\\n    }\\n    \\n    void helper(vector<vector<vector<int>>>& dp, int a, int b) {\\n        if(dp[a][b].size() != 0) {\\n            return;\\n        }\\n     \\n        for(int i = a; i < b; ++i) {\\n            helper(dp, a, i);\\n            helper(dp, i + 1, b);\\n        }\\n        \\n        for(int i = a; i < b; ++i) {\\n            for(int& t1 : dp[a][i]) {\\n                for(int& t2 : dp[i + 1][b]) {\\n                    // combine each result in two vectors\\n                    if(c[i] == \\'+\\') {\\n                        dp[a][b].push_back(t1 + t2);\\n                    } else if(c[i] == \\'-\\') {\\n                        dp[a][b].push_back(t1 - t2);\\n                    } else if(c[i] == \\'*\\') {\\n                        dp[a][b].push_back(t1 * t2);\\n                    }\\n                }\\n            }\\n        }   \\n    }\\n    \\n};\\n```\n```\\n/// siquan 04/14/2022\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> n; // number\\n    vector<char> c; //  + - *\\n    \\n    static int addfp(int& a, int& b) {\\n        return a + b;\\n    }\\n    \\n    static int minusfp(int& a, int& b) {\\n        return a - b;\\n    }\\n    \\n    static int multifp(int& a, int& b) {\\n        return a * b;\\n    }\\n    \\n    vector<int> diffWaysToCompute(string e) {\\n        int csize = e.size();\\n        int num = 0;\\n        \\n        for(int i = 0; i < csize; ++i) {\\n            if(e[i] >= \\'0\\' && e[i] <= \\'9\\') {\\n                num *= 10;\\n                num += e[i] - \\'0\\';\\n            } else {\\n                n.push_back(num);\\n                num = 0;\\n                c.push_back(e[i]);\\n            }\\n        }\\n        n.push_back(num);\\n        \\n        int size = n.size();\\n        \\n        // dp[a][b] means what is the result vector for #a to #b \\n        vector<vector<vector<int>>> dp(size, vector<vector<int>>(size, vector<int>()));\\n        \\n        for(int i = 0; i < size; ++i) {\\n            dp[i][i].push_back(n[i]); // add the number itself\\n        }\\n        \\n        helper(dp, 0, size - 1);\\n\\n        return dp[0][size - 1];\\n    }\\n    \\n    void helper(vector<vector<vector<int>>>& dp, int a, int b) {\\n        if(dp[a][b].size() != 0) {\\n            return;\\n        }\\n     \\n        for(int i = a; i < b; ++i) {\\n            helper(dp, a, i);\\n            helper(dp, i + 1, b);\\n        }\\n        \\n        int (* p)(int&, int&);\\n        \\n        for(int i = a; i < b; ++i) {\\n            if(c[i] == \\'+\\') {\\n                p = &addfp;\\n            } else if(c[i] == \\'-\\') {\\n                p = &minusfp;\\n            } else if(c[i] == \\'*\\') {\\n                p = &multifp;\\n            }\\n            for(int& t1 : dp[a][i]) {\\n                for(int& t2 : dp[i + 1][b]) {\\n                    dp[a][b].push_back(p(t1, t2));\\n                    \\n                    // combine each result in two vectors\\n                    // if(c[i] == \\'+\\') {\\n                    //     dp[a][b].push_back(t1 + t2);\\n                    // } else if(c[i] == \\'-\\') {\\n                    //     dp[a][b].push_back(t1 - t2);\\n                    // } else if(c[i] == \\'*\\') {\\n                    //     dp[a][b].push_back(t1 * t2);\\n                    // }\\n                }\\n            }\\n        }   \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815312,
                "title": "explained-c-generate-unique-bsts-parenthesis-concept-easy-recursive-one-pass",
                "content": "First generate all possibilities of parenthesis around given expression using concept of generating all parenthesis,\\n\\ncheck out that here :\\nhttps://leetcode.com/problems/generate-parentheses/discuss/1804825/c-using-generating-unique-bsts-concept\\n\\nThen evaluate inorder expression using Stacks:\\n\\n**Solution** :\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string exp) {\\n        vector<string> exp_v ;\\n        int j = 0;\\n        while(j<exp.length()){\\n            if(exp[j]>=\\'0\\' && exp[j]<=\\'9\\') {\\n                int a = 0,x=1;\\n                while(exp[j]>=\\'0\\' && exp[j]<=\\'9\\'){\\n                    a=a*x+(exp[j]-\\'0\\');x=x*10;\\n                    j++;\\n                }\\n                exp_v.push_back(to_string(a));\\n            }else{\\n                exp_v.push_back(checkChar(exp[j]));\\n                j++;\\n            }\\n        }\\n        vector<string > vs=  help (exp_v,0,exp_v.size()-1);\\n        // for (auto i:exp_v )cout<< i<<endl;\\n        vector<int> v ;\\n        for (auto i: vs ){\\n            vector<string> exp1 ;\\n            int j =0;\\n            while(j<i.length()){\\n                if(i[j]>=\\'0\\' && i[j]<=\\'9\\') {\\n                    int a = 0,x=1;\\n                    while(i[j]>=\\'0\\' && i[j]<=\\'9\\'){\\n                        a=a*x+(i[j]-\\'0\\');\\n                        x=x*10;\\n                        j++;\\n                    }\\n                    exp1.push_back(to_string(a));\\n                }else{\\n                    exp1.push_back(checkChar(i[j]));\\n                    j++;\\n                }\\n            }\\n            v.push_back(eval(exp1));\\n        }\\n        return v;\\n    }\\n    // start=0 and end =n-1\\n    // counts all possibilites of parenthesis and generates them\\n    vector<string> help(vector<string> exp,int start,int end){\\n        if (start>end) return {\"\"};\\n        if (start==end){\\n            return {exp[start]};\\n        }\\n        vector<string> ans ;\\n        for (int i =start+1;i<=end;i+=2){\\n            vector<string> in = help(exp,start,i-1);\\n            vector<string> out = help(exp,i+1,end);\\n            for (auto l: in){\\n                for (auto r:out){\\n                    ans.push_back(\"(\"+l+exp[i]+r+\")\");\\n                }\\n            }\\n        }\\n        return ans ;\\n    } \\n    \\n    // evaluating my expr\\n    int eval (vector<string> exp){\\n        stack <string> st ;\\n        for (int i = 0;i<exp.size();i++){\\n            if(exp[i]==\")\"){\\n                int b = stoi(st.top());\\n                st.pop();\\n                string ops = st.top();\\n                char op = ops[0];\\n                st.pop();\\n                int a = stoi(st.top());\\n                st.pop();\\n                st.pop(); // poping out \"(\"\\n                int c = opEval(a,op,b);\\n                st.push(to_string(c));\\n            }else{\\n                st.push(exp[i]);\\n            }\\n        }\\n        return stoi(st.top());\\n    }\\n    \\n    string checkChar(char c){\\n        if (c==\\'+\\') return \"+\";\\n        if (c==\\'-\\') return \"-\";\\n        if (c==\\'*\\') return \"*\";\\n        if (c==\\')\\') return \")\";\\n        return \"(\";\\n    }\\n    \\n    int opEval(int a, char op , int b){\\n        if (op==\\'+\\') return a+b;\\n        else if (op==\\'-\\') return a-b;\\n        else return a*b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string exp) {\\n        vector<string> exp_v ;\\n        int j = 0;\\n        while(j<exp.length()){\\n            if(exp[j]>=\\'0\\' && exp[j]<=\\'9\\') {\\n                int a = 0,x=1;\\n                while(exp[j]>=\\'0\\' && exp[j]<=\\'9\\'){\\n                    a=a*x+(exp[j]-\\'0\\');x=x*10;\\n                    j++;\\n                }\\n                exp_v.push_back(to_string(a));\\n            }else{\\n                exp_v.push_back(checkChar(exp[j]));\\n                j++;\\n            }\\n        }\\n        vector<string > vs=  help (exp_v,0,exp_v.size()-1);\\n        // for (auto i:exp_v )cout<< i<<endl;\\n        vector<int> v ;\\n        for (auto i: vs ){\\n            vector<string> exp1 ;\\n            int j =0;\\n            while(j<i.length()){\\n                if(i[j]>=\\'0\\' && i[j]<=\\'9\\') {\\n                    int a = 0,x=1;\\n                    while(i[j]>=\\'0\\' && i[j]<=\\'9\\'){\\n                        a=a*x+(i[j]-\\'0\\');\\n                        x=x*10;\\n                        j++;\\n                    }\\n                    exp1.push_back(to_string(a));\\n                }else{\\n                    exp1.push_back(checkChar(i[j]));\\n                    j++;\\n                }\\n            }\\n            v.push_back(eval(exp1));\\n        }\\n        return v;\\n    }\\n    // start=0 and end =n-1\\n    // counts all possibilites of parenthesis and generates them\\n    vector<string> help(vector<string> exp,int start,int end){\\n        if (start>end) return {\"\"};\\n        if (start==end){\\n            return {exp[start]};\\n        }\\n        vector<string> ans ;\\n        for (int i =start+1;i<=end;i+=2){\\n            vector<string> in = help(exp,start,i-1);\\n            vector<string> out = help(exp,i+1,end);\\n            for (auto l: in){\\n                for (auto r:out){\\n                    ans.push_back(\"(\"+l+exp[i]+r+\")\");\\n                }\\n            }\\n        }\\n        return ans ;\\n    } \\n    \\n    // evaluating my expr\\n    int eval (vector<string> exp){\\n        stack <string> st ;\\n        for (int i = 0;i<exp.size();i++){\\n            if(exp[i]==\")\"){\\n                int b = stoi(st.top());\\n                st.pop();\\n                string ops = st.top();\\n                char op = ops[0];\\n                st.pop();\\n                int a = stoi(st.top());\\n                st.pop();\\n                st.pop(); // poping out \"(\"\\n                int c = opEval(a,op,b);\\n                st.push(to_string(c));\\n            }else{\\n                st.push(exp[i]);\\n            }\\n        }\\n        return stoi(st.top());\\n    }\\n    \\n    string checkChar(char c){\\n        if (c==\\'+\\') return \"+\";\\n        if (c==\\'-\\') return \"-\";\\n        if (c==\\'*\\') return \"*\";\\n        if (c==\\')\\') return \")\";\\n        return \"(\";\\n    }\\n    \\n    int opEval(int a, char op , int b){\\n        if (op==\\'+\\') return a+b;\\n        else if (op==\\'-\\') return a-b;\\n        else return a*b;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1800372,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar diffWaysToCompute = function(expression) {\\n\\t\\tconst map = new Map();\\n\\t\\tconst operator = [\\'+\\', \\'-\\', \\'*\\'];\\n\\t\\tconst calculate = {\\n\\t\\t\\t\\'+\\': (a, b) => a + b,\\n\\t\\t\\t\\'-\\': (a, b) => a - b,\\n\\t\\t\\t\\'*\\': (a, b) => a * b,\\n\\t\\t};\\n\\t\\tconst compute = (express = expression) => {\\n\\t\\t\\tif (map.has(express)) return map.get(express);\\n\\t\\t\\tconst result = [];\\n\\n\\t\\t\\tfor (let index = 0; index < express.length; index++) {\\n\\t\\t\\t\\tconst currStr = express[index];\\n\\t\\t\\t\\tif (!operator.includes(currStr)) continue;\\n\\t\\t\\t\\tconst left = compute(express.slice(0, index));\\n\\t\\t\\t\\tconst right = compute(express.slice(index + 1));\\n\\n\\t\\t\\t\\tleft.forEach(valueL => {\\n\\t\\t\\t\\t\\tright.forEach(valueR => {\\n\\t\\t\\t\\t\\t\\tconst value = calculate[currStr](valueL, valueR);\\n\\n\\t\\t\\t\\t\\t\\tresult.push(value);\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\tresult.length === 0 && result.push(+express);\\n\\t\\t\\tmap.set(express, result);\\n\\t\\t\\treturn result;\\n\\t\\t};\\n\\n\\t\\treturn compute();",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar diffWaysToCompute = function(expression) {\\n\\t\\tconst map = new Map();\\n\\t\\tconst operator = [\\'+\\', \\'-\\', \\'*\\'];\\n\\t\\tconst calculate = {\\n\\t\\t\\t\\'+\\': (a, b) => a + b,\\n\\t\\t\\t\\'-\\': (a, b) => a - b,\\n\\t\\t\\t\\'*\\': (a, b) => a * b,\\n\\t\\t};\\n\\t\\tconst compute = (express = expression) => {\\n\\t\\t\\tif (map.has(express)) return map.get(express);\\n\\t\\t\\tconst result = [];\\n\\n\\t\\t\\tfor (let index = 0; index < express.length; index++) {\\n\\t\\t\\t\\tconst currStr = express[index];\\n\\t\\t\\t\\tif (!operator.includes(currStr)) continue;\\n\\t\\t\\t\\tconst left = compute(express.slice(0, index));\\n\\t\\t\\t\\tconst right = compute(express.slice(index + 1));\\n\\n\\t\\t\\t\\tleft.forEach(valueL => {\\n\\t\\t\\t\\t\\tright.forEach(valueR => {\\n\\t\\t\\t\\t\\t\\tconst value = calculate[currStr](valueL, valueR);\\n\\n\\t\\t\\t\\t\\t\\tresult.push(value);\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\tresult.length === 0 && result.push(+express);\\n\\t\\t\\tmap.set(express, result);\\n\\t\\t\\treturn result;\\n\\t\\t};\\n\\n\\t\\treturn compute();",
                "codeTag": "Unknown"
            },
            {
                "id": 1746060,
                "title": "java-easy-solution-99-faster-stringtokenizer-dp-bottom-up",
                "content": "```\\nimport java.util.*;\\nclass Solution {\\n    String data[];\\n    \\n    List<Integer> dp[][];\\n    public List<Integer> diffWaysToCompute(String expression) {\\n     \\n        StringTokenizer token=new StringTokenizer(expression,\"+-*\",true);\\n        data=new String[token.countTokens()];\\n        int i=0;\\n        while(token.hasMoreTokens())\\n            data[i++]=token.nextToken();\\n        \\n        dp=new ArrayList[data.length][data.length];\\n        return rec(0,data.length-1);\\n    }\\n    List<Integer> rec(int i,int j){\\n        \\n        if(dp[i][j]!=null) return dp[i][j];\\n        \\n        ArrayList<Integer> result=new ArrayList<>();\\n        if(i==j) {\\n            result.add(Integer.parseInt(data[i]));\\n            return dp[i][j]=result;\\n        } \\n        for(int k=i+1;k<=j-1;k+=2){\\n            List<Integer>  a = rec(i,k-1);\\n            List<Integer> b = rec(k+1,j);\\n            for(int a1:a){\\n                for(int b1:b)\\n                    result.add(cal(data[k],a1,b1));\\n            }\\n        }\\n        return  dp[i][j]=result;\\n    }\\n    \\n    int cal(String op,int a,int b){\\n        \\n        switch(op){\\n                case \"+\" :return a+b;\\n                case \"-\": return a-b;\\n                case \"*\": return a*b;\\n        }\\n        return 0;\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    String data[];\\n    \\n    List<Integer> dp[][];\\n    public List<Integer> diffWaysToCompute(String expression) {\\n     \\n        StringTokenizer token=new StringTokenizer(expression,\"+-*\",true);\\n        data=new String[token.countTokens()];\\n        int i=0;\\n        while(token.hasMoreTokens())\\n            data[i++]=token.nextToken();\\n        \\n        dp=new ArrayList[data.length][data.length];\\n        return rec(0,data.length-1);\\n    }\\n    List<Integer> rec(int i,int j){\\n        \\n        if(dp[i][j]!=null) return dp[i][j];\\n        \\n        ArrayList<Integer> result=new ArrayList<>();\\n        if(i==j) {\\n            result.add(Integer.parseInt(data[i]));\\n            return dp[i][j]=result;\\n        } \\n        for(int k=i+1;k<=j-1;k+=2){\\n            List<Integer>  a = rec(i,k-1);\\n            List<Integer> b = rec(k+1,j);\\n            for(int a1:a){\\n                for(int b1:b)\\n                    result.add(cal(data[k],a1,b1));\\n            }\\n        }\\n        return  dp[i][j]=result;\\n    }\\n    \\n    int cal(String op,int a,int b){\\n        \\n        switch(op){\\n                case \"+\" :return a+b;\\n                case \"-\": return a-b;\\n                case \"*\": return a*b;\\n        }\\n        return 0;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721276,
                "title": "c-advance-approach-100-fast-97-efficient-extension-of-matrix-chain-multiplication-mcm",
                "content": "```class Solution {\\npublic:\\n    void crossproduct(vector< int>& l, vector< int>& r, char op, vector< int>& p){\\n        for(int i:l){\\n            for(int j:r){\\n                if(op == \\'+\\') p.push_back(i+j);\\n                else if(op == \\'*\\') p.push_back(i*j);\\n                else p.push_back(i-j);\\n            }\\n        }\\n    }\\n    vector< int> findpossibleSol(vector<int>& operands, vector<char>& operators){\\n        int n = operands.size();\\n        vector< vector< vector< int>>> dp(n,vector< vector< int>>(n,vector< int>()));\\n        for(int i = 0; i < operands.size(); i++){\\n            dp[i][i].push_back(operands[i]);\\n        }\\n        for(int l = 1; l < n; l++){\\n            for(int i = 0, j = l; i < n-l; i++,j++){\\n                \\n                for(int k = i; k < j; k++){\\n                    crossproduct(dp[i][k], dp[k+1][j], operators[k], dp[i][j]);\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n    \\n    vector< int> diffWaysToCompute(string expression) {\\n        int n = expression.length();\\n        vector<int> operands;\\n        vector<char> operators;\\n        int num = 0;\\n        for(int i = 0; i < n; i++){\\n            if(expression[i] >= \\'0\\' && expression[i] <= \\'9\\'){\\n                num = 10*num + (expression[i]-\\'0\\');\\n            }\\n            else{\\n                operands.push_back(num);\\n                num = 0;\\n                operators.push_back(expression[i]);\\n            }\\n        }\\n        operands.push_back(num);\\n        return findpossibleSol(operands, operators);\\n    }\\n};\\n```\\nIf you know about the Tabulation DP approach of MCM, you will get this easily.\\nIn MCM, for ```[mat[i],..,mat[j]]```, we try all type of multiplication possible, and take the minimum.\\n\\nHere I am maintaining vector for each ```dp[i][j]``` cell, all possible evaluation for ```[i,...,j]``` operands.\\nSo instead of taking minimum from all the subproblems, i am crossproducting vectors of ```dp[i][k] and dp[i][k+1] for all i <= k < j```. crossproduct has operator ```operators[k]``` from actual expression.\\n\\nSo, 1. Divide given expression into operands and operator vector\\n2. Apply above given logic\\n3. Look at the ```function crossproduct()```  for details on how cross product been taken.",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    void crossproduct(vector< int>& l, vector< int>& r, char op, vector< int>& p){\\n        for(int i:l){\\n            for(int j:r){\\n                if(op == \\'+\\') p.push_back(i+j);\\n                else if(op == \\'*\\') p.push_back(i*j);\\n                else p.push_back(i-j);\\n            }\\n        }\\n    }\\n    vector< int> findpossibleSol(vector<int>& operands, vector<char>& operators){\\n        int n = operands.size();\\n        vector< vector< vector< int>>> dp(n,vector< vector< int>>(n,vector< int>()));\\n        for(int i = 0; i < operands.size(); i++){\\n            dp[i][i].push_back(operands[i]);\\n        }\\n        for(int l = 1; l < n; l++){\\n            for(int i = 0, j = l; i < n-l; i++,j++){\\n                \\n                for(int k = i; k < j; k++){\\n                    crossproduct(dp[i][k], dp[k+1][j], operators[k], dp[i][j]);\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n    \\n    vector< int> diffWaysToCompute(string expression) {\\n        int n = expression.length();\\n        vector<int> operands;\\n        vector<char> operators;\\n        int num = 0;\\n        for(int i = 0; i < n; i++){\\n            if(expression[i] >= \\'0\\' && expression[i] <= \\'9\\'){\\n                num = 10*num + (expression[i]-\\'0\\');\\n            }\\n            else{\\n                operands.push_back(num);\\n                num = 0;\\n                operators.push_back(expression[i]);\\n            }\\n        }\\n        operands.push_back(num);\\n        return findpossibleSol(operands, operators);\\n    }\\n};\\n```\n```[mat[i],..,mat[j]]```\n```dp[i][j]```\n```[i,...,j]```\n```dp[i][k] and dp[i][k+1] for all i <= k < j```\n```operators[k]```\n```function crossproduct()```",
                "codeTag": "Java"
            },
            {
                "id": 1714469,
                "title": "java-memorization-99-faster",
                "content": "String exp;\\n    HashMap<Integer, HashMap<Integer, List<Integer>>> memo = new HashMap<>();\\n    \\n    public List<Integer> diffWaysToCompute(String expression) {\\n        /*\\n        T: O(every expression possible)\\n        S: O(every expression possible)\\n        */\\n        this.exp= expression; \\n        \\n        return recursion(0, exp.length());\\n    }\\n    \\n    List<Integer> recursion(int s, int e) {\\n        if(memo.containsKey(s) && memo.get(s).containsKey(e)) return memo.get(s).get(e);\\n        List<Integer> res = new LinkedList<>();\\n        for(int i=s; i<e;i++){\\n            char c = exp.charAt(i);\\n            if(c == \\'+\\' || c == \\'-\\' || c == \\'*\\'){\\n                List<Integer> left = recursion(s, i);\\n                List<Integer> right = recursion(i+1, e);\\n                \\n                for(int l : left){\\n                    for(int r : right){\\n                        if(c == \\'+\\')    res.add(l+r);\\n                        if(c == \\'-\\')    res.add(l-r);\\n                        if(c == \\'*\\')    res.add(l*r);\\n                    }\\n                }\\n            }\\n        }\\n        if(res.size() ==0) res.add(Integer.valueOf(exp.substring(s,e)));\\n        \\n        if(!memo.containsKey(s)) memo.put(s, new HashMap<Integer, List<Integer>>());\\n        memo.get(s).put(e, res);\\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "String exp;\\n    HashMap<Integer, HashMap<Integer, List<Integer>>> memo = new HashMap<>();\\n    \\n    public List<Integer> diffWaysToCompute(String expression) {\\n        /*\\n        T: O(every expression possible)\\n        S: O(every expression possible)\\n        */\\n        this.exp= expression; \\n        \\n        return recursion(0, exp.length());\\n    }\\n    \\n    List<Integer> recursion(int s, int e) {\\n        if(memo.containsKey(s) && memo.get(s).containsKey(e)) return memo.get(s).get(e);\\n        List<Integer> res = new LinkedList<>();\\n        for(int i=s; i<e;i++){\\n            char c = exp.charAt(i);\\n            if(c == \\'+\\' || c == \\'-\\' || c == \\'*\\'){\\n                List<Integer> left = recursion(s, i);\\n                List<Integer> right = recursion(i+1, e);\\n                \\n                for(int l : left){\\n                    for(int r : right){\\n                        if(c == \\'+\\')    res.add(l+r);\\n                        if(c == \\'-\\')    res.add(l-r);\\n                        if(c == \\'*\\')    res.add(l*r);\\n                    }\\n                }\\n            }\\n        }\\n        if(res.size() ==0) res.add(Integer.valueOf(exp.substring(s,e)));\\n        \\n        if(!memo.containsKey(s)) memo.put(s, new HashMap<Integer, List<Integer>>());\\n        memo.get(s).put(e, res);\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1688407,
                "title": "c-0ms-dfs-memo",
                "content": "```\\nstruct HashPair {\\npublic:\\n    size_t operator() (const pair<int, int> &p) const {\\n        size_t h1 = hash<int>{}(p.first);\\n        size_t h2 = hash<int>{}(p.second);\\n        return h1 ^ h2;\\n    }\\n};\\n\\nclass Solution {\\nprivate:\\n    unordered_map<pair<int, int>, vector<int>, HashPair> memo;\\n    \\n    int str2Val(string &str, int s, int e) {\\n        int mul = 1;\\n        int res = 0;\\n        for (int i = e; i >= s; i--) {\\n            res += (str[i] - \\'0\\') * mul;\\n            mul *= 10;\\n        }\\n        return res;\\n    }\\n    \\n    bool isOperator(char c) {\\n        if (c == \\'+\\' || c == \\'-\\' || c == \\'*\\') return true;\\n        return false;\\n    }\\n    \\n    int cal(int a, int b, char op) {\\n        switch(op) {\\n            case \\'+\\':\\n                return a + b;\\n            case \\'-\\':\\n                return a - b;\\n            case \\'*\\':\\n                return a * b;\\n            default:\\n                break;\\n        }\\n        return 0;\\n    }\\n    \\n    vector<int> dfs(string &exp, int s, int e) {\\n        vector<int> res;\\n                \\n        // End case, no operator in this string\\n        if (e - s < 2) {\\n            res.push_back(str2Val(exp, s, e));\\n            return res;\\n        }\\n        \\n        // We have results for this particular interval\\n        if (memo.count({s, e})) return memo[{s, e}];\\n        \\n        // For each operator in current interval, recursively calculate result\\n        for (int i = s; i <= e; i++) {\\n            if (!isOperator(exp[i])) continue;\\n            \\n            vector<int> l = dfs(exp, s, i - 1);\\n            vector<int> r = dfs(exp, i + 1, e);\\n            \\n            for (int j = 0; j < l.size(); j++) {\\n                for (int k = 0; k < r.size(); k++) {\\n                    res.push_back(cal(l[j], r[k], exp[i]));\\n                }\\n            }\\n        }\\n        \\n        // Push result to memo to eliminate repeated computation\\n        memo[{s, e}] = res;\\n        return res;\\n    }\\npublic:\\n    vector<int> diffWaysToCompute(string exp) {\\n        return dfs(exp, 0, exp.size() - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nstruct HashPair {\\npublic:\\n    size_t operator() (const pair<int, int> &p) const {\\n        size_t h1 = hash<int>{}(p.first);\\n        size_t h2 = hash<int>{}(p.second);\\n        return h1 ^ h2;\\n    }\\n};\\n\\nclass Solution {\\nprivate:\\n    unordered_map<pair<int, int>, vector<int>, HashPair> memo;\\n    \\n    int str2Val(string &str, int s, int e) {\\n        int mul = 1;\\n        int res = 0;\\n        for (int i = e; i >= s; i--) {\\n            res += (str[i] - \\'0\\') * mul;\\n            mul *= 10;\\n        }\\n        return res;\\n    }\\n    \\n    bool isOperator(char c) {\\n        if (c == \\'+\\' || c == \\'-\\' || c == \\'*\\') return true;\\n        return false;\\n    }\\n    \\n    int cal(int a, int b, char op) {\\n        switch(op) {\\n            case \\'+\\':\\n                return a + b;\\n            case \\'-\\':\\n                return a - b;\\n            case \\'*\\':\\n                return a * b;\\n            default:\\n                break;\\n        }\\n        return 0;\\n    }\\n    \\n    vector<int> dfs(string &exp, int s, int e) {\\n        vector<int> res;\\n                \\n        // End case, no operator in this string\\n        if (e - s < 2) {\\n            res.push_back(str2Val(exp, s, e));\\n            return res;\\n        }\\n        \\n        // We have results for this particular interval\\n        if (memo.count({s, e})) return memo[{s, e}];\\n        \\n        // For each operator in current interval, recursively calculate result\\n        for (int i = s; i <= e; i++) {\\n            if (!isOperator(exp[i])) continue;\\n            \\n            vector<int> l = dfs(exp, s, i - 1);\\n            vector<int> r = dfs(exp, i + 1, e);\\n            \\n            for (int j = 0; j < l.size(); j++) {\\n                for (int k = 0; k < r.size(); k++) {\\n                    res.push_back(cal(l[j], r[k], exp[i]));\\n                }\\n            }\\n        }\\n        \\n        // Push result to memo to eliminate repeated computation\\n        memo[{s, e}] = res;\\n        return res;\\n    }\\npublic:\\n    vector<int> diffWaysToCompute(string exp) {\\n        return dfs(exp, 0, exp.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683340,
                "title": "recursion",
                "content": "```python\\n    def diffWaysToCompute(self, expr: str) -> List[int]:\\n        def search(expr):\\n            if expr.isdigit():\\n                return {int(expr)}\\n            \\n            ans = []\\n            for i in range(1, len(expr)-1):\\n                if expr[i] in (\\'+\\', \\'-\\', \\'*\\'):\\n                    for lhs in search(expr[:i]):\\n                        for rhs in search(expr[i+1:]):\\n                            ans += alu[expr[i]](lhs, rhs),\\n            return ans\\n                \\n        alu = {\\'+\\': lambda x, y : x + y,\\n               \\'-\\': lambda x, y : x - y,\\n               \\'*\\': lambda x, y : x * y,}\\n        \\n        return search(expr)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    def diffWaysToCompute(self, expr: str) -> List[int]:\\n        def search(expr):\\n            if expr.isdigit():\\n                return {int(expr)}\\n            \\n            ans = []\\n            for i in range(1, len(expr)-1):\\n                if expr[i] in (\\'+\\', \\'-\\', \\'*\\'):\\n                    for lhs in search(expr[:i]):\\n                        for rhs in search(expr[i+1:]):\\n                            ans += alu[expr[i]](lhs, rhs),\\n            return ans\\n                \\n        alu = {\\'+\\': lambda x, y : x + y,\\n               \\'-\\': lambda x, y : x - y,\\n               \\'*\\': lambda x, y : x * y,}\\n        \\n        return search(expr)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1680428,
                "title": "c-easy-dynamic-programming-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string e) {\\n        vector<int>res;\\n        if(e.length()==0)\\n            return res;\\n        \\n        for(int i=0;i<e.length();i++){\\n            if(e[i]==\\'-\\' || e[i]==\\'+\\' || e[i]==\\'*\\'){\\n                vector<int>left= diffWaysToCompute(e.substr(0,i));\\n                vector<int>right=diffWaysToCompute(e.substr(i+1));\\n                \\n                for(auto &a:left){\\n                    for(auto &b: right){\\n                \\n                        if(e[i]==\\'+\\'){\\n                            res.push_back(a+b);\\n                        }\\n                        else\\n                        if(e[i]==\\'-\\'){\\n                            res.push_back(a-b);\\n                        }\\n                        else\\n                        if(e[i]==\\'*\\'){\\n                            res.push_back(a*b);\\n                        }\\n                    }\\n\\n                }\\n     \\n            }\\n        }\\n        if(res.size()==0){\\n                stringstream geek(e);\\n                int x = 0;\\n                geek>>x;\\n            res.push_back(x);}\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string e) {\\n        vector<int>res;\\n        if(e.length()==0)\\n            return res;\\n        \\n        for(int i=0;i<e.length();i++){\\n            if(e[i]==\\'-\\' || e[i]==\\'+\\' || e[i]==\\'*\\'){\\n                vector<int>left= diffWaysToCompute(e.substr(0,i));\\n                vector<int>right=diffWaysToCompute(e.substr(i+1));\\n                \\n                for(auto &a:left){\\n                    for(auto &b: right){\\n                \\n                        if(e[i]==\\'+\\'){\\n                            res.push_back(a+b);\\n                        }\\n                        else\\n                        if(e[i]==\\'-\\'){\\n                            res.push_back(a-b);\\n                        }\\n                        else\\n                        if(e[i]==\\'*\\'){\\n                            res.push_back(a*b);\\n                        }\\n                    }\\n\\n                }\\n     \\n            }\\n        }\\n        if(res.size()==0){\\n                stringstream geek(e);\\n                int x = 0;\\n                geek>>x;\\n            res.push_back(x);}\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602811,
                "title": "java-recursive-divide-conquer-approach",
                "content": "```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String string) {\\n        List<Integer> ans=new ArrayList<>();\\n        \\n        for(int i=0;i<string.length();i++){\\n            char x=string.charAt(i);\\n            if(x==\\'+\\' || x==\\'-\\' || x==\\'*\\'){\\n                String a=string.substring(0,i);\\n                String b=string.substring(i+1);\\n                \\n                List<Integer> aL=diffWaysToCompute(a);\\n                List<Integer> bL=diffWaysToCompute(b);\\n                \\n                for(int y=0;y<aL.size();y++){\\n                    for(int z=0;z<bL.size();z++){\\n                        int p=aL.get(y);\\n                        int q=bL.get(z);\\n                        \\n                        if(x==\\'+\\') ans.add(p+q);\\n                        else if(x==\\'-\\') ans.add(p-q);\\n                        else if(x==\\'*\\') ans.add(p*q);\\n                    }\\n                }\\n            }\\n        }\\n        if(ans.size()==0) ans.add(Integer.valueOf(string));\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String string) {\\n        List<Integer> ans=new ArrayList<>();\\n        \\n        for(int i=0;i<string.length();i++){\\n            char x=string.charAt(i);\\n            if(x==\\'+\\' || x==\\'-\\' || x==\\'*\\'){\\n                String a=string.substring(0,i);\\n                String b=string.substring(i+1);\\n                \\n                List<Integer> aL=diffWaysToCompute(a);\\n                List<Integer> bL=diffWaysToCompute(b);\\n                \\n                for(int y=0;y<aL.size();y++){\\n                    for(int z=0;z<bL.size();z++){\\n                        int p=aL.get(y);\\n                        int q=bL.get(z);\\n                        \\n                        if(x==\\'+\\') ans.add(p+q);\\n                        else if(x==\\'-\\') ans.add(p-q);\\n                        else if(x==\\'*\\') ans.add(p*q);\\n                    }\\n                }\\n            }\\n        }\\n        if(ans.size()==0) ans.add(Integer.valueOf(string));\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1558460,
                "title": "c-memoization-100-faster-easy-to-read",
                "content": "```\\nclass Solution {\\n    /* Hash map to use as a cache */\\n    unordered_map<string, vector<int>> mem;\\n    \\n    /* Given an expression, return the\\n    indexes of the operands */\\n    vector<int> getOps(string str)\\n    {\\n        vector<int> ops;\\n        \\n        for(int i=0; i<str.length(); i++)\\n        {\\n            if((str[i] == \\'+\\') || (str[i] == \\'-\\') ||\\n               (str[i] == \\'*\\'))\\n            {\\n                ops.push_back(i);\\n            }\\n        }\\n        \\n        return ops;\\n    }\\n    \\n    /* Compute the given operation on the\\n    given integers */\\n    int compute(int num1, int num2, char op)\\n    {\\n        switch(op)\\n        {\\n            case \\'+\\':\\n                return (num1 + num2);\\n            case \\'-\\':\\n                return (num1 - num2);\\n            default:\\n                return (num1 * num2);\\n        }\\n    }\\n    \\npublic:\\n    vector<int> diffWaysToCompute(string expression) {\\n        vector<int> ret;\\n        \\n        /* Get indexes of operators */\\n        vector<int> ops = getOps(expression);\\n        \\n        if(expression.length() == 0)\\n            return ret;\\n        \\n        /* Must be an integer value if no operators \\n        return that value */\\n        if(ops.size() == 0)\\n        {\\n            int num = stoi(expression, nullptr);\\n            ret.push_back(num);\\n            return ret;\\n        }\\n        \\n        /* Return ways if already computed */\\n        if(mem.count(expression))\\n            return mem[expression];\\n        \\n        for(int i=0; i<ops.size(); i++)\\n        {\\n            \\n            /* split string at operand */\\n            string exp1 = expression.substr(0,ops[i]);\\n            string exp2 = expression.substr(ops[i]+1, expression.size() - (ops[i] - 1));\\n            \\n            vector<int> res1 = diffWaysToCompute(exp1);\\n            vector<int> res2 = diffWaysToCompute(exp2);\\n            \\n            for(int k=0; k<res1.size(); k++)\\n            {\\n                for(int j=0; j<res2.size(); j++)\\n                {\\n                    int total = compute(res1[k], res2[j], expression[ops[i]]);\\n                    ret.push_back(total);\\n                }\\n            }\\n        }\\n        \\n        /* cache computed ways */\\n        mem.insert({{expression, ret}});\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /* Hash map to use as a cache */\\n    unordered_map<string, vector<int>> mem;\\n    \\n    /* Given an expression, return the\\n    indexes of the operands */\\n    vector<int> getOps(string str)\\n    {\\n        vector<int> ops;\\n        \\n        for(int i=0; i<str.length(); i++)\\n        {\\n            if((str[i] == \\'+\\') || (str[i] == \\'-\\') ||\\n               (str[i] == \\'*\\'))\\n            {\\n                ops.push_back(i);\\n            }\\n        }\\n        \\n        return ops;\\n    }\\n    \\n    /* Compute the given operation on the\\n    given integers */\\n    int compute(int num1, int num2, char op)\\n    {\\n        switch(op)\\n        {\\n            case \\'+\\':\\n                return (num1 + num2);\\n            case \\'-\\':\\n                return (num1 - num2);\\n            default:\\n                return (num1 * num2);\\n        }\\n    }\\n    \\npublic:\\n    vector<int> diffWaysToCompute(string expression) {\\n        vector<int> ret;\\n        \\n        /* Get indexes of operators */\\n        vector<int> ops = getOps(expression);\\n        \\n        if(expression.length() == 0)\\n            return ret;\\n        \\n        /* Must be an integer value if no operators \\n        return that value */\\n        if(ops.size() == 0)\\n        {\\n            int num = stoi(expression, nullptr);\\n            ret.push_back(num);\\n            return ret;\\n        }\\n        \\n        /* Return ways if already computed */\\n        if(mem.count(expression))\\n            return mem[expression];\\n        \\n        for(int i=0; i<ops.size(); i++)\\n        {\\n            \\n            /* split string at operand */\\n            string exp1 = expression.substr(0,ops[i]);\\n            string exp2 = expression.substr(ops[i]+1, expression.size() - (ops[i] - 1));\\n            \\n            vector<int> res1 = diffWaysToCompute(exp1);\\n            vector<int> res2 = diffWaysToCompute(exp2);\\n            \\n            for(int k=0; k<res1.size(); k++)\\n            {\\n                for(int j=0; j<res2.size(); j++)\\n                {\\n                    int total = compute(res1[k], res2[j], expression[ops[i]]);\\n                    ret.push_back(total);\\n                }\\n            }\\n        }\\n        \\n        /* cache computed ways */\\n        mem.insert({{expression, ret}});\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443492,
                "title": "a-recursive-java-solution-simple-to-understand-runtime-10ms",
                "content": "self explanatory code\\n\\njust keep in mind 3 things\\n1.always make a partion when you encounters a operator or a string which is not numeric\\n2.always keep in mind that when you approach an element which is single take it and put it into the list\\n3. if u encounter a null skip it\\n\\n\\nExample 2:\\n\\nInput: expression = \"2*3-4*5\"\\nOutput: [-34,-14,-10,-10,10]\\nExplanation:\\n(2*(3-(4*5))) = -34 \\n((2*3)-(4*5)) = -14 \\n((2*(3-4))*5) = -10 \\n(2*((3-4)*5)) = -10 \\n(((2*3)-4)*5) = 10\\n\\ndo left * right\\nexample \\n(((2*(3-4))*5) = -10 \\n(2*((3-4)*5)) = -10 \\n\\nsee the paranthesis\\n```\\n\\nclass Solution \\n{\\n    //to check if string is a no or something else\\n  public static boolean isNumeric(String str) \\n  { \\n  try {  \\n      Integer.parseInt(str);  \\n      return true;\\n      } \\n      catch(NumberFormatException e){  \\n      return false;  \\n     }  \\n  }\\n/// to pack MCM\\n    public static List<Integer> generate(int n,int i,int j,String arr[])\\n    {\\n        if(i>=j)   //if u got a null\\n        {\\n            return null;\\n        }\\n        if(i==j-1)  // if u encounters a single character\\n        {\\n            List<Integer> store_val=new ArrayList<Integer>();store_val.add(Integer.parseInt(arr[i]));\\n            return store_val;\\n        }\\n         List<Integer> store_total_val=new ArrayList<Integer>();\\n        for(int k=i;k<j;k++)\\n        {\\n            if(isNumeric(arr[k]))   //to check if a string is numeric\\n            {\\n                continue;\\n            }\\n            List<Integer> store_val_left=generate(n,i,k,arr);  //store the left follow catllan rule\\n            List<Integer> store_val_right=generate(n,k+1,j,arr); //store the right \\n            if(store_val_left!=null && store_val_right!=null)\\n            {\\n                for(Integer left:store_val_left)\\n                {\\n                    for(Integer right:store_val_right)\\n                    {\\n                         if(arr[k].equals(\"*\")) // do every elements left*right\\n                         {\\n                              store_total_val.add(left*right);\\n                         }\\n                        else\\n                             if(arr[k].equals(\"+\"))\\n                         {\\n                              store_total_val.add(left+right);\\n                         }\\n                        else\\n                            if(arr[k].equals(\"-\"))\\n                         {\\n                              store_total_val.add(left-right);\\n                         }\\n                        else\\n                              if(arr[k].equals(\"/\"))\\n                         {\\n                              store_total_val.add(left/right);\\n                         }\\n                    }\\n                }\\n            }\\n        }\\n        return store_total_val;\\n    }\\n    public List<Integer> diffWaysToCompute(String s) \\n    {\\n        int n=s.length();\\n        ArrayList<String> arr=new ArrayList<String>();\\n        for(int i=0;i<n;i++) /*i have did this because if \"22*3-45\" it changes to [\"22\",\"*\\n\",\"3\",\"-\",\"45\"]*/\\n{\\n\\n            String s1=\"\";\\n            while(i<n && s.charAt(i)!=\\'*\\'&&s.charAt(i)!=\\'+\\'&&s.charAt(i)!=\\'-\\'&&s.charAt(i)!=\\'/\\')\\n            {\\n                s1=s1+s.charAt(i);\\n                i++;\\n            }\\n            arr.add(s1);\\n             String s2=\"\";\\n            if(i<n)\\n            {\\n           s2=s2+s.charAt(i);\\n            arr.add(s2);\\n            }\\n        }\\n        String[] p=new String[arr.size()];\\n        for(int i=0;i<arr.size();i++)\\n        {\\n\\n            p[i]=arr.get(i);\\n        }\\n\\t\\treturn generate(arr.size(),0,arr.size(),p);\\n\\t\\t\\t\\t\\n    }\\n}\\n\\n\\n```\\n# please upvote",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution \\n{\\n    //to check if string is a no or something else\\n  public static boolean isNumeric(String str) \\n  { \\n  try {  \\n      Integer.parseInt(str);  \\n      return true;\\n      } \\n      catch(NumberFormatException e){  \\n      return false;  \\n     }  \\n  }\\n/// to pack MCM\\n    public static List<Integer> generate(int n,int i,int j,String arr[])\\n    {\\n        if(i>=j)   //if u got a null\\n        {\\n            return null;\\n        }\\n        if(i==j-1)  // if u encounters a single character\\n        {\\n            List<Integer> store_val=new ArrayList<Integer>();store_val.add(Integer.parseInt(arr[i]));\\n            return store_val;\\n        }\\n         List<Integer> store_total_val=new ArrayList<Integer>();\\n        for(int k=i;k<j;k++)\\n        {\\n            if(isNumeric(arr[k]))   //to check if a string is numeric\\n            {\\n                continue;\\n            }\\n            List<Integer> store_val_left=generate(n,i,k,arr);  //store the left follow catllan rule\\n            List<Integer> store_val_right=generate(n,k+1,j,arr); //store the right \\n            if(store_val_left!=null && store_val_right!=null)\\n            {\\n                for(Integer left:store_val_left)\\n                {\\n                    for(Integer right:store_val_right)\\n                    {\\n                         if(arr[k].equals(\"*\")) // do every elements left*right\\n                         {\\n                              store_total_val.add(left*right);\\n                         }\\n                        else\\n                             if(arr[k].equals(\"+\"))\\n                         {\\n                              store_total_val.add(left+right);\\n                         }\\n                        else\\n                            if(arr[k].equals(\"-\"))\\n                         {\\n                              store_total_val.add(left-right);\\n                         }\\n                        else\\n                              if(arr[k].equals(\"/\"))\\n                         {\\n                              store_total_val.add(left/right);\\n                         }\\n                    }\\n                }\\n            }\\n        }\\n        return store_total_val;\\n    }\\n    public List<Integer> diffWaysToCompute(String s) \\n    {\\n        int n=s.length();\\n        ArrayList<String> arr=new ArrayList<String>();\\n        for(int i=0;i<n;i++) /*i have did this because if \"22*3-45\" it changes to [\"22\",\"*\\n\",\"3\",\"-\",\"45\"]*/\\n{\\n\\n            String s1=\"\";\\n            while(i<n && s.charAt(i)!=\\'*\\'&&s.charAt(i)!=\\'+\\'&&s.charAt(i)!=\\'-\\'&&s.charAt(i)!=\\'/\\')\\n            {\\n                s1=s1+s.charAt(i);\\n                i++;\\n            }\\n            arr.add(s1);\\n             String s2=\"\";\\n            if(i<n)\\n            {\\n           s2=s2+s.charAt(i);\\n            arr.add(s2);\\n            }\\n        }\\n        String[] p=new String[arr.size()];\\n        for(int i=0;i<arr.size();i++)\\n        {\\n\\n            p[i]=arr.get(i);\\n        }\\n\\t\\treturn generate(arr.size(),0,arr.size(),p);\\n\\t\\t\\t\\t\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409381,
                "title": "c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void print (vector<int> &arr) {\\n        cout << \"arr is \";\\n        for (int &i : arr) {\\n            cout << i << \" \";\\n        }\\n        cout << endl;\\n    }\\n    \\n    vector<int> diffWaysToCompute(string expression) {\\n        vector<int> ans;\\n        if (expression.length() == 0) return ans;\\n        \\n        \\n        //cout << \"Expression is \" << expression << endl;\\n        for (int i = 0; i < expression.length(); i++) {\\n            if (isdigit(expression[i])) {\\n                continue;\\n            }\\n            vector<int> left = diffWaysToCompute(expression.substr(0, i));\\n            vector<int> right = diffWaysToCompute(expression.substr(i+1));\\n            for (int j = 0; j < left.size(); j++) {\\n                for (int k = 0; k < right.size(); k++) {\\n                    switch (expression[i]) {\\n                        case \\'+\\':\\n                            ans.push_back(left[j]+right[k]);\\n                            break;\\n                        case \\'-\\':\\n                            ans.push_back(left[j]-right[k]);\\n                            break;\\n                        case \\'*\\':\\n                            ans.push_back(left[j]*right[k]);\\n                            break;\\n                        default:\\n                            break;\\n                    }\\n                }\\n            }\\n           // print(ans);\\n        }\\n        \\n        if (ans.size() == 0 && expression.length() > 0) {\\n            ans.push_back(stoi(expression));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void print (vector<int> &arr) {\\n        cout << \"arr is \";\\n        for (int &i : arr) {\\n            cout << i << \" \";\\n        }\\n        cout << endl;\\n    }\\n    \\n    vector<int> diffWaysToCompute(string expression) {\\n        vector<int> ans;\\n        if (expression.length() == 0) return ans;\\n        \\n        \\n        //cout << \"Expression is \" << expression << endl;\\n        for (int i = 0; i < expression.length(); i++) {\\n            if (isdigit(expression[i])) {\\n                continue;\\n            }\\n            vector<int> left = diffWaysToCompute(expression.substr(0, i));\\n            vector<int> right = diffWaysToCompute(expression.substr(i+1));\\n            for (int j = 0; j < left.size(); j++) {\\n                for (int k = 0; k < right.size(); k++) {\\n                    switch (expression[i]) {\\n                        case \\'+\\':\\n                            ans.push_back(left[j]+right[k]);\\n                            break;\\n                        case \\'-\\':\\n                            ans.push_back(left[j]-right[k]);\\n                            break;\\n                        case \\'*\\':\\n                            ans.push_back(left[j]*right[k]);\\n                            break;\\n                        default:\\n                            break;\\n                    }\\n                }\\n            }\\n           // print(ans);\\n        }\\n        \\n        if (ans.size() == 0 && expression.length() > 0) {\\n            ans.push_back(stoi(expression));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1242683,
                "title": "c-dp-recursion-divide-and-conquer-solution-beats-100",
                "content": "```\\nclass Solution {\\n    unordered_map<string, vector<int>> results_map;\\npublic:\\n    vector<int> diffWaysToCompute(string expression) {\\n        if (results_map.count(expression)) return results_map[expression];\\n        vector<int> ans;\\n\\n        for (int i = 0; i < expression.size(); ++i) {\\n            if (expression[i] == \\'+\\' || expression[i] == \\'-\\' || expression[i] == \\'*\\') {\\n\\n                vector<int> result1 = diffWaysToCompute(expression.substr(0, i));\\n                vector<int> result2 = diffWaysToCompute(expression.substr(i + 1));\\n\\n                for (int r1 : result1)\\n                    for (int r2 : result2)\\n                        if (expression[i] == \\'+\\')\\n                            ans.push_back(r1 + r2);\\n                        else if (expression[i] == \\'-\\')\\n                            ans.push_back(r1 - r2);\\n                        else if (expression[i] == \\'*\\')\\n                            ans.push_back(r1 * r2);\\n            }\\n        }\\n        if (!ans.size()) ans.push_back(stoi(expression));\\n        results_map[expression] = ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<string, vector<int>> results_map;\\npublic:\\n    vector<int> diffWaysToCompute(string expression) {\\n        if (results_map.count(expression)) return results_map[expression];\\n        vector<int> ans;\\n\\n        for (int i = 0; i < expression.size(); ++i) {\\n            if (expression[i] == \\'+\\' || expression[i] == \\'-\\' || expression[i] == \\'*\\') {\\n\\n                vector<int> result1 = diffWaysToCompute(expression.substr(0, i));\\n                vector<int> result2 = diffWaysToCompute(expression.substr(i + 1));\\n\\n                for (int r1 : result1)\\n                    for (int r2 : result2)\\n                        if (expression[i] == \\'+\\')\\n                            ans.push_back(r1 + r2);\\n                        else if (expression[i] == \\'-\\')\\n                            ans.push_back(r1 - r2);\\n                        else if (expression[i] == \\'*\\')\\n                            ans.push_back(r1 * r2);\\n            }\\n        }\\n        if (!ans.size()) ans.push_back(stoi(expression));\\n        results_map[expression] = ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228755,
                "title": "concise-recursive-97-faster-substrings-switch-cases-js-es6",
                "content": "```\\nconst diffWaysToCompute = function(expression) {\\n    if(!expression.length) return [0];\\n    const result = [];\\n\\t\\n    for(let idx = 0; idx < expression.length; idx++){\\n        const char = expression[idx];\\n        if(char === \"+\" || char === \"-\" || char === \"*\"){\\n\\t\\t\\t//recurse\\n            const left = diffWaysToCompute(expression.substring(0, idx));\\n            const right = diffWaysToCompute(expression.substring(idx+1));\\n            //compute\\n            for(let leftVal of left){\\n                for(let rightVal of right){\\n                   switch(char){\\n                    case \"+\": result.push(parseInt(leftVal)+parseInt(rightVal)); break;\\n                    case \"-\": result.push(parseInt(leftVal)-parseInt(rightVal)); break;\\n                    default: result.push(parseInt(leftVal)*parseInt(rightVal)); break;\\n                    } \\n                }\\n            }  \\n        }\\n    }\\n    if(!result.length) return [expression]\\n    return result\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/97a6d72d-60bf-4648-810e-708cbe4d09b9_1621898269.7715015.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nconst diffWaysToCompute = function(expression) {\\n    if(!expression.length) return [0];\\n    const result = [];\\n\\t\\n    for(let idx = 0; idx < expression.length; idx++){\\n        const char = expression[idx];\\n        if(char === \"+\" || char === \"-\" || char === \"*\"){\\n\\t\\t\\t//recurse\\n            const left = diffWaysToCompute(expression.substring(0, idx));\\n            const right = diffWaysToCompute(expression.substring(idx+1));\\n            //compute\\n            for(let leftVal of left){\\n                for(let rightVal of right){\\n                   switch(char){\\n                    case \"+\": result.push(parseInt(leftVal)+parseInt(rightVal)); break;\\n                    case \"-\": result.push(parseInt(leftVal)-parseInt(rightVal)); break;\\n                    default: result.push(parseInt(leftVal)*parseInt(rightVal)); break;\\n                    } \\n                }\\n            }  \\n        }\\n    }\\n    if(!result.length) return [expression]\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1170449,
                "title": "javascript-intuitive-divide-and-conquer",
                "content": "```javascript\\nvar diffWaysToCompute = function(expression) {\\n    const numsArr = expression.match(/\\\\d+/g).map(Number);\\n    const opsArr = expression.match(/[^\\\\d]/g);\\n    \\n    function backtrack(nums, ops) {\\n        if(nums.length == 1) return nums;\\n        const result = [];\\n        \\n        for(let i = 0; i < ops.length; i++) {\\n            const left = backtrack(nums.slice(0, i+1), ops.slice(0, i));\\n            const right = backtrack(nums.slice(i+1), ops.slice(i+1));\\n            \\n            for(let n1 of left) {\\n                for(let n2 of right) {\\n                    if(ops[i] == \\'*\\') result.push(n1 * n2);\\n                    else if(ops[i] == \\'+\\') result.push(n1 + n2);\\n                    else result.push(n1 - n2)\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    return backtrack(numsArr, opsArr);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Divide and Conquer"
                ],
                "code": "```javascript\\nvar diffWaysToCompute = function(expression) {\\n    const numsArr = expression.match(/\\\\d+/g).map(Number);\\n    const opsArr = expression.match(/[^\\\\d]/g);\\n    \\n    function backtrack(nums, ops) {\\n        if(nums.length == 1) return nums;\\n        const result = [];\\n        \\n        for(let i = 0; i < ops.length; i++) {\\n            const left = backtrack(nums.slice(0, i+1), ops.slice(0, i));\\n            const right = backtrack(nums.slice(i+1), ops.slice(i+1));\\n            \\n            for(let n1 of left) {\\n                for(let n2 of right) {\\n                    if(ops[i] == \\'*\\') result.push(n1 * n2);\\n                    else if(ops[i] == \\'+\\') result.push(n1 + n2);\\n                    else result.push(n1 - n2)\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    return backtrack(numsArr, opsArr);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1135458,
                "title": "my-java-solution-using-recursion-and-hashmap",
                "content": "```\\nclass Solution {\\n    private Map<String, List<Integer>> map = new HashMap<>();\\n    public List<Integer> diffWaysToCompute(String expression) {\\n        int length = expression.length();\\n        List<Integer> result = new ArrayList<>();\\n        if (expression == null || length == 0)\\n            return result;\\n        if (map.containsKey(expression))\\n            return map.get(expression);\\n        for (int i=0; i<length; i++) {\\n            char ch = expression.charAt(i);\\n            if (ch == \\'+\\' || ch == \\'-\\' || ch == \\'*\\') {\\n                String operator1 = expression.substring(0, i);\\n                String operator2 = expression.substring(i+1);\\n                List<Integer> divide1 = diffWaysToCompute(operator1);\\n                List<Integer> divide2 = diffWaysToCompute(operator2);\\n                for (Integer num1 : divide1) {\\n                    for (Integer num2 : divide2) {\\n                        int arithmeticResult = 0;\\n                        if (ch == \\'+\\')\\n                            arithmeticResult = num1 + num2;\\n                        else if (ch == \\'-\\')\\n                            arithmeticResult = num1 - num2;\\n                        else if (ch == \\'*\\')\\n                            arithmeticResult = num1 * num2;\\n                        result.add(arithmeticResult);\\n                    }\\n                }\\n            }\\n        }\\n        if (result.size() == 0)\\n            result.add(Integer.valueOf(expression));\\n        map.put(expression, result);\\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private Map<String, List<Integer>> map = new HashMap<>();\\n    public List<Integer> diffWaysToCompute(String expression) {\\n        int length = expression.length();\\n        List<Integer> result = new ArrayList<>();\\n        if (expression == null || length == 0)\\n            return result;\\n        if (map.containsKey(expression))\\n            return map.get(expression);\\n        for (int i=0; i<length; i++) {\\n            char ch = expression.charAt(i);\\n            if (ch == \\'+\\' || ch == \\'-\\' || ch == \\'*\\') {\\n                String operator1 = expression.substring(0, i);\\n                String operator2 = expression.substring(i+1);\\n                List<Integer> divide1 = diffWaysToCompute(operator1);\\n                List<Integer> divide2 = diffWaysToCompute(operator2);\\n                for (Integer num1 : divide1) {\\n                    for (Integer num2 : divide2) {\\n                        int arithmeticResult = 0;\\n                        if (ch == \\'+\\')\\n                            arithmeticResult = num1 + num2;\\n                        else if (ch == \\'-\\')\\n                            arithmeticResult = num1 - num2;\\n                        else if (ch == \\'*\\')\\n                            arithmeticResult = num1 * num2;\\n                        result.add(arithmeticResult);\\n                    }\\n                }\\n            }\\n        }\\n        if (result.size() == 0)\\n            result.add(Integer.valueOf(expression));\\n        map.put(expression, result);\\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119315,
                "title": "java-divide-and-conquer-solution-with-detailed-comments",
                "content": "```\\nclass Solution {\\n\\n    public List<Integer> diffWaysToCompute(String expression) {\\n        List<Integer> combinedResult = new ArrayList<>();\\n        \\n        for(int i = 0; i < expression.length(); i++){\\n            // if the character at postion \\'i\\' is not a digit then its an operator which means we have an expression\\n            if(!Character.isDigit(expression.charAt(i))){        \\n                // store the operator \\n                char op = expression.charAt(i);\\n                \\n                // divide step:\\n                // obtain the substring that is to the left of the operator \\n                // and the substring that is to the right of the operator\\n                String leftHalf = expression.substring(0, i);\\n                String rightHalf = expression.substring(i+1, expression.length());\\n                \\n                // conquer step:\\n                // recursively find all the ways to compute the left and right halves of the expression \\n                List<Integer> leftResults = diffWaysToCompute(leftHalf);\\n                List<Integer> rightResults = diffWaysToCompute(rightHalf);\\n                \\n                // combine step:\\n                // combine the left and right halves by computing the current operation using all of the \\n                // left results with all of the right results\\n                for(int leftVal : leftResults){\\n                    for(int rightVal : rightResults){\\n                        int result = executeOperation(leftVal, rightVal, op);\\n                        combinedResult.add(result);\\n                    }\\n                }           \\n            }\\n        }\\n        \\n        // handle the base case where the string passed to the algorithm was just a number or empty string and not an expression\\n        if(combinedResult.isEmpty() && !expression.isEmpty()) combinedResult.add(Integer.valueOf(expression));\\n        \\n        return combinedResult;\\n    }\\n    \\n    public int executeOperation(int x, int y, char op){\\n        if(op == \\'*\\') return x * y;\\n        if(op == \\'-\\') return x - y;\\n        return x + y;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<Integer> diffWaysToCompute(String expression) {\\n        List<Integer> combinedResult = new ArrayList<>();\\n        \\n        for(int i = 0; i < expression.length(); i++){\\n            // if the character at postion \\'i\\' is not a digit then its an operator which means we have an expression\\n            if(!Character.isDigit(expression.charAt(i))){        \\n                // store the operator \\n                char op = expression.charAt(i);\\n                \\n                // divide step:\\n                // obtain the substring that is to the left of the operator \\n                // and the substring that is to the right of the operator\\n                String leftHalf = expression.substring(0, i);\\n                String rightHalf = expression.substring(i+1, expression.length());\\n                \\n                // conquer step:\\n                // recursively find all the ways to compute the left and right halves of the expression \\n                List<Integer> leftResults = diffWaysToCompute(leftHalf);\\n                List<Integer> rightResults = diffWaysToCompute(rightHalf);\\n                \\n                // combine step:\\n                // combine the left and right halves by computing the current operation using all of the \\n                // left results with all of the right results\\n                for(int leftVal : leftResults){\\n                    for(int rightVal : rightResults){\\n                        int result = executeOperation(leftVal, rightVal, op);\\n                        combinedResult.add(result);\\n                    }\\n                }           \\n            }\\n        }\\n        \\n        // handle the base case where the string passed to the algorithm was just a number or empty string and not an expression\\n        if(combinedResult.isEmpty() && !expression.isEmpty()) combinedResult.add(Integer.valueOf(expression));\\n        \\n        return combinedResult;\\n    }\\n    \\n    public int executeOperation(int x, int y, char op){\\n        if(op == \\'*\\') return x * y;\\n        if(op == \\'-\\') return x - y;\\n        return x + y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095569,
                "title": "easy-to-understand-java-solution-1-ms-faster-than-99-68-clean-code-with-comment",
                "content": "class Solution {\\n    ArrayList<Integer> numbers;\\n    ArrayList<Character> operators; \\n    ArrayList<Integer>[][] dp;\\n    int n;\\n    \\n    public List<Integer> diffWaysToCompute(String input) {\\n        //intialise \\n        numbers = new ArrayList();\\n        operators = new ArrayList();\\n\\n        splitNumbersAndOperators(input);\\n        \\n        n = numbers.size();\\n        dp = new ArrayList[n][n];\\n        \\n        //find all ways to compute         \\n        findWays();\\n        \\n        //all possible ways to compute \\n        return dp[0][n - 1];\\n    }\\n    \\n    private void findWays(){\\n        \\n        //iterate for each widows size [1 to n]\\n        for(int windowSize = 1; windowSize <= n; windowSize++){\\n            for(int left = 0; left <= n - windowSize; left++){\\n                \\n                int right = left + windowSize - 1;\\n                \\n                //save all the posible result from left to right, [left, right] e,g inclusive\\n                dp[left][right] = getAllPossibleResult(left, right);\\n            }\\n        }\\n        \\n    }\\n    \\n    private ArrayList<Integer> getAllPossibleResult(int left, int right){\\n        ArrayList<Integer> results = new ArrayList();\\n        \\n        if(left == right){\\n            results.add(numbers.get(left));\\n            return results;\\n        } \\n        \\n        //    2  *  3  -  4  *  5 - 9\\n        \\n        //    0     1     2     3   4  -> index       \\n        //    2     3     4     5   9  -> numbers\\n        //    *     -     *     -      -> operators\\n        //.               oI           -> operatorIndex = 2\\n        \\n        // possible left calculation\\n        //     2     3    4 \\n        //     *     - \\n        //     1. (2 * 3) - 4 =  2\\n        //     2. 2 * (3 - 4) =  -2\\n        //     dp[left][operatorIndex] = [2, -2]\\n        //     dp[0][2] = [2, -2]\\n        \\n        \\n        // possible right calculation\\n        //     5     9\\n        //     -\\n        //     1. (5 - 9) = -4\\n        //     dp[operatorIndex + 1][right] = [-4]\\n        //     dp[2 + 1][4] = [-4]\\n        \\n        \\n        for(int operatorIndex = left; operatorIndex < right; operatorIndex++){\\n            char operator = operators.get(operatorIndex);\\n            \\n            //get all possible left calculation result from left -> operatorIndex\\n            for(int leftResult :  dp[left][operatorIndex]){\\n                \\n                //get all possible right calculation result from operatorIndex + 1 -> right\\n                for(int rightResult :  dp[operatorIndex + 1][right]){\\n                    //add calculation result\\n                    results.add(calculate(leftResult, rightResult,  operator));\\n                }\\n            }\\n        }\\n        \\n        return results;\\n    }\\n    \\n    private void splitNumbersAndOperators(String str){\\n        // 2*32-1\\n        // 012345\\n        \\n        int num = 0;\\n        \\n        for(char c : str.toCharArray()){\\n            if(c == \\'+\\' || c == \\'-\\' || c == \\'*\\') {\\n                //add this oerator in the operator list\\n                operators.add(c);\\n                \\n                //add number in number list\\n                numbers.add(num);\\n                \\n                //now reset this numbere to 0,\\n                //so it can find another number after this operator e.g c\\n                num = 0;\\n            } else {\\n                int digit = c - \\'0\\';\\n                num = (num * 10) + digit;\\n            }\\n        }\\n        \\n        //add last number\\n        numbers.add(num);\\n    }\\n    \\n    private int calculate(int num1, int num2, char operator){\\n        if(operator == \\'+\\') return num1 + num2;\\n        \\n        if(operator == \\'-\\') return num1 - num2;\\n        \\n        if(operator == \\'*\\') return num1 * num2;\\n        \\n        return  num1 * num2;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    ArrayList<Integer> numbers;\\n    ArrayList<Character> operators; \\n    ArrayList<Integer>[][] dp;\\n    int n;\\n    \\n    public List<Integer> diffWaysToCompute(String input) {\\n        //intialise \\n        numbers = new ArrayList();\\n        operators = new ArrayList();\\n\\n        splitNumbersAndOperators(input);\\n        \\n        n = numbers.size();\\n        dp = new ArrayList[n][n];\\n        \\n        //find all ways to compute         \\n        findWays();\\n        \\n        //all possible ways to compute \\n        return dp[0][n - 1];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1019945,
                "title": "dp-solution-4ms",
                "content": "```\\nclass Solution {\\n    String input;\\n    Map<String, List<Integer>> dp = new HashMap<>();\\n    public List<Integer> diffWaysToCompute(String input) {\\n        this.input = input;\\n        return helper(0, input.length() - 1);\\n    }\\n    \\n    public boolean isNumber(int s, int e) {\\n        for (int i = s; i <= e; i++)\\n            if (!Character.isDigit(input.charAt(i))) return false;\\n        return true;\\n    }\\n    \\n    public int operate(int l, int r, char op) {\\n        if (op == \\'-\\') return l - r;\\n        else if (op == \\'+\\') return l + r;\\n        else return l * r;\\n    }\\n    \\n    public List<Integer> helper(int s, int e) { \\n        List<Integer> result = new ArrayList<>();\\n        \\n        String key = s + \"#\" + e;\\n        if (dp.containsKey(key)) return dp.get(key);\\n        if (isNumber(s, e)) {\\n            result.add(Integer.parseInt(input.substring(s, e + 1)));\\n            dp.put(key, result);\\n            return result;\\n        }\\n        \\n        for (int i = s; i <= e; i++) {\\n            char ch = input.charAt(i);\\n            if (!Character.isDigit(ch)) {\\n                List<Integer> leftOp = helper(s, i - 1);\\n                List<Integer> rightOp = helper(i + 1, e);\\n                for (int l: leftOp) {\\n                    for (int r: rightOp) {\\n                        result.add(operate(l, r, ch));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        dp.put(key, result);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    String input;\\n    Map<String, List<Integer>> dp = new HashMap<>();\\n    public List<Integer> diffWaysToCompute(String input) {\\n        this.input = input;\\n        return helper(0, input.length() - 1);\\n    }\\n    \\n    public boolean isNumber(int s, int e) {\\n        for (int i = s; i <= e; i++)\\n            if (!Character.isDigit(input.charAt(i))) return false;\\n        return true;\\n    }\\n    \\n    public int operate(int l, int r, char op) {\\n        if (op == \\'-\\') return l - r;\\n        else if (op == \\'+\\') return l + r;\\n        else return l * r;\\n    }\\n    \\n    public List<Integer> helper(int s, int e) { \\n        List<Integer> result = new ArrayList<>();\\n        \\n        String key = s + \"#\" + e;\\n        if (dp.containsKey(key)) return dp.get(key);\\n        if (isNumber(s, e)) {\\n            result.add(Integer.parseInt(input.substring(s, e + 1)));\\n            dp.put(key, result);\\n            return result;\\n        }\\n        \\n        for (int i = s; i <= e; i++) {\\n            char ch = input.charAt(i);\\n            if (!Character.isDigit(ch)) {\\n                List<Integer> leftOp = helper(s, i - 1);\\n                List<Integer> rightOp = helper(i + 1, e);\\n                for (int l: leftOp) {\\n                    for (int r: rightOp) {\\n                        result.add(operate(l, r, ch));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        dp.put(key, result);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1005450,
                "title": "c-recursive-ast-memoization-with-segments-as-the-keys-explanation",
                "content": "Then one must realize that parentheses solely define the order of operations - based on that order, we can build AST. Putting parenthesis means changing the evaluation order, and that\\'s all.\\nSo the idea is to forget about parenthesis at all and consider all possible AST\\'s instead.\\n\\nFirstly, we convert the input string to the array of integers where the integer is either an operand(number) or operator(ASCII number of characters).\\nThat is done for efficiency - to avoid making substrings at each division step.\\n\\nThen for the passed segment - [s, e], where edge elements are always numbers - we consider each possible operator as the root of AST and build its subtrees recursively.\\nFor each child, we return all the possible values evaluated from the subtrees and so on.\\nProcessing both child values, we form the result values of the tree.\\n\\n```\\nclass Solution {\\n    struct pair_hash {\\n        template <typename T, typename U>\\n        std::size_t operator() (const std::pair<T, U> &rhs) const {\\n            size_t retval = std::hash<T>()(rhs.first);\\n            retval ^= std::hash<U>()(rhs.second) + 0x9e3779b9 + (retval << 6) + (retval >> 2);\\n            return retval;\\n        }\\n    };\\n    unordered_map<pair<int, int>, vector<int>, pair_hash> mp;\\n    vector<int> comp_expr(const vector<int> &nums, int s, int e) {\\n        if (s+1 == e)\\n            return vector<int>{nums[s]};\\n        auto it = mp.find({s, e});\\n        if (it != mp.end())\\n            return it->second;\\n\\n        vector<int> res;\\n        for (int i = s+1; i < e; i += 2) {\\n            vector<int> larr = comp_expr(nums, s, i);\\n            vector<int> rarr = comp_expr(nums, i+1, e);\\n            for (int x : larr)\\n                for (int y : rarr) {\\n                    if (nums[i] == \\'+\\')\\n                        res.push_back(x+y);\\n                    else if (nums[i] == \\'-\\')\\n                        res.push_back(x-y);\\n                    else\\n                        res.push_back(x*y);\\n                }\\n        }\\n        mp[{s, e}] = res;\\n        return res;\\n    }\\npublic:\\n    Solution() {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n    }\\n    vector<int> diffWaysToCompute(const string &input) {\\n        if (input.empty())\\n            return vector<int>();\\n\\n        istringstream ss(input);\\n        int n;\\n        char op;\\n        \\n        vector<int> nums;\\n        while (true) {\\n            ss >> n;\\n            nums.push_back(n);\\n            if (!(ss >> op))\\n                break;\\n            nums.push_back(op);\\n        }\\n        \\n        return comp_expr(nums, 0, nums.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Divide and Conquer",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    struct pair_hash {\\n        template <typename T, typename U>\\n        std::size_t operator() (const std::pair<T, U> &rhs) const {\\n            size_t retval = std::hash<T>()(rhs.first);\\n            retval ^= std::hash<U>()(rhs.second) + 0x9e3779b9 + (retval << 6) + (retval >> 2);\\n            return retval;\\n        }\\n    };\\n    unordered_map<pair<int, int>, vector<int>, pair_hash> mp;\\n    vector<int> comp_expr(const vector<int> &nums, int s, int e) {\\n        if (s+1 == e)\\n            return vector<int>{nums[s]};\\n        auto it = mp.find({s, e});\\n        if (it != mp.end())\\n            return it->second;\\n\\n        vector<int> res;\\n        for (int i = s+1; i < e; i += 2) {\\n            vector<int> larr = comp_expr(nums, s, i);\\n            vector<int> rarr = comp_expr(nums, i+1, e);\\n            for (int x : larr)\\n                for (int y : rarr) {\\n                    if (nums[i] == \\'+\\')\\n                        res.push_back(x+y);\\n                    else if (nums[i] == \\'-\\')\\n                        res.push_back(x-y);\\n                    else\\n                        res.push_back(x*y);\\n                }\\n        }\\n        mp[{s, e}] = res;\\n        return res;\\n    }\\npublic:\\n    Solution() {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n    }\\n    vector<int> diffWaysToCompute(const string &input) {\\n        if (input.empty())\\n            return vector<int>();\\n\\n        istringstream ss(input);\\n        int n;\\n        char op;\\n        \\n        vector<int> nums;\\n        while (true) {\\n            ss >> n;\\n            nums.push_back(n);\\n            if (!(ss >> op))\\n                break;\\n            nums.push_back(op);\\n        }\\n        \\n        return comp_expr(nums, 0, nums.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972821,
                "title": "python-divide-and-conquer-beats-95",
                "content": "```\\nclass Solution:\\n    \\n    \\n    def diffWaysToCompute(self, input: str) -> List[int]:\\n\\n        memo = {}\\n        \\n        def calc(input):\\n\\t\\t\\n\\t\\t    #memoziation\\n            if input in memo:\\n                return memo[input]\\n            ops = {\\n                \\'+\\': lambda x,y: x + y,\\n                \\'-\\': lambda x,y: x - y,\\n                \\'*\\': lambda x,y: x * y\\n            }\\n\\n            res = []\\n            for i in range(len(input)):\\n                if input[i] in ops:\\n                    \\n                    # split array into 2 parts for each operator\\n                    pre = calc(input[:i])\\n                    post = calc(input[i+1:])\\n\\n                    #recurively calculate boht sides. \\n                    # This is the same is (pre) op (post)\\n                    for j in range(len(pre)):\\n                        for k in range(len(post)):\\n                            value = ops[input[i]](int(pre[j]),int(post[k]))\\n                            res.append(value)\\n            \\n            # if there were non operators, then just return the numbers\\n            if len(res) == 0:\\n                res.append(int(input))\\n            \\n\\t\\t\\t#memoziation - save it for later\\n            memo[input] = res\\n            return res\\n        \\n        return calc(input)\\n```\\n\\ni was confusing this with a slightly similar problem of generating all variations of legal parenthesis. Guess it pays to step back and evalute individually vs. mechanically just applying previous techniques. Isnt this is still an application of Catalin Numbers? I believe so. I still need to work out the math for the time complexity. Space Complexity is O(n) where n is the length of the input as at one time no more than n layers be placed on the stack.\\n\\nThe key insite to this is dividing the array correctly when we see an operator.\\nEx. [2 - 1 -1] -> \\n\\noption 1:\\n[2] - [1-1]\\n[pre] - [post]\\n\\noption 2:\\n[2 -1] - [1]\\n[pre] - [post]\\n\\nRecusive Steps:\\nOn the way down we do the split detailed above. \\nThe stop condition is when we have no more operators on the statement.\\nOn the way back up from the recursion we do the actual calculation based on the operator we encountered.\\n\\n\\nAfter determining Recursive Algorithm. The next question is how can you speed it up? We know that we will see same string multiple times. So rather than recalculate it all the time, we store the result with a hash with the input as the key and result as the value. Whenever we encounter this input, we just return the saved value, thus saving us a recalcuation.\\n(When i added memoization to this solution, it effectively halved the time)\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    \\n    def diffWaysToCompute(self, input: str) -> List[int]:\\n\\n        memo = {}\\n        \\n        def calc(input):\\n\\t\\t\\n\\t\\t    #memoziation\\n            if input in memo:\\n                return memo[input]\\n            ops = {\\n                \\'+\\': lambda x,y: x + y,\\n                \\'-\\': lambda x,y: x - y,\\n                \\'*\\': lambda x,y: x * y\\n            }\\n\\n            res = []\\n            for i in range(len(input)):\\n                if input[i] in ops:\\n                    \\n                    # split array into 2 parts for each operator\\n                    pre = calc(input[:i])\\n                    post = calc(input[i+1:])\\n\\n                    #recurively calculate boht sides. \\n                    # This is the same is (pre) op (post)\\n                    for j in range(len(pre)):\\n                        for k in range(len(post)):\\n                            value = ops[input[i]](int(pre[j]),int(post[k]))\\n                            res.append(value)\\n            \\n            # if there were non operators, then just return the numbers\\n            if len(res) == 0:\\n                res.append(int(input))\\n            \\n\\t\\t\\t#memoziation - save it for later\\n            memo[input] = res\\n            return res\\n        \\n        return calc(input)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820237,
                "title": "c-dp-iterative-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string input) {\\n        input.push_back(\\'#\\');\\n\\t\\t/** Values contain all the operands\\n\\t\\t  * Operators contains all the operators\\n\\t\\t  * dp[{l, r}] contains all possible results for subarray [l, r] in \\'values\\' \\n\\t\\t  */\\n        vector<int> values, operators;\\n\\t\\tmap<pair<int, int>, vector<int>> dp;\\n        int start = 0;\\n        for (int i = 0; i < (int)input.length(); i++) {\\n            if (!(input[i] >= \\'0\\' && input[i] <= \\'9\\')) {\\n                int cur = 0;\\n                for (int j = start; j < i; j++)\\n                    cur = cur * 10 + (input[j] - \\'0\\');\\n                start = i + 1;\\n                values.push_back(cur);\\n                if (!(input[i] == \\'#\\')) {\\n                    if (input[i] == \\'+\\')\\n                        operators.push_back(0);\\n                    else if (input[i] == \\'-\\')\\n                        operators.push_back(1);\\n                    else operators.push_back(2);\\n                }\\n            }\\n        }\\n        for (int i = 0; i < (int)values.size(); i++) {\\n            vector<int> v;\\n            v.push_back(values[i]);\\n            dp[{i, i}] = v;\\n        }\\n        for (int l = 2; l <= (int)values.size(); l++) {\\n            for (int i = 0; i < (int)values.size() - l + 1; i++) {\\n                int j = i + l - 1;\\n                vector<int> v;\\n                for (int k = i + 1; k <= j; k++) {\\n                    int op = operators[k - 1];\\n                    for (auto it1 : dp[{i, k - 1}]) {\\n                        for (auto it2 : dp[{k, j}]) {\\n                            if (op == 0)\\n                                v.push_back(it1 + it2);\\n                            else if (op == 1)\\n                                v.push_back(it1 - it2);\\n                            else v.push_back(it1 * it2);\\n                        }\\n                    }\\n                }\\n                dp[{i, j}] = v;\\n            }\\n        }\\n        return dp[{0, (int)values.size() - 1}];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string input) {\\n        input.push_back(\\'#\\');\\n\\t\\t/** Values contain all the operands\\n\\t\\t  * Operators contains all the operators\\n\\t\\t  * dp[{l, r}] contains all possible results for subarray [l, r] in \\'values\\' \\n\\t\\t  */\\n        vector<int> values, operators;\\n\\t\\tmap<pair<int, int>, vector<int>> dp;\\n        int start = 0;\\n        for (int i = 0; i < (int)input.length(); i++) {\\n            if (!(input[i] >= \\'0\\' && input[i] <= \\'9\\')) {\\n                int cur = 0;\\n                for (int j = start; j < i; j++)\\n                    cur = cur * 10 + (input[j] - \\'0\\');\\n                start = i + 1;\\n                values.push_back(cur);\\n                if (!(input[i] == \\'#\\')) {\\n                    if (input[i] == \\'+\\')\\n                        operators.push_back(0);\\n                    else if (input[i] == \\'-\\')\\n                        operators.push_back(1);\\n                    else operators.push_back(2);\\n                }\\n            }\\n        }\\n        for (int i = 0; i < (int)values.size(); i++) {\\n            vector<int> v;\\n            v.push_back(values[i]);\\n            dp[{i, i}] = v;\\n        }\\n        for (int l = 2; l <= (int)values.size(); l++) {\\n            for (int i = 0; i < (int)values.size() - l + 1; i++) {\\n                int j = i + l - 1;\\n                vector<int> v;\\n                for (int k = i + 1; k <= j; k++) {\\n                    int op = operators[k - 1];\\n                    for (auto it1 : dp[{i, k - 1}]) {\\n                        for (auto it2 : dp[{k, j}]) {\\n                            if (op == 0)\\n                                v.push_back(it1 + it2);\\n                            else if (op == 1)\\n                                v.push_back(it1 - it2);\\n                            else v.push_back(it1 * it2);\\n                        }\\n                    }\\n                }\\n                dp[{i, j}] = v;\\n            }\\n        }\\n        return dp[{0, (int)values.size() - 1}];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773949,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string input) {\\n        vector<int> res;\\n        int n = input.size();\\n        for(int i = 0; i < n; i++){\\n            char c = input[i];\\n            if(c == \\'+\\' || c == \\'-\\' || c == \\'*\\'){\\n                vector<int> res1 = diffWaysToCompute(input.substr(0, i));\\n                vector<int> res2 = diffWaysToCompute(input.substr(i + 1));\\n                for(int n1 : res1){\\n                    for(int n2 : res2){\\n                        if(c == \\'+\\')\\n                            res.push_back(n1 + n2);\\n                        else if(c == \\'-\\')\\n                            res.push_back(n1 - n2);\\n                        else\\n                            res.push_back(n1 * n2);\\n                    }\\n                }\\n            }\\n        }\\n        if(res.size() == 0)\\n            res.push_back(stoi(input));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string input) {\\n        vector<int> res;\\n        int n = input.size();\\n        for(int i = 0; i < n; i++){\\n            char c = input[i];\\n            if(c == \\'+\\' || c == \\'-\\' || c == \\'*\\'){\\n                vector<int> res1 = diffWaysToCompute(input.substr(0, i));\\n                vector<int> res2 = diffWaysToCompute(input.substr(i + 1));\\n                for(int n1 : res1){\\n                    for(int n2 : res2){\\n                        if(c == \\'+\\')\\n                            res.push_back(n1 + n2);\\n                        else if(c == \\'-\\')\\n                            res.push_back(n1 - n2);\\n                        else\\n                            res.push_back(n1 * n2);\\n                    }\\n                }\\n            }\\n        }\\n        if(res.size() == 0)\\n            res.push_back(stoi(input));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765714,
                "title": "javascript-divideandconquer-recursive-o-n-time-o-n-space",
                "content": "```\\nvar diffWaysToCompute = function(input) {\\n    const res = [];    \\n    \\n    for (let i=0; i<input.length; i++) {\\n        let ch = input.charAt(i);\\n        if (ch==\\'+\\' || ch==\\'-\\'  || ch==\\'*\\') {\\n            let leftHalf = diffWaysToCompute(input.substring(0,i));\\n            let rightHalf = diffWaysToCompute(input.substring(i+1));\\n            \\n            for (let x of leftHalf) {\\n                for (let y of rightHalf) { \\n                    if (ch==\\'+\\')  res.push(x+y);\\n                    else if (ch==\\'-\\')  res.push(x-y);\\n                    else if (ch==\\'*\\')  res.push(x*y);\\n                } \\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    if (res.length==0) res.push(parseInt(input));\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar diffWaysToCompute = function(input) {\\n    const res = [];    \\n    \\n    for (let i=0; i<input.length; i++) {\\n        let ch = input.charAt(i);\\n        if (ch==\\'+\\' || ch==\\'-\\'  || ch==\\'*\\') {\\n            let leftHalf = diffWaysToCompute(input.substring(0,i));\\n            let rightHalf = diffWaysToCompute(input.substring(i+1));\\n            \\n            for (let x of leftHalf) {\\n                for (let y of rightHalf) { \\n                    if (ch==\\'+\\')  res.push(x+y);\\n                    else if (ch==\\'-\\')  res.push(x-y);\\n                    else if (ch==\\'*\\')  res.push(x*y);\\n                } \\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    if (res.length==0) res.push(parseInt(input));\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 764006,
                "title": "python3-dp",
                "content": "The algo here is dynamic programming. Define `fn(lo, hi)` to return the set of possible results after putting parentheses to `tokens[lo:hi]` where `tokens` is the output of pre-processing the input. Then, we can reuse such output of smaller chunks to construct bigger ones. \\n\\nTo expedite the calculation, we pre-process the input to tokenize it in the first step. After the pre-processing, the input should become a list of numbers of operators. \\n\\ntop-down implementation (28ms, 95%)\\n```\\nclass Solution:\\n    def diffWaysToCompute(self, input: str) -> List[int]:\\n        #pre-processing to tokenize input \\n        tokens = re.split(r\\'(\\\\D)\\', input)\\n        mp = {\"+\": add, \"-\": sub, \"*\": mul}\\n        for i, token in enumerate(tokens):\\n            if token.isdigit(): tokens[i] = int(token)\\n            else: tokens[i] = mp[token]\\n        \\n\\t\\t@lru_cache(None)\\n        def fn(lo, hi): \\n            \"\"\"Return possible outcomes of tokens[lo:hi]\"\"\"\\n            if lo+1 == hi: return [tokens[lo]]\\n            ans = []\\n            for mid in range(lo+1, hi, 2): \\n                ans.extend(tokens[mid](x, y) for x in fn(lo, mid) for y in fn(mid+1, hi))\\n            return ans\\n        \\n        return fn(0, len(tokens))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diffWaysToCompute(self, input: str) -> List[int]:\\n        #pre-processing to tokenize input \\n        tokens = re.split(r\\'(\\\\D)\\', input)\\n        mp = {\"+\": add, \"-\": sub, \"*\": mul}\\n        for i, token in enumerate(tokens):\\n            if token.isdigit(): tokens[i] = int(token)\\n            else: tokens[i] = mp[token]\\n        \\n\\t\\t@lru_cache(None)\\n        def fn(lo, hi): \\n            \"\"\"Return possible outcomes of tokens[lo:hi]\"\"\"\\n            if lo+1 == hi: return [tokens[lo]]\\n            ans = []\\n            for mid in range(lo+1, hi, 2): \\n                ans.extend(tokens[mid](x, y) for x in fn(lo, mid) for y in fn(mid+1, hi))\\n            return ans\\n        \\n        return fn(0, len(tokens))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749727,
                "title": "concise-java-recursive-solution-with-comments",
                "content": "For any operator in the string, if its left part has `m` results while the right has `n` results, we have `m * n` ways to add parenthesis. That\\'s the basic idea. \\n```java\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        List<Integer> res = new LinkedList<>();\\n        \\n        // find the first operator\\n\\t\\tint k = 0;\\n        while (k < input.length() && Character.isDigit(input.charAt(k))) k++;\\n        \\n        // no operator\\n\\t\\tif (k == input.length()) {\\n            res.add(Integer.parseInt(input));\\n            return res;\\n        }\\n        \\n\\t\\t// start from the current position (the first operator)\\n        for (int i = k; i < input.length(); i++) {\\n            int c = input.charAt(i);\\n            if (!Character.isDigit(c)) {\\n\\t\\t\\t    // recursively call the fucntion to find different ways for both left and right sides of current operator\\n                List<Integer> left = diffWaysToCompute(input.substring(0, i));\\n                List<Integer> right = diffWaysToCompute(input.substring(i+1));\\n                for (int m: left) {\\n                    for (int n: right) {\\n                        if (c == \\'+\\') res.add(m + n);\\n                        else if (c == \\'-\\') res.add(m - n);\\n                        else res.add(m * n);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        List<Integer> res = new LinkedList<>();\\n        \\n        // find the first operator\\n\\t\\tint k = 0;\\n        while (k < input.length() && Character.isDigit(input.charAt(k))) k++;\\n        \\n        // no operator\\n\\t\\tif (k == input.length()) {\\n            res.add(Integer.parseInt(input));\\n            return res;\\n        }\\n        \\n\\t\\t// start from the current position (the first operator)\\n        for (int i = k; i < input.length(); i++) {\\n            int c = input.charAt(i);\\n            if (!Character.isDigit(c)) {\\n\\t\\t\\t    // recursively call the fucntion to find different ways for both left and right sides of current operator\\n                List<Integer> left = diffWaysToCompute(input.substring(0, i));\\n                List<Integer> right = diffWaysToCompute(input.substring(i+1));\\n                for (int m: left) {\\n                    for (int n: right) {\\n                        if (c == \\'+\\') res.add(m + n);\\n                        else if (c == \\'-\\') res.add(m - n);\\n                        else res.add(m * n);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747134,
                "title": "easy-understand-java-solution-2ms",
                "content": "My solution is intuitive ---- just divide the original string according to the operators in the string. For example, the input string is `\"2*3-4*5\"`, we can divide it into three different subproblems (because there are exactly three operators), as shown below :\\n> subproblem_1 :  (\"2\")  *  (\"3-4 * 5\")\\n> subproblem_2:    (\"2*3\") - (\"4 * 5\")\\n> subproblem_3:   (\"2*3-4\") * (\"5\")\\n> \\nThen we can conquer these subproblems recursively. To do this, we need another two methods :\\n* `boolean hasNextOperator (String s, int start, int end)`\\nthis method determines whether there exists an operator (+ , -, * ) from  the indice `start` to the `end` in the string `s`. \\n* `int findNextOperator(String input, int start, int end)`\\nthis method returns the index of the next operator, which is used to divide the current problem and to calculate the expression.\\n\\nBesides, we need the method `calculate(..)` to obtain the value of the expression. \\nNote that, the **base case** is that the current string is just representing an integer, and we can get this integer and return it. \\n\\nHere are the code, hope it helps.\\n\\n```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        int n = input.length();\\n        return recur(input, 0, n-1);\\n    }\\n    \\n    public List<Integer> recur(String input, int low, int high) {\\n        List<Integer> result = new ArrayList<>();\\n        // base case : one integer\\n        if (!hasNextOperator(input, low, high)) {\\n            int num = 0;\\n            for (int i = low; i <= high; i++) \\n                num = num * 10 + (input.charAt(i) - \\'0\\');\\n            result.add(num);\\n            return result;\\n        }\\n        \\n        int start = low;\\n        do {\\n            List<Integer> list = new ArrayList<>();\\n            int index = findNextOperator(input, start, high);\\n            // divide and conquer the subproblem\\n            List<Integer> left = new ArrayList<>();\\n            List<Integer> right = new ArrayList<>();\\n            left = recur (input, low, index-1);\\n            right = recur (input, index + 1, high);\\n\\n            // combine the solutions to the subproblem\\n            for (int i = 0; i < left.size(); i++) {\\n                for (int j = 0; j < right.size(); j++) {\\n                    int cur = calculate (left.get(i), right.get(j), input.charAt(index));\\n                    list.add(cur);\\n                }\\n            }\\n\\n            result.addAll(list);\\n            start = index + 1;\\n        } while (start <= high && hasNextOperator(input, start, high));\\n        \\n        return result;\\n    }\\n    \\n    public int findNextOperator(String input, int start, int end) {\\n        int index = -1;\\n        for (int i = start; i <= end; i++) {\\n            if (!Character.isDigit(input.charAt(i))) {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    \\n    public boolean hasNextOperator(String input, int start, int end) {\\n        for (int i = start; i <= end; i++) \\n            if (!Character.isDigit(input.charAt(i))) return true;\\n        return false;\\n    }\\n                \\n    public int calculate (int a, int b, char c) {\\n        int result = 0;\\n        if (c == \\'+\\') \\n            result = a + b;\\n        else if (c == \\'-\\') \\n            result = a - b;\\n        else\\n            result = a * b;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        int n = input.length();\\n        return recur(input, 0, n-1);\\n    }\\n    \\n    public List<Integer> recur(String input, int low, int high) {\\n        List<Integer> result = new ArrayList<>();\\n        // base case : one integer\\n        if (!hasNextOperator(input, low, high)) {\\n            int num = 0;\\n            for (int i = low; i <= high; i++) \\n                num = num * 10 + (input.charAt(i) - \\'0\\');\\n            result.add(num);\\n            return result;\\n        }\\n        \\n        int start = low;\\n        do {\\n            List<Integer> list = new ArrayList<>();\\n            int index = findNextOperator(input, start, high);\\n            // divide and conquer the subproblem\\n            List<Integer> left = new ArrayList<>();\\n            List<Integer> right = new ArrayList<>();\\n            left = recur (input, low, index-1);\\n            right = recur (input, index + 1, high);\\n\\n            // combine the solutions to the subproblem\\n            for (int i = 0; i < left.size(); i++) {\\n                for (int j = 0; j < right.size(); j++) {\\n                    int cur = calculate (left.get(i), right.get(j), input.charAt(index));\\n                    list.add(cur);\\n                }\\n            }\\n\\n            result.addAll(list);\\n            start = index + 1;\\n        } while (start <= high && hasNextOperator(input, start, high));\\n        \\n        return result;\\n    }\\n    \\n    public int findNextOperator(String input, int start, int end) {\\n        int index = -1;\\n        for (int i = start; i <= end; i++) {\\n            if (!Character.isDigit(input.charAt(i))) {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    \\n    public boolean hasNextOperator(String input, int start, int end) {\\n        for (int i = start; i <= end; i++) \\n            if (!Character.isDigit(input.charAt(i))) return true;\\n        return false;\\n    }\\n                \\n    public int calculate (int a, int b, char c) {\\n        int result = 0;\\n        if (c == \\'+\\') \\n            result = a + b;\\n        else if (c == \\'-\\') \\n            result = a - b;\\n        else\\n            result = a * b;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 742259,
                "title": "python-divide-and-conquer-with-memo",
                "content": "```\\nclass Solution:\\n    def diffWaysToCompute(self, input: str) -> List[int]:\\n        \"\"\"\\n        :type input: str\\n        :rtype: List[int]\\n        \"\"\"\\n        memo = {}\\n        if input.isdigit():\\n            return [int(input)]\\n        if input in memo:\\n            return memo[input] \\n        res = []\\n        for i in range(len(input)):\\n            if input[i] in \"-+*\":\\n                res1 = self.diffWaysToCompute(input[:i])\\n                res2 = self.diffWaysToCompute(input[i + 1:])\\n                for left in res1:\\n                    for right in res2:\\n                        res.append(self.helper(left, right, input[i]))\\n        memo[input] = res\\n        return res\\n\\n    def helper(self, left, right, operator):\\n        if operator == \"+\":\\n            return left + right\\n        elif operator == \"-\":\\n            return left - right\\n        else:\\n            return left * right\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def diffWaysToCompute(self, input: str) -> List[int]:\\n        \"\"\"\\n        :type input: str\\n        :rtype: List[int]\\n        \"\"\"\\n        memo = {}\\n        if input.isdigit():\\n            return [int(input)]\\n        if input in memo:\\n            return memo[input] \\n        res = []\\n        for i in range(len(input)):\\n            if input[i] in \"-+*\":\\n                res1 = self.diffWaysToCompute(input[:i])\\n                res2 = self.diffWaysToCompute(input[i + 1:])\\n                for left in res1:\\n                    for right in res2:\\n                        res.append(self.helper(left, right, input[i]))\\n        memo[input] = res\\n        return res\\n\\n    def helper(self, left, right, operator):\\n        if operator == \"+\":\\n            return left + right\\n        elif operator == \"-\":\\n            return left - right\\n        else:\\n            return left * right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729913,
                "title": "recursive-solution-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string input) {\\n        vector<int> result;\\n    // base case: if the input string is a number, parse and add it to output.\\n    if (input.find(\"+\") == string::npos && input.find(\"-\") == string::npos &&\\n        input.find(\"*\") == string::npos) {\\n      result.push_back(stoi(input));\\n    } else {\\n      for (int i = 0; i < input.length(); i++) {\\n        char chr = input[i];\\n        if (!isdigit(chr)) {\\n          // break the equation here into two parts and make recursively calls\\n          vector<int> leftParts = diffWaysToCompute(input.substr(0, i));\\n          vector<int> rightParts = diffWaysToCompute(input.substr(i + 1));\\n          for (auto part1 : leftParts) {\\n            for (auto part2 : rightParts) {\\n              if (chr == \\'+\\') {\\n                result.push_back(part1 + part2);\\n              } else if (chr == \\'-\\') {\\n                result.push_back(part1 - part2);\\n              } else if (chr == \\'*\\') {\\n                result.push_back(part1 * part2);\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n    return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string input) {\\n        vector<int> result;\\n    // base case: if the input string is a number, parse and add it to output.\\n    if (input.find(\"+\") == string::npos && input.find(\"-\") == string::npos &&\\n        input.find(\"*\") == string::npos) {\\n      result.push_back(stoi(input));\\n    } else {\\n      for (int i = 0; i < input.length(); i++) {\\n        char chr = input[i];\\n        if (!isdigit(chr)) {\\n          // break the equation here into two parts and make recursively calls\\n          vector<int> leftParts = diffWaysToCompute(input.substr(0, i));\\n          vector<int> rightParts = diffWaysToCompute(input.substr(i + 1));\\n          for (auto part1 : leftParts) {\\n            for (auto part2 : rightParts) {\\n              if (chr == \\'+\\') {\\n                result.push_back(part1 + part2);\\n              } else if (chr == \\'-\\') {\\n                result.push_back(part1 - part2);\\n              } else if (chr == \\'*\\') {\\n                result.push_back(part1 * part2);\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n    return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 592575,
                "title": "simple-python-recursive",
                "content": "\\tclass Solution:\\n    def diffWaysToCompute(self, input: str) -> List[int]:\\n        \\n        def deep(string):\\n            cur = []\\n            for i, c in enumerate(string):\\n                if c in \\'+-*\\':\\n                    for a in deep(string[:i]):\\n                        for b in deep(string[i + 1:]):\\n                            cur += [a + b if c == \\'+\\' else a - b if c == \\'-\\' else a * b]\\n            if not cur:\\n                return [int(string)]\\n            else:\\n                return cur\\n            \\n        return deep(input)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def diffWaysToCompute(self, input: str) -> List[int]:\\n        \\n        def deep(string):\\n            cur = []\\n            for i, c in enumerate(string):\\n                if c in \\'+-*\\':\\n                    for a in deep(string[:i]):\\n                        for b in deep(string[i + 1:]):\\n                            cur += [a + b if c == \\'+\\' else a - b if c == \\'-\\' else a * b]\\n            if not cur:\\n                return [int(string)]\\n            else:\\n                return cur\\n            \\n        return deep(input)",
                "codeTag": "Java"
            },
            {
                "id": 530179,
                "title": "c-clear-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string input) {\\n        vector<int> result;\\n        for (int i = 0; i < input.size(); ++ i) {\\n            if (op_map.count(input[i])) {\\n                auto left = diffWaysToCompute(input.substr(0, i));\\n                auto right = diffWaysToCompute(input.substr(i + 1));\\n                for (const auto lv : left) {\\n                    for (const auto rv: right) {\\n                        result.push_back(op_map[input[i]](lv, rv));\\n                    }\\n                }\\n            }\\n        }\\n        if (!input.empty() && result.empty()) {\\n            result.push_back(stoi(input));\\n        }\\n        return result;\\n    }\\nprivate:\\n    unordered_map<char, function<int(int,int)>> op_map = {\\n            {\\'+\\', [](int a, int b) { return a + b; }},\\n            {\\'-\\', [](int a, int b) { return a - b; }},\\n            {\\'*\\', [](int a, int b) { return a * b; }},\\n        };\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> diffWaysToCompute(string input) {\\n        vector<int> result;\\n        for (int i = 0; i < input.size(); ++ i) {\\n            if (op_map.count(input[i])) {\\n                auto left = diffWaysToCompute(input.substr(0, i));\\n                auto right = diffWaysToCompute(input.substr(i + 1));\\n                for (const auto lv : left) {\\n                    for (const auto rv: right) {\\n                        result.push_back(op_map[input[i]](lv, rv));\\n                    }\\n                }\\n            }\\n        }\\n        if (!input.empty() && result.empty()) {\\n            result.push_back(stoi(input));\\n        }\\n        return result;\\n    }\\nprivate:\\n    unordered_map<char, function<int(int,int)>> op_map = {\\n            {\\'+\\', [](int a, int b) { return a + b; }},\\n            {\\'-\\', [](int a, int b) { return a - b; }},\\n            {\\'*\\', [](int a, int b) { return a * b; }},\\n        };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 514811,
                "title": "java-use-divide-and-conquer-and-result-caching",
                "content": "```\\nclass Solution {\\n    private Map<String, List<Integer>> map;\\n    public List<Integer> diffWaysToCompute(String input) {\\n        map = new HashMap<>();\\n        return helper(input, map);\\n    }\\n    \\n    private List<Integer> helper(String input, Map<String, List<Integer>> map) {\\n        if (map.containsKey(input)) return map.get(input);\\n        List<Integer> res = new ArrayList<>();\\n        for(int k = 0; k < input.length(); k++) {\\n            char c = input.charAt(k);\\n            if (c == \\'-\\' || c == \\'+\\' || c == \\'*\\') {\\n                List<Integer> left = helper(input.substring(0, k), map);\\n                List<Integer> right = helper(input.substring(k + 1), map);\\n                for (int i : left) {\\n                    for (int j : right) {\\n                        switch (c) {\\n                            case \\'+\\': \\n                                res.add(i + j);\\n                                break;\\n                            case \\'-\\': \\n                                res.add(i - j);\\n                                break;\\n                            case \\'*\\': \\n                                res.add(i * j);\\n                                break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if (res.size() == 0) res.add(Integer.valueOf(input));\\n        map.put(input, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private Map<String, List<Integer>> map;\\n    public List<Integer> diffWaysToCompute(String input) {\\n        map = new HashMap<>();\\n        return helper(input, map);\\n    }\\n    \\n    private List<Integer> helper(String input, Map<String, List<Integer>> map) {\\n        if (map.containsKey(input)) return map.get(input);\\n        List<Integer> res = new ArrayList<>();\\n        for(int k = 0; k < input.length(); k++) {\\n            char c = input.charAt(k);\\n            if (c == \\'-\\' || c == \\'+\\' || c == \\'*\\') {\\n                List<Integer> left = helper(input.substring(0, k), map);\\n                List<Integer> right = helper(input.substring(k + 1), map);\\n                for (int i : left) {\\n                    for (int j : right) {\\n                        switch (c) {\\n                            case \\'+\\': \\n                                res.add(i + j);\\n                                break;\\n                            case \\'-\\': \\n                                res.add(i - j);\\n                                break;\\n                            case \\'*\\': \\n                                res.add(i * j);\\n                                break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if (res.size() == 0) res.add(Integer.valueOf(input));\\n        map.put(input, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501931,
                "title": "java-d-c-beats-100",
                "content": "\\n```\\npublic List<Integer> diffWaysToCompute(String input) {\\n        if (input == null || input.length() == 0) {\\n            return Collections.emptyList();\\n        } else if (input.length() == 1) {\\n            return Collections.singletonList(Integer.parseInt(input));\\n        }\\n\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < input.length(); i++) {\\n            char ch = input.charAt(i);\\n            if (ch == \\'-\\' || ch == \\'+\\' || ch == \\'*\\') {\\n                List<Integer> leftValues = diffWaysToCompute(input.substring(0, i));\\n                List<Integer> rightValues = diffWaysToCompute(input.substring(i + 1));\\n\\n                for (int val1 : leftValues) {\\n                    for (int val2 : rightValues) {\\n                        res.add(calculate(val1, val2, ch));\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (res.size() == 0) {\\n            res.add(Integer.parseInt(input));\\n        }\\n        \\n        return res;\\n    }\\n\\n\\n    private int calculate(int val1, int val2, char ch) {\\n        switch (ch) {\\n            case \\'+\\':\\n                return val1 + val2;\\n            case \\'-\\':\\n                return val1 - val2;\\n            default:\\n                return val1 * val2;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "```\\npublic List<Integer> diffWaysToCompute(String input) {\\n        if (input == null || input.length() == 0) {\\n            return Collections.emptyList();\\n        } else if (input.length() == 1) {\\n            return Collections.singletonList(Integer.parseInt(input));\\n        }\\n\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < input.length(); i++) {\\n            char ch = input.charAt(i);\\n            if (ch == \\'-\\' || ch == \\'+\\' || ch == \\'*\\') {\\n                List<Integer> leftValues = diffWaysToCompute(input.substring(0, i));\\n                List<Integer> rightValues = diffWaysToCompute(input.substring(i + 1));\\n\\n                for (int val1 : leftValues) {\\n                    for (int val2 : rightValues) {\\n                        res.add(calculate(val1, val2, ch));\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (res.size() == 0) {\\n            res.add(Integer.parseInt(input));\\n        }\\n        \\n        return res;\\n    }\\n\\n\\n    private int calculate(int val1, int val2, char ch) {\\n        switch (ch) {\\n            case \\'+\\':\\n                return val1 + val2;\\n            case \\'-\\':\\n                return val1 - val2;\\n            default:\\n                return val1 * val2;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 461528,
                "title": "c-beats-100-in-time-and-space-0ms",
                "content": "Uses DP, comments to help with understanding\\n```\\nvector<int> diffWaysToCompute(string str) {\\n\\tint N = str.length(), start = 0;\\n\\tvector < int > nums;\\n\\tvector < char > ops; // ops[i] is between nums[i] and nums[i+1]\\n\\tfor (int i = 0; i != N; i++) {\\n\\t\\tchar op = str[i];\\n\\t\\tif (op == \\'+\\' || op == \\'-\\' || op == \\'\\') {\\n\\t\\t\\tnums.pushback(stoi(str.substr(start, i - start)));\\n\\t\\t\\tops.pushback(op);\\n\\t\\t\\tstart = i + 1;\\n\\t\\t}\\n\\t} // break up str into an array of just numbers, and another of just ops\\n\\tnums.pushback(stoi(str.substr(start))); // push back last num\\n\\tN = nums.size();\\n\\tvector < vector < vector < int >>> dp(N, vector < vector < int >> (N));\\n\\tfor (int cy = N; cy != 0; cy--) // cycle\\n\\t\\tfor (int i = 0; i != cy; i++) {\\n\\t\\t\\tint j = i - cy + N; // go along diagonal (NW to SE)\\n\\t\\t\\tif (i == j) {\\n\\t\\t\\t\\tdp[i][j].pushback(nums[i]);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int k = i; k != j; k++)\\n\\t\\t\\t\\tadd(dp, ops[k], i, k, j);\\n\\t\\t}\\n\\treturn dp[0][N - 1];\\n}\\n\\n    void add(vector < vector < vector < int >>> & dp, char op, int i, int k, int j) {\\n        for (int a: dp[i][k]) // for each num possible in LHS\\n            for (int b: dp[k + 1][j]) // traverse RHS as well\\n                if (op == \\'+\\') dp[i][j].pushback(a + b); // put together the two nums\\n                else if (op == \\'-\\') dp[i][j].pushback(a - b); // using appropriate op\\n        else dp[i][j].pushback(a  b);\\n    }\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvector<int> diffWaysToCompute(string str) {\\n\\tint N = str.length(), start = 0;\\n\\tvector < int > nums;\\n\\tvector < char > ops; // ops[i] is between nums[i] and nums[i+1]\\n\\tfor (int i = 0; i != N; i++) {\\n\\t\\tchar op = str[i];\\n\\t\\tif (op == \\'+\\' || op == \\'-\\' || op == \\'\\') {\\n\\t\\t\\tnums.pushback(stoi(str.substr(start, i - start)));\\n\\t\\t\\tops.pushback(op);\\n\\t\\t\\tstart = i + 1;\\n\\t\\t}\\n\\t} // break up str into an array of just numbers, and another of just ops\\n\\tnums.pushback(stoi(str.substr(start))); // push back last num\\n\\tN = nums.size();\\n\\tvector < vector < vector < int >>> dp(N, vector < vector < int >> (N));\\n\\tfor (int cy = N; cy != 0; cy--) // cycle\\n\\t\\tfor (int i = 0; i != cy; i++) {\\n\\t\\t\\tint j = i - cy + N; // go along diagonal (NW to SE)\\n\\t\\t\\tif (i == j) {\\n\\t\\t\\t\\tdp[i][j].pushback(nums[i]);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int k = i; k != j; k++)\\n\\t\\t\\t\\tadd(dp, ops[k], i, k, j);\\n\\t\\t}\\n\\treturn dp[0][N - 1];\\n}\\n\\n    void add(vector < vector < vector < int >>> & dp, char op, int i, int k, int j) {\\n        for (int a: dp[i][k]) // for each num possible in LHS\\n            for (int b: dp[k + 1][j]) // traverse RHS as well\\n                if (op == \\'+\\') dp[i][j].pushback(a + b); // put together the two nums\\n                else if (op == \\'-\\') dp[i][j].pushback(a - b); // using appropriate op\\n        else dp[i][j].pushback(a  b);\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 426320,
                "title": "python3-divide-and-conquer-recursive",
                "content": "```\\nclass Solution:\\n    def diffWaysToCompute(self, input: str) -> List[int]:\\n        if input.isdigit():\\n            return [int(input)]\\n        \\n        ans = []\\n        for i, c in enumerate(input):\\n            if not c.isdigit():\\n                l = self.diffWaysToCompute(input[0:i])\\n                r = self.diffWaysToCompute(input[i+1:])\\n                for l1 in l:\\n                    for r1 in r:\\n                        if c == \\'+\\':\\n                            ans.append(l1 + r1)\\n                        elif c == \\'-\\':\\n                            ans.append(l1 - r1)\\n                        elif c == \\'*\\':\\n                            ans.append(l1 * r1)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def diffWaysToCompute(self, input: str) -> List[int]:\\n        if input.isdigit():\\n            return [int(input)]\\n        \\n        ans = []\\n        for i, c in enumerate(input):\\n            if not c.isdigit():\\n                l = self.diffWaysToCompute(input[0:i])\\n                r = self.diffWaysToCompute(input[i+1:])\\n                for l1 in l:\\n                    for r1 in r:\\n                        if c == \\'+\\':\\n                            ans.append(l1 + r1)\\n                        elif c == \\'-\\':\\n                            ans.append(l1 - r1)\\n                        elif c == \\'*\\':\\n                            ans.append(l1 * r1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414110,
                "title": "clean-python-solution-divide-and-conquer",
                "content": "# Code\\n```python\\nclass Solution(object):\\n    def diffWaysToCompute(self, S):\\n        def calculate(operator, n1, n2):\\n            if operator==\"+\":\\n                return n1+n2\\n            elif operator==\\'-\\':\\n                return n1-n2\\n            elif operator==\\'*\\':\\n                return n1*n2\\n            else:\\n                return None\\n\\n        if S.isdigit(): return [int(S)]\\n\\n        opt = []\\n        for i in xrange(len(S)):\\n            if S[i]==\\'+\\' or S[i]==\\'-\\' or S[i]==\\'*\\':\\n                left = self.diffWaysToCompute(S[:i])\\n                right = self.diffWaysToCompute(S[i+1:])\\n                for n1 in left:\\n                    for n2 in right:\\n                        opt.append(calculate(S[i], n1, n2))\\n        return opt\\n```\\n\\n# More Resource\\nI really take time tried to make the best solution or explaination. Because I wanted to help others like me.  \\nIf you like my answer, a star on [GitHub](https://github.com/wuduhren/leetcode-python) means a lot to me. \\nhttps://github.com/wuduhren/leetcode-python\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def diffWaysToCompute(self, S):\\n        def calculate(operator, n1, n2):\\n            if operator==\"+\":\\n                return n1+n2\\n            elif operator==\\'-\\':\\n                return n1-n2\\n            elif operator==\\'*\\':\\n                return n1*n2\\n            else:\\n                return None\\n\\n        if S.isdigit(): return [int(S)]\\n\\n        opt = []\\n        for i in xrange(len(S)):\\n            if S[i]==\\'+\\' or S[i]==\\'-\\' or S[i]==\\'*\\':\\n                left = self.diffWaysToCompute(S[:i])\\n                right = self.diffWaysToCompute(S[i+1:])\\n                for n1 in left:\\n                    for n2 in right:\\n                        opt.append(calculate(S[i], n1, n2))\\n        return opt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327553,
                "title": "golang-0ms-dp",
                "content": "explaination:\\n\\tdp[i][j] = cartProd {\\n\\t\\tdp[i][k] op dp[k+1][j]\\n\\t}, i<=k<j\\n```\\nfunc parseString(input string) ([]int, []byte) {\\n\\tnums := make([]int, 0)\\n\\tops := make([]byte, 0)\\n\\tnum := 0\\n\\tfor i := 0; i < len(input); i++ {\\n\\t\\tch := input[i]\\n\\t\\tif ch >= \\'0\\' && ch <= \\'9\\' {\\n\\t\\t\\tnum = num*10 + int(ch-\\'0\\')\\n\\t\\t} else {\\n\\t\\t\\tnums = append(nums, num)\\n\\t\\t\\tnum = 0\\n\\t\\t\\tops = append(ops, ch)\\n\\t\\t}\\n\\t}\\n\\tnums = append(nums, num)\\n\\treturn nums, ops\\n}\\n\\nfunc combine(op byte, a, b int) int {\\n\\tswitch op {\\n\\tcase \\'*\\':\\n\\t\\treturn a * b\\n\\tcase \\'-\\':\\n\\t\\treturn a - b\\n\\tcase \\'+\\':\\n\\t\\treturn a + b\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc merge(op byte, a []int, b []int, c *[]int) {\\n\\tfor _, k1 := range a {\\n\\t\\tfor _, k2 := range b {\\n\\t\\t\\tk := combine(op, k1, k2)\\n\\t\\t\\t*c = append(*c, k)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc diffWaysToCompute(input string) []int {\\n\\tnums, ops := parseString(input)\\n\\tsize := len(nums)\\n\\tdp := make([][][]int, size)\\n\\n\\tfor i := 0; i < size; i++ {\\n\\t\\tdp[i] = make([][]int, size)\\n\\t\\tfor j := 0; j < size; j++ {\\n\\t\\t\\tdp[i][j] = make([]int, 0)\\n\\t\\t}\\n\\t\\tdp[i][i] = append(dp[i][i], nums[i])\\n\\t}\\n\\n\\tfor l := 2; l <= size; l++ {\\n\\t\\tfor i := 0; i < size-l+1; i++ {\\n\\t\\t\\tj := i + l - 1\\n\\t\\t\\tfor k := i; k < j; k++ {\\n\\t\\t\\t\\tmerge(ops[k], dp[i][k], dp[k+1][j], &dp[i][j])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][size-1]\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc parseString(input string) ([]int, []byte) {\\n\\tnums := make([]int, 0)\\n\\tops := make([]byte, 0)\\n\\tnum := 0\\n\\tfor i := 0; i < len(input); i++ {\\n\\t\\tch := input[i]\\n\\t\\tif ch >= \\'0\\' && ch <= \\'9\\' {\\n\\t\\t\\tnum = num*10 + int(ch-\\'0\\')\\n\\t\\t} else {\\n\\t\\t\\tnums = append(nums, num)\\n\\t\\t\\tnum = 0\\n\\t\\t\\tops = append(ops, ch)\\n\\t\\t}\\n\\t}\\n\\tnums = append(nums, num)\\n\\treturn nums, ops\\n}\\n\\nfunc combine(op byte, a, b int) int {\\n\\tswitch op {\\n\\tcase \\'*\\':\\n\\t\\treturn a * b\\n\\tcase \\'-\\':\\n\\t\\treturn a - b\\n\\tcase \\'+\\':\\n\\t\\treturn a + b\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc merge(op byte, a []int, b []int, c *[]int) {\\n\\tfor _, k1 := range a {\\n\\t\\tfor _, k2 := range b {\\n\\t\\t\\tk := combine(op, k1, k2)\\n\\t\\t\\t*c = append(*c, k)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc diffWaysToCompute(input string) []int {\\n\\tnums, ops := parseString(input)\\n\\tsize := len(nums)\\n\\tdp := make([][][]int, size)\\n\\n\\tfor i := 0; i < size; i++ {\\n\\t\\tdp[i] = make([][]int, size)\\n\\t\\tfor j := 0; j < size; j++ {\\n\\t\\t\\tdp[i][j] = make([]int, 0)\\n\\t\\t}\\n\\t\\tdp[i][i] = append(dp[i][i], nums[i])\\n\\t}\\n\\n\\tfor l := 2; l <= size; l++ {\\n\\t\\tfor i := 0; i < size-l+1; i++ {\\n\\t\\t\\tj := i + l - 1\\n\\t\\t\\tfor k := i; k < j; k++ {\\n\\t\\t\\t\\tmerge(ops[k], dp[i][k], dp[k+1][j], &dp[i][j])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][size-1]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 317135,
                "title": "backtracking-with-caching",
                "content": "Evaluate expression and return if the expression exisit in cache 5 ms faster than backtracking :D\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.cache = dict()\\n    def diffWaysToCompute(self, inp: str) -> List[int]:                \\n        res = []\\n        if inp in self.cache:\\n            return self.cache[inp]\\n        for i in range(len(inp)):\\n            if inp[i] in [\\'+\\',\\'-\\',\\'*\\']:\\n                left = self.diffWaysToCompute(inp[:i])\\n                right = self.diffWaysToCompute(inp[i+1:])\\n                for l in left:\\n                    for r in right:                        \\n                        if inp[i] == \\'+\\':\\n                            res.append( l + r)\\n                        elif inp[i] == \\'-\\':\\n                            res.append( l - r)\\n                        elif inp[i] == \\'*\\':\\n                            res.append( l * r)\\n        self.cache[inp]=res\\n        if len(res) ==0:\\n            self.cache[inp]=[int(inp)]\\n            return [int(inp)]\\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.cache = dict()\\n    def diffWaysToCompute(self, inp: str) -> List[int]:                \\n        res = []\\n        if inp in self.cache:\\n            return self.cache[inp]\\n        for i in range(len(inp)):\\n            if inp[i] in [\\'+\\',\\'-\\',\\'*\\']:\\n                left = self.diffWaysToCompute(inp[:i])\\n                right = self.diffWaysToCompute(inp[i+1:])\\n                for l in left:\\n                    for r in right:                        \\n                        if inp[i] == \\'+\\':\\n                            res.append( l + r)\\n                        elif inp[i] == \\'-\\':\\n                            res.append( l - r)\\n                        elif inp[i] == \\'*\\':\\n                            res.append( l * r)\\n        self.cache[inp]=res\\n        if len(res) ==0:\\n            self.cache[inp]=[int(inp)]\\n            return [int(inp)]\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307119,
                "title": "python-20ms-solution-divide-n-conquer",
                "content": "```\\nclass Solution(object):\\n    def diffWaysToCompute(self, input):\\n        if not input: return []\\n        if input.isdigit(): return [int(input)]\\n        mylist = []\\n        for i in range(len(input)):\\n            if input[i] not in [\\'+\\',\\'-\\',\\'*\\']: continue\\n            left = self.diffWaysToCompute(input[:i])\\n            right = self.diffWaysToCompute(input[i+1:])\\n            for l in left:\\n                for r in right:\\n                    if input[i]==\\'+\\': mylist.append(l+r)\\n                    elif input[i]==\\'-\\': mylist.append(l-r)\\n                    elif input[i]==\\'*\\': mylist.append(l*r)\\n        return mylist\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def diffWaysToCompute(self, input):\\n        if not input: return []\\n        if input.isdigit(): return [int(input)]\\n        mylist = []\\n        for i in range(len(input)):\\n            if input[i] not in [\\'+\\',\\'-\\',\\'*\\']: continue\\n            left = self.diffWaysToCompute(input[:i])\\n            right = self.diffWaysToCompute(input[i+1:])\\n            for l in left:\\n                for r in right:\\n                    if input[i]==\\'+\\': mylist.append(l+r)\\n                    elif input[i]==\\'-\\': mylist.append(l-r)\\n                    elif input[i]==\\'*\\': mylist.append(l*r)\\n        return mylist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283597,
                "title": "java-clean-solution",
                "content": "```\\nclass Solution {\\n    Map<String, List<Integer>> cache = new HashMap<>();\\n    public List<Integer> diffWaysToCompute(String input) {\\n        List<Integer> ret = new ArrayList<>();\\n        if (input == null) return ret;\\n        if (cache.containsKey(input)) return cache.get(input);\\n        boolean isAllDigit = true;\\n        for (char c: input.toCharArray()) {\\n            if (c == \\'+\\' || c == \\'-\\' || c == \\'*\\') { \\n                isAllDigit = false;\\n                break;\\n            }\\n        }\\n        if (isAllDigit) return Arrays.asList(Integer.valueOf(input));\\n        \\n        for (int i = 1; i < input.length()-1; ++i) {\\n            char c = input.charAt(i);\\n            if (c == \\'+\\' || c == \\'-\\' || c == \\'*\\') {\\n                List<Integer> lList = diffWaysToCompute(input.substring(0, i));\\n                List<Integer> rList = diffWaysToCompute(input.substring(i+1));\\n                for (Integer lNum: lList) {\\n                    for (Integer rNum: rList) {\\n                        switch (c) {\\n                            case \\'+\\': ret.add(lNum + rNum); break;\\n                            case \\'-\\': ret.add(lNum - rNum); break;\\n                            case \\'*\\': ret.add(lNum * rNum); break;\\n                            default: break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        cache.put(input, ret);\\n        return ret;\\n    }\\n}\\n```\\n\\nUsing pattern could be further cleaner but with overhead. \\n\\n```\\nimport java.util.regex.Pattern;\\n\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        List<Integer> ret = new ArrayList<>();\\n        if (input == null) return ret;\\n        if (Pattern.matches(\"\\\\\\\\d+\", input)) return Arrays.asList(Integer.valueOf(input));\\n        \\n        for (int i = 1; i < input.length()-1; ++i) {\\n            char c = input.charAt(i);\\n            if (c == \\'+\\' || c == \\'-\\' || c == \\'*\\') {\\n                for (Integer lNum: diffWaysToCompute(input.substring(0, i))) {\\n                    for (Integer rNum: diffWaysToCompute(input.substring(i+1))) {\\n                        switch (c) {\\n                            case \\'+\\': ret.add(lNum + rNum); break;\\n                            case \\'-\\': ret.add(lNum - rNum); break;\\n                            case \\'*\\': ret.add(lNum * rNum); break;\\n                            default: break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<String, List<Integer>> cache = new HashMap<>();\\n    public List<Integer> diffWaysToCompute(String input) {\\n        List<Integer> ret = new ArrayList<>();\\n        if (input == null) return ret;\\n        if (cache.containsKey(input)) return cache.get(input);\\n        boolean isAllDigit = true;\\n        for (char c: input.toCharArray()) {\\n            if (c == \\'+\\' || c == \\'-\\' || c == \\'*\\') { \\n                isAllDigit = false;\\n                break;\\n            }\\n        }\\n        if (isAllDigit) return Arrays.asList(Integer.valueOf(input));\\n        \\n        for (int i = 1; i < input.length()-1; ++i) {\\n            char c = input.charAt(i);\\n            if (c == \\'+\\' || c == \\'-\\' || c == \\'*\\') {\\n                List<Integer> lList = diffWaysToCompute(input.substring(0, i));\\n                List<Integer> rList = diffWaysToCompute(input.substring(i+1));\\n                for (Integer lNum: lList) {\\n                    for (Integer rNum: rList) {\\n                        switch (c) {\\n                            case \\'+\\': ret.add(lNum + rNum); break;\\n                            case \\'-\\': ret.add(lNum - rNum); break;\\n                            case \\'*\\': ret.add(lNum * rNum); break;\\n                            default: break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        cache.put(input, ret);\\n        return ret;\\n    }\\n}\\n```\n```\\nimport java.util.regex.Pattern;\\n\\nclass Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        List<Integer> ret = new ArrayList<>();\\n        if (input == null) return ret;\\n        if (Pattern.matches(\"\\\\\\\\d+\", input)) return Arrays.asList(Integer.valueOf(input));\\n        \\n        for (int i = 1; i < input.length()-1; ++i) {\\n            char c = input.charAt(i);\\n            if (c == \\'+\\' || c == \\'-\\' || c == \\'*\\') {\\n                for (Integer lNum: diffWaysToCompute(input.substring(0, i))) {\\n                    for (Integer rNum: diffWaysToCompute(input.substring(i+1))) {\\n                        switch (c) {\\n                            case \\'+\\': ret.add(lNum + rNum); break;\\n                            case \\'-\\': ret.add(lNum - rNum); break;\\n                            case \\'*\\': ret.add(lNum * rNum); break;\\n                            default: break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280224,
                "title": "javascript-memorization-beat-100",
                "content": "```\\nvar diffWaysToCompute = function(input) {\\n  let map = {};\\n  \\n  return recursive(input, map);\\n};\\n\\nfunction recursive(input, map) {\\n  let res = [];\\n  for(let i = 0; i < input.length; i++) {\\n    let ele = input[i];\\n    if(ele == \\'+\\' || ele == \\'-\\' || ele == \\'*\\') {\\n      let firstPart = map[input.slice(0, i)] || recursive(input.slice(0, i), map);\\n      let secondPart = map[input.slice(i + 1)] || recursive(input.slice(i + 1), map);\\n      for(let j = 0; j < firstPart.length; j++) {\\n        let first = +firstPart[j];\\n        for(let k = 0; k < secondPart.length; k++) {\\n          let second = +secondPart[k];\\n          let c = 0;\\n          switch(input[i]) {\\n            case \\'+\\': \\n              c = first + second;\\n              break;\\n            case \\'-\\':\\n              c = first - second;\\n              break;\\n            case \\'*\\':\\n              c = first * second;\\n              break;\\n          }\\n          res.push(c);\\n        }\\n      }\\n    }\\n  }\\n  \\n  if(!res.length) {\\n    res.push(input);\\n  }\\n  map[input] = res;\\n  \\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar diffWaysToCompute = function(input) {\\n  let map = {};\\n  \\n  return recursive(input, map);\\n};\\n\\nfunction recursive(input, map) {\\n  let res = [];\\n  for(let i = 0; i < input.length; i++) {\\n    let ele = input[i];\\n    if(ele == \\'+\\' || ele == \\'-\\' || ele == \\'*\\') {\\n      let firstPart = map[input.slice(0, i)] || recursive(input.slice(0, i), map);\\n      let secondPart = map[input.slice(i + 1)] || recursive(input.slice(i + 1), map);\\n      for(let j = 0; j < firstPart.length; j++) {\\n        let first = +firstPart[j];\\n        for(let k = 0; k < secondPart.length; k++) {\\n          let second = +secondPart[k];\\n          let c = 0;\\n          switch(input[i]) {\\n            case \\'+\\': \\n              c = first + second;\\n              break;\\n            case \\'-\\':\\n              c = first - second;\\n              break;\\n            case \\'*\\':\\n              c = first * second;\\n              break;\\n          }\\n          res.push(c);\\n        }\\n      }\\n    }\\n  }\\n  \\n  if(!res.length) {\\n    res.push(input);\\n  }\\n  map[input] = res;\\n  \\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 218354,
                "title": "6ms-bst-java-solution-with-complexity-n-log-n",
                "content": "Use operator as subtree\\'s root while numbers as leafs.\\n\\n```\\n    public List<Integer> diffWaysToCompute(String input) {\\n        // log(N)\\n        List<TreeNode> nodes = parse(input);\\n        // N*log(N)\\n        List<TreeNode> trees = subtrees(nodes, 0, nodes.size() - 1);\\n        // N*log(N)\\n        List<Integer> results = new LinkedList<>();\\n        for (TreeNode root : trees) {\\n            results.add(calc(root));\\n        }\\n        return results;\\n    }\\n\\n    private List<TreeNode> parse(String input) {\\n        List<TreeNode> nodes = new ArrayList<>(input.length());\\n        String num = \"\";\\n        for (int i = 0; i < input.length(); i++) {\\n            char c = input.charAt(i);\\n            if (TreeNode.isOp(c)) {\\n                if (!num.isEmpty()) {\\n                    nodes.add(TreeNode.num(Integer.parseInt(num)));\\n                    num = \"\";\\n                }\\n                nodes.add(TreeNode.op(c));\\n            } else {\\n                num += c;\\n            }\\n        }\\n        if (!num.isEmpty()) {\\n            nodes.add(TreeNode.num(Integer.parseInt(num)));\\n        }\\n        return nodes;\\n    }\\n\\n    private List<TreeNode> subtrees(List<TreeNode> nodes, int from, int to) {\\n        List<TreeNode> trees = new LinkedList<>();\\n        if (from == to) {\\n            trees.add(TreeNode.num(nodes.get(from).num));\\n            return trees;\\n        }\\n        for (int i = from; i <= to; i++) {\\n            TreeNode node = nodes.get(i);\\n            if (!node.isOp()) {\\n                continue;\\n            }\\n            List<TreeNode> leftTrees = subtrees(nodes, from, i - 1);\\n            List<TreeNode> rightTrees = subtrees(nodes, i + 1, to);\\n            // cartesian product of left/right subtrees with operator as root.\\n            for (TreeNode left : leftTrees) {\\n                for (TreeNode right : rightTrees) {\\n                    TreeNode root = TreeNode.op(node.op);\\n                    root.left = left;\\n                    root.right = right;\\n                    trees.add(root);\\n                }\\n            }\\n        }\\n        return trees;\\n    }\\n\\n    private int calc(TreeNode node) {\\n        if (node.isOp()) {\\n            int left = calc(node.left);\\n            int right = calc(node.right);\\n            switch (node.op) {\\n                case \\'+\\':\\n                    return left + right;\\n                case \\'-\\':\\n                    return left - right;\\n                case \\'*\\':\\n                    return left * right;\\n                default:\\n                    throw new IllegalArgumentException(\"Unknown operator: \" + node.op);\\n            }\\n        } else {\\n            return node.num;\\n        }\\n    }\\n\\n    public static class TreeNode {\\n        char op;\\n        int num;\\n        TreeNode left;\\n        TreeNode right;\\n\\n        static TreeNode num(int num) {\\n            TreeNode node = new TreeNode();\\n            node.num = num;\\n            return node;\\n        }\\n\\n        static TreeNode op(char op) {\\n            TreeNode node = new TreeNode();\\n            node.op = op;\\n            return node;\\n        }\\n\\n        boolean isOp() {\\n            return isOp(op);\\n        }\\n\\n        static boolean isOp(char c) {\\n            return c == \\'+\\' || c == \\'-\\' || c == \\'*\\';\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> diffWaysToCompute(String input) {\\n        // log(N)\\n        List<TreeNode> nodes = parse(input);\\n        // N*log(N)\\n        List<TreeNode> trees = subtrees(nodes, 0, nodes.size() - 1);\\n        // N*log(N)\\n        List<Integer> results = new LinkedList<>();\\n        for (TreeNode root : trees) {\\n            results.add(calc(root));\\n        }\\n        return results;\\n    }\\n\\n    private List<TreeNode> parse(String input) {\\n        List<TreeNode> nodes = new ArrayList<>(input.length());\\n        String num = \"\";\\n        for (int i = 0; i < input.length(); i++) {\\n            char c = input.charAt(i);\\n            if (TreeNode.isOp(c)) {\\n                if (!num.isEmpty()) {\\n                    nodes.add(TreeNode.num(Integer.parseInt(num)));\\n                    num = \"\";\\n                }\\n                nodes.add(TreeNode.op(c));\\n            } else {\\n                num += c;\\n            }\\n        }\\n        if (!num.isEmpty()) {\\n            nodes.add(TreeNode.num(Integer.parseInt(num)));\\n        }\\n        return nodes;\\n    }\\n\\n    private List<TreeNode> subtrees(List<TreeNode> nodes, int from, int to) {\\n        List<TreeNode> trees = new LinkedList<>();\\n        if (from == to) {\\n            trees.add(TreeNode.num(nodes.get(from).num));\\n            return trees;\\n        }\\n        for (int i = from; i <= to; i++) {\\n            TreeNode node = nodes.get(i);\\n            if (!node.isOp()) {\\n                continue;\\n            }\\n            List<TreeNode> leftTrees = subtrees(nodes, from, i - 1);\\n            List<TreeNode> rightTrees = subtrees(nodes, i + 1, to);\\n            // cartesian product of left/right subtrees with operator as root.\\n            for (TreeNode left : leftTrees) {\\n                for (TreeNode right : rightTrees) {\\n                    TreeNode root = TreeNode.op(node.op);\\n                    root.left = left;\\n                    root.right = right;\\n                    trees.add(root);\\n                }\\n            }\\n        }\\n        return trees;\\n    }\\n\\n    private int calc(TreeNode node) {\\n        if (node.isOp()) {\\n            int left = calc(node.left);\\n            int right = calc(node.right);\\n            switch (node.op) {\\n                case \\'+\\':\\n                    return left + right;\\n                case \\'-\\':\\n                    return left - right;\\n                case \\'*\\':\\n                    return left * right;\\n                default:\\n                    throw new IllegalArgumentException(\"Unknown operator: \" + node.op);\\n            }\\n        } else {\\n            return node.num;\\n        }\\n    }\\n\\n    public static class TreeNode {\\n        char op;\\n        int num;\\n        TreeNode left;\\n        TreeNode right;\\n\\n        static TreeNode num(int num) {\\n            TreeNode node = new TreeNode();\\n            node.num = num;\\n            return node;\\n        }\\n\\n        static TreeNode op(char op) {\\n            TreeNode node = new TreeNode();\\n            node.op = op;\\n            return node;\\n        }\\n\\n        boolean isOp() {\\n            return isOp(op);\\n        }\\n\\n        static boolean isOp(char c) {\\n            return c == \\'+\\' || c == \\'-\\' || c == \\'*\\';\\n        }\\n    }\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566624,
                "content": [
                    {
                        "username": "Heuit",
                        "content": "Some people wrote that Time complexity is catalan no. \\n ![image](https://assets.leetcode.com/users/images/9f316483-ff7b-47d7-a04a-0dca53a6dc67_1594908454.325404.png)\\n nth catalan no = (1/(n+1)) (2nCn) ,\\n \\n **But I can\\'t interpret these.**\\n\\n*What would be the interview answer to find the worst case time complexity before and after memoization?*\\n"
                    },
                    {
                        "username": "opeltantra",
                        "content": "From the problem description, input with negative integer seems to be possible.\\nex) -3-1, 2*-3-4*5\\nBut it turns out that all testcases use positive integer.\\nEven the test program throws exception when I put '-3-1' as an input.\\nAnd most of the solutions here doesn't consider negative input.\\nI think the input space needs to be specified in the problem description.\\nAny opinions? Please correct me if i'm wrong."
                    },
                    {
                        "username": "hpande145",
                        "content": "how will you distinguish between negetive number and \\'-\\' operator anyways"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is written that the integer values are in the range $[0, 99]$. Therefore, negative integers are not possible anymore."
                    },
                    {
                        "username": "scalacs",
                        "content": "With memoization, the time complexity is still nth Catalan, let n be the number of numbers after tokenization. To verify, simply print out the size of your solution given different length, you can see the sequence is exactly the Catalan numbers, i.e. 1, 1, 2, 5, 14, 42, 132, 429, 1430, .... \\nTherefore even with memoization, that\\'s still the amount of answer we need to compute.\\n\\nSame thing with space complexity. And you can tell why the space complexity is not O(n^2), because each result we cached is a list of different length, not a single number.\\n"
                    },
                    {
                        "username": "duhaime",
                        "content": "The problem statement says:\\n\\nGiven a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\\n\\nThe first example sequence is: `2-1-1`\\n\\nThe expected answer is:\\n((2-1)-1) = 0 \\n(2-(1-1)) = 2\\n\\nBut there is a third valid way to group the expression:\\n(2-1-1) = 0\\n\\nThe problem statement should be rewritten to indicate that only parenthetical groupings that produce distinct results should be retained. The notion of \"possible ways to group numbers and operators\" is not watertight."
                    },
                    {
                        "username": "ashish2nine",
                        "content": "I guess the third way that you have mentioned won\\'t work because when you will solve (2-1-1), at first you will have to consider two numbers and apply the operator on them, like you know in your head that the answer to (2-1-1) is 0 but when you solve it, you will either solve (2-1) first and then subtract 1 from that or you will first do (1-1) and then subtract the answer from 2, and in this way its either of the two possible cases."
                    },
                    {
                        "username": "laodasb",
                        "content": "Like the title said."
                    },
                    {
                        "username": "babaduredi",
                        "content": "This problem need not to deal with parenthesis placement literally !!"
                    },
                    {
                        "username": "catnoodle",
                        "content": "Even though it\\'s a simple check at the beginning, I feel it\\'s an important edge case to be caught in the interview."
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "can anyone give me hint about only the state of dp? Thank You"
                    },
                    {
                        "username": "forestsong",
                        "content": "Clearly many solutions didn\\'t consider test cases like `-2-1-1`"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@mudhapakamanohar](/mudhapakamanohar) suppose it is not ignored I am interested in the solution or hints"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "The numbers in the input string are in the range of [0,99]. Hence, your testcase can be ignored."
                    },
                    {
                        "username": "fanofxiaofeng",
                        "content": "for example, is \"2 - -3 \" a valid input string? If it is not, I guess the problem will be easier in some way."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "It\\'s already given in the question that all numbers in the range of [0,99]"
                    }
                ]
            },
            {
                "id": 1571483,
                "content": [
                    {
                        "username": "Heuit",
                        "content": "Some people wrote that Time complexity is catalan no. \\n ![image](https://assets.leetcode.com/users/images/9f316483-ff7b-47d7-a04a-0dca53a6dc67_1594908454.325404.png)\\n nth catalan no = (1/(n+1)) (2nCn) ,\\n \\n **But I can\\'t interpret these.**\\n\\n*What would be the interview answer to find the worst case time complexity before and after memoization?*\\n"
                    },
                    {
                        "username": "opeltantra",
                        "content": "From the problem description, input with negative integer seems to be possible.\\nex) -3-1, 2*-3-4*5\\nBut it turns out that all testcases use positive integer.\\nEven the test program throws exception when I put '-3-1' as an input.\\nAnd most of the solutions here doesn't consider negative input.\\nI think the input space needs to be specified in the problem description.\\nAny opinions? Please correct me if i'm wrong."
                    },
                    {
                        "username": "hpande145",
                        "content": "how will you distinguish between negetive number and \\'-\\' operator anyways"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is written that the integer values are in the range $[0, 99]$. Therefore, negative integers are not possible anymore."
                    },
                    {
                        "username": "scalacs",
                        "content": "With memoization, the time complexity is still nth Catalan, let n be the number of numbers after tokenization. To verify, simply print out the size of your solution given different length, you can see the sequence is exactly the Catalan numbers, i.e. 1, 1, 2, 5, 14, 42, 132, 429, 1430, .... \\nTherefore even with memoization, that\\'s still the amount of answer we need to compute.\\n\\nSame thing with space complexity. And you can tell why the space complexity is not O(n^2), because each result we cached is a list of different length, not a single number.\\n"
                    },
                    {
                        "username": "duhaime",
                        "content": "The problem statement says:\\n\\nGiven a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\\n\\nThe first example sequence is: `2-1-1`\\n\\nThe expected answer is:\\n((2-1)-1) = 0 \\n(2-(1-1)) = 2\\n\\nBut there is a third valid way to group the expression:\\n(2-1-1) = 0\\n\\nThe problem statement should be rewritten to indicate that only parenthetical groupings that produce distinct results should be retained. The notion of \"possible ways to group numbers and operators\" is not watertight."
                    },
                    {
                        "username": "ashish2nine",
                        "content": "I guess the third way that you have mentioned won\\'t work because when you will solve (2-1-1), at first you will have to consider two numbers and apply the operator on them, like you know in your head that the answer to (2-1-1) is 0 but when you solve it, you will either solve (2-1) first and then subtract 1 from that or you will first do (1-1) and then subtract the answer from 2, and in this way its either of the two possible cases."
                    },
                    {
                        "username": "laodasb",
                        "content": "Like the title said."
                    },
                    {
                        "username": "babaduredi",
                        "content": "This problem need not to deal with parenthesis placement literally !!"
                    },
                    {
                        "username": "catnoodle",
                        "content": "Even though it\\'s a simple check at the beginning, I feel it\\'s an important edge case to be caught in the interview."
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "can anyone give me hint about only the state of dp? Thank You"
                    },
                    {
                        "username": "forestsong",
                        "content": "Clearly many solutions didn\\'t consider test cases like `-2-1-1`"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@mudhapakamanohar](/mudhapakamanohar) suppose it is not ignored I am interested in the solution or hints"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "The numbers in the input string are in the range of [0,99]. Hence, your testcase can be ignored."
                    },
                    {
                        "username": "fanofxiaofeng",
                        "content": "for example, is \"2 - -3 \" a valid input string? If it is not, I guess the problem will be easier in some way."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "It\\'s already given in the question that all numbers in the range of [0,99]"
                    }
                ]
            },
            {
                "id": 1568586,
                "content": [
                    {
                        "username": "Heuit",
                        "content": "Some people wrote that Time complexity is catalan no. \\n ![image](https://assets.leetcode.com/users/images/9f316483-ff7b-47d7-a04a-0dca53a6dc67_1594908454.325404.png)\\n nth catalan no = (1/(n+1)) (2nCn) ,\\n \\n **But I can\\'t interpret these.**\\n\\n*What would be the interview answer to find the worst case time complexity before and after memoization?*\\n"
                    },
                    {
                        "username": "opeltantra",
                        "content": "From the problem description, input with negative integer seems to be possible.\\nex) -3-1, 2*-3-4*5\\nBut it turns out that all testcases use positive integer.\\nEven the test program throws exception when I put '-3-1' as an input.\\nAnd most of the solutions here doesn't consider negative input.\\nI think the input space needs to be specified in the problem description.\\nAny opinions? Please correct me if i'm wrong."
                    },
                    {
                        "username": "hpande145",
                        "content": "how will you distinguish between negetive number and \\'-\\' operator anyways"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is written that the integer values are in the range $[0, 99]$. Therefore, negative integers are not possible anymore."
                    },
                    {
                        "username": "scalacs",
                        "content": "With memoization, the time complexity is still nth Catalan, let n be the number of numbers after tokenization. To verify, simply print out the size of your solution given different length, you can see the sequence is exactly the Catalan numbers, i.e. 1, 1, 2, 5, 14, 42, 132, 429, 1430, .... \\nTherefore even with memoization, that\\'s still the amount of answer we need to compute.\\n\\nSame thing with space complexity. And you can tell why the space complexity is not O(n^2), because each result we cached is a list of different length, not a single number.\\n"
                    },
                    {
                        "username": "duhaime",
                        "content": "The problem statement says:\\n\\nGiven a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\\n\\nThe first example sequence is: `2-1-1`\\n\\nThe expected answer is:\\n((2-1)-1) = 0 \\n(2-(1-1)) = 2\\n\\nBut there is a third valid way to group the expression:\\n(2-1-1) = 0\\n\\nThe problem statement should be rewritten to indicate that only parenthetical groupings that produce distinct results should be retained. The notion of \"possible ways to group numbers and operators\" is not watertight."
                    },
                    {
                        "username": "ashish2nine",
                        "content": "I guess the third way that you have mentioned won\\'t work because when you will solve (2-1-1), at first you will have to consider two numbers and apply the operator on them, like you know in your head that the answer to (2-1-1) is 0 but when you solve it, you will either solve (2-1) first and then subtract 1 from that or you will first do (1-1) and then subtract the answer from 2, and in this way its either of the two possible cases."
                    },
                    {
                        "username": "laodasb",
                        "content": "Like the title said."
                    },
                    {
                        "username": "babaduredi",
                        "content": "This problem need not to deal with parenthesis placement literally !!"
                    },
                    {
                        "username": "catnoodle",
                        "content": "Even though it\\'s a simple check at the beginning, I feel it\\'s an important edge case to be caught in the interview."
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "can anyone give me hint about only the state of dp? Thank You"
                    },
                    {
                        "username": "forestsong",
                        "content": "Clearly many solutions didn\\'t consider test cases like `-2-1-1`"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@mudhapakamanohar](/mudhapakamanohar) suppose it is not ignored I am interested in the solution or hints"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "The numbers in the input string are in the range of [0,99]. Hence, your testcase can be ignored."
                    },
                    {
                        "username": "fanofxiaofeng",
                        "content": "for example, is \"2 - -3 \" a valid input string? If it is not, I guess the problem will be easier in some way."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "It\\'s already given in the question that all numbers in the range of [0,99]"
                    }
                ]
            },
            {
                "id": 1575799,
                "content": [
                    {
                        "username": "Heuit",
                        "content": "Some people wrote that Time complexity is catalan no. \\n ![image](https://assets.leetcode.com/users/images/9f316483-ff7b-47d7-a04a-0dca53a6dc67_1594908454.325404.png)\\n nth catalan no = (1/(n+1)) (2nCn) ,\\n \\n **But I can\\'t interpret these.**\\n\\n*What would be the interview answer to find the worst case time complexity before and after memoization?*\\n"
                    },
                    {
                        "username": "opeltantra",
                        "content": "From the problem description, input with negative integer seems to be possible.\\nex) -3-1, 2*-3-4*5\\nBut it turns out that all testcases use positive integer.\\nEven the test program throws exception when I put '-3-1' as an input.\\nAnd most of the solutions here doesn't consider negative input.\\nI think the input space needs to be specified in the problem description.\\nAny opinions? Please correct me if i'm wrong."
                    },
                    {
                        "username": "hpande145",
                        "content": "how will you distinguish between negetive number and \\'-\\' operator anyways"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is written that the integer values are in the range $[0, 99]$. Therefore, negative integers are not possible anymore."
                    },
                    {
                        "username": "scalacs",
                        "content": "With memoization, the time complexity is still nth Catalan, let n be the number of numbers after tokenization. To verify, simply print out the size of your solution given different length, you can see the sequence is exactly the Catalan numbers, i.e. 1, 1, 2, 5, 14, 42, 132, 429, 1430, .... \\nTherefore even with memoization, that\\'s still the amount of answer we need to compute.\\n\\nSame thing with space complexity. And you can tell why the space complexity is not O(n^2), because each result we cached is a list of different length, not a single number.\\n"
                    },
                    {
                        "username": "duhaime",
                        "content": "The problem statement says:\\n\\nGiven a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\\n\\nThe first example sequence is: `2-1-1`\\n\\nThe expected answer is:\\n((2-1)-1) = 0 \\n(2-(1-1)) = 2\\n\\nBut there is a third valid way to group the expression:\\n(2-1-1) = 0\\n\\nThe problem statement should be rewritten to indicate that only parenthetical groupings that produce distinct results should be retained. The notion of \"possible ways to group numbers and operators\" is not watertight."
                    },
                    {
                        "username": "ashish2nine",
                        "content": "I guess the third way that you have mentioned won\\'t work because when you will solve (2-1-1), at first you will have to consider two numbers and apply the operator on them, like you know in your head that the answer to (2-1-1) is 0 but when you solve it, you will either solve (2-1) first and then subtract 1 from that or you will first do (1-1) and then subtract the answer from 2, and in this way its either of the two possible cases."
                    },
                    {
                        "username": "laodasb",
                        "content": "Like the title said."
                    },
                    {
                        "username": "babaduredi",
                        "content": "This problem need not to deal with parenthesis placement literally !!"
                    },
                    {
                        "username": "catnoodle",
                        "content": "Even though it\\'s a simple check at the beginning, I feel it\\'s an important edge case to be caught in the interview."
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "can anyone give me hint about only the state of dp? Thank You"
                    },
                    {
                        "username": "forestsong",
                        "content": "Clearly many solutions didn\\'t consider test cases like `-2-1-1`"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@mudhapakamanohar](/mudhapakamanohar) suppose it is not ignored I am interested in the solution or hints"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "The numbers in the input string are in the range of [0,99]. Hence, your testcase can be ignored."
                    },
                    {
                        "username": "fanofxiaofeng",
                        "content": "for example, is \"2 - -3 \" a valid input string? If it is not, I guess the problem will be easier in some way."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "It\\'s already given in the question that all numbers in the range of [0,99]"
                    }
                ]
            },
            {
                "id": 1566629,
                "content": [
                    {
                        "username": "Heuit",
                        "content": "Some people wrote that Time complexity is catalan no. \\n ![image](https://assets.leetcode.com/users/images/9f316483-ff7b-47d7-a04a-0dca53a6dc67_1594908454.325404.png)\\n nth catalan no = (1/(n+1)) (2nCn) ,\\n \\n **But I can\\'t interpret these.**\\n\\n*What would be the interview answer to find the worst case time complexity before and after memoization?*\\n"
                    },
                    {
                        "username": "opeltantra",
                        "content": "From the problem description, input with negative integer seems to be possible.\\nex) -3-1, 2*-3-4*5\\nBut it turns out that all testcases use positive integer.\\nEven the test program throws exception when I put '-3-1' as an input.\\nAnd most of the solutions here doesn't consider negative input.\\nI think the input space needs to be specified in the problem description.\\nAny opinions? Please correct me if i'm wrong."
                    },
                    {
                        "username": "hpande145",
                        "content": "how will you distinguish between negetive number and \\'-\\' operator anyways"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is written that the integer values are in the range $[0, 99]$. Therefore, negative integers are not possible anymore."
                    },
                    {
                        "username": "scalacs",
                        "content": "With memoization, the time complexity is still nth Catalan, let n be the number of numbers after tokenization. To verify, simply print out the size of your solution given different length, you can see the sequence is exactly the Catalan numbers, i.e. 1, 1, 2, 5, 14, 42, 132, 429, 1430, .... \\nTherefore even with memoization, that\\'s still the amount of answer we need to compute.\\n\\nSame thing with space complexity. And you can tell why the space complexity is not O(n^2), because each result we cached is a list of different length, not a single number.\\n"
                    },
                    {
                        "username": "duhaime",
                        "content": "The problem statement says:\\n\\nGiven a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\\n\\nThe first example sequence is: `2-1-1`\\n\\nThe expected answer is:\\n((2-1)-1) = 0 \\n(2-(1-1)) = 2\\n\\nBut there is a third valid way to group the expression:\\n(2-1-1) = 0\\n\\nThe problem statement should be rewritten to indicate that only parenthetical groupings that produce distinct results should be retained. The notion of \"possible ways to group numbers and operators\" is not watertight."
                    },
                    {
                        "username": "ashish2nine",
                        "content": "I guess the third way that you have mentioned won\\'t work because when you will solve (2-1-1), at first you will have to consider two numbers and apply the operator on them, like you know in your head that the answer to (2-1-1) is 0 but when you solve it, you will either solve (2-1) first and then subtract 1 from that or you will first do (1-1) and then subtract the answer from 2, and in this way its either of the two possible cases."
                    },
                    {
                        "username": "laodasb",
                        "content": "Like the title said."
                    },
                    {
                        "username": "babaduredi",
                        "content": "This problem need not to deal with parenthesis placement literally !!"
                    },
                    {
                        "username": "catnoodle",
                        "content": "Even though it\\'s a simple check at the beginning, I feel it\\'s an important edge case to be caught in the interview."
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "can anyone give me hint about only the state of dp? Thank You"
                    },
                    {
                        "username": "forestsong",
                        "content": "Clearly many solutions didn\\'t consider test cases like `-2-1-1`"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@mudhapakamanohar](/mudhapakamanohar) suppose it is not ignored I am interested in the solution or hints"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "The numbers in the input string are in the range of [0,99]. Hence, your testcase can be ignored."
                    },
                    {
                        "username": "fanofxiaofeng",
                        "content": "for example, is \"2 - -3 \" a valid input string? If it is not, I guess the problem will be easier in some way."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "It\\'s already given in the question that all numbers in the range of [0,99]"
                    }
                ]
            },
            {
                "id": 1571484,
                "content": [
                    {
                        "username": "Heuit",
                        "content": "Some people wrote that Time complexity is catalan no. \\n ![image](https://assets.leetcode.com/users/images/9f316483-ff7b-47d7-a04a-0dca53a6dc67_1594908454.325404.png)\\n nth catalan no = (1/(n+1)) (2nCn) ,\\n \\n **But I can\\'t interpret these.**\\n\\n*What would be the interview answer to find the worst case time complexity before and after memoization?*\\n"
                    },
                    {
                        "username": "opeltantra",
                        "content": "From the problem description, input with negative integer seems to be possible.\\nex) -3-1, 2*-3-4*5\\nBut it turns out that all testcases use positive integer.\\nEven the test program throws exception when I put '-3-1' as an input.\\nAnd most of the solutions here doesn't consider negative input.\\nI think the input space needs to be specified in the problem description.\\nAny opinions? Please correct me if i'm wrong."
                    },
                    {
                        "username": "hpande145",
                        "content": "how will you distinguish between negetive number and \\'-\\' operator anyways"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is written that the integer values are in the range $[0, 99]$. Therefore, negative integers are not possible anymore."
                    },
                    {
                        "username": "scalacs",
                        "content": "With memoization, the time complexity is still nth Catalan, let n be the number of numbers after tokenization. To verify, simply print out the size of your solution given different length, you can see the sequence is exactly the Catalan numbers, i.e. 1, 1, 2, 5, 14, 42, 132, 429, 1430, .... \\nTherefore even with memoization, that\\'s still the amount of answer we need to compute.\\n\\nSame thing with space complexity. And you can tell why the space complexity is not O(n^2), because each result we cached is a list of different length, not a single number.\\n"
                    },
                    {
                        "username": "duhaime",
                        "content": "The problem statement says:\\n\\nGiven a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\\n\\nThe first example sequence is: `2-1-1`\\n\\nThe expected answer is:\\n((2-1)-1) = 0 \\n(2-(1-1)) = 2\\n\\nBut there is a third valid way to group the expression:\\n(2-1-1) = 0\\n\\nThe problem statement should be rewritten to indicate that only parenthetical groupings that produce distinct results should be retained. The notion of \"possible ways to group numbers and operators\" is not watertight."
                    },
                    {
                        "username": "ashish2nine",
                        "content": "I guess the third way that you have mentioned won\\'t work because when you will solve (2-1-1), at first you will have to consider two numbers and apply the operator on them, like you know in your head that the answer to (2-1-1) is 0 but when you solve it, you will either solve (2-1) first and then subtract 1 from that or you will first do (1-1) and then subtract the answer from 2, and in this way its either of the two possible cases."
                    },
                    {
                        "username": "laodasb",
                        "content": "Like the title said."
                    },
                    {
                        "username": "babaduredi",
                        "content": "This problem need not to deal with parenthesis placement literally !!"
                    },
                    {
                        "username": "catnoodle",
                        "content": "Even though it\\'s a simple check at the beginning, I feel it\\'s an important edge case to be caught in the interview."
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "can anyone give me hint about only the state of dp? Thank You"
                    },
                    {
                        "username": "forestsong",
                        "content": "Clearly many solutions didn\\'t consider test cases like `-2-1-1`"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@mudhapakamanohar](/mudhapakamanohar) suppose it is not ignored I am interested in the solution or hints"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "The numbers in the input string are in the range of [0,99]. Hence, your testcase can be ignored."
                    },
                    {
                        "username": "fanofxiaofeng",
                        "content": "for example, is \"2 - -3 \" a valid input string? If it is not, I guess the problem will be easier in some way."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "It\\'s already given in the question that all numbers in the range of [0,99]"
                    }
                ]
            },
            {
                "id": 1568555,
                "content": [
                    {
                        "username": "Heuit",
                        "content": "Some people wrote that Time complexity is catalan no. \\n ![image](https://assets.leetcode.com/users/images/9f316483-ff7b-47d7-a04a-0dca53a6dc67_1594908454.325404.png)\\n nth catalan no = (1/(n+1)) (2nCn) ,\\n \\n **But I can\\'t interpret these.**\\n\\n*What would be the interview answer to find the worst case time complexity before and after memoization?*\\n"
                    },
                    {
                        "username": "opeltantra",
                        "content": "From the problem description, input with negative integer seems to be possible.\\nex) -3-1, 2*-3-4*5\\nBut it turns out that all testcases use positive integer.\\nEven the test program throws exception when I put '-3-1' as an input.\\nAnd most of the solutions here doesn't consider negative input.\\nI think the input space needs to be specified in the problem description.\\nAny opinions? Please correct me if i'm wrong."
                    },
                    {
                        "username": "hpande145",
                        "content": "how will you distinguish between negetive number and \\'-\\' operator anyways"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is written that the integer values are in the range $[0, 99]$. Therefore, negative integers are not possible anymore."
                    },
                    {
                        "username": "scalacs",
                        "content": "With memoization, the time complexity is still nth Catalan, let n be the number of numbers after tokenization. To verify, simply print out the size of your solution given different length, you can see the sequence is exactly the Catalan numbers, i.e. 1, 1, 2, 5, 14, 42, 132, 429, 1430, .... \\nTherefore even with memoization, that\\'s still the amount of answer we need to compute.\\n\\nSame thing with space complexity. And you can tell why the space complexity is not O(n^2), because each result we cached is a list of different length, not a single number.\\n"
                    },
                    {
                        "username": "duhaime",
                        "content": "The problem statement says:\\n\\nGiven a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\\n\\nThe first example sequence is: `2-1-1`\\n\\nThe expected answer is:\\n((2-1)-1) = 0 \\n(2-(1-1)) = 2\\n\\nBut there is a third valid way to group the expression:\\n(2-1-1) = 0\\n\\nThe problem statement should be rewritten to indicate that only parenthetical groupings that produce distinct results should be retained. The notion of \"possible ways to group numbers and operators\" is not watertight."
                    },
                    {
                        "username": "ashish2nine",
                        "content": "I guess the third way that you have mentioned won\\'t work because when you will solve (2-1-1), at first you will have to consider two numbers and apply the operator on them, like you know in your head that the answer to (2-1-1) is 0 but when you solve it, you will either solve (2-1) first and then subtract 1 from that or you will first do (1-1) and then subtract the answer from 2, and in this way its either of the two possible cases."
                    },
                    {
                        "username": "laodasb",
                        "content": "Like the title said."
                    },
                    {
                        "username": "babaduredi",
                        "content": "This problem need not to deal with parenthesis placement literally !!"
                    },
                    {
                        "username": "catnoodle",
                        "content": "Even though it\\'s a simple check at the beginning, I feel it\\'s an important edge case to be caught in the interview."
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "can anyone give me hint about only the state of dp? Thank You"
                    },
                    {
                        "username": "forestsong",
                        "content": "Clearly many solutions didn\\'t consider test cases like `-2-1-1`"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@mudhapakamanohar](/mudhapakamanohar) suppose it is not ignored I am interested in the solution or hints"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "The numbers in the input string are in the range of [0,99]. Hence, your testcase can be ignored."
                    },
                    {
                        "username": "fanofxiaofeng",
                        "content": "for example, is \"2 - -3 \" a valid input string? If it is not, I guess the problem will be easier in some way."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "It\\'s already given in the question that all numbers in the range of [0,99]"
                    }
                ]
            },
            {
                "id": 1731057,
                "content": [
                    {
                        "username": "Heuit",
                        "content": "Some people wrote that Time complexity is catalan no. \\n ![image](https://assets.leetcode.com/users/images/9f316483-ff7b-47d7-a04a-0dca53a6dc67_1594908454.325404.png)\\n nth catalan no = (1/(n+1)) (2nCn) ,\\n \\n **But I can\\'t interpret these.**\\n\\n*What would be the interview answer to find the worst case time complexity before and after memoization?*\\n"
                    },
                    {
                        "username": "opeltantra",
                        "content": "From the problem description, input with negative integer seems to be possible.\\nex) -3-1, 2*-3-4*5\\nBut it turns out that all testcases use positive integer.\\nEven the test program throws exception when I put '-3-1' as an input.\\nAnd most of the solutions here doesn't consider negative input.\\nI think the input space needs to be specified in the problem description.\\nAny opinions? Please correct me if i'm wrong."
                    },
                    {
                        "username": "hpande145",
                        "content": "how will you distinguish between negetive number and \\'-\\' operator anyways"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is written that the integer values are in the range $[0, 99]$. Therefore, negative integers are not possible anymore."
                    },
                    {
                        "username": "scalacs",
                        "content": "With memoization, the time complexity is still nth Catalan, let n be the number of numbers after tokenization. To verify, simply print out the size of your solution given different length, you can see the sequence is exactly the Catalan numbers, i.e. 1, 1, 2, 5, 14, 42, 132, 429, 1430, .... \\nTherefore even with memoization, that\\'s still the amount of answer we need to compute.\\n\\nSame thing with space complexity. And you can tell why the space complexity is not O(n^2), because each result we cached is a list of different length, not a single number.\\n"
                    },
                    {
                        "username": "duhaime",
                        "content": "The problem statement says:\\n\\nGiven a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\\n\\nThe first example sequence is: `2-1-1`\\n\\nThe expected answer is:\\n((2-1)-1) = 0 \\n(2-(1-1)) = 2\\n\\nBut there is a third valid way to group the expression:\\n(2-1-1) = 0\\n\\nThe problem statement should be rewritten to indicate that only parenthetical groupings that produce distinct results should be retained. The notion of \"possible ways to group numbers and operators\" is not watertight."
                    },
                    {
                        "username": "ashish2nine",
                        "content": "I guess the third way that you have mentioned won\\'t work because when you will solve (2-1-1), at first you will have to consider two numbers and apply the operator on them, like you know in your head that the answer to (2-1-1) is 0 but when you solve it, you will either solve (2-1) first and then subtract 1 from that or you will first do (1-1) and then subtract the answer from 2, and in this way its either of the two possible cases."
                    },
                    {
                        "username": "laodasb",
                        "content": "Like the title said."
                    },
                    {
                        "username": "babaduredi",
                        "content": "This problem need not to deal with parenthesis placement literally !!"
                    },
                    {
                        "username": "catnoodle",
                        "content": "Even though it\\'s a simple check at the beginning, I feel it\\'s an important edge case to be caught in the interview."
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "can anyone give me hint about only the state of dp? Thank You"
                    },
                    {
                        "username": "forestsong",
                        "content": "Clearly many solutions didn\\'t consider test cases like `-2-1-1`"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@mudhapakamanohar](/mudhapakamanohar) suppose it is not ignored I am interested in the solution or hints"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "The numbers in the input string are in the range of [0,99]. Hence, your testcase can be ignored."
                    },
                    {
                        "username": "fanofxiaofeng",
                        "content": "for example, is \"2 - -3 \" a valid input string? If it is not, I guess the problem will be easier in some way."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "It\\'s already given in the question that all numbers in the range of [0,99]"
                    }
                ]
            },
            {
                "id": 1572857,
                "content": [
                    {
                        "username": "Heuit",
                        "content": "Some people wrote that Time complexity is catalan no. \\n ![image](https://assets.leetcode.com/users/images/9f316483-ff7b-47d7-a04a-0dca53a6dc67_1594908454.325404.png)\\n nth catalan no = (1/(n+1)) (2nCn) ,\\n \\n **But I can\\'t interpret these.**\\n\\n*What would be the interview answer to find the worst case time complexity before and after memoization?*\\n"
                    },
                    {
                        "username": "opeltantra",
                        "content": "From the problem description, input with negative integer seems to be possible.\\nex) -3-1, 2*-3-4*5\\nBut it turns out that all testcases use positive integer.\\nEven the test program throws exception when I put '-3-1' as an input.\\nAnd most of the solutions here doesn't consider negative input.\\nI think the input space needs to be specified in the problem description.\\nAny opinions? Please correct me if i'm wrong."
                    },
                    {
                        "username": "hpande145",
                        "content": "how will you distinguish between negetive number and \\'-\\' operator anyways"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is written that the integer values are in the range $[0, 99]$. Therefore, negative integers are not possible anymore."
                    },
                    {
                        "username": "scalacs",
                        "content": "With memoization, the time complexity is still nth Catalan, let n be the number of numbers after tokenization. To verify, simply print out the size of your solution given different length, you can see the sequence is exactly the Catalan numbers, i.e. 1, 1, 2, 5, 14, 42, 132, 429, 1430, .... \\nTherefore even with memoization, that\\'s still the amount of answer we need to compute.\\n\\nSame thing with space complexity. And you can tell why the space complexity is not O(n^2), because each result we cached is a list of different length, not a single number.\\n"
                    },
                    {
                        "username": "duhaime",
                        "content": "The problem statement says:\\n\\nGiven a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\\n\\nThe first example sequence is: `2-1-1`\\n\\nThe expected answer is:\\n((2-1)-1) = 0 \\n(2-(1-1)) = 2\\n\\nBut there is a third valid way to group the expression:\\n(2-1-1) = 0\\n\\nThe problem statement should be rewritten to indicate that only parenthetical groupings that produce distinct results should be retained. The notion of \"possible ways to group numbers and operators\" is not watertight."
                    },
                    {
                        "username": "ashish2nine",
                        "content": "I guess the third way that you have mentioned won\\'t work because when you will solve (2-1-1), at first you will have to consider two numbers and apply the operator on them, like you know in your head that the answer to (2-1-1) is 0 but when you solve it, you will either solve (2-1) first and then subtract 1 from that or you will first do (1-1) and then subtract the answer from 2, and in this way its either of the two possible cases."
                    },
                    {
                        "username": "laodasb",
                        "content": "Like the title said."
                    },
                    {
                        "username": "babaduredi",
                        "content": "This problem need not to deal with parenthesis placement literally !!"
                    },
                    {
                        "username": "catnoodle",
                        "content": "Even though it\\'s a simple check at the beginning, I feel it\\'s an important edge case to be caught in the interview."
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "can anyone give me hint about only the state of dp? Thank You"
                    },
                    {
                        "username": "forestsong",
                        "content": "Clearly many solutions didn\\'t consider test cases like `-2-1-1`"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@mudhapakamanohar](/mudhapakamanohar) suppose it is not ignored I am interested in the solution or hints"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "The numbers in the input string are in the range of [0,99]. Hence, your testcase can be ignored."
                    },
                    {
                        "username": "fanofxiaofeng",
                        "content": "for example, is \"2 - -3 \" a valid input string? If it is not, I guess the problem will be easier in some way."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "It\\'s already given in the question that all numbers in the range of [0,99]"
                    }
                ]
            },
            {
                "id": 1571485,
                "content": [
                    {
                        "username": "Heuit",
                        "content": "Some people wrote that Time complexity is catalan no. \\n ![image](https://assets.leetcode.com/users/images/9f316483-ff7b-47d7-a04a-0dca53a6dc67_1594908454.325404.png)\\n nth catalan no = (1/(n+1)) (2nCn) ,\\n \\n **But I can\\'t interpret these.**\\n\\n*What would be the interview answer to find the worst case time complexity before and after memoization?*\\n"
                    },
                    {
                        "username": "opeltantra",
                        "content": "From the problem description, input with negative integer seems to be possible.\\nex) -3-1, 2*-3-4*5\\nBut it turns out that all testcases use positive integer.\\nEven the test program throws exception when I put '-3-1' as an input.\\nAnd most of the solutions here doesn't consider negative input.\\nI think the input space needs to be specified in the problem description.\\nAny opinions? Please correct me if i'm wrong."
                    },
                    {
                        "username": "hpande145",
                        "content": "how will you distinguish between negetive number and \\'-\\' operator anyways"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is written that the integer values are in the range $[0, 99]$. Therefore, negative integers are not possible anymore."
                    },
                    {
                        "username": "scalacs",
                        "content": "With memoization, the time complexity is still nth Catalan, let n be the number of numbers after tokenization. To verify, simply print out the size of your solution given different length, you can see the sequence is exactly the Catalan numbers, i.e. 1, 1, 2, 5, 14, 42, 132, 429, 1430, .... \\nTherefore even with memoization, that\\'s still the amount of answer we need to compute.\\n\\nSame thing with space complexity. And you can tell why the space complexity is not O(n^2), because each result we cached is a list of different length, not a single number.\\n"
                    },
                    {
                        "username": "duhaime",
                        "content": "The problem statement says:\\n\\nGiven a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\\n\\nThe first example sequence is: `2-1-1`\\n\\nThe expected answer is:\\n((2-1)-1) = 0 \\n(2-(1-1)) = 2\\n\\nBut there is a third valid way to group the expression:\\n(2-1-1) = 0\\n\\nThe problem statement should be rewritten to indicate that only parenthetical groupings that produce distinct results should be retained. The notion of \"possible ways to group numbers and operators\" is not watertight."
                    },
                    {
                        "username": "ashish2nine",
                        "content": "I guess the third way that you have mentioned won\\'t work because when you will solve (2-1-1), at first you will have to consider two numbers and apply the operator on them, like you know in your head that the answer to (2-1-1) is 0 but when you solve it, you will either solve (2-1) first and then subtract 1 from that or you will first do (1-1) and then subtract the answer from 2, and in this way its either of the two possible cases."
                    },
                    {
                        "username": "laodasb",
                        "content": "Like the title said."
                    },
                    {
                        "username": "babaduredi",
                        "content": "This problem need not to deal with parenthesis placement literally !!"
                    },
                    {
                        "username": "catnoodle",
                        "content": "Even though it\\'s a simple check at the beginning, I feel it\\'s an important edge case to be caught in the interview."
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "can anyone give me hint about only the state of dp? Thank You"
                    },
                    {
                        "username": "forestsong",
                        "content": "Clearly many solutions didn\\'t consider test cases like `-2-1-1`"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@mudhapakamanohar](/mudhapakamanohar) suppose it is not ignored I am interested in the solution or hints"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "The numbers in the input string are in the range of [0,99]. Hence, your testcase can be ignored."
                    },
                    {
                        "username": "fanofxiaofeng",
                        "content": "for example, is \"2 - -3 \" a valid input string? If it is not, I guess the problem will be easier in some way."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "It\\'s already given in the question that all numbers in the range of [0,99]"
                    }
                ]
            },
            {
                "id": 1566624,
                "content": [
                    {
                        "username": "Heuit",
                        "content": "Some people wrote that Time complexity is catalan no. \\n ![image](https://assets.leetcode.com/users/images/9f316483-ff7b-47d7-a04a-0dca53a6dc67_1594908454.325404.png)\\n nth catalan no = (1/(n+1)) (2nCn) ,\\n \\n **But I can\\'t interpret these.**\\n\\n*What would be the interview answer to find the worst case time complexity before and after memoization?*\\n"
                    },
                    {
                        "username": "opeltantra",
                        "content": "From the problem description, input with negative integer seems to be possible.\\nex) -3-1, 2*-3-4*5\\nBut it turns out that all testcases use positive integer.\\nEven the test program throws exception when I put '-3-1' as an input.\\nAnd most of the solutions here doesn't consider negative input.\\nI think the input space needs to be specified in the problem description.\\nAny opinions? Please correct me if i'm wrong."
                    },
                    {
                        "username": "hpande145",
                        "content": "how will you distinguish between negetive number and \\'-\\' operator anyways"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is written that the integer values are in the range $[0, 99]$. Therefore, negative integers are not possible anymore."
                    },
                    {
                        "username": "scalacs",
                        "content": "With memoization, the time complexity is still nth Catalan, let n be the number of numbers after tokenization. To verify, simply print out the size of your solution given different length, you can see the sequence is exactly the Catalan numbers, i.e. 1, 1, 2, 5, 14, 42, 132, 429, 1430, .... \\nTherefore even with memoization, that\\'s still the amount of answer we need to compute.\\n\\nSame thing with space complexity. And you can tell why the space complexity is not O(n^2), because each result we cached is a list of different length, not a single number.\\n"
                    },
                    {
                        "username": "duhaime",
                        "content": "The problem statement says:\\n\\nGiven a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\\n\\nThe first example sequence is: `2-1-1`\\n\\nThe expected answer is:\\n((2-1)-1) = 0 \\n(2-(1-1)) = 2\\n\\nBut there is a third valid way to group the expression:\\n(2-1-1) = 0\\n\\nThe problem statement should be rewritten to indicate that only parenthetical groupings that produce distinct results should be retained. The notion of \"possible ways to group numbers and operators\" is not watertight."
                    },
                    {
                        "username": "ashish2nine",
                        "content": "I guess the third way that you have mentioned won\\'t work because when you will solve (2-1-1), at first you will have to consider two numbers and apply the operator on them, like you know in your head that the answer to (2-1-1) is 0 but when you solve it, you will either solve (2-1) first and then subtract 1 from that or you will first do (1-1) and then subtract the answer from 2, and in this way its either of the two possible cases."
                    },
                    {
                        "username": "laodasb",
                        "content": "Like the title said."
                    },
                    {
                        "username": "babaduredi",
                        "content": "This problem need not to deal with parenthesis placement literally !!"
                    },
                    {
                        "username": "catnoodle",
                        "content": "Even though it\\'s a simple check at the beginning, I feel it\\'s an important edge case to be caught in the interview."
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "can anyone give me hint about only the state of dp? Thank You"
                    },
                    {
                        "username": "forestsong",
                        "content": "Clearly many solutions didn\\'t consider test cases like `-2-1-1`"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@mudhapakamanohar](/mudhapakamanohar) suppose it is not ignored I am interested in the solution or hints"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "The numbers in the input string are in the range of [0,99]. Hence, your testcase can be ignored."
                    },
                    {
                        "username": "fanofxiaofeng",
                        "content": "for example, is \"2 - -3 \" a valid input string? If it is not, I guess the problem will be easier in some way."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "It\\'s already given in the question that all numbers in the range of [0,99]"
                    }
                ]
            },
            {
                "id": 1571483,
                "content": [
                    {
                        "username": "Heuit",
                        "content": "Some people wrote that Time complexity is catalan no. \\n ![image](https://assets.leetcode.com/users/images/9f316483-ff7b-47d7-a04a-0dca53a6dc67_1594908454.325404.png)\\n nth catalan no = (1/(n+1)) (2nCn) ,\\n \\n **But I can\\'t interpret these.**\\n\\n*What would be the interview answer to find the worst case time complexity before and after memoization?*\\n"
                    },
                    {
                        "username": "opeltantra",
                        "content": "From the problem description, input with negative integer seems to be possible.\\nex) -3-1, 2*-3-4*5\\nBut it turns out that all testcases use positive integer.\\nEven the test program throws exception when I put '-3-1' as an input.\\nAnd most of the solutions here doesn't consider negative input.\\nI think the input space needs to be specified in the problem description.\\nAny opinions? Please correct me if i'm wrong."
                    },
                    {
                        "username": "hpande145",
                        "content": "how will you distinguish between negetive number and \\'-\\' operator anyways"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is written that the integer values are in the range $[0, 99]$. Therefore, negative integers are not possible anymore."
                    },
                    {
                        "username": "scalacs",
                        "content": "With memoization, the time complexity is still nth Catalan, let n be the number of numbers after tokenization. To verify, simply print out the size of your solution given different length, you can see the sequence is exactly the Catalan numbers, i.e. 1, 1, 2, 5, 14, 42, 132, 429, 1430, .... \\nTherefore even with memoization, that\\'s still the amount of answer we need to compute.\\n\\nSame thing with space complexity. And you can tell why the space complexity is not O(n^2), because each result we cached is a list of different length, not a single number.\\n"
                    },
                    {
                        "username": "duhaime",
                        "content": "The problem statement says:\\n\\nGiven a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\\n\\nThe first example sequence is: `2-1-1`\\n\\nThe expected answer is:\\n((2-1)-1) = 0 \\n(2-(1-1)) = 2\\n\\nBut there is a third valid way to group the expression:\\n(2-1-1) = 0\\n\\nThe problem statement should be rewritten to indicate that only parenthetical groupings that produce distinct results should be retained. The notion of \"possible ways to group numbers and operators\" is not watertight."
                    },
                    {
                        "username": "ashish2nine",
                        "content": "I guess the third way that you have mentioned won\\'t work because when you will solve (2-1-1), at first you will have to consider two numbers and apply the operator on them, like you know in your head that the answer to (2-1-1) is 0 but when you solve it, you will either solve (2-1) first and then subtract 1 from that or you will first do (1-1) and then subtract the answer from 2, and in this way its either of the two possible cases."
                    },
                    {
                        "username": "laodasb",
                        "content": "Like the title said."
                    },
                    {
                        "username": "babaduredi",
                        "content": "This problem need not to deal with parenthesis placement literally !!"
                    },
                    {
                        "username": "catnoodle",
                        "content": "Even though it\\'s a simple check at the beginning, I feel it\\'s an important edge case to be caught in the interview."
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "can anyone give me hint about only the state of dp? Thank You"
                    },
                    {
                        "username": "forestsong",
                        "content": "Clearly many solutions didn\\'t consider test cases like `-2-1-1`"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@mudhapakamanohar](/mudhapakamanohar) suppose it is not ignored I am interested in the solution or hints"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "The numbers in the input string are in the range of [0,99]. Hence, your testcase can be ignored."
                    },
                    {
                        "username": "fanofxiaofeng",
                        "content": "for example, is \"2 - -3 \" a valid input string? If it is not, I guess the problem will be easier in some way."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "It\\'s already given in the question that all numbers in the range of [0,99]"
                    }
                ]
            },
            {
                "id": 1568586,
                "content": [
                    {
                        "username": "Heuit",
                        "content": "Some people wrote that Time complexity is catalan no. \\n ![image](https://assets.leetcode.com/users/images/9f316483-ff7b-47d7-a04a-0dca53a6dc67_1594908454.325404.png)\\n nth catalan no = (1/(n+1)) (2nCn) ,\\n \\n **But I can\\'t interpret these.**\\n\\n*What would be the interview answer to find the worst case time complexity before and after memoization?*\\n"
                    },
                    {
                        "username": "opeltantra",
                        "content": "From the problem description, input with negative integer seems to be possible.\\nex) -3-1, 2*-3-4*5\\nBut it turns out that all testcases use positive integer.\\nEven the test program throws exception when I put '-3-1' as an input.\\nAnd most of the solutions here doesn't consider negative input.\\nI think the input space needs to be specified in the problem description.\\nAny opinions? Please correct me if i'm wrong."
                    },
                    {
                        "username": "hpande145",
                        "content": "how will you distinguish between negetive number and \\'-\\' operator anyways"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is written that the integer values are in the range $[0, 99]$. Therefore, negative integers are not possible anymore."
                    },
                    {
                        "username": "scalacs",
                        "content": "With memoization, the time complexity is still nth Catalan, let n be the number of numbers after tokenization. To verify, simply print out the size of your solution given different length, you can see the sequence is exactly the Catalan numbers, i.e. 1, 1, 2, 5, 14, 42, 132, 429, 1430, .... \\nTherefore even with memoization, that\\'s still the amount of answer we need to compute.\\n\\nSame thing with space complexity. And you can tell why the space complexity is not O(n^2), because each result we cached is a list of different length, not a single number.\\n"
                    },
                    {
                        "username": "duhaime",
                        "content": "The problem statement says:\\n\\nGiven a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\\n\\nThe first example sequence is: `2-1-1`\\n\\nThe expected answer is:\\n((2-1)-1) = 0 \\n(2-(1-1)) = 2\\n\\nBut there is a third valid way to group the expression:\\n(2-1-1) = 0\\n\\nThe problem statement should be rewritten to indicate that only parenthetical groupings that produce distinct results should be retained. The notion of \"possible ways to group numbers and operators\" is not watertight."
                    },
                    {
                        "username": "ashish2nine",
                        "content": "I guess the third way that you have mentioned won\\'t work because when you will solve (2-1-1), at first you will have to consider two numbers and apply the operator on them, like you know in your head that the answer to (2-1-1) is 0 but when you solve it, you will either solve (2-1) first and then subtract 1 from that or you will first do (1-1) and then subtract the answer from 2, and in this way its either of the two possible cases."
                    },
                    {
                        "username": "laodasb",
                        "content": "Like the title said."
                    },
                    {
                        "username": "babaduredi",
                        "content": "This problem need not to deal with parenthesis placement literally !!"
                    },
                    {
                        "username": "catnoodle",
                        "content": "Even though it\\'s a simple check at the beginning, I feel it\\'s an important edge case to be caught in the interview."
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "can anyone give me hint about only the state of dp? Thank You"
                    },
                    {
                        "username": "forestsong",
                        "content": "Clearly many solutions didn\\'t consider test cases like `-2-1-1`"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@mudhapakamanohar](/mudhapakamanohar) suppose it is not ignored I am interested in the solution or hints"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "The numbers in the input string are in the range of [0,99]. Hence, your testcase can be ignored."
                    },
                    {
                        "username": "fanofxiaofeng",
                        "content": "for example, is \"2 - -3 \" a valid input string? If it is not, I guess the problem will be easier in some way."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "It\\'s already given in the question that all numbers in the range of [0,99]"
                    }
                ]
            },
            {
                "id": 1575799,
                "content": [
                    {
                        "username": "Heuit",
                        "content": "Some people wrote that Time complexity is catalan no. \\n ![image](https://assets.leetcode.com/users/images/9f316483-ff7b-47d7-a04a-0dca53a6dc67_1594908454.325404.png)\\n nth catalan no = (1/(n+1)) (2nCn) ,\\n \\n **But I can\\'t interpret these.**\\n\\n*What would be the interview answer to find the worst case time complexity before and after memoization?*\\n"
                    },
                    {
                        "username": "opeltantra",
                        "content": "From the problem description, input with negative integer seems to be possible.\\nex) -3-1, 2*-3-4*5\\nBut it turns out that all testcases use positive integer.\\nEven the test program throws exception when I put '-3-1' as an input.\\nAnd most of the solutions here doesn't consider negative input.\\nI think the input space needs to be specified in the problem description.\\nAny opinions? Please correct me if i'm wrong."
                    },
                    {
                        "username": "hpande145",
                        "content": "how will you distinguish between negetive number and \\'-\\' operator anyways"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is written that the integer values are in the range $[0, 99]$. Therefore, negative integers are not possible anymore."
                    },
                    {
                        "username": "scalacs",
                        "content": "With memoization, the time complexity is still nth Catalan, let n be the number of numbers after tokenization. To verify, simply print out the size of your solution given different length, you can see the sequence is exactly the Catalan numbers, i.e. 1, 1, 2, 5, 14, 42, 132, 429, 1430, .... \\nTherefore even with memoization, that\\'s still the amount of answer we need to compute.\\n\\nSame thing with space complexity. And you can tell why the space complexity is not O(n^2), because each result we cached is a list of different length, not a single number.\\n"
                    },
                    {
                        "username": "duhaime",
                        "content": "The problem statement says:\\n\\nGiven a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\\n\\nThe first example sequence is: `2-1-1`\\n\\nThe expected answer is:\\n((2-1)-1) = 0 \\n(2-(1-1)) = 2\\n\\nBut there is a third valid way to group the expression:\\n(2-1-1) = 0\\n\\nThe problem statement should be rewritten to indicate that only parenthetical groupings that produce distinct results should be retained. The notion of \"possible ways to group numbers and operators\" is not watertight."
                    },
                    {
                        "username": "ashish2nine",
                        "content": "I guess the third way that you have mentioned won\\'t work because when you will solve (2-1-1), at first you will have to consider two numbers and apply the operator on them, like you know in your head that the answer to (2-1-1) is 0 but when you solve it, you will either solve (2-1) first and then subtract 1 from that or you will first do (1-1) and then subtract the answer from 2, and in this way its either of the two possible cases."
                    },
                    {
                        "username": "laodasb",
                        "content": "Like the title said."
                    },
                    {
                        "username": "babaduredi",
                        "content": "This problem need not to deal with parenthesis placement literally !!"
                    },
                    {
                        "username": "catnoodle",
                        "content": "Even though it\\'s a simple check at the beginning, I feel it\\'s an important edge case to be caught in the interview."
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "can anyone give me hint about only the state of dp? Thank You"
                    },
                    {
                        "username": "forestsong",
                        "content": "Clearly many solutions didn\\'t consider test cases like `-2-1-1`"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@mudhapakamanohar](/mudhapakamanohar) suppose it is not ignored I am interested in the solution or hints"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "The numbers in the input string are in the range of [0,99]. Hence, your testcase can be ignored."
                    },
                    {
                        "username": "fanofxiaofeng",
                        "content": "for example, is \"2 - -3 \" a valid input string? If it is not, I guess the problem will be easier in some way."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "It\\'s already given in the question that all numbers in the range of [0,99]"
                    }
                ]
            },
            {
                "id": 1566629,
                "content": [
                    {
                        "username": "Heuit",
                        "content": "Some people wrote that Time complexity is catalan no. \\n ![image](https://assets.leetcode.com/users/images/9f316483-ff7b-47d7-a04a-0dca53a6dc67_1594908454.325404.png)\\n nth catalan no = (1/(n+1)) (2nCn) ,\\n \\n **But I can\\'t interpret these.**\\n\\n*What would be the interview answer to find the worst case time complexity before and after memoization?*\\n"
                    },
                    {
                        "username": "opeltantra",
                        "content": "From the problem description, input with negative integer seems to be possible.\\nex) -3-1, 2*-3-4*5\\nBut it turns out that all testcases use positive integer.\\nEven the test program throws exception when I put '-3-1' as an input.\\nAnd most of the solutions here doesn't consider negative input.\\nI think the input space needs to be specified in the problem description.\\nAny opinions? Please correct me if i'm wrong."
                    },
                    {
                        "username": "hpande145",
                        "content": "how will you distinguish between negetive number and \\'-\\' operator anyways"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is written that the integer values are in the range $[0, 99]$. Therefore, negative integers are not possible anymore."
                    },
                    {
                        "username": "scalacs",
                        "content": "With memoization, the time complexity is still nth Catalan, let n be the number of numbers after tokenization. To verify, simply print out the size of your solution given different length, you can see the sequence is exactly the Catalan numbers, i.e. 1, 1, 2, 5, 14, 42, 132, 429, 1430, .... \\nTherefore even with memoization, that\\'s still the amount of answer we need to compute.\\n\\nSame thing with space complexity. And you can tell why the space complexity is not O(n^2), because each result we cached is a list of different length, not a single number.\\n"
                    },
                    {
                        "username": "duhaime",
                        "content": "The problem statement says:\\n\\nGiven a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\\n\\nThe first example sequence is: `2-1-1`\\n\\nThe expected answer is:\\n((2-1)-1) = 0 \\n(2-(1-1)) = 2\\n\\nBut there is a third valid way to group the expression:\\n(2-1-1) = 0\\n\\nThe problem statement should be rewritten to indicate that only parenthetical groupings that produce distinct results should be retained. The notion of \"possible ways to group numbers and operators\" is not watertight."
                    },
                    {
                        "username": "ashish2nine",
                        "content": "I guess the third way that you have mentioned won\\'t work because when you will solve (2-1-1), at first you will have to consider two numbers and apply the operator on them, like you know in your head that the answer to (2-1-1) is 0 but when you solve it, you will either solve (2-1) first and then subtract 1 from that or you will first do (1-1) and then subtract the answer from 2, and in this way its either of the two possible cases."
                    },
                    {
                        "username": "laodasb",
                        "content": "Like the title said."
                    },
                    {
                        "username": "babaduredi",
                        "content": "This problem need not to deal with parenthesis placement literally !!"
                    },
                    {
                        "username": "catnoodle",
                        "content": "Even though it\\'s a simple check at the beginning, I feel it\\'s an important edge case to be caught in the interview."
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "can anyone give me hint about only the state of dp? Thank You"
                    },
                    {
                        "username": "forestsong",
                        "content": "Clearly many solutions didn\\'t consider test cases like `-2-1-1`"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@mudhapakamanohar](/mudhapakamanohar) suppose it is not ignored I am interested in the solution or hints"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "The numbers in the input string are in the range of [0,99]. Hence, your testcase can be ignored."
                    },
                    {
                        "username": "fanofxiaofeng",
                        "content": "for example, is \"2 - -3 \" a valid input string? If it is not, I guess the problem will be easier in some way."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "It\\'s already given in the question that all numbers in the range of [0,99]"
                    }
                ]
            },
            {
                "id": 1571484,
                "content": [
                    {
                        "username": "Heuit",
                        "content": "Some people wrote that Time complexity is catalan no. \\n ![image](https://assets.leetcode.com/users/images/9f316483-ff7b-47d7-a04a-0dca53a6dc67_1594908454.325404.png)\\n nth catalan no = (1/(n+1)) (2nCn) ,\\n \\n **But I can\\'t interpret these.**\\n\\n*What would be the interview answer to find the worst case time complexity before and after memoization?*\\n"
                    },
                    {
                        "username": "opeltantra",
                        "content": "From the problem description, input with negative integer seems to be possible.\\nex) -3-1, 2*-3-4*5\\nBut it turns out that all testcases use positive integer.\\nEven the test program throws exception when I put '-3-1' as an input.\\nAnd most of the solutions here doesn't consider negative input.\\nI think the input space needs to be specified in the problem description.\\nAny opinions? Please correct me if i'm wrong."
                    },
                    {
                        "username": "hpande145",
                        "content": "how will you distinguish between negetive number and \\'-\\' operator anyways"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is written that the integer values are in the range $[0, 99]$. Therefore, negative integers are not possible anymore."
                    },
                    {
                        "username": "scalacs",
                        "content": "With memoization, the time complexity is still nth Catalan, let n be the number of numbers after tokenization. To verify, simply print out the size of your solution given different length, you can see the sequence is exactly the Catalan numbers, i.e. 1, 1, 2, 5, 14, 42, 132, 429, 1430, .... \\nTherefore even with memoization, that\\'s still the amount of answer we need to compute.\\n\\nSame thing with space complexity. And you can tell why the space complexity is not O(n^2), because each result we cached is a list of different length, not a single number.\\n"
                    },
                    {
                        "username": "duhaime",
                        "content": "The problem statement says:\\n\\nGiven a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\\n\\nThe first example sequence is: `2-1-1`\\n\\nThe expected answer is:\\n((2-1)-1) = 0 \\n(2-(1-1)) = 2\\n\\nBut there is a third valid way to group the expression:\\n(2-1-1) = 0\\n\\nThe problem statement should be rewritten to indicate that only parenthetical groupings that produce distinct results should be retained. The notion of \"possible ways to group numbers and operators\" is not watertight."
                    },
                    {
                        "username": "ashish2nine",
                        "content": "I guess the third way that you have mentioned won\\'t work because when you will solve (2-1-1), at first you will have to consider two numbers and apply the operator on them, like you know in your head that the answer to (2-1-1) is 0 but when you solve it, you will either solve (2-1) first and then subtract 1 from that or you will first do (1-1) and then subtract the answer from 2, and in this way its either of the two possible cases."
                    },
                    {
                        "username": "laodasb",
                        "content": "Like the title said."
                    },
                    {
                        "username": "babaduredi",
                        "content": "This problem need not to deal with parenthesis placement literally !!"
                    },
                    {
                        "username": "catnoodle",
                        "content": "Even though it\\'s a simple check at the beginning, I feel it\\'s an important edge case to be caught in the interview."
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "can anyone give me hint about only the state of dp? Thank You"
                    },
                    {
                        "username": "forestsong",
                        "content": "Clearly many solutions didn\\'t consider test cases like `-2-1-1`"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@mudhapakamanohar](/mudhapakamanohar) suppose it is not ignored I am interested in the solution or hints"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "The numbers in the input string are in the range of [0,99]. Hence, your testcase can be ignored."
                    },
                    {
                        "username": "fanofxiaofeng",
                        "content": "for example, is \"2 - -3 \" a valid input string? If it is not, I guess the problem will be easier in some way."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "It\\'s already given in the question that all numbers in the range of [0,99]"
                    }
                ]
            },
            {
                "id": 1568555,
                "content": [
                    {
                        "username": "Heuit",
                        "content": "Some people wrote that Time complexity is catalan no. \\n ![image](https://assets.leetcode.com/users/images/9f316483-ff7b-47d7-a04a-0dca53a6dc67_1594908454.325404.png)\\n nth catalan no = (1/(n+1)) (2nCn) ,\\n \\n **But I can\\'t interpret these.**\\n\\n*What would be the interview answer to find the worst case time complexity before and after memoization?*\\n"
                    },
                    {
                        "username": "opeltantra",
                        "content": "From the problem description, input with negative integer seems to be possible.\\nex) -3-1, 2*-3-4*5\\nBut it turns out that all testcases use positive integer.\\nEven the test program throws exception when I put '-3-1' as an input.\\nAnd most of the solutions here doesn't consider negative input.\\nI think the input space needs to be specified in the problem description.\\nAny opinions? Please correct me if i'm wrong."
                    },
                    {
                        "username": "hpande145",
                        "content": "how will you distinguish between negetive number and \\'-\\' operator anyways"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is written that the integer values are in the range $[0, 99]$. Therefore, negative integers are not possible anymore."
                    },
                    {
                        "username": "scalacs",
                        "content": "With memoization, the time complexity is still nth Catalan, let n be the number of numbers after tokenization. To verify, simply print out the size of your solution given different length, you can see the sequence is exactly the Catalan numbers, i.e. 1, 1, 2, 5, 14, 42, 132, 429, 1430, .... \\nTherefore even with memoization, that\\'s still the amount of answer we need to compute.\\n\\nSame thing with space complexity. And you can tell why the space complexity is not O(n^2), because each result we cached is a list of different length, not a single number.\\n"
                    },
                    {
                        "username": "duhaime",
                        "content": "The problem statement says:\\n\\nGiven a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\\n\\nThe first example sequence is: `2-1-1`\\n\\nThe expected answer is:\\n((2-1)-1) = 0 \\n(2-(1-1)) = 2\\n\\nBut there is a third valid way to group the expression:\\n(2-1-1) = 0\\n\\nThe problem statement should be rewritten to indicate that only parenthetical groupings that produce distinct results should be retained. The notion of \"possible ways to group numbers and operators\" is not watertight."
                    },
                    {
                        "username": "ashish2nine",
                        "content": "I guess the third way that you have mentioned won\\'t work because when you will solve (2-1-1), at first you will have to consider two numbers and apply the operator on them, like you know in your head that the answer to (2-1-1) is 0 but when you solve it, you will either solve (2-1) first and then subtract 1 from that or you will first do (1-1) and then subtract the answer from 2, and in this way its either of the two possible cases."
                    },
                    {
                        "username": "laodasb",
                        "content": "Like the title said."
                    },
                    {
                        "username": "babaduredi",
                        "content": "This problem need not to deal with parenthesis placement literally !!"
                    },
                    {
                        "username": "catnoodle",
                        "content": "Even though it\\'s a simple check at the beginning, I feel it\\'s an important edge case to be caught in the interview."
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "can anyone give me hint about only the state of dp? Thank You"
                    },
                    {
                        "username": "forestsong",
                        "content": "Clearly many solutions didn\\'t consider test cases like `-2-1-1`"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@mudhapakamanohar](/mudhapakamanohar) suppose it is not ignored I am interested in the solution or hints"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "The numbers in the input string are in the range of [0,99]. Hence, your testcase can be ignored."
                    },
                    {
                        "username": "fanofxiaofeng",
                        "content": "for example, is \"2 - -3 \" a valid input string? If it is not, I guess the problem will be easier in some way."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "It\\'s already given in the question that all numbers in the range of [0,99]"
                    }
                ]
            },
            {
                "id": 1731057,
                "content": [
                    {
                        "username": "Heuit",
                        "content": "Some people wrote that Time complexity is catalan no. \\n ![image](https://assets.leetcode.com/users/images/9f316483-ff7b-47d7-a04a-0dca53a6dc67_1594908454.325404.png)\\n nth catalan no = (1/(n+1)) (2nCn) ,\\n \\n **But I can\\'t interpret these.**\\n\\n*What would be the interview answer to find the worst case time complexity before and after memoization?*\\n"
                    },
                    {
                        "username": "opeltantra",
                        "content": "From the problem description, input with negative integer seems to be possible.\\nex) -3-1, 2*-3-4*5\\nBut it turns out that all testcases use positive integer.\\nEven the test program throws exception when I put '-3-1' as an input.\\nAnd most of the solutions here doesn't consider negative input.\\nI think the input space needs to be specified in the problem description.\\nAny opinions? Please correct me if i'm wrong."
                    },
                    {
                        "username": "hpande145",
                        "content": "how will you distinguish between negetive number and \\'-\\' operator anyways"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is written that the integer values are in the range $[0, 99]$. Therefore, negative integers are not possible anymore."
                    },
                    {
                        "username": "scalacs",
                        "content": "With memoization, the time complexity is still nth Catalan, let n be the number of numbers after tokenization. To verify, simply print out the size of your solution given different length, you can see the sequence is exactly the Catalan numbers, i.e. 1, 1, 2, 5, 14, 42, 132, 429, 1430, .... \\nTherefore even with memoization, that\\'s still the amount of answer we need to compute.\\n\\nSame thing with space complexity. And you can tell why the space complexity is not O(n^2), because each result we cached is a list of different length, not a single number.\\n"
                    },
                    {
                        "username": "duhaime",
                        "content": "The problem statement says:\\n\\nGiven a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\\n\\nThe first example sequence is: `2-1-1`\\n\\nThe expected answer is:\\n((2-1)-1) = 0 \\n(2-(1-1)) = 2\\n\\nBut there is a third valid way to group the expression:\\n(2-1-1) = 0\\n\\nThe problem statement should be rewritten to indicate that only parenthetical groupings that produce distinct results should be retained. The notion of \"possible ways to group numbers and operators\" is not watertight."
                    },
                    {
                        "username": "ashish2nine",
                        "content": "I guess the third way that you have mentioned won\\'t work because when you will solve (2-1-1), at first you will have to consider two numbers and apply the operator on them, like you know in your head that the answer to (2-1-1) is 0 but when you solve it, you will either solve (2-1) first and then subtract 1 from that or you will first do (1-1) and then subtract the answer from 2, and in this way its either of the two possible cases."
                    },
                    {
                        "username": "laodasb",
                        "content": "Like the title said."
                    },
                    {
                        "username": "babaduredi",
                        "content": "This problem need not to deal with parenthesis placement literally !!"
                    },
                    {
                        "username": "catnoodle",
                        "content": "Even though it\\'s a simple check at the beginning, I feel it\\'s an important edge case to be caught in the interview."
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "can anyone give me hint about only the state of dp? Thank You"
                    },
                    {
                        "username": "forestsong",
                        "content": "Clearly many solutions didn\\'t consider test cases like `-2-1-1`"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@mudhapakamanohar](/mudhapakamanohar) suppose it is not ignored I am interested in the solution or hints"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "The numbers in the input string are in the range of [0,99]. Hence, your testcase can be ignored."
                    },
                    {
                        "username": "fanofxiaofeng",
                        "content": "for example, is \"2 - -3 \" a valid input string? If it is not, I guess the problem will be easier in some way."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "It\\'s already given in the question that all numbers in the range of [0,99]"
                    }
                ]
            },
            {
                "id": 1572857,
                "content": [
                    {
                        "username": "Heuit",
                        "content": "Some people wrote that Time complexity is catalan no. \\n ![image](https://assets.leetcode.com/users/images/9f316483-ff7b-47d7-a04a-0dca53a6dc67_1594908454.325404.png)\\n nth catalan no = (1/(n+1)) (2nCn) ,\\n \\n **But I can\\'t interpret these.**\\n\\n*What would be the interview answer to find the worst case time complexity before and after memoization?*\\n"
                    },
                    {
                        "username": "opeltantra",
                        "content": "From the problem description, input with negative integer seems to be possible.\\nex) -3-1, 2*-3-4*5\\nBut it turns out that all testcases use positive integer.\\nEven the test program throws exception when I put '-3-1' as an input.\\nAnd most of the solutions here doesn't consider negative input.\\nI think the input space needs to be specified in the problem description.\\nAny opinions? Please correct me if i'm wrong."
                    },
                    {
                        "username": "hpande145",
                        "content": "how will you distinguish between negetive number and \\'-\\' operator anyways"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is written that the integer values are in the range $[0, 99]$. Therefore, negative integers are not possible anymore."
                    },
                    {
                        "username": "scalacs",
                        "content": "With memoization, the time complexity is still nth Catalan, let n be the number of numbers after tokenization. To verify, simply print out the size of your solution given different length, you can see the sequence is exactly the Catalan numbers, i.e. 1, 1, 2, 5, 14, 42, 132, 429, 1430, .... \\nTherefore even with memoization, that\\'s still the amount of answer we need to compute.\\n\\nSame thing with space complexity. And you can tell why the space complexity is not O(n^2), because each result we cached is a list of different length, not a single number.\\n"
                    },
                    {
                        "username": "duhaime",
                        "content": "The problem statement says:\\n\\nGiven a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\\n\\nThe first example sequence is: `2-1-1`\\n\\nThe expected answer is:\\n((2-1)-1) = 0 \\n(2-(1-1)) = 2\\n\\nBut there is a third valid way to group the expression:\\n(2-1-1) = 0\\n\\nThe problem statement should be rewritten to indicate that only parenthetical groupings that produce distinct results should be retained. The notion of \"possible ways to group numbers and operators\" is not watertight."
                    },
                    {
                        "username": "ashish2nine",
                        "content": "I guess the third way that you have mentioned won\\'t work because when you will solve (2-1-1), at first you will have to consider two numbers and apply the operator on them, like you know in your head that the answer to (2-1-1) is 0 but when you solve it, you will either solve (2-1) first and then subtract 1 from that or you will first do (1-1) and then subtract the answer from 2, and in this way its either of the two possible cases."
                    },
                    {
                        "username": "laodasb",
                        "content": "Like the title said."
                    },
                    {
                        "username": "babaduredi",
                        "content": "This problem need not to deal with parenthesis placement literally !!"
                    },
                    {
                        "username": "catnoodle",
                        "content": "Even though it\\'s a simple check at the beginning, I feel it\\'s an important edge case to be caught in the interview."
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "can anyone give me hint about only the state of dp? Thank You"
                    },
                    {
                        "username": "forestsong",
                        "content": "Clearly many solutions didn\\'t consider test cases like `-2-1-1`"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@mudhapakamanohar](/mudhapakamanohar) suppose it is not ignored I am interested in the solution or hints"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "The numbers in the input string are in the range of [0,99]. Hence, your testcase can be ignored."
                    },
                    {
                        "username": "fanofxiaofeng",
                        "content": "for example, is \"2 - -3 \" a valid input string? If it is not, I guess the problem will be easier in some way."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "It\\'s already given in the question that all numbers in the range of [0,99]"
                    }
                ]
            },
            {
                "id": 1571485,
                "content": [
                    {
                        "username": "Heuit",
                        "content": "Some people wrote that Time complexity is catalan no. \\n ![image](https://assets.leetcode.com/users/images/9f316483-ff7b-47d7-a04a-0dca53a6dc67_1594908454.325404.png)\\n nth catalan no = (1/(n+1)) (2nCn) ,\\n \\n **But I can\\'t interpret these.**\\n\\n*What would be the interview answer to find the worst case time complexity before and after memoization?*\\n"
                    },
                    {
                        "username": "opeltantra",
                        "content": "From the problem description, input with negative integer seems to be possible.\\nex) -3-1, 2*-3-4*5\\nBut it turns out that all testcases use positive integer.\\nEven the test program throws exception when I put '-3-1' as an input.\\nAnd most of the solutions here doesn't consider negative input.\\nI think the input space needs to be specified in the problem description.\\nAny opinions? Please correct me if i'm wrong."
                    },
                    {
                        "username": "hpande145",
                        "content": "how will you distinguish between negetive number and \\'-\\' operator anyways"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is written that the integer values are in the range $[0, 99]$. Therefore, negative integers are not possible anymore."
                    },
                    {
                        "username": "scalacs",
                        "content": "With memoization, the time complexity is still nth Catalan, let n be the number of numbers after tokenization. To verify, simply print out the size of your solution given different length, you can see the sequence is exactly the Catalan numbers, i.e. 1, 1, 2, 5, 14, 42, 132, 429, 1430, .... \\nTherefore even with memoization, that\\'s still the amount of answer we need to compute.\\n\\nSame thing with space complexity. And you can tell why the space complexity is not O(n^2), because each result we cached is a list of different length, not a single number.\\n"
                    },
                    {
                        "username": "duhaime",
                        "content": "The problem statement says:\\n\\nGiven a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\\n\\nThe first example sequence is: `2-1-1`\\n\\nThe expected answer is:\\n((2-1)-1) = 0 \\n(2-(1-1)) = 2\\n\\nBut there is a third valid way to group the expression:\\n(2-1-1) = 0\\n\\nThe problem statement should be rewritten to indicate that only parenthetical groupings that produce distinct results should be retained. The notion of \"possible ways to group numbers and operators\" is not watertight."
                    },
                    {
                        "username": "ashish2nine",
                        "content": "I guess the third way that you have mentioned won\\'t work because when you will solve (2-1-1), at first you will have to consider two numbers and apply the operator on them, like you know in your head that the answer to (2-1-1) is 0 but when you solve it, you will either solve (2-1) first and then subtract 1 from that or you will first do (1-1) and then subtract the answer from 2, and in this way its either of the two possible cases."
                    },
                    {
                        "username": "laodasb",
                        "content": "Like the title said."
                    },
                    {
                        "username": "babaduredi",
                        "content": "This problem need not to deal with parenthesis placement literally !!"
                    },
                    {
                        "username": "catnoodle",
                        "content": "Even though it\\'s a simple check at the beginning, I feel it\\'s an important edge case to be caught in the interview."
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "can anyone give me hint about only the state of dp? Thank You"
                    },
                    {
                        "username": "forestsong",
                        "content": "Clearly many solutions didn\\'t consider test cases like `-2-1-1`"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@mudhapakamanohar](/mudhapakamanohar) suppose it is not ignored I am interested in the solution or hints"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "The numbers in the input string are in the range of [0,99]. Hence, your testcase can be ignored."
                    },
                    {
                        "username": "fanofxiaofeng",
                        "content": "for example, is \"2 - -3 \" a valid input string? If it is not, I guess the problem will be easier in some way."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "It\\'s already given in the question that all numbers in the range of [0,99]"
                    }
                ]
            }
        ]
    },
    {
        "title": "Flatten Nested List Iterator",
        "question_content": "<p>You are given a nested list of integers <code>nestedList</code>. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.</p>\n\n<p>Implement the <code>NestedIterator</code> class:</p>\n\n<ul>\n\t<li><code>NestedIterator(List&lt;NestedInteger&gt; nestedList)</code> Initializes the iterator with the nested list <code>nestedList</code>.</li>\n\t<li><code>int next()</code> Returns the next integer in the nested list.</li>\n\t<li><code>boolean hasNext()</code> Returns <code>true</code> if there are still some integers in the nested list and <code>false</code> otherwise.</li>\n</ul>\n\n<p>Your code will be tested with the following pseudocode:</p>\n\n<pre>\ninitialize iterator with nestedList\nres = []\nwhile iterator.hasNext()\n    append iterator.next() to the end of res\nreturn res\n</pre>\n\n<p>If <code>res</code> matches the expected flattened list, then your code will be judged as correct.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nestedList = [[1,1],2,[1,1]]\n<strong>Output:</strong> [1,1,2,1,1]\n<strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nestedList = [1,[4,[6]]]\n<strong>Output:</strong> [1,4,6]\n<strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nestedList.length &lt;= 500</code></li>\n\t<li>The values of the integers in the nested list is in the range <code>[-10<sup>6</sup>, 10<sup>6</sup>]</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 80147,
                "title": "simple-java-solution-using-a-stack-with-explanation",
                "content": "A question before this is the Nested List Weight Sum, and it requires recursion to solve.  As it carries to this problem that we will need recursion to solve it.  But since we need to access each NestedInteger at a time, we will use a stack to help.  \\n\\nIn the constructor, we push all the nestedList into the stack from back to front, so when we pop the stack, it returns the very first element.  Second, in the hasNext() function, we peek the first element in stack currently, and if it is an Integer, we will return true and pop the element.  If it is a list, we will further flatten it.  This is iterative version of flatting the nested list.  Again, we need to iterate from the back to front of the list.\\n\\nNote: first version of the solution has some mistakes as mentioned in some of the comments below, updated it and apologize if it was misleading.\\n\\n```\\npublic class NestedIterator implements Iterator<Integer> {\\n    Deque<NestedInteger> stack = new ArrayDeque<>();\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        prepareStack(nestedList);\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        if (!hasNext()) {\\n            return null;\\n        }\\n        return stack.pop().getInteger();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        while (!stack.isEmpty() && !stack.peek().isInteger()) {\\n            List<NestedInteger> list = stack.pop().getList();\\n            prepareStack(list);\\n        }\\n        return !stack.isEmpty();\\n    }\\n    \\n    private void prepareStack(List<NestedInteger> nestedList) {\\n        for (int i = nestedList.size() - 1; i >= 0; i--) {\\n            stack.push(nestedList.get(i));\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "A question before this is the Nested List Weight Sum, and it requires recursion to solve.  As it carries to this problem that we will need recursion to solve it.  But since we need to access each NestedInteger at a time, we will use a stack to help.  \\n\\nIn the constructor, we push all the nestedList into the stack from back to front, so when we pop the stack, it returns the very first element.  Second, in the hasNext() function, we peek the first element in stack currently, and if it is an Integer, we will return true and pop the element.  If it is a list, we will further flatten it.  This is iterative version of flatting the nested list.  Again, we need to iterate from the back to front of the list.\\n\\nNote: first version of the solution has some mistakes as mentioned in some of the comments below, updated it and apologize if it was misleading.\\n\\n```\\npublic class NestedIterator implements Iterator<Integer> {\\n    Deque<NestedInteger> stack = new ArrayDeque<>();\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        prepareStack(nestedList);\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        if (!hasNext()) {\\n            return null;\\n        }\\n        return stack.pop().getInteger();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        while (!stack.isEmpty() && !stack.peek().isInteger()) {\\n            List<NestedInteger> list = stack.pop().getList();\\n            prepareStack(list);\\n        }\\n        return !stack.isEmpty();\\n    }\\n    \\n    private void prepareStack(List<NestedInteger> nestedList) {\\n        for (int i = nestedList.size() - 1; i >= 0; i--) {\\n            stack.push(nestedList.get(i));\\n        }\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 80146,
                "title": "real-iterator-in-python-java-c",
                "content": "In my opinion an iterator shouldn't copy the entire data (which some solutions have done) but just iterate over the original data structure.\\n\\nI keep the current progress in a stack. My `hasNext` tries to find an integer. My `next` returns it and moves on. I call `hasNext` in `next` because `hasNext` is optional. Some user of the iterator might call only `next` and never `hasNext`, e.g., if they know how many integers are in the structure or if they want to handle the ending with exception handling.\\n\\n---\\n\\n**Python**\\n\\nUsing a stack of [list, index] pairs.\\n\\n    class NestedIterator(object):\\n    \\n        def __init__(self, nestedList):\\n            self.stack = [[nestedList, 0]]\\n    \\n        def next(self):\\n            self.hasNext()\\n            nestedList, i = self.stack[-1]\\n            self.stack[-1][1] += 1\\n            return nestedList[i].getInteger()\\n                \\n        def hasNext(self):\\n            s = self.stack\\n            while s:\\n                nestedList, i = s[-1]\\n                if i == len(nestedList):\\n                    s.pop()\\n                else:\\n                    x = nestedList[i]\\n                    if x.isInteger():\\n                        return True\\n                    s[-1][1] += 1\\n                    s.append([x.getList(), 0])\\n            return False\\n\\n---\\n\\n**Java**\\n\\nUsing a stack of ListIterators.\\n\\n    public class NestedIterator implements Iterator<Integer> {\\n    \\n        public NestedIterator(List<NestedInteger> nestedList) {\\n            lists = new Stack<>();\\n            lists.push(nestedList.listIterator());\\n        }\\n    \\n        public Integer next() {\\n            hasNext();\\n            return lists.peek().next().getInteger();\\n        }\\n    \\n        public boolean hasNext() {\\n            while (!lists.empty()) {\\n                if (!lists.peek().hasNext()) {\\n                    lists.pop();\\n                } else {\\n                    NestedInteger x = lists.peek().next();\\n                    if (x.isInteger())\\n                        return lists.peek().previous() == x;\\n                    lists.push(x.getList().listIterator());\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        private Stack<ListIterator<NestedInteger>> lists;\\n    }\\n\\n---\\n\\n**C++**\\n\\nUsing stacks of begin and end iterators.\\n\\n    class NestedIterator {\\n    public:\\n        NestedIterator(vector<NestedInteger> &nestedList) {\\n            begins.push(nestedList.begin());\\n            ends.push(nestedList.end());\\n        }\\n    \\n        int next() {\\n            hasNext();\\n            return (begins.top()++)->getInteger();\\n        }\\n    \\n        bool hasNext() {\\n            while (begins.size()) {\\n                if (begins.top() == ends.top()) {\\n                    begins.pop();\\n                    ends.pop();\\n                } else {\\n                    auto x = begins.top();\\n                    if (x->isInteger())\\n                        return true;\\n                    begins.top()++;\\n                    begins.push(x->getList().begin());\\n                    ends.push(x->getList().end());\\n                }\\n            }\\n            return false;\\n        }\\n    \\n    private:\\n        stack<vector<NestedInteger>::iterator> begins, ends;\\n    };",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "In my opinion an iterator shouldn't copy the entire data (which some solutions have done) but just iterate over the original data structure.\\n\\nI keep the current progress in a stack. My `hasNext` tries to find an integer. My `next` returns it and moves on. I call `hasNext` in `next` because `hasNext` is optional. Some user of the iterator might call only `next` and never `hasNext`, e.g., if they know how many integers are in the structure or if they want to handle the ending with exception handling.\\n\\n---\\n\\n**Python**\\n\\nUsing a stack of [list, index] pairs.\\n\\n    class NestedIterator(object):\\n    \\n        def __init__(self, nestedList):\\n            self.stack = [[nestedList, 0]]\\n    \\n        def next(self):\\n            self.hasNext()\\n            nestedList, i = self.stack[-1]\\n            self.stack[-1][1] += 1\\n            return nestedList[i].getInteger()\\n                \\n        def hasNext(self):\\n            s = self.stack\\n            while s:\\n                nestedList, i = s[-1]\\n                if i == len(nestedList):\\n                    s.pop()\\n                else:\\n                    x = nestedList[i]\\n                    if x.isInteger():\\n                        return True\\n                    s[-1][1] += 1\\n                    s.append([x.getList(), 0])\\n            return False\\n\\n---\\n\\n**Java**\\n\\nUsing a stack of ListIterators.\\n\\n    public class NestedIterator implements Iterator<Integer> {\\n    \\n        public NestedIterator(List<NestedInteger> nestedList) {\\n            lists = new Stack<>();\\n            lists.push(nestedList.listIterator());\\n        }\\n    \\n        public Integer next() {\\n            hasNext();\\n            return lists.peek().next().getInteger();\\n        }\\n    \\n        public boolean hasNext() {\\n            while (!lists.empty()) {\\n                if (!lists.peek().hasNext()) {\\n                    lists.pop();\\n                } else {\\n                    NestedInteger x = lists.peek().next();\\n                    if (x.isInteger())\\n                        return lists.peek().previous() == x;\\n                    lists.push(x.getList().listIterator());\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        private Stack<ListIterator<NestedInteger>> lists;\\n    }\\n\\n---\\n\\n**C++**\\n\\nUsing stacks of begin and end iterators.\\n\\n    class NestedIterator {\\n    public:\\n        NestedIterator(vector<NestedInteger> &nestedList) {\\n            begins.push(nestedList.begin());\\n            ends.push(nestedList.end());\\n        }\\n    \\n        int next() {\\n            hasNext();\\n            return (begins.top()++)->getInteger();\\n        }\\n    \\n        bool hasNext() {\\n            while (begins.size()) {\\n                if (begins.top() == ends.top()) {\\n                    begins.pop();\\n                    ends.pop();\\n                } else {\\n                    auto x = begins.top();\\n                    if (x->isInteger())\\n                        return true;\\n                    begins.top()++;\\n                    begins.push(x->getList().begin());\\n                    ends.push(x->getList().end());\\n                }\\n            }\\n            return false;\\n        }\\n    \\n    private:\\n        stack<vector<NestedInteger>::iterator> begins, ends;\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 80142,
                "title": "8-line-python-solution",
                "content": "    class NestedIterator(object):\\n    \\n        def __init__(self, nestedList):\\n            \"\"\"\\n            Initialize your data structure here.\\n            :type nestedList: List[NestedInteger]\\n            \"\"\"\\n            self.stack = nestedList[::-1]\\n            \\n        def next(self):\\n            \"\"\"\\n            :rtype: int\\n            \"\"\"\\n            return self.stack.pop().getInteger()\\n            \\n        def hasNext(self):\\n            \"\"\"\\n            :rtype: bool\\n            \"\"\"\\n            while self.stack:\\n                top = self.stack[-1]\\n                if top.isInteger():\\n                    return True\\n                self.stack = self.stack[:-1] + top.getList()[::-1]\\n            return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class NestedIterator(object):\\n    \\n        def __init__(self, nestedList):\\n            \"\"\"\\n            Initialize your data structure here.\\n            :type nestedList: List[NestedInteger]\\n            \"\"\"\\n            self.stack = nestedList[::-1]\\n            \\n        def next(self):\\n            \"\"\"\\n            :rtype: int\\n            \"\"\"\\n            return self.stack.pop().getInteger()\\n            \\n        def hasNext(self):\\n            \"\"\"\\n            :rtype: bool\\n            \"\"\"\\n            while self.stack:\\n                top = self.stack[-1]\\n                if top.isInteger():\\n                    return True\\n                self.stack = self.stack[:-1] + top.getList()[::-1]\\n            return False",
                "codeTag": "Java"
            },
            {
                "id": 80234,
                "title": "evolve-from-intuition-to-optimal-a-review-of-top-solutions",
                "content": "This problem is simialr to [589. N-ary Tree Preorder Traversal](https://leetcode.com/problems/n-ary-tree-preorder-traversal/discuss/1041021/Three-solutions).\\n1. O(n) space, Flatten the list in constructor. The nested list can be visualized as a tree and the iterator order is dfs.\\n* c++\\n```\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        dfs(nestedList); \\n    }\\n    void dfs(vector<NestedInteger> &nestedList) {\\n         for(int i=nestedList.size()-1;i>=0;i--)\\n            if(nestedList[i].isInteger()) stk.push(nestedList[i].getInteger());\\n            else dfs(nestedList[i].getList());\\n    }\\n    int next() {\\n        int nxt = stk.top();\\n        stk.pop();\\n        return nxt;\\n    }\\n    bool hasNext() {\\n        return !stk.empty();\\n    }\\nprivate:\\n    stack<int> stk;\\n};\\n```\\n* java\\n```\\npublic class NestedIterator implements Iterator<Integer> {\\n    Queue<Integer> q;\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        q=new LinkedList<Integer>();\\n        dfs(nestedList);\\n    }\\n    private void dfs(List<NestedInteger> nestedList){\\n        for(NestedInteger ni:nestedList)\\n            if(ni.isInteger()) q.add(ni.getInteger());\\n            else dfs(ni.getList());    \\n    }\\n    @Override\\n    public Integer next() {\\n        return q.poll(); \\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return !q.isEmpty(); \\n    }\\n}\\n```\\n2. O(n) space, Flatten the list as you go. #1 is not an iterator because an iterator should never copy the data structure. Besides, it is a waste of time to flatten and store the whole list if we may only visit a few elements. So we can store the first level in the stack and flatten it as we go. If the list is flat, then there is no saving over #1.\\n* c++\\n```\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        for(int i=nestedList.size()-1;i>=0;i--) stk.push(&nestedList[i]);\\n    }\\n    int next() {\\n        int nxt = stk.top()->getInteger();\\n        stk.pop();\\n        return nxt;\\n    }\\n    bool hasNext() {\\n        while(!stk.empty()) {\\n            NestedInteger *p = stk.top();\\n            if(p->isInteger()) return 1;\\n            vector<NestedInteger> &vec = p->getList();\\n            stk.pop();\\n            for(int i=vec.size()-1;i>=0;i--) stk.push(&vec[i]);\\n        }\\n        return 0;\\n    }\\nprivate:\\n    stack<NestedInteger*> stk;\\n};\\n```\\n* java\\n```\\npublic class NestedIterator implements Iterator<Integer> {\\n    Stack<NestedInteger> stk;\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        stk=new Stack<NestedInteger>();\\n        addToStack(nestedList);\\n    }\\n    private void addToStack(List<NestedInteger> nestedList) {\\n        for(int i=nestedList.size()-1;i>=0;i--) \\n            stk.push(nestedList.get(i));    \\n    }\\n    @Override\\n    public Integer next() {\\n        return stk.pop().getInteger(); \\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        while(!stk.isEmpty()&&!stk.peek().isInteger()) {  //dfs until an integer is found\\n            addToStack(stk.pop().getList());\\n        }\\n        return !stk.isEmpty(); \\n    }\\n}\\n```\\n3. Real iterator, O(h) space, h is the depth of the list. #2 stores each element in the current list. This still can be large. A list iterator is sufficient to dfs the list.\\n* c++ \\nThis solution only stores 2 iterators of the current list. The great idea is from [@StefanPochmann](https://discuss.leetcode.com/topic/41870/real-iterator-in-python-java-c). \\n```\\nclass NestedIterator {\\npublic:\\n    typedef vector<NestedInteger>::iterator iter;  \\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        begins.push(nestedList.begin());\\n        ends.push(nestedList.end());\\n    }\\n    int next() {\\n        return begins.top()++->getInteger();\\n    }\\n    bool hasNext() {\\n        while(!begins.empty()) {\\n            iter it = begins.top();\\n            if(it == ends.top()) {\\n                begins.pop();\\n                ends.pop();\\n                if(!begins.empty()) begins.top()++;\\n            } else if (it->isInteger()) return 1;\\n            else {\\n                vector<NestedInteger>& lst = it->getList();\\n                begins.push(lst.begin());\\n                ends.push(lst.end());\\n            }\\n        }\\n        return 0;\\n    }\\nprivate:\\n   stack<iter> begins, ends;\\n};\\n```\\n* java\\n```\\npublic class NestedIterator implements Iterator<Integer> {\\n    Stack<Iterator<NestedInteger>> stk;\\n    Integer next;\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        stk=new Stack<Iterator<NestedInteger>>();\\n        stk.add(nestedList.iterator());\\n        advance();\\n    }\\n    private void advance() {\\n        next = null;\\n        while(!stk.isEmpty()) {\\n            Iterator<NestedInteger> it = stk.peek();\\n            if(!it.hasNext()) {\\n                stk.pop();\\n            } else {\\n                NestedInteger ni = it.next();\\n                if(ni.isInteger()) {\\n                    next = ni.getInteger();\\n                    return;\\n                }\\n                stk.add(ni.getList().iterator());\\n            }\\n        }\\n    }\\n    @Override\\n    public Integer next() {\\n        Integer ret = next;\\n        advance();\\n        return ret; \\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return next != null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        dfs(nestedList); \\n    }\\n    void dfs(vector<NestedInteger> &nestedList) {\\n         for(int i=nestedList.size()-1;i>=0;i--)\\n            if(nestedList[i].isInteger()) stk.push(nestedList[i].getInteger());\\n            else dfs(nestedList[i].getList());\\n    }\\n    int next() {\\n        int nxt = stk.top();\\n        stk.pop();\\n        return nxt;\\n    }\\n    bool hasNext() {\\n        return !stk.empty();\\n    }\\nprivate:\\n    stack<int> stk;\\n};\\n```\n```\\npublic class NestedIterator implements Iterator<Integer> {\\n    Queue<Integer> q;\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        q=new LinkedList<Integer>();\\n        dfs(nestedList);\\n    }\\n    private void dfs(List<NestedInteger> nestedList){\\n        for(NestedInteger ni:nestedList)\\n            if(ni.isInteger()) q.add(ni.getInteger());\\n            else dfs(ni.getList());    \\n    }\\n    @Override\\n    public Integer next() {\\n        return q.poll(); \\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return !q.isEmpty(); \\n    }\\n}\\n```\n```\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        for(int i=nestedList.size()-1;i>=0;i--) stk.push(&nestedList[i]);\\n    }\\n    int next() {\\n        int nxt = stk.top()->getInteger();\\n        stk.pop();\\n        return nxt;\\n    }\\n    bool hasNext() {\\n        while(!stk.empty()) {\\n            NestedInteger *p = stk.top();\\n            if(p->isInteger()) return 1;\\n            vector<NestedInteger> &vec = p->getList();\\n            stk.pop();\\n            for(int i=vec.size()-1;i>=0;i--) stk.push(&vec[i]);\\n        }\\n        return 0;\\n    }\\nprivate:\\n    stack<NestedInteger*> stk;\\n};\\n```\n```\\npublic class NestedIterator implements Iterator<Integer> {\\n    Stack<NestedInteger> stk;\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        stk=new Stack<NestedInteger>();\\n        addToStack(nestedList);\\n    }\\n    private void addToStack(List<NestedInteger> nestedList) {\\n        for(int i=nestedList.size()-1;i>=0;i--) \\n            stk.push(nestedList.get(i));    \\n    }\\n    @Override\\n    public Integer next() {\\n        return stk.pop().getInteger(); \\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        while(!stk.isEmpty()&&!stk.peek().isInteger()) {  //dfs until an integer is found\\n            addToStack(stk.pop().getList());\\n        }\\n        return !stk.isEmpty(); \\n    }\\n}\\n```\n```\\nclass NestedIterator {\\npublic:\\n    typedef vector<NestedInteger>::iterator iter;  \\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        begins.push(nestedList.begin());\\n        ends.push(nestedList.end());\\n    }\\n    int next() {\\n        return begins.top()++->getInteger();\\n    }\\n    bool hasNext() {\\n        while(!begins.empty()) {\\n            iter it = begins.top();\\n            if(it == ends.top()) {\\n                begins.pop();\\n                ends.pop();\\n                if(!begins.empty()) begins.top()++;\\n            } else if (it->isInteger()) return 1;\\n            else {\\n                vector<NestedInteger>& lst = it->getList();\\n                begins.push(lst.begin());\\n                ends.push(lst.end());\\n            }\\n        }\\n        return 0;\\n    }\\nprivate:\\n   stack<iter> begins, ends;\\n};\\n```\n```\\npublic class NestedIterator implements Iterator<Integer> {\\n    Stack<Iterator<NestedInteger>> stk;\\n    Integer next;\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        stk=new Stack<Iterator<NestedInteger>>();\\n        stk.add(nestedList.iterator());\\n        advance();\\n    }\\n    private void advance() {\\n        next = null;\\n        while(!stk.isEmpty()) {\\n            Iterator<NestedInteger> it = stk.peek();\\n            if(!it.hasNext()) {\\n                stk.pop();\\n            } else {\\n                NestedInteger ni = it.next();\\n                if(ni.isInteger()) {\\n                    next = ni.getInteger();\\n                    return;\\n                }\\n                stk.add(ni.getList().iterator());\\n            }\\n        }\\n    }\\n    @Override\\n    public Integer next() {\\n        Integer ret = next;\\n        advance();\\n        return ret; \\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return next != null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80169,
                "title": "concise-c-without-storing-all-values-at-initialization",
                "content": "    class NestedIterator {\\n    private:\\n        stack<NestedInteger> nodes;\\n        \\n    public:\\n        NestedIterator(vector<NestedInteger> &nestedList) {\\n            int size = nestedList.size();\\n            for(int i = size - 1; i >= 0; --i) {\\n                nodes.push(nestedList[i]);\\n            }\\n        }\\n\\n    int next() {\\n        int result = nodes.top().getInteger();\\n        nodes.pop();\\n        return result;\\n    }\\n\\n    bool hasNext() {\\n        while(!nodes.empty()) {\\n            NestedInteger curr = nodes.top();\\n            if(curr.isInteger()) {\\n                return true;\\n            }\\n            \\n            nodes.pop();\\n            vector<NestedInteger>& adjs = curr.getList();\\n            int size = adjs.size();\\n            for(int i = size - 1; i >= 0; --i) {\\n                nodes.push(adjs[i]);\\n            }\\n        }\\n        \\n        return false;\\n        }\\n    };\\n\\nThe same idea as a DFS, the only tricky part probably is you have to find a value node to claim there is next. And to do that, you have to look through all the nodes in the worst case in the entire graph. So you just keep going until you find a value node; if you can't, there is no next.",
                "solutionTags": [],
                "code": "    class NestedIterator {\\n    private:\\n        stack<NestedInteger> nodes;\\n        \\n    public:\\n        NestedIterator(vector<NestedInteger> &nestedList) {\\n            int size = nestedList.size();\\n            for(int i = size - 1; i >= 0; --i) {\\n                nodes.push(nestedList[i]);\\n            }\\n        }\\n\\n    int next() {\\n        int result = nodes.top().getInteger();\\n        nodes.pop();\\n        return result;\\n    }\\n\\n    bool hasNext() {\\n        while(!nodes.empty()) {\\n            NestedInteger curr = nodes.top();\\n            if(curr.isInteger()) {\\n                return true;\\n            }\\n            \\n            nodes.pop();\\n            vector<NestedInteger>& adjs = curr.getList();\\n            int size = adjs.size();\\n            for(int i = size - 1; i >= 0; --i) {\\n                nodes.push(adjs[i]);\\n            }\\n        }\\n        \\n        return false;\\n        }\\n    };\\n\\nThe same idea as a DFS, the only tricky part probably is you have to find a value node to claim there is next. And to do that, you have to look through all the nodes in the worst case in the entire graph. So you just keep going until you find a value node; if you can't, there is no next.",
                "codeTag": "Java"
            },
            {
                "id": 335847,
                "title": "multiple-solution-beat-100-using-list-queue-and-stack",
                "content": "This is intersting question, so i decided to solve as many way possible [ there is one more way left, which i did not coded.] \\nPlease follow the comments for understanding;\\n\\n```\\n\\n\\n/**\\n * This is the smartest one and easiest of them all.\\n * We basically process the given list and store all the values;\\n * <p>\\n * Advantages:\\n * 1. Its fast\\n * 2. this is fail safe iterator, means it won\\'t throw concurrent modification exception\\n * 3. good choice for multi threading\\n * <p>\\n * Disadvantages:\\n * 1. This occupy lot of extra space, and\\n * 2. this is not lazy in its behaviour rather proactive\\n */\\nclass NestedIteratorUsingList implements Iterator<Integer> {\\n\\n    /**\\n     * use to store the elements from given list\\n     */\\n    private List<Integer> elements = new ArrayList<>();\\n\\n    /**\\n     * to keep track the element which need to show\\n     */\\n    int index = 0;\\n\\n    public NestedIteratorUsingList(List<NestedInteger> nestedList) {\\n\\n        init(nestedList);\\n    }\\n\\n    /**\\n     * store them recursively\\n     *\\n     * @param nestedList\\n     */\\n    private void init(List<NestedInteger> nestedList) {\\n        if (nestedList.isEmpty())\\n            return;\\n\\n        for (NestedInteger nst : nestedList) {\\n\\n            if (!nst.isInteger()) {\\n                init(nst.getList());\\n\\n            } else\\n                elements.add(nst.getInteger());\\n        }\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return elements.get(index++);\\n\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        if (index < this.elements.size())\\n            return true;\\n        else\\n            return false;\\n    }\\n}\\n\\n\\n/**\\n * This is second variation of above algorithm, everything on above algorithm apply, apply on this too.\\n * 1. Interviewer might ask you to use some inbuilt data structure if need.\\n * We are just mimicking the queue in above solution, this true queue based solution\\n * 2. Interviewer might ask you to minimize the overall process of processing\\n * <p>\\n * Neat and clean\\n */\\nclass NestedIteratorUsingQueue implements Iterator<Integer> {\\n\\n    private Queue<Integer> queue;\\n\\n    public NestedIteratorUsingQueue(List<NestedInteger> nestedList) {\\n\\n        queue = new LinkedList<>();\\n        init(nestedList);\\n    }\\n\\n    private void init(List<NestedInteger> nestedList) {\\n        if (nestedList.isEmpty())\\n            return;\\n\\n        for (NestedInteger nst : nestedList) {\\n\\n            if (!nst.isInteger()) {\\n                init(nst.getList());\\n\\n            } else\\n                queue.offer(nst.getInteger());\\n        }\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return queue.poll();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return !queue.isEmpty();\\n    }\\n}\\n\\n/**\\n * This is another approach, which is lazy in nature. It has advantages on memory usage.\\n */\\nclass NestedIteratorUsingStack implements Iterator<Integer> {\\n\\n    /**\\n     * keep a stack for which element we need to print\\n     */\\n    private Stack<NestedInteger> stack;\\n\\n    public NestedIteratorUsingStack(List<NestedInteger> nestedList) {\\n\\n        if (nestedList.isEmpty())\\n            return;\\n\\n        stack = new Stack<>();\\n\\n        /**\\n         * since we need to show from left to right direction, simply push all the elements in reverse order initially\\n         */\\n        for (int i = nestedList.size() - 1; i >= 0; i--)\\n            stack.push(nestedList.get(i));\\n    }\\n\\n\\n    @Override\\n    public Integer next() {\\n\\n        return stack.pop().getInteger();\\n\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        /**\\n         * based on top, just process\\n         */\\n        while (!stack.isEmpty() && !stack.peek().isInteger()) {\\n            List<NestedInteger> nst = stack.pop().getList();\\n\\n            for (int i = nst.size() - 1; i >= 0; i--) {\\n                stack.push(nst.get(i));\\n            }\\n\\n\\n        }\\n        return !stack.isEmpty();\\n\\n    }\\n}\\n\\n\\n\\n```\\n\\nSome driver program \\n\\n```\\n\\n\\npublic class FlattenNestedListIterator {\\n\\n\\n    public static void main(String args[]) {\\n        usingList();\\n        usingQueue();\\n        usingStack();\\n\\n    }\\n\\n    private static void usingStack() {\\n        System.out.println(\"\\\\nUsing stack \");\\n        testUsingStack1();\\n        testUsingStack2();\\n        testUsingStack3();\\n    }\\n\\n    private static void usingQueue() {\\n        System.out.println(\"\\\\nUsing queue \");\\n        testUsingQueue1();\\n        testUsingQueue2();\\n        testUsingQueue3();\\n    }\\n\\n    private static void usingList() {\\n        System.out.println(\"\\\\nUsing List \");\\n        test1();\\n        test2();\\n        test3();\\n    }\\n\\n    public static void test3() {\\n        System.out.println();\\n        List<NestedInteger> sample = Arrays.asList(\\n                new NestedIntegerValue(1),\\n                new NestedIntegerValues(new NestedIntegerValue(4),\\n                        new NestedIntegerValues(\\n                                new NestedIntegerValues(new NestedIntegerValue(9),\\n                                        new NestedIntegerValues(new NestedIntegerValue(9))),\\n                                new NestedIntegerValue(6))));\\n\\n        System.out.println(sample);\\n        NestedIteratorUsingList iterator = new NestedIteratorUsingList(sample);\\n        while (iterator.hasNext()) {\\n            System.out.print(iterator.next());\\n        }\\n    }\\n\\n    public static void test2() {\\n        System.out.println();\\n        List<NestedInteger> sample2 = Arrays.asList(\\n                new NestedIntegerValue(1),\\n                new NestedIntegerValues(new NestedIntegerValue(4), new NestedIntegerValues(new NestedIntegerValue(6))));\\n\\n        System.out.println(sample2);\\n        NestedIteratorUsingList iterator = new NestedIteratorUsingList(sample2);\\n        while (iterator.hasNext()) {\\n            System.out.print(iterator.next());\\n        }\\n    }\\n\\n    public static void test1() {\\n        System.out.println();\\n        List<NestedInteger> sample1 = Arrays.asList(\\n                new NestedIntegerValues(new NestedIntegerValue(1), new NestedIntegerValue(1)),\\n                new NestedIntegerValue(2),\\n                new NestedIntegerValues(new NestedIntegerValue(1), new NestedIntegerValue(1)));\\n\\n        System.out.println(sample1);\\n        NestedIteratorUsingList iterator = new NestedIteratorUsingList(sample1);\\n        while (iterator.hasNext()) {\\n            System.out.print(iterator.next());\\n        }\\n    }\\n\\n\\n    public static void testUsingQueue3() {\\n        System.out.println();\\n        List<NestedInteger> sample = Arrays.asList(\\n                new NestedIntegerValue(1),\\n                new NestedIntegerValues(new NestedIntegerValue(4),\\n                        new NestedIntegerValues(\\n                                new NestedIntegerValues(new NestedIntegerValue(9),\\n                                        new NestedIntegerValues(new NestedIntegerValue(9))),\\n                                new NestedIntegerValue(6))));\\n\\n        System.out.println(sample);\\n        NestedIteratorUsingQueue iterator = new NestedIteratorUsingQueue(sample);\\n        while (iterator.hasNext()) {\\n            System.out.print(iterator.next());\\n        }\\n    }\\n\\n    public static void testUsingQueue2() {\\n        System.out.println();\\n        List<NestedInteger> sample2 = Arrays.asList(\\n                new NestedIntegerValue(1),\\n                new NestedIntegerValues(new NestedIntegerValue(4), new NestedIntegerValues(new NestedIntegerValue(6))));\\n\\n        System.out.println(sample2);\\n        NestedIteratorUsingQueue iterator = new NestedIteratorUsingQueue(sample2);\\n        while (iterator.hasNext()) {\\n            System.out.print(iterator.next());\\n        }\\n    }\\n\\n    public static void testUsingQueue1() {\\n        System.out.println();\\n        List<NestedInteger> sample1 = Arrays.asList(\\n                new NestedIntegerValues(new NestedIntegerValue(1), new NestedIntegerValue(1)),\\n                new NestedIntegerValue(2),\\n                new NestedIntegerValues(new NestedIntegerValue(1), new NestedIntegerValue(1)));\\n\\n        System.out.println(sample1);\\n        NestedIteratorUsingQueue iterator = new NestedIteratorUsingQueue(sample1);\\n        while (iterator.hasNext()) {\\n            System.out.print(iterator.next());\\n        }\\n    }\\n\\n\\n    public static void testUsingStack3() {\\n        System.out.println();\\n        List<NestedInteger> sample = Arrays.asList(\\n                new NestedIntegerValue(1),\\n                new NestedIntegerValues(new NestedIntegerValue(4),\\n                        new NestedIntegerValues(\\n                                new NestedIntegerValues(new NestedIntegerValue(9),\\n                                        new NestedIntegerValues(new NestedIntegerValue(9))),\\n                                new NestedIntegerValue(6))));\\n\\n        System.out.println(sample);\\n        NestedIteratorUsingStack iterator = new NestedIteratorUsingStack(sample);\\n        while (iterator.hasNext()) {\\n            System.out.print(iterator.next());\\n        }\\n    }\\n\\n    public static void testUsingStack2() {\\n        System.out.println();\\n        List<NestedInteger> sample2 = Arrays.asList(\\n                new NestedIntegerValue(1),\\n                new NestedIntegerValues(new NestedIntegerValue(4), new NestedIntegerValues(new NestedIntegerValue(6))));\\n\\n        System.out.println(sample2);\\n        NestedIteratorUsingStack iterator = new NestedIteratorUsingStack(sample2);\\n        while (iterator.hasNext()) {\\n            System.out.print(iterator.next());\\n        }\\n    }\\n\\n    public static void testUsingStack1() {\\n        System.out.println();\\n        List<NestedInteger> sample1 = Arrays.asList(\\n                new NestedIntegerValues(new NestedIntegerValue(1), new NestedIntegerValue(1)),\\n                new NestedIntegerValue(2),\\n                new NestedIntegerValues(new NestedIntegerValue(1), new NestedIntegerValue(1)));\\n\\n        System.out.println(sample1);\\n        NestedIteratorUsingStack iterator = new NestedIteratorUsingStack(sample1);\\n        while (iterator.hasNext()) {\\n            System.out.print(iterator.next());\\n        }\\n    }\\n}\\n```\\n\\nclasses\\n\\n```\\npublic interface NestedInteger\\n{\\n    /** @return true if this LinkedInt.NestedInteger holds a single integer, rather than a nested list */\\n    boolean isInteger();\\n\\n    /** @return the single integer that this LinkedInt.NestedInteger holds, if it holds a single integer\\n     * Return null if this LinkedInt.NestedInteger holds a nested list */\\n    Integer getInteger();\\n\\n    /** @return the nested list that this LinkedInt.NestedInteger holds, if it holds a nested list\\n     * Return null if this LinkedInt.NestedInteger holds a single integer */\\n    List<NestedInteger> getList();\\n}\\n\\n\\n```\\n\\n\\nand \\n\\n```\\npublic class NestedIntegerValue implements NestedInteger {\\n\\n    Integer value;\\n\\n    public NestedIntegerValue(Integer v){\\n        value = v;\\n    }\\n\\n    @Override\\n    public boolean isInteger() {\\n        return true;\\n    }\\n\\n    @Override\\n    public Integer getInteger() {\\n        return value;\\n    }\\n\\n    @Override\\n    public List<NestedInteger> getList() {\\n        return new ArrayList<>();\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return value.toString();\\n    }\\n}\\n\\n```\\n\\n\\nand \\n```\\npublic class NestedIntegerValues implements NestedInteger {\\n\\n    List<NestedInteger> values;\\n\\n\\n    public NestedIntegerValues(NestedInteger... values) {\\n        this.values = Arrays.asList(values);\\n    }\\n\\n    @Override\\n    public boolean isInteger() {\\n        return false;\\n    }\\n\\n    @Override\\n    public Integer getInteger() {\\n        return null;\\n    }\\n\\n    @Override\\n    public List<NestedInteger> getList() {\\n        return values;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        StringBuffer buff = new StringBuffer();\\n        buff.append(\\'{\\');\\n        values.forEach(v -> {\\n            buff.append(v.toString());\\n            buff.append(\\',\\');\\n        });\\n        buff.setCharAt(buff.length() - 1, \\'}\\');\\n        return buff.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n/**\\n * This is the smartest one and easiest of them all.\\n * We basically process the given list and store all the values;\\n * <p>\\n * Advantages:\\n * 1. Its fast\\n * 2. this is fail safe iterator, means it won\\'t throw concurrent modification exception\\n * 3. good choice for multi threading\\n * <p>\\n * Disadvantages:\\n * 1. This occupy lot of extra space, and\\n * 2. this is not lazy in its behaviour rather proactive\\n */\\nclass NestedIteratorUsingList implements Iterator<Integer> {\\n\\n    /**\\n     * use to store the elements from given list\\n     */\\n    private List<Integer> elements = new ArrayList<>();\\n\\n    /**\\n     * to keep track the element which need to show\\n     */\\n    int index = 0;\\n\\n    public NestedIteratorUsingList(List<NestedInteger> nestedList) {\\n\\n        init(nestedList);\\n    }\\n\\n    /**\\n     * store them recursively\\n     *\\n     * @param nestedList\\n     */\\n    private void init(List<NestedInteger> nestedList) {\\n        if (nestedList.isEmpty())\\n            return;\\n\\n        for (NestedInteger nst : nestedList) {\\n\\n            if (!nst.isInteger()) {\\n                init(nst.getList());\\n\\n            } else\\n                elements.add(nst.getInteger());\\n        }\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return elements.get(index++);\\n\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        if (index < this.elements.size())\\n            return true;\\n        else\\n            return false;\\n    }\\n}\\n\\n\\n/**\\n * This is second variation of above algorithm, everything on above algorithm apply, apply on this too.\\n * 1. Interviewer might ask you to use some inbuilt data structure if need.\\n * We are just mimicking the queue in above solution, this true queue based solution\\n * 2. Interviewer might ask you to minimize the overall process of processing\\n * <p>\\n * Neat and clean\\n */\\nclass NestedIteratorUsingQueue implements Iterator<Integer> {\\n\\n    private Queue<Integer> queue;\\n\\n    public NestedIteratorUsingQueue(List<NestedInteger> nestedList) {\\n\\n        queue = new LinkedList<>();\\n        init(nestedList);\\n    }\\n\\n    private void init(List<NestedInteger> nestedList) {\\n        if (nestedList.isEmpty())\\n            return;\\n\\n        for (NestedInteger nst : nestedList) {\\n\\n            if (!nst.isInteger()) {\\n                init(nst.getList());\\n\\n            } else\\n                queue.offer(nst.getInteger());\\n        }\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return queue.poll();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return !queue.isEmpty();\\n    }\\n}\\n\\n/**\\n * This is another approach, which is lazy in nature. It has advantages on memory usage.\\n */\\nclass NestedIteratorUsingStack implements Iterator<Integer> {\\n\\n    /**\\n     * keep a stack for which element we need to print\\n     */\\n    private Stack<NestedInteger> stack;\\n\\n    public NestedIteratorUsingStack(List<NestedInteger> nestedList) {\\n\\n        if (nestedList.isEmpty())\\n            return;\\n\\n        stack = new Stack<>();\\n\\n        /**\\n         * since we need to show from left to right direction, simply push all the elements in reverse order initially\\n         */\\n        for (int i = nestedList.size() - 1; i >= 0; i--)\\n            stack.push(nestedList.get(i));\\n    }\\n\\n\\n    @Override\\n    public Integer next() {\\n\\n        return stack.pop().getInteger();\\n\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        /**\\n         * based on top, just process\\n         */\\n        while (!stack.isEmpty() && !stack.peek().isInteger()) {\\n            List<NestedInteger> nst = stack.pop().getList();\\n\\n            for (int i = nst.size() - 1; i >= 0; i--) {\\n                stack.push(nst.get(i));\\n            }\\n\\n\\n        }\\n        return !stack.isEmpty();\\n\\n    }\\n}\\n\\n\\n\\n```\n```\\n\\n\\npublic class FlattenNestedListIterator {\\n\\n\\n    public static void main(String args[]) {\\n        usingList();\\n        usingQueue();\\n        usingStack();\\n\\n    }\\n\\n    private static void usingStack() {\\n        System.out.println(\"\\\\nUsing stack \");\\n        testUsingStack1();\\n        testUsingStack2();\\n        testUsingStack3();\\n    }\\n\\n    private static void usingQueue() {\\n        System.out.println(\"\\\\nUsing queue \");\\n        testUsingQueue1();\\n        testUsingQueue2();\\n        testUsingQueue3();\\n    }\\n\\n    private static void usingList() {\\n        System.out.println(\"\\\\nUsing List \");\\n        test1();\\n        test2();\\n        test3();\\n    }\\n\\n    public static void test3() {\\n        System.out.println();\\n        List<NestedInteger> sample = Arrays.asList(\\n                new NestedIntegerValue(1),\\n                new NestedIntegerValues(new NestedIntegerValue(4),\\n                        new NestedIntegerValues(\\n                                new NestedIntegerValues(new NestedIntegerValue(9),\\n                                        new NestedIntegerValues(new NestedIntegerValue(9))),\\n                                new NestedIntegerValue(6))));\\n\\n        System.out.println(sample);\\n        NestedIteratorUsingList iterator = new NestedIteratorUsingList(sample);\\n        while (iterator.hasNext()) {\\n            System.out.print(iterator.next());\\n        }\\n    }\\n\\n    public static void test2() {\\n        System.out.println();\\n        List<NestedInteger> sample2 = Arrays.asList(\\n                new NestedIntegerValue(1),\\n                new NestedIntegerValues(new NestedIntegerValue(4), new NestedIntegerValues(new NestedIntegerValue(6))));\\n\\n        System.out.println(sample2);\\n        NestedIteratorUsingList iterator = new NestedIteratorUsingList(sample2);\\n        while (iterator.hasNext()) {\\n            System.out.print(iterator.next());\\n        }\\n    }\\n\\n    public static void test1() {\\n        System.out.println();\\n        List<NestedInteger> sample1 = Arrays.asList(\\n                new NestedIntegerValues(new NestedIntegerValue(1), new NestedIntegerValue(1)),\\n                new NestedIntegerValue(2),\\n                new NestedIntegerValues(new NestedIntegerValue(1), new NestedIntegerValue(1)));\\n\\n        System.out.println(sample1);\\n        NestedIteratorUsingList iterator = new NestedIteratorUsingList(sample1);\\n        while (iterator.hasNext()) {\\n            System.out.print(iterator.next());\\n        }\\n    }\\n\\n\\n    public static void testUsingQueue3() {\\n        System.out.println();\\n        List<NestedInteger> sample = Arrays.asList(\\n                new NestedIntegerValue(1),\\n                new NestedIntegerValues(new NestedIntegerValue(4),\\n                        new NestedIntegerValues(\\n                                new NestedIntegerValues(new NestedIntegerValue(9),\\n                                        new NestedIntegerValues(new NestedIntegerValue(9))),\\n                                new NestedIntegerValue(6))));\\n\\n        System.out.println(sample);\\n        NestedIteratorUsingQueue iterator = new NestedIteratorUsingQueue(sample);\\n        while (iterator.hasNext()) {\\n            System.out.print(iterator.next());\\n        }\\n    }\\n\\n    public static void testUsingQueue2() {\\n        System.out.println();\\n        List<NestedInteger> sample2 = Arrays.asList(\\n                new NestedIntegerValue(1),\\n                new NestedIntegerValues(new NestedIntegerValue(4), new NestedIntegerValues(new NestedIntegerValue(6))));\\n\\n        System.out.println(sample2);\\n        NestedIteratorUsingQueue iterator = new NestedIteratorUsingQueue(sample2);\\n        while (iterator.hasNext()) {\\n            System.out.print(iterator.next());\\n        }\\n    }\\n\\n    public static void testUsingQueue1() {\\n        System.out.println();\\n        List<NestedInteger> sample1 = Arrays.asList(\\n                new NestedIntegerValues(new NestedIntegerValue(1), new NestedIntegerValue(1)),\\n                new NestedIntegerValue(2),\\n                new NestedIntegerValues(new NestedIntegerValue(1), new NestedIntegerValue(1)));\\n\\n        System.out.println(sample1);\\n        NestedIteratorUsingQueue iterator = new NestedIteratorUsingQueue(sample1);\\n        while (iterator.hasNext()) {\\n            System.out.print(iterator.next());\\n        }\\n    }\\n\\n\\n    public static void testUsingStack3() {\\n        System.out.println();\\n        List<NestedInteger> sample = Arrays.asList(\\n                new NestedIntegerValue(1),\\n                new NestedIntegerValues(new NestedIntegerValue(4),\\n                        new NestedIntegerValues(\\n                                new NestedIntegerValues(new NestedIntegerValue(9),\\n                                        new NestedIntegerValues(new NestedIntegerValue(9))),\\n                                new NestedIntegerValue(6))));\\n\\n        System.out.println(sample);\\n        NestedIteratorUsingStack iterator = new NestedIteratorUsingStack(sample);\\n        while (iterator.hasNext()) {\\n            System.out.print(iterator.next());\\n        }\\n    }\\n\\n    public static void testUsingStack2() {\\n        System.out.println();\\n        List<NestedInteger> sample2 = Arrays.asList(\\n                new NestedIntegerValue(1),\\n                new NestedIntegerValues(new NestedIntegerValue(4), new NestedIntegerValues(new NestedIntegerValue(6))));\\n\\n        System.out.println(sample2);\\n        NestedIteratorUsingStack iterator = new NestedIteratorUsingStack(sample2);\\n        while (iterator.hasNext()) {\\n            System.out.print(iterator.next());\\n        }\\n    }\\n\\n    public static void testUsingStack1() {\\n        System.out.println();\\n        List<NestedInteger> sample1 = Arrays.asList(\\n                new NestedIntegerValues(new NestedIntegerValue(1), new NestedIntegerValue(1)),\\n                new NestedIntegerValue(2),\\n                new NestedIntegerValues(new NestedIntegerValue(1), new NestedIntegerValue(1)));\\n\\n        System.out.println(sample1);\\n        NestedIteratorUsingStack iterator = new NestedIteratorUsingStack(sample1);\\n        while (iterator.hasNext()) {\\n            System.out.print(iterator.next());\\n        }\\n    }\\n}\\n```\n```\\npublic interface NestedInteger\\n{\\n    /** @return true if this LinkedInt.NestedInteger holds a single integer, rather than a nested list */\\n    boolean isInteger();\\n\\n    /** @return the single integer that this LinkedInt.NestedInteger holds, if it holds a single integer\\n     * Return null if this LinkedInt.NestedInteger holds a nested list */\\n    Integer getInteger();\\n\\n    /** @return the nested list that this LinkedInt.NestedInteger holds, if it holds a nested list\\n     * Return null if this LinkedInt.NestedInteger holds a single integer */\\n    List<NestedInteger> getList();\\n}\\n\\n\\n```\n```\\npublic class NestedIntegerValue implements NestedInteger {\\n\\n    Integer value;\\n\\n    public NestedIntegerValue(Integer v){\\n        value = v;\\n    }\\n\\n    @Override\\n    public boolean isInteger() {\\n        return true;\\n    }\\n\\n    @Override\\n    public Integer getInteger() {\\n        return value;\\n    }\\n\\n    @Override\\n    public List<NestedInteger> getList() {\\n        return new ArrayList<>();\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return value.toString();\\n    }\\n}\\n\\n```\n```\\npublic class NestedIntegerValues implements NestedInteger {\\n\\n    List<NestedInteger> values;\\n\\n\\n    public NestedIntegerValues(NestedInteger... values) {\\n        this.values = Arrays.asList(values);\\n    }\\n\\n    @Override\\n    public boolean isInteger() {\\n        return false;\\n    }\\n\\n    @Override\\n    public Integer getInteger() {\\n        return null;\\n    }\\n\\n    @Override\\n    public List<NestedInteger> getList() {\\n        return values;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        StringBuffer buff = new StringBuffer();\\n        buff.append(\\'{\\');\\n        values.forEach(v -> {\\n            buff.append(v.toString());\\n            buff.append(\\',\\');\\n        });\\n        buff.setCharAt(buff.length() - 1, \\'}\\');\\n        return buff.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80175,
                "title": "share-my-java-neat-solution-8ms",
                "content": "I feel my solution is pretty neat compared to the existing solutions, so I want to share it with you to provide some extra ingredients. Basically, I have similar idea as [StafanPochmann][1]'s [solution][2], but I feel to use listIterator seems overkill. So what I do is just to keep an additional field storing the next integer. Please check the code.\\n\\n    public class NestedIterator implements Iterator<Integer> {\\n        NestedInteger nextInt;\\n        Stack<Iterator<NestedInteger>> stack;\\n\\n        public NestedIterator(List<NestedInteger> nestedList) {\\n            stack = new Stack<Iterator<NestedInteger>>();\\n            stack.push(nestedList.iterator());\\n        }\\n\\n        @Override\\n        public Integer next() {\\n            return nextInt != null ? nextInt.getInteger() : null; //Just in case\\n        }\\n\\n        @Override\\n        public boolean hasNext() {\\n            while (!stack.isEmpty()) {\\n                if (!stack.peek().hasNext()) stack.pop();\\n                else if ((nextInt = stack.peek().next()).isInteger()) return true;\\n                else stack.push(nextInt.getList().iterator());\\n            }\\n            return false;\\n        }\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/user/StefanPochmann\\n  [2]: https://leetcode.com/discuss/95934/real-iterator-in-python-java-c",
                "solutionTags": [
                    "Java"
                ],
                "code": "I feel my solution is pretty neat compared to the existing solutions, so I want to share it with you to provide some extra ingredients. Basically, I have similar idea as [StafanPochmann][1]'s [solution][2], but I feel to use listIterator seems overkill. So what I do is just to keep an additional field storing the next integer. Please check the code.\\n\\n    public class NestedIterator implements Iterator<Integer> {\\n        NestedInteger nextInt;\\n        Stack<Iterator<NestedInteger>> stack;\\n\\n        public NestedIterator(List<NestedInteger> nestedList) {\\n            stack = new Stack<Iterator<NestedInteger>>();\\n            stack.push(nestedList.iterator());\\n        }\\n\\n        @Override\\n        public Integer next() {\\n            return nextInt != null ? nextInt.getInteger() : null; //Just in case\\n        }\\n\\n        @Override\\n        public boolean hasNext() {\\n            while (!stack.isEmpty()) {\\n                if (!stack.peek().hasNext()) stack.pop();\\n                else if ((nextInt = stack.peek().next()).isInteger()) return true;\\n                else stack.push(nextInt.getList().iterator());\\n            }\\n            return false;\\n        }\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/user/StefanPochmann\\n  [2]: https://leetcode.com/discuss/95934/real-iterator-in-python-java-c",
                "codeTag": "Java"
            },
            {
                "id": 80156,
                "title": "flatten-the-list-and-iterate-with-plain-next-and-hasnext-java",
                "content": "First flatten the list to a list of Integer by using DFS, then just call the plain <code>next()</code> and <code>hasNext()</code>\\n   \\n    public class NestedIterator implements Iterator<Integer> {\\n    \\n    private List<Integer> flattenedList;\\n    private Iterator<Integer> it;\\n  \\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        flattenedList = new LinkedList<Integer>();\\n        flatten(nestedList);\\n        it = flattenedList.iterator();\\n    }\\n\\n    private void flatten(List<NestedInteger> nestedList) {\\n        for (NestedInteger i : nestedList) {\\n            if (i.isInteger()) {\\n                flattenedList.add(i.getInteger());\\n            } else {\\n                flatten(i.getList());\\n            }\\n        }\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return it.next();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return it.hasNext();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "First flatten the list to a list of Integer by using DFS, then just call the plain <code>next()</code> and <code>hasNext()</code>\\n   \\n    public class NestedIterator implements Iterator<Integer> {\\n    \\n    private List<Integer> flattenedList;\\n    private Iterator<Integer> it;\\n  \\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        flattenedList = new LinkedList<Integer>();\\n        flatten(nestedList);\\n        it = flattenedList.iterator();\\n    }\\n\\n    private void flatten(List<NestedInteger> nestedList) {\\n        for (NestedInteger i : nestedList) {\\n            if (i.isInteger()) {\\n                flattenedList.add(i.getInteger());\\n            } else {\\n                flatten(i.getList());\\n            }\\n        }\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return it.next();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return it.hasNext();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 80247,
                "title": "python-generators-solution",
                "content": "    class NestedIterator(object):\\n    \\n        def __init__(self, nestedList):\\n            def gen(nestedList):\\n                for x in nestedList:\\n                    if x.isInteger():\\n                        yield x.getInteger()\\n                    else:\\n                        for y in gen(x.getList()):\\n                            yield y\\n            self.gen = gen(nestedList)\\n    \\n        def next(self):\\n            return self.value\\n    \\n        def hasNext(self):\\n            try:\\n                self.value = next(self.gen)\\n                return True\\n            except StopIteration:\\n                return False\\n\\nThis assumes that the iterator is just used as described in the problem. Usually, hasNext should be both optional and idempotent, but a next+hasNext iterator is very unpythonic anyway, so I decided to not do that here, as I feel it would distract from the generator.\\n\\nAnd of course while this solution is (IMHO) somewhat cute, it passes each value through each level it's nested in, so it's not efficient.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class NestedIterator(object):\\n    \\n        def __init__(self, nestedList):\\n            def gen(nestedList):\\n                for x in nestedList:\\n                    if x.isInteger():\\n                        yield x.getInteger()\\n                    else:\\n                        for y in gen(x.getList()):\\n                            yield y\\n            self.gen = gen(nestedList)\\n    \\n        def next(self):\\n            return self.value\\n    \\n        def hasNext(self):\\n            try:\\n                self.value = next(self.gen)\\n                return True\\n            except StopIteration:\\n                return False\\n\\nThis assumes that the iterator is just used as described in the problem. Usually, hasNext should be both optional and idempotent, but a next+hasNext iterator is very unpythonic anyway, so I decided to not do that here, as I feel it would distract from the generator.\\n\\nAnd of course while this solution is (IMHO) somewhat cute, it passes each value through each level it's nested in, so it's not efficient.",
                "codeTag": "Java"
            },
            {
                "id": 1156221,
                "title": "c-super-simple-and-short-solution",
                "content": "```\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        for (auto x : nestedList) {\\n            makeFlat(x);\\n        }\\n    }\\n    \\n    int next() {\\n        return flat[i++];\\n    }\\n    \\n    bool hasNext() {\\n        return i < flat.size();\\n    }\\n    \\nprivate:\\n    void makeFlat(NestedInteger x) {\\n        if (x.isInteger()) {\\n            flat.push_back(x.getInteger());\\n        }\\n        else {\\n            for (auto y : x.getList())\\n                makeFlat(y);\\n        }\\n    }\\n    \\n    vector<int> flat;\\n    int i = 0;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        for (auto x : nestedList) {\\n            makeFlat(x);\\n        }\\n    }\\n    \\n    int next() {\\n        return flat[i++];\\n    }\\n    \\n    bool hasNext() {\\n        return i < flat.size();\\n    }\\n    \\nprivate:\\n    void makeFlat(NestedInteger x) {\\n        if (x.isInteger()) {\\n            flat.push_back(x.getInteger());\\n        }\\n        else {\\n            for (auto y : x.getList())\\n                makeFlat(y);\\n        }\\n    }\\n    \\n    vector<int> flat;\\n    int i = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018816,
                "title": "python-generator-solution-with-explanation",
                "content": "### Introduction\\n\\nGiven an unknown implementation of a nested list structure containing integer values, design an iterator as a wrapper for the nested list structure which allows for 1) checking if a next value exists, and 2) obtaining of the next value in the iteration.\\n\\nI\\'d just like to note that the type hinting for the Python version of the `NestedIterator` class (Py3 at least) isn\\'t written very well; I had to resort to peeking at the data structure of the unknown `NestedInteger` class to get an idea of what we were dealing with behind the scenes. This is a big no-no for interviews especially since it\\'s explicitly stated that the implementation of `NestedInteger` should remain unknown to us; however, this was the only way forward for me.\\n\\nI have re-written the type-hinting for `nestedList` in `__init__()` from `[NestedInteger]` to `List[NestedInteger]` (which btw makes no sense to me; why would you not wrap everything into one `NestedInteger` object and pass that to `NestedIterator` instead); hopefully this helps anyone who stumbles onto the same problem.\\n\\n---\\n\\n### Explanation\\n\\nThere are many possible solutions; generator objects are unique (I think) to Python so this is the implementation I am going with. The benefit of generator objects is that **we are not required to store the entire (nested) list in memory and access it index-wise**; rather, the generator object allows us to step through each object in the iteration manually. This **saves on memory without compromising the speed at which we are able to iterate through the nested list structure**.\\n\\nFor more information on generator objects, I think [this article](https://www.programiz.com/python-programming/generator) is a good start.\\n\\n---\\n\\n### Implementation\\n\\n```python\\nclass NestedIterator:\\n    def __init__(self, nestedList: List[NestedInteger]):\\n        def get(currList: List[NestedInteger]) -> Generator[int, None, None]:\\n            \"\"\"\\n            Generator function to iterate through all nested NestedInteger objects and return its integer value.\\n            :param currList: The current (nested) list of NestedIntegers to iterate through.\\n            :yields:         The integer value of the current NestedInteger in the iteration.\\n            \"\"\"\\n            for nestedInteger in currList:\\n                if nestedInteger.isInteger():  # nestedInteger has a single integer value\\n                    yield nestedInteger.getInteger()\\n                else:                          # nestedInteger is a list of NestedIntegers\\n                    yield from get(nestedInteger.getList())\\n        self.generator = get(nestedList)               # Initialise the generator object with the given NestedInteger list\\n        self.nextInteger = next(self.generator, None)  # Obtain the next (first) NestedInteger pre-emptively\\n    \\n    def next(self) -> int:\\n        result = self.nextInteger                      # store the current NestedInteger integer value\\n        self.nextInteger = next(self.generator, None)  # Obtain the next NestedInteger pre-emptively\\n        return result\\n    \\n    def hasNext(self) -> bool:\\n        return self.nextInteger is not None\\n```\\n\\n**TC: O(1)** for all functions, since we are stepping through the iteration manually.\\n**SC: O(h)**, where `h` is the maximum depth of the nested list structure, due to implicit stack space used by the generator function.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass NestedIterator:\\n    def __init__(self, nestedList: List[NestedInteger]):\\n        def get(currList: List[NestedInteger]) -> Generator[int, None, None]:\\n            \"\"\"\\n            Generator function to iterate through all nested NestedInteger objects and return its integer value.\\n            :param currList: The current (nested) list of NestedIntegers to iterate through.\\n            :yields:         The integer value of the current NestedInteger in the iteration.\\n            \"\"\"\\n            for nestedInteger in currList:\\n                if nestedInteger.isInteger():  # nestedInteger has a single integer value\\n                    yield nestedInteger.getInteger()\\n                else:                          # nestedInteger is a list of NestedIntegers\\n                    yield from get(nestedInteger.getList())\\n        self.generator = get(nestedList)               # Initialise the generator object with the given NestedInteger list\\n        self.nextInteger = next(self.generator, None)  # Obtain the next (first) NestedInteger pre-emptively\\n    \\n    def next(self) -> int:\\n        result = self.nextInteger                      # store the current NestedInteger integer value\\n        self.nextInteger = next(self.generator, None)  # Obtain the next NestedInteger pre-emptively\\n        return result\\n    \\n    def hasNext(self) -> bool:\\n        return self.nextInteger is not None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156268,
                "title": "js-python-java-c-simple-queue-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThis problem is fairly straightforward, as long as we pay attention to the behavior of the **NestedInteger** class.\\n\\nIt is easiest to apply our flattening method (**flatten()**) during the class construction process, so that we only ever store the flattened list (**data**) in our class instance. Since there can be multiple layers of nesting, we should make **flatten** a **recursive** function.\\n\\nWith **flatten**, we should iterate through the given **list** and if the current element (**el**) is an integer we should push its contained value onto **data**, otherwise we should recursively call **flatten** on the nested list contained in **el**.\\n\\nOnce our **data** is successfully flattened, **next()** should be as easy as removing and returning the lead element of **data**. When **data** is reduced to a length of **0**, then **hasNext()** can **return false**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences between the code for all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **96ms / 48.8MB** (beats 96% / 100%).\\n```javascript\\nclass NestedIterator {\\n    constructor(nestedList) {\\n        this.data = []\\n        this.flatten(nestedList)\\n    };\\n    \\n    flatten(list) {\\n        for (let el of list)\\n            if (el.isInteger()) this.data.push(el.getInteger())\\n            else this.flatten(el.getList())\\n    };\\n    \\n    hasNext() { return this.data.length };\\n    \\n    next() { return this.data.shift() };\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **60ms / 17.4MB** (beats 93% / 95%).\\n```python\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.data = []\\n        self.flatten(nestedList)\\n        \\n    def flatten(self, lst):\\n        for el in lst:\\n            if el.isInteger(): self.data.append(el.getInteger())\\n            else: self.flatten(el.getList())\\n    \\n    def hasNext(self) -> bool: return len(self.data)\\n    \\n    def next(self) -> int: return self.data.pop(0)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **2ms / 40.9MB** (beats 97% / 96%).\\n```java\\npublic class NestedIterator implements Iterator<Integer> {\\n    Queue<Integer> data = new LinkedList<>();\\n\\n    public NestedIterator(List<NestedInteger> nestedList) { \\n        flatten(nestedList);\\n    }\\n    \\n    public void flatten(List<NestedInteger> list) {\\n        for (NestedInteger el : list)\\n            if (el.isInteger()) data.add(el.getInteger());\\n            else flatten(el.getList());\\n    }\\n\\n    public Integer next() { return data.poll(); }\\n\\n    public boolean hasNext() { return data.size() > 0; }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **8ms / 13.9MB** (beats 99% / 51%).\\n```c++\\nclass NestedIterator {\\nqueue<int> data;\\n    \\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        flatten(nestedList);\\n    }\\n    \\n    void flatten(vector<NestedInteger> &list) {\\n        for (NestedInteger el : list)\\n            if (el.isInteger()) data.push(el.getInteger());\\n            else flatten(el.getList());\\n    }\\n    \\n    int next() {\\n        int res = data.front(); data.pop();\\n        return res;\\n    }\\n    \\n    bool hasNext() { return data.size() > 0; }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nclass NestedIterator {\\n    constructor(nestedList) {\\n        this.data = []\\n        this.flatten(nestedList)\\n    };\\n    \\n    flatten(list) {\\n        for (let el of list)\\n            if (el.isInteger()) this.data.push(el.getInteger())\\n            else this.flatten(el.getList())\\n    };\\n    \\n    hasNext() { return this.data.length };\\n    \\n    next() { return this.data.shift() };\\n};\\n```\n```python\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.data = []\\n        self.flatten(nestedList)\\n        \\n    def flatten(self, lst):\\n        for el in lst:\\n            if el.isInteger(): self.data.append(el.getInteger())\\n            else: self.flatten(el.getList())\\n    \\n    def hasNext(self) -> bool: return len(self.data)\\n    \\n    def next(self) -> int: return self.data.pop(0)\\n```\n```java\\npublic class NestedIterator implements Iterator<Integer> {\\n    Queue<Integer> data = new LinkedList<>();\\n\\n    public NestedIterator(List<NestedInteger> nestedList) { \\n        flatten(nestedList);\\n    }\\n    \\n    public void flatten(List<NestedInteger> list) {\\n        for (NestedInteger el : list)\\n            if (el.isInteger()) data.add(el.getInteger());\\n            else flatten(el.getList());\\n    }\\n\\n    public Integer next() { return data.poll(); }\\n\\n    public boolean hasNext() { return data.size() > 0; }\\n}\\n```\n```c++\\nclass NestedIterator {\\nqueue<int> data;\\n    \\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        flatten(nestedList);\\n    }\\n    \\n    void flatten(vector<NestedInteger> &list) {\\n        for (NestedInteger el : list)\\n            if (el.isInteger()) data.push(el.getInteger());\\n            else flatten(el.getList());\\n    }\\n    \\n    int next() {\\n        int res = data.front(); data.pop();\\n        return res;\\n    }\\n    \\n    bool hasNext() { return data.size() > 0; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018329,
                "title": "java-clean",
                "content": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n\\n    private List<Integer> integerList = new ArrayList<>();\\n    private int index = 0;\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        for (NestedInteger nestedInteger : nestedList) {\\n            flatten(nestedInteger);\\n        }\\n    }\\n    \\n    private void flatten(NestedInteger nested) {\\n        if (nested.isInteger()) \\n            integerList.add(nested.getInteger());\\n        else \\n            for (NestedInteger nestedFromList : nested.getList()) {\\n                flatten(nestedFromList);\\n        }\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return index < integerList.size();\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return integerList.get(index++);\\n    }\\n}\\n```\\n\\nMy repositories with leetcode problems solving - [Java](https://github.com/FLlGHT/algorithms/tree/master/j-algorithms/src/main/java),  [C++](https://github.com/FLlGHT/algorithms/tree/master/c-algorithms/src/main/c%2B%2B)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n\\n    private List<Integer> integerList = new ArrayList<>();\\n    private int index = 0;\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        for (NestedInteger nestedInteger : nestedList) {\\n            flatten(nestedInteger);\\n        }\\n    }\\n    \\n    private void flatten(NestedInteger nested) {\\n        if (nested.isInteger()) \\n            integerList.add(nested.getInteger());\\n        else \\n            for (NestedInteger nestedFromList : nested.getList()) {\\n                flatten(nestedFromList);\\n        }\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return index < integerList.size();\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return integerList.get(index++);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156562,
                "title": "short-simple-code-c-solution-using-pointers-iterators-without-making-copies",
                "content": "In real-world scenarios, we can\\'t be sure that the data in the nested list would be as lightweight or primitive as integers. So it is important to be able to solve this question **without making copies of the real container / data-structure** and iterating over the original data itself.\\n\\n---\\n\\n***Solution - I (Using Pointers in C++) :***\\n\\n```\\nclass NestedIterator {\\npublic:\\n    stack<NestedInteger*> Start, End; // stores pointer to start & end of nested lists\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        Start.push(&nestedList.front());\\n        End.push(&nestedList.back());\\n    }\\n    // will only return the next integer and increment the pointer on top of stack\\n    int next() {\\n        return Start.top()++ -> getInteger();\\n    }\\n    // Returns true only if there\\'s more integer(s) yet to be traversed\\n\\t// If there are next integers, this function also ensures the stack top points to it\\n\\t// when size of stack becomes 0, we have traversed all of nestedList\\n    bool hasNext() {  \\n        while(size(Start)){\\n            auto top = Start.top();            \\n            if(Start.top() > End.top()){ // when a list is completely traversed\\n                Start.pop(), End.pop();\\n                continue;\\n            }                            \\n            if(top -> isInteger()) break;            \\n            Start.top()++;\\n            if(!size(top -> getList())) continue;\\n            Start.push(&top -> getList().front());  \\n            End.push(&top -> getList().back());\\n        }\\n        return size(Start);\\n    }\\n};\\n```\\n\\n---\\n\\n***Solution - II (Using Iterators in C++) :***\\n\\n```\\nclass NestedIterator {\\npublic:\\n    stack<vector<NestedInteger>::iterator> Start, End; // stores iterators to start & end of nested lists\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        Start.push(begin(nestedList)); // only storing the iterator to start of nestedList\\n        End.push(end(nestedList));     // required to detect if we reached end of nestedList\\n    }\\n    // will only return the next integer and increment the iterator\\n    int next() {\\n        return Start.top()++ -> getInteger();\\n    }\\n    /*  before next() is called, each time hasNext will make sure there exists a integer to return\\n\\t\\tIf there exists, it will make sure that top of stack points to it.\\n\\t\\tIf stack size becomes empty, all of nestedList is traversed\\n\\t*/\\n\\t    bool hasNext() {        \\n        while(size(Start)){\\t\\t\\t\\n            auto top = Start.top();            \\n\\t\\t\\t// If it is end of one of nested list, pop that list, so we can iterate over the next one\\n            if(Start.top() == End.top()){\\n                Start.pop(), End.pop();\\n                continue;\\n            }                \\n            if(top -> isInteger()) break;\\n\\t\\t\\t// if top is not integer, then it is definately a list\\n\\t\\t\\t// First increment top of stack, so we know that all integers uptill(including top list) now have been traversed\\n\\t\\t\\t// and then push the start iterator of top into stack, so that we traverse that one next\\n            Start.top()++;\\n            Start.push(begin(top -> getList()));  \\n            End.push(end(top -> getList()));\\n        }\\n\\t\\t// true will only be returned when stack top holds iterator of next integer\\n        return size(Start); \\n    }    \\n};\\n```\\n\\n---\\n\\n*Best Runtimes -*\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/e5cf0e4e-4086-411a-83dd-1a82b6e13a8b_1618322510.5969079.png /> </td> </tr></table>\\n\\nThis approach is **more efficient** than some other solutions which are making copies of real data or storing all the nested values at initialization itself. The advantage would be more obvious in scenarios where the real data is some complex data-type where making copies wouldn\\'t be viable (or even allowed).\\n\\n---\\n---\\n\\n\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any questions or mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---\\n",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass NestedIterator {\\npublic:\\n    stack<NestedInteger*> Start, End; // stores pointer to start & end of nested lists\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        Start.push(&nestedList.front());\\n        End.push(&nestedList.back());\\n    }\\n    // will only return the next integer and increment the pointer on top of stack\\n    int next() {\\n        return Start.top()++ -> getInteger();\\n    }\\n    // Returns true only if there\\'s more integer(s) yet to be traversed\\n\\t// If there are next integers, this function also ensures the stack top points to it\\n\\t// when size of stack becomes 0, we have traversed all of nestedList\\n    bool hasNext() {  \\n        while(size(Start)){\\n            auto top = Start.top();            \\n            if(Start.top() > End.top()){ // when a list is completely traversed\\n                Start.pop(), End.pop();\\n                continue;\\n            }                            \\n            if(top -> isInteger()) break;            \\n            Start.top()++;\\n            if(!size(top -> getList())) continue;\\n            Start.push(&top -> getList().front());  \\n            End.push(&top -> getList().back());\\n        }\\n        return size(Start);\\n    }\\n};\\n```\n```\\nclass NestedIterator {\\npublic:\\n    stack<vector<NestedInteger>::iterator> Start, End; // stores iterators to start & end of nested lists\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        Start.push(begin(nestedList)); // only storing the iterator to start of nestedList\\n        End.push(end(nestedList));     // required to detect if we reached end of nestedList\\n    }\\n    // will only return the next integer and increment the iterator\\n    int next() {\\n        return Start.top()++ -> getInteger();\\n    }\\n    /*  before next() is called, each time hasNext will make sure there exists a integer to return\\n\\t\\tIf there exists, it will make sure that top of stack points to it.\\n\\t\\tIf stack size becomes empty, all of nestedList is traversed\\n\\t*/\\n\\t    bool hasNext() {        \\n        while(size(Start)){\\t\\t\\t\\n            auto top = Start.top();            \\n\\t\\t\\t// If it is end of one of nested list, pop that list, so we can iterate over the next one\\n            if(Start.top() == End.top()){\\n                Start.pop(), End.pop();\\n                continue;\\n            }                \\n            if(top -> isInteger()) break;\\n\\t\\t\\t// if top is not integer, then it is definately a list\\n\\t\\t\\t// First increment top of stack, so we know that all integers uptill(including top list) now have been traversed\\n\\t\\t\\t// and then push the start iterator of top into stack, so that we traverse that one next\\n            Start.top()++;\\n            Start.push(begin(top -> getList()));  \\n            End.push(end(top -> getList()));\\n        }\\n\\t\\t// true will only be returned when stack top holds iterator of next integer\\n        return size(Start); \\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017509,
                "title": "easy-peasy-solution-c-recursion",
                "content": "```\\nclass NestedIterator {\\n    vector<int> v;\\n    int pos=0;\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        flatten(nestedList);\\n    }\\n    \\n    void flatten(vector<NestedInteger> &nestedList)\\n    {\\n        for(auto x : nestedList)\\n        {\\n            if(x.isInteger())\\n                v.push_back(x.getInteger());\\n            else\\n                flatten(x.getList());\\n        }\\n    }\\n    \\n    int next() {\\n        return v[pos++];\\n    }\\n    \\n    bool hasNext() {\\n        return pos < v.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass NestedIterator {\\n    vector<int> v;\\n    int pos=0;\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        flatten(nestedList);\\n    }\\n    \\n    void flatten(vector<NestedInteger> &nestedList)\\n    {\\n        for(auto x : nestedList)\\n        {\\n            if(x.isInteger())\\n                v.push_back(x.getInteger());\\n            else\\n                flatten(x.getList());\\n        }\\n    }\\n    \\n    int next() {\\n        return v[pos++];\\n    }\\n    \\n    bool hasNext() {\\n        return pos < v.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142999,
                "title": "load-data-on-next-instead-of-hasnext-java-ac-solution",
                "content": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n    private Stack<NestedInteger> stack;\\n\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        stack = new Stack<>();\\n        enstack(nestedList);\\n    }\\n    \\n    private void enstack(List<NestedInteger> list) {        \\n        for (int i = list.size() - 1; i >= 0; i--) {\\n            stack.push(list.get(i));\\n        }\\n        \\n        while (!stack.isEmpty() && !stack.peek().isInteger()) {\\n            enstack(stack.pop().getList());\\n        }\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        Integer res = stack.pop().getInteger();\\n        if (!stack.isEmpty() && !stack.peek().isInteger()) {\\n            enstack(stack.pop().getList());\\n        }\\n        return res;\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return !stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n    private Stack<NestedInteger> stack;\\n\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        stack = new Stack<>();\\n        enstack(nestedList);\\n    }\\n    \\n    private void enstack(List<NestedInteger> list) {        \\n        for (int i = list.size() - 1; i >= 0; i--) {\\n            stack.push(list.get(i));\\n        }\\n        \\n        while (!stack.isEmpty() && !stack.peek().isInteger()) {\\n            enstack(stack.pop().getList());\\n        }\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        Integer res = stack.pop().getInteger();\\n        if (!stack.isEmpty() && !stack.peek().isInteger()) {\\n            enstack(stack.pop().getList());\\n        }\\n        return res;\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return !stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156192,
                "title": "python-another-solution-using-deque-explained",
                "content": "There are a lot of different approaches, how you can solve this problem, starting with stack and ending with generators.\\n\\nHere I choose not very smart, but easy to code way: I used deque.\\n\\n1. First, we put all our nestedList structure to deque.\\n2. I use function `FixDeque`, which pop the left element from deque and put all elements of this nested list back to the left of our deque in opposite order.\\n3. Function `next` will look at first element of deque. If it is integer, we pop it and return in, in opposite case we fix our deque first and then run function recursively.\\n4. Function `hasNext` will try to fix our deque first if it needed to be fix and then check if it is empty or not.\\n\\n#### Complexity\\nTime complexity potentially `O(n+k)`, where `k` is number of brackets and `n` is number of numbers. Space complexity is the same.\\n\\n#### Code\\n```\\nclass NestedIterator:\\n    def __init__(self, nestedList):\\n        self.deq = deque(nestedList)\\n                        \\n    def FixDeque(self):\\n        last = self.deq.popleft()\\n        for e in last.getList()[::-1]:\\n            self.deq.appendleft(e)\\n        \\n    def next(self):\\n        first = self.deq[0]\\n        if first.isInteger():\\n            self.deq.popleft()\\n            return first.getInteger()\\n        else:\\n            self.FixDeque()\\n            return self.next()\\n    \\n    def hasNext(self):\\n        while self.deq and not self.deq[0].isInteger():\\n            self.FixDeque()\\n        return self.deq\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass NestedIterator:\\n    def __init__(self, nestedList):\\n        self.deq = deque(nestedList)\\n                        \\n    def FixDeque(self):\\n        last = self.deq.popleft()\\n        for e in last.getList()[::-1]:\\n            self.deq.appendleft(e)\\n        \\n    def next(self):\\n        first = self.deq[0]\\n        if first.isInteger():\\n            self.deq.popleft()\\n            return first.getInteger()\\n        else:\\n            self.FixDeque()\\n            return self.next()\\n    \\n    def hasNext(self):\\n        while self.deq and not self.deq[0].isInteger():\\n            self.FixDeque()\\n        return self.deq\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422191,
                "title": "clean-javascript-es6-generator-version",
                "content": "Reference: https://leetcode.com/problems/flatten-nested-list-iterator/discuss/124532/Short-Javascript-generator-solution\\n\\n```js\\nclass NestedIterator {\\n  constructor(nestedList) {\\n    this.gen = this.listGenerator(nestedList);\\n    this.nextVal = this.gen.next();\\n  }\\n\\n  hasNext() {\\n    return !this.nextVal.done;\\n  }\\n\\n  next() {\\n    const val = this.nextVal.value;\\n    this.nextVal = this.gen.next();\\n    return val;\\n  }\\n\\n  *listGenerator(list) {\\n    for (const el of list) {\\n      if (el.isInteger()) yield el.getInteger();\\n      else yield* this.listGenerator(el.getList());\\n    }\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nclass NestedIterator {\\n  constructor(nestedList) {\\n    this.gen = this.listGenerator(nestedList);\\n    this.nextVal = this.gen.next();\\n  }\\n\\n  hasNext() {\\n    return !this.nextVal.done;\\n  }\\n\\n  next() {\\n    const val = this.nextVal.value;\\n    this.nextVal = this.gen.next();\\n    return val;\\n  }\\n\\n  *listGenerator(list) {\\n    for (const el of list) {\\n      if (el.isInteger()) yield el.getInteger();\\n      else yield* this.listGenerator(el.getList());\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80362,
                "title": "simple-iteration-solution-in-c",
                "content": "    class NestedIterator {\\n        queue<int> myqueue;\\n    public:\\n        NestedIterator(vector<NestedInteger> &nestedList) {\\n            int n = nestedList.size();\\n            for(int i = 0; i < n; i++) {\\n                if(nestedList[i].isInteger()) {\\n                    myqueue.push(nestedList[i].getInteger());\\n                }\\n                else {\\n                    vector<NestedInteger> nest = nestedList[i].getList();\\n                    NestedIterator* tmp = new NestedIterator(nest);\\n                    while(tmp->hasNext()) {\\n                        myqueue.push(tmp->next());\\n                    }\\n                }\\n            }\\n        }\\n\\n        int next() {\\n            int tmp = myqueue.front();\\n            myqueue.pop();\\n            return tmp;\\n        }\\n\\n        bool hasNext() {\\n            return !myqueue.empty();\\n        }\\n    };",
                "solutionTags": [],
                "code": "    class NestedIterator {\\n        queue<int> myqueue;\\n    public:\\n        NestedIterator(vector<NestedInteger> &nestedList) {\\n            int n = nestedList.size();\\n            for(int i = 0; i < n; i++) {\\n                if(nestedList[i].isInteger()) {\\n                    myqueue.push(nestedList[i].getInteger());\\n                }\\n                else {\\n                    vector<NestedInteger> nest = nestedList[i].getList();\\n                    NestedIterator* tmp = new NestedIterator(nest);\\n                    while(tmp->hasNext()) {\\n                        myqueue.push(tmp->next());\\n                    }\\n                }\\n            }\\n        }\\n\\n        int next() {\\n            int tmp = myqueue.front();\\n            myqueue.pop();\\n            return tmp;\\n        }\\n\\n        bool hasNext() {\\n            return !myqueue.empty();\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 2019833,
                "title": "c-short-and-simple-solution-easily-understandable",
                "content": "```\\nclass NestedIterator {\\npublic:\\n    \\n    vector<int> res; //store final result\\n    int idx=0; //store index\\n    \\n    void flattenList(vector<NestedInteger> &nestedList)\\n    {\\n        for(auto x:nestedList)\\n        {\\n            //if x is int then push it into the vector res\\n            if(x.isInteger())\\n            {\\n                res.push_back(x.getInteger());\\n            }\\n            \\n            //if x is list then call the flattenList function again\\n            else\\n            {\\n                flattenList(x.getList());\\n            }\\n        }\\n    }\\n    \\n    NestedIterator(vector<NestedInteger> &nestedList) \\n    {\\n        //call the flattenList function to make the 1d array of whole nestedList\\n        flattenList(nestedList);\\n        \\n    }\\n    \\n    int next() \\n    {\\n        //return the value at index idx\\n        return res[idx++];   \\n    }\\n    \\n    bool hasNext() \\n    {\\n        //check whether next elements is available or not by checking index value is less than res size\\n        return idx<res.size();   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass NestedIterator {\\npublic:\\n    \\n    vector<int> res; //store final result\\n    int idx=0; //store index\\n    \\n    void flattenList(vector<NestedInteger> &nestedList)\\n    {\\n        for(auto x:nestedList)\\n        {\\n            //if x is int then push it into the vector res\\n            if(x.isInteger())\\n            {\\n                res.push_back(x.getInteger());\\n            }\\n            \\n            //if x is list then call the flattenList function again\\n            else\\n            {\\n                flattenList(x.getList());\\n            }\\n        }\\n    }\\n    \\n    NestedIterator(vector<NestedInteger> &nestedList) \\n    {\\n        //call the flattenList function to make the 1d array of whole nestedList\\n        flattenList(nestedList);\\n        \\n    }\\n    \\n    int next() \\n    {\\n        //return the value at index idx\\n        return res[idx++];   \\n    }\\n    \\n    bool hasNext() \\n    {\\n        //check whether next elements is available or not by checking index value is less than res size\\n        return idx<res.size();   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018125,
                "title": "c-recursion",
                "content": "```\\nclass NestedIterator {\\n    int curr=0;\\n    vector<int> flattenList;\\npublic:\\n    \\n    void helperFunc(vector<NestedInteger> &nestedList){\\n        \\n        int n=nestedList.size(),temp;        \\n        vector<NestedInteger> temp2;\\n        \\n        for(int i=0;i<n;i++){\\n            if(nestedList[i].isInteger()){\\n                temp=nestedList[i].getInteger();\\n                flattenList.push_back(temp);\\n            }else{\\n                temp2=nestedList[i].getList();\\n                helperFunc(temp2);\\n            }\\n        } \\n        \\n    }\\n    \\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n          helperFunc(nestedList);             \\n    }\\n    \\n    int next() {\\n        \\n        int ans=flattenList[curr];\\n        curr++;\\n        return ans;\\n        \\n    }\\n    \\n    bool hasNext() {\\n        if(curr==flattenList.size()) return false;    \\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass NestedIterator {\\n    int curr=0;\\n    vector<int> flattenList;\\npublic:\\n    \\n    void helperFunc(vector<NestedInteger> &nestedList){\\n        \\n        int n=nestedList.size(),temp;        \\n        vector<NestedInteger> temp2;\\n        \\n        for(int i=0;i<n;i++){\\n            if(nestedList[i].isInteger()){\\n                temp=nestedList[i].getInteger();\\n                flattenList.push_back(temp);\\n            }else{\\n                temp2=nestedList[i].getList();\\n                helperFunc(temp2);\\n            }\\n        } \\n        \\n    }\\n    \\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n          helperFunc(nestedList);             \\n    }\\n    \\n    int next() {\\n        \\n        int ans=flattenList[curr];\\n        curr++;\\n        return ans;\\n        \\n    }\\n    \\n    bool hasNext() {\\n        if(curr==flattenList.size()) return false;    \\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 124532,
                "title": "short-javascript-generator-solution",
                "content": "I saw couple similar solutions posted already, but wanted to share mine as it\\'s a bit more concise compared to others. Passes around 90% of other JS submissions.\\n\\n```\\nfunction* listGenerator(nestedList) {\\n    for (let el of nestedList) {\\n        if (el.isInteger()) {\\n            yield el.getInteger();\\n        } else {\\n            yield* listGenerator(el.getList());\\n        }\\n    }\\n}\\n\\nvar NestedIterator = function(nestedList) {\\n    this._gen = listGenerator(nestedList);\\n    this._val = this._gen.next();\\n};\\n\\nNestedIterator.prototype.hasNext = function() {\\n    return !this._val.done;\\n};\\n\\nNestedIterator.prototype.next = function() {\\n    var num = this._val.value;\\n    this._val = this._gen.next();\\n    return num;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction* listGenerator(nestedList) {\\n    for (let el of nestedList) {\\n        if (el.isInteger()) {\\n            yield el.getInteger();\\n        } else {\\n            yield* listGenerator(el.getList());\\n        }\\n    }\\n}\\n\\nvar NestedIterator = function(nestedList) {\\n    this._gen = listGenerator(nestedList);\\n    this._val = this._gen.next();\\n};\\n\\nNestedIterator.prototype.hasNext = function() {\\n    return !this._val.done;\\n};\\n\\nNestedIterator.prototype.next = function() {\\n    var num = this._val.value;\\n    this._val = this._gen.next();\\n    return num;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 675365,
                "title": "c-o-1-space-complexity-no-queue-stack",
                "content": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\n\\nclass NestedIterator {\\npublic:\\n    vector<NestedInteger> &data;\\n    int currentInd = 0;\\n    NestedIterator *it = nullptr;\\n    \\n    NestedIterator(vector<NestedInteger> &nestedList):data(nestedList) {\\n    }\\n    \\n    int next() {\\n        if(data[currentInd].isInteger())\\n            return data[currentInd++].getInteger();\\n        \\n        return it->next();\\n    }\\n    \\n    bool hasNext() {\\n        while(data.size() > currentInd){\\n            if(data[currentInd].isInteger())\\n                return true;\\n            \\n            if(it==nullptr)\\n                it = new NestedIterator(data[currentInd].getList());  \\n            \\n            if(it->hasNext())\\n                return true;\\n            \\n            delete it;\\n            it = nullptr;\\n            \\n            currentInd++;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your NestedIterator object will be instantiated and called as such:\\n * NestedIterator i(nestedList);\\n * while (i.hasNext()) cout << i.next();\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\n\\nclass NestedIterator {\\npublic:\\n    vector<NestedInteger> &data;\\n    int currentInd = 0;\\n    NestedIterator *it = nullptr;\\n    \\n    NestedIterator(vector<NestedInteger> &nestedList):data(nestedList) {\\n    }\\n    \\n    int next() {\\n        if(data[currentInd].isInteger())\\n            return data[currentInd++].getInteger();\\n        \\n        return it->next();\\n    }\\n    \\n    bool hasNext() {\\n        while(data.size() > currentInd){\\n            if(data[currentInd].isInteger())\\n                return true;\\n            \\n            if(it==nullptr)\\n                it = new NestedIterator(data[currentInd].getList());  \\n            \\n            if(it->hasNext())\\n                return true;\\n            \\n            delete it;\\n            it = nullptr;\\n            \\n            currentInd++;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your NestedIterator object will be instantiated and called as such:\\n * NestedIterator i(nestedList);\\n * while (i.hasNext()) cout << i.next();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 148600,
                "title": "straight-forward-python-solution-no-stack-needed",
                "content": "```\\nfrom collections import deque\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type nestedList: List[NestedInteger]\\n        \"\"\"\\n        self.q=deque()\\n        self.flatten(nestedList)\\n                    \\n    def flatten(self,nestedList):\\n        for l in nestedList:\\n            if l.isInteger():\\n                self.q.append(l.getInteger())\\n            else:\\n                self.flatten(l.getList())\\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.q.popleft()\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return len(self.q)>0\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type nestedList: List[NestedInteger]\\n        \"\"\"\\n        self.q=deque()\\n        self.flatten(nestedList)\\n                    \\n    def flatten(self,nestedList):\\n        for l in nestedList:\\n            if l.isInteger():\\n                self.q.append(l.getInteger())\\n            else:\\n                self.flatten(l.getList())\\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.q.popleft()\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return len(self.q)>0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019060,
                "title": "c-easy-explanation-short-simple-o-n-daily-leetcoding-challenge-may-day-8",
                "content": "```\\nclass NestedIterator {\\npublic:\\n    vector<int> v;           // it will store the final ans\\n    int loc = 0;             // it will store the location\\n    \\n    void flatten(vector<NestedInteger> &nestedList)\\n    {\\n        for(auto x : nestedList)\\n        {\\n            // if it is integer then push it into the vector\\n            if(x.isInteger())\\n                v.push_back(x.getInteger());\\n            \\n            // if it is list then call the same function for list\\n            else\\n                flatten(x.getList());\\n        }\\n        \\n    }\\n    \\n    NestedIterator(vector<NestedInteger> &nestedList) \\n    {\\n        // just call thre function for iterating over the whole NestedInteger\\n        flatten(nestedList);\\n    }\\n    \\n    int next() \\n    {\\n        // just returning the value according to the location\\n        return v[loc++];\\n    }\\n    \\n    bool hasNext() \\n    {\\n        // return true if our loc is under vector size\\n        return (loc<v.size());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass NestedIterator {\\npublic:\\n    vector<int> v;           // it will store the final ans\\n    int loc = 0;             // it will store the location\\n    \\n    void flatten(vector<NestedInteger> &nestedList)\\n    {\\n        for(auto x : nestedList)\\n        {\\n            // if it is integer then push it into the vector\\n            if(x.isInteger())\\n                v.push_back(x.getInteger());\\n            \\n            // if it is list then call the same function for list\\n            else\\n                flatten(x.getList());\\n        }\\n        \\n    }\\n    \\n    NestedIterator(vector<NestedInteger> &nestedList) \\n    {\\n        // just call thre function for iterating over the whole NestedInteger\\n        flatten(nestedList);\\n    }\\n    \\n    int next() \\n    {\\n        // just returning the value according to the location\\n        return v[loc++];\\n    }\\n    \\n    bool hasNext() \\n    {\\n        // return true if our loc is under vector size\\n        return (loc<v.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511283,
                "title": "c-stack-solution",
                "content": "**Note**\\nFor an enumerable type (e.g., Array, List, etc.), we can use enumerator to retrieve its values. We can use ```GetEnumerator()``` to get the enumerator.\\n![image](https://assets.leetcode.com/users/images/15e13163-073d-4cae-88b8-eb464f5cffcc_1633734350.3798525.png)\\n\\nThe ```Enumerator``` implements the ```IEnumerator``` interface, which contains 3 members: ```Current```, ```MoveNext()``` and ```Reset()```.\\n- ```Current```: property that returns the element at the current position of the enumrator.\\n- ```MoveNext()```: move to the next element.\\n- ```Reset()```: set enumerator to its initial position.\\n\\n\\n**Implementation**\\n```\\npublic class NestedIterator {\\n    \\n    public Stack<IEnumerator<NestedInteger>> stack;\\n\\n    public NestedIterator(IList<NestedInteger> nestedList) {\\n        \\n        stack = new Stack<IEnumerator<NestedInteger>>();\\n        stack.Push(nestedList.GetEnumerator());\\n    }\\n\\n    public bool HasNext() {\\n        \\n        while(stack.Count > 0)\\n        {\\n            if(stack.Peek().MoveNext())\\n            {\\n                if(stack.Peek().Current.IsInteger())\\n                    return true;\\n                else\\n                    stack.Push(stack.Peek().Current.GetList().GetEnumerator());\\n            }\\n            else\\n                stack.Pop();\\n        }\\n        \\n        return false;\\n    }\\n\\n    public int Next() {\\n        \\n        return stack.Peek().Current.GetInteger();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```GetEnumerator()```\n```Enumerator```\n```IEnumerator```\n```Current```\n```MoveNext()```\n```Reset()```\n```Current```\n```MoveNext()```\n```Reset()```\n```\\npublic class NestedIterator {\\n    \\n    public Stack<IEnumerator<NestedInteger>> stack;\\n\\n    public NestedIterator(IList<NestedInteger> nestedList) {\\n        \\n        stack = new Stack<IEnumerator<NestedInteger>>();\\n        stack.Push(nestedList.GetEnumerator());\\n    }\\n\\n    public bool HasNext() {\\n        \\n        while(stack.Count > 0)\\n        {\\n            if(stack.Peek().MoveNext())\\n            {\\n                if(stack.Peek().Current.IsInteger())\\n                    return true;\\n                else\\n                    stack.Push(stack.Peek().Current.GetList().GetEnumerator());\\n            }\\n            else\\n                stack.Pop();\\n        }\\n        \\n        return false;\\n    }\\n\\n    public int Next() {\\n        \\n        return stack.Peek().Current.GetInteger();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156270,
                "title": "flatten-nested-list-iterator-js-python-java-c-simple-queue-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThis problem is fairly straightforward, as long as we pay attention to the behavior of the **NestedInteger** class.\\n\\nIt is easiest to apply our flattening method (**flatten()**) during the class construction process, so that we only ever store the flattened list (**data**) in our class instance. Since there can be multiple layers of nesting, we should make **flatten** a **recursive** function.\\n\\nWith **flatten**, we should iterate through the given **list** and if the current element (**el**) is an integer we should push its contained value onto **data**, otherwise we should recursively call **flatten** on the nested list contained in **el**.\\n\\nOnce our **data** is successfully flattened, **next()** should be as easy as removing and returning the lead element of **data**. When **data** is reduced to a length of **0**, then **hasNext()** can **return false**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences between the code for all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **96ms / 48.8MB** (beats 96% / 100%).\\n```javascript\\nclass NestedIterator {\\n    constructor(nestedList) {\\n        this.data = []\\n        this.flatten(nestedList)\\n    };\\n    \\n    flatten(list) {\\n        for (let el of list)\\n            if (el.isInteger()) this.data.push(el.getInteger())\\n            else this.flatten(el.getList())\\n    };\\n    \\n    hasNext() { return this.data.length };\\n    \\n    next() { return this.data.shift() };\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **60ms / 17.4MB** (beats 93% / 95%).\\n```python\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.data = []\\n        self.flatten(nestedList)\\n        \\n    def flatten(self, lst):\\n        for el in lst:\\n            if el.isInteger(): self.data.append(el.getInteger())\\n            else: self.flatten(el.getList())\\n    \\n    def hasNext(self) -> bool: return len(self.data)\\n    \\n    def next(self) -> int: return self.data.pop(0)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **2ms / 40.9MB** (beats 97% / 96%).\\n```java\\npublic class NestedIterator implements Iterator<Integer> {\\n    Queue<Integer> data = new LinkedList<>();\\n\\n    public NestedIterator(List<NestedInteger> nestedList) { \\n        flatten(nestedList);\\n    }\\n    \\n    public void flatten(List<NestedInteger> list) {\\n        for (NestedInteger el : list)\\n            if (el.isInteger()) data.add(el.getInteger());\\n            else flatten(el.getList());\\n    }\\n\\n    public Integer next() { return data.poll(); }\\n\\n    public boolean hasNext() { return data.size() > 0; }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **8ms / 13.9MB** (beats 99% / 51%).\\n```c++\\nclass NestedIterator {\\nqueue<int> data;\\n    \\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        flatten(nestedList);\\n    }\\n    \\n    void flatten(vector<NestedInteger> &list) {\\n        for (NestedInteger el : list)\\n            if (el.isInteger()) data.push(el.getInteger());\\n            else flatten(el.getList());\\n    }\\n    \\n    int next() {\\n        int res = data.front(); data.pop();\\n        return res;\\n    }\\n    \\n    bool hasNext() { return data.size() > 0; }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nclass NestedIterator {\\n    constructor(nestedList) {\\n        this.data = []\\n        this.flatten(nestedList)\\n    };\\n    \\n    flatten(list) {\\n        for (let el of list)\\n            if (el.isInteger()) this.data.push(el.getInteger())\\n            else this.flatten(el.getList())\\n    };\\n    \\n    hasNext() { return this.data.length };\\n    \\n    next() { return this.data.shift() };\\n};\\n```\n```python\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.data = []\\n        self.flatten(nestedList)\\n        \\n    def flatten(self, lst):\\n        for el in lst:\\n            if el.isInteger(): self.data.append(el.getInteger())\\n            else: self.flatten(el.getList())\\n    \\n    def hasNext(self) -> bool: return len(self.data)\\n    \\n    def next(self) -> int: return self.data.pop(0)\\n```\n```java\\npublic class NestedIterator implements Iterator<Integer> {\\n    Queue<Integer> data = new LinkedList<>();\\n\\n    public NestedIterator(List<NestedInteger> nestedList) { \\n        flatten(nestedList);\\n    }\\n    \\n    public void flatten(List<NestedInteger> list) {\\n        for (NestedInteger el : list)\\n            if (el.isInteger()) data.add(el.getInteger());\\n            else flatten(el.getList());\\n    }\\n\\n    public Integer next() { return data.poll(); }\\n\\n    public boolean hasNext() { return data.size() > 0; }\\n}\\n```\n```c++\\nclass NestedIterator {\\nqueue<int> data;\\n    \\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        flatten(nestedList);\\n    }\\n    \\n    void flatten(vector<NestedInteger> &list) {\\n        for (NestedInteger el : list)\\n            if (el.isInteger()) data.push(el.getInteger());\\n            else flatten(el.getList());\\n    }\\n    \\n    int next() {\\n        int res = data.front(); data.pop();\\n        return res;\\n    }\\n    \\n    bool hasNext() { return data.size() > 0; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017690,
                "title": "easy-to-understand-java-solution-using-arraylist",
                "content": "**Approach**\\n* create an empty array list that will store answer\\n* Iterate through the original arraylist \\n* check for the element in the array list if it is an integer append it in the result array list else it will be an list inside a list so call a helper function like *search* which will search for the integer in array lsit \\n* List which is in search fucntion can also have two thigns either an integer or another list \\n* if it is a integer append it in result\\n* else run a loop for the next list size and again recursively call helper function for that list.\\n\\n\\n **Now let the recursion do its Magic**\\n here is the code for the help.\\n please **upvote** if you liked it .\\n catch me on [LinkedIn](https://www.linkedin.com/in/ashutoshuniyal-012/)\\n```\\npublic class NestedIterator implements Iterator<Integer> {\\n    \\n    List<Integer> result = new ArrayList<>();\\n    int index=0; \\n\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        \\n        for(int i =0 ; i < nestedList.size(); i++)  \\n        {\\n            if(nestedList.get(i).isInteger())  \\n                result.add(nestedList.get(i).getInteger());\\n            else{\\n                search(nestedList.get(i));\\n            }\\n        }\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return result.get(index++);\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return index<result.size();\\n    }\\n    public void search(NestedInteger data){\\n        if(data.isInteger())\\n            result.add(data.getInteger());\\n        else{\\n            for(int i =0; i <data.getList().size();i++){\\n                search(data.getList().get(i));\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n    \\n    List<Integer> result = new ArrayList<>();\\n    int index=0; \\n\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        \\n        for(int i =0 ; i < nestedList.size(); i++)  \\n        {\\n            if(nestedList.get(i).isInteger())  \\n                result.add(nestedList.get(i).getInteger());\\n            else{\\n                search(nestedList.get(i));\\n            }\\n        }\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return result.get(index++);\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return index<result.size();\\n    }\\n    public void search(NestedInteger data){\\n        if(data.isInteger())\\n            result.add(data.getInteger());\\n        else{\\n            for(int i =0; i <data.getList().size();i++){\\n                search(data.getList().get(i));\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156573,
                "title": "flatten-nested-list-iterator-c-pointer-iterators-without-making-copies",
                "content": "In real-world scenarios, we can\\'t be sure that the data in the nested list would be as lightweight or primitive as integers. So it is important to be able to solve this question **without making copies of the real container / data-structure** and iterating over the original data itself.\\n\\n---\\n\\n***Solution - I (Using Pointers in C++) :***\\n\\n```\\nclass NestedIterator {\\npublic:\\n    stack<NestedInteger*> Start, End; // stores pointer to start & end of nested lists\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        Start.push(&nestedList.front());\\n        End.push(&nestedList.back());\\n    }\\n    // will only return the next integer and increment the pointer on top of stack\\n    int next() {\\n        return Start.top()++ -> getInteger();\\n    }\\n    // Returns true only if there\\'s more integer(s) yet to be traversed\\n\\t// If there are next integers, this function also ensures the stack top points to it\\n\\t// when size of stack becomes 0, we have traversed all of nestedList\\n    bool hasNext() {  \\n        while(size(Start)){\\n            auto top = Start.top();            \\n            if(Start.top() > End.top()){ // when a list is completely traversed\\n                Start.pop(), End.pop();\\n                continue;\\n            }                            \\n            if(top -> isInteger()) break;            \\n            Start.top()++;\\n            if(!size(top -> getList())) continue;\\n            Start.push(&top -> getList().front());  \\n            End.push(&top -> getList().back());\\n        }\\n        return size(Start);\\n    }\\n};\\n```\\n\\n---\\n\\n***Solution - II (Using Iterators in C++) :***\\n\\n```\\nclass NestedIterator {\\npublic:\\n    stack<vector<NestedInteger>::iterator> Start, End; // stores iterators to start & end of nested lists\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        Start.push(begin(nestedList)); // only storing the iterator to start of nestedList\\n        End.push(end(nestedList));     // required to detect if we reached end of nestedList\\n    }\\n    // will only return the next integer and increment the iterator\\n    int next() {\\n        return Start.top()++ -> getInteger();\\n    }\\n    /*  before next() is called, each time hasNext will make sure there exists a integer to return\\n\\t\\tIf there exists, it will make sure that top of stack points to it.\\n\\t\\tIf stack size becomes empty, all of nestedList is traversed\\n\\t*/\\n\\t    bool hasNext() {        \\n        while(size(Start)){\\t\\t\\t\\n            auto top = Start.top();            \\n\\t\\t\\t// If it is end of one of nested list, pop that list, so we can iterate over the next one\\n            if(Start.top() == End.top()){\\n                Start.pop(), End.pop();\\n                continue;\\n            }                \\n            if(top -> isInteger()) break;\\n\\t\\t\\t// if top is not integer, then it is definately a list\\n\\t\\t\\t// First increment top of stack, so we know that all integers uptill(including top list) now have been traversed\\n\\t\\t\\t// and then push the start iterator of top into stack, so that we traverse that one next\\n            Start.top()++;\\n            Start.push(begin(top -> getList()));  \\n            End.push(end(top -> getList()));\\n        }\\n\\t\\t// true will only be returned when stack top holds iterator of next integer\\n        return size(Start); \\n    }    \\n};\\n```\\n\\n---\\n\\n*Best Runtimes -*\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/e5cf0e4e-4086-411a-83dd-1a82b6e13a8b_1618322510.5969079.png /> </td> </tr></table>\\n\\nThis approach is **more efficient** than some other solutions which are making copies of real data or storing all the nested values at initialization itself. The advantage would be more obvious in scenarios where the real data is some complex data-type where making copies wouldn\\'t be viable (or even allowed).\\n\\n---\\n---\\n\\n\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any questions or mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---\\n",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass NestedIterator {\\npublic:\\n    stack<NestedInteger*> Start, End; // stores pointer to start & end of nested lists\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        Start.push(&nestedList.front());\\n        End.push(&nestedList.back());\\n    }\\n    // will only return the next integer and increment the pointer on top of stack\\n    int next() {\\n        return Start.top()++ -> getInteger();\\n    }\\n    // Returns true only if there\\'s more integer(s) yet to be traversed\\n\\t// If there are next integers, this function also ensures the stack top points to it\\n\\t// when size of stack becomes 0, we have traversed all of nestedList\\n    bool hasNext() {  \\n        while(size(Start)){\\n            auto top = Start.top();            \\n            if(Start.top() > End.top()){ // when a list is completely traversed\\n                Start.pop(), End.pop();\\n                continue;\\n            }                            \\n            if(top -> isInteger()) break;            \\n            Start.top()++;\\n            if(!size(top -> getList())) continue;\\n            Start.push(&top -> getList().front());  \\n            End.push(&top -> getList().back());\\n        }\\n        return size(Start);\\n    }\\n};\\n```\n```\\nclass NestedIterator {\\npublic:\\n    stack<vector<NestedInteger>::iterator> Start, End; // stores iterators to start & end of nested lists\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        Start.push(begin(nestedList)); // only storing the iterator to start of nestedList\\n        End.push(end(nestedList));     // required to detect if we reached end of nestedList\\n    }\\n    // will only return the next integer and increment the iterator\\n    int next() {\\n        return Start.top()++ -> getInteger();\\n    }\\n    /*  before next() is called, each time hasNext will make sure there exists a integer to return\\n\\t\\tIf there exists, it will make sure that top of stack points to it.\\n\\t\\tIf stack size becomes empty, all of nestedList is traversed\\n\\t*/\\n\\t    bool hasNext() {        \\n        while(size(Start)){\\t\\t\\t\\n            auto top = Start.top();            \\n\\t\\t\\t// If it is end of one of nested list, pop that list, so we can iterate over the next one\\n            if(Start.top() == End.top()){\\n                Start.pop(), End.pop();\\n                continue;\\n            }                \\n            if(top -> isInteger()) break;\\n\\t\\t\\t// if top is not integer, then it is definately a list\\n\\t\\t\\t// First increment top of stack, so we know that all integers uptill(including top list) now have been traversed\\n\\t\\t\\t// and then push the start iterator of top into stack, so that we traverse that one next\\n            Start.top()++;\\n            Start.push(begin(top -> getList()));  \\n            End.push(end(top -> getList()));\\n        }\\n\\t\\t// true will only be returned when stack top holds iterator of next integer\\n        return size(Start); \\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 122697,
                "title": "8-line-c-solution-using-queue-18-ms-beats-97",
                "content": "Very simple solution in which we are converting the nested array into a flattened queue. \\n\\nFor next() we can define the front of the queue as next element and for hasNext() we can check if the queue is empty or not.\\n\\n```\\nclass NestedIterator {\\nprivate:\\n    static queue<int> result;\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        for(NestedInteger& nestedInt : nestedList)\\n            if(nestedInt.isInteger())\\n                NestedIterator::result.push(nestedInt.getInteger());\\n            else\\n                NestedIterator(nestedInt.getList());\\n    }\\n\\n    int next() { \\n        int next = result.front();\\n        result.pop();\\n        return next; \\n    }\\n\\n    bool hasNext() { return (!result.empty()); }\\n};\\nqueue<int> NestedIterator::result;\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass NestedIterator {\\nprivate:\\n    static queue<int> result;\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        for(NestedInteger& nestedInt : nestedList)\\n            if(nestedInt.isInteger())\\n                NestedIterator::result.push(nestedInt.getInteger());\\n            else\\n                NestedIterator(nestedInt.getList());\\n    }\\n\\n    int next() { \\n        int next = result.front();\\n        result.pop();\\n        return next; \\n    }\\n\\n    bool hasNext() { return (!result.empty()); }\\n};\\nqueue<int> NestedIterator::result;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80404,
                "title": "simple-iterative-dfs-using-stack",
                "content": "    public class NestedIterator implements Iterator<Integer> {\\n        Stack<Iterator<NestedInteger>> stack = new Stack<>();\\n        Integer current = null;\\n        \\n        public NestedIterator(List<NestedInteger> nestedList) {\\n            if (nestedList != null) {\\n                stack.push(nestedList.iterator());\\n            }\\n        }\\n    \\n        @Override\\n        public Integer next() {\\n            return current;\\n        }\\n    \\n        @Override\\n        public boolean hasNext() {\\n            while (!stack.isEmpty()) {\\n                Iterator<NestedInteger> node = stack.peek();\\n        \\n                // This will clear out empty iterators.\\n                if (!node.hasNext()) {\\n                    stack.pop();\\n                    continue;\\n                }\\n                \\n                // If the value is an integer, done - load up and return.\\n                // Otherwise push the current list to the top of the stack and continue.\\n                NestedInteger value = node.next();\\n                if (value.isInteger()) {\\n                    current = value.getInteger();\\n                    return true;\\n                } else {\\n                    stack.push(value.getList().iterator());\\n                }\\n            }\\n            \\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public class NestedIterator implements Iterator<Integer> {\\n        Stack<Iterator<NestedInteger>> stack = new Stack<>();\\n        Integer current = null;\\n        \\n        public NestedIterator(List<NestedInteger> nestedList) {\\n            if (nestedList != null) {\\n                stack.push(nestedList.iterator());\\n            }\\n        }\\n    \\n        @Override\\n        public Integer next() {\\n            return current;\\n        }\\n    \\n        @Override\\n        public boolean hasNext() {\\n            while (!stack.isEmpty()) {\\n                Iterator<NestedInteger> node = stack.peek();\\n        \\n                // This will clear out empty iterators.\\n                if (!node.hasNext()) {\\n                    stack.pop();\\n                    continue;\\n                }\\n                \\n                // If the value is an integer, done - load up and return.\\n                // Otherwise push the current list to the top of the stack and continue.\\n                NestedInteger value = node.next();\\n                if (value.isInteger()) {\\n                    current = value.getInteger();\\n                    return true;\\n                } else {\\n                    stack.push(value.getList().iterator());\\n                }\\n            }\\n            \\n            return false;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3244963,
                "title": "341-time-90-75-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe NestedIterator class implements an iterator to flatten a nested list of integers. It has three methods:\\n\\n1. __init__(self, nestedList: List[NestedInteger]): Initializes the iterator with the nested list nestedList. It creates a deque to store the flattened integers, and calls the addInteger function to add integers to the deque.\\n\\n2. next(self) -> int: Returns the next integer in the nested list. It removes and returns the leftmost element from the deque using the popleft method.\\n\\n3. hasNext(self) -> bool: Returns true if there are still some integers in the nested list and false otherwise. It checks if the deque is not empty using the bool function.\\n\\n4. addInteger(self, nestedList: List[NestedInteger]) -> None: Adds integers to the deque. It takes a nested list as input, and iterates over its elements. If an element is an integer, it adds it to the deque using the append method. If an element is a list, it recursively calls the addInteger function to add integers to the deque.\\n\\n# Complexity\\n- Time complexity:\\n90.75%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NestedIterator:\\n  def __init__(self, nestedList: List[NestedInteger]):\\n    # Initialize a deque to store the flattened integers\\n    self.q = collections.deque()\\n    # Call the addInteger function to add integers to the deque\\n    self.addInteger(nestedList)\\n\\n  def next(self) -> int:\\n    # Remove and return the leftmost element from the deque\\n    return self.q.popleft()\\n\\n  def hasNext(self) -> bool:\\n    # Return True if the deque is not empty, False otherwise\\n    return bool(self.q)\\n\\n  def addInteger(self, nestedList: List[NestedInteger]) -> None:\\n    # Iterate over the elements in the nestedList\\n    for ni in nestedList:\\n      # If the element is an integer, add it to the deque\\n      if ni.isInteger():\\n        self.q.append(ni.getInteger())\\n      # If the element is a list, recursively call the addInteger function to add integers to the deque\\n      else:\\n        self.addInteger(ni.getList())\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass NestedIterator:\\n  def __init__(self, nestedList: List[NestedInteger]):\\n    # Initialize a deque to store the flattened integers\\n    self.q = collections.deque()\\n    # Call the addInteger function to add integers to the deque\\n    self.addInteger(nestedList)\\n\\n  def next(self) -> int:\\n    # Remove and return the leftmost element from the deque\\n    return self.q.popleft()\\n\\n  def hasNext(self) -> bool:\\n    # Return True if the deque is not empty, False otherwise\\n    return bool(self.q)\\n\\n  def addInteger(self, nestedList: List[NestedInteger]) -> None:\\n    # Iterate over the elements in the nestedList\\n    for ni in nestedList:\\n      # If the element is an integer, add it to the deque\\n      if ni.isInteger():\\n        self.q.append(ni.getInteger())\\n      # If the element is a list, recursively call the addInteger function to add integers to the deque\\n      else:\\n        self.addInteger(ni.getList())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017613,
                "title": "easy-and-clear-3-approach-x-x",
                "content": "<hr>\\n<hr>\\n\\n***USING QUEUE***\\n\\n<hr>\\n<hr>\\n\\n```\\npublic class NestedIterator implements Iterator<Integer> {\\n    Queue<Integer> q = new LinkedList();\\n\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        fillup(nestedList);\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        if(!q.isEmpty())\\n            return (Integer)q.poll();\\n            \\n        return null;\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return !q.isEmpty();\\n    }\\n    \\n    private void fillup(List<NestedInteger> nestedlist)\\n    {\\n        if(nestedlist == null)\\n            return;\\n        \\n        for(NestedInteger member:nestedlist)\\n        {\\n            if(member.isInteger())\\n            {\\n                q.offer(member.getInteger());\\n            }\\n            else\\n            {\\n                fillup(member.getList());\\n            }\\n        }\\n    }\\n}\\n```\\n\\n<hr>\\n<hr>\\n\\n***USING STACK***\\n\\n<hr>\\n<hr>\\n\\n```\\npublic class NestedIterator implements Iterator<Integer> {\\n    Stack<ListIterator<NestedInteger>> stack;\\n    NestedInteger cache;\\n    \\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        stack = new Stack<>();\\n        stack.push(nestedList.listIterator());\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return cache.getInteger();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        while (true) {\\n            if (stack.isEmpty()) break;\\n            if (!stack.peek().hasNext()) {\\n                stack.pop();\\n                continue;\\n            }\\n            \\n            cache = stack.peek().next();\\n            if (!cache.isInteger()) {\\n                stack.push(cache.getList().listIterator());\\n                continue;\\n            }\\n            \\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n<hr>\\n<hr>\\n\\n***USING ARRAYLIST***\\n\\n<hr>\\n<hr>\\n\\n```\\n public class NestedIterator implements Iterator<Integer> {\\n\\n         List<Integer> res = new ArrayList<>();\\n         int index = 0;\\n\\n     public NestedIterator(List<NestedInteger> nestedList) {\\n              res = helper(nestedList);\\n       }\\n\\n     private  List<Integer> helper(List<NestedInteger> list){\\n                List<Integer> cur = new ArrayList<>();\\n                for(NestedInteger x: list){\\n                       if(x.isInteger()) cur.add(x.getInteger());\\n                       else{\\n                              List<Integer> remain = helper(x.getList());\\n                              cur.addAll(remain);\\n                       }\\n               }\\n             return cur;\\n      }\\n      @Override\\n      public Integer next() {\\n              if(this.hasNext())\\n                     return res.get(index++);\\n             else return -1;\\n      }\\n\\n      @Override\\n     public boolean hasNext() {\\n               return index < res.size();\\n     }\\n}\\n```\\n\\n<hr>\\n<hr>",
                "solutionTags": [],
                "code": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n    Queue<Integer> q = new LinkedList();\\n\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        fillup(nestedList);\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        if(!q.isEmpty())\\n            return (Integer)q.poll();\\n            \\n        return null;\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return !q.isEmpty();\\n    }\\n    \\n    private void fillup(List<NestedInteger> nestedlist)\\n    {\\n        if(nestedlist == null)\\n            return;\\n        \\n        for(NestedInteger member:nestedlist)\\n        {\\n            if(member.isInteger())\\n            {\\n                q.offer(member.getInteger());\\n            }\\n            else\\n            {\\n                fillup(member.getList());\\n            }\\n        }\\n    }\\n}\\n```\n```\\npublic class NestedIterator implements Iterator<Integer> {\\n    Stack<ListIterator<NestedInteger>> stack;\\n    NestedInteger cache;\\n    \\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        stack = new Stack<>();\\n        stack.push(nestedList.listIterator());\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return cache.getInteger();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        while (true) {\\n            if (stack.isEmpty()) break;\\n            if (!stack.peek().hasNext()) {\\n                stack.pop();\\n                continue;\\n            }\\n            \\n            cache = stack.peek().next();\\n            if (!cache.isInteger()) {\\n                stack.push(cache.getList().listIterator());\\n                continue;\\n            }\\n            \\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\n public class NestedIterator implements Iterator<Integer> {\\n\\n         List<Integer> res = new ArrayList<>();\\n         int index = 0;\\n\\n     public NestedIterator(List<NestedInteger> nestedList) {\\n              res = helper(nestedList);\\n       }\\n\\n     private  List<Integer> helper(List<NestedInteger> list){\\n                List<Integer> cur = new ArrayList<>();\\n                for(NestedInteger x: list){\\n                       if(x.isInteger()) cur.add(x.getInteger());\\n                       else{\\n                              List<Integer> remain = helper(x.getList());\\n                              cur.addAll(remain);\\n                       }\\n               }\\n             return cur;\\n      }\\n      @Override\\n      public Integer next() {\\n              if(this.hasNext())\\n                     return res.get(index++);\\n             else return -1;\\n      }\\n\\n      @Override\\n     public boolean hasNext() {\\n               return index < res.size();\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 486261,
                "title": "python-solution-without-pre-processing-the-entire-list",
                "content": "It\\'s not necessary to pre-process the entire list and create a flatten copy of it , because the idea is to implement an iterator, this means you need to process and return the data when the user asks for them. Imagine the user instanciates the Iterator class, but he never asks if the iterator has some data (hasNext()), another situation is when you have 10 elements, but the user just gets 2 elements. That\\'s the reason I think is better to return and process on demand. This is my solution.\\n\\n```\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.__nestedList = nestedList\\n        self.__position = 0\\n        self.__lists = []\\n    \\n    def next(self) -> int:\\n        integer = self.__nestedList[self.__position].getInteger()\\n        self.__position += 1\\n        return integer\\n        \\n    \\n    def hasNext(self) -> bool:    \\n        while not self.__isComplete():\\n            currNode = self.__nestedList[self.__position]\\n            \\n            if currNode.isInteger():\\n                return True\\n            else:\\n                self.__position += 1\\n                self.__lists.append((self.__nestedList, self.__position))\\n                self.__position = 0\\n                self.__nestedList = currNode.getList()\\n            \\n        if self.__isComplete() and not self.__listEmpty():\\n            self.__nestedList, self.__position = self.__lists.pop()\\n            return self.hasNext()\\n                    \\n        return False\\n    \\n    def __listEmpty(self) -> bool:\\n        return len(self.__lists) == 0\\n    \\n    def __isComplete(self) -> bool:\\n        return self.__position >= len(self.__nestedList)\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.__nestedList = nestedList\\n        self.__position = 0\\n        self.__lists = []\\n    \\n    def next(self) -> int:\\n        integer = self.__nestedList[self.__position].getInteger()\\n        self.__position += 1\\n        return integer\\n        \\n    \\n    def hasNext(self) -> bool:    \\n        while not self.__isComplete():\\n            currNode = self.__nestedList[self.__position]\\n            \\n            if currNode.isInteger():\\n                return True\\n            else:\\n                self.__position += 1\\n                self.__lists.append((self.__nestedList, self.__position))\\n                self.__position = 0\\n                self.__nestedList = currNode.getList()\\n            \\n        if self.__isComplete() and not self.__listEmpty():\\n            self.__nestedList, self.__position = self.__lists.pop()\\n            return self.hasNext()\\n                    \\n        return False\\n    \\n    def __listEmpty(self) -> bool:\\n        return len(self.__lists) == 0\\n    \\n    def __isComplete(self) -> bool:\\n        return self.__position >= len(self.__nestedList)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094400,
                "title": "easy-approach-beginner-friendly-beats-others",
                "content": "\\n\\n# Code\\n```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\n\\nclass NestedIterator {\\npublic:\\n    vector<int>list;\\n    int idx;\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        listIterator(nestedList);\\n        idx=0;\\n    }\\n    void listIterator(vector<NestedInteger> &nestedList){\\n        for(int i=0;i<nestedList.size();i++){\\n            if(nestedList[i].isInteger()){\\n                list.push_back(nestedList[i].getInteger());\\n            }else{\\n                listIterator(nestedList[i].getList());\\n            }\\n        }\\n    }\\n    \\n    int next() {\\n        return list[idx++];\\n    }\\n    \\n    bool hasNext() {\\n        return idx<list.size();\\n    }\\n};\\n\\n\\n/**\\n * Your NestedIterator object will be instantiated and called as such:\\n * NestedIterator i(nestedList);\\n * while (i.hasNext()) cout << i.next();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Design"
                ],
                "code": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\n\\nclass NestedIterator {\\npublic:\\n    vector<int>list;\\n    int idx;\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        listIterator(nestedList);\\n        idx=0;\\n    }\\n    void listIterator(vector<NestedInteger> &nestedList){\\n        for(int i=0;i<nestedList.size();i++){\\n            if(nestedList[i].isInteger()){\\n                list.push_back(nestedList[i].getInteger());\\n            }else{\\n                listIterator(nestedList[i].getList());\\n            }\\n        }\\n    }\\n    \\n    int next() {\\n        return list[idx++];\\n    }\\n    \\n    bool hasNext() {\\n        return idx<list.size();\\n    }\\n};\\n\\n\\n/**\\n * Your NestedIterator object will be instantiated and called as such:\\n * NestedIterator i(nestedList);\\n * while (i.hasNext()) cout << i.next();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2018299,
                "title": "short-fast-and-simple-code-c",
                "content": "**Recursion:**\\n```Loop(List)```:\\nTo flatten the List traverse its elements:\\n* If the element is an Integer: Push it into answer vector\\n* Else the element is a List: Flatten it first -> Loop(List) ```//Recursion```\\n\\n**Code:**\\n\\n```\\nclass NestedIterator {\\npublic:\\n    vector<int> ans;\\n    int x=0;\\n    NestedIterator(vector<NestedInteger> &List) \\n    {\\n        Loop(List);\\n    }\\n    \\n    void Loop(vector<NestedInteger> &List)\\n    {\\n        int s=List.size();\\n        for(int i=0; i<s; i++)\\n            List[i].isInteger()?  ans.push_back(List[i].getInteger()) : Loop(List[i].getList());\\n    }\\n    \\n    int next() \\n    {\\n        return ans[x++];\\n    }\\n    \\n    bool hasNext() \\n    {\\n        return x < ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```Loop(List)```\n```//Recursion```\n```\\nclass NestedIterator {\\npublic:\\n    vector<int> ans;\\n    int x=0;\\n    NestedIterator(vector<NestedInteger> &List) \\n    {\\n        Loop(List);\\n    }\\n    \\n    void Loop(vector<NestedInteger> &List)\\n    {\\n        int s=List.size();\\n        for(int i=0; i<s; i++)\\n            List[i].isInteger()?  ans.push_back(List[i].getInteger()) : Loop(List[i].getList());\\n    }\\n    \\n    int next() \\n    {\\n        return ans[x++];\\n    }\\n    \\n    bool hasNext() \\n    {\\n        return x < ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699244,
                "title": "python-simple-recursive-solution",
                "content": "```\\n# \"\"\"\\n# This is the interface that allows for creating nested lists.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n#class NestedInteger:\\n#    def isInteger(self) -> bool:\\n#        \"\"\"\\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\\n#        \"\"\"\\n#\\n#    def getInteger(self) -> int:\\n#        \"\"\"\\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\\n#        Return None if this NestedInteger holds a nested list\\n#        \"\"\"\\n#\\n#    def getList(self) -> [NestedInteger]:\\n#        \"\"\"\\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\\n#        Return None if this NestedInteger holds a single integer\\n#        \"\"\"\\n\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        ## RC ##\\n        ## APPRAOCH : RECURSION / DFS ##\\n        \\n        self.queue = []\\n        self.flattenList(nestedList)\\n        \\n    def flattenList(self, nestedList):\\n        for item in nestedList:\\n            if(not item.isInteger()):\\n                self.flattenList(item.getList())\\n            else:\\n                self.queue.append(item.getInteger())\\n                \\n    def next(self) -> int:\\n        return self.queue.pop(0)\\n    \\n    def hasNext(self) -> bool:\\n         return len(self.queue) > 0\\n\\n# Your NestedIterator object will be instantiated and called as such:\\n# i, v = NestedIterator(nestedList), []\\n# while i.hasNext(): v.append(i.next())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# \"\"\"\\n# This is the interface that allows for creating nested lists.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n#class NestedInteger:\\n#    def isInteger(self) -> bool:\\n#        \"\"\"\\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\\n#        \"\"\"\\n#\\n#    def getInteger(self) -> int:\\n#        \"\"\"\\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\\n#        Return None if this NestedInteger holds a nested list\\n#        \"\"\"\\n#\\n#    def getList(self) -> [NestedInteger]:\\n#        \"\"\"\\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\\n#        Return None if this NestedInteger holds a single integer\\n#        \"\"\"\\n\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        ## RC ##\\n        ## APPRAOCH : RECURSION / DFS ##\\n        \\n        self.queue = []\\n        self.flattenList(nestedList)\\n        \\n    def flattenList(self, nestedList):\\n        for item in nestedList:\\n            if(not item.isInteger()):\\n                self.flattenList(item.getList())\\n            else:\\n                self.queue.append(item.getInteger())\\n                \\n    def next(self) -> int:\\n        return self.queue.pop(0)\\n    \\n    def hasNext(self) -> bool:\\n         return len(self.queue) > 0\\n\\n# Your NestedIterator object will be instantiated and called as such:\\n# i, v = NestedIterator(nestedList), []\\n# while i.hasNext(): v.append(i.next())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 582851,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\nRecursively `go()` flatten the array of nested integers `A` into a queue of integers `q`.\\n\\n*Javascript*\\n```\\nclass NestedIterator {\\n    constructor(A) {\\n        this.q = [];\\n        let go = A => {\\n            for (let x of A)\\n                if (x.isInteger())\\n                    this.q.push(x.getInteger());\\n                else\\n                    go(x.getList());\\n        };\\n        go(A);\\n    }\\n    next() {\\n        return this.q.shift();\\n    }\\n    hasNext() {\\n        return this.q.length;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &A) {\\n        go(A);\\n    }\\n    int next() {\\n        auto i = q.front(); q.pop();\\n        return i;\\n    }\\n    bool hasNext() {\\n        return !q.empty();\\n    }\\nprivate:\\n    queue<int> q;\\n    void go(const vector<NestedInteger> &A) {\\n        for (auto x: A)\\n            if (x.isInteger())\\n                q.push(x.getInteger());\\n            else\\n                go(x.getList());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass NestedIterator {\\n    constructor(A) {\\n        this.q = [];\\n        let go = A => {\\n            for (let x of A)\\n                if (x.isInteger())\\n                    this.q.push(x.getInteger());\\n                else\\n                    go(x.getList());\\n        };\\n        go(A);\\n    }\\n    next() {\\n        return this.q.shift();\\n    }\\n    hasNext() {\\n        return this.q.length;\\n    }\\n}\\n```\n```\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &A) {\\n        go(A);\\n    }\\n    int next() {\\n        auto i = q.front(); q.pop();\\n        return i;\\n    }\\n    bool hasNext() {\\n        return !q.empty();\\n    }\\nprivate:\\n    queue<int> q;\\n    void go(const vector<NestedInteger> &A) {\\n        for (auto x: A)\\n            if (x.isInteger())\\n                q.push(x.getInteger());\\n            else\\n                go(x.getList());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 302547,
                "title": "java-solution-faster-than-100-and-memory-less-than-100",
                "content": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n    \\n    private Queue<Integer> queue = new LinkedList<>();\\n    \\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        addToQueue(nestedList);\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return queue.poll();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return !queue.isEmpty();\\n    }\\n    \\n    private void addToQueue(List<NestedInteger> nestedList){\\n        if(nestedList.isEmpty()){\\n            return;\\n        }\\n        \\n        for(NestedInteger i : nestedList){\\n            if(i.isInteger()){\\n                queue.offer(i.getInteger());\\n            }else{\\n                addToQueue(i.getList());\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n    \\n    private Queue<Integer> queue = new LinkedList<>();\\n    \\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        addToQueue(nestedList);\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return queue.poll();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return !queue.isEmpty();\\n    }\\n    \\n    private void addToQueue(List<NestedInteger> nestedList){\\n        if(nestedList.isEmpty()){\\n            return;\\n        }\\n        \\n        for(NestedInteger i : nestedList){\\n            if(i.isInteger()){\\n                queue.offer(i.getInteger());\\n            }else{\\n                addToQueue(i.getList());\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017683,
                "title": "python-ideas-simply-explained",
                "content": "**Key Ideas:**\\n* \\xA0*init()*: First completely flatten the nested list so that it\\'s easy to  keeptrack of which element we\\'re are on\\n* \\xA0*next()*: Treating the list as a queue, simply dequeue the next element from the queue(/list)\\n* \\xA0*has_next()*: Is the flattened list empty or not?\\n\\n```\\n\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        \\n        def flatten(nested_list):\\n            res = []\\n            for e in nested_list:\\n                if e.isInteger():\\n                    res.append(e.getInteger())\\n                else:\\n                    res.extend(flatten(e.getList()))\\n            return res\\n        \\n        self.flat_list = flatten(nestedList)\\n        \\n    def next(self) -> int:\\n        return self.flat_list.pop(0)\\n    \\n    def hasNext(self) -> bool:\\n         return len(self.flat_list)>0\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        \\n        def flatten(nested_list):\\n            res = []\\n            for e in nested_list:\\n                if e.isInteger():\\n                    res.append(e.getInteger())\\n                else:\\n                    res.extend(flatten(e.getList()))\\n            return res\\n        \\n        self.flat_list = flatten(nestedList)\\n        \\n    def next(self) -> int:\\n        return self.flat_list.pop(0)\\n    \\n    def hasNext(self) -> bool:\\n         return len(self.flat_list)>0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1160058,
                "title": "c-solution-with-queue",
                "content": "```\\n// Runtime: 12 ms, faster than 91.59% of C++ online submissions for Flatten Nested List Iterator.\\n// Memory Usage: 12.8 MB, less than 90.97% of C++ online submissions for Flatten Nested List Iterator.\\n\\nqueue<int> qIntegers;\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        for (auto& niIt : nestedList) {\\n            if (niIt.isInteger()) \\n                qIntegers.push(niIt.getInteger());\\n            else\\n                NestedIterator(niIt.getList());\\n        }\\n    }\\n    \\n    int next() {\\n        int nextInt = qIntegers.front();\\n        qIntegers.pop();\\n        return nextInt;\\n    }\\n    \\n    bool hasNext() {\\n        return !qIntegers.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\n// Runtime: 12 ms, faster than 91.59% of C++ online submissions for Flatten Nested List Iterator.\\n// Memory Usage: 12.8 MB, less than 90.97% of C++ online submissions for Flatten Nested List Iterator.\\n\\nqueue<int> qIntegers;\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        for (auto& niIt : nestedList) {\\n            if (niIt.isInteger()) \\n                qIntegers.push(niIt.getInteger());\\n            else\\n                NestedIterator(niIt.getList());\\n        }\\n    }\\n    \\n    int next() {\\n        int nextInt = qIntegers.front();\\n        qIntegers.pop();\\n        return nextInt;\\n    }\\n    \\n    bool hasNext() {\\n        return !qIntegers.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157107,
                "title": "true-lazy-iterator-no-preps-in-constructor",
                "content": "```\\ntype NestedIterator struct {\\n\\tidx            int\\n\\tnestedIterator *NestedIterator\\n\\tnestedList     []*NestedInteger\\n}\\n\\nfunc Constructor(nestedList []*NestedInteger) *NestedIterator {\\n\\treturn &NestedIterator{\\n\\t\\tidx:        -1,\\n\\t\\tnestedList: nestedList,\\n\\t}\\n}\\n\\nfunc (ni *NestedIterator) Next() int {\\n\\tif nestedIterator := ni.nestedIterator; nestedIterator != nil {\\n\\t\\treturn nestedIterator.Next()\\n\\t}\\n\\n\\treturn ni.nestedList[ni.idx].GetInteger()\\n}\\n\\nfunc (ni *NestedIterator) HasNext() bool {\\n\\tif iterator := ni.nestedIterator; iterator != nil {\\n\\t\\tif iterator.HasNext() {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tni.nestedIterator = nil\\n\\t}\\n\\n\\tni.idx++\\n\\tif ni.idx == len(ni.nestedList) {\\n\\t\\treturn false\\n\\t}\\n\\n\\tif ni.nestedList[ni.idx].IsInteger() {\\n\\t\\treturn true\\n\\t}\\n\\tni.nestedIterator = Constructor(ni.nestedList[ni.idx].GetList())\\n\\treturn ni.HasNext()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype NestedIterator struct {\\n\\tidx            int\\n\\tnestedIterator *NestedIterator\\n\\tnestedList     []*NestedInteger\\n}\\n\\nfunc Constructor(nestedList []*NestedInteger) *NestedIterator {\\n\\treturn &NestedIterator{\\n\\t\\tidx:        -1,\\n\\t\\tnestedList: nestedList,\\n\\t}\\n}\\n\\nfunc (ni *NestedIterator) Next() int {\\n\\tif nestedIterator := ni.nestedIterator; nestedIterator != nil {\\n\\t\\treturn nestedIterator.Next()\\n\\t}\\n\\n\\treturn ni.nestedList[ni.idx].GetInteger()\\n}\\n\\nfunc (ni *NestedIterator) HasNext() bool {\\n\\tif iterator := ni.nestedIterator; iterator != nil {\\n\\t\\tif iterator.HasNext() {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tni.nestedIterator = nil\\n\\t}\\n\\n\\tni.idx++\\n\\tif ni.idx == len(ni.nestedList) {\\n\\t\\treturn false\\n\\t}\\n\\n\\tif ni.nestedList[ni.idx].IsInteger() {\\n\\t\\treturn true\\n\\t}\\n\\tni.nestedIterator = Constructor(ni.nestedList[ni.idx].GetList())\\n\\treturn ni.HasNext()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1153583,
                "title": "kotlin-with-yield",
                "content": "```\\nclass NestedIterator(nestedList: List<NestedInteger>) {\\n  private val iterator = iterate(nestedList)\\n  \\n  private fun iterate(nestedList: List<NestedInteger>): Iterator<Int> {\\n    return iterator {\\n      for (nested in nestedList) {\\n        nested.getInteger()?.let { yield(it) }\\n        nested.getList()?.let { yieldAll(iterate(it)) }\\n      }\\n    }\\n  }\\n  \\n  fun next() = iterator.next()\\n  fun hasNext() = iterator.hasNext()\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass NestedIterator(nestedList: List<NestedInteger>) {\\n  private val iterator = iterate(nestedList)\\n  \\n  private fun iterate(nestedList: List<NestedInteger>): Iterator<Int> {\\n    return iterator {\\n      for (nested in nestedList) {\\n        nested.getInteger()?.let { yield(it) }\\n        nested.getList()?.let { yieldAll(iterate(it)) }\\n      }\\n    }\\n  }\\n  \\n  fun next() = iterator.next()\\n  fun hasNext() = iterator.hasNext()\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238784,
                "title": "no-stack-no-preprocessing-simple-recursively-using-same-iterator",
                "content": "```\\nprivate class NestedIterator implements Iterator<Integer> {\\n        List<NestedInteger> list;\\n        Integer next = null;\\n        NestedIterator nextIterator = null;\\n\\n        int index = 0;\\n\\n        public NestedIterator(List<NestedInteger> nestedList) {\\n            list = nestedList;\\n            setNext();\\n        }\\n\\n        private void setNext() {\\n            next = null;\\n            while (next == null && index < list.size()) {\\n                if (list.get(index).isInteger()) {\\n                    next = list.get(index).getInteger();\\n                    index++;\\n                } else {\\n                    if (nextIterator == null) {\\n                        nextIterator = new NestedIterator(list.get(index).getList());\\n                    }\\n                    if (nextIterator.hasNext()) {\\n                        next = nextIterator.next();\\n                    } else {\\n                        nextIterator = null;\\n                        index++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        @Override\\n        public Integer next() {\\n            int result = next;\\n            setNext();\\n            return result;\\n        }\\n\\n        @Override\\n        public boolean hasNext() {\\n            return next != null;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate class NestedIterator implements Iterator<Integer> {\\n        List<NestedInteger> list;\\n        Integer next = null;\\n        NestedIterator nextIterator = null;\\n\\n        int index = 0;\\n\\n        public NestedIterator(List<NestedInteger> nestedList) {\\n            list = nestedList;\\n            setNext();\\n        }\\n\\n        private void setNext() {\\n            next = null;\\n            while (next == null && index < list.size()) {\\n                if (list.get(index).isInteger()) {\\n                    next = list.get(index).getInteger();\\n                    index++;\\n                } else {\\n                    if (nextIterator == null) {\\n                        nextIterator = new NestedIterator(list.get(index).getList());\\n                    }\\n                    if (nextIterator.hasNext()) {\\n                        next = nextIterator.next();\\n                    } else {\\n                        nextIterator = null;\\n                        index++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        @Override\\n        public Integer next() {\\n            int result = next;\\n            setNext();\\n            return result;\\n        }\\n\\n        @Override\\n        public boolean hasNext() {\\n            return next != null;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80172,
                "title": "one-of-the-testcases-maybe-wrong-for-c-language",
                "content": "I get a similar situation with the problem 251. Flatten 2D Vector.\\n\\nhttps://leetcode.com/discuss/68749/i-suspect-that-the-judge-is-wrong-for-c-language\\n\\nthe testcase begin with \\n\\n    [[-35,-73,-20,57,51,-14,102,73,-82,-25,-45,-90,95,68,27,-18,-29,-77,-3,-2,19,24,8,-55,-80,-55,-31,55,-95,-\\n\\nmaybe wrong for C language. it has 105 rows and total 10973 integers.\\n\\nMy c solution:\\n\\n    struct NestedIterator {\\n        struct NestedInteger ***stack;\\n        int *ind;\\n        int *size;\\n        int stackSize;\\n        int len;\\n        int cache;\\n    };\\n    \\n    struct NestedIterator *nestedIterCreate(struct NestedInteger** nestedList, int nestedListSize) {\\n        struct NestedIterator *iter = malloc(sizeof(struct NestedIterator));\\n        iter->stackSize = 1000;\\n        iter->stack = malloc(iter->stackSize * sizeof(struct NestedInteger **));\\n        iter->ind = malloc(iter->stackSize * sizeof(int));\\n        iter->size = malloc(iter->stackSize * sizeof(int));\\n        iter->len = 1;\\n        iter->stack[0] = nestedList;\\n        iter->ind[0] = 0;\\n        iter->size[0] = nestedListSize;\\n        return iter;\\n    }\\n    \\n    bool nestedIterHasNext(struct NestedIterator *iter) {\\n        if (!iter->len) return false;\\n        if (iter->ind[iter->len - 1] == iter->size[iter->len - 1]) {\\n            iter->len--;\\n            return nestedIterHasNext(iter);\\n        }\\n        struct NestedInteger **tgt = iter->stack[iter->len - 1][iter->ind[iter->len - 1]];\\n        if (NestedIntegerIsInteger(tgt)) return true;\\n        iter->ind[iter->len - 1]++;\\n        if (iter->len == iter->stackSize) {\\n            iter->stackSize += 1000;\\n            iter->stack = realloc(iter->stack, iter->stackSize * sizeof(struct NestedInteger **));\\n            iter->ind = realloc(iter->ind, iter->stackSize * sizeof(int));\\n            iter->size = realloc(iter->size, iter->stackSize * sizeof(int));\\n        }\\n        iter->stack[iter->len] = NestedIntegerGetList(tgt);;\\n        iter->ind[iter->len] = 0;\\n        iter->size[iter->len] = NestedIntegerGetListSize(tgt);\\n        iter->len++;\\n        return nestedIterHasNext(iter);\\n    }\\n    \\n    int nestedIterNext(struct NestedIterator *iter) {\\n        struct NestedInteger **tgt = iter->stack[iter->len - 1][iter->ind[iter->len - 1]];\\n        iter->ind[iter->len - 1]++;\\n        return NestedIntegerGetInteger(tgt);\\n    }\\n    \\n    /** Deallocates memory previously allocated for the iterator */\\n    void nestedIterFree(struct NestedIterator *iter) {\\n        free(iter->stack);\\n        free(iter->ind);\\n        free(iter->size);\\n        free(iter);\\n    }\\n    \\n    /**\\n     * Your NestedIterator will be called like this:\\n     * struct NestedIterator *i = nestedIterCreate(nestedList, nestedListSize);\\n     * while (nestedIterHasNext(i)) printf(\"%d\\\\n\", nestedIterNext(i));\\n     * nestedIterFree(i);\\n     */",
                "solutionTags": [],
                "code": "I get a similar situation with the problem 251. Flatten 2D Vector.\\n\\nhttps://leetcode.com/discuss/68749/i-suspect-that-the-judge-is-wrong-for-c-language\\n\\nthe testcase begin with \\n\\n    [[-35,-73,-20,57,51,-14,102,73,-82,-25,-45,-90,95,68,27,-18,-29,-77,-3,-2,19,24,8,-55,-80,-55,-31,55,-95,-\\n\\nmaybe wrong for C language. it has 105 rows and total 10973 integers.\\n\\nMy c solution:\\n\\n    struct NestedIterator {\\n        struct NestedInteger ***stack;\\n        int *ind;\\n        int *size;\\n        int stackSize;\\n        int len;\\n        int cache;\\n    };\\n    \\n    struct NestedIterator *nestedIterCreate(struct NestedInteger** nestedList, int nestedListSize) {\\n        struct NestedIterator *iter = malloc(sizeof(struct NestedIterator));\\n        iter->stackSize = 1000;\\n        iter->stack = malloc(iter->stackSize * sizeof(struct NestedInteger **));\\n        iter->ind = malloc(iter->stackSize * sizeof(int));\\n        iter->size = malloc(iter->stackSize * sizeof(int));\\n        iter->len = 1;\\n        iter->stack[0] = nestedList;\\n        iter->ind[0] = 0;\\n        iter->size[0] = nestedListSize;\\n        return iter;\\n    }\\n    \\n    bool nestedIterHasNext(struct NestedIterator *iter) {\\n        if (!iter->len) return false;\\n        if (iter->ind[iter->len - 1] == iter->size[iter->len - 1]) {\\n            iter->len--;\\n            return nestedIterHasNext(iter);\\n        }\\n        struct NestedInteger **tgt = iter->stack[iter->len - 1][iter->ind[iter->len - 1]];\\n        if (NestedIntegerIsInteger(tgt)) return true;\\n        iter->ind[iter->len - 1]++;\\n        if (iter->len == iter->stackSize) {\\n            iter->stackSize += 1000;\\n            iter->stack = realloc(iter->stack, iter->stackSize * sizeof(struct NestedInteger **));\\n            iter->ind = realloc(iter->ind, iter->stackSize * sizeof(int));\\n            iter->size = realloc(iter->size, iter->stackSize * sizeof(int));\\n        }\\n        iter->stack[iter->len] = NestedIntegerGetList(tgt);;\\n        iter->ind[iter->len] = 0;\\n        iter->size[iter->len] = NestedIntegerGetListSize(tgt);\\n        iter->len++;\\n        return nestedIterHasNext(iter);\\n    }\\n    \\n    int nestedIterNext(struct NestedIterator *iter) {\\n        struct NestedInteger **tgt = iter->stack[iter->len - 1][iter->ind[iter->len - 1]];\\n        iter->ind[iter->len - 1]++;\\n        return NestedIntegerGetInteger(tgt);\\n    }\\n    \\n    /** Deallocates memory previously allocated for the iterator */\\n    void nestedIterFree(struct NestedIterator *iter) {\\n        free(iter->stack);\\n        free(iter->ind);\\n        free(iter->size);\\n        free(iter);\\n    }\\n    \\n    /**\\n     * Your NestedIterator will be called like this:\\n     * struct NestedIterator *i = nestedIterCreate(nestedList, nestedListSize);\\n     * while (nestedIterHasNext(i)) printf(\"%d\\\\n\", nestedIterNext(i));\\n     * nestedIterFree(i);\\n     */",
                "codeTag": "Unknown"
            },
            {
                "id": 2018658,
                "title": "c-simple-solution-explained-using-recursion",
                "content": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\n\\n\\n//From the above NestedInteger interface defination we have 3 functions which we can use:\\n\\n//1) isInteger() : To check whether the element is integer or or a nested list, it returns true in case of integer\\n//2) getInteger(): Get that integer after using isInteger() method\\n//3) getList(): If isInteger() returns false, it means it is a nested list which we cant get from this method\\n\\n\\nclass NestedIterator {\\npublic:\\n\\n\\t//Initialize the global vector which will be our flatten list and our answer, which we will make by pushing elements\\n    vector<int> result;\\n\\t//Initialize the current iterator for the flatten list we declared above, to check if we are out of bounds or not for is hasNext() method\\n    int i = 0;\\n    \\n\\t\\n\\t//This is a recursive function\\n\\t// Why we are using recursion here ?\\n\\t// Ans: As in this test case nestedList = [1,[4,[6]]]\\n\\t\\n\\t// We start iterating the list, we found 4 as integer, we pushed it into our result vector.\\n\\t// Then we get a nested list, which infact has a nested list in itself [4, [6]],6 here is in nested list of this list\\n\\t\\n\\t// So, we check if an element is integer, we simply pushes that to our result\\n\\t// Otherwise if the element is a list we call the function recursively for this element\\n\\t// And if this list contains more nested lists, it will call for them too\\n\\t\\n    void Solve(vector<NestedInteger> nestedList) {\\n\\t//Iterating over the list\\n        for(auto u : nestedList) {\\n\\t\\t//If integer, simply push to result\\n            if(u.isInteger()) {\\n                result.push_back(u.getInteger());\\n            }\\n\\t\\t\\t//If a list otherwise, call recursively again\\n            else {\\n                Solve(u.getList());\\n            }\\n        }\\n    }\\n    \\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n\\t// Call the recursive function from the contructor itself to generate\\n\\t// the flatten list which we have declared as name result above\\n        Solve(nestedList);\\n    }\\n    \\n    int next() {\\n\\t// Return the element for the current iterator(Which we declared globally)\\n        return result[i++];\\n    }\\n    \\n    bool hasNext() {\\n\\t// Check if it is not out of bounds (Which we declared globally for)\\n        if(i < result.size()) {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your NestedIterator object will be instantiated and called as such:\\n * NestedIterator i(nestedList);\\n * while (i.hasNext()) cout << i.next();\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\n\\n\\n//From the above NestedInteger interface defination we have 3 functions which we can use:\\n\\n//1) isInteger() : To check whether the element is integer or or a nested list, it returns true in case of integer\\n//2) getInteger(): Get that integer after using isInteger() method\\n//3) getList(): If isInteger() returns false, it means it is a nested list which we cant get from this method\\n\\n\\nclass NestedIterator {\\npublic:\\n\\n\\t//Initialize the global vector which will be our flatten list and our answer, which we will make by pushing elements\\n    vector<int> result;\\n\\t//Initialize the current iterator for the flatten list we declared above, to check if we are out of bounds or not for is hasNext() method\\n    int i = 0;\\n    \\n\\t\\n\\t//This is a recursive function\\n\\t// Why we are using recursion here ?\\n\\t// Ans: As in this test case nestedList = [1,[4,[6]]]\\n\\t\\n\\t// We start iterating the list, we found 4 as integer, we pushed it into our result vector.\\n\\t// Then we get a nested list, which infact has a nested list in itself [4, [6]],6 here is in nested list of this list\\n\\t\\n\\t// So, we check if an element is integer, we simply pushes that to our result\\n\\t// Otherwise if the element is a list we call the function recursively for this element\\n\\t// And if this list contains more nested lists, it will call for them too\\n\\t\\n    void Solve(vector<NestedInteger> nestedList) {\\n\\t//Iterating over the list\\n        for(auto u : nestedList) {\\n\\t\\t//If integer, simply push to result\\n            if(u.isInteger()) {\\n                result.push_back(u.getInteger());\\n            }\\n\\t\\t\\t//If a list otherwise, call recursively again\\n            else {\\n                Solve(u.getList());\\n            }\\n        }\\n    }\\n    \\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n\\t// Call the recursive function from the contructor itself to generate\\n\\t// the flatten list which we have declared as name result above\\n        Solve(nestedList);\\n    }\\n    \\n    int next() {\\n\\t// Return the element for the current iterator(Which we declared globally)\\n        return result[i++];\\n    }\\n    \\n    bool hasNext() {\\n\\t// Check if it is not out of bounds (Which we declared globally for)\\n        if(i < result.size()) {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your NestedIterator object will be instantiated and called as such:\\n * NestedIterator i(nestedList);\\n * while (i.hasNext()) cout << i.next();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2017536,
                "title": "java-python-clean-recursive-solution",
                "content": "**[Here](https://leetcode.com/problems/flatten-nested-list-iterator/solutions/4060670/java-power-of-stream-api-clean-and-simple/)** is link to Java Solution using Stream API.\\n\\n  \\n```\\nfrom itertools import chain\\nfrom typing import List, Optional\\n\\n\\nclass NestedIterator:\\n    def __init__(self, nestedList: List[NestedInteger]):\\n        self.itr = iter(nestedList)\\n\\n    def next(self) -> int:\\n        val = next(self.itr)\\n\\n        if val.isInteger():\\n            return val.getInteger()\\n\\n        # expanding iterator\\n        self.itr = chain(val.getList(), self.itr)\\n\\n        return self.next()\\n\\n    def hasNext(self) -> bool:\\n        val: Optional[NestedInteger] = next(self.itr, None)\\n\\n        if val is None:  # no item in the iterator\\n            return False\\n        elif val.isInteger():  # we got an item\\n            self.itr = chain([val], self.itr)\\n            return True\\n        else:\\n            # expanding iterator\\n            self.itr = chain(val.getList(), self.itr)\\n            return self.hasNext()\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nfrom itertools import chain\\nfrom typing import List, Optional\\n\\n\\nclass NestedIterator:\\n    def __init__(self, nestedList: List[NestedInteger]):\\n        self.itr = iter(nestedList)\\n\\n    def next(self) -> int:\\n        val = next(self.itr)\\n\\n        if val.isInteger():\\n            return val.getInteger()\\n\\n        # expanding iterator\\n        self.itr = chain(val.getList(), self.itr)\\n\\n        return self.next()\\n\\n    def hasNext(self) -> bool:\\n        val: Optional[NestedInteger] = next(self.itr, None)\\n\\n        if val is None:  # no item in the iterator\\n            return False\\n        elif val.isInteger():  # we got an item\\n            self.itr = chain([val], self.itr)\\n            return True\\n        else:\\n            # expanding iterator\\n            self.itr = chain(val.getList(), self.itr)\\n            return self.hasNext()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157065,
                "title": "c-simple-single-stack-implementation",
                "content": "```\\nclass NestedIterator {\\npublic:\\n    stack<NestedInteger> s;\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        \\n        for(int i=nestedList.size()-1;i>=0;i--){\\n            s.push(nestedList[i]);\\n        }\\n    }\\n    \\n    int next() {\\n        int ans=s.top().getInteger();\\n        s.pop();\\n        return ans;\\n    }\\n    \\n    bool hasNext() {\\n        while(!s.empty()){\\n            NestedInteger curr=s.top();\\n            if(curr.isInteger()){\\n                return true;\\n            }\\n            s.pop();\\n            vector<NestedInteger>& elements=curr.getList();\\n            for(int i=elements.size()-1;i>=0;i--){\\n                s.push(elements[i]);\\n            }\\n            \\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass NestedIterator {\\npublic:\\n    stack<NestedInteger> s;\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        \\n        for(int i=nestedList.size()-1;i>=0;i--){\\n            s.push(nestedList[i]);\\n        }\\n    }\\n    \\n    int next() {\\n        int ans=s.top().getInteger();\\n        s.pop();\\n        return ans;\\n    }\\n    \\n    bool hasNext() {\\n        while(!s.empty()){\\n            NestedInteger curr=s.top();\\n            if(curr.isInteger()){\\n                return true;\\n            }\\n            s.pop();\\n            vector<NestedInteger>& elements=curr.getList();\\n            for(int i=elements.size()-1;i>=0;i--){\\n                s.push(elements[i]);\\n            }\\n            \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156552,
                "title": "python-stack",
                "content": "```\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.res = []\\n        stack = nestedList\\n        while stack:\\n            k = stack[0]\\n            stack  = stack[1:]\\n            if k.isInteger():\\n                self.res.append(k)\\n            else:\\n                stack=k.getList()+stack\\n        self.i=0\\n    \\n    def next(self) -> int:\\n        self.i+=1\\n        return self.res[self.i-1]\\n    \\n    def hasNext(self) -> bool:\\n        return self.i<len(self.res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.res = []\\n        stack = nestedList\\n        while stack:\\n            k = stack[0]\\n            stack  = stack[1:]\\n            if k.isInteger():\\n                self.res.append(k)\\n            else:\\n                stack=k.getList()+stack\\n        self.i=0\\n    \\n    def next(self) -> int:\\n        self.i+=1\\n        return self.res[self.i-1]\\n    \\n    def hasNext(self) -> bool:\\n        return self.i<len(self.res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156146,
                "title": "c-super-clean-short-implementation",
                "content": "```\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) \\n    {\\n        flatten(nestedList);\\n    }\\n    \\n    int next() \\n    {\\n        return flatList[iterator++];\\n    }\\n    \\n    bool hasNext() \\n    {\\n        return iterator < flatList.size();\\n    }\\n    \\n    void flatten(vector<NestedInteger> &nestedList)\\n    {\\n        for (auto i : nestedList)\\n        {\\n            if (i.isInteger())  \\n                flatList.push_back(i.getInteger());\\n        \\n            else \\n                flatten(i.getList());\\n        }\\n    }\\n    \\nprivate:\\n    vector<int> flatList;\\n    size_t iterator = 0;\\n \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) \\n    {\\n        flatten(nestedList);\\n    }\\n    \\n    int next() \\n    {\\n        return flatList[iterator++];\\n    }\\n    \\n    bool hasNext() \\n    {\\n        return iterator < flatList.size();\\n    }\\n    \\n    void flatten(vector<NestedInteger> &nestedList)\\n    {\\n        for (auto i : nestedList)\\n        {\\n            if (i.isInteger())  \\n                flatList.push_back(i.getInteger());\\n        \\n            else \\n                flatten(i.getList());\\n        }\\n    }\\n    \\nprivate:\\n    vector<int> flatList;\\n    size_t iterator = 0;\\n \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522754,
                "title": "clean-python-solution",
                "content": "```\\n\\'\\'\\'\\nUse a stack to hold the nestedList[::-1], so pop operation get the first item.\\nUse hasNext to extract integer and put it on the stack top\\nTime: O(n)\\nSpace: O(n)\\n\\'\\'\\'\\n\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.stack = nestedList[::-1]\\n    \\n    def next(self) -> int:\\n        return self.stack.pop().getInteger()\\n    \\n    def hasNext(self) -> bool:\\n        while self.stack and not self.stack[-1].isInteger():\\n            cur = self.stack.pop().getList()\\n            while cur:\\n                self.stack.append(cur.pop())\\n\\t\\treturn True if self.stack else False\\n```",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\nUse a stack to hold the nestedList[::-1], so pop operation get the first item.\\nUse hasNext to extract integer and put it on the stack top\\nTime: O(n)\\nSpace: O(n)\\n\\'\\'\\'\\n\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.stack = nestedList[::-1]\\n    \\n    def next(self) -> int:\\n        return self.stack.pop().getInteger()\\n    \\n    def hasNext(self) -> bool:\\n        while self.stack and not self.stack[-1].isInteger():\\n            cur = self.stack.pop().getList()\\n            while cur:\\n                self.stack.append(cur.pop())\\n\\t\\treturn True if self.stack else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509748,
                "title": "easy-to-understand-python-solution",
                "content": "It\\'s just one of the ways to solve the problem. I recommend [this](https://leetcode.com/problems/flatten-nested-list-iterator/discuss/80146/Real-iterator-in-Python-Java-C%2B%2B) if you prefer a real iterator that does not copy the list.\\n```python\\ndef dfs(nested, flat):\\n    for elem in nested:\\n        if elem.isInteger():\\n            flat.append(elem.getInteger())\\n        else:\\n            dfs(elem.getList(), flat)\\n\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.flatList, self.i = [], 0\\n        dfs(nestedList, self.flatList)\\n    \\n    def next(self) -> int:\\n        self.i += 1\\n        return self.flatList[self.i-1]\\n    \\n    def hasNext(self) -> bool:\\n        return self.i < len(self.flatList)\\n```\\n**Update:** a real iterator, same algorithm.\\n```python\\ndef dfs(nested):\\n    for elem in nested:\\n        if elem.isInteger():\\n            yield elem.getInteger()\\n        else:\\n            for n in dfs(elem.getList()):\\n                yield n\\n\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.it = iter(dfs(nestedList))\\n    \\n    def next(self) -> int:\\n        return self.n\\n    \\n    def hasNext(self) -> bool:\\n        try:\\n            self.n = next(self.it)\\n            return True\\n        except StopIteration:\\n            return False\\n```\\nVote up if you find this helpful, thanks!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef dfs(nested, flat):\\n    for elem in nested:\\n        if elem.isInteger():\\n            flat.append(elem.getInteger())\\n        else:\\n            dfs(elem.getList(), flat)\\n\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.flatList, self.i = [], 0\\n        dfs(nestedList, self.flatList)\\n    \\n    def next(self) -> int:\\n        self.i += 1\\n        return self.flatList[self.i-1]\\n    \\n    def hasNext(self) -> bool:\\n        return self.i < len(self.flatList)\\n```\n```python\\ndef dfs(nested):\\n    for elem in nested:\\n        if elem.isInteger():\\n            yield elem.getInteger()\\n        else:\\n            for n in dfs(elem.getList()):\\n                yield n\\n\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.it = iter(dfs(nestedList))\\n    \\n    def next(self) -> int:\\n        return self.n\\n    \\n    def hasNext(self) -> bool:\\n        try:\\n            self.n = next(self.it)\\n            return True\\n        except StopIteration:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387494,
                "title": "truly-lazy-recursive-python-solution",
                "content": "I noticed a lot of the top solutions are not truly lazy (e.g. iterate through the list to add to a stack or some equivalent algorithm). Iterators are supposed to be lazy though, so I should not know anything about future values other than the next immediate one.\\n\\nThis is a lazy Python solution that only loads the next value at each iteration of next().\\n\\n```\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type nestedList: List[NestedInteger]\\n        \"\"\"\\n        self.nestedList = nestedList\\n        self.idx = 0\\n        self.nextVal = None\\n        self.it = None\\n        \\n        self.loadNextVal()\\n        \\n    def loadNextVal(self):\\n        if self.it:\\n            if self.it.hasNext():\\n                self.nextVal = self.it.next()\\n            else:\\n                self.it = None\\n                self.loadNextVal()\\n        \\n        else:\\n            while self.idx < len(self.nestedList):\\n                curr = self.nestedList[self.idx]\\n                self.idx += 1\\n                if curr.isInteger():\\n                    self.nextVal = curr.getInteger()\\n                    break\\n                else:\\n                    self.it = NestedIterator(curr.getList())\\n                    if self.it.hasNext():\\n                        self.nextVal = self.it.next()\\n                        break\\n                    else:\\n                        continue        \\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        ret = self.nextVal\\n        self.nextVal = None\\n        self.loadNextVal()\\n        return ret\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return self.nextVal != None\\n```",
                "solutionTags": [],
                "code": "```\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type nestedList: List[NestedInteger]\\n        \"\"\"\\n        self.nestedList = nestedList\\n        self.idx = 0\\n        self.nextVal = None\\n        self.it = None\\n        \\n        self.loadNextVal()\\n        \\n    def loadNextVal(self):\\n        if self.it:\\n            if self.it.hasNext():\\n                self.nextVal = self.it.next()\\n            else:\\n                self.it = None\\n                self.loadNextVal()\\n        \\n        else:\\n            while self.idx < len(self.nestedList):\\n                curr = self.nestedList[self.idx]\\n                self.idx += 1\\n                if curr.isInteger():\\n                    self.nextVal = curr.getInteger()\\n                    break\\n                else:\\n                    self.it = NestedIterator(curr.getList())\\n                    if self.it.hasNext():\\n                        self.nextVal = self.it.next()\\n                        break\\n                    else:\\n                        continue        \\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        ret = self.nextVal\\n        self.nextVal = None\\n        self.loadNextVal()\\n        return ret\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return self.nextVal != None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80284,
                "title": "java-dfs",
                "content": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n    \\n    LinkedList<Integer> list;\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        list = new LinkedList<Integer>();\\n        dfs(nestedList);\\n    }\\n    \\n    private void dfs(List<NestedInteger> nestedList){\\n        for(NestedInteger i : nestedList){\\n            if(i.isInteger()){\\n                list.add(i.getInteger());\\n            }else{\\n                dfs(i.getList());\\n            }\\n        }\\n        return;\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return list.removeFirst();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return !list.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n    \\n    LinkedList<Integer> list;\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        list = new LinkedList<Integer>();\\n        dfs(nestedList);\\n    }\\n    \\n    private void dfs(List<NestedInteger> nestedList){\\n        for(NestedInteger i : nestedList){\\n            if(i.isInteger()){\\n                list.add(i.getInteger());\\n            }else{\\n                dfs(i.getList());\\n            }\\n        }\\n        return;\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return list.removeFirst();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return !list.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80387,
                "title": "python-solution-132-ms",
                "content": "Use queue, iterator\\n\\n    class NestedIterator(object):\\n        def __init__(self,nestedList):\\n            self.queue = collections.deque([])\\n            for elem in nestedList:\\n                if elem.isInteger():\\n                    self.queue.append(elem.getInteger())\\n                else:\\n                    newList = NestedIterator(elem.getList())\\n                    while newList.hasNext():\\n                        self.queue.append(newList.next())\\n        def hasNext(self):\\n            if self.queue:\\n                return True\\n            return False\\n        def next(self):\\n            return self.queue.popleft()",
                "solutionTags": [
                    "Python"
                ],
                "code": "Use queue, iterator\\n\\n    class NestedIterator(object):\\n        def __init__(self,nestedList):\\n            self.queue = collections.deque([])\\n            for elem in nestedList:\\n                if elem.isInteger():\\n                    self.queue.append(elem.getInteger())\\n                else:\\n                    newList = NestedIterator(elem.getList())\\n                    while newList.hasNext():\\n                        self.queue.append(newList.next())\\n        def hasNext(self):\\n            if self.queue:\\n                return True\\n            return False\\n        def next(self):\\n            return self.queue.popleft()",
                "codeTag": "Java"
            },
            {
                "id": 80145,
                "title": "using-javascript-can-t-pass-test-case-why",
                "content": "The code can pass in development, however it is failed on leetcode. I don't know what's wrong ?  the code is below:\\n       \\n     /**\\n         * @constructor\\n         * @param {NestedInteger[]} nestedList\\n         */\\n        var NestedIterator = function(nestedList) {\\n            this.list = nestedList;\\n            this.position = 0;\\n          this.childIterator = null;\\n          this.finalList = [];\\n        };\\n        \\n        \\n        /**\\n         * @this NestedIterator\\n         * @returns {boolean}\\n         */\\n        NestedIterator.prototype.hasNext = function() {\\n          return (this.list.length - 1 >= this.position) ? true : false;\\n        };\\n        \\n        /**\\n         * @this NestedIterator\\n         * @returns {integer}\\n         */\\n        NestedIterator.prototype.next = function() {\\n            while (this.hasNext()) {\\n            var item = this.list[this.position];\\n            if (Object.prototype.toString.call(item) === '[object Array]') {\\n              var childIterator = this.childIterator;\\n              if (!childIterator) {\\n                this.childIterator = childIterator = new NestedIterator(item);\\n              }\\n              if (childIterator.hasNext()) {\\n                var val = childIterator.next();\\n                if (!childIterator.hasNext()) {\\n                  this.position++;\\n                  this.childIterator = null;\\n                }\\n                return val;\\n              }\\n            } else {\\n              this.position++;\\n              return item;\\n            }\\n          }\\n          return this.finalList;\\n        };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "The code can pass in development, however it is failed on leetcode. I don't know what's wrong ?  the code is below:\\n       \\n     /**\\n         * @constructor\\n         * @param {NestedInteger[]} nestedList\\n         */\\n        var NestedIterator = function(nestedList) {\\n            this.list = nestedList;\\n            this.position = 0;\\n          this.childIterator = null;\\n          this.finalList = [];\\n        };\\n        \\n        \\n        /**\\n         * @this NestedIterator\\n         * @returns {boolean}\\n         */\\n        NestedIterator.prototype.hasNext = function() {\\n          return (this.list.length - 1 >= this.position) ? true : false;\\n        };\\n        \\n        /**\\n         * @this NestedIterator\\n         * @returns {integer}\\n         */\\n        NestedIterator.prototype.next = function() {\\n            while (this.hasNext()) {\\n            var item = this.list[this.position];\\n            if (Object.prototype.toString.call(item) === '[object Array]') {\\n              var childIterator = this.childIterator;\\n              if (!childIterator) {\\n                this.childIterator = childIterator = new NestedIterator(item);\\n              }\\n              if (childIterator.hasNext()) {\\n                var val = childIterator.next();\\n                if (!childIterator.hasNext()) {\\n                  this.position++;\\n                  this.childIterator = null;\\n                }\\n                return val;\\n              }\\n            } else {\\n              this.position++;\\n              return item;\\n            }\\n          }\\n          return this.finalList;\\n        };",
                "codeTag": "Unknown"
            },
            {
                "id": 80445,
                "title": "my-solution-by-doing-a-dfs-and-using-a-queue-to-store-numbers",
                "content": "\\n\\n    class NestedIterator {\\n    private:\\n        queue<int> q;\\n    public:\\n        NestedIterator(vector<NestedInteger> &nestedList) {\\n            for(auto ni:nestedList){\\n                dfs(ni);\\n            }\\n        }\\n        void dfs(NestedInteger ni){\\n            if(ni.isInteger()){\\n                int tmp = ni.getInteger();\\n                q.push(tmp);\\n            }\\n            for(auto nii:ni.getList()){\\n                dfs(nii);\\n            }\\n        }\\n        \\n        int next() {\\n           int element = q.front();\\n           q.pop();\\n           return element;\\n        }\\n    \\n        bool hasNext() {\\n            return !q.empty();\\n        }\\n    };",
                "solutionTags": [],
                "code": "\\n\\n    class NestedIterator {\\n    private:\\n        queue<int> q;\\n    public:\\n        NestedIterator(vector<NestedInteger> &nestedList) {\\n            for(auto ni:nestedList){\\n                dfs(ni);\\n            }\\n        }\\n        void dfs(NestedInteger ni){\\n            if(ni.isInteger()){\\n                int tmp = ni.getInteger();\\n                q.push(tmp);\\n            }\\n            for(auto nii:ni.getList()){\\n                dfs(nii);\\n            }\\n        }\\n        \\n        int next() {\\n           int element = q.front();\\n           q.pop();\\n           return element;\\n        }\\n    \\n        bool hasNext() {\\n            return !q.empty();\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 2093058,
                "title": "python-6-line-solution-recursive",
                "content": "```\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.nums=[];\\n        def go(u=nestedList):\\n            for el in u: self.nums.append(el.getInteger()) if el.isInteger() else go(el.getList());\\n        go();\\n    \\n    def next(self) -> int:\\n        return self.nums.pop(0);\\n    \\n    def hasNext(self) -> bool:\\n         return len(self.nums)>0;\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.nums=[];\\n        def go(u=nestedList):\\n            for el in u: self.nums.append(el.getInteger()) if el.isInteger() else go(el.getList());\\n        go();\\n    \\n    def next(self) -> int:\\n        return self.nums.pop(0);\\n    \\n    def hasNext(self) -> bool:\\n         return len(self.nums)>0;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019504,
                "title": "simple-c-solution-stack",
                "content": "The key idea is to store NestedInteger objects in stack (where `next()` is either equal to stack top or nested in it).\\n\\n0. `pushList(v)` pushes elements of vector v to stack in reversed order.\\n1. **Initialization**. Prepare stack just pushing all NestedList elements to stack in reversed order (so that the first element is on top of stack).\\n2. `hasNext()` prepares next element. If the element on the stack top is integer, then it is the required next int. Otherwise, it is a nested list (vector of NestedInteger), so we pop it, push to stack its elements (via `pushList`) and repeat processing the stack top.\\n3. `next()` firstly prepares next using `hasNext()` and then returns it (popping it beforehand)\\n\\n```\\nclass NestedIterator {\\n    stack<NestedInteger> s;\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        pushList(nestedList);\\n    }\\n    \\n    int next() {\\n        hasNext();\\n        int res = s.top().getInteger();\\n        s.pop();\\n        return res;\\n    }\\n    \\n    bool hasNext() {\\n        while (!s.empty()) {\\n            if (s.top().isInteger()) {\\n                return true;\\n            }\\n            auto t = s.top();\\n            s.pop();\\n            pushList(t.getList());\\n        }\\n        return false;\\n    }\\n    \\n    void pushList(const vector<NestedInteger>& v) {\\n        for (int i = v.size() - 1; i >= 0; --i) {\\n            s.push(v[i]);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass NestedIterator {\\n    stack<NestedInteger> s;\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        pushList(nestedList);\\n    }\\n    \\n    int next() {\\n        hasNext();\\n        int res = s.top().getInteger();\\n        s.pop();\\n        return res;\\n    }\\n    \\n    bool hasNext() {\\n        while (!s.empty()) {\\n            if (s.top().isInteger()) {\\n                return true;\\n            }\\n            auto t = s.top();\\n            s.pop();\\n            pushList(t.getList());\\n        }\\n        return false;\\n    }\\n    \\n    void pushList(const vector<NestedInteger>& v) {\\n        for (int i = v.size() - 1; i >= 0; --i) {\\n            s.push(v[i]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894816,
                "title": "c-just-recursion",
                "content": "```\\nclass NestedIterator {\\nprivate:\\n    vector<int> arr;\\n    int idx = 0;\\npublic:\\n    void push_list(vector<NestedInteger> &nestedList){\\n        int n = nestedList.size();\\n        for(int i=0;i<n;i++){\\n            if(nestedList[i].isInteger())\\n                arr.push_back(nestedList[i].getInteger());\\n            else\\n                push_list(nestedList[i].getList());\\n        }\\n    }\\n    \\n    NestedIterator(vector<NestedInteger> &nestedList) { \\n        push_list(nestedList); \\n    }\\n    \\n    int next() { \\n        return arr[idx++]; \\n    }\\n    \\n    bool hasNext() { \\n        return idx < arr.size(); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass NestedIterator {\\nprivate:\\n    vector<int> arr;\\n    int idx = 0;\\npublic:\\n    void push_list(vector<NestedInteger> &nestedList){\\n        int n = nestedList.size();\\n        for(int i=0;i<n;i++){\\n            if(nestedList[i].isInteger())\\n                arr.push_back(nestedList[i].getInteger());\\n            else\\n                push_list(nestedList[i].getList());\\n        }\\n    }\\n    \\n    NestedIterator(vector<NestedInteger> &nestedList) { \\n        push_list(nestedList); \\n    }\\n    \\n    int next() { \\n        return arr[idx++]; \\n    }\\n    \\n    bool hasNext() { \\n        return idx < arr.size(); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446981,
                "title": "js-two-solutions-pre-processing-and-processing-in-each-iteration",
                "content": "**Solution 1: Pre-processing (preparing the list before iterating)**\\n\\n```\\nclass NestedIterator {\\n    constructor(nestedList) {\\n        this.flattenedList = this.flatten(nestedList);\\n    }\\n    hasNext() {\\n        return this.flattenedList.length !== 0;\\n    }\\n    next() {\\n        return this.flattenedList.shift();\\n    }\\n    flatten(list) {\\n        let result = [];\\n        list.forEach(val => {\\n            if(val.isInteger()) {\\n                result.push(val.getInteger());\\n            } else {\\n                result = result.concat(this.flatten(val.getList()));\\n            }\\n        })\\n        return result;\\n    }\\n}\\n```\\nTime Complexity:\\n`constructor = O(m * n)` [m - average size of each list, n - total number of values in the nested list]\\n`hasNext = O(1)`\\n`next = O(1)`\\n\\nSpace Complexity: `O(m * n)`\\n\\n----\\n\\n**Solution 2: Processing in each iteration**\\n\\n```\\nclass NestedIterator {\\n    constructor(nestedList) {\\n        this.stack = new Stack();\\n        this.addToStack(nestedList);\\n    }\\n    hasNext() {\\n\\t\\t// If the stack is not empty, check if the top value is an integer. If yes, return true\\n\\t\\t// Else, add the values inside the list into the stack and continue the loop until we have an integer at the top of the stack\\n        while(!this.stack.isEmpty()) {\\n            const top = this.stack.top();\\n            if(top.isInteger()) {\\n                return true;\\n            } else {\\n                this.stack.pop();\\n                this.addToStack(top.getList());\\n            }    \\n        }\\n\\t\\t// this will hold true if the stack is empty (no more integers to return)\\n        return false;\\n    }\\n    next() {\\n        return this.stack.pop().getInteger();\\n    }\\n    addToStack(list) {\\n\\t\\t// add the values from right to left since stack property is LIFO\\n        for(let i = list.length - 1; i >= 0; --i) {\\n            this.stack.push(list[i]);\\n        }\\n    }\\n}\\n\\nclass Stack {\\n    constructor() {    // O(1)\\n        this.values = [];\\n    }\\n    isEmpty() {    // O(1)\\n        return this.values.length === 0;\\n    }\\n    top() {    // O(1)\\n        return this.values[this.values.length - 1];\\n    }\\n    pop() {    // O(1)\\n        return this.values.pop();\\n    }\\n    push(val) {    // O(1)\\n        this.values.push(val);\\n    }\\n}\\n```\\nTime Complexity:\\n`constructor = O(n)` \\n`hasNext = O(m)`\\n`next = O(1)`\\n\\nSpace Complexity: `O(m * n)`\\n[m - average size of each list, n - total number of values in the nested list]",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass NestedIterator {\\n    constructor(nestedList) {\\n        this.flattenedList = this.flatten(nestedList);\\n    }\\n    hasNext() {\\n        return this.flattenedList.length !== 0;\\n    }\\n    next() {\\n        return this.flattenedList.shift();\\n    }\\n    flatten(list) {\\n        let result = [];\\n        list.forEach(val => {\\n            if(val.isInteger()) {\\n                result.push(val.getInteger());\\n            } else {\\n                result = result.concat(this.flatten(val.getList()));\\n            }\\n        })\\n        return result;\\n    }\\n}\\n```\n```\\nclass NestedIterator {\\n    constructor(nestedList) {\\n        this.stack = new Stack();\\n        this.addToStack(nestedList);\\n    }\\n    hasNext() {\\n\\t\\t// If the stack is not empty, check if the top value is an integer. If yes, return true\\n\\t\\t// Else, add the values inside the list into the stack and continue the loop until we have an integer at the top of the stack\\n        while(!this.stack.isEmpty()) {\\n            const top = this.stack.top();\\n            if(top.isInteger()) {\\n                return true;\\n            } else {\\n                this.stack.pop();\\n                this.addToStack(top.getList());\\n            }    \\n        }\\n\\t\\t// this will hold true if the stack is empty (no more integers to return)\\n        return false;\\n    }\\n    next() {\\n        return this.stack.pop().getInteger();\\n    }\\n    addToStack(list) {\\n\\t\\t// add the values from right to left since stack property is LIFO\\n        for(let i = list.length - 1; i >= 0; --i) {\\n            this.stack.push(list[i]);\\n        }\\n    }\\n}\\n\\nclass Stack {\\n    constructor() {    // O(1)\\n        this.values = [];\\n    }\\n    isEmpty() {    // O(1)\\n        return this.values.length === 0;\\n    }\\n    top() {    // O(1)\\n        return this.values[this.values.length - 1];\\n    }\\n    pop() {    // O(1)\\n        return this.values.pop();\\n    }\\n    push(val) {    // O(1)\\n        this.values.push(val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156688,
                "title": "easy-to-understand-recursive-solution",
                "content": "```\\npublic class NestedIterator {\\n    IList<int> result;\\n    int index;\\n    public NestedIterator(IList<NestedInteger> nestedList) {\\n        result = new List<int>();\\n        index = 0;        \\n        AddValues(nestedList);\\n    }\\n    \\n    private void AddValues(IList<NestedInteger> nestedList)\\n    {\\n        for (int i = 0; i < nestedList.Count; i++)\\n        {\\n            if (nestedList[i].IsInteger())\\n            {\\n                result.Add(nestedList[i].GetInteger());\\n            }\\n            else\\n            {\\n                AddValues(nestedList[i].GetList());\\n            }\\n            \\n        }\\n    }\\n\\n    public bool HasNext() {\\n        return index < result.Count;\\n    }\\n\\n    public int Next() {\\n        return result[index++];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\npublic class NestedIterator {\\n    IList<int> result;\\n    int index;\\n    public NestedIterator(IList<NestedInteger> nestedList) {\\n        result = new List<int>();\\n        index = 0;        \\n        AddValues(nestedList);\\n    }\\n    \\n    private void AddValues(IList<NestedInteger> nestedList)\\n    {\\n        for (int i = 0; i < nestedList.Count; i++)\\n        {\\n            if (nestedList[i].IsInteger())\\n            {\\n                result.Add(nestedList[i].GetInteger());\\n            }\\n            else\\n            {\\n                AddValues(nestedList[i].GetList());\\n            }\\n            \\n        }\\n    }\\n\\n    public bool HasNext() {\\n        return index < result.Count;\\n    }\\n\\n    public int Next() {\\n        return result[index++];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156235,
                "title": "java-recursive-solution",
                "content": "**Idea:**\\nTry to store nested list into normal arraylist then it would be easier for us to find next and hasnext.\\n1. make a arraylist of integer which will store nestedlist as of normal list.\\n2. make a recursive function helper. \\n  eg : [[1,1],2,[3,4]] \\n  run a loop over nestlist.size() which is 3 initially if it is integer add to output else get list and pass into helper.\\n\\n**CODE:**\\n```\\npublic class NestedIterator implements Iterator<Integer> {\\n    private ArrayList<Integer> output=new ArrayList<>();\\n    private int idx=0;\\n    \\n    private void helper(List<NestedInteger> nestedList){\\n        for(int i=0;i<nestedList.size();i++){\\n            if(nestedList.get(i).isInteger()){\\n                output.add(nestedList.get(i).getInteger());\\n            }else{\\n                helper(nestedList.get(i).getList());\\n            }\\n        }\\n    }\\n    \\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        helper(nestedList);\\n    }\\n\\n    @Override\\n    public Integer next() {\\n       int val=output.get(idx);\\n       idx++;\\n        return val;\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return idx<output.size();\\n    }\\n}\\n```\\n\\n**Complexity:**\\n`Time:O(n) and Space:O(n)`\\n\\nPlease **UPVOTE** if found it helpful :)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n    private ArrayList<Integer> output=new ArrayList<>();\\n    private int idx=0;\\n    \\n    private void helper(List<NestedInteger> nestedList){\\n        for(int i=0;i<nestedList.size();i++){\\n            if(nestedList.get(i).isInteger()){\\n                output.add(nestedList.get(i).getInteger());\\n            }else{\\n                helper(nestedList.get(i).getList());\\n            }\\n        }\\n    }\\n    \\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        helper(nestedList);\\n    }\\n\\n    @Override\\n    public Integer next() {\\n       int val=output.get(idx);\\n       idx++;\\n        return val;\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return idx<output.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956120,
                "title": "implemented-it-using-stack-one-of-the-best-solution-in-c",
                "content": "```\\nclass NestedIterator {\\npublic:\\n    \\n    stack<NestedInteger> st;\\n    \\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        for(int i = nestedList.size()-1;i>=0;i--)\\n        {\\n            st.push(nestedList[i]);\\n        }\\n    }\\n    \\n    int next() {\\n        auto temp = st.top();\\n        st.pop();\\n        return temp.getInteger();\\n    }\\n    \\n    bool hasNext() {\\n        \\n        while(st.size())\\n        {\\n            NestedInteger temp = st.top();\\n            if(temp.isInteger())\\n            {\\n                return true;\\n            }\\n            st.pop();\\n            auto vec = temp.getList();\\n            for(int i = vec.size()-1;i>=0;i--)\\n            {\\n                st.push(vec[i]);\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n\\n ```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass NestedIterator {\\npublic:\\n    \\n    stack<NestedInteger> st;\\n    \\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        for(int i = nestedList.size()-1;i>=0;i--)\\n        {\\n            st.push(nestedList[i]);\\n        }\\n    }\\n    \\n    int next() {\\n        auto temp = st.top();\\n        st.pop();\\n        return temp.getInteger();\\n    }\\n    \\n    bool hasNext() {\\n        \\n        while(st.size())\\n        {\\n            NestedInteger temp = st.top();\\n            if(temp.isInteger())\\n            {\\n                return true;\\n            }\\n            st.pop();\\n            auto vec = temp.getList();\\n            for(int i = vec.size()-1;i>=0;i--)\\n            {\\n                st.push(vec[i]);\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 395658,
                "title": "python-solution-using-queue",
                "content": "```\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type nestedList: List[NestedInteger]\\n        \"\"\"\\n        self.dq = collections.deque([])\\n        self.dfs(nestedList)\\n        \\n    def dfs(self, nest):\\n        for x in nest:\\n            if x.isInteger():\\n                self.dq.append(x.getInteger())\\n            else:\\n                self.dfs(x.getList())\\n                \\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.dq.popleft()\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return len(self.dq) > 0\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type nestedList: List[NestedInteger]\\n        \"\"\"\\n        self.dq = collections.deque([])\\n        self.dfs(nestedList)\\n        \\n    def dfs(self, nest):\\n        for x in nest:\\n            if x.isInteger():\\n                self.dq.append(x.getInteger())\\n            else:\\n                self.dfs(x.getList())\\n                \\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.dq.popleft()\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return len(self.dq) > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222545,
                "title": "easy-python-solution-beats-99",
                "content": "Here is an easy python solution via recursion:\\n\\n```\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type nestedList: List[NestedInteger]\\n        \"\"\"\\n        self.ls = self.flatten(nestedList)\\n        self.ls = self.ls[::-1]\\n        \\n    def flatten(self, ls):\\n        res = []\\n        for item in ls:\\n            if item.isInteger():\\n                res.append(item.getInteger())\\n            else:\\n                res.extend(self.flatten(item.getList()))\\n        return res\\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.ls.pop()\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return len(self.ls) > 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type nestedList: List[NestedInteger]\\n        \"\"\"\\n        self.ls = self.flatten(nestedList)\\n        self.ls = self.ls[::-1]\\n        \\n    def flatten(self, ls):\\n        res = []\\n        for item in ls:\\n            if item.isInteger():\\n                res.append(item.getInteger())\\n            else:\\n                res.extend(self.flatten(item.getList()))\\n        return res\\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.ls.pop()\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return len(self.ls) > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126297,
                "title": "very-simple-javascript-solution-flatten-then-iterate",
                "content": "```\\nvar NestedIterator = function(nestedList) {\\n    var flattenArray = function(nestedList, list) {\\n        for (var i = 0; i < nestedList.length; i++) {\\n            if (nestedList[i].isInteger()) {\\n                list.push(nestedList[i].getInteger());\\n            } else {\\n                flattenArray(nestedList[i].getList(), list);\\n            }\\n        }\\n    };\\n    \\n    this.list = [];\\n    this.index = -1;\\n    flattenArray(nestedList, this.list);\\n};\\n\\nNestedIterator.prototype.hasNext = function() {\\n    return this.index < this.list.length - 1;\\n};\\n\\nNestedIterator.prototype.next = function() {\\n    this.index++;\\n    return this.list[this.index];\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvar NestedIterator = function(nestedList) {\\n    var flattenArray = function(nestedList, list) {\\n        for (var i = 0; i < nestedList.length; i++) {\\n            if (nestedList[i].isInteger()) {\\n                list.push(nestedList[i].getInteger());\\n            } else {\\n                flattenArray(nestedList[i].getList(), list);\\n            }\\n        }\\n    };\\n    \\n    this.list = [];\\n    this.index = -1;\\n    flattenArray(nestedList, this.list);\\n};\\n\\nNestedIterator.prototype.hasNext = function() {\\n    return this.index < this.list.length - 1;\\n};\\n\\nNestedIterator.prototype.next = function() {\\n    this.index++;\\n    return this.list[this.index];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 80239,
                "title": "c-look-no-further-than-the-next-integer-stack-only-what-is-necessary",
                "content": "The idea is you always seek to the next integer, then your next is that element.  Upon construction and after every next, again seek to the next integer.  The stack will only need to hold lists that you need to revisit due to diving down a sub list.  I see a lot of solutions that push all the elements from the current list onto a stack a head of time.  Seems unnecessary.\\n\\n```\\npublic class NestedIterator \\n{\\n    Stack<Pos> stack = new Stack<Pos>();\\n    Pos curr = null;\\n    \\n    public NestedIterator(IList<NestedInteger> nestedList) \\n    {\\n        curr = NextInteger(new Pos(nestedList, -1)); // little trick starting at -1\\n    }\\n\\n    public bool HasNext() \\n    {\\n        return curr.index < curr.list.Count;\\n    }\\n\\n    public int Next() \\n    {\\n        int x = HasNext() ? curr.list[curr.index].GetInteger() : -1;\\n        curr = NextInteger(curr);\\n        return x;\\n    }\\n    \\n    public Pos NextInteger(Pos p)\\n    {\\n        p.index++;\\n        \\n        while (p.index < p.list.Count || stack.Count > 0)\\n        {\\n            if (p.index < p.list.Count)\\n            {\\n                if (p.list[p.index].IsInteger()) break;\\n                \\n                if (p.index + 1 < p.list.Count) \\n                    stack.Push(new Pos(p.list, p.index + 1));\\n                    \\n                p = new Pos(p.list[p.index].GetList(), 0);\\n            }\\n            else\\n            {\\n                p = stack.Pop();\\n            }\\n        }\\n        \\n        return p;\\n    }\\n}\\n\\n// tuple to hold list and index\\npublic class Pos\\n{\\n    public IList<NestedInteger> list;\\n    public int index;\\n    \\n    public Pos(IList<NestedInteger> list, int index)\\n    {\\n        this.list = list;\\n        this.index = index;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class NestedIterator \\n{\\n    Stack<Pos> stack = new Stack<Pos>();\\n    Pos curr = null;\\n    \\n    public NestedIterator(IList<NestedInteger> nestedList) \\n    {\\n        curr = NextInteger(new Pos(nestedList, -1)); // little trick starting at -1\\n    }\\n\\n    public bool HasNext() \\n    {\\n        return curr.index < curr.list.Count;\\n    }\\n\\n    public int Next() \\n    {\\n        int x = HasNext() ? curr.list[curr.index].GetInteger() : -1;\\n        curr = NextInteger(curr);\\n        return x;\\n    }\\n    \\n    public Pos NextInteger(Pos p)\\n    {\\n        p.index++;\\n        \\n        while (p.index < p.list.Count || stack.Count > 0)\\n        {\\n            if (p.index < p.list.Count)\\n            {\\n                if (p.list[p.index].IsInteger()) break;\\n                \\n                if (p.index + 1 < p.list.Count) \\n                    stack.Push(new Pos(p.list, p.index + 1));\\n                    \\n                p = new Pos(p.list[p.index].GetList(), 0);\\n            }\\n            else\\n            {\\n                p = stack.Pop();\\n            }\\n        }\\n        \\n        return p;\\n    }\\n}\\n\\n// tuple to hold list and index\\npublic class Pos\\n{\\n    public IList<NestedInteger> list;\\n    public int index;\\n    \\n    public Pos(IList<NestedInteger> list, int index)\\n    {\\n        this.list = list;\\n        this.index = index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346446,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\nclass NestedIterator {\\n    vector<int> v;\\n    int pos=0;\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) \\n    {\\n        flatten(nestedList);\\n    }\\n    \\n    void flatten(vector<NestedInteger> &nestedList)\\n    {\\n        for(auto x : nestedList)\\n        {\\n            if(x.isInteger())\\n                v.push_back(x.getInteger());\\n            else\\n                flatten(x.getList());\\n        }\\n    }\\n    \\n    int next() {\\n        return v[pos++];\\n    }\\n    \\n    bool hasNext() {\\n        return pos < v.size();\\n    }\\n};\\n\\n/**\\n * Your NestedIterator object will be instantiated and called as such:\\n * NestedIterator i(nestedList);\\n * while (i.hasNext()) cout << i.next();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\nclass NestedIterator {\\n    vector<int> v;\\n    int pos=0;\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) \\n    {\\n        flatten(nestedList);\\n    }\\n    \\n    void flatten(vector<NestedInteger> &nestedList)\\n    {\\n        for(auto x : nestedList)\\n        {\\n            if(x.isInteger())\\n                v.push_back(x.getInteger());\\n            else\\n                flatten(x.getList());\\n        }\\n    }\\n    \\n    int next() {\\n        return v[pos++];\\n    }\\n    \\n    bool hasNext() {\\n        return pos < v.size();\\n    }\\n};\\n\\n/**\\n * Your NestedIterator object will be instantiated and called as such:\\n * NestedIterator i(nestedList);\\n * while (i.hasNext()) cout << i.next();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2019318,
                "title": "java-solution-using-stacks",
                "content": "Solved this problem through two stacks, \\ni -> a stack which maintains the last interated list of NestedInteger\\nii -> a stack which maintains index till which we traversed in the last list of NestedInteger\\nAlso, these stacks contains corressponding elements. \\n\\nAnd for the traversal inside the current list, i have taken a currList var and a index pointer for the currList.\\n\\n```\\n\\tpublic class NestedIterator implements Iterator<Integer> {\\n    \\n    List<NestedInteger> currList;\\n    Stack<List<NestedInteger>> last;\\n    Stack<Integer> ind;\\n    int i;\\n\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n\\t\\n        currList = nestedList;\\n        last = new Stack<>();\\n        ind = new Stack<>();\\n        i = 0;\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        \\n        Integer ans = currList.get(i).getInteger();\\n        i++;\\n        while(i >= currList.size() && !last.isEmpty()){\\n            currList = last.pop();\\n            i = ind.pop();\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        if(i >= currList.size()){\\n            if(!last.isEmpty()){\\n                currList = last.pop();\\n                i = ind.pop();\\n                i++;\\n                return this.hasNext();\\n            }else return false;\\n        }\\n        \\n        if(currList.get(i).isInteger()){\\n            return true;\\n        }else{\\n            last.push(currList);\\n            ind.push(i);\\n            currList = currList.get(i).getList();\\n            i = 0;\\n            return this.hasNext();\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Design",
                    "Iterator"
                ],
                "code": "```\\n\\tpublic class NestedIterator implements Iterator<Integer> {\\n    \\n    List<NestedInteger> currList;\\n    Stack<List<NestedInteger>> last;\\n    Stack<Integer> ind;\\n    int i;\\n\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n\\t\\n        currList = nestedList;\\n        last = new Stack<>();\\n        ind = new Stack<>();\\n        i = 0;\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        \\n        Integer ans = currList.get(i).getInteger();\\n        i++;\\n        while(i >= currList.size() && !last.isEmpty()){\\n            currList = last.pop();\\n            i = ind.pop();\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        if(i >= currList.size()){\\n            if(!last.isEmpty()){\\n                currList = last.pop();\\n                i = ind.pop();\\n                i++;\\n                return this.hasNext();\\n            }else return false;\\n        }\\n        \\n        if(currList.get(i).isInteger()){\\n            return true;\\n        }else{\\n            last.push(currList);\\n            ind.push(i);\\n            currList = currList.get(i).getList();\\n            i = 0;\\n            return this.hasNext();\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017599,
                "title": "simple-recursive-solution",
                "content": "```\\nclass NestedIterator {\\npublic:\\n    vector<int> ans;\\n    int id, n;\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        get(0, nestedList);\\n        id = 0;\\n        n = ans.size();\\n    }\\n    \\n    void get(int i, vector<NestedInteger> nestedList){\\n        if(i == nestedList.size()){\\n            return;\\n        }\\n        \\n        if(nestedList[i].isInteger()){\\n            ans.push_back(nestedList[i].getInteger());\\n            get(i+1, nestedList);\\n        }\\n        else{\\n            get(0, nestedList[i].getList());\\n            get(i+1, nestedList);\\n        }\\n    }\\n    \\n    int next() {\\n        return ans[id++];\\n    }\\n    \\n    bool hasNext() {\\n        return id < n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass NestedIterator {\\npublic:\\n    vector<int> ans;\\n    int id, n;\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        get(0, nestedList);\\n        id = 0;\\n        n = ans.size();\\n    }\\n    \\n    void get(int i, vector<NestedInteger> nestedList){\\n        if(i == nestedList.size()){\\n            return;\\n        }\\n        \\n        if(nestedList[i].isInteger()){\\n            ans.push_back(nestedList[i].getInteger());\\n            get(i+1, nestedList);\\n        }\\n        else{\\n            get(0, nestedList[i].getList());\\n            get(i+1, nestedList);\\n        }\\n    }\\n    \\n    int next() {\\n        return ans[id++];\\n    }\\n    \\n    bool hasNext() {\\n        return id < n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1608243,
                "title": "c",
                "content": "```\\nclass NestedIterator {\\npublic:\\n    vector<int> v;\\n    int i =0;\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        v.clear();\\n        for ( NestedInteger it: nestedList){\\n            solve(nestedList,it);\\n        }\\n    }\\n    \\n    int next() {\\n        int x =  v[i];\\n        i++;\\n        return x;\\n    }\\n    \\n    bool hasNext() {\\n        return i==v.size()?0:1; \\n        \\n    }\\n    void solve(vector<NestedInteger> &nestedList,NestedInteger it){\\n        if (it.isInteger()){\\n            v.push_back(it.getInteger());\\n        }\\n        else{\\n            for (NestedInteger m:it.getList()){\\n                solve(it.getList(),m);\\n            }\\n        }\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "```\\nclass NestedIterator {\\npublic:\\n    vector<int> v;\\n    int i =0;\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        v.clear();\\n        for ( NestedInteger it: nestedList){\\n            solve(nestedList,it);\\n        }\\n    }\\n    \\n    int next() {\\n        int x =  v[i];\\n        i++;\\n        return x;\\n    }\\n    \\n    bool hasNext() {\\n        return i==v.size()?0:1; \\n        \\n    }\\n    void solve(vector<NestedInteger> &nestedList,NestedInteger it){\\n        if (it.isInteger()){\\n            v.push_back(it.getInteger());\\n        }\\n        else{\\n            for (NestedInteger m:it.getList()){\\n                solve(it.getList(),m);\\n            }\\n        }\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1572564,
                "title": "python",
                "content": "```\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.l = []\\n        self._dfs(nestedList)\\n    \\n    def _dfs(self, L):\\n        for i in reversed(L):\\n            if i.isInteger():\\n                self.l.append(i.getInteger())\\n            else:\\n                self._dfs(i.getList())\\n    \\n    def next(self) -> int:\\n        return self.l.pop()\\n    \\n    def hasNext(self) -> bool:\\n        return self.l\\n```",
                "solutionTags": [],
                "code": "```\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.l = []\\n        self._dfs(nestedList)\\n    \\n    def _dfs(self, L):\\n        for i in reversed(L):\\n            if i.isInteger():\\n                self.l.append(i.getInteger())\\n            else:\\n                self._dfs(i.getList())\\n    \\n    def next(self) -> int:\\n        return self.l.pop()\\n    \\n    def hasNext(self) -> bool:\\n        return self.l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394615,
                "title": "c-flatten-nested-list-iterator-recursive",
                "content": "```\\nclass NestedIterator {\\nprivate:\\n    vector<int> ans;\\n    int i = 0;\\npublic:\\n    void helper(vector<NestedInteger>& nestedList){\\n        for(int i = 0; i < nestedList.size(); i++){\\n            if(nestedList[i].isInteger()){\\n                ans.push_back(nestedList[i].getInteger());\\n            }else{\\n                helper(nestedList[i].getList());\\n            }\\n        }    \\n    }\\n    \\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        helper(nestedList);\\n    }\\n    \\n    int next() {\\n        int res = ans.at(i);\\n        i++;\\n        \\n        return res;\\n    }\\n    \\n    bool hasNext() {\\n        return i != ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass NestedIterator {\\nprivate:\\n    vector<int> ans;\\n    int i = 0;\\npublic:\\n    void helper(vector<NestedInteger>& nestedList){\\n        for(int i = 0; i < nestedList.size(); i++){\\n            if(nestedList[i].isInteger()){\\n                ans.push_back(nestedList[i].getInteger());\\n            }else{\\n                helper(nestedList[i].getList());\\n            }\\n        }    \\n    }\\n    \\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        helper(nestedList);\\n    }\\n    \\n    int next() {\\n        int res = ans.at(i);\\n        i++;\\n        \\n        return res;\\n    }\\n    \\n    bool hasNext() {\\n        return i != ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157621,
                "title": "c-simple-solution-using-vector",
                "content": "We can use recursion when we met a new list and push back integer when we met an integer.\\n```\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        for(int i = 0; i < nestedList.size(); i++){\\n            if(nestedList[i].isInteger()){\\n                items.push_back(nestedList[i].getInteger()); //If this one is integer, push back into vector\\n            }else{\\n                auto j = NestedIterator(nestedList[i].getList()); //If this one is a list, recurse with the new list\\n                while (j.hasNext()) items.push_back(j.next()); //Get the elements from new list and push into current vector (This is from given code)\\n            }\\n        }\\n    }\\n    \\n    int next() {\\n        return items[cur++]; //Return next item\\n    }\\n    \\n    bool hasNext() {\\n        return (cur < items.size()); //Check if index is smaller than vector size\\n    }\\n    \\nprivate:\\n    vector<int> items; //Vector for all items\\n    int cur = 0; //Current index\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        for(int i = 0; i < nestedList.size(); i++){\\n            if(nestedList[i].isInteger()){\\n                items.push_back(nestedList[i].getInteger()); //If this one is integer, push back into vector\\n            }else{\\n                auto j = NestedIterator(nestedList[i].getList()); //If this one is a list, recurse with the new list\\n                while (j.hasNext()) items.push_back(j.next()); //Get the elements from new list and push into current vector (This is from given code)\\n            }\\n        }\\n    }\\n    \\n    int next() {\\n        return items[cur++]; //Return next item\\n    }\\n    \\n    bool hasNext() {\\n        return (cur < items.size()); //Check if index is smaller than vector size\\n    }\\n    \\nprivate:\\n    vector<int> items; //Vector for all items\\n    int cur = 0; //Current index\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156125,
                "title": "flatten-nested-list-iterator-simple-solution-easy-to-understand",
                "content": "Here we store the pointers instead to values, to make the code work faster.\\n\\n**Do Upvote** if you like the code!!\\n```\\nclass NestedIterator {\\n    stack<NestedInteger*> st;\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        for (int i = nestedList.size()-1; i >= 0; i--) {\\n            st.push(&nestedList[i]);\\n        }\\n    }\\n    int next() {\\n        int ans =  st.top()->getInteger();\\n        st.pop();\\n        return ans;\\n    }\\n    bool hasNext() {\\n        while (st.empty() == false) {\\n            if (st.top()->isInteger())\\n                return true;\\n            NestedInteger* curr = st.top();\\n            st.pop();\\n            for (int i = curr->getList().size()-1; i >= 0; i--) {\\n                st.push(&curr->getList()[i]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass NestedIterator {\\n    stack<NestedInteger*> st;\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        for (int i = nestedList.size()-1; i >= 0; i--) {\\n            st.push(&nestedList[i]);\\n        }\\n    }\\n    int next() {\\n        int ans =  st.top()->getInteger();\\n        st.pop();\\n        return ans;\\n    }\\n    bool hasNext() {\\n        while (st.empty() == false) {\\n            if (st.top()->isInteger())\\n                return true;\\n            NestedInteger* curr = st.top();\\n            st.pop();\\n            for (int i = curr->getList().size()-1; i >= 0; i--) {\\n                st.push(&curr->getList()[i]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083443,
                "title": "using-recursion-in-c",
                "content": "```\\nclass NestedIterator {\\npublic:\\n    vector<int>ans;\\n    int i=0;\\n    \\n    void helper(vector<NestedInteger> &v){\\n        for(int i=0;i<v.size();i++){\\n            if(v[i].isInteger())\\n                ans.push_back(v[i].getInteger());\\n            else\\n                helper(v[i].getList());\\n        }\\n    }\\n    \\n    NestedIterator(vector<NestedInteger> &v) {\\n        helper(v);\\n    }\\n    \\n    int next() {\\n        return ans[i++];\\n    }\\n    \\n    bool hasNext() {\\n        return i!=ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass NestedIterator {\\npublic:\\n    vector<int>ans;\\n    int i=0;\\n    \\n    void helper(vector<NestedInteger> &v){\\n        for(int i=0;i<v.size();i++){\\n            if(v[i].isInteger())\\n                ans.push_back(v[i].getInteger());\\n            else\\n                helper(v[i].getList());\\n        }\\n    }\\n    \\n    NestedIterator(vector<NestedInteger> &v) {\\n        helper(v);\\n    }\\n    \\n    int next() {\\n        return ans[i++];\\n    }\\n    \\n    bool hasNext() {\\n        return i!=ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870349,
                "title": "java-lazy-unwinding",
                "content": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n    List<NestedInteger> list;\\n    int                 pos;\\n    NestedIterator      nested;\\n    Integer             cur;\\n\\n    public NestedIterator(List<NestedInteger> list) {\\n        this.list = list;\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        if (nested != null) {\\n            return nested.next();\\n        }\\n        Integer v = cur;\\n        cur       = null;\\n        return v;\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        if (cur != null) return true;\\n        \\n        if (this.nested != null) {\\n            if (this.nested.hasNext()) \\n                return true;\\n            this.nested = null;\\n        }\\n        \\n        if (pos >= list.size()) \\n            return false;\\n        \\n        NestedInteger n = list.get(pos++);\\n        \\n        if (!n.isInteger()) {\\n            nested = new NestedIterator(n.getList());\\n            return hasNext();\\n        }\\n        \\n        cur = n.getInteger();\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n    List<NestedInteger> list;\\n    int                 pos;\\n    NestedIterator      nested;\\n    Integer             cur;\\n\\n    public NestedIterator(List<NestedInteger> list) {\\n        this.list = list;\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        if (nested != null) {\\n            return nested.next();\\n        }\\n        Integer v = cur;\\n        cur       = null;\\n        return v;\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        if (cur != null) return true;\\n        \\n        if (this.nested != null) {\\n            if (this.nested.hasNext()) \\n                return true;\\n            this.nested = null;\\n        }\\n        \\n        if (pos >= list.size()) \\n            return false;\\n        \\n        NestedInteger n = list.get(pos++);\\n        \\n        if (!n.isInteger()) {\\n            nested = new NestedIterator(n.getList());\\n            return hasNext();\\n        }\\n        \\n        cur = n.getInteger();\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760927,
                "title": "go-4ms-recursive",
                "content": "```\\ntype NestedIterator struct {\\n    list []*NestedInteger\\n    i int\\n    cur *NestedIterator\\n}\\n\\nfunc Constructor(nestedList []*NestedInteger) *NestedIterator {\\n    return &NestedIterator{list: nestedList}\\n}\\n\\nfunc (this *NestedIterator) Next() int {\\n    if this.list[this.i].IsInteger() {\\n        res := this.list[this.i].GetInteger()\\n        this.i++\\n        return res\\n    }\\n       \\n    return this.cur.Next()\\n}\\n\\nfunc (this *NestedIterator) HasNext() bool {\\n    if this.i >= len(this.list) {\\n        return false\\n    }\\n    if this.list[this.i].IsInteger() {\\n        return true\\n    }\\n    if this.cur == nil {\\n        this.cur = Constructor(this.list[this.i].GetList()) \\n    }\\n    \\n    if this.cur.HasNext() {\\n        return true\\n    }\\n    \\n    this.i++\\n    this.cur = nil\\n    \\n    return this.HasNext()\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype NestedIterator struct {\\n    list []*NestedInteger\\n    i int\\n    cur *NestedIterator\\n}\\n\\nfunc Constructor(nestedList []*NestedInteger) *NestedIterator {\\n    return &NestedIterator{list: nestedList}\\n}\\n\\nfunc (this *NestedIterator) Next() int {\\n    if this.list[this.i].IsInteger() {\\n        res := this.list[this.i].GetInteger()\\n        this.i++\\n        return res\\n    }\\n       \\n    return this.cur.Next()\\n}\\n\\nfunc (this *NestedIterator) HasNext() bool {\\n    if this.i >= len(this.list) {\\n        return false\\n    }\\n    if this.list[this.i].IsInteger() {\\n        return true\\n    }\\n    if this.cur == nil {\\n        this.cur = Constructor(this.list[this.i].GetList()) \\n    }\\n    \\n    if this.cur.HasNext() {\\n        return true\\n    }\\n    \\n    this.i++\\n    this.cur = nil\\n    \\n    return this.HasNext()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 690293,
                "title": "c",
                "content": "DFS\\nAgain, the description is not clear enough. Checking the defination of NestedInteger makes it easier to understand the problem.\\n```\\n        public class NestedIterator\\n        {\\n            private Queue<int> q = new Queue<int>();\\n\\n            public NestedIterator(IList<NestedInteger> nestedList)\\n            {\\n                foreach (var item in nestedList)\\n                    DFS(item);\\n            }\\n\\n            public bool HasNext()\\n            {\\n                return q.Count != 0;\\n            }\\n\\n            public int Next()\\n            {\\n                return q.Count == 0 ? 0 : q.Dequeue();\\n            }\\n\\n            private void DFS(NestedInteger cur)\\n            {\\n                if (cur.IsInteger())\\n                    q.Enqueue(cur.GetInteger());\\n                else\\n                    foreach (var item in cur.GetList())\\n                        DFS(item);\\n            }\\n        }",
                "solutionTags": [],
                "code": "DFS\\nAgain, the description is not clear enough. Checking the defination of NestedInteger makes it easier to understand the problem.\\n```\\n        public class NestedIterator\\n        {\\n            private Queue<int> q = new Queue<int>();\\n\\n            public NestedIterator(IList<NestedInteger> nestedList)\\n            {\\n                foreach (var item in nestedList)\\n                    DFS(item);\\n            }\\n\\n            public bool HasNext()\\n            {\\n                return q.Count != 0;\\n            }\\n\\n            public int Next()\\n            {\\n                return q.Count == 0 ? 0 : q.Dequeue();\\n            }\\n\\n            private void DFS(NestedInteger cur)\\n            {\\n                if (cur.IsInteger())\\n                    q.Enqueue(cur.GetInteger());\\n                else\\n                    foreach (var item in cur.GetList())\\n                        DFS(item);\\n            }\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 638264,
                "title": "clean-swift-stack-solution",
                "content": "Using passed in NestedInteger array as a stack. And in init method pre calculating first NestedInteger and setting that as currentNestedInteger. Need to make sure currentNestedInteger holds the NestedInteger of Int type. If no value left in the nestedList array currentNestedInteger will be nil.\\n\\nTo make sure currentNestedInteger always holds the correct next value precalcuatling value when ```next()``` is called.\\n\\nAnd in ```getCurrent``` checking for Int type NestedInteger if not then flattening the list until found the Int type or list is empty.\\n\\n```\\nclass NestedIterator {\\n    \\n    private var currentIndex: Int\\n    private var nestedList: [NestedInteger]\\n    private var currentNestedInteger: NestedInteger?\\n\\n    init(_ nestedList: [NestedInteger]) {\\n        currentIndex = 0\\n        self.nestedList = nestedList\\n        currentNestedInteger = getCurrent()\\n    }\\n    \\n    func next() -> Int {\\n        let value = currentNestedInteger?.getInteger() ?? 0\\n        currentNestedInteger = getCurrent()\\n        return value\\n    }\\n    \\n    func hasNext() -> Bool {        \\n        return currentNestedInteger != nil                 \\n    }\\n    \\n    private func getCurrent() -> NestedInteger? {\\n        if nestedList.isEmpty { return nil }\\n        \\n        let nestedInteger = nestedList.removeFirst()\\n        if nestedInteger.isInteger() {\\n            return nestedInteger\\n        } else {\\n            let list = nestedInteger.getList()\\n            nestedList.insert(contentsOf: list, at: 0)            \\n            return getCurrent()                        \\n        }\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```next()```\n```getCurrent```\n```\\nclass NestedIterator {\\n    \\n    private var currentIndex: Int\\n    private var nestedList: [NestedInteger]\\n    private var currentNestedInteger: NestedInteger?\\n\\n    init(_ nestedList: [NestedInteger]) {\\n        currentIndex = 0\\n        self.nestedList = nestedList\\n        currentNestedInteger = getCurrent()\\n    }\\n    \\n    func next() -> Int {\\n        let value = currentNestedInteger?.getInteger() ?? 0\\n        currentNestedInteger = getCurrent()\\n        return value\\n    }\\n    \\n    func hasNext() -> Bool {        \\n        return currentNestedInteger != nil                 \\n    }\\n    \\n    private func getCurrent() -> NestedInteger? {\\n        if nestedList.isEmpty { return nil }\\n        \\n        let nestedInteger = nestedList.removeFirst()\\n        if nestedInteger.isInteger() {\\n            return nestedInteger\\n        } else {\\n            let list = nestedInteger.getList()\\n            nestedList.insert(contentsOf: list, at: 0)            \\n            return getCurrent()                        \\n        }\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 586346,
                "title": "very-simple-java-solution-using-a-stack",
                "content": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n    private Stack<NestedInteger> stack;\\n\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        this.stack = new Stack<>();\\n        for (int i = nestedList.size() - 1; i >= 0; i--) stack.push(nestedList.get(i));\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        while (!stack.isEmpty() && !stack.peek().isInteger()) {\\n            List<NestedInteger> list = stack.pop().getList();\\n            for (int i = list.size() - 1; i >= 0; i--) stack.push(list.get(i));\\n        }\\n        return stack.pop().getInteger();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        while (!stack.isEmpty() && !stack.peek().isInteger()) {\\n            List<NestedInteger> list = stack.pop().getList();\\n            for (int i = list.size() - 1; i >= 0; i--) stack.push(list.get(i));\\n        }\\n        return !stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n    private Stack<NestedInteger> stack;\\n\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        this.stack = new Stack<>();\\n        for (int i = nestedList.size() - 1; i >= 0; i--) stack.push(nestedList.get(i));\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        while (!stack.isEmpty() && !stack.peek().isInteger()) {\\n            List<NestedInteger> list = stack.pop().getList();\\n            for (int i = list.size() - 1; i >= 0; i--) stack.push(list.get(i));\\n        }\\n        return stack.pop().getInteger();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        while (!stack.isEmpty() && !stack.peek().isInteger()) {\\n            List<NestedInteger> list = stack.pop().getList();\\n            for (int i = list.size() - 1; i >= 0; i--) stack.push(list.get(i));\\n        }\\n        return !stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526414,
                "title": "java-clean-code-with-dfs",
                "content": "```java \\npublic class NestedIterator implements Iterator<Integer> {\\n\\n\\tprivate List<Integer> flattened = new ArrayList<>();\\n\\tprivate int index = 0;\\n\\n\\tpublic NestedIterator(List<NestedInteger> nestedList) {\\n\\t\\tif (nestedList == null || nestedList.size() == 0) return; // throw exception\\n\\t\\t\\n\\t\\tflattened = new ArrayList<>();\\n\\t\\tdfs(nestedList, flattened);\\n\\t}\\n\\n\\tprivate void dfs(List<NestedInteger> nestedList, List<Integer> flattened) {\\n\\t\\tfor (int i = 0; i < nestedList.size(); i++) {\\n\\t\\t\\tNestedInteger value = nestedList.get(i);\\n\\t\\t\\tif (value.isInteger()) \\n\\t\\t\\t\\tflattened.add(value.getInteger());\\n\\t\\t\\telse\\n\\t\\t\\t\\tdfs(value.getList(), flattened);\\n\\t\\t}\\n\\t}\\n\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t\\treturn index < flattened.size() ? flattened.get(index++) : null;\\n\\t}\\n\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t\\treturn index < flattened.size();\\n\\t}\\n}",
                "solutionTags": [],
                "code": "```java \\npublic class NestedIterator implements Iterator<Integer> {\\n\\n\\tprivate List<Integer> flattened = new ArrayList<>();\\n\\tprivate int index = 0;\\n\\n\\tpublic NestedIterator(List<NestedInteger> nestedList) {\\n\\t\\tif (nestedList == null || nestedList.size() == 0) return; // throw exception\\n\\t\\t\\n\\t\\tflattened = new ArrayList<>();\\n\\t\\tdfs(nestedList, flattened);\\n\\t}\\n\\n\\tprivate void dfs(List<NestedInteger> nestedList, List<Integer> flattened) {\\n\\t\\tfor (int i = 0; i < nestedList.size(); i++) {\\n\\t\\t\\tNestedInteger value = nestedList.get(i);\\n\\t\\t\\tif (value.isInteger()) \\n\\t\\t\\t\\tflattened.add(value.getInteger());\\n\\t\\t\\telse\\n\\t\\t\\t\\tdfs(value.getList(), flattened);\\n\\t\\t}\\n\\t}\\n\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t\\treturn index < flattened.size() ? flattened.get(index++) : null;\\n\\t}\\n\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t\\treturn index < flattened.size();\\n\\t}\\n}",
                "codeTag": "Java"
            },
            {
                "id": 510768,
                "title": "16ms-cxx-93-100-lazy-iterator-do-not-flatten-the-list-at-first",
                "content": "```cpp\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) : list_(nestedList) {\\n    }\\n\\n    int next() {\\n        auto& ni = list_[index_];\\n        if (ni.isInteger()) {\\n            int v = ni.getInteger();\\n            index_ ++;\\n            return v;\\n        } else {\\n            return nestedIter_->next();\\n        }\\n    }\\n\\n    bool hasNext() {\\n        if (index_ >= list_.size())\\n            return false;\\n        \\n        auto& current = list_[index_]; \\n        if (current.isInteger())\\n            return true;\\n        \\n        if (!nestedIter_ && !current.getList().empty())\\n            nestedIter_.reset(new NestedIterator(current.getList()));\\n\\n        if (nestedIter_ && nestedIter_->hasNext())\\n            return true;\\n        else    \\n            nestedIter_ = nullptr;\\n        \\n        // current list is empty, check remain nodes.\\n        index_ += 1;\\n        return hasNext();\\n    }\\n\\nprivate:\\n    vector<NestedInteger> &list_;    // avoid copy\\n    int index_{0};\\n\\n    // It\\'s valid if list_[index] is a list\\n    std::unique_ptr<NestedIterator> nestedIter_;\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) : list_(nestedList) {\\n    }\\n\\n    int next() {\\n        auto& ni = list_[index_];\\n        if (ni.isInteger()) {\\n            int v = ni.getInteger();\\n            index_ ++;\\n            return v;\\n        } else {\\n            return nestedIter_->next();\\n        }\\n    }\\n\\n    bool hasNext() {\\n        if (index_ >= list_.size())\\n            return false;\\n        \\n        auto& current = list_[index_]; \\n        if (current.isInteger())\\n            return true;\\n        \\n        if (!nestedIter_ && !current.getList().empty())\\n            nestedIter_.reset(new NestedIterator(current.getList()));\\n\\n        if (nestedIter_ && nestedIter_->hasNext())\\n            return true;\\n        else    \\n            nestedIter_ = nullptr;\\n        \\n        // current list is empty, check remain nodes.\\n        index_ += 1;\\n        return hasNext();\\n    }\\n\\nprivate:\\n    vector<NestedInteger> &list_;    // avoid copy\\n    int index_{0};\\n\\n    // It\\'s valid if list_[index] is a list\\n    std::unique_ptr<NestedIterator> nestedIter_;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477390,
                "title": "c-concise-selectmany-based-iterator-bests-85",
                "content": "```csharp\\npublic class NestedIterator \\n{\\n    IEnumerator<int> iterator;\\n\\n    IEnumerable<int> Iterate(NestedInteger n)\\n    {\\n        if(n.IsInteger()) return new[] { n.GetInteger() };\\n        else return n.GetList().SelectMany(Iterate).AsEnumerable();\\n    }\\n    \\n    public NestedIterator(IList<NestedInteger> nestedList) => iterator = nestedList.SelectMany(Iterate).GetEnumerator();\\n    public bool HasNext() => iterator.MoveNext();\\n    public int Next() => iterator.Current;\\n}\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```csharp\\npublic class NestedIterator \\n{\\n    IEnumerator<int> iterator;\\n\\n    IEnumerable<int> Iterate(NestedInteger n)\\n    {\\n        if(n.IsInteger()) return new[] { n.GetInteger() };\\n        else return n.GetList().SelectMany(Iterate).AsEnumerable();\\n    }\\n    \\n    public NestedIterator(IList<NestedInteger> nestedList) => iterator = nestedList.SelectMany(Iterate).GetEnumerator();\\n    public bool HasNext() => iterator.MoveNext();\\n    public int Next() => iterator.Current;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 326782,
                "title": "c-simple-100-solution-using-stack-true-iterator-with-no-pre-processing",
                "content": "Most post here uses pre processing to first store the elements in a container and go through them later on. This kind of method would:\\n1. Require huge space if the element in the list is a certain type like a customized class that needs much more space than \"int\".\\n2. The initiation of the iterator is time consuming without even start using it.\\n3.  Does uncessary work if the list has 100000 element but we might go through only 10 of it.\\n\\nThe following code keeps a pointer to the current element and staks to store information when we go into the next level of brackets. Special attention needs to be paid for cases like [1, [2, [] ], 3] that has empty vectors.\\n```\\nclass NestedIterator {\\nprivate:\\n    NestedInteger* p; //pointer to current element\\n    int index; // index of current element in vector\\n    int size; // size of current vector\\n    stack<NestedInteger*> pStack; // stack for p\\n    stack<int> iStack; // stack for index\\n    stack<int> sStack; // stack for size    \\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        index = 0;\\n        size  = nestedList.size();\\n        if(size != 0)\\n            p = &nestedList[0];\\n    }\\n\\n    int next() {\\n        int res = p -> getInteger();\\n        p++; // move to next element, maybe invalid but will be handled by hasNext()\\n        index++;\\n        return res;\\n    }\\n\\n    bool hasNext() { // move to the next(including current) node that is an integer \\n        while(index >= size || p -> isInteger() == false){ /*p -> getList().size() == 0 && p -> isInteger() == false || */ // it turns out p -> isInteger is also false if p points to empty list []\\n            if(index >= size){ // if out of current vector range \\n                if(pStack.size() == 0)\\n                    return false;\\n                p = pStack.top() + 1;\\n                index = iStack.top() + 1;\\n                size = sStack.top();\\n                pStack.pop();\\n                iStack.pop();\\n                sStack.pop();\\n            }else if(p -> getList().size() == 0){// if current p is empty, go to next element in current vector\\n                p++;\\n                index++;\\n            }else{// p is not integer, go to next level\\n                pStack.push(p);\\n                iStack.push(index);\\n                sStack.push(size);\\n                size = p -> getList().size();\\n                p = &(p -> getList()[0]); //vector head addr;\\n                index = 0;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass NestedIterator {\\nprivate:\\n    NestedInteger* p; //pointer to current element\\n    int index; // index of current element in vector\\n    int size; // size of current vector\\n    stack<NestedInteger*> pStack; // stack for p\\n    stack<int> iStack; // stack for index\\n    stack<int> sStack; // stack for size    \\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        index = 0;\\n        size  = nestedList.size();\\n        if(size != 0)\\n            p = &nestedList[0];\\n    }\\n\\n    int next() {\\n        int res = p -> getInteger();\\n        p++; // move to next element, maybe invalid but will be handled by hasNext()\\n        index++;\\n        return res;\\n    }\\n\\n    bool hasNext() { // move to the next(including current) node that is an integer \\n        while(index >= size || p -> isInteger() == false){ /*p -> getList().size() == 0 && p -> isInteger() == false || */ // it turns out p -> isInteger is also false if p points to empty list []\\n            if(index >= size){ // if out of current vector range \\n                if(pStack.size() == 0)\\n                    return false;\\n                p = pStack.top() + 1;\\n                index = iStack.top() + 1;\\n                size = sStack.top();\\n                pStack.pop();\\n                iStack.pop();\\n                sStack.pop();\\n            }else if(p -> getList().size() == 0){// if current p is empty, go to next element in current vector\\n                p++;\\n                index++;\\n            }else{// p is not integer, go to next level\\n                pStack.push(p);\\n                iStack.push(index);\\n                sStack.push(size);\\n                size = p -> getList().size();\\n                p = &(p -> getList()[0]); //vector head addr;\\n                index = 0;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322476,
                "title": "javascript-98-recursion",
                "content": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * function NestedInteger() {\\n *\\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     @return {boolean}\\n *     this.isInteger = function() {\\n *         ...\\n *     };\\n *\\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     Return null if this NestedInteger holds a nested list\\n *     @return {integer}\\n *     this.getInteger = function() {\\n *         ...\\n *     };\\n *\\n *     Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     Return null if this NestedInteger holds a single integer\\n *     @return {NestedInteger[]}\\n *     this.getList = function() {\\n *         ...\\n *     };\\n * };\\n */\\n/**\\n * @constructor\\n * @param {NestedInteger[]} nestedList\\n */\\nconst flatten = function(nestedList, res = []) {\\n    if (!nestedList.length) {\\n        return res;\\n    }\\n    \\n    while(nestedList.length) {\\n        let list = nestedList.shift();\\n        if (list.isInteger()) {\\n            res.push(list.getInteger());\\n        } else {\\n            flatten(list.getList(), res);\\n        }\\n    }\\n    return res;\\n}\\nvar NestedIterator = function(nestedList) {\\n  this.queue = flatten(nestedList);  \\n};\\n\\n/**\\n * @this NestedIterator\\n * @returns {boolean}\\n */\\nNestedIterator.prototype.hasNext = function() {\\n    return this.queue.length;\\n};\\n\\n/**\\n * @this NestedIterator\\n * @returns {integer}\\n */\\nNestedIterator.prototype.next = function() {\\n    return this.queue.shift();\\n};\\n\\n/**\\n * Your NestedIterator will be called like this:\\n * var i = new NestedIterator(nestedList), a = [];\\n * while (i.hasNext()) a.push(i.next());\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * function NestedInteger() {\\n *\\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     @return {boolean}\\n *     this.isInteger = function() {\\n *         ...\\n *     };\\n *\\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     Return null if this NestedInteger holds a nested list\\n *     @return {integer}\\n *     this.getInteger = function() {\\n *         ...\\n *     };\\n *\\n *     Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     Return null if this NestedInteger holds a single integer\\n *     @return {NestedInteger[]}\\n *     this.getList = function() {\\n *         ...\\n *     };\\n * };\\n */\\n/**\\n * @constructor\\n * @param {NestedInteger[]} nestedList\\n */\\nconst flatten = function(nestedList, res = []) {\\n    if (!nestedList.length) {\\n        return res;\\n    }\\n    \\n    while(nestedList.length) {\\n        let list = nestedList.shift();\\n        if (list.isInteger()) {\\n            res.push(list.getInteger());\\n        } else {\\n            flatten(list.getList(), res);\\n        }\\n    }\\n    return res;\\n}\\nvar NestedIterator = function(nestedList) {\\n  this.queue = flatten(nestedList);  \\n};\\n\\n/**\\n * @this NestedIterator\\n * @returns {boolean}\\n */\\nNestedIterator.prototype.hasNext = function() {\\n    return this.queue.length;\\n};\\n\\n/**\\n * @this NestedIterator\\n * @returns {integer}\\n */\\nNestedIterator.prototype.next = function() {\\n    return this.queue.shift();\\n};\\n\\n/**\\n * Your NestedIterator will be called like this:\\n * var i = new NestedIterator(nestedList), a = [];\\n * while (i.hasNext()) a.push(i.next());\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 227409,
                "title": "javascript-iterative-stack-solution",
                "content": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * function NestedInteger() {\\n *\\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     @return {boolean}\\n *     this.isInteger = function() {\\n *         ...\\n *     };\\n *\\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     Return null if this NestedInteger holds a nested list\\n *     @return {integer}\\n *     this.getInteger = function() {\\n *         ...\\n *     };\\n *\\n *     Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     Return null if this NestedInteger holds a single integer\\n *     @return {NestedInteger[]}\\n *     this.getList = function() {\\n *         ...\\n *     };\\n * };\\n */\\n/**\\n * @constructor\\n * @param {NestedInteger[]} nestedList\\n */\\nvar NestedIterator = function(nestedList) {\\n  this.stack = [nestedList]\\n};\\n\\n\\n/**\\n * @this NestedIterator\\n * @returns {boolean}\\n */\\nNestedIterator.prototype.hasNext = function() {\\n  while (Array.isArray(this.stack[this.stack.length - 1])) {\\n    let top = this.stack.pop()\\n    for (let i = top.length - 1; i >= 0; i--)\\n      this.stack.push(top[i].isInteger() ? top[i] : top[i].getList())\\n  }\\n  \\n  return !!this.stack.length\\n};\\n\\n/**\\n * @this NestedIterator\\n * @returns {integer}\\n */\\nNestedIterator.prototype.next = function() {\\n  this.hasNext()\\n  return this.stack.pop().getInteger()\\n};\\n\\n/**\\n * Your NestedIterator will be called like this:\\n * var i = new NestedIterator(nestedList), a = [];\\n * while (i.hasNext()) a.push(i.next());\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * function NestedInteger() {\\n *\\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     @return {boolean}\\n *     this.isInteger = function() {\\n *         ...\\n *     };\\n *\\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     Return null if this NestedInteger holds a nested list\\n *     @return {integer}\\n *     this.getInteger = function() {\\n *         ...\\n *     };\\n *\\n *     Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     Return null if this NestedInteger holds a single integer\\n *     @return {NestedInteger[]}\\n *     this.getList = function() {\\n *         ...\\n *     };\\n * };\\n */\\n/**\\n * @constructor\\n * @param {NestedInteger[]} nestedList\\n */\\nvar NestedIterator = function(nestedList) {\\n  this.stack = [nestedList]\\n};\\n\\n\\n/**\\n * @this NestedIterator\\n * @returns {boolean}\\n */\\nNestedIterator.prototype.hasNext = function() {\\n  while (Array.isArray(this.stack[this.stack.length - 1])) {\\n    let top = this.stack.pop()\\n    for (let i = top.length - 1; i >= 0; i--)\\n      this.stack.push(top[i].isInteger() ? top[i] : top[i].getList())\\n  }\\n  \\n  return !!this.stack.length\\n};\\n\\n/**\\n * @this NestedIterator\\n * @returns {integer}\\n */\\nNestedIterator.prototype.next = function() {\\n  this.hasNext()\\n  return this.stack.pop().getInteger()\\n};\\n\\n/**\\n * Your NestedIterator will be called like this:\\n * var i = new NestedIterator(nestedList), a = [];\\n * while (i.hasNext()) a.push(i.next());\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 216353,
                "title": "python-iterative-dfs",
                "content": "```\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type nestedList: List[NestedInteger]\\n        \"\"\"\\n        self.stack = []\\n        for i in range(len(nestedList)-1, -1, -1):\\n            self.stack.append(nestedList[i])\\n        self.nextValue = None\\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n\\t\\tans = None\\n        if self.hasNext():\\n            ans = self.nextValue\\n            self.nextValue = None #reset self.nextValue\\n        return ans\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        if self.nextValue is not None:\\n            return True\\n\\n        while len(self.stack) > 0:\\n            ni = self.stack.pop()\\n            if ni.isInteger():\\n                self.nextValue = ni.getInteger()\\n                return True\\n            else:\\n                niList = ni.getList()\\n                for i in range(len(niList) - 1, -1, -1):\\n                    self.stack.append(niList[i])\\n        return False",
                "solutionTags": [],
                "code": "```\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type nestedList: List[NestedInteger]\\n        \"\"\"\\n        self.stack = []\\n        for i in range(len(nestedList)-1, -1, -1):\\n            self.stack.append(nestedList[i])\\n        self.nextValue = None\\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n\\t\\tans = None\\n        if self.hasNext():\\n            ans = self.nextValue\\n            self.nextValue = None #reset self.nextValue\\n        return ans\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        if self.nextValue is not None:\\n            return True\\n\\n        while len(self.stack) > 0:\\n            ni = self.stack.pop()\\n            if ni.isInteger():\\n                self.nextValue = ni.getInteger()\\n                return True\\n            else:\\n                niList = ni.getList()\\n                for i in range(len(niList) - 1, -1, -1):\\n                    self.stack.append(niList[i])\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 188935,
                "title": "java-implementation-straight-forward-recursive-hasnext",
                "content": "This implementation ensures the head is always an integer.\\n\\n```\\npublic class NestedIterator implements Iterator<Integer> {\\n    public Stack<NestedInteger> stack = new Stack<>();\\n    \\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        for (int i = nestedList.size() - 1; i >= 0; i--) {\\n            stack.push(nestedList.get(i));\\n        }\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return stack.pop().getInteger();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        if (stack.isEmpty()) {\\n            return false;\\n        }\\n        \\n        NestedInteger nestedInteger = stack.peek();\\n        if (nestedInteger.isInteger()) { //Head is integer\\n            return true;\\n        }\\n        stack.pop(); //Head is list, we\\'re breaking it down.\\n        for (int i = nestedInteger.getList().size() - 1; i >= 0; i--) {\\n            stack.push(nestedInteger.getList().get(i));\\n        }\\n        \\n        return hasNext();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n    public Stack<NestedInteger> stack = new Stack<>();\\n    \\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        for (int i = nestedList.size() - 1; i >= 0; i--) {\\n            stack.push(nestedList.get(i));\\n        }\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return stack.pop().getInteger();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        if (stack.isEmpty()) {\\n            return false;\\n        }\\n        \\n        NestedInteger nestedInteger = stack.peek();\\n        if (nestedInteger.isInteger()) { //Head is integer\\n            return true;\\n        }\\n        stack.pop(); //Head is list, we\\'re breaking it down.\\n        for (int i = nestedInteger.getList().size() - 1; i >= 0; i--) {\\n            stack.push(nestedInteger.getList().get(i));\\n        }\\n        \\n        return hasNext();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153195,
                "title": "reasonable-java-solution-with-detailed-annotations",
                "content": "This is the basic idea:\\n1. There is a Stack<NestedInteger> to save the NestedInteger s to keep the order\\n2. ALWAYS keep the fact that the top of the stack is an integer  (see method \"stackMaintain()\")\\n3. If we call next(), the top integer will be taken, and the remaining stack will be maintained, to make sure that the Condition 2 is satisfied.\\n4. If we call hasNext(), we will change NOTHING to the stack, just returning the fact whether we still have some integers left in the stack. \\n\\n\\n```\\nimport java.util.NoSuchElementException;\\npublic class NestedIterator implements Iterator<Integer> {\\n    private Stack<NestedInteger> nestStack = new Stack<NestedInteger>(); // construct a new stack to save the NestedIterator\\n   \\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        for (int i = nestedList.size() - 1; i >= 0; i--) {\\n            nestStack.push(nestedList.get(i)); // put all the nestedList to the nestStack\\n        }\\n        stackMaintain(); // see methond \"stackMaintain()\"\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        // in case of people use too many next() without hasNext(), we should set an \"Exception\" here\\n        if (nestStack.empty()) { throw new NoSuchElementException(); }\\n        // since the integer is always on top of the stack, we just pop it and take it\\n        int next = nestStack.pop().getInteger();\\n        // after the top integer is taken, we should always maintain the stack\\n        stackMaintain();\\n        return next;\\n        \\n    }\\n\\n    @Override\\n    public boolean hasNext() { \\n        return (!nestStack.empty()); \\n        // thanks to stackMaintain(), there is always an integer on top of the stack\\n        // if there is no integer, this means that the stack is already empty\\n        // thus, we just need to judge whether the stack is empty\\n    }\\n    \\n    private void stackMaintain() { // the method to make the top of the stack an Integer\\n        \\n        // If the stack is empty or the peek is already an integer, we don\\'t do anything\\n        // But as long as it is not empty && the peek is not an integer, we will keep \"maintaining\" it\\n        // until: the peek is integer OR the stack is already empty\\n        while (!nestStack.empty() && !nestStack.peek().isInteger()) { \\n            // while the peek is not integer, pop() it and add the numbers to the stack util there is an int on top of the stack\\n            // 1. pop the peek first\\n            List<NestedInteger> subList= nestStack.pop().getList();\\n            // 2. add all the elements to the stack, according to the inital order\\n            for (int i = subList.size() - 1; i >= 0; i--) {\\n                nestStack.push(subList.get(i));\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.NoSuchElementException;\\npublic class NestedIterator implements Iterator<Integer> {\\n    private Stack<NestedInteger> nestStack = new Stack<NestedInteger>(); // construct a new stack to save the NestedIterator\\n   \\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        for (int i = nestedList.size() - 1; i >= 0; i--) {\\n            nestStack.push(nestedList.get(i)); // put all the nestedList to the nestStack\\n        }\\n        stackMaintain(); // see methond \"stackMaintain()\"\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        // in case of people use too many next() without hasNext(), we should set an \"Exception\" here\\n        if (nestStack.empty()) { throw new NoSuchElementException(); }\\n        // since the integer is always on top of the stack, we just pop it and take it\\n        int next = nestStack.pop().getInteger();\\n        // after the top integer is taken, we should always maintain the stack\\n        stackMaintain();\\n        return next;\\n        \\n    }\\n\\n    @Override\\n    public boolean hasNext() { \\n        return (!nestStack.empty()); \\n        // thanks to stackMaintain(), there is always an integer on top of the stack\\n        // if there is no integer, this means that the stack is already empty\\n        // thus, we just need to judge whether the stack is empty\\n    }\\n    \\n    private void stackMaintain() { // the method to make the top of the stack an Integer\\n        \\n        // If the stack is empty or the peek is already an integer, we don\\'t do anything\\n        // But as long as it is not empty && the peek is not an integer, we will keep \"maintaining\" it\\n        // until: the peek is integer OR the stack is already empty\\n        while (!nestStack.empty() && !nestStack.peek().isInteger()) { \\n            // while the peek is not integer, pop() it and add the numbers to the stack util there is an int on top of the stack\\n            // 1. pop the peek first\\n            List<NestedInteger> subList= nestStack.pop().getList();\\n            // 2. add all the elements to the stack, according to the inital order\\n            for (int i = subList.size() - 1; i >= 0; i--) {\\n                nestStack.push(subList.get(i));\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146564,
                "title": "python-solution-with-explaination",
                "content": "The idea is to use a stack to access the next element. In order to access the next element, we store the list and index of the next element inside the list as a pair on the stack. When hasNext() is called, stack needs to be checked, if its top list\\'s next element is integer, then return True else keep on traversing the stack to find the next integer. This is the crux of the logic, see comments in the hasNext() method for more details.\\n\\n```\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type nestedList: List[NestedInteger]\\n        \"\"\"\\n        self.lists = nestedList\\n        self.stack = [[nestedList, 0]] # <list, next element index>\\n   \\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        rtn = self.stack[-1][0][self.stack[-1][1]].getInteger()\\n        self.stack[-1][1] += 1 # Update the top list by 1\\n\\n        return rtn\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        while self.stack:\\n            top = self.stack[-1][0]\\n            idx = self.stack[-1][1]\\n            \\n            # If the last call to next consumed all elements from the top list, then pop the current top list.\\n            if idx == len(top): \\n                self.stack.pop()\\n                continue\\n            \\n            # If the element at idx on top list is an integer, then return True\\n            if top[idx].isInteger():\\n                return True\\n            \\n            # Before adding another element to the stack, the top element needs to be updated so that\\n            # next time it is popped, it would point to the next element within it.\\n            self.stack[-1][1] += 1 \\n            self.stack.append([top[idx].getList(), 0])\\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type nestedList: List[NestedInteger]\\n        \"\"\"\\n        self.lists = nestedList\\n        self.stack = [[nestedList, 0]] # <list, next element index>\\n   \\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        rtn = self.stack[-1][0][self.stack[-1][1]].getInteger()\\n        self.stack[-1][1] += 1 # Update the top list by 1\\n\\n        return rtn\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        while self.stack:\\n            top = self.stack[-1][0]\\n            idx = self.stack[-1][1]\\n            \\n            # If the last call to next consumed all elements from the top list, then pop the current top list.\\n            if idx == len(top): \\n                self.stack.pop()\\n                continue\\n            \\n            # If the element at idx on top list is an integer, then return True\\n            if top[idx].isInteger():\\n                return True\\n            \\n            # Before adding another element to the stack, the top element needs to be updated so that\\n            # next time it is popped, it would point to the next element within it.\\n            self.stack[-1][1] += 1 \\n            self.stack.append([top[idx].getList(), 0])\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123768,
                "title": "python-solution",
                "content": "```\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type nestedList: List[NestedInteger]\\n        \"\"\"\\n        self.stack = [ni for ni in reversed(nestedList)]\\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.stack.pop().getInteger()\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        while self.stack:\\n            top = self.stack[-1]\\n            if top.isInteger():\\n                return True\\n            self.stack.pop()\\n            for ni in reversed(top.getList()):\\n                self.stack.append(ni)\\n\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type nestedList: List[NestedInteger]\\n        \"\"\"\\n        self.stack = [ni for ni in reversed(nestedList)]\\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.stack.pop().getInteger()\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        while self.stack:\\n            top = self.stack[-1]\\n            if top.isInteger():\\n                return True\\n            self.stack.pop()\\n            for ni in reversed(top.getList()):\\n                self.stack.append(ni)\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80194,
                "title": "swift-solution",
                "content": "```\\nclass NestedIterator {\\n    \\n    var stack = [NestedInteger]()\\n    \\n    init(_ nestedList: [NestedInteger]) {\\n        for i in stride(from: nestedList.count - 1, through: 0, by: -1) {\\n            stack.append(nestedList[i])\\n        }\\n    }\\n    \\n    func next() -> Int {\\n        return stack.removeLast().getInteger()\\n    }\\n    \\n    func hasNext() -> Bool {\\n        while !stack.isEmpty {\\n            let current = stack.last!\\n            if current.isInteger() {\\n                return true\\n            }\\n            stack.removeLast()\\n            for i in stride(from: current.getList().count - 1, through: 0, by: -1) {\\n                stack.append(current.getList()[i])\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n\\nclass NestedInteger {\\n    var list: [NestedInteger]?\\n    var integer: Int?\\n    \\n    public init(_ list: [NestedInteger]) {\\n        self.list = list\\n    }\\n    \\n    public init(_ integer: Int) {\\n        self.integer = integer\\n    }\\n    \\n    public init() {\\n        self.list = [NestedInteger]()\\n    }\\n    \\n    public func isInteger() -> Bool {\\n        return self.integer != nil\\n    }\\n    \\n    public func getInteger() -> Int {\\n        return self.integer!\\n    }\\n    \\n    public func setInteger(value: Int) {\\n        self.integer = value\\n    }\\n    \\n    public func add(elem: NestedInteger) {\\n        if list != nil {\\n            self.list?.append(elem)\\n        } else {\\n            self.list = [NestedInteger]()\\n            self.list?.append(elem)\\n        }\\n    }\\n    \\n    public func getList() -> [NestedInteger] {\\n        return self.list!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Stack"
                ],
                "code": "```\\nclass NestedIterator {\\n    \\n    var stack = [NestedInteger]()\\n    \\n    init(_ nestedList: [NestedInteger]) {\\n        for i in stride(from: nestedList.count - 1, through: 0, by: -1) {\\n            stack.append(nestedList[i])\\n        }\\n    }\\n    \\n    func next() -> Int {\\n        return stack.removeLast().getInteger()\\n    }\\n    \\n    func hasNext() -> Bool {\\n        while !stack.isEmpty {\\n            let current = stack.last!\\n            if current.isInteger() {\\n                return true\\n            }\\n            stack.removeLast()\\n            for i in stride(from: current.getList().count - 1, through: 0, by: -1) {\\n                stack.append(current.getList()[i])\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n\\nclass NestedInteger {\\n    var list: [NestedInteger]?\\n    var integer: Int?\\n    \\n    public init(_ list: [NestedInteger]) {\\n        self.list = list\\n    }\\n    \\n    public init(_ integer: Int) {\\n        self.integer = integer\\n    }\\n    \\n    public init() {\\n        self.list = [NestedInteger]()\\n    }\\n    \\n    public func isInteger() -> Bool {\\n        return self.integer != nil\\n    }\\n    \\n    public func getInteger() -> Int {\\n        return self.integer!\\n    }\\n    \\n    public func setInteger(value: Int) {\\n        self.integer = value\\n    }\\n    \\n    public func add(elem: NestedInteger) {\\n        if list != nil {\\n            self.list?.append(elem)\\n        } else {\\n            self.list = [NestedInteger]()\\n            self.list?.append(elem)\\n        }\\n    }\\n    \\n    public func getList() -> [NestedInteger] {\\n        return self.list!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80282,
                "title": "purely-recursive-solution-without-storing-list",
                "content": "Rather than storing a stack of iterators, I use three members to list out all elements:\\n\\n``` iterator ``` - a list iterator of type ```Iterator<NestedInteger>```\\n``` subiter ``` - a nested iterator of type ```NestedIterator```\\n``` current ``` - pointer to the current nested list at hand.\\n\\nA recursive structure - think of the whole nested list as root of a tree, the child elements being either purely integer or roots of similar subtrees. To iterate over the next child of a root, we'll first have to finish iterating over the current subtree.\\n\\n```\\n                                        [[],1,[2,[3]]]\\n                                       /     |        \\\\\\n                                      []     1         [2,[3]]\\n                                                      /       \\\\\\n                                                     2        [3]\\n                                                                \\\\\\n                                                                 3\\n```\\nIt can be seen that a dfs approach for iteration over the tree will suffice to give us the answer\\n\\n```\\npublic class NestedIterator implements Iterator<Integer> {\\n\\n    ListIterator<NestedInteger> iterator; //iterator over nodes\\n    NestedIterator subiter; //subiterator for each of those nodes\\n    NestedInteger current; //current list\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        if(nestedList != null)\\n           iterator = nestedList.listIterator();\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        //if 'current' is integer, return it\\n        if(current.isInteger()) return current.getInteger(); \\n        //otherwise, the 'next' lies in the subiterator for 'current'\\n        return subiter.next(); \\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        //first we will finish iterating over all elements\\n        // in the subtree through subiterator\\n        if(subiter != null && subiter.hasNext()) return true;\\n        //if subiterator has not been initialized or has reached the \\n        //end of 'current', start processing\\n        //the next child of the parent list\\n        if(iterator.hasNext()){\\n            current = iterator.next();\\n            //integer\\n            if(current.isInteger()) return true; \\n            //empty list i.e. []\\n            if(current.getList().size() == 0) return hasNext(); \\n            //initialize a subiterator on this non integer list\\n            subiter = new NestedIterator(current.getList());\\n            // if subiterator has an element remaining or \\n            //this list has an element remaining\\n            return subiter.hasNext()||hasNext(); \\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "``` iterator ```\n```Iterator<NestedInteger>```\n``` subiter ```\n```NestedIterator```\n``` current ```\n```\\n                                        [[],1,[2,[3]]]\\n                                       /     |        \\\\\\n                                      []     1         [2,[3]]\\n                                                      /       \\\\\\n                                                     2        [3]\\n                                                                \\\\\\n                                                                 3\\n```\n```\\npublic class NestedIterator implements Iterator<Integer> {\\n\\n    ListIterator<NestedInteger> iterator; //iterator over nodes\\n    NestedIterator subiter; //subiterator for each of those nodes\\n    NestedInteger current; //current list\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        if(nestedList != null)\\n           iterator = nestedList.listIterator();\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        //if 'current' is integer, return it\\n        if(current.isInteger()) return current.getInteger(); \\n        //otherwise, the 'next' lies in the subiterator for 'current'\\n        return subiter.next(); \\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        //first we will finish iterating over all elements\\n        // in the subtree through subiterator\\n        if(subiter != null && subiter.hasNext()) return true;\\n        //if subiterator has not been initialized or has reached the \\n        //end of 'current', start processing\\n        //the next child of the parent list\\n        if(iterator.hasNext()){\\n            current = iterator.next();\\n            //integer\\n            if(current.isInteger()) return true; \\n            //empty list i.e. []\\n            if(current.getList().size() == 0) return hasNext(); \\n            //initialize a subiterator on this non integer list\\n            subiter = new NestedIterator(current.getList());\\n            // if subiterator has an element remaining or \\n            //this list has an element remaining\\n            return subiter.hasNext()||hasNext(); \\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80296,
                "title": "java-8-using-streaming-api",
                "content": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n\\n  private Iterator<Integer> iterator;\\n  \\n  public NestedIterator(List<NestedInteger> nestedList) {\\n    iterator = flatStream(nestedList).iterator();\\n  }\\n\\n  private Stream<Integer> flatStream(List<NestedInteger> nestedList) {\\n    return nestedList.stream()\\n        .flatMap(ni -> ni.isInteger() ? Stream.of(ni.getInteger()) : flatStream(ni.getList()));\\n  }\\n\\n  @Override\\n  public Integer next() {\\n    return iterator.next();\\n  }\\n\\n  @Override\\n  public boolean hasNext() {\\n    return iterator.hasNext();\\n\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n\\n  private Iterator<Integer> iterator;\\n  \\n  public NestedIterator(List<NestedInteger> nestedList) {\\n    iterator = flatStream(nestedList).iterator();\\n  }\\n\\n  private Stream<Integer> flatStream(List<NestedInteger> nestedList) {\\n    return nestedList.stream()\\n        .flatMap(ni -> ni.isInteger() ? Stream.of(ni.getInteger()) : flatStream(ni.getList()));\\n  }\\n\\n  @Override\\n  public Integer next() {\\n    return iterator.next();\\n  }\\n\\n  @Override\\n  public boolean hasNext() {\\n    return iterator.hasNext();\\n\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80324,
                "title": "share-my-5-line-python-solution",
                "content": "```\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type nestedList: List[NestedInteger]\\n        \"\"\"\\n        self.nl = nestedList[::-1]\\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.nl.pop().getInteger()\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        while self.nl and not self.nl[-1].isInteger():\\n            self.nl.extend(self.nl.pop().getList()[::-1])\\n        return bool(self.nl)\\n```",
                "solutionTags": [],
                "code": "```\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type nestedList: List[NestedInteger]\\n        \"\"\"\\n        self.nl = nestedList[::-1]\\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.nl.pop().getInteger()\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        while self.nl and not self.nl[-1].isInteger():\\n            self.nl.extend(self.nl.pop().getList()[::-1])\\n        return bool(self.nl)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80353,
                "title": "python-99-112ms-solution",
                "content": "    class NestedIterator(object):\\n        def __init__(self, nestedList):\\n            self.l = self._flatten(nestedList)\\n            self.i = -1\\n            \\n        def _flatten(self, l):\\n            l2 = []\\n            for ele in l:\\n                if ele.isInteger():\\n                    l2.append(ele.getInteger())\\n                else:\\n                    l2.extend(self._flatten(ele.getList()))\\n            return l2\\n    \\n        def next(self):\\n            self.i += 1\\n            return self.l[self.i]\\n    \\n        def hasNext(self):\\n            return self.i < len(self.l) - 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class NestedIterator(object):\\n        def __init__(self, nestedList):\\n            self.l = self._flatten(nestedList)\\n            self.i = -1\\n            \\n        def _flatten(self, l):\\n            l2 = []\\n            for ele in l:\\n                if ele.isInteger():\\n                    l2.append(ele.getInteger())\\n                else:\\n                    l2.extend(self._flatten(ele.getList()))\\n            return l2\\n    \\n        def next(self):\\n            self.i += 1\\n            return self.l[self.i]\\n    \\n        def hasNext(self):\\n            return self.i < len(self.l) - 1",
                "codeTag": "Java"
            },
            {
                "id": 80357,
                "title": "easy-to-understand-java-solution-with-recursion",
                "content": "   We can easily think of recursion since this nestedInteger is defined as Integer and List can contain each other. So my solution basically is to store all integers to a normal ArrayList, well, which costs more space than expected.\\n\\nFor the nestedList given, we iterate all its elements in order. If the nestedInteger is an integer, add it to the list; if not, it means it is a list then. Do the recursion for the list we've done for its parent list. That describes basically what nestedListHelper() and nestedIntegerHelper() do.\\n\\nHope it helps.\\n\\n\\n\\n    public class NestedIterator implements Iterator<Integer> {\\n    \\n    List<Integer> list = new ArrayList<Integer>();    \\n    \\n    int curIdx = 0;\\n    \\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        nestedListHelper(nestedList);\\n    }\\n    \\n    private void nestedListHelper(List<NestedInteger> nestedList) {\\n        for(NestedInteger nestedInteger: nestedList) {\\n            nestedIntegerHelper(nestedInteger);\\n        }\\n    }\\n\\n    private void nestedIntegerHelper(NestedInteger nestedInteger) {\\n        if(nestedInteger.isInteger()) {\\n            list.add(nestedInteger.getInteger());\\n            return;\\n        }\\n        nestedListHelper(nestedInteger.getList());\\n    }\\n    @Override\\n    public Integer next() {\\n        return list.get(curIdx++);\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return curIdx < list.size();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "   We can easily think of recursion since this nestedInteger is defined as Integer and List can contain each other. So my solution basically is to store all integers to a normal ArrayList, well, which costs more space than expected.\\n\\nFor the nestedList given, we iterate all its elements in order. If the nestedInteger is an integer, add it to the list; if not, it means it is a list then. Do the recursion for the list we've done for its parent list. That describes basically what nestedListHelper() and nestedIntegerHelper() do.\\n\\nHope it helps.\\n\\n\\n\\n    public class NestedIterator implements Iterator<Integer> {\\n    \\n    List<Integer> list = new ArrayList<Integer>();    \\n    \\n    int curIdx = 0;\\n    \\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        nestedListHelper(nestedList);\\n    }\\n    \\n    private void nestedListHelper(List<NestedInteger> nestedList) {\\n        for(NestedInteger nestedInteger: nestedList) {\\n            nestedIntegerHelper(nestedInteger);\\n        }\\n    }\\n\\n    private void nestedIntegerHelper(NestedInteger nestedInteger) {\\n        if(nestedInteger.isInteger()) {\\n            list.add(nestedInteger.getInteger());\\n            return;\\n        }\\n        nestedListHelper(nestedInteger.getList());\\n    }\\n    @Override\\n    public Integer next() {\\n        return list.get(curIdx++);\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return curIdx < list.size();\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 80380,
                "title": "java-recursive-solution-straightforward-to-understand",
                "content": "Assuming the list to be iterated is [A, B], where A and B are in type NestedInteger.\\nWhenever we visit an element (current element), it has following three conditions: \\na) it is an integer; b) it is a non-empty list; c) it is an empty list.\\n\\nIf (a), we just output the integer and move to next element\\n\\nif (b), actually we are back to original problem (i.e. iterating a list of NestedInteger) before we move to next element\\n\\nif (c), we skip it and move to next element\\n\\nSimilarly, when we check hasNext() integer, we have two conditions: \\n(1) we are in a nested list\\n(2) we just move to the next element in top level\\nwhat hasNext() can bring us is that if it returns 'true', when calling 'next()', we can output an integer; \\notherwise the iterator already reaches the end of the list. Therefore we won't encounter (c) when calling next(). \\n\\nThus, the iterating solution is using a variable to hold current nestedInteger in top level, if it is an integer, we output the integer and move to the next nestedInteger; else we product a NestedIterator for the current nestedInteger (which is a list).\\n\\n    public class NestedIterator implements Iterator<Integer> {\\n        \\n        private List<NestedInteger> nestedIntegerList;\\n        private NestedIterator nextNestedIterator;\\n        private NestedInteger nextNestedInteger;\\n        private int currentPosition;\\n        \\n        public NestedIterator(List<NestedInteger> nestedList) {\\n            this.nestedIntegerList = nestedList;\\n            this.currentPosition = 0;\\n        }\\n    \\n        @Override\\n        public Integer next() {\\n            return nextNestedInteger.isInteger() ? nextNestedInteger.getInteger() : \\n                                                   nextNestedIterator.next();\\n        }\\n    \\n        @Override\\n        public boolean hasNext() {\\n    \\n            if (nextNestedIterator != null && nextNestedIterator.hasNext()) {\\n                return true;\\n            }\\n            if (currentPosition >= nestedIntegerList.size()) {\\n                return false;\\n            }\\n            \\n            nextNestedInteger = nestedIntegerList.get(currentPosition++);\\n            if ( nextNestedInteger.isInteger() || \\n                 (nextNestedIterator = \\n                    new NestedIterator(nextNestedInteger.getList())).hasNext()) {\\n                return true;\\n            } else {\\n                return hasNext();\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "Assuming the list to be iterated is [A, B], where A and B are in type NestedInteger.\\nWhenever we visit an element (current element), it has following three conditions: \\na) it is an integer; b) it is a non-empty list; c) it is an empty list.\\n\\nIf (a), we just output the integer and move to next element\\n\\nif (b), actually we are back to original problem (i.e. iterating a list of NestedInteger) before we move to next element\\n\\nif (c), we skip it and move to next element\\n\\nSimilarly, when we check hasNext() integer, we have two conditions: \\n(1) we are in a nested list\\n(2) we just move to the next element in top level\\nwhat hasNext() can bring us is that if it returns 'true', when calling 'next()', we can output an integer; \\notherwise the iterator already reaches the end of the list. Therefore we won't encounter (c) when calling next(). \\n\\nThus, the iterating solution is using a variable to hold current nestedInteger in top level, if it is an integer, we output the integer and move to the next nestedInteger; else we product a NestedIterator for the current nestedInteger (which is a list).\\n\\n    public class NestedIterator implements Iterator<Integer> {\\n        \\n        private List<NestedInteger> nestedIntegerList;\\n        private NestedIterator nextNestedIterator;\\n        private NestedInteger nextNestedInteger;\\n        private int currentPosition;\\n        \\n        public NestedIterator(List<NestedInteger> nestedList) {\\n            this.nestedIntegerList = nestedList;\\n            this.currentPosition = 0;\\n        }\\n    \\n        @Override\\n        public Integer next() {\\n            return nextNestedInteger.isInteger() ? nextNestedInteger.getInteger() : \\n                                                   nextNestedIterator.next();\\n        }\\n    \\n        @Override\\n        public boolean hasNext() {\\n    \\n            if (nextNestedIterator != null && nextNestedIterator.hasNext()) {\\n                return true;\\n            }\\n            if (currentPosition >= nestedIntegerList.size()) {\\n                return false;\\n            }\\n            \\n            nextNestedInteger = nestedIntegerList.get(currentPosition++);\\n            if ( nextNestedInteger.isInteger() || \\n                 (nextNestedIterator = \\n                    new NestedIterator(nextNestedInteger.getList())).hasNext()) {\\n                return true;\\n            } else {\\n                return hasNext();\\n            }\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 80143,
                "title": "7ms-java-solution",
                "content": "    private List<Integer> nestedList = new ArrayList<>();\\n    private int index;\\n    \\n    private static void buildList(List<Integer> list, List<NestedInteger> nestedList) {\\n        for (NestedInteger nestedInteger : nestedList) {\\n            if (nestedInteger.isInteger()) list.add(nestedInteger.getInteger());\\n            else buildList(list, nestedInteger.getList());\\n        }\\n    }\\n\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        buildList(this.nestedList, nestedList);\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return nestedList.get(index++);\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return nestedList.size() != index;\\n    }",
                "solutionTags": [],
                "code": "    private List<Integer> nestedList = new ArrayList<>();\\n    private int index;\\n    \\n    private static void buildList(List<Integer> list, List<NestedInteger> nestedList) {\\n        for (NestedInteger nestedInteger : nestedList) {\\n            if (nestedInteger.isInteger()) list.add(nestedInteger.getInteger());\\n            else buildList(list, nestedInteger.getList());\\n        }\\n    }\\n\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        buildList(this.nestedList, nestedList);\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return nestedList.get(index++);\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return nestedList.size() != index;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 80321,
                "title": "java-dfs-solution",
                "content": "    public class NestedIterator implements Iterator<Integer> {\\n    List<Integer> result;\\n    int index;\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        result = new ArrayList<Integer>();\\n        index = 0;\\n        dfs(nestedList, result);\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return result.get(index++);\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return index != result.size();\\n    }\\n    \\n    private void dfs(List<NestedInteger> list, List<Integer> result) {\\n        for(NestedInteger tmp : list) {\\n            if(tmp.isInteger()) result.add(tmp.getInteger());\\n            else dfs(tmp.getList(), result);\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search"
                ],
                "code": "    public class NestedIterator implements Iterator<Integer> {\\n    List<Integer> result;\\n    int index;\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        result = new ArrayList<Integer>();\\n        index = 0;\\n        dfs(nestedList, result);\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return result.get(index++);\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return index != result.size();\\n    }\\n    \\n    private void dfs(List<NestedInteger> list, List<Integer> result) {\\n        for(NestedInteger tmp : list) {\\n            if(tmp.isInteger()) result.add(tmp.getInteger());\\n            else dfs(tmp.getList(), result);\\n        }\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2642534,
                "title": "simple-queue-using-c-simple-easy-to-understand",
                "content": "class NestedIterator {\\npublic:\\n    \\n    queue<int>q;\\n    \\n    void findAllValue(NestedInteger x) {\\n        if (x.isInteger()) {\\n            q.push(x.getInteger());\\n        }\\n        else {\\n            for (auto y : x.getList())\\n                findAllValue(y);\\n        }\\n    }\\n    \\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        for(auto x:nestedList){\\n            findAllValue(x);\\n        }    \\n    }\\n    \\n    int next() {\\n        int x;\\n        if(hasNext()){\\n            x=q.front();\\n            q.pop();\\n        }\\n         return x;\\n    }\\n    \\n    bool hasNext() {\\n        if(!q.empty())return 1;\\n        return 0;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class NestedIterator {\\npublic:\\n    \\n    queue<int>q;\\n    \\n    void findAllValue(NestedInteger x) {\\n        if (x.isInteger()) {\\n            q.push(x.getInteger());\\n        }\\n        else {\\n            for (auto y : x.getList())\\n                findAllValue(y);\\n        }\\n    }\\n    \\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        for(auto x:nestedList){\\n            findAllValue(x);\\n        }    \\n    }\\n    \\n    int next() {\\n        int x;\\n        if(hasNext()){\\n            x=q.front();\\n            q.pop();\\n        }\\n         return x;\\n    }\\n    \\n    bool hasNext() {\\n        if(!q.empty())return 1;\\n        return 0;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 2367642,
                "title": "java",
                "content": "\\tpublic class NestedIterator implements Iterator<Integer> {\\n\\t\\tQueue<Integer> queue;\\n\\t\\tpublic NestedIterator(List<NestedInteger> nestedList) {\\n\\t\\t\\tqueue = new ArrayDeque<>();\\n\\t\\t\\tflatten(nestedList);\\n\\t\\t}\\n\\n    public void flatten(List<NestedInteger> nestedList){\\n        for(NestedInteger i:nestedList){\\n            if(i.isInteger()){\\n                queue.add(i.getInteger());\\n            }else{\\n                flatten(i.getList());\\n            }\\n        }\\n    }\\n    \\n    @Override\\n    public Integer next() {\\n        return queue.poll();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return queue.size()>0;\\n    }",
                "solutionTags": [],
                "code": "\\tpublic class NestedIterator implements Iterator<Integer> {\\n\\t\\tQueue<Integer> queue;\\n\\t\\tpublic NestedIterator(List<NestedInteger> nestedList) {\\n\\t\\t\\tqueue = new ArrayDeque<>();\\n\\t\\t\\tflatten(nestedList);\\n\\t\\t}\\n\\n    public void flatten(List<NestedInteger> nestedList){\\n        for(NestedInteger i:nestedList){\\n            if(i.isInteger()){\\n                queue.add(i.getInteger());\\n            }else{\\n                flatten(i.getList());\\n            }\\n        }\\n    }\\n    \\n    @Override\\n    public Integer next() {\\n        return queue.poll();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return queue.size()>0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2245912,
                "title": "java-intuitive-solution-recursion",
                "content": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n    private List<Integer> list;\\n    private int count = 0;\\n\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        list = new ArrayList<>();\\n        flatten(nestedList);\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return list.get(count++);\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return count < list.size();\\n    }\\n    \\n    private void flatten(List<NestedInteger> nestedList) {\\n        for(NestedInteger nestInt: nestedList) {\\n            if(nestInt.isInteger())\\n                list.add(nestInt.getInteger());\\n            else\\n               flatten(nestInt.getList());\\n        }\\n    }\\n}\\n```\\n\\nPlease upvote if you find it useful.",
                "solutionTags": [],
                "code": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n    private List<Integer> list;\\n    private int count = 0;\\n\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        list = new ArrayList<>();\\n        flatten(nestedList);\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return list.get(count++);\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return count < list.size();\\n    }\\n    \\n    private void flatten(List<NestedInteger> nestedList) {\\n        for(NestedInteger nestInt: nestedList) {\\n            if(nestInt.isInteger())\\n                list.add(nestInt.getInteger());\\n            else\\n               flatten(nestInt.getList());\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056678,
                "title": "java-o-h-space-using-stack-and-iterator",
                "content": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n    Stack<Iterator<NestedInteger>> s;\\n    int currentInt; // to keep track of last visited integer\\n\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        s = new Stack();\\n        s.add(nestedList.listIterator()); // add initial iterator to stack\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return currentInt;\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        while(!s.isEmpty() && !s.peek().hasNext()) // pop out iterators which have no next element\\n            s.pop();\\n        if(s.isEmpty())                            // if stack of iterators is empty that means there is no next element\\n            return false;  \\n        NestedInteger cur = s.peek().next();\\n        if(!cur.isInteger()){\\n            s.add(cur.getList().listIterator());   // if current element contains list add this list\\'s iterator to stack and return if there is integer inside it\\n            return this.hasNext();\\n        }\\n        currentInt = cur.getInteger();             // if current element is integer remember it to return as next element\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n    Stack<Iterator<NestedInteger>> s;\\n    int currentInt; // to keep track of last visited integer\\n\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        s = new Stack();\\n        s.add(nestedList.listIterator()); // add initial iterator to stack\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return currentInt;\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        while(!s.isEmpty() && !s.peek().hasNext()) // pop out iterators which have no next element\\n            s.pop();\\n        if(s.isEmpty())                            // if stack of iterators is empty that means there is no next element\\n            return false;  \\n        NestedInteger cur = s.peek().next();\\n        if(!cur.isInteger()){\\n            s.add(cur.getList().listIterator());   // if current element contains list add this list\\'s iterator to stack and return if there is integer inside it\\n            return this.hasNext();\\n        }\\n        currentInt = cur.getInteger();             // if current element is integer remember it to return as next element\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020087,
                "title": "c-easy-solution",
                "content": "Here\\'s what approach I have used - \\n* Take a new array sorted which will store the final flattened values.\\n* There are also 2 integer variable, i representing the current index and l represeting the length of flattened array.\\n* In the constructor function of the class, call the flaten function which is using recursion to flaten the array -\\n   1. Check if the NestedInteger is an integer, if it is, push it directly to the sorted array.\\n   2. Else call the function flaten again for the nested List.\\n* Now sorted array contains all the integer values, store the size of sorted array in the variable l.\\n\\n\\n```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\n\\nclass NestedIterator :public NestedInteger{\\npublic:\\n/* To store the flattened array */\\n    vector<int> sorted;\\n    int i=0,l;\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        flaten(nestedList);\\n\\t\\t/* Size of the flattened array */\\n        l = sorted.size();\\n    }\\n    void flaten(vector<NestedInteger> &nestedList){\\n       for(auto it:nestedList){\\n            if(it.isInteger()){\\n                sorted.push_back(it.getInteger());\\n            }\\n            else flaten(it.getList());\\n        } \\n    }\\n    int next() {\\n        return (i<l)? sorted[i++]: NULL;\\n    }\\n    \\n    bool hasNext() {\\n        return (i<l);\\n    }\\n};\\n\\n/**\\n * Your NestedIterator object will be instantiated and called as such:\\n * NestedIterator i(nestedList);\\n * while (i.hasNext()) cout << i.next();\\n */\\n```\\n\\nHope it\\'s helpful.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\n\\nclass NestedIterator :public NestedInteger{\\npublic:\\n/* To store the flattened array */\\n    vector<int> sorted;\\n    int i=0,l;\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        flaten(nestedList);\\n\\t\\t/* Size of the flattened array */\\n        l = sorted.size();\\n    }\\n    void flaten(vector<NestedInteger> &nestedList){\\n       for(auto it:nestedList){\\n            if(it.isInteger()){\\n                sorted.push_back(it.getInteger());\\n            }\\n            else flaten(it.getList());\\n        } \\n    }\\n    int next() {\\n        return (i<l)? sorted[i++]: NULL;\\n    }\\n    \\n    bool hasNext() {\\n        return (i<l);\\n    }\\n};\\n\\n/**\\n * Your NestedIterator object will be instantiated and called as such:\\n * NestedIterator i(nestedList);\\n * while (i.hasNext()) cout << i.next();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2020026,
                "title": "no-stack-used-recursion-used-3ms-java-solution",
                "content": "Our main motto here is how to differentiate wheather the current element of nestedList is an \"Integer\" or \"List\", if we can Identify the type of current element then, question will be just add that integer in the resulatnt list (\"res\") or if current element is list or list of list then iterate the list and again add integer of list in the resulatnt list \"res\".\\nFor identifying and differentiating between list and integer we have interface provided in question itself. \\nAs mentioned in interface of NestedInteger the isInteger() function return true if current element of nestedList is Integer or will return fasle otherwise (i.e in case current element is List).\\n\\n**Logic:** Traverse the given nestedList and perform operation accordingly if current element is List or Integer.\\n**Case 1: Current element is Integer** \\n**Operation:** Add in the \"res\" list\\n\\n**Case 2: Current elemet is List**\\n**Operation:** Again iterator over current List(i.e current element) and perform recurssion till Integer not found, Note it will cover List of List(nested list) case as well. When Integer found add in the \"res\".\\n\\nAppart from creating flatten list we have 2 more functions to implement. For them we are going to use Java in-built iterator class and its function. \\n**Approach:** After flattenting nestedList and creating \"res\" (i.e result after flattening of list), just convert the res to iterartor and functions of iterator i.e hasNext() and next() will take care of rest.\\n**Code of the discussed Approach:**\\n```\\npublic class NestedIterator implements Iterator<Integer> {\\n    List<Integer> res = new ArrayList<>();\\n    Iterator<Integer> it;\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        \\n        flatting(nestedList, res);\\n        it = res.iterator();\\n    }\\n    private List<Integer> flatting(List<NestedInteger> nestedList, List<Integer> res)\\n    {\\n        for(int i =0;i<nestedList.size();i++)\\n        {\\n            if(nestedList.get(i).isInteger())\\n            {\\n                res.add(nestedList.get(i).getInteger());\\n            }\\n            else\\n            {\\n                flatting(nestedList.get(i).getList() , res);\\n            }\\n        }\\n        return res;\\n    }\\n    @Override\\n    public Integer next() {\\n         return it.next();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n     return it.hasNext();   \\n    }\\n}\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "Our main motto here is how to differentiate wheather the current element of nestedList is an \"Integer\" or \"List\", if we can Identify the type of current element then, question will be just add that integer in the resulatnt list (\"res\") or if current element is list or list of list then iterate the list and again add integer of list in the resulatnt list \"res\".\\nFor identifying and differentiating between list and integer we have interface provided in question itself. \\nAs mentioned in interface of NestedInteger the isInteger() function return true if current element of nestedList is Integer or will return fasle otherwise (i.e in case current element is List).\\n\\n**Logic:** Traverse the given nestedList and perform operation accordingly if current element is List or Integer.\\n**Case 1: Current element is Integer** \\n**Operation:** Add in the \"res\" list\\n\\n**Case 2: Current elemet is List**\\n**Operation:** Again iterator over current List(i.e current element) and perform recurssion till Integer not found, Note it will cover List of List(nested list) case as well. When Integer found add in the \"res\".\\n\\nAppart from creating flatten list we have 2 more functions to implement. For them we are going to use Java in-built iterator class and its function. \\n**Approach:** After flattenting nestedList and creating \"res\" (i.e result after flattening of list), just convert the res to iterartor and functions of iterator i.e hasNext() and next() will take care of rest.\\n**Code of the discussed Approach:**\\n```\\npublic class NestedIterator implements Iterator<Integer> {\\n    List<Integer> res = new ArrayList<>();\\n    Iterator<Integer> it;\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        \\n        flatting(nestedList, res);\\n        it = res.iterator();\\n    }\\n    private List<Integer> flatting(List<NestedInteger> nestedList, List<Integer> res)\\n    {\\n        for(int i =0;i<nestedList.size();i++)\\n        {\\n            if(nestedList.get(i).isInteger())\\n            {\\n                res.add(nestedList.get(i).getInteger());\\n            }\\n            else\\n            {\\n                flatting(nestedList.get(i).getList() , res);\\n            }\\n        }\\n        return res;\\n    }\\n    @Override\\n    public Integer next() {\\n         return it.next();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n     return it.hasNext();   \\n    }\\n}\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2019498,
                "title": "js-easy-stack-explained-why-concat-flat-don-t-work",
                "content": "Check what nestedList object exactly looks like using JSON.strinigify(nestedList):\\nIt is nested object inside array with key \"_integer\" and \"_list\".\\ne.g: [[1,1],2,[1,1]] looks like -\\n```\\n[\\n  {\\n    \"_integer\": null,\\n    \"_list\": [\\n      {\\n        \"_integer\": 1,\\n        \"_list\": []\\n      },\\n      {\\n        \"_integer\": 1,\\n        \"_list\": []\\n      }\\n    ]\\n  },\\n  {\\n    \"_integer\": 2,\\n    \"_list\": []\\n  },\\n  {\\n    \"_integer\": null,\\n    \"_list\": [\\n      {\\n        \"_integer\": 1,\\n        \"_list\": []\\n      },\\n      {\\n        \"_integer\": 1,\\n        \"_list\": []\\n      }\\n    ]\\n  }\\n]\\n```\\nSolution using stack:\\n```\\n/**\\n * @constructor\\n * @param {NestedInteger[]} nestedList\\n */\\nvar NestedIterator = function(nestedList) {\\n   this.list = flatten(nestedList)\\n   this.top = 0\\n};\\n\\n\\n/**\\n * @this NestedIterator\\n * @returns {boolean}\\n */\\nNestedIterator.prototype.hasNext = function() {\\n    return this.top < this.list.length\\n};\\n\\n/**\\n * @this NestedIterator\\n * @returns {integer}\\n */\\nNestedIterator.prototype.next = function() {\\n    return this.list[this.top++]\\n};\\n\\n\\nfunction flatten(input) {\\n  const stack = [...input];\\n  const res = [];\\n  while (stack.length) {\\n    let next = stack.pop();\\n    if (next._list.length) {\\n      stack.push(...next._list);\\n    } else if(next._integer != null) {\\n      res.push(next._integer);\\n    }\\n  }\\n  return res.reverse()\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\n[\\n  {\\n    \"_integer\": null,\\n    \"_list\": [\\n      {\\n        \"_integer\": 1,\\n        \"_list\": []\\n      },\\n      {\\n        \"_integer\": 1,\\n        \"_list\": []\\n      }\\n    ]\\n  },\\n  {\\n    \"_integer\": 2,\\n    \"_list\": []\\n  },\\n  {\\n    \"_integer\": null,\\n    \"_list\": [\\n      {\\n        \"_integer\": 1,\\n        \"_list\": []\\n      },\\n      {\\n        \"_integer\": 1,\\n        \"_list\": []\\n      }\\n    ]\\n  }\\n]\\n```\n```\\n/**\\n * @constructor\\n * @param {NestedInteger[]} nestedList\\n */\\nvar NestedIterator = function(nestedList) {\\n   this.list = flatten(nestedList)\\n   this.top = 0\\n};\\n\\n\\n/**\\n * @this NestedIterator\\n * @returns {boolean}\\n */\\nNestedIterator.prototype.hasNext = function() {\\n    return this.top < this.list.length\\n};\\n\\n/**\\n * @this NestedIterator\\n * @returns {integer}\\n */\\nNestedIterator.prototype.next = function() {\\n    return this.list[this.top++]\\n};\\n\\n\\nfunction flatten(input) {\\n  const stack = [...input];\\n  const res = [];\\n  while (stack.length) {\\n    let next = stack.pop();\\n    if (next._list.length) {\\n      stack.push(...next._list);\\n    } else if(next._integer != null) {\\n      res.push(next._integer);\\n    }\\n  }\\n  return res.reverse()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2019362,
                "title": "easy-recursive-solution-using-c-intuitive-solution",
                "content": "CODE\\n\\n```\\nclass NestedIterator {\\npublic:\\n    vector<int> v;\\n    int i=0;\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        for(auto i:nestedList){\\n            \\n                    helper(i);\\n                \\n                    \\n            }\\n        \\n    }\\n    void helper(NestedInteger val){\\n              \\n            if(val.isInteger()){\\n                v.push_back(val.getInteger());\\n            }\\n                else{\\n                    for(auto it:val.getList()){\\n                        helper(it);\\n                    }\\n                }\\n                    \\n            \\n    }\\n    int next() {\\n        return v[i++];\\n    }\\n    \\n    bool hasNext() {\\n        return i<v.size();\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Array",
                    "Stack",
                    "Tree",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass NestedIterator {\\npublic:\\n    vector<int> v;\\n    int i=0;\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        for(auto i:nestedList){\\n            \\n                    helper(i);\\n                \\n                    \\n            }\\n        \\n    }\\n    void helper(NestedInteger val){\\n              \\n            if(val.isInteger()){\\n                v.push_back(val.getInteger());\\n            }\\n                else{\\n                    for(auto it:val.getList()){\\n                        helper(it);\\n                    }\\n                }\\n                    \\n            \\n    }\\n    int next() {\\n        return v[i++];\\n    }\\n    \\n    bool hasNext() {\\n        return i<v.size();\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019358,
                "title": "daily-leetcode-challenge-8-may-python3-solution-python",
                "content": "\\n\\tclass NestedIterator:\\n\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.list = []                               \\n        for i in nestedList:                   \\n            if i.isInteger():                         \\n                self.list.append(i)\\n            else:\\n                step = NestedIterator(i.getList())     \\n                while step.hasNext():                  \\n                    self.list.append(step.next())\\n\\t\\t\\t\\t\\t\\n    def next(self) -> int:\\n        if self.list:\\n            return self.list.pop(0)                      \\n    def hasNext(self) -> bool:\\n        return self.list",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\tclass NestedIterator:\\n\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.list = []                               \\n        for i in nestedList:                   \\n            if i.isInteger():                         \\n                self.list.append(i)\\n            else:\\n                step = NestedIterator(i.getList())     \\n                while step.hasNext():                  \\n                    self.list.append(step.next())\\n\\t\\t\\t\\t\\t\\n    def next(self) -> int:\\n        if self.list:\\n            return self.list.pop(0)                      \\n    def hasNext(self) -> bool:\\n        return self.list",
                "codeTag": "Java"
            },
            {
                "id": 2018779,
                "title": "simple-c-easy-explanation-stack",
                "content": "```\\nclass NestedIterator\\n{\\npublic:\\n    stack<int> st;\\n    NestedIterator(vector<NestedInteger> &nestedList)\\n    {\\n        ListToInteger(nestedList);\\n    //This method is used to check on every traversal of nestedList that \\n    //the element being traversed is a List or a single Element\\n    }\\n    //This ListToInteger function is implementing dfs(Depth First Search)\\n    //We are traversing all the list in the nested form till the last \\n    //single element\\n    void ListToInteger(vector<NestedInteger> &nestedList)\\n    {\\n        for (int i = nestedList.size() - 1; i >= 0; i--)\\n    //We are traversing nestedList from last so that in the last we\\n    //dont have to reverse the stack\\n        {\\n            if (nestedList[i].isInteger())\\n        //If single element\\n                st.push(nestedList[i].getInteger());\\n        //then storing this element in LIFO style.\\n            else\\n                ListToInteger(nestedList[i].getList());\\n            //Traversing the encountered list in the nestedList\\n        }\\n    }\\n\\n    int next()\\n    //Giving info of the next element\\n    {\\n        int temp = st.top();\\n        st.pop();\\n        return temp;\\n    }\\n\\n    bool hasNext()\\n    //If the stack is not empty\\n    {\\n        return !st.empty();\\n    }\\n};\\n```\\n**Note:-** \\n1) In place of using Stack above we could also use **Queue** . In that case we dont have to traverse the nestedList from last . \\n2) If you are doing this question in any Text-Editor then from **class NestedInteger** remove first const from ```const vector<NestedInteger> &getList() const``` or it will give error-squiggles.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\nclass NestedIterator\\n{\\npublic:\\n    stack<int> st;\\n    NestedIterator(vector<NestedInteger> &nestedList)\\n    {\\n        ListToInteger(nestedList);\\n    //This method is used to check on every traversal of nestedList that \\n    //the element being traversed is a List or a single Element\\n    }\\n    //This ListToInteger function is implementing dfs(Depth First Search)\\n    //We are traversing all the list in the nested form till the last \\n    //single element\\n    void ListToInteger(vector<NestedInteger> &nestedList)\\n    {\\n        for (int i = nestedList.size() - 1; i >= 0; i--)\\n    //We are traversing nestedList from last so that in the last we\\n    //dont have to reverse the stack\\n        {\\n            if (nestedList[i].isInteger())\\n        //If single element\\n                st.push(nestedList[i].getInteger());\\n        //then storing this element in LIFO style.\\n            else\\n                ListToInteger(nestedList[i].getList());\\n            //Traversing the encountered list in the nestedList\\n        }\\n    }\\n\\n    int next()\\n    //Giving info of the next element\\n    {\\n        int temp = st.top();\\n        st.pop();\\n        return temp;\\n    }\\n\\n    bool hasNext()\\n    //If the stack is not empty\\n    {\\n        return !st.empty();\\n    }\\n};\\n```\n```const vector<NestedInteger> &getList() const```",
                "codeTag": "Java"
            },
            {
                "id": 2018717,
                "title": "c-dfs-clean-code-detailed-explanation-with-tree-visualization",
                "content": "# Approach\\n* Consider a Nested List as an n-ary tree where for a node there can be two types of children.\\n\\t* Having only one integer element **i.e Leaf Node**\\n\\t* A Nested List itself **i.e Internal Node**\\n\\n* We can traverse through this tree structure using Depth First Search and store the nodes in an integer vector.\\n* For all children of a node, if child is an integer then push it. Use given methods on the class.\\n* Else call DFS for this child nested list. \\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/26c1e56e-a792-41bd-be1d-20350884bded_1651994608.5956874.png)\\n\\n\\n\\n* If Current element is less than size of created integer vector then we have a next element else not.\\n* Return vector[curr] for next element.\\n\\n```\\nclass NestedIterator {\\npublic:\\n    \\n    vector<int> data;\\n    int curr = 0, size;\\n\\t \\n    void DFS(vector<NestedInteger> &nestedList, vector<int> &data)\\n    {   \\n        int i, n = nestedList.size();\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(nestedList[i].isInteger())\\n                this->data.push_back(nestedList[i].getInteger());\\n            else\\n                DFS(nestedList[i].getList(), this->data);        \\n        }\\n    }\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        \\n        DFS(nestedList, this->data);\\n        this->size = this->data.size();            \\n    }\\n    \\n    int next() {\\n        int ans = this->data[curr];\\n        curr += 1;\\n        return ans;\\n    }\\n    \\n    bool hasNext() {\\n        if(this->curr == this->size)\\n            return false;\\n        return true;\\n    }\\n};\\n\\n```\\n\\n**Please upvote if you liked the explanation.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass NestedIterator {\\npublic:\\n    \\n    vector<int> data;\\n    int curr = 0, size;\\n\\t \\n    void DFS(vector<NestedInteger> &nestedList, vector<int> &data)\\n    {   \\n        int i, n = nestedList.size();\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(nestedList[i].isInteger())\\n                this->data.push_back(nestedList[i].getInteger());\\n            else\\n                DFS(nestedList[i].getList(), this->data);        \\n        }\\n    }\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        \\n        DFS(nestedList, this->data);\\n        this->size = this->data.size();            \\n    }\\n    \\n    int next() {\\n        int ans = this->data[curr];\\n        curr += 1;\\n        return ans;\\n    }\\n    \\n    bool hasNext() {\\n        if(this->curr == this->size)\\n            return false;\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018372,
                "title": "c-easy-recursive-solution-daily-leetcoding-challenge-may-day-8",
                "content": "**Explaination of Functions :**\\n\\n* **Flatten** : There are 2 possibilities at every level. One is diretly integer insert it directly to the vector. Otherwise call the same fuction to separate the integer ans list.\\n\\n* **NestedIterator** : Iterate for every element and nested list through our flatten function and also keep on incresing the counter value for the size of flatten vector.\\n\\n* **Next** : Next function will return the next value \\n\\n* **HasNext** : HasNext will return false if our next function reached the vector size otherwise true.\\n\\n```\\nclass NestedIterator {\\npublic:\\n    \\n    int m=0,n=0;\\n    vector<int> flatten;\\n    \\n    void flatten(NestedInteger x){\\n        \\n        if(x.isInteger())\\n            flatten.push_back(x.getInteger());\\n        else {\\n            for(auto i:x.getList())\\n                flatten(i);\\n        }\\n    }\\n    \\n    NestedIterator(vector<NestedInteger> &a) {\\n        for(auto i:a)\\n            flatten(i);\\n        n = flatten.size();\\n    }\\n    \\n    int next() {\\n        m++;\\n        return flatten[m-1];\\n    }\\n    \\n    bool hasNext() {\\n        if(m==n)\\n            return false;//reached capacity!\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass NestedIterator {\\npublic:\\n    \\n    int m=0,n=0;\\n    vector<int> flatten;\\n    \\n    void flatten(NestedInteger x){\\n        \\n        if(x.isInteger())\\n            flatten.push_back(x.getInteger());\\n        else {\\n            for(auto i:x.getList())\\n                flatten(i);\\n        }\\n    }\\n    \\n    NestedIterator(vector<NestedInteger> &a) {\\n        for(auto i:a)\\n            flatten(i);\\n        n = flatten.size();\\n    }\\n    \\n    int next() {\\n        m++;\\n        return flatten[m-1];\\n    }\\n    \\n    bool hasNext() {\\n        if(m==n)\\n            return false;//reached capacity!\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018353,
                "title": "c-easy-recursion-clean-explained-commented-fast",
                "content": "**Runtime: 14 ms, faster than 80.11% of C++ online submissions for Flatten Nested List Iterator.\\nMemory Usage: 13.3 MB, less than 60.67% of C++ online submissions for Flatten Nested List Iterator.**\\n\\n--> First we will store all elements into an array then for function next and hasnext we will return the value accordingly.\\n\\n--> We are traversing through the given vector and checking it\\'s value if it is a integer we will store the value otherwise we will call the recursion with that list itself.\\n```\\nclass NestedIterator {\\npublic:\\n    vector<int>nums; //store values in this vector\\n    int pos = -1; //for the current position of vector\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        convert(nestedList);\\n        pos = 0;\\n    }\\n    void convert(vector<NestedInteger>&lis){\\n        for(auto i:lis){\\n            if(i.isInteger()) nums.push_back(i.getInteger()); // these function already defined in the NestedInteger class\\n            else{\\n                convert(i.getList()); // calling recursion\\n            }\\n        }\\n    }\\n    \\n    int next() {\\n        return nums[pos++]; //return the current pointing value\\n    }\\n    \\n    bool hasNext() {\\n        return pos < nums.size(); //return whether next value is there or not.\\n    }\\n};\\n```\\nIf you find it useful hit like.\\nThanks....",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass NestedIterator {\\npublic:\\n    vector<int>nums; //store values in this vector\\n    int pos = -1; //for the current position of vector\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        convert(nestedList);\\n        pos = 0;\\n    }\\n    void convert(vector<NestedInteger>&lis){\\n        for(auto i:lis){\\n            if(i.isInteger()) nums.push_back(i.getInteger()); // these function already defined in the NestedInteger class\\n            else{\\n                convert(i.getList()); // calling recursion\\n            }\\n        }\\n    }\\n    \\n    int next() {\\n        return nums[pos++]; //return the current pointing value\\n    }\\n    \\n    bool hasNext() {\\n        return pos < nums.size(); //return whether next value is there or not.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018284,
                "title": "cpp-java-python-intuition-explained-simple-code",
                "content": "```\\n# In my opinion an iterator shouldn\\'t copy the entire data (which some solutions have done) but just iterate over the original data structure.***\\n# \\n# I keep the current progress in a stack. My hasNext tries to find an integer. My next returns it and moves on.\\n# I call hasNext in next because hasNext is optional. Some user of the iterator might call only next and never hasNext, \\n# e.g., if they know how many integers are in the structure or if they want to handle the ending with exception handling.***\\n\\nPython\\n\\nUsing a stack of [list, index] pairs.\\n\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        self.stack = [[nestedList, 0]]\\n\\n    def next(self):\\n        self.hasNext()\\n        nestedList, i = self.stack[-1]\\n        self.stack[-1][1] += 1\\n        return nestedList[i].getInteger()\\n            \\n    def hasNext(self):\\n        s = self.stack\\n        while s:\\n            nestedList, i = s[-1]\\n            if i == len(nestedList):\\n                s.pop()\\n            else:\\n                x = nestedList[i]\\n                if x.isInteger():\\n                    return True\\n                s[-1][1] += 1\\n                s.append([x.getList(), 0])\\n        return False\\nJava\\n\\nUsing a stack of ListIterators.\\n\\npublic class NestedIterator implements Iterator<Integer> {\\n\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        lists = new Stack<>();\\n        lists.push(nestedList.listIterator());\\n    }\\n\\n    public Integer next() {\\n        hasNext();\\n        return lists.peek().next().getInteger();\\n    }\\n\\n    public boolean hasNext() {\\n        while (!lists.empty()) {\\n            if (!lists.peek().hasNext()) {\\n                lists.pop();\\n            } else {\\n                NestedInteger x = lists.peek().next();\\n                if (x.isInteger())\\n                    return lists.peek().previous() == x;\\n                lists.push(x.getList().listIterator());\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private Stack<ListIterator<NestedInteger>> lists;\\n}\\nC++\\n\\nUsing stacks of begin and end iterators.\\n\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        begins.push(nestedList.begin());\\n        ends.push(nestedList.end());\\n    }\\n\\n    int next() {\\n        hasNext();\\n        return (begins.top()++)->getInteger();\\n    }\\n\\n    bool hasNext() {\\n        while (begins.size()) {\\n            if (begins.top() == ends.top()) {\\n                begins.pop();\\n                ends.pop();\\n            } else {\\n                auto x = begins.top();\\n                if (x->isInteger())\\n                    return true;\\n                begins.top()++;\\n                begins.push(x->getList().begin());\\n                ends.push(x->getList().end());\\n            }\\n        }\\n        return false;\\n    }\\n\\nprivate:\\n    stack<vector<NestedInteger>::iterator> begins, ends;\\n};\\n\\n**PLEASE VOTE IF YOU FOUND IT USEFUL**\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\n# In my opinion an iterator shouldn\\'t copy the entire data (which some solutions have done) but just iterate over the original data structure.***\\n# \\n# I keep the current progress in a stack. My hasNext tries to find an integer. My next returns it and moves on.\\n# I call hasNext in next because hasNext is optional. Some user of the iterator might call only next and never hasNext, \\n# e.g., if they know how many integers are in the structure or if they want to handle the ending with exception handling.***\\n\\nPython\\n\\nUsing a stack of [list, index] pairs.\\n\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        self.stack = [[nestedList, 0]]\\n\\n    def next(self):\\n        self.hasNext()\\n        nestedList, i = self.stack[-1]\\n        self.stack[-1][1] += 1\\n        return nestedList[i].getInteger()\\n            \\n    def hasNext(self):\\n        s = self.stack\\n        while s:\\n            nestedList, i = s[-1]\\n            if i == len(nestedList):\\n                s.pop()\\n            else:\\n                x = nestedList[i]\\n                if x.isInteger():\\n                    return True\\n                s[-1][1] += 1\\n                s.append([x.getList(), 0])\\n        return False\\nJava\\n\\nUsing a stack of ListIterators.\\n\\npublic class NestedIterator implements Iterator<Integer> {\\n\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        lists = new Stack<>();\\n        lists.push(nestedList.listIterator());\\n    }\\n\\n    public Integer next() {\\n        hasNext();\\n        return lists.peek().next().getInteger();\\n    }\\n\\n    public boolean hasNext() {\\n        while (!lists.empty()) {\\n            if (!lists.peek().hasNext()) {\\n                lists.pop();\\n            } else {\\n                NestedInteger x = lists.peek().next();\\n                if (x.isInteger())\\n                    return lists.peek().previous() == x;\\n                lists.push(x.getList().listIterator());\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private Stack<ListIterator<NestedInteger>> lists;\\n}\\nC++\\n\\nUsing stacks of begin and end iterators.\\n\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        begins.push(nestedList.begin());\\n        ends.push(nestedList.end());\\n    }\\n\\n    int next() {\\n        hasNext();\\n        return (begins.top()++)->getInteger();\\n    }\\n\\n    bool hasNext() {\\n        while (begins.size()) {\\n            if (begins.top() == ends.top()) {\\n                begins.pop();\\n                ends.pop();\\n            } else {\\n                auto x = begins.top();\\n                if (x->isInteger())\\n                    return true;\\n                begins.top()++;\\n                begins.push(x->getList().begin());\\n                ends.push(x->getList().end());\\n            }\\n        }\\n        return false;\\n    }\\n\\nprivate:\\n    stack<vector<NestedInteger>::iterator> begins, ends;\\n};\\n\\n**PLEASE VOTE IF YOU FOUND IT USEFUL**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018079,
                "title": "golang-generators-using-channels-and-go-routines",
                "content": "```\\ntype NestedIterator struct {\\n    ch chan int\\n    ans int\\n}\\n\\nfunc Constructor(nestedList []*NestedInteger) *NestedIterator {\\n    ch := make(chan int)\\n    go Helper(nestedList,ch) // invoking the goroutine so that it can keep values in our channel, it will yield once val is kept in channel\\n    return &NestedIterator{ch,0}\\n}\\n\\nfunc (this *NestedIterator) Next() int {\\n    return this.ans\\n}\\n\\nfunc (this *NestedIterator) HasNext() bool {\\n    v,ok:=<-this.ch // ok will be true for non closed channels, reading from channel\\n    this.ans = v\\n    return ok \\n}\\nfunc Helper(nestedList []*NestedInteger, ch chan int){\\n    var recurse func([]*NestedInteger)\\n    recurse = func(nestedList []*NestedInteger){\\n        for _,val := range nestedList{\\n            if val.IsInteger(){\\n                ch <- val.GetInteger() // writing to channel\\n            }else{\\n                recurse(val.GetList())\\n            }\\n        }\\n    }\\n    recurse(nestedList)\\n    defer close(ch) //closing the channels once all the values in nestedList are iterated\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ntype NestedIterator struct {\\n    ch chan int\\n    ans int\\n}\\n\\nfunc Constructor(nestedList []*NestedInteger) *NestedIterator {\\n    ch := make(chan int)\\n    go Helper(nestedList,ch) // invoking the goroutine so that it can keep values in our channel, it will yield once val is kept in channel\\n    return &NestedIterator{ch,0}\\n}\\n\\nfunc (this *NestedIterator) Next() int {\\n    return this.ans\\n}\\n\\nfunc (this *NestedIterator) HasNext() bool {\\n    v,ok:=<-this.ch // ok will be true for non closed channels, reading from channel\\n    this.ans = v\\n    return ok \\n}\\nfunc Helper(nestedList []*NestedInteger, ch chan int){\\n    var recurse func([]*NestedInteger)\\n    recurse = func(nestedList []*NestedInteger){\\n        for _,val := range nestedList{\\n            if val.IsInteger(){\\n                ch <- val.GetInteger() // writing to channel\\n            }else{\\n                recurse(val.GetList())\\n            }\\n        }\\n    }\\n    recurse(nestedList)\\n    defer close(ch) //closing the channels once all the values in nestedList are iterated\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2017974,
                "title": "100-oms-c-java-python-easy-simple-fast-concise-code",
                "content": "```\\n\\nIn my opinion an iterator shouldn\\'t copy the entire data (which some solutions have done) but just iterate over the original data structure.\\n\\nI keep the current progress in a stack. My hasNext tries to find an integer. My next returns it and moves on. I call hasNext in next because hasNext is optional. Some user of the iterator might call only next and never hasNext, e.g., if they know how many integers are in the structure or if they want to handle the ending with exception handling.\\n\\nPython\\n\\nUsing a stack of [list, index] pairs.\\n\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        self.stack = [[nestedList, 0]]\\n\\n    def next(self):\\n        self.hasNext()\\n        nestedList, i = self.stack[-1]\\n        self.stack[-1][1] += 1\\n        return nestedList[i].getInteger()\\n            \\n    def hasNext(self):\\n        s = self.stack\\n        while s:\\n            nestedList, i = s[-1]\\n            if i == len(nestedList):\\n                s.pop()\\n            else:\\n                x = nestedList[i]\\n                if x.isInteger():\\n                    return True\\n                s[-1][1] += 1\\n                s.append([x.getList(), 0])\\n        return False\\nJava\\n\\nUsing a stack of ListIterators.\\n\\npublic class NestedIterator implements Iterator<Integer> {\\n\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        lists = new Stack<>();\\n        lists.push(nestedList.listIterator());\\n    }\\n\\n    public Integer next() {\\n        hasNext();\\n        return lists.peek().next().getInteger();\\n    }\\n\\n    public boolean hasNext() {\\n        while (!lists.empty()) {\\n            if (!lists.peek().hasNext()) {\\n                lists.pop();\\n            } else {\\n                NestedInteger x = lists.peek().next();\\n                if (x.isInteger())\\n                    return lists.peek().previous() == x;\\n                lists.push(x.getList().listIterator());\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private Stack<ListIterator<NestedInteger>> lists;\\n}\\nC++\\n\\nUsing stacks of begin and end iterators.\\n\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        begins.push(nestedList.begin());\\n        ends.push(nestedList.end());\\n    }\\n\\n    int next() {\\n        hasNext();\\n        return (begins.top()++)->getInteger();\\n    }\\n\\n    bool hasNext() {\\n        while (begins.size()) {\\n            if (begins.top() == ends.top()) {\\n                begins.pop();\\n                ends.pop();\\n            } else {\\n                auto x = begins.top();\\n                if (x->isInteger())\\n                    return true;\\n                begins.top()++;\\n                begins.push(x->getList().begin());\\n                ends.push(x->getList().end());\\n            }\\n        }\\n        return false;\\n    }\\n\\nprivate:\\n    stack<vector<NestedInteger>::iterator> begins, ends;\\n};\\n\\n\\n\\nConcise code \\n\\nprivate Stack<NestedInteger> stack;\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        stack = new Stack<>();\\n        flattenList(nestedList);\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return hasNext() ? stack.pop().getInteger() : null;\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        while (!stack.isEmpty()) {\\n            if (stack.peek().isInteger()) return true;\\n            flattenList(stack.pop().getList());\\n        } return false;\\n    }\\n\\n    private void flattenList(List<NestedInteger> list) {\\n        for (int i = list.size() - 1; i >= 0; i--) {\\n            stack.push(list.get(i));\\n        }\\n    }\\n\\nUPVOTE \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\n\\nIn my opinion an iterator shouldn\\'t copy the entire data (which some solutions have done) but just iterate over the original data structure.\\n\\nI keep the current progress in a stack. My hasNext tries to find an integer. My next returns it and moves on. I call hasNext in next because hasNext is optional. Some user of the iterator might call only next and never hasNext, e.g., if they know how many integers are in the structure or if they want to handle the ending with exception handling.\\n\\nPython\\n\\nUsing a stack of [list, index] pairs.\\n\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        self.stack = [[nestedList, 0]]\\n\\n    def next(self):\\n        self.hasNext()\\n        nestedList, i = self.stack[-1]\\n        self.stack[-1][1] += 1\\n        return nestedList[i].getInteger()\\n            \\n    def hasNext(self):\\n        s = self.stack\\n        while s:\\n            nestedList, i = s[-1]\\n            if i == len(nestedList):\\n                s.pop()\\n            else:\\n                x = nestedList[i]\\n                if x.isInteger():\\n                    return True\\n                s[-1][1] += 1\\n                s.append([x.getList(), 0])\\n        return False\\nJava\\n\\nUsing a stack of ListIterators.\\n\\npublic class NestedIterator implements Iterator<Integer> {\\n\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        lists = new Stack<>();\\n        lists.push(nestedList.listIterator());\\n    }\\n\\n    public Integer next() {\\n        hasNext();\\n        return lists.peek().next().getInteger();\\n    }\\n\\n    public boolean hasNext() {\\n        while (!lists.empty()) {\\n            if (!lists.peek().hasNext()) {\\n                lists.pop();\\n            } else {\\n                NestedInteger x = lists.peek().next();\\n                if (x.isInteger())\\n                    return lists.peek().previous() == x;\\n                lists.push(x.getList().listIterator());\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private Stack<ListIterator<NestedInteger>> lists;\\n}\\nC++\\n\\nUsing stacks of begin and end iterators.\\n\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        begins.push(nestedList.begin());\\n        ends.push(nestedList.end());\\n    }\\n\\n    int next() {\\n        hasNext();\\n        return (begins.top()++)->getInteger();\\n    }\\n\\n    bool hasNext() {\\n        while (begins.size()) {\\n            if (begins.top() == ends.top()) {\\n                begins.pop();\\n                ends.pop();\\n            } else {\\n                auto x = begins.top();\\n                if (x->isInteger())\\n                    return true;\\n                begins.top()++;\\n                begins.push(x->getList().begin());\\n                ends.push(x->getList().end());\\n            }\\n        }\\n        return false;\\n    }\\n\\nprivate:\\n    stack<vector<NestedInteger>::iterator> begins, ends;\\n};\\n\\n\\n\\nConcise code \\n\\nprivate Stack<NestedInteger> stack;\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        stack = new Stack<>();\\n        flattenList(nestedList);\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return hasNext() ? stack.pop().getInteger() : null;\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        while (!stack.isEmpty()) {\\n            if (stack.peek().isInteger()) return true;\\n            flattenList(stack.pop().getList());\\n        } return false;\\n    }\\n\\n    private void flattenList(List<NestedInteger> list) {\\n        for (int i = list.size() - 1; i >= 0; i--) {\\n            stack.push(list.get(i));\\n        }\\n    }\\n\\nUPVOTE \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017637,
                "title": "c-o-n-solution",
                "content": "```\\nclass NestedIterator {\\npublic:\\n    vector<int> elements;\\n    int index;\\n\\t//build tree from given Data structure.\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        buildList(nestedList,elements);\\n        index=0;\\n    }\\n\\t//if integer add to vector or else call reccursively.\\n    void buildList(vector<NestedInteger> &nestedList,vector<int> &elements){\\n        for(auto i:nestedList){\\n            if(i.isInteger()){\\n                elements.push_back(i.getInteger());\\n            }else{\\n                buildList(i.getList(),elements);\\n            }\\n        }\\n    }\\n    int next() {\\n        return elements[index++];\\n    }\\n    \\n    bool hasNext() {\\n        return index!=elements.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass NestedIterator {\\npublic:\\n    vector<int> elements;\\n    int index;\\n\\t//build tree from given Data structure.\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        buildList(nestedList,elements);\\n        index=0;\\n    }\\n\\t//if integer add to vector or else call reccursively.\\n    void buildList(vector<NestedInteger> &nestedList,vector<int> &elements){\\n        for(auto i:nestedList){\\n            if(i.isInteger()){\\n                elements.push_back(i.getInteger());\\n            }else{\\n                buildList(i.getList(),elements);\\n            }\\n        }\\n    }\\n    int next() {\\n        return elements[index++];\\n    }\\n    \\n    bool hasNext() {\\n        return index!=elements.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968925,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tpublic class NestedIterator implements Iterator<Integer> {\\n\\n    List<Integer> list;//in which we ll store all integers while initialization.\\n    int pointer;\\n    int size;\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        list=new ArrayList<Integer>();\\n        //check if all elements of nestedList following \\n        for(NestedInteger ni:nestedList){\\n            //yes:  just add it to the list\\n            if(ni.isInteger()){\\n                list.add(ni.getInteger());\\n            }else{\\n                //no : then its NestedInteger hence we create an intence of NestedIterator and get all Integers of ni obj.\\n                NestedIterator itr=new NestedIterator(ni.getList());\\n                list.addAll(itr.list);\\n            }\\n        }\\n        pointer=0;\\n        size=list.size();\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return list.get(pointer++);\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        if(pointer<size){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n\\tpublic class NestedIterator implements Iterator<Integer> {\\n\\n    List<Integer> list;//in which we ll store all integers while initialization.\\n    int pointer;\\n    int size;\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        list=new ArrayList<Integer>();\\n        //check if all elements of nestedList following \\n        for(NestedInteger ni:nestedList){\\n            //yes:  just add it to the list\\n            if(ni.isInteger()){\\n                list.add(ni.getInteger());\\n            }else{\\n                //no : then its NestedInteger hence we create an intence of NestedIterator and get all Integers of ni obj.\\n                NestedIterator itr=new NestedIterator(ni.getList());\\n                list.addAll(itr.list);\\n            }\\n        }\\n        pointer=0;\\n        size=list.size();\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return list.get(pointer++);\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        if(pointer<size){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1960222,
                "title": "c-using-dfs",
                "content": "```\\nclass NestedIterator {\\npublic:\\n    vector<int> ans;\\n    int index = 0;\\n    \\n    void dfs(vector<NestedInteger> nestedList) {\\n        \\n         for(int i = 0; i < nestedList.size(); i++) {\\n                \\n            if(nestedList[i].isInteger())\\n                ans.push_back(nestedList[i].getInteger());\\n            else\\n                dfs(nestedList[i].getList());    \\n                \\n        }   \\n    }\\n    \\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n       dfs(nestedList);             \\n    }\\n    \\n    int next() {\\n           index++;\\n         return ans[index-1]; \\n    }\\n    \\n    bool hasNext() {\\n      return index < ans.size();         \\n    }\\n};\\nIf Helpful Please Like And Upvoke\\n```",
                "solutionTags": [],
                "code": "```\\nclass NestedIterator {\\npublic:\\n    vector<int> ans;\\n    int index = 0;\\n    \\n    void dfs(vector<NestedInteger> nestedList) {\\n        \\n         for(int i = 0; i < nestedList.size(); i++) {\\n                \\n            if(nestedList[i].isInteger())\\n                ans.push_back(nestedList[i].getInteger());\\n            else\\n                dfs(nestedList[i].getList());    \\n                \\n        }   \\n    }\\n    \\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n       dfs(nestedList);             \\n    }\\n    \\n    int next() {\\n           index++;\\n         return ans[index-1]; \\n    }\\n    \\n    bool hasNext() {\\n      return index < ans.size();         \\n    }\\n};\\nIf Helpful Please Like And Upvoke\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869877,
                "title": "flatten-nested-list-iterator-solution-java",
                "content": "public class NestedIterator implements Iterator<Integer> {\\n  public NestedIterator(List<NestedInteger> nestedList) {\\n    addInteger(nestedList);\\n  }\\n\\n  @Override\\n  public Integer next() {\\n    return q.poll();\\n  }\\n\\n  @Override\\n  public boolean hasNext() {\\n    return !q.isEmpty();\\n  }\\n\\n  private Queue<Integer> q = new ArrayDeque<>();\\n\\n  private void addInteger(final List<NestedInteger> nestedList) {\\n    for (final NestedInteger ni : nestedList)\\n      if (ni.isInteger())\\n        q.offer(ni.getInteger());\\n      else\\n        addInteger(ni.getList());\\n  }\\n}",
                "solutionTags": [
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Design",
                    "Queue"
                ],
                "code": "public class NestedIterator implements Iterator<Integer> {\\n  public NestedIterator(List<NestedInteger> nestedList) {\\n    addInteger(nestedList);\\n  }\\n\\n  @Override\\n  public Integer next() {\\n    return q.poll();\\n  }\\n\\n  @Override\\n  public boolean hasNext() {\\n    return !q.isEmpty();\\n  }\\n\\n  private Queue<Integer> q = new ArrayDeque<>();\\n\\n  private void addInteger(final List<NestedInteger> nestedList) {\\n    for (final NestedInteger ni : nestedList)\\n      if (ni.isInteger())\\n        q.offer(ni.getInteger());\\n      else\\n        addInteger(ni.getList());\\n  }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1686634,
                "title": "python-solution-using-yield",
                "content": "Making a new list is an easy solution to implement with recursion.\\n\\n```\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.res = []\\n        self._flattener(nestedList)\\n        self.ptr = 0\\n            \\n    def _flattener(self, nestedList):\\n        for nl in nestedList:\\n            if nl.isInteger():\\n                self.res.append(nl.getInteger())\\n            else:\\n                self._flattener(nl.getList())\\n    \\n    def next(self) -> int:\\n        ret = self.res[self.ptr]\\n        self.ptr += 1\\n        return ret\\n    \\n    def hasNext(self) -> bool:\\n        return self.ptr < len(self.res)\\n```\\n\\nHowever, above does not seem to act like an real iterator, as it is not lazy.\\n\\nWe can use \\'yield\\' to make something really works like an iterator as below.\\n\\n```\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        def _generator(nestedList):\\n            for nl in nestedList:\\n                if nl.isInteger():\\n                    yield nl.getInteger()\\n                else:\\n                    yield from _generator(nl.getList())\\n        self.gen = _generator(nestedList)\\n        self.nextelem = next(self.gen, None)\\n    \\n    def next(self) -> int:\\n        ret = self.nextelem\\n        self.nextelem = next(self.gen, None)\\n        return ret\\n    \\n    def hasNext(self) -> bool:\\n        return self.nextelem != None\\n\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.res = []\\n        self._flattener(nestedList)\\n        self.ptr = 0\\n            \\n    def _flattener(self, nestedList):\\n        for nl in nestedList:\\n            if nl.isInteger():\\n                self.res.append(nl.getInteger())\\n            else:\\n                self._flattener(nl.getList())\\n    \\n    def next(self) -> int:\\n        ret = self.res[self.ptr]\\n        self.ptr += 1\\n        return ret\\n    \\n    def hasNext(self) -> bool:\\n        return self.ptr < len(self.res)\\n```\n```\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        def _generator(nestedList):\\n            for nl in nestedList:\\n                if nl.isInteger():\\n                    yield nl.getInteger()\\n                else:\\n                    yield from _generator(nl.getList())\\n        self.gen = _generator(nestedList)\\n        self.nextelem = next(self.gen, None)\\n    \\n    def next(self) -> int:\\n        ret = self.nextelem\\n        self.nextelem = next(self.gen, None)\\n        return ret\\n    \\n    def hasNext(self) -> bool:\\n        return self.nextelem != None\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640443,
                "title": "c-solution-faster-than-100-00-doesn-t-use-stack-or-queue",
                "content": "\\n```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * interface NestedInteger {\\n *\\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool IsInteger();\\n *\\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // Return null if this NestedInteger holds a nested list\\n *     int GetInteger();\\n *\\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // Return null if this NestedInteger holds a single integer\\n *     IList<NestedInteger> GetList();\\n * }\\n */\\npublic class NestedIterator {\\n\\n    IList<NestedInteger> nestedList;\\n    NestedIterator iterator;\\n    int curIndex = 0;\\n    \\n    public NestedIterator(IList<NestedInteger> nestedList) {\\n        this.nestedList = nestedList;\\n    }\\n\\n    public bool HasNext() {\\n        // check if the nested list is empty\\n        if(nestedList.Count == 0) {\\n            return false;\\n        }\\n        \\n        if(iterator != null) {\\n            if(iterator.HasNext()) {\\n                return true;\\n            }\\n            iterator = null;\\n        }\\n        \\n        if(HasReachedEnd()) {\\n            return false;\\n        }\\n        \\n        // searching if there is any integer integer\\n        while(!nestedList[curIndex].IsInteger()) {\\n            // recursively checking any list\\n            iterator = new NestedIterator(nestedList[curIndex].GetList());\\n            curIndex++;\\n            if(iterator.HasNext()) {\\n                return true;\\n            }\\n            iterator = null;\\n            if(HasReachedEnd()) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private bool HasReachedEnd() {\\n        return curIndex >= nestedList.Count;\\n    }\\n\\n    public int Next() {\\n        if(iterator != null) {\\n            return iterator.Next();\\n        }\\n        var value = nestedList[curIndex].GetInteger();\\n        curIndex++;\\n        return value; \\n    }\\n}\\n\\n/**\\n * Your NestedIterator will be called like this:\\n * NestedIterator i = new NestedIterator(nestedList);\\n * while (i.HasNext()) v[f()] = i.Next();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * interface NestedInteger {\\n *\\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool IsInteger();\\n *\\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // Return null if this NestedInteger holds a nested list\\n *     int GetInteger();\\n *\\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // Return null if this NestedInteger holds a single integer\\n *     IList<NestedInteger> GetList();\\n * }\\n */\\npublic class NestedIterator {\\n\\n    IList<NestedInteger> nestedList;\\n    NestedIterator iterator;\\n    int curIndex = 0;\\n    \\n    public NestedIterator(IList<NestedInteger> nestedList) {\\n        this.nestedList = nestedList;\\n    }\\n\\n    public bool HasNext() {\\n        // check if the nested list is empty\\n        if(nestedList.Count == 0) {\\n            return false;\\n        }\\n        \\n        if(iterator != null) {\\n            if(iterator.HasNext()) {\\n                return true;\\n            }\\n            iterator = null;\\n        }\\n        \\n        if(HasReachedEnd()) {\\n            return false;\\n        }\\n        \\n        // searching if there is any integer integer\\n        while(!nestedList[curIndex].IsInteger()) {\\n            // recursively checking any list\\n            iterator = new NestedIterator(nestedList[curIndex].GetList());\\n            curIndex++;\\n            if(iterator.HasNext()) {\\n                return true;\\n            }\\n            iterator = null;\\n            if(HasReachedEnd()) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private bool HasReachedEnd() {\\n        return curIndex >= nestedList.Count;\\n    }\\n\\n    public int Next() {\\n        if(iterator != null) {\\n            return iterator.Next();\\n        }\\n        var value = nestedList[curIndex].GetInteger();\\n        curIndex++;\\n        return value; \\n    }\\n}\\n\\n/**\\n * Your NestedIterator will be called like this:\\n * NestedIterator i = new NestedIterator(nestedList);\\n * while (i.HasNext()) v[f()] = i.Next();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593112,
                "title": "simple-recursive-solution-using-c",
                "content": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\n\\nclass NestedIterator {\\npublic:\\n    deque<int> dq;\\n    void process(vector<NestedInteger> &nestedList) {\\n        int n = nestedList.size();\\n        for(int i = 0; i < n; i++) {\\n            if(!nestedList[i].isInteger()) {\\n                vector<NestedInteger> lst = nestedList[i].getList();\\n                process(lst);\\n            }\\n            else {\\n                dq.push_back(nestedList[i].getInteger());\\n            }\\n        }\\n    }\\n    void printDq(deque<int> dq) {\\n        while(!dq.empty()) {\\n            int f = dq.front();\\n            dq.pop_front();\\n            cout<<f<<\" \";\\n        }\\n        cout<<endl;\\n    }\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        process(nestedList);  \\n        // printDq(dq);\\n    }\\n    \\n    int next() {\\n        if(!dq.empty()) {\\n            int f = dq.front();\\n            dq.pop_front();\\n            return f;\\n        }\\n        return -1;\\n    }\\n    \\n    bool hasNext() {\\n        if(!dq.empty()) {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your NestedIterator object will be instantiated and called as such:\\n * NestedIterator i(nestedList);\\n * while (i.hasNext()) cout << i.next();\\n */\\n ```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\n\\nclass NestedIterator {\\npublic:\\n    deque<int> dq;\\n    void process(vector<NestedInteger> &nestedList) {\\n        int n = nestedList.size();\\n        for(int i = 0; i < n; i++) {\\n            if(!nestedList[i].isInteger()) {\\n                vector<NestedInteger> lst = nestedList[i].getList();\\n                process(lst);\\n            }\\n            else {\\n                dq.push_back(nestedList[i].getInteger());\\n            }\\n        }\\n    }\\n    void printDq(deque<int> dq) {\\n        while(!dq.empty()) {\\n            int f = dq.front();\\n            dq.pop_front();\\n            cout<<f<<\" \";\\n        }\\n        cout<<endl;\\n    }\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        process(nestedList);  \\n        // printDq(dq);\\n    }\\n    \\n    int next() {\\n        if(!dq.empty()) {\\n            int f = dq.front();\\n            dq.pop_front();\\n            return f;\\n        }\\n        return -1;\\n    }\\n    \\n    bool hasNext() {\\n        if(!dq.empty()) {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your NestedIterator object will be instantiated and called as such:\\n * NestedIterator i(nestedList);\\n * while (i.hasNext()) cout << i.next();\\n */\\n ```",
                "codeTag": "C++"
            },
            {
                "id": 1527755,
                "title": "java-recursion-with-comments",
                "content": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n    List<Integer> list;//in which we ll store all integers while initialization.\\n    int pointer;\\n    int size;\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        list=new ArrayList<Integer>();\\n        //check if all elements of nestedList following \\n        for(NestedInteger ni:nestedList){\\n            //yes:  just add it to the list\\n            if(ni.isInteger()){\\n                list.add(ni.getInteger());\\n            }else{\\n                //no : then its NestedInteger hence we create an intence of NestedIterator and get all Integers of ni obj.\\n                NestedIterator itr=new NestedIterator(ni.getList());\\n                list.addAll(itr.list);\\n            }\\n        }\\n        pointer=0;\\n        size=list.size();\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return list.get(pointer++);\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        if(pointer<size){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your NestedIterator object will be instantiated and called as such:\\n * NestedIterator i = new NestedIterator(nestedList);\\n * while (i.hasNext()) v[f()] = i.next();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n    List<Integer> list;//in which we ll store all integers while initialization.\\n    int pointer;\\n    int size;\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        list=new ArrayList<Integer>();\\n        //check if all elements of nestedList following \\n        for(NestedInteger ni:nestedList){\\n            //yes:  just add it to the list\\n            if(ni.isInteger()){\\n                list.add(ni.getInteger());\\n            }else{\\n                //no : then its NestedInteger hence we create an intence of NestedIterator and get all Integers of ni obj.\\n                NestedIterator itr=new NestedIterator(ni.getList());\\n                list.addAll(itr.list);\\n            }\\n        }\\n        pointer=0;\\n        size=list.size();\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return list.get(pointer++);\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        if(pointer<size){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your NestedIterator object will be instantiated and called as such:\\n * NestedIterator i = new NestedIterator(nestedList);\\n * while (i.hasNext()) v[f()] = i.next();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392015,
                "title": "c-dfs",
                "content": "```csharp\\npublic class NestedIterator {\\n    \\n    Queue<int> queue = new Queue<int>();\\n\\n    public NestedIterator(IList<NestedInteger> nestedList) {\\n        Helper(nestedList, this.queue);\\n    }\\n\\n    public bool HasNext() {\\n        return this.queue.Any();\\n    }\\n\\n    public int Next() {\\n        return this.queue.Dequeue();\\n    }\\n    \\n    void Helper(IList<NestedInteger> list, Queue<int> queue) {\\n        foreach (var e in list) {\\n            if (e.IsInteger()) {\\n                queue.Enqueue(e.GetInteger());\\n            } else {\\n                Helper(e.GetList(), queue);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class NestedIterator {\\n    \\n    Queue<int> queue = new Queue<int>();\\n\\n    public NestedIterator(IList<NestedInteger> nestedList) {\\n        Helper(nestedList, this.queue);\\n    }\\n\\n    public bool HasNext() {\\n        return this.queue.Any();\\n    }\\n\\n    public int Next() {\\n        return this.queue.Dequeue();\\n    }\\n    \\n    void Helper(IList<NestedInteger> list, Queue<int> queue) {\\n        foreach (var e in list) {\\n            if (e.IsInteger()) {\\n                queue.Enqueue(e.GetInteger());\\n            } else {\\n                Helper(e.GetList(), queue);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1311685,
                "title": "my-very-simple-solution-in-python",
                "content": "```# \"\"\"\\n# This is the interface that allows for creating nested lists.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n#class NestedInteger(object):\\n#    def isInteger(self):\\n#        \"\"\"\\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\\n#        :rtype bool\\n#        \"\"\"\\n#\\n#    def getInteger(self):\\n#        \"\"\"\\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\\n#        Return None if this NestedInteger holds a nested list\\n#        :rtype int\\n#        \"\"\"\\n#\\n#    def getList(self):\\n#        \"\"\"\\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\\n#        Return None if this NestedInteger holds a single integer\\n#        :rtype List[NestedInteger]\\n#        \"\"\"\\n\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type nestedList: List[NestedInteger]\\n        \"\"\"\\n        self.l = []\\n        self.flattenList(nestedList)\\n        \\n    def flattenList(self,nestedList):\\n        for x in nestedList:\\n            if x.isInteger():\\n                self.l.append(x.getInteger())\\n            else:\\n                self.flattenList(x.getList())\\n        \\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.l.pop(0)\\n        \\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return 0 < len(self.l)\\n        \\n\\n# Your NestedIterator object will be instantiated and called as such:\\n# i, v = NestedIterator(nestedList), []\\n# while i.hasNext(): v.append(i.next())",
                "solutionTags": [],
                "code": "```# \"\"\"\\n# This is the interface that allows for creating nested lists.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n#class NestedInteger(object):\\n#    def isInteger(self):\\n#        \"\"\"\\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\\n#        :rtype bool\\n#        \"\"\"\\n#\\n#    def getInteger(self):\\n#        \"\"\"\\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\\n#        Return None if this NestedInteger holds a nested list\\n#        :rtype int\\n#        \"\"\"\\n#\\n#    def getList(self):\\n#        \"\"\"\\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\\n#        Return None if this NestedInteger holds a single integer\\n#        :rtype List[NestedInteger]\\n#        \"\"\"\\n\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type nestedList: List[NestedInteger]\\n        \"\"\"\\n        self.l = []\\n        self.flattenList(nestedList)\\n        \\n    def flattenList(self,nestedList):\\n        for x in nestedList:\\n            if x.isInteger():\\n                self.l.append(x.getInteger())\\n            else:\\n                self.flattenList(x.getList())\\n        \\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.l.pop(0)\\n        \\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return 0 < len(self.l)\\n        \\n\\n# Your NestedIterator object will be instantiated and called as such:\\n# i, v = NestedIterator(nestedList), []\\n# while i.hasNext(): v.append(i.next())",
                "codeTag": "Java"
            },
            {
                "id": 1296785,
                "title": "easy-recursive-solution-in-c",
                "content": "```\\nclass NestedIterator \\n{\\npublic:\\n    // vector to store the flattened form\\n    vector<int>v;\\n    \\n    // pointer to point the current element\\n    int i=0;\\n    void helper(vector<NestedInteger>nestedList)\\n    {\\n        for(int i=0;i<nestedList.size();i++)\\n        {\\n            if(nestedList[i].isInteger())\\n            {\\n                v.push_back(nestedList[i].getInteger());\\n            }\\n            else\\n            {\\n                helper(nestedList[i].getList());\\n            }\\n        }\\n    }\\n    NestedIterator(vector<NestedInteger> &nestedList) \\n    {\\n        v.clear();\\n        helper(nestedList);\\n    }\\n    \\n    int next() \\n    {\\n        return i<v.size()?v[i++]:-1;\\n    }\\n    \\n    bool hasNext() \\n    {\\n        return i<v.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass NestedIterator \\n{\\npublic:\\n    // vector to store the flattened form\\n    vector<int>v;\\n    \\n    // pointer to point the current element\\n    int i=0;\\n    void helper(vector<NestedInteger>nestedList)\\n    {\\n        for(int i=0;i<nestedList.size();i++)\\n        {\\n            if(nestedList[i].isInteger())\\n            {\\n                v.push_back(nestedList[i].getInteger());\\n            }\\n            else\\n            {\\n                helper(nestedList[i].getList());\\n            }\\n        }\\n    }\\n    NestedIterator(vector<NestedInteger> &nestedList) \\n    {\\n        v.clear();\\n        helper(nestedList);\\n    }\\n    \\n    int next() \\n    {\\n        return i<v.size()?v[i++]:-1;\\n    }\\n    \\n    bool hasNext() \\n    {\\n        return i<v.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203846,
                "title": "simplest-explanation-queue-recursive-w-commentary-js-es6",
                "content": "`Commentary:` \\n>- Although it is clear that a queue DS implementation should work easily, it\\'s the interface two built-in functions that can seem pretty dense initially.\\n> - Save your time by not writing a function that simply flattens a nested array.This question demands use of given api: getInteger() and getList()\\n```\\nconst NestedIterator = function(nestedList) {\\n    this.queue = flatten(nestedList);\\n};\\nNestedIterator.prototype.hasNext = function() {\\n    return this.queue.length !== 0\\n};\\nNestedIterator.prototype.next = function() {\\n    return this.queue.shift();\\n};\\n\\n//Helper function\\nfunction flatten(list, que = []){\\n    while(list.length) {\\n        let item = list.shift();\\n        if (item.isInteger()) que.push(item.getInteger());\\n        else flatten(item.getList(), que);\\n    }\\n    return que;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\nconst NestedIterator = function(nestedList) {\\n    this.queue = flatten(nestedList);\\n};\\nNestedIterator.prototype.hasNext = function() {\\n    return this.queue.length !== 0\\n};\\nNestedIterator.prototype.next = function() {\\n    return this.queue.shift();\\n};\\n\\n//Helper function\\nfunction flatten(list, que = []){\\n    while(list.length) {\\n        let item = list.shift();\\n        if (item.isInteger()) que.push(item.getInteger());\\n        else flatten(item.getList(), que);\\n    }\\n    return que;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1199553,
                "title": "c-efficient-with-yield-return-enumerator-and-ienumerable-int",
                "content": "```\\npublic class NestedIterator {\\n    private IEnumerator<int> iterator;\\n    \\n    /// O(D) - D is # of nesting for given list\\n    public NestedIterator(IList<NestedInteger> nestedList) {\\n        this.iterator = FlattenNestedList(nestedList).GetEnumerator();\\n    }\\n\\n    // O(1)\\n    public bool HasNext() {\\n        return this.iterator.MoveNext();\\n    }\\n\\n    // O(1)\\n    public int Next() {\\n        return this.iterator.Current;\\n    }\\n    \\n    // O(D)\\n    private IEnumerable<int> FlattenNestedList(IList<NestedInteger> nestedList) {\\n     //   if (nestedList is null || nestedList.Count < 1) yield return int.MinValue;\\n        \\n        foreach (var n in nestedList) {\\n            if (n.IsInteger())\\n                yield return n.GetInteger();\\n            else\\n                foreach (var e in FlattenNestedList(n.GetList()))\\n                    yield return e;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class NestedIterator {\\n    private IEnumerator<int> iterator;\\n    \\n    /// O(D) - D is # of nesting for given list\\n    public NestedIterator(IList<NestedInteger> nestedList) {\\n        this.iterator = FlattenNestedList(nestedList).GetEnumerator();\\n    }\\n\\n    // O(1)\\n    public bool HasNext() {\\n        return this.iterator.MoveNext();\\n    }\\n\\n    // O(1)\\n    public int Next() {\\n        return this.iterator.Current;\\n    }\\n    \\n    // O(D)\\n    private IEnumerable<int> FlattenNestedList(IList<NestedInteger> nestedList) {\\n     //   if (nestedList is null || nestedList.Count < 1) yield return int.MinValue;\\n        \\n        foreach (var n in nestedList) {\\n            if (n.IsInteger())\\n                yield return n.GetInteger();\\n            else\\n                foreach (var e in FlattenNestedList(n.GetList()))\\n                    yield return e;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158079,
                "title": "python-solution-with-explanation",
                "content": "In python we can either use deque or stack for this approach. \\nIn the first place it is difficult to get idea about why to use stack or queue kind of data structure. \\n\\nThe reason we need data structure is because at every step it can be either integer or list and to save list we definetely need some data structure to work efficiently.\\n\\nIn Problem statement it is mentioned that there will be call on hasNext() first and if that returns true then next() is called. \\nThere are two ways to think: \\n\\n1) Every time on hasNext check if the object at index is integer or list and based on that flatten it in some temp list/stack/deque kind of data structure.  (lazy loading of inner lists)\\n2) Initially at beginning traverse the whole list and by recursive call convert nested list into flat list. (eager loading of inner lists)\\n\\nThere are total 3 methods:\\n1) next() which returns element on top of data structure it should always be integer. \\n2) hasNext() which will check is there any element exist which is pending to traverse, there is possibility that list is empty or list can have inner list inside that like [[], [3]] , [[[[5]]]]. Hence to overcome such scenarios we need while loop there which will check and retrieve the element for the nested lists. \\n3) initStack(): which is helper method, which helps in retriving values from nested list all at once if we follow recursive (eager) method, or current/next element of the list if we follow lazy loading.\\n\\nNote: Methods isInteger(), getInteger() and getList() implementation already exist in custom class provided in method definition NestedInteger.\\n\\n```\\n    class NestedIterator:\\n\\n        def initStack(self,nestedList):\\n\\n            for ele in (nestedList):\\n                if ele.isInteger():\\n                    #print(nestedList[i].getInteger())\\n                    self.stack.append(ele)\\n                else:\\n                    #print(nestedList[i].getList())\\n                    self.stack.extend(ele.getList()[::-1])\\n\\n        def __init__(self, nestedList: [NestedInteger]):\\n            self.currentList = nestedList\\n            self.stack = []\\n            self.initStack(self.currentList[::-1])\\n\\n\\n        def next(self) -> int:\\n            return self.stack.pop()\\n\\n        def hasNext(self) -> bool:\\n            while self.stack:\\n                if self.stack[-1].isInteger():\\n                    return True\\n\\n                self.initStack(self.stack.pop().getList()[::-1])\\n\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\n    class NestedIterator:\\n\\n        def initStack(self,nestedList):\\n\\n            for ele in (nestedList):\\n                if ele.isInteger():\\n                    #print(nestedList[i].getInteger())\\n                    self.stack.append(ele)\\n                else:\\n                    #print(nestedList[i].getList())\\n                    self.stack.extend(ele.getList()[::-1])\\n\\n        def __init__(self, nestedList: [NestedInteger]):\\n            self.currentList = nestedList\\n            self.stack = []\\n            self.initStack(self.currentList[::-1])\\n\\n\\n        def next(self) -> int:\\n            return self.stack.pop()\\n\\n        def hasNext(self) -> bool:\\n            while self.stack:\\n                if self.stack[-1].isInteger():\\n                    return True\\n\\n                self.initStack(self.stack.pop().getList()[::-1])\\n\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157698,
                "title": "python3",
                "content": "```\\nfrom collections import deque \\n# \"\"\"\\n# This is the interface that allows for creating nested lists.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n#class NestedInteger:\\n#    def isInteger(self) -> bool:\\n#        \"\"\"\\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\\n#        \"\"\"\\n#\\n#    def getInteger(self) -> int:\\n#        \"\"\"\\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\\n#        Return None if this NestedInteger holds a nested list\\n#        \"\"\"\\n#\\n#    def getList(self) -> [NestedInteger]:\\n#        \"\"\"\\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\\n#        Return None if this NestedInteger holds a single integer\\n#        \"\"\"\\n\\n\\ndef get(list,arr):\\n    for i in list:\\n        if i.isInteger():\\n            arr.append(i.getInteger())\\n        else:\\n            get(i.getList(),arr)\\n    return arr\\n\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.arr=deque(get(nestedList,[]))\\n        \\n    def next(self) -> int:\\n        return self.arr.popleft()\\n    \\n    def hasNext(self) -> bool:\\n        return len(self.arr)>0\\n\\n# Your NestedIterator object will be instantiated and called as such:\\n# i, v = NestedIterator(nestedList), []\\n# while i.hasNext(): v.append(i.next())",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque \\n# \"\"\"\\n# This is the interface that allows for creating nested lists.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n#class NestedInteger:\\n#    def isInteger(self) -> bool:\\n#        \"\"\"\\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\\n#        \"\"\"\\n#\\n#    def getInteger(self) -> int:\\n#        \"\"\"\\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\\n#        Return None if this NestedInteger holds a nested list\\n#        \"\"\"\\n#\\n#    def getList(self) -> [NestedInteger]:\\n#        \"\"\"\\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\\n#        Return None if this NestedInteger holds a single integer\\n#        \"\"\"\\n\\n\\ndef get(list,arr):\\n    for i in list:\\n        if i.isInteger():\\n            arr.append(i.getInteger())\\n        else:\\n            get(i.getList(),arr)\\n    return arr\\n\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.arr=deque(get(nestedList,[]))\\n        \\n    def next(self) -> int:\\n        return self.arr.popleft()\\n    \\n    def hasNext(self) -> bool:\\n        return len(self.arr)>0\\n\\n# Your NestedIterator object will be instantiated and called as such:\\n# i, v = NestedIterator(nestedList), []\\n# while i.hasNext(): v.append(i.next())",
                "codeTag": "Java"
            },
            {
                "id": 1156908,
                "title": "java-clean-easy-and-fast-solution-using-recursion",
                "content": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n\\n    private List<Integer> flatList = new ArrayList<>();\\n    private int cursor = 0;\\n    \\n    public NestedIterator(List<NestedInteger> nestedList) {\\n         //copy data\\n        nestedList.forEach(this::flat);\\n\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        cursor++;\\n        return flatList.get(cursor - 1);\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return cursor <= flatList.size() - 1;\\n    }\\n    \\n    \\n    private void flat(NestedInteger nestedInteger) {\\n\\n        if (nestedInteger.isInteger()) {\\n            flatList.add(nestedInteger.getInteger());\\n        } else {\\n            nestedInteger.getList().forEach(this::flat);\\n        }\\n    }\\n    \\n  \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n\\n    private List<Integer> flatList = new ArrayList<>();\\n    private int cursor = 0;\\n    \\n    public NestedIterator(List<NestedInteger> nestedList) {\\n         //copy data\\n        nestedList.forEach(this::flat);\\n\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        cursor++;\\n        return flatList.get(cursor - 1);\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return cursor <= flatList.size() - 1;\\n    }\\n    \\n    \\n    private void flat(NestedInteger nestedInteger) {\\n\\n        if (nestedInteger.isInteger()) {\\n            flatList.add(nestedInteger.getInteger());\\n        } else {\\n            nestedInteger.getList().forEach(this::flat);\\n        }\\n    }\\n    \\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156642,
                "title": "cpp-easy-solution-fast",
                "content": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\n\\nclass NestedIterator {\\npublic:\\n    queue<int>q;\\n    void insert(vector<NestedInteger> nestedList)\\n    {\\n        int n=nestedList.size();\\n        //cout<<n<<endl;\\n        for(int i=0;i<n;i++)\\n        {\\n            NestedInteger ns=nestedList[i];\\n            if(ns.isInteger())\\n                q.push(ns.getInteger());\\n            else\\n            {\\n                insert(ns.getList());\\n            }\\n        }\\n    }\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        insert(nestedList);\\n        \\n    }\\n    \\n    int next() {\\n        int a=q.front();\\n        q.pop();\\n       return a; \\n    }\\n    \\n    bool hasNext() {\\n       return !q.empty(); \\n    }\\n};\\n\\n/**\\n * Your NestedIterator object will be instantiated and called as such:\\n * NestedIterator i(nestedList);\\n * while (i.hasNext()) cout << i.next();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\n\\nclass NestedIterator {\\npublic:\\n    queue<int>q;\\n    void insert(vector<NestedInteger> nestedList)\\n    {\\n        int n=nestedList.size();\\n        //cout<<n<<endl;\\n        for(int i=0;i<n;i++)\\n        {\\n            NestedInteger ns=nestedList[i];\\n            if(ns.isInteger())\\n                q.push(ns.getInteger());\\n            else\\n            {\\n                insert(ns.getList());\\n            }\\n        }\\n    }\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        insert(nestedList);\\n        \\n    }\\n    \\n    int next() {\\n        int a=q.front();\\n        q.pop();\\n       return a; \\n    }\\n    \\n    bool hasNext() {\\n       return !q.empty(); \\n    }\\n};\\n\\n/**\\n * Your NestedIterator object will be instantiated and called as such:\\n * NestedIterator i(nestedList);\\n * while (i.hasNext()) cout << i.next();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1156544,
                "title": "rust-stack-solution",
                "content": "```rust\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub enum NestedInteger {\\n//   Int(i32),\\n//   List(Vec<NestedInteger>)\\n// }\\nstruct NestedIterator {\\n    stack: Vec<NestedInteger>,\\n    next: Option<i32>,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl NestedIterator {\\n\\n    fn new(nested_list: Vec<NestedInteger>) -> Self {\\n        let mut s = Self {\\n            stack: nested_list.into_iter().rev().collect::<Vec<_>>(),\\n            next: None,\\n        };\\n        s.advance_next();\\n        s\\n    }\\n    \\n    fn next(&mut self) -> i32 {\\n        let ret = self.next.unwrap();\\n        self.advance_next();\\n        ret\\n    }\\n    \\n    fn has_next(&self) -> bool {\\n        self.next.is_some()\\n    }\\n\\n    fn advance_next(&mut self) {\\n        while let Some(last) = self.stack.pop() {\\n            match last {\\n                NestedInteger::Int(n) => {\\n                    self.next = Some(n);\\n                    return;\\n                }\\n                NestedInteger::List(list) => {\\n                    self.stack.extend(list.into_iter().rev());\\n                }\\n            }\\n        }\\n        self.next = None;\\n    }\\n}\\n ```",
                "solutionTags": [
                    "Rust",
                    "Stack"
                ],
                "code": "```rust\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub enum NestedInteger {\\n//   Int(i32),\\n//   List(Vec<NestedInteger>)\\n// }\\nstruct NestedIterator {\\n    stack: Vec<NestedInteger>,\\n    next: Option<i32>,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl NestedIterator {\\n\\n    fn new(nested_list: Vec<NestedInteger>) -> Self {\\n        let mut s = Self {\\n            stack: nested_list.into_iter().rev().collect::<Vec<_>>(),\\n            next: None,\\n        };\\n        s.advance_next();\\n        s\\n    }\\n    \\n    fn next(&mut self) -> i32 {\\n        let ret = self.next.unwrap();\\n        self.advance_next();\\n        ret\\n    }\\n    \\n    fn has_next(&self) -> bool {\\n        self.next.is_some()\\n    }\\n\\n    fn advance_next(&mut self) {\\n        while let Some(last) = self.stack.pop() {\\n            match last {\\n                NestedInteger::Int(n) => {\\n                    self.next = Some(n);\\n                    return;\\n                }\\n                NestedInteger::List(list) => {\\n                    self.stack.extend(list.into_iter().rev());\\n                }\\n            }\\n        }\\n        self.next = None;\\n    }\\n}\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1156251,
                "title": "python-simple-o-n-time-and-o-n-auxillary-space",
                "content": "My answer for this question. (Ran all tests)\\n```\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        def flatten(a):\\n            req = []\\n            for ele in a:\\n                if ele.isInteger():\\n                    req.append(ele.getInteger())\\n                else:\\n                    req.extend(flatten(ele.getList()))\\n            return req\\n        \\n        self.flatten = flatten(nestedList)\\n        self.curr = 0\\n          \\n    def next(self) -> int:\\n        t = self.flatten[self.curr]\\n        self.curr+=1\\n        return t\\n        \\n    def hasNext(self) -> bool:\\n        return self.curr<len(self.flatten)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "My answer for this question. (Ran all tests)\\n```\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        def flatten(a):\\n            req = []\\n            for ele in a:\\n                if ele.isInteger():\\n                    req.append(ele.getInteger())\\n                else:\\n                    req.extend(flatten(ele.getList()))\\n            return req\\n        \\n        self.flatten = flatten(nestedList)\\n        self.curr = 0\\n          \\n    def next(self) -> int:\\n        t = self.flatten[self.curr]\\n        self.curr+=1\\n        return t\\n        \\n    def hasNext(self) -> bool:\\n        return self.curr<len(self.flatten)",
                "codeTag": "Java"
            },
            {
                "id": 1144761,
                "title": "succinct-python-recursive-generator-approach-o-n-time-o-1-space",
                "content": "Note the use of yield from expression. I also appended a sentinel \"END\" to the original list so that I do not have to deal with try/except construct:\\n```\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        def _iter(lst) -> int:\\n           for i in lst:\\n                if i==\"END\":\\n                    yield i\\n                elif i.isInteger():\\n                    yield i.getInteger()\\n                else:\\n                    yield from _iter(i.getList())  #equivalent to for s in iter(i.getList()): yield s\\n        self.gen=_iter(nestedList+[\"END\"])\\n        self.nowserving=next(self.gen)\\n            \\n    def next(self) -> int:\\n        t,self.nowserving=self.nowserving,next(self.gen)\\n        return t\\n    \\n    def hasNext(self) -> bool:\\n        return  self.nowserving!=\"END\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        def _iter(lst) -> int:\\n           for i in lst:\\n                if i==\"END\":\\n                    yield i\\n                elif i.isInteger():\\n                    yield i.getInteger()\\n                else:\\n                    yield from _iter(i.getList())  #equivalent to for s in iter(i.getList()): yield s\\n        self.gen=_iter(nestedList+[\"END\"])\\n        self.nowserving=next(self.gen)\\n            \\n    def next(self) -> int:\\n        t,self.nowserving=self.nowserving,next(self.gen)\\n        return t\\n    \\n    def hasNext(self) -> bool:\\n        return  self.nowserving!=\"END\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047334,
                "title": "c-using-stack",
                "content": "\\n\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        for(int i = nestedList.size() - 1; i >= 0; --i) {\\n            stk.push(nestedList[i]);\\n        }\\n    }\\n    \\n    int next() {\\n        NestedInteger cur = stk.top();  // if hasNext is true, we are sure \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// the top of stack item is an integer, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// we can directly reture. Here we\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// have an assumption here, the caller\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// always call hasNext first, before call next().\\n        stk.pop();\\n        return cur.getInteger();\\n    }\\n    \\n    bool hasNext() {\\n        while(!stk.empty()) {\\n            NestedInteger cur = stk.top();            \\n\\n            if (cur.isInteger()) {\\n                return true;\\n            } else {\\n                auto cc = cur.getList();\\n                stk.pop();\\n                \\n                for(int i = cc.size() - 1; i >= 0; --i) {\\n                    stk.push(cc[i]);\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    private:\\n        std::stack<NestedInteger> stk;",
                "solutionTags": [],
                "code": "\\n\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        for(int i = nestedList.size() - 1; i >= 0; --i) {\\n            stk.push(nestedList[i]);\\n        }\\n    }\\n    \\n    int next() {\\n        NestedInteger cur = stk.top();  // if hasNext is true, we are sure \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// the top of stack item is an integer, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// we can directly reture. Here we\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// have an assumption here, the caller\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// always call hasNext first, before call next().\\n        stk.pop();\\n        return cur.getInteger();\\n    }\\n    \\n    bool hasNext() {\\n        while(!stk.empty()) {\\n            NestedInteger cur = stk.top();            \\n\\n            if (cur.isInteger()) {\\n                return true;\\n            } else {\\n                auto cc = cur.getList();\\n                stk.pop();\\n                \\n                for(int i = cc.size() - 1; i >= 0; --i) {\\n                    stk.push(cc[i]);\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    private:\\n        std::stack<NestedInteger> stk;",
                "codeTag": "Unknown"
            },
            {
                "id": 1001520,
                "title": "comment-is-not-accurate-in-java-return-empty-list-if-nestedinteger-holds-a-single-integer",
                "content": "In  public interface NestedInteger, comments:\\n```\\n // @return the nested list that this NestedInteger holds, if it holds a nested list\\n // Return null if this NestedInteger holds a single integer\\n public List<NestedInteger> getList();\\n```\\nIt actually returns an empty list if this NestedInteger holds a single integer",
                "solutionTags": [],
                "code": "```\\n // @return the nested list that this NestedInteger holds, if it holds a nested list\\n // Return null if this NestedInteger holds a single integer\\n public List<NestedInteger> getList();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 997939,
                "title": "c-no-preprocessing-stack-to-track-recursion",
                "content": "```\\n#define stV (*(st.top().first))\\n#define stI (st.top().second)\\n\\nclass NestedIterator {\\nprivate:\\n\\t// Each entry in stack keeps a pointer to vector and the current index it is at in the corresponding vector\\n    stack <pair<vector<NestedInteger>*, int>> st;\\n    void getNextAtTop() {\\n        while(!st.empty()){\\n            if (stI<stV.size() && stV[stI].isInteger())\\n                break;\\n            if (stI<stV.size() && !stV[stI].getList().empty())\\n                st.push({&(stV[stI].getList()), 0});\\n            else if(stI < (int)stV.size()-1)\\n                stI++;\\n            else{\\n                st.pop();\\n                if(!st.empty()) stI++;\\n            }\\n        }\\n    }\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        if (nestedList.empty()) return;\\n        st.push({&nestedList, 0});\\n        getNextAtTop();\\n    }\\n    \\n    int next() {\\n        if (st.empty()) return -1;\\n        int ans = stV[stI].getInteger();\\n        while(!st.empty() && stI>=stV.size()-1){\\n            st.pop();\\n        }\\n        if (st.empty()) return ans;\\n        stI++;\\n        getNextAtTop();\\n        return ans;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define stV (*(st.top().first))\\n#define stI (st.top().second)\\n\\nclass NestedIterator {\\nprivate:\\n\\t// Each entry in stack keeps a pointer to vector and the current index it is at in the corresponding vector\\n    stack <pair<vector<NestedInteger>*, int>> st;\\n    void getNextAtTop() {\\n        while(!st.empty()){\\n            if (stI<stV.size() && stV[stI].isInteger())\\n                break;\\n            if (stI<stV.size() && !stV[stI].getList().empty())\\n                st.push({&(stV[stI].getList()), 0});\\n            else if(stI < (int)stV.size()-1)\\n                stI++;\\n            else{\\n                st.pop();\\n                if(!st.empty()) stI++;\\n            }\\n        }\\n    }\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        if (nestedList.empty()) return;\\n        st.push({&nestedList, 0});\\n        getNextAtTop();\\n    }\\n    \\n    int next() {\\n        if (st.empty()) return -1;\\n        int ans = stV[stI].getInteger();\\n        while(!st.empty() && stI>=stV.size()-1){\\n            st.pop();\\n        }\\n        if (st.empty()) return ans;\\n        stI++;\\n        getNextAtTop();\\n        return ans;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981556,
                "title": "simple-c-without-using-stack-and-queue",
                "content": "```\\nclass NestedIterator {\\n    vector<int> v;\\n    int i=0;\\npublic:\\n    void helper(vector<NestedInteger> &nestedList)\\n    {\\n        for(int i=0;i<nestedList.size();i++)\\n        {\\n            if(nestedList[i].isInteger())\\n                v.push_back(nestedList[i].getInteger());\\n            else\\n                helper(nestedList[i].getList());\\n        }\\n    }\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        helper(nestedList);\\n    }\\n    \\n    int next() {\\n        return v[i++];\\n    }\\n    \\n    bool hasNext() {\\n        return i<v.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass NestedIterator {\\n    vector<int> v;\\n    int i=0;\\npublic:\\n    void helper(vector<NestedInteger> &nestedList)\\n    {\\n        for(int i=0;i<nestedList.size();i++)\\n        {\\n            if(nestedList[i].isInteger())\\n                v.push_back(nestedList[i].getInteger());\\n            else\\n                helper(nestedList[i].getList());\\n        }\\n    }\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        helper(nestedList);\\n    }\\n    \\n    int next() {\\n        return v[i++];\\n    }\\n    \\n    bool hasNext() {\\n        return i<v.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928981,
                "title": "simple-dfs-solution-c",
                "content": "```\\nclass NestedIterator {\\npublic:\\n    vector<int>mylist;\\n    int idx = 0;\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        flatten(nestedList);\\n    }\\n    void flatten(vector<NestedInteger>&nestedList)\\n    {\\n        for(auto nestedInteger:nestedList)\\n        {\\n            if(nestedInteger.isInteger()){\\n                mylist.push_back(nestedInteger.getInteger());\\n            }\\n            else{\\n                flatten(nestedInteger.getList());\\n            }\\n        }\\n    }\\n    int next() {\\n        return mylist[idx++];\\n    }\\n    \\n    bool hasNext() {\\n      return  idx<mylist.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass NestedIterator {\\npublic:\\n    vector<int>mylist;\\n    int idx = 0;\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        flatten(nestedList);\\n    }\\n    void flatten(vector<NestedInteger>&nestedList)\\n    {\\n        for(auto nestedInteger:nestedList)\\n        {\\n            if(nestedInteger.isInteger()){\\n                mylist.push_back(nestedInteger.getInteger());\\n            }\\n            else{\\n                flatten(nestedInteger.getList());\\n            }\\n        }\\n    }\\n    int next() {\\n        return mylist[idx++];\\n    }\\n    \\n    bool hasNext() {\\n      return  idx<mylist.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877469,
                "title": "simple-java-solution-using-queue-2ms",
                "content": "Using a Queue is simple, because the sequence is align with the input.\\n\\n```\\n    private Queue<Integer> queue = new LinkedList<>();\\n    \\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        for(NestedInteger item : nestedList) {\\n            putIntoQueue(item);\\n        }\\n    }\\n\\n    public Integer next() {\\n        return queue.poll();\\n    }\\n\\n    public boolean hasNext() {\\n        return queue.size() >= 1;\\n    }\\n    \\n    private void putIntoQueue(NestedInteger integer) {\\n        if(integer.isInteger()) {\\n            queue.add(integer.getInteger());\\n        } else {\\n            for(NestedInteger item : integer.getList()) {\\n                putIntoQueue(item);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private Queue<Integer> queue = new LinkedList<>();\\n    \\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        for(NestedInteger item : nestedList) {\\n            putIntoQueue(item);\\n        }\\n    }\\n\\n    public Integer next() {\\n        return queue.poll();\\n    }\\n\\n    public boolean hasNext() {\\n        return queue.size() >= 1;\\n    }\\n    \\n    private void putIntoQueue(NestedInteger integer) {\\n        if(integer.isInteger()) {\\n            queue.add(integer.getInteger());\\n        } else {\\n            for(NestedInteger item : integer.getList()) {\\n                putIntoQueue(item);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 815738,
                "title": "python-7-lines-with-yield-99",
                "content": "```\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        self.flatten_this_shit = list(reversed(list(self.flatten(nestedList))))\\n        \\n    def next(self):\\n        return self.flatten_this_shit.pop()\\n        \\n    def hasNext(self):\\n        return len(self.flatten_this_shit)\\n    \\n    def flatten(self, nestedList):\\n        for ni_outer in nestedList:\\n            if not ni_outer.isInteger():\\n                for ni_inner in self.flatten(ni_outer.getList()): yield ni_inner\\n            else: yield ni_outer.getInteger()\\n```",
                "solutionTags": [],
                "code": "```\\nclass NestedIterator(object):\\n\\n    def __init__(self, nestedList):\\n        self.flatten_this_shit = list(reversed(list(self.flatten(nestedList))))\\n        \\n    def next(self):\\n        return self.flatten_this_shit.pop()\\n        \\n    def hasNext(self):\\n        return len(self.flatten_this_shit)\\n    \\n    def flatten(self, nestedList):\\n        for ni_outer in nestedList:\\n            if not ni_outer.isInteger():\\n                for ni_inner in self.flatten(ni_outer.getList()): yield ni_inner\\n            else: yield ni_outer.getInteger()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793922,
                "title": "python3-flatten-upfront-on-the-fly",
                "content": "Approach 1 - flatten upfront \\n```\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        \\n        def fn(nums):\\n            \"\"\"Return flattened list.\"\"\"\\n            ans = []\\n            for x in nums:\\n                if x.isInteger(): ans.append(x.getInteger())\\n                else: ans.extend(fn(x.getList()))\\n            return ans\\n        \\n        self.data = fn(nestedList)\\n        self.i = 0\\n    \\n    def next(self) -> int:\\n        ans = self.data[self.i]\\n        self.i += 1\\n        return ans \\n    \\n    def hasNext(self) -> bool:\\n         return self.i < len(self.data)\\n```\\n\\nflatten on-the-fly \\n```\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.stack = []\\n        if nestedList: self.stack.append((nestedList, 0))\\n        self.val = self._get()\\n            \\n    def _get(self) -> int: \\n        \"\"\"Get next value in queue.\"\"\"\\n        while self.stack: \\n            data, i = self.stack.pop()\\n            if i+1 < len(data): self.stack.append((data, i+1)) #backtracking point \\n            if data[i].isInteger(): return data[i].getInteger()\\n            if not data[i].getList(): continue #empty list \\n            self.stack.append((data[i].getList(), 0)) #push nested list on stack\\n        return None\\n    \\n    def next(self) -> int:\\n        ans, self.val = self.val, self._get()\\n        return ans \\n    \\n    def hasNext(self) -> bool:\\n        return self.val is not None \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        \\n        def fn(nums):\\n            \"\"\"Return flattened list.\"\"\"\\n            ans = []\\n            for x in nums:\\n                if x.isInteger(): ans.append(x.getInteger())\\n                else: ans.extend(fn(x.getList()))\\n            return ans\\n        \\n        self.data = fn(nestedList)\\n        self.i = 0\\n    \\n    def next(self) -> int:\\n        ans = self.data[self.i]\\n        self.i += 1\\n        return ans \\n    \\n    def hasNext(self) -> bool:\\n         return self.i < len(self.data)\\n```\n```\\nclass NestedIterator:\\n    def __init__(self, nestedList: [NestedInteger]):\\n        self.stack = []\\n        if nestedList: self.stack.append((nestedList, 0))\\n        self.val = self._get()\\n            \\n    def _get(self) -> int: \\n        \"\"\"Get next value in queue.\"\"\"\\n        while self.stack: \\n            data, i = self.stack.pop()\\n            if i+1 < len(data): self.stack.append((data, i+1)) #backtracking point \\n            if data[i].isInteger(): return data[i].getInteger()\\n            if not data[i].getList(): continue #empty list \\n            self.stack.append((data[i].getList(), 0)) #push nested list on stack\\n        return None\\n    \\n    def next(self) -> int:\\n        ans, self.val = self.val, self._get()\\n        return ans \\n    \\n    def hasNext(self) -> bool:\\n        return self.val is not None \\n```",
                "codeTag": "Java"
            },
            {
                "id": 766028,
                "title": "c-clean-solution-using-queue",
                "content": "```\\nclass NestedIterator {\\n    queue<int> q;\\n\\t\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        init(nestedList);\\n    }\\n    \\n    void init(vector<NestedInteger> &nestedList) {\\n        for (auto it : nestedList)\\n            if (it.isInteger())\\n                q.push(it.getInteger());\\n            else\\n                init(it.getList());\\n    }\\n    \\n    int next() {\\n        int nextElement = q.front(); q.pop();\\n        \\n        return nextElement;\\n    }\\n    \\n    bool hasNext() {\\n        return !q.empty();\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass NestedIterator {\\n    queue<int> q;\\n\\t\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        init(nestedList);\\n    }\\n    \\n    void init(vector<NestedInteger> &nestedList) {\\n        for (auto it : nestedList)\\n            if (it.isInteger())\\n                q.push(it.getInteger());\\n            else\\n                init(it.getList());\\n    }\\n    \\n    int next() {\\n        int nextElement = q.front(); q.pop();\\n        \\n        return nextElement;\\n    }\\n    \\n    bool hasNext() {\\n        return !q.empty();\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 755971,
                "title": "go-4ms-simple-solution",
                "content": "```go\\ntype NestedIterator struct {\\n    pointers [][]*NestedInteger\\n    indexes  []int\\n}\\n\\nfunc Constructor(nestedList []*NestedInteger) *NestedIterator {\\n    return &NestedIterator{\\n        pointers: [][]*NestedInteger{nestedList},\\n        indexes:  []int{-1},\\n    }\\n}\\n\\nfunc (this *NestedIterator) Next() int {\\n    level := len(this.pointers)-1\\n    return this.pointers[level][this.indexes[level]].GetInteger()\\n}\\n\\nfunc (this *NestedIterator) HasNext() bool {\\n    level := len(this.pointers) - 1\\n    if level < 0 {\\n        return false\\n    }\\n    if this.indexes[level] + 1 >= len(this.pointers[level]) {\\n        this.pointers = this.pointers[:level]\\n        this.indexes = this.indexes[:level]\\n        return this.HasNext()\\n    }\\n    this.indexes[level]++\\n    if this.pointers[level][this.indexes[level]].IsInteger() {\\n        return true\\n    }\\n    this.pointers = append(this.pointers, this.pointers[level][this.indexes[level]].GetList())\\n    this.indexes = append(this.indexes, -1)\\n    return this.HasNext()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype NestedIterator struct {\\n    pointers [][]*NestedInteger\\n    indexes  []int\\n}\\n\\nfunc Constructor(nestedList []*NestedInteger) *NestedIterator {\\n    return &NestedIterator{\\n        pointers: [][]*NestedInteger{nestedList},\\n        indexes:  []int{-1},\\n    }\\n}\\n\\nfunc (this *NestedIterator) Next() int {\\n    level := len(this.pointers)-1\\n    return this.pointers[level][this.indexes[level]].GetInteger()\\n}\\n\\nfunc (this *NestedIterator) HasNext() bool {\\n    level := len(this.pointers) - 1\\n    if level < 0 {\\n        return false\\n    }\\n    if this.indexes[level] + 1 >= len(this.pointers[level]) {\\n        this.pointers = this.pointers[:level]\\n        this.indexes = this.indexes[:level]\\n        return this.HasNext()\\n    }\\n    this.indexes[level]++\\n    if this.pointers[level][this.indexes[level]].IsInteger() {\\n        return true\\n    }\\n    this.pointers = append(this.pointers, this.pointers[level][this.indexes[level]].GetList())\\n    this.indexes = append(this.indexes, -1)\\n    return this.HasNext()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540893,
                "title": "c-beats-100-in-time-and-space-no-built-in-ds-etc-simple-and-short",
                "content": "```\\nstruct NestedIterator {\\n    int *a, i, n;\\n};\\n\\n#define is_int(...) NestedIntegerIsInteger(__VA_ARGS__)\\n#define gi(...)     NestedIntegerGetInteger(__VA_ARGS__)\\n#define gl(...)     NestedIntegerGetList(__VA_ARGS__)\\n#define glsz(...)   NestedIntegerGetListSize(__VA_ARGS__)\\n\\nvoid *fl(void** nl, int sz, struct NestedIterator *ni) {\\n    if (sz > 0) {\\n        if (is_int(*nl))\\n            ni->a[ni->n++] = gi(*nl);\\n        else\\n            fl(gl(*nl), glsz(*nl), ni);\\n        fl(++nl, --sz, ni);\\n    }\\n    return ni;\\n}\\n\\nstruct NestedIterator *nestedIterCreate(struct NestedInteger** nestedList, int nestedListSize) {\\n    struct NestedIterator *ni = calloc(1, sizeof *ni);\\n    ni->a = calloc(1, sizeof(int [100000]));\\n    return fl((void **)nestedList, nestedListSize, ni);\\n}\\n\\nbool nestedIterHasNext(struct NestedIterator *iter) {\\n    return iter->i < iter->n;\\n}\\n\\nint nestedIterNext(struct NestedIterator *iter) {\\n    return iter->a[iter->i++];\\n}\\n\\nvoid nestedIterFree(struct NestedIterator *iter) {\\n    free(iter->a), free(iter);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct NestedIterator {\\n    int *a, i, n;\\n};\\n\\n#define is_int(...) NestedIntegerIsInteger(__VA_ARGS__)\\n#define gi(...)     NestedIntegerGetInteger(__VA_ARGS__)\\n#define gl(...)     NestedIntegerGetList(__VA_ARGS__)\\n#define glsz(...)   NestedIntegerGetListSize(__VA_ARGS__)\\n\\nvoid *fl(void** nl, int sz, struct NestedIterator *ni) {\\n    if (sz > 0) {\\n        if (is_int(*nl))\\n            ni->a[ni->n++] = gi(*nl);\\n        else\\n            fl(gl(*nl), glsz(*nl), ni);\\n        fl(++nl, --sz, ni);\\n    }\\n    return ni;\\n}\\n\\nstruct NestedIterator *nestedIterCreate(struct NestedInteger** nestedList, int nestedListSize) {\\n    struct NestedIterator *ni = calloc(1, sizeof *ni);\\n    ni->a = calloc(1, sizeof(int [100000]));\\n    return fl((void **)nestedList, nestedListSize, ni);\\n}\\n\\nbool nestedIterHasNext(struct NestedIterator *iter) {\\n    return iter->i < iter->n;\\n}\\n\\nint nestedIterNext(struct NestedIterator *iter) {\\n    return iter->a[iter->i++];\\n}\\n\\nvoid nestedIterFree(struct NestedIterator *iter) {\\n    free(iter->a), free(iter);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 519764,
                "title": "fast-and-simple-c",
                "content": "```\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        \\n        for ( auto& elem : nestedList )\\n            tearDown( elem );\\n    }\\n\\n    int next() {\\n        \\n        int top = queue_.front();\\n        queue_.pop();   \\n        return top;\\n    }\\n\\n    bool hasNext() {\\n        \\n        return !queue_.empty();\\n        \\n    }\\n                \\n    void tearDown( NestedInteger& elem )      \\n    {\\n        if ( elem.isInteger() )\\n             queue_.push( elem.getInteger() );\\n        else\\n        {\\n            for ( auto& lists : elem.getList())\\n                  tearDown( lists );\\n        }\\n    }\\n    \\n    std::queue<int> queue_;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass NestedIterator {\\npublic:\\n    NestedIterator(vector<NestedInteger> &nestedList) {\\n        \\n        for ( auto& elem : nestedList )\\n            tearDown( elem );\\n    }\\n\\n    int next() {\\n        \\n        int top = queue_.front();\\n        queue_.pop();   \\n        return top;\\n    }\\n\\n    bool hasNext() {\\n        \\n        return !queue_.empty();\\n        \\n    }\\n                \\n    void tearDown( NestedInteger& elem )      \\n    {\\n        if ( elem.isInteger() )\\n             queue_.push( elem.getInteger() );\\n        else\\n        {\\n            for ( auto& lists : elem.getList())\\n                  tearDown( lists );\\n        }\\n    }\\n    \\n    std::queue<int> queue_;\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565281,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I noticed simple approach is to just flatten entire list first in constructor, since this makes next and hasNext O(1), even though constructor is O(N). Would an interviewer be ok with this approach, or would he want to actually dynamically maintain some kind of stack so that it always has the next integer?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "To clarify the problem description, a nestedList may contain an empty list as a member, and one of the test cases will force you to handle that edge case."
                    },
                    {
                        "username": "leazzz",
                        "content": "which is stupid"
                    },
                    {
                        "username": "kaidul",
                        "content": "For this problem \"Run Code\" button is not working and code can't be tested. Please fix it :)"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Dayum 2016!!!!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/flatten-nested-list-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Make a Flat List with Recursion\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Two Stacks\n\n  \n**Approach 4:** Stack of Iterators\n\n  \n**Approach 5:** Using a Generator\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ashishk1",
                        "content": "Can anyone help me understand, how to implement such data structure which will hold a List or an integer at a perticular index."
                    },
                    {
                        "username": "manafa",
                        "content": "The test for C has problem\\nLine 59: store to address 0x000000b133b0 with insufficient space for an object of type 'int'"
                    },
                    {
                        "username": "steventang626",
                        "content": "I wrote a blog to talk about this problem and a possible follow-up question that how to change the iterator to be dynamic. \\n\\nMy blog article link is [here](http://steventang626.com/2019/01/18/NestedIterator). Looking for improvement suggestion of the dynamic iteartor implementation."
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem is very similar to [2625. Flatten Deeply Nested Array](https://leetcode.com/problems/flatten-deeply-nested-array/)"
                    },
                    {
                        "username": "zy2021",
                        "content": "Could someone help me understand the type hinting in the given starter code for Python 3? I see \"[NestedInteger]\", what does that mean? I can understand it if it\\'s \"List[NestedInteger]\", but don\\'t know what it means if we only have square brackets. Thanks!\\n"
                    },
                    {
                        "username": "MetalGeek321",
                        "content": "[NestedInteger] is equivalent to List[NestedInteger]. It just means that you are creating a variable that holds a List of instances that are of type NestedInteger. You can verify that by running this code snippet:\\n\\nnestedListA: List[NestedInteger] = [NestedInteger([1, 1]), NestedInteger(2), NestedInteger([3, 5, 7])]\\nprint(type(nestedListA))\\n\\nnestedListB: [NestedInteger] = [NestedInteger([1, 2]), NestedInteger(3), NestedInteger(5)]\\nprint(type(nestedListB))"
                    }
                ]
            },
            {
                "id": 1842911,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I noticed simple approach is to just flatten entire list first in constructor, since this makes next and hasNext O(1), even though constructor is O(N). Would an interviewer be ok with this approach, or would he want to actually dynamically maintain some kind of stack so that it always has the next integer?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "To clarify the problem description, a nestedList may contain an empty list as a member, and one of the test cases will force you to handle that edge case."
                    },
                    {
                        "username": "leazzz",
                        "content": "which is stupid"
                    },
                    {
                        "username": "kaidul",
                        "content": "For this problem \"Run Code\" button is not working and code can't be tested. Please fix it :)"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Dayum 2016!!!!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/flatten-nested-list-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Make a Flat List with Recursion\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Two Stacks\n\n  \n**Approach 4:** Stack of Iterators\n\n  \n**Approach 5:** Using a Generator\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ashishk1",
                        "content": "Can anyone help me understand, how to implement such data structure which will hold a List or an integer at a perticular index."
                    },
                    {
                        "username": "manafa",
                        "content": "The test for C has problem\\nLine 59: store to address 0x000000b133b0 with insufficient space for an object of type 'int'"
                    },
                    {
                        "username": "steventang626",
                        "content": "I wrote a blog to talk about this problem and a possible follow-up question that how to change the iterator to be dynamic. \\n\\nMy blog article link is [here](http://steventang626.com/2019/01/18/NestedIterator). Looking for improvement suggestion of the dynamic iteartor implementation."
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem is very similar to [2625. Flatten Deeply Nested Array](https://leetcode.com/problems/flatten-deeply-nested-array/)"
                    },
                    {
                        "username": "zy2021",
                        "content": "Could someone help me understand the type hinting in the given starter code for Python 3? I see \"[NestedInteger]\", what does that mean? I can understand it if it\\'s \"List[NestedInteger]\", but don\\'t know what it means if we only have square brackets. Thanks!\\n"
                    },
                    {
                        "username": "MetalGeek321",
                        "content": "[NestedInteger] is equivalent to List[NestedInteger]. It just means that you are creating a variable that holds a List of instances that are of type NestedInteger. You can verify that by running this code snippet:\\n\\nnestedListA: List[NestedInteger] = [NestedInteger([1, 1]), NestedInteger(2), NestedInteger([3, 5, 7])]\\nprint(type(nestedListA))\\n\\nnestedListB: [NestedInteger] = [NestedInteger([1, 2]), NestedInteger(3), NestedInteger(5)]\\nprint(type(nestedListB))"
                    }
                ]
            },
            {
                "id": 1565531,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I noticed simple approach is to just flatten entire list first in constructor, since this makes next and hasNext O(1), even though constructor is O(N). Would an interviewer be ok with this approach, or would he want to actually dynamically maintain some kind of stack so that it always has the next integer?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "To clarify the problem description, a nestedList may contain an empty list as a member, and one of the test cases will force you to handle that edge case."
                    },
                    {
                        "username": "leazzz",
                        "content": "which is stupid"
                    },
                    {
                        "username": "kaidul",
                        "content": "For this problem \"Run Code\" button is not working and code can't be tested. Please fix it :)"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Dayum 2016!!!!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/flatten-nested-list-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Make a Flat List with Recursion\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Two Stacks\n\n  \n**Approach 4:** Stack of Iterators\n\n  \n**Approach 5:** Using a Generator\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ashishk1",
                        "content": "Can anyone help me understand, how to implement such data structure which will hold a List or an integer at a perticular index."
                    },
                    {
                        "username": "manafa",
                        "content": "The test for C has problem\\nLine 59: store to address 0x000000b133b0 with insufficient space for an object of type 'int'"
                    },
                    {
                        "username": "steventang626",
                        "content": "I wrote a blog to talk about this problem and a possible follow-up question that how to change the iterator to be dynamic. \\n\\nMy blog article link is [here](http://steventang626.com/2019/01/18/NestedIterator). Looking for improvement suggestion of the dynamic iteartor implementation."
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem is very similar to [2625. Flatten Deeply Nested Array](https://leetcode.com/problems/flatten-deeply-nested-array/)"
                    },
                    {
                        "username": "zy2021",
                        "content": "Could someone help me understand the type hinting in the given starter code for Python 3? I see \"[NestedInteger]\", what does that mean? I can understand it if it\\'s \"List[NestedInteger]\", but don\\'t know what it means if we only have square brackets. Thanks!\\n"
                    },
                    {
                        "username": "MetalGeek321",
                        "content": "[NestedInteger] is equivalent to List[NestedInteger]. It just means that you are creating a variable that holds a List of instances that are of type NestedInteger. You can verify that by running this code snippet:\\n\\nnestedListA: List[NestedInteger] = [NestedInteger([1, 1]), NestedInteger(2), NestedInteger([3, 5, 7])]\\nprint(type(nestedListA))\\n\\nnestedListB: [NestedInteger] = [NestedInteger([1, 2]), NestedInteger(3), NestedInteger(5)]\\nprint(type(nestedListB))"
                    }
                ]
            },
            {
                "id": 1567756,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I noticed simple approach is to just flatten entire list first in constructor, since this makes next and hasNext O(1), even though constructor is O(N). Would an interviewer be ok with this approach, or would he want to actually dynamically maintain some kind of stack so that it always has the next integer?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "To clarify the problem description, a nestedList may contain an empty list as a member, and one of the test cases will force you to handle that edge case."
                    },
                    {
                        "username": "leazzz",
                        "content": "which is stupid"
                    },
                    {
                        "username": "kaidul",
                        "content": "For this problem \"Run Code\" button is not working and code can't be tested. Please fix it :)"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Dayum 2016!!!!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/flatten-nested-list-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Make a Flat List with Recursion\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Two Stacks\n\n  \n**Approach 4:** Stack of Iterators\n\n  \n**Approach 5:** Using a Generator\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ashishk1",
                        "content": "Can anyone help me understand, how to implement such data structure which will hold a List or an integer at a perticular index."
                    },
                    {
                        "username": "manafa",
                        "content": "The test for C has problem\\nLine 59: store to address 0x000000b133b0 with insufficient space for an object of type 'int'"
                    },
                    {
                        "username": "steventang626",
                        "content": "I wrote a blog to talk about this problem and a possible follow-up question that how to change the iterator to be dynamic. \\n\\nMy blog article link is [here](http://steventang626.com/2019/01/18/NestedIterator). Looking for improvement suggestion of the dynamic iteartor implementation."
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem is very similar to [2625. Flatten Deeply Nested Array](https://leetcode.com/problems/flatten-deeply-nested-array/)"
                    },
                    {
                        "username": "zy2021",
                        "content": "Could someone help me understand the type hinting in the given starter code for Python 3? I see \"[NestedInteger]\", what does that mean? I can understand it if it\\'s \"List[NestedInteger]\", but don\\'t know what it means if we only have square brackets. Thanks!\\n"
                    },
                    {
                        "username": "MetalGeek321",
                        "content": "[NestedInteger] is equivalent to List[NestedInteger]. It just means that you are creating a variable that holds a List of instances that are of type NestedInteger. You can verify that by running this code snippet:\\n\\nnestedListA: List[NestedInteger] = [NestedInteger([1, 1]), NestedInteger(2), NestedInteger([3, 5, 7])]\\nprint(type(nestedListA))\\n\\nnestedListB: [NestedInteger] = [NestedInteger([1, 2]), NestedInteger(3), NestedInteger(5)]\\nprint(type(nestedListB))"
                    }
                ]
            },
            {
                "id": 1575260,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I noticed simple approach is to just flatten entire list first in constructor, since this makes next and hasNext O(1), even though constructor is O(N). Would an interviewer be ok with this approach, or would he want to actually dynamically maintain some kind of stack so that it always has the next integer?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "To clarify the problem description, a nestedList may contain an empty list as a member, and one of the test cases will force you to handle that edge case."
                    },
                    {
                        "username": "leazzz",
                        "content": "which is stupid"
                    },
                    {
                        "username": "kaidul",
                        "content": "For this problem \"Run Code\" button is not working and code can't be tested. Please fix it :)"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Dayum 2016!!!!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/flatten-nested-list-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Make a Flat List with Recursion\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Two Stacks\n\n  \n**Approach 4:** Stack of Iterators\n\n  \n**Approach 5:** Using a Generator\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ashishk1",
                        "content": "Can anyone help me understand, how to implement such data structure which will hold a List or an integer at a perticular index."
                    },
                    {
                        "username": "manafa",
                        "content": "The test for C has problem\\nLine 59: store to address 0x000000b133b0 with insufficient space for an object of type 'int'"
                    },
                    {
                        "username": "steventang626",
                        "content": "I wrote a blog to talk about this problem and a possible follow-up question that how to change the iterator to be dynamic. \\n\\nMy blog article link is [here](http://steventang626.com/2019/01/18/NestedIterator). Looking for improvement suggestion of the dynamic iteartor implementation."
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem is very similar to [2625. Flatten Deeply Nested Array](https://leetcode.com/problems/flatten-deeply-nested-array/)"
                    },
                    {
                        "username": "zy2021",
                        "content": "Could someone help me understand the type hinting in the given starter code for Python 3? I see \"[NestedInteger]\", what does that mean? I can understand it if it\\'s \"List[NestedInteger]\", but don\\'t know what it means if we only have square brackets. Thanks!\\n"
                    },
                    {
                        "username": "MetalGeek321",
                        "content": "[NestedInteger] is equivalent to List[NestedInteger]. It just means that you are creating a variable that holds a List of instances that are of type NestedInteger. You can verify that by running this code snippet:\\n\\nnestedListA: List[NestedInteger] = [NestedInteger([1, 1]), NestedInteger(2), NestedInteger([3, 5, 7])]\\nprint(type(nestedListA))\\n\\nnestedListB: [NestedInteger] = [NestedInteger([1, 2]), NestedInteger(3), NestedInteger(5)]\\nprint(type(nestedListB))"
                    }
                ]
            },
            {
                "id": 1567960,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I noticed simple approach is to just flatten entire list first in constructor, since this makes next and hasNext O(1), even though constructor is O(N). Would an interviewer be ok with this approach, or would he want to actually dynamically maintain some kind of stack so that it always has the next integer?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "To clarify the problem description, a nestedList may contain an empty list as a member, and one of the test cases will force you to handle that edge case."
                    },
                    {
                        "username": "leazzz",
                        "content": "which is stupid"
                    },
                    {
                        "username": "kaidul",
                        "content": "For this problem \"Run Code\" button is not working and code can't be tested. Please fix it :)"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Dayum 2016!!!!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/flatten-nested-list-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Make a Flat List with Recursion\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Two Stacks\n\n  \n**Approach 4:** Stack of Iterators\n\n  \n**Approach 5:** Using a Generator\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ashishk1",
                        "content": "Can anyone help me understand, how to implement such data structure which will hold a List or an integer at a perticular index."
                    },
                    {
                        "username": "manafa",
                        "content": "The test for C has problem\\nLine 59: store to address 0x000000b133b0 with insufficient space for an object of type 'int'"
                    },
                    {
                        "username": "steventang626",
                        "content": "I wrote a blog to talk about this problem and a possible follow-up question that how to change the iterator to be dynamic. \\n\\nMy blog article link is [here](http://steventang626.com/2019/01/18/NestedIterator). Looking for improvement suggestion of the dynamic iteartor implementation."
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem is very similar to [2625. Flatten Deeply Nested Array](https://leetcode.com/problems/flatten-deeply-nested-array/)"
                    },
                    {
                        "username": "zy2021",
                        "content": "Could someone help me understand the type hinting in the given starter code for Python 3? I see \"[NestedInteger]\", what does that mean? I can understand it if it\\'s \"List[NestedInteger]\", but don\\'t know what it means if we only have square brackets. Thanks!\\n"
                    },
                    {
                        "username": "MetalGeek321",
                        "content": "[NestedInteger] is equivalent to List[NestedInteger]. It just means that you are creating a variable that holds a List of instances that are of type NestedInteger. You can verify that by running this code snippet:\\n\\nnestedListA: List[NestedInteger] = [NestedInteger([1, 1]), NestedInteger(2), NestedInteger([3, 5, 7])]\\nprint(type(nestedListA))\\n\\nnestedListB: [NestedInteger] = [NestedInteger([1, 2]), NestedInteger(3), NestedInteger(5)]\\nprint(type(nestedListB))"
                    }
                ]
            },
            {
                "id": 1572418,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I noticed simple approach is to just flatten entire list first in constructor, since this makes next and hasNext O(1), even though constructor is O(N). Would an interviewer be ok with this approach, or would he want to actually dynamically maintain some kind of stack so that it always has the next integer?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "To clarify the problem description, a nestedList may contain an empty list as a member, and one of the test cases will force you to handle that edge case."
                    },
                    {
                        "username": "leazzz",
                        "content": "which is stupid"
                    },
                    {
                        "username": "kaidul",
                        "content": "For this problem \"Run Code\" button is not working and code can't be tested. Please fix it :)"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Dayum 2016!!!!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/flatten-nested-list-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Make a Flat List with Recursion\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Two Stacks\n\n  \n**Approach 4:** Stack of Iterators\n\n  \n**Approach 5:** Using a Generator\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ashishk1",
                        "content": "Can anyone help me understand, how to implement such data structure which will hold a List or an integer at a perticular index."
                    },
                    {
                        "username": "manafa",
                        "content": "The test for C has problem\\nLine 59: store to address 0x000000b133b0 with insufficient space for an object of type 'int'"
                    },
                    {
                        "username": "steventang626",
                        "content": "I wrote a blog to talk about this problem and a possible follow-up question that how to change the iterator to be dynamic. \\n\\nMy blog article link is [here](http://steventang626.com/2019/01/18/NestedIterator). Looking for improvement suggestion of the dynamic iteartor implementation."
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem is very similar to [2625. Flatten Deeply Nested Array](https://leetcode.com/problems/flatten-deeply-nested-array/)"
                    },
                    {
                        "username": "zy2021",
                        "content": "Could someone help me understand the type hinting in the given starter code for Python 3? I see \"[NestedInteger]\", what does that mean? I can understand it if it\\'s \"List[NestedInteger]\", but don\\'t know what it means if we only have square brackets. Thanks!\\n"
                    },
                    {
                        "username": "MetalGeek321",
                        "content": "[NestedInteger] is equivalent to List[NestedInteger]. It just means that you are creating a variable that holds a List of instances that are of type NestedInteger. You can verify that by running this code snippet:\\n\\nnestedListA: List[NestedInteger] = [NestedInteger([1, 1]), NestedInteger(2), NestedInteger([3, 5, 7])]\\nprint(type(nestedListA))\\n\\nnestedListB: [NestedInteger] = [NestedInteger([1, 2]), NestedInteger(3), NestedInteger(5)]\\nprint(type(nestedListB))"
                    }
                ]
            },
            {
                "id": 1861166,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I noticed simple approach is to just flatten entire list first in constructor, since this makes next and hasNext O(1), even though constructor is O(N). Would an interviewer be ok with this approach, or would he want to actually dynamically maintain some kind of stack so that it always has the next integer?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "To clarify the problem description, a nestedList may contain an empty list as a member, and one of the test cases will force you to handle that edge case."
                    },
                    {
                        "username": "leazzz",
                        "content": "which is stupid"
                    },
                    {
                        "username": "kaidul",
                        "content": "For this problem \"Run Code\" button is not working and code can't be tested. Please fix it :)"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Dayum 2016!!!!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/flatten-nested-list-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Make a Flat List with Recursion\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Two Stacks\n\n  \n**Approach 4:** Stack of Iterators\n\n  \n**Approach 5:** Using a Generator\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ashishk1",
                        "content": "Can anyone help me understand, how to implement such data structure which will hold a List or an integer at a perticular index."
                    },
                    {
                        "username": "manafa",
                        "content": "The test for C has problem\\nLine 59: store to address 0x000000b133b0 with insufficient space for an object of type 'int'"
                    },
                    {
                        "username": "steventang626",
                        "content": "I wrote a blog to talk about this problem and a possible follow-up question that how to change the iterator to be dynamic. \\n\\nMy blog article link is [here](http://steventang626.com/2019/01/18/NestedIterator). Looking for improvement suggestion of the dynamic iteartor implementation."
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem is very similar to [2625. Flatten Deeply Nested Array](https://leetcode.com/problems/flatten-deeply-nested-array/)"
                    },
                    {
                        "username": "zy2021",
                        "content": "Could someone help me understand the type hinting in the given starter code for Python 3? I see \"[NestedInteger]\", what does that mean? I can understand it if it\\'s \"List[NestedInteger]\", but don\\'t know what it means if we only have square brackets. Thanks!\\n"
                    },
                    {
                        "username": "MetalGeek321",
                        "content": "[NestedInteger] is equivalent to List[NestedInteger]. It just means that you are creating a variable that holds a List of instances that are of type NestedInteger. You can verify that by running this code snippet:\\n\\nnestedListA: List[NestedInteger] = [NestedInteger([1, 1]), NestedInteger(2), NestedInteger([3, 5, 7])]\\nprint(type(nestedListA))\\n\\nnestedListB: [NestedInteger] = [NestedInteger([1, 2]), NestedInteger(3), NestedInteger(5)]\\nprint(type(nestedListB))"
                    }
                ]
            },
            {
                "id": 1837902,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "I noticed simple approach is to just flatten entire list first in constructor, since this makes next and hasNext O(1), even though constructor is O(N). Would an interviewer be ok with this approach, or would he want to actually dynamically maintain some kind of stack so that it always has the next integer?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "To clarify the problem description, a nestedList may contain an empty list as a member, and one of the test cases will force you to handle that edge case."
                    },
                    {
                        "username": "leazzz",
                        "content": "which is stupid"
                    },
                    {
                        "username": "kaidul",
                        "content": "For this problem \"Run Code\" button is not working and code can't be tested. Please fix it :)"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Dayum 2016!!!!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/flatten-nested-list-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Make a Flat List with Recursion\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Two Stacks\n\n  \n**Approach 4:** Stack of Iterators\n\n  \n**Approach 5:** Using a Generator\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ashishk1",
                        "content": "Can anyone help me understand, how to implement such data structure which will hold a List or an integer at a perticular index."
                    },
                    {
                        "username": "manafa",
                        "content": "The test for C has problem\\nLine 59: store to address 0x000000b133b0 with insufficient space for an object of type 'int'"
                    },
                    {
                        "username": "steventang626",
                        "content": "I wrote a blog to talk about this problem and a possible follow-up question that how to change the iterator to be dynamic. \\n\\nMy blog article link is [here](http://steventang626.com/2019/01/18/NestedIterator). Looking for improvement suggestion of the dynamic iteartor implementation."
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem is very similar to [2625. Flatten Deeply Nested Array](https://leetcode.com/problems/flatten-deeply-nested-array/)"
                    },
                    {
                        "username": "zy2021",
                        "content": "Could someone help me understand the type hinting in the given starter code for Python 3? I see \"[NestedInteger]\", what does that mean? I can understand it if it\\'s \"List[NestedInteger]\", but don\\'t know what it means if we only have square brackets. Thanks!\\n"
                    },
                    {
                        "username": "MetalGeek321",
                        "content": "[NestedInteger] is equivalent to List[NestedInteger]. It just means that you are creating a variable that holds a List of instances that are of type NestedInteger. You can verify that by running this code snippet:\\n\\nnestedListA: List[NestedInteger] = [NestedInteger([1, 1]), NestedInteger(2), NestedInteger([3, 5, 7])]\\nprint(type(nestedListA))\\n\\nnestedListB: [NestedInteger] = [NestedInteger([1, 2]), NestedInteger(3), NestedInteger(5)]\\nprint(type(nestedListB))"
                    }
                ]
            }
        ]
    }
]