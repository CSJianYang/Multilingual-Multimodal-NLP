[
    {
        "title": "Remove Outermost Parentheses",
        "question_content": "A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\n\n\tFor example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\n\nA valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.\nGiven a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.\nReturn s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.\n&nbsp;\nExample 1:\n\nInput: s = \"(()())(())\"\nOutput: \"()()()\"\nExplanation: \nThe input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\".\n\nExample 2:\n\nInput: s = \"(()())(())(()(()))\"\nOutput: \"()()()()(())\"\nExplanation: \nThe input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\".\n\nExample 3:\n\nInput: s = \"()()\"\nOutput: \"\"\nExplanation: \nThe input string is \"()()\", with primitive decomposition \"()\" + \"()\".\nAfter removing outer parentheses of each part, this is \"\" + \"\" = \"\".\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 105\n\ts[i] is either '(' or ')'.\n\ts is a valid parentheses string.",
        "solutions": [
            {
                "id": 270022,
                "title": "java-c-python-count-opened-parenthesis",
                "content": "## **Intuition**\\nQuote from @shubhama,\\nPrimitive string will have equal number of opened and closed parenthesis.\\n\\n## **Explanation**:\\n`opened` count the number of opened parenthesis.\\nAdd every char to the result,\\nunless the first left parenthesis,\\nand the last right parenthesis.\\n\\n## **Time Complexity**:\\n`O(N)` Time, `O(N)` space\\n\\n<br>\\n\\n**Java:**\\n```\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder s = new StringBuilder();\\n        int opened = 0;\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\' && opened++ > 0) s.append(c);\\n            if (c == \\')\\' && opened-- > 1) s.append(c);\\n        }\\n        return s.toString();\\n    }\\n```\\n\\n**C++:**\\n```\\n    string removeOuterParentheses(string S) {\\n        string res;\\n        int opened = 0;\\n        for (char c : S) {\\n            if (c == \\'(\\' && opened++ > 0) res += c;\\n            if (c == \\')\\' && opened-- > 1) res += c;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```\\n    def removeOuterParentheses(self, S):\\n        res, opened = [], 0\\n        for c in S:\\n            if c == \\'(\\' and opened > 0: res.append(c)\\n            if c == \\')\\' and opened > 1: res.append(c)\\n            opened += 1 if c == \\'(\\' else -1\\n        return \"\".join(res)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder s = new StringBuilder();\\n        int opened = 0;\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\' && opened++ > 0) s.append(c);\\n            if (c == \\')\\' && opened-- > 1) s.append(c);\\n        }\\n        return s.toString();\\n    }\\n```\n```\\n    string removeOuterParentheses(string S) {\\n        string res;\\n        int opened = 0;\\n        for (char c : S) {\\n            if (c == \\'(\\' && opened++ > 0) res += c;\\n            if (c == \\')\\' && opened-- > 1) res += c;\\n        }\\n        return res;\\n    }\\n```\n```\\n    def removeOuterParentheses(self, S):\\n        res, opened = [], 0\\n        for c in S:\\n            if c == \\'(\\' and opened > 0: res.append(c)\\n            if c == \\')\\' and opened > 1: res.append(c)\\n            opened += 1 if c == \\'(\\' else -1\\n        return \"\".join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3551123,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string res;\\n        int opened = 0;\\n        for (char c : S) {\\n            if (c == \\'(\\' && opened++ > 0) res += c;\\n            if (c == \\')\\' && opened-- > 1) res += c;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        res, opened = [], 0\\n        for c in S:\\n            if c == \\'(\\' and opened > 0: res.append(c)\\n            if c == \\')\\' and opened > 1: res.append(c)\\n            opened += 1 if c == \\'(\\' else -1\\n        \\n        return \"\".join(res)\\n```\\n\\n```Java []\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int len = s.length();\\n        if (len <= 2) return \"\";\\n        char[] c = s.toCharArray();\\n        StringBuilder newString = new StringBuilder();\\n        int open = 1;\\n        int openLeft = 0;\\n        for (int i = 1; i < len; i++) {\\n            if (c[i] == \\'(\\') {\\n                open++;\\n                if (open > 1) newString.append(\\'(\\');\\n            }\\n            else {\\n                if (open > 1) newString.append(\\')\\');\\n                open--;\\n            }\\n        }\\n        return newString.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string res;\\n        int opened = 0;\\n        for (char c : S) {\\n            if (c == \\'(\\' && opened++ > 0) res += c;\\n            if (c == \\')\\' && opened-- > 1) res += c;\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        res, opened = [], 0\\n        for c in S:\\n            if c == \\'(\\' and opened > 0: res.append(c)\\n            if c == \\')\\' and opened > 1: res.append(c)\\n            opened += 1 if c == \\'(\\' else -1\\n        \\n        return \"\".join(res)\\n```\n```Java []\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int len = s.length();\\n        if (len <= 2) return \"\";\\n        char[] c = s.toCharArray();\\n        StringBuilder newString = new StringBuilder();\\n        int open = 1;\\n        int openLeft = 0;\\n        for (int i = 1; i < len; i++) {\\n            if (c[i] == \\'(\\') {\\n                open++;\\n                if (open > 1) newString.append(\\'(\\');\\n            }\\n            else {\\n                if (open > 1) newString.append(\\')\\');\\n                open--;\\n            }\\n        }\\n        return newString.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165562,
                "title": "well-explained-code-in-java",
                "content": "\\n\\n# Approach\\nThis is a solution to the problem of removing outermost parentheses from a string containing only parentheses.\\n\\nThe approach used is to keep track of the parentheses using a stack. Whenever an opening parenthesis is encountered, it is pushed onto the stack. Whenever a closing parenthesis is encountered, the last opening parenthesis is popped from the stack.\\n\\nIf the stack size is greater than zero after pushing or popping, it means that the parenthesis is not an outer parenthesis, and it is added to the result string. If the stack size is zero, it means that the parenthesis is an outer parenthesis and it is not added to the result string.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n), where n is the length of the input string. This is because each character in the string is processed once and the push and pop operations on the stack take O(1) time each.\\n\\n\\n\\n- Space complexity:\\nThe space complexity of this solution is O(n), where n is the length of the input string. This is because the maximum size of the stack is n/2 (if all the parentheses are opening parentheses), and in the worst case, the result string can also have a size of n/2.\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> bracket = new Stack<>();\\n        StringBuilder sb = new StringBuilder(\"\");\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                if(bracket.size()>0){\\n                    sb.append(s.charAt(i));\\n                }\\n                bracket.push(s.charAt(i));\\n            }else{\\n                bracket.pop();\\n                if(bracket.size()>0){\\n                    sb.append(s.charAt(i));\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/150a5515-b27f-42d1-9a2e-aed10f236bca_1675969899.9073486.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> bracket = new Stack<>();\\n        StringBuilder sb = new StringBuilder(\"\");\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                if(bracket.size()>0){\\n                    sb.append(s.charAt(i));\\n                }\\n                bracket.push(s.charAt(i));\\n            }else{\\n                bracket.pop();\\n                if(bracket.size()>0){\\n                    sb.append(s.charAt(i));\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270566,
                "title": "my-java-3ms-straight-forward-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int open=0, close=0, start=0;\\n        for(int i=0; i<S.length(); i++) {\\n            if(S.charAt(i) == \\'(\\') {\\n                open++;\\n            } else if(S.charAt(i) == \\')\\') {\\n                close++;\\n            }\\n            if(open==close) {\\n                sb.append(S.substring(start+1, i));\\n                start=i+1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int open=0, close=0, start=0;\\n        for(int i=0; i<S.length(); i++) {\\n            if(S.charAt(i) == \\'(\\') {\\n                open++;\\n            } else if(S.charAt(i) == \\')\\') {\\n                close++;\\n            }\\n            if(open==close) {\\n                sb.append(S.substring(start+1, i));\\n                start=i+1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290126,
                "title": "c-0ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        int count = 0;\\n        std::string str;\\n        for (char c : S) {\\n            if (c == \\'(\\') {\\n                if (count++) {\\n                    str += \\'(\\';\\n                }\\n            } else {\\n                if (--count) {\\n                    str += \\')\\';\\n                }\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        int count = 0;\\n        std::string str;\\n        for (char c : S) {\\n            if (c == \\'(\\') {\\n                if (count++) {\\n                    str += \\'(\\';\\n                }\\n            } else {\\n                if (--count) {\\n                    str += \\')\\';\\n                }\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815947,
                "title": "c-two-solution-stack-and-with-out-stack-only-slight-modification-in-stack-sol",
                "content": "please **upVote** my solution if you like it.\\n\\nMy first solution is stack based and it consume more memory than with out stack solution in my second solution to elemenate stack from it so please reffer to that also \\n\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    string removeOuterParentheses(string S) {\\n        stack<char>st;\\n        string ans;\\n        for(auto a:S)\\n        {\\n            if(a==\\'(\\')\\n            {\\n                if(st.size()>0)\\n                {\\n                    ans+=\\'(\\';\\n                }\\n                st.push(\\'(\\');\\n            }\\n            else\\n            {\\n                if(st.size()>1)\\n                {\\n                    ans+=\\')\\';\\n                }\\n                st.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'\\n\\nSolution without stack \\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    string removeOuterParentheses(string S) {\\n        int st=0;\\n        string ans;\\n        for(auto a:S)\\n        {\\n            if(a==\\'(\\')\\n            {\\n                if(st>0)\\n                {\\n                    ans+=\\'(\\';\\n                }\\n                st++;\\n            }\\n            else\\n            {\\n                if(st>1)\\n                {\\n                    ans+=\\')\\';\\n                }\\n                st--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string removeOuterParentheses(string S) {\\n        stack<char>st;\\n        string ans;\\n        for(auto a:S)\\n        {\\n            if(a==\\'(\\')\\n            {\\n                if(st.size()>0)\\n                {\\n                    ans+=\\'(\\';\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 299353,
                "title": "python-simple-o-n-solution-beats-97",
                "content": "```python\\ndef removeOuterParentheses(self, S):\\n\\tres = []\\n\\tbalance = 0\\n\\ti = 0\\n\\tfor j in range(len(S)):\\n\\t\\tif S[j] == \"(\":\\n\\t\\t\\tbalance += 1\\n\\t\\telif S[j] == \")\":\\n\\t\\t\\tbalance -= 1\\n\\t\\tif balance == 0:\\n\\t\\t\\tres.append(S[i+1:j])\\n\\t\\t\\ti = j+1\\n\\treturn \"\".join(res)\\n```",
                "solutionTags": [],
                "code": "```python\\ndef removeOuterParentheses(self, S):\\n\\tres = []\\n\\tbalance = 0\\n\\ti = 0\\n\\tfor j in range(len(S)):\\n\\t\\tif S[j] == \"(\":\\n\\t\\t\\tbalance += 1\\n\\t\\telif S[j] == \")\":\\n\\t\\t\\tbalance -= 1\\n\\t\\tif balance == 0:\\n\\t\\t\\tres.append(S[i+1:j])\\n\\t\\t\\ti = j+1\\n\\treturn \"\".join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2916928,
                "title": "one-pass-faang-sde-1-interview",
                "content": "```\\nVery Easy Beginner Friendly Solution \\uD83D\\uDCA1\\nDo not use stack to prevent more extra space.\\n\\n\\nPlease do Upvote if it helps :)\\n```\\n\\n# Complexity\\n- Time complexity: O(n) //One pass\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) //For resultant string\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string res;\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' && count==0)\\n                count++;\\n            else if(s[i]==\\'(\\' && count>=1){\\n                res+=s[i];\\n                count++;\\n            }   \\n            else if(s[i]==\\')\\' && count>1){\\n                res+=s[i];\\n                count--;\\n            }\\n            else if(s[i]==\\')\\' && count==1)\\n                count--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```\\nVery Easy Beginner Friendly Solution \\uD83D\\uDCA1\\nDo not use stack to prevent more extra space.\\n\\n\\nPlease do Upvote if it helps :)\\n```\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string res;\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' && count==0)\\n                count++;\\n            else if(s[i]==\\'(\\' && count>=1){\\n                res+=s[i];\\n                count++;\\n            }   \\n            else if(s[i]==\\')\\' && count>1){\\n                res+=s[i];\\n                count--;\\n            }\\n            else if(s[i]==\\')\\' && count==1)\\n                count--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319686,
                "title": "easy-to-understand-python-with-comments",
                "content": "```Python\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        res = \\'\\'\\n        stack = []\\n        \\n        # basket is used to store previous value\\n        basket = \\'\\'\\n        \\n        for p in S:\\n            if p == \\'(\\':\\n                stack.append(p)\\n            else:\\n                stack.pop()\\n            basket += p\\n            \\n            # if the stack is empty it means we have a valid\\n            # decomposition. remove the outer parentheses\\n            # and put it in the result/res. make sure to\\n            # clean up the basket though!\\n            if not stack:\\n                res += basket[1:-1]\\n                basket = \\'\\'\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```Python\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        res = \\'\\'\\n        stack = []\\n        \\n        # basket is used to store previous value\\n        basket = \\'\\'\\n        \\n        for p in S:\\n            if p == \\'(\\':\\n                stack.append(p)\\n            else:\\n                stack.pop()\\n            basket += p\\n            \\n            # if the stack is empty it means we have a valid\\n            # decomposition. remove the outer parentheses\\n            # and put it in the result/res. make sure to\\n            # clean up the basket though!\\n            if not stack:\\n                res += basket[1:-1]\\n                basket = \\'\\'\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428396,
                "title": "java-beats-98-simple-iterative-solution",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        int counter = 0;\\n        for(char c : S.toCharArray()){\\n            if(c == \\'(\\'){\\n                if(counter != 0) sb.append(c);\\n                counter++;\\n            }\\n            else{\\n                counter--;\\n                if(counter != 0) sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        int counter = 0;\\n        for(char c : S.toCharArray()){\\n            if(c == \\'(\\'){\\n                if(counter != 0) sb.append(c);\\n                counter++;\\n            }\\n            else{\\n                counter--;\\n                if(counter != 0) sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273884,
                "title": "ridiculously-simple-java-o-n-solution-explanation-0ms-beats-100-time-memory",
                "content": "**Explanation:**\\nSince the input String only consists of parentheses we don\\'t even have to mainatain a Stack. We can simply maintain a counter which is O(1) and keep incrementing and decrementing it\\'s value based on the opening/closing bracket.\\n\\n**Algorithm:**\\n1. Convert the given input String to a `char` array and start scanning.\\n2. Maintain a `sum` counter (Initially 0) and for every following character in the input char array,\\n3. When, `(` check whether **sum** is greater than **zero** and if yes, add this char to your String Builder; Also, increment the **sum** by **1** \\n4. When, `)` decrement the **sum** by **1** and then, check whether **sum** is greater than **zero** and if yes, add this char to your String Builder;\\n5. Return the string from your builder.\\n\\n**Code:**\\n```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder builder = new StringBuilder();\\n\\tchar[] chr = S.toCharArray();\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < chr.length; i++) {\\n\\t\\tif (chr[i] == \\'(\\') {\\n\\t\\t\\tif (sum > 0) { builder.append(chr[i]); }\\n\\t\\t\\tsum += 1;\\n\\t\\t} else {\\n\\t\\t\\tsum -= 1;\\n\\t\\t\\tif (sum > 0) { builder.append(chr[i]); }\\n\\t\\t}\\n\\t}\\n\\treturn builder.toString();\\n}\\n```\\n\\n**Compressed Version:**\\n```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder builder = new StringBuilder();\\n\\tchar[] chr = S.toCharArray();\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < chr.length; i++) {\\n\\t\\tif ((chr[i] == \\'(\\' && sum++ > 0) || (chr[i] == \\')\\' && --sum > 0)) {\\n\\t\\t\\tbuilder.append(chr[i]);\\n\\t\\t}\\n\\t}\\n\\treturn builder.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder builder = new StringBuilder();\\n\\tchar[] chr = S.toCharArray();\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < chr.length; i++) {\\n\\t\\tif (chr[i] == \\'(\\') {\\n\\t\\t\\tif (sum > 0) { builder.append(chr[i]); }\\n\\t\\t\\tsum += 1;\\n\\t\\t} else {\\n\\t\\t\\tsum -= 1;\\n\\t\\t\\tif (sum > 0) { builder.append(chr[i]); }\\n\\t\\t}\\n\\t}\\n\\treturn builder.toString();\\n}\\n```\n```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder builder = new StringBuilder();\\n\\tchar[] chr = S.toCharArray();\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < chr.length; i++) {\\n\\t\\tif ((chr[i] == \\'(\\' && sum++ > 0) || (chr[i] == \\')\\' && --sum > 0)) {\\n\\t\\t\\tbuilder.append(chr[i]);\\n\\t\\t}\\n\\t}\\n\\treturn builder.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 269956,
                "title": "c-two-pointers",
                "content": "# Intuition\\nWhen the number of ```open``` parentheses equals ```closed```, we found a primitive string.\\n# Solution\\nUse two pointers to track primitive strings; when ```open == close```, remove outermost parentheses and add the string to the result.\\n```\\nstring removeOuterParentheses(string S, string res = \"\") {\\n  for (auto p1 = 0, p2 = 0, open = 0, close = 0; p2 < S.size(); ++p2) {\\n    if (S[p2] == \\'(\\') ++open;\\n    else ++close;\\n    if (open == close) {\\n      res += S.substr(p1 + 1, p2 - p1 - 1);\\n      p1 = p2 + 1;\\n    }\\n  }\\n  return res;\\n}\\n```\\n# Complexity Analysis\\nRuntime: O(n).\\nMemory: O(n) to store the result.",
                "solutionTags": [],
                "code": "```open```\n```closed```\n```open == close```\n```\\nstring removeOuterParentheses(string S, string res = \"\") {\\n  for (auto p1 = 0, p2 = 0, open = 0, close = 0; p2 < S.size(); ++p2) {\\n    if (S[p2] == \\'(\\') ++open;\\n    else ++close;\\n    if (open == close) {\\n      res += S.substr(p1 + 1, p2 - p1 - 1);\\n      p1 = p2 + 1;\\n    }\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1262840,
                "title": "c-stack-and-without-stack-solutions",
                "content": "**Stack implementation**\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s)\\n    {\\n        stack<char>sc;\\n        string ans;\\n        for(char i:s)\\n        {\\n            if(i == \\'(\\')\\n            {\\n                if(sc.size() > 0)\\n                {\\n                    ans += i;\\n                }\\n                sc.push(i);\\n            }\\n            else\\n            {\\n                if(sc.size() > 1)\\n                {\\n                    ans += i;\\n                }\\n                sc.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Without stack implementation**\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s)\\n    {\\n        int count = 0;\\n        string ans;\\n        for(char i:s)\\n        {\\n            if(i == \\'(\\')\\n            {\\n                if(count > 0)\\n                {\\n                    ans += i;\\n                }\\n                count++;\\n            }\\n            else\\n            {\\n                if(count > 1)\\n                {\\n                    ans += i;\\n                }\\n                count--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s)\\n    {\\n        stack<char>sc;\\n        string ans;\\n        for(char i:s)\\n        {\\n            if(i == \\'(\\')\\n            {\\n                if(sc.size() > 0)\\n                {\\n                    ans += i;\\n                }\\n                sc.push(i);\\n            }\\n            else\\n            {\\n                if(sc.size() > 1)\\n                {\\n                    ans += i;\\n                }\\n                sc.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s)\\n    {\\n        int count = 0;\\n        string ans;\\n        for(char i:s)\\n        {\\n            if(i == \\'(\\')\\n            {\\n                if(count > 0)\\n                {\\n                    ans += i;\\n                }\\n                count++;\\n            }\\n            else\\n            {\\n                if(count > 1)\\n                {\\n                    ans += i;\\n                }\\n                count--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594405,
                "title": "python-super-easy-98-speed",
                "content": "We just need a For-Loop to count the number of Parenthesis open. The \"append\" operator goes at the center of the expression to avoid including the Outermost Patentheses. Cheers,\\n\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        popen, result = 0, []\\n        for x in S:\\n            if x==\\')\\':\\n                popen -= 1\\n            if popen>0:\\n                result.append(x)\\n            if x==\\'(\\':\\n                popen += 1\\n        return \\'\\'.join(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        popen, result = 0, []\\n        for x in S:\\n            if x==\\')\\':\\n                popen -= 1\\n            if popen>0:\\n                result.append(x)\\n            if x==\\'(\\':\\n                popen += 1\\n        return \\'\\'.join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301174,
                "title": "javascript-beats-99-26-easy-to-understand",
                "content": "```\\nvar removeOuterParentheses = function(S) {\\n    let result = \\'\\';\\n    let open = 0\\n    for (let i = 0; i < S.length; i++) {\\n        if (S[i] === \\'(\\') {\\n            if (open > 0) { \\n\\t\\t\\t\\tresult += \\'(\\';\\n\\t\\t\\t}\\n\\t\\t\\topen++;\\n        } else if (S[i] === \\')\\') {\\n            if (open > 1) { \\n\\t\\t\\t\\tresult += \\')\\'; \\n\\t\\t\\t}\\n\\t\\t\\topen--;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar removeOuterParentheses = function(S) {\\n    let result = \\'\\';\\n    let open = 0\\n    for (let i = 0; i < S.length; i++) {\\n        if (S[i] === \\'(\\') {\\n            if (open > 0) { \\n\\t\\t\\t\\tresult += \\'(\\';\\n\\t\\t\\t}\\n\\t\\t\\topen++;\\n        } else if (S[i] === \\')\\') {\\n            if (open > 1) { \\n\\t\\t\\t\\tresult += \\')\\'; \\n\\t\\t\\t}\\n\\t\\t\\topen--;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2680199,
                "title": "python-solution-using-stack-and-maintaining-counter",
                "content": "# Before I explain any further get this, let\\'s say for each \"(\" you get you put -1 and for each \")\" you get you put +1 to the counter varriable and because of that whenever we encounter a valid paranthese our sum will be zero for example for (()())(()) can be decomposed to (()()) + (()) note that for each valid decomposition our sum will be zero. Example (()) -1-1+1+1 ==0 also for (()()) -1-1+1-1+1+1==0 for each time our sum is zero we are looking at a valid decompostion and hence at that moment we take what we have in our stack and remove the outter brackets which is done easily using stack[1:-1] it will exlude the first and last from our stack and we add this value to our answer list and make our stack empty again for future decompistion, we repeat this and return the \" \".join(final_answer) here final answer is the list that has all the decompositions with there outter barckets removed. Upvote if you liked the approch. Thanks\\n\\n\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        stack = []\\n        final_answer = []\\n        counter=0\\n        for val in s:\\n            stack.append(val)\\n            if val==\\'(\\':\\n                counter+=1\\n            elif val==\\')\\':\\n                counter-=1\\n            if counter==0:\\n                final_answer+=stack[1:-1]\\n                stack=[]\\n        \\n        return \"\".join(final_answer)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        stack = []\\n        final_answer = []\\n        counter=0\\n        for val in s:\\n            stack.append(val)\\n            if val==\\'(\\':\\n                counter+=1\\n            elif val==\\')\\':\\n                counter-=1\\n            if counter==0:\\n                final_answer+=stack[1:-1]\\n                stack=[]\\n        \\n        return \"\".join(final_answer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379872,
                "title": "javascript-solution-98-faster",
                "content": "```\\nvar removeOuterParentheses = function(S) {\\n    let parenthesCount = 0;\\n    let result = \"\";\\n    \\n    for (const letter of S) {\\n        if (letter === \"(\") {\\n            if (parenthesCount) {\\n                result += letter;\\n            }\\n            parenthesCount++;\\n        } else {\\n            parenthesCount--;\\n            if (parenthesCount) {\\n                result += letter;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeOuterParentheses = function(S) {\\n    let parenthesCount = 0;\\n    let result = \"\";\\n    \\n    for (const letter of S) {\\n        if (letter === \"(\") {\\n            if (parenthesCount) {\\n                result += letter;\\n            }\\n            parenthesCount++;\\n        } else {\\n            parenthesCount--;\\n            if (parenthesCount) {\\n                result += letter;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 358358,
                "title": "shortest-python-solution",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        cnt, res = 0, \\'\\'\\n        for c in S:\\n            if c == \\')\\': cnt -= 1  \\n            if cnt != 0: res += c \\n            if c == \\'(\\': cnt+=1    \\n        return res\\n```            \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        cnt, res = 0, \\'\\'\\n        for c in S:\\n            if c == \\')\\': cnt -= 1  \\n            if cnt != 0: res += c \\n            if c == \\'(\\': cnt+=1    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399066,
                "title": "python3-simple-solution-99-8",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        res = \"\"\\n        count = 0\\n        first = 0\\n        for i in range(len(S)):\\n            if S[i] == \"(\":\\n                count +=1\\n            else:\\n                count -= 1\\n            \\n            if(count == 0):\\n                res +=(S[first+1:i])\\n                first = i+1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        res = \"\"\\n        count = 0\\n        first = 0\\n        for i in range(len(S)):\\n            if S[i] == \"(\":\\n                count +=1\\n            else:\\n                count -= 1\\n            \\n            if(count == 0):\\n                res +=(S[first+1:i])\\n                first = i+1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194215,
                "title": "best-c-2-solution-ever-string-stack-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using String + Stack.\\n2. Solved using String.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of the string(num). Here loop creates the time complexity.\\n\\n    Space complexity : O(N), Stack(store) space.\\n\\n    Solved using String + Stack.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> store;\\n        string ans = \"\";\\n        for(auto c : s){\\n            if(c == \\'(\\'){\\n                if(store.size() > 0){\\n                    ans += c;\\n                }\\n                store.push(c);\\n            }\\n            else if(c == \\')\\'){\\n                if(store.size() > 1){\\n                    ans += c;\\n                }\\n                store.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of the string(num). Here loop creates the time complexity.\\n\\n    Space complexity : O(1), Constant space. Extra space is only allocated for the String(ans), however the\\n    output does not count towards the space complexity.\\n\\n    Solved using String.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans = \"\";\\n        int openParentheses = 0;\\n        for(auto c : s){\\n            if(c == \\'(\\'){\\n                if(openParentheses > 0){\\n                    ans += c;\\n                }\\n                openParentheses++;\\n            }\\n            else if(c == \\')\\'){\\n                if(openParentheses > 1){\\n                    ans += c;\\n                }\\n                openParentheses--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of the string(num). Here loop creates the time complexity.\\n\\n    Space complexity : O(N), Stack(store) space.\\n\\n    Solved using String + Stack.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> store;\\n        string ans = \"\";\\n        for(auto c : s){\\n            if(c == \\'(\\'){\\n                if(store.size() > 0){\\n                    ans += c;\\n                }\\n                store.push(c);\\n            }\\n            else if(c == \\')\\'){\\n                if(store.size() > 1){\\n                    ans += c;\\n                }\\n                store.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of the string(num). Here loop creates the time complexity.\\n\\n    Space complexity : O(1), Constant space. Extra space is only allocated for the String(ans), however the\\n    output does not count towards the space complexity.\\n\\n    Solved using String.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans = \"\";\\n        int openParentheses = 0;\\n        for(auto c : s){\\n            if(c == \\'(\\'){\\n                if(openParentheses > 0){\\n                    ans += c;\\n                }\\n                openParentheses++;\\n            }\\n            else if(c == \\')\\'){\\n                if(openParentheses > 1){\\n                    ans += c;\\n                }\\n                openParentheses--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 308161,
                "title": "java-in-6-lines",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        int count = 0;\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\n\\t\\tfor (char c : s.toCharArray()) {\\n\\n\\t\\t\\tif (c == \\'(\\' && count++ > 0) { sb.append(c); }\\n\\t\\t\\tif (c == \\')\\' && --count > 0) { sb.append(c); }\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        int count = 0;\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\n\\t\\tfor (char c : s.toCharArray()) {\\n\\n\\t\\t\\tif (c == \\'(\\' && count++ > 0) { sb.append(c); }\\n\\t\\t\\tif (c == \\')\\' && --count > 0) { sb.append(c); }\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270153,
                "title": "simple-o-n-java-solution",
                "content": "Thanks to fengyunzhe90.\\n\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        \\n        String result = \"\";\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            \\n            if (stack.isEmpty() && c == \\'(\\') {\\n                stack.push(c);\\n                continue;\\n            }\\n            \\n            if (stack.size() == 1 && c == \\')\\') {\\n                stack.pop();\\n                continue;\\n            }\\n            \\n            if (c == \\'(\\') {\\n                stack.push(c);\\n            }\\n            \\n            if (c == \\')\\') {\\n                stack.pop();\\n            }\\n            result += c + \"\";\\n        }\\n\\n        return result;\\n    }\\n} ;",
                "solutionTags": [],
                "code": "class Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        \\n        String result = \"\";\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            \\n            if (stack.isEmpty() && c == \\'(\\') {\\n                stack.push(c);\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1297744,
                "title": "java-o-n-easy-approach-with-comment",
                "content": "```\\nclass Solution\\n{\\n    public String removeOuterParentheses(String S) \\n    {\\n        Stack<Character> valid=new Stack<>();//checking the balance and when the stack is Empty\\n        List<Integer> index=new ArrayList<>();//for storing the index\\n        char ch;\\n        \\n        for(int i=0;i<S.length();i++)//traversering the indices \\n        {\\n            ch=S.charAt(i);//extracting charracter\\n            if(valid.isEmpty())//new valid parentheses \\n            {\\n                valid.push(ch);//pushing it into the stack the open parentheses \\n                index.add(i);//and pushing it corresponding index \\n            }\\n            else if(ch==\\')\\'&&valid.peek()==\\'(\\')\\n            {\\n                valid.pop();\\n                if(valid.isEmpty())//ending of new valid parentheses\\n                   index.add(i);//storing the closing index \\n            }\\n            else\\n            {\\n                valid.push(ch);//otherwise pushing he open parentheses \\n            }\\n        }\\n        StringBuilder res=new StringBuilder();//resultant \\n        for(int i=0;i<index.size();i+=2)//index is always in pair i.e;starting and ending \\n        {\\n            res.append(S.substring(index.get(i)+1,index.get(i+1)));//removing the outmost parenthesis for the given pair of indices \\n        }\\n        return res.toString();//returning the String \\n    }\\n}//Please do vote me, It helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution\\n{\\n    public String removeOuterParentheses(String S) \\n    {\\n        Stack<Character> valid=new Stack<>();//checking the balance and when the stack is Empty\\n        List<Integer> index=new ArrayList<>();//for storing the index\\n        char ch;\\n        \\n        for(int i=0;i<S.length();i++)//traversering the indices \\n        {\\n            ch=S.charAt(i);//extracting charracter\\n            if(valid.isEmpty())//new valid parentheses \\n            {\\n                valid.push(ch);//pushing it into the stack the open parentheses \\n                index.add(i);//and pushing it corresponding index \\n            }\\n            else if(ch==\\')\\'&&valid.peek()==\\'(\\')\\n            {\\n                valid.pop();\\n                if(valid.isEmpty())//ending of new valid parentheses\\n                   index.add(i);//storing the closing index \\n            }\\n            else\\n            {\\n                valid.push(ch);//otherwise pushing he open parentheses \\n            }\\n        }\\n        StringBuilder res=new StringBuilder();//resultant \\n        for(int i=0;i<index.size();i+=2)//index is always in pair i.e;starting and ending \\n        {\\n            res.append(S.substring(index.get(i)+1,index.get(i+1)));//removing the outmost parenthesis for the given pair of indices \\n        }\\n        return res.toString();//returning the String \\n    }\\n}//Please do vote me, It helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978008,
                "title": "java-simple-solution-runtime-2ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count = 0;\\n        StringBuilder result = new StringBuilder();\\n\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                if (count != 0) {\\n                    result.append(c);\\n                }\\n                count++;\\n            } else {\\n                if (count != 1) {\\n                    result.append(c);\\n                }\\n                count--;\\n            }\\n        }\\n\\n        return result.toString();\\n    }\\n}\\n\\n```\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/81901a24-f5a0-4fb4-a020-a3cda419a018_1693337713.2181766.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count = 0;\\n        StringBuilder result = new StringBuilder();\\n\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                if (count != 0) {\\n                    result.append(c);\\n                }\\n                count++;\\n            } else {\\n                if (count != 1) {\\n                    result.append(c);\\n                }\\n                count--;\\n            }\\n        }\\n\\n        return result.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766133,
                "title": "stack-java",
                "content": "If you like it pls upvote\\n```\\n\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                if (st.size() >= 1) {\\n                    sb.append(s.charAt(i));\\n                }\\n                st.push(s.charAt(i));\\n            } else {\\n                if (st.size() > 1) {\\n                    sb.append(s.charAt(i));\\n                }\\n                st.pop();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                if (st.size() >= 1) {\\n                    sb.append(s.charAt(i));\\n                }\\n                st.push(s.charAt(i));\\n            } else {\\n                if (st.size() > 1) {\\n                    sb.append(s.charAt(i));\\n                }\\n                st.pop();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 271188,
                "title": "c-solution-using-stack",
                "content": "```class Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string result=\"\";\\n        stack<char> st;\\n        for(auto ch : S){\\n            if(ch==\\'(\\'){\\n                if(st.size()>0){\\n                    result+=ch;\\n                }\\n                st.push(ch);\\n            }\\n            else{\\n                if(st.size()>1){\\n                    result+=ch;\\n                }\\n                st.pop();\\n            }\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string result=\"\";\\n        stack<char> st;\\n        for(auto ch : S){\\n            if(ch==\\'(\\'){\\n                if(st.size()>0){\\n                    result+=ch;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2607580,
                "title": "java-2-approaches-with-without-stack",
                "content": "**The main thing is --> (()()) --> If the stack(or counter) is greater than 1 then include \"(\" and \")\" in answer else don\\'t include as we need to remove outermost parenthesis... If you find the solution helpful please  upvote :)**\\n\\n**Without stack approach -->**\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int level = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                level++;\\n            }\\n            if(level > 1){\\n                sb.append(s.charAt(i));\\n            }\\n            if(s.charAt(i) == \\')\\'){\\n                level--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n\\n**With Stack Approach-->**\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        Stack<Character> st = new Stack<>();\\n        for(char c : s.toCharArray()){\\n            if(st.isEmpty() && c == \\'(\\'){\\n                st.push(\\'(\\');\\n            }\\n            else if(!st.isEmpty() && c == \\'(\\'){\\n                st.push(c);\\n                sb.append(c);\\n            }\\n            else if(st.size() >1 && c == \\')\\'){\\n                st.pop();\\n                sb.append(c);\\n            }\\n            else if(st.size() == 1 && c == \\')\\'){\\n                st.pop();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int level = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                level++;\\n            }\\n            if(level > 1){\\n                sb.append(s.charAt(i));\\n            }\\n            if(s.charAt(i) == \\')\\'){\\n                level--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        Stack<Character> st = new Stack<>();\\n        for(char c : s.toCharArray()){\\n            if(st.isEmpty() && c == \\'(\\'){\\n                st.push(\\'(\\');\\n            }\\n            else if(!st.isEmpty() && c == \\'(\\'){\\n                st.push(c);\\n                sb.append(c);\\n            }\\n            else if(st.size() >1 && c == \\')\\'){\\n                st.pop();\\n                sb.append(c);\\n            }\\n            else if(st.size() == 1 && c == \\')\\'){\\n                st.pop();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977605,
                "title": "c-0ms-shortest-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char> st;\\n        string ans;\\n        for(char c: S)\\n        {\\n            if(c == \\')\\') st.pop();\\n            if(!st.empty()) ans += c;\\n            if(c == \\'(\\') st.push(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char> st;\\n        string ans;\\n        for(char c: S)\\n        {\\n            if(c == \\')\\') st.pop();\\n            if(!st.empty()) ans += c;\\n            if(c == \\'(\\') st.push(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915577,
                "title": "clean-javascript-solution",
                "content": "```\\n// time O(n) space O(n)\\nvar removeOuterParentheses = function(S) {\\n    let result = \\'\\'\\n    let level = 0\\n    \\n    for(const item of S) {\\n        if(item === \\')\\') {\\n            level--\\n        }\\n        if(level >= 1) {\\n            result += item                \\n        }\\n        if(item === \\'(\\') {\\n            level++\\n        }\\n    }\\n    \\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// time O(n) space O(n)\\nvar removeOuterParentheses = function(S) {\\n    let result = \\'\\'\\n    let level = 0\\n    \\n    for(const item of S) {\\n        if(item === \\')\\') {\\n            level--\\n        }\\n        if(level >= 1) {\\n            result += item                \\n        }\\n        if(item === \\'(\\') {\\n            level++\\n        }\\n    }\\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526367,
                "title": "c-2-solutions-stack-counter",
                "content": "# Solution 1 : Use std::stack\\n\\n## Intuition\\nTo solve this problem, we can keep track of the outer parentheses using a stack. Whenever we encounter an open parenthesis, we push it onto the stack. When we encounter a close parenthesis, we pop an open parenthesis from the stack. We only add the current character to our result string when the stack is not empty.\\n\\n## Approach\\n1 Initialize an empty stack and an empty result string.\\n2. Iterate through the input string:\\na. If the stack is not empty, add the current character to the result string.\\nb. If the current character is an open parenthesis, push it onto the stack.\\nc. If the current character is a close parenthesis, pop an open parenthesis from the stack. If the stack is now empty, remove the last character from the result string.\\n3. Return the result string.\\n\\n## Complexity\\n- Time complexity: $$O(n)$$, where n is the length of the input string. We iterate through the entire string once.\\n- Space complexity: $$O(n)$$, as in the worst case (e.g., all open parentheses), the stack could store all characters in the input string.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        std::stack<char> stack;\\n        std::string r;\\n\\n        for(auto c: s){\\n            if(!stack.empty()) {\\n                r += c;\\n            }\\n            if(c == \\'(\\') {\\n                stack.push(c);\\n            }\\n            else {\\n                stack.pop();\\n                if(stack.empty()) { \\n                    r.pop_back();\\n                }\\n            }\\n        }\\n\\n        return r;\\n    }\\n};\\n```\\n\\n\\n# Solution 2 : Use a counter\\n\\n## Intuition\\nAn alternative to using a stack is to simply maintain a count of the open parentheses encountered. We can increment the count when we encounter an open parenthesis and decrement it when we encounter a close parenthesis.\\n\\n## Approach\\n1. Initialize an empty result string and a count variable set to 0.\\n2. Iterate through the input string:\\na. If the current character is an open parenthesis and the count is greater than 0, add the current character to the result string and increment the count.\\nb. If the current character is a close parenthesis and the count is greater than 1, add the current character to the result string and decrement the count.\\n3. Return the result string.\\n\\n## Complexity\\n- Time complexity: $$O(n)$$, where n is the length of the input string. We iterate through the entire string once.\\n- Space complexity: $$O(n)$$, since the result string could store up to n-2 characters (e.g., if the input string has only one pair of outer parentheses).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        std::string r;\\n        int count = 0;\\n        for(char c : s){\\n            if(c == \\'(\\' && count++ > 0) r += c;\\n            if(c == \\')\\' && count-- > 1) r += c;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        std::stack<char> stack;\\n        std::string r;\\n\\n        for(auto c: s){\\n            if(!stack.empty()) {\\n                r += c;\\n            }\\n            if(c == \\'(\\') {\\n                stack.push(c);\\n            }\\n            else {\\n                stack.pop();\\n                if(stack.empty()) { \\n                    r.pop_back();\\n                }\\n            }\\n        }\\n\\n        return r;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        std::string r;\\n        int count = 0;\\n        for(char c : s){\\n            if(c == \\'(\\' && count++ > 0) r += c;\\n            if(c == \\')\\' && count-- > 1) r += c;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720986,
                "title": "c-stack-and-without-stack-easy-solution",
                "content": "**Approach 1: (Stack) \\u2705**\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n\\nstring removeOuterParentheses(string S) {\\n    stack<char>st;\\n    string ans;\\n    for(auto a:S)\\n    {\\n        if(a==\\'(\\')\\n        {\\n            if(st.size()>0)\\n            {\\n                ans+=\\'(\\';\\n            }\\n            st.push(\\'(\\');\\n        }\\n        else\\n        {\\n            if(st.size()>1)\\n            {\\n                ans+=\\')\\';\\n            }\\n            st.pop();\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                if(st.size() > 0){\\n                    sb.append(ch);\\n                }\\n                st.push(ch);\\n            }\\n            else\\n            {\\n               st.pop();\\n                if(st.size() > 0){\\n                    sb.append(ch);\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n**Approach 2: (Without Stack ) \\u2705**\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n\\nstring removeOuterParentheses(string S) {\\n    int st=0;\\n    string ans;\\n    for(auto a:S)\\n    {\\n        if(a==\\'(\\')\\n        {\\n            if(st>0)\\n            {\\n                ans+=\\'(\\';\\n            }\\n            st++;\\n        }\\n        else\\n        {\\n            if(st>1)\\n            {\\n                ans+=\\')\\';\\n            }\\n            st--;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        int counter = 0;\\n        for(char c : S.toCharArray()){\\n            if(c == \\'(\\'){\\n                if(counter != 0) sb.append(c);\\n                counter++;\\n            }\\n            else{\\n                counter--;\\n                if(counter != 0) sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nstring removeOuterParentheses(string S) {\\n    stack<char>st;\\n    string ans;\\n    for(auto a:S)\\n    {\\n        if(a==\\'(\\')\\n        {\\n            if(st.size()>0)\\n            {\\n                ans+=\\'(\\';\\n            }\\n            st.push(\\'(\\');\\n        }\\n        else\\n        {\\n            if(st.size()>1)\\n            {\\n                ans+=\\')\\';\\n            }\\n            st.pop();\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                if(st.size() > 0){\\n                    sb.append(ch);\\n                }\\n                st.push(ch);\\n            }\\n            else\\n            {\\n               st.pop();\\n                if(st.size() > 0){\\n                    sb.append(ch);\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\nstring removeOuterParentheses(string S) {\\n    int st=0;\\n    string ans;\\n    for(auto a:S)\\n    {\\n        if(a==\\'(\\')\\n        {\\n            if(st>0)\\n            {\\n                ans+=\\'(\\';\\n            }\\n            st++;\\n        }\\n        else\\n        {\\n            if(st>1)\\n            {\\n                ans+=\\')\\';\\n            }\\n            st--;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```\n```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        int counter = 0;\\n        for(char c : S.toCharArray()){\\n            if(c == \\'(\\'){\\n                if(counter != 0) sb.append(c);\\n                counter++;\\n            }\\n            else{\\n                counter--;\\n                if(counter != 0) sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250239,
                "title": "java-two-solution-1-using-stack-2-simple-for-loop",
                "content": "using Stack\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        Stack<Character> st=new Stack();\\n        StringBuilder sb=new StringBuilder();\\n        for(char ch:S.toCharArray())\\n        {\\n            if(ch==\\'(\\')\\n            {\\n                 if(st.size()>=1)\\n                 {\\n                     sb.append(ch);\\n                 }\\n                st.push(ch);\\n            }\\n            else{\\n                if(st.size()>1)\\n                 {\\n                     sb.append(ch);\\n                 }\\n                st.pop();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\nusing Array\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        int top=-1;\\n        String str=\"\";\\n        for(int i=0;i<S.length()-1;i++){\\n           \\n            if(S.charAt(i)==\\'(\\'&&++top!=0)\\n           {\\n               str+=S.charAt(i);\\n           }\\n            else if(S.charAt(i)==\\')\\'&&--top!=-1)\\n            {\\n                str+=S.charAt(i);\\n            }\\n          \\n        }\\n        return str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        Stack<Character> st=new Stack();\\n        StringBuilder sb=new StringBuilder();\\n        for(char ch:S.toCharArray())\\n        {\\n            if(ch==\\'(\\')\\n            {\\n                 if(st.size()>=1)\\n                 {\\n                     sb.append(ch);\\n                 }\\n                st.push(ch);\\n            }\\n            else{\\n                if(st.size()>1)\\n                 {\\n                     sb.append(ch);\\n                 }\\n                st.pop();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        int top=-1;\\n        String str=\"\";\\n        for(int i=0;i<S.length()-1;i++){\\n           \\n            if(S.charAt(i)==\\'(\\'&&++top!=0)\\n           {\\n               str+=S.charAt(i);\\n           }\\n            else if(S.charAt(i)==\\')\\'&&--top!=-1)\\n            {\\n                str+=S.charAt(i);\\n            }\\n          \\n        }\\n        return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162269,
                "title": "python-simplest-solution",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        \\n        stack=[]\\n        counter=0\\n        for i in S:\\n            if i==\\'(\\':\\n                counter=counter+1\\n                if counter==1:\\n                    pass\\n                else:\\n                    stack.append(i)\\n            else:\\n                counter=counter-1\\n                if counter == 0:\\n                    pass\\n                else:\\n                    stack.append(i)\\n        return (\\'\\'.join(stack))\\n```\\n\\nDo upvote \\uD83D\\uDC4D if you like and understand my approach!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        \\n        stack=[]\\n        counter=0\\n        for i in S:\\n            if i==\\'(\\':\\n                counter=counter+1\\n                if counter==1:\\n                    pass\\n                else:\\n                    stack.append(i)\\n            else:\\n                counter=counter-1\\n                if counter == 0:\\n                    pass\\n                else:\\n                    stack.append(i)\\n        return (\\'\\'.join(stack))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270450,
                "title": "javascript-counter-solution",
                "content": "```\\n/**\\n * @param {string} S\\n * @return {string}\\n */\\nvar removeOuterParentheses = function(S) {\\n    let counter = 0;\\n    let result = \\'\\';\\n    \\n    for (let i = 0; i < S.length; i++) {\\n        if ((S[i] === \\'(\\' && ++counter !== 1) || (S[i] === \\')\\' && --counter !== 0)) {\\n            result += S[i];\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} S\\n * @return {string}\\n */\\nvar removeOuterParentheses = function(S) {\\n    let counter = 0;\\n    let result = \\'\\';\\n    \\n    for (let i = 0; i < S.length; i++) {\\n        if ((S[i] === \\'(\\' && ++counter !== 1) || (S[i] === \\')\\' && --counter !== 0)) {\\n            result += S[i];\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3890939,
                "title": "easy-c-solution-beginner-friendly",
                "content": "\\n# Approach\\nThis question is all about the counter. As the very first bracket would start from 0 and thus that will not be included and the last outermost bracket with value 0 will also be not included.\\n\\nIn this way we will check whether the char should be added into the string or not. \\nAdd 1 if there is \\'(\\' open parenthesis. and sub 1 if  \\')\\' clsed paranthesis.\\n\\nFor eg.\\n    \\n![01.png](https://assets.leetcode.com/users/images/0aec98a5-dfdc-452d-9417-ad1e1bacf6eb_1691679008.493465.png)\\n\\n\\nIn above explanation, wherever the count is zero. We are not adding that in string.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans=\"\";\\n        int c=0;\\n        for(char ch:s){\\n            if(ch==\\'(\\' && c==0){\\n                //skip, as this would be the first bracket so it will be considered as outermost bracket\\n                c++;\\n            }\\n            else if(ch==\\'(\\' && c>=1){\\n                ans+=ch;\\n                c++;\\n                //add ch in the string\\n            }\\n            else if(ch==\\')\\' && c>1){\\n                //sub ch in the string, as it\\'s pair is alrrady added\\n                ans+=ch;\\n                c--;\\n            }\\n            else if(ch==\\')\\' && c==1){\\n                //skip it, outermost bracket\\n                c--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans=\"\";\\n        int c=0;\\n        for(char ch:s){\\n            if(ch==\\'(\\' && c==0){\\n                //skip, as this would be the first bracket so it will be considered as outermost bracket\\n                c++;\\n            }\\n            else if(ch==\\'(\\' && c>=1){\\n                ans+=ch;\\n                c++;\\n                //add ch in the string\\n            }\\n            else if(ch==\\')\\' && c>1){\\n                //sub ch in the string, as it\\'s pair is alrrady added\\n                ans+=ch;\\n                c--;\\n            }\\n            else if(ch==\\')\\' && c==1){\\n                //skip it, outermost bracket\\n                c--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876395,
                "title": "c-beats-100-self-explained-beginner-friendly-approach-clean-code-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string result;\\n        stack <char> st;\\n        for(int i:s)\\n        {\\n            if(i==\\'(\\')\\n            {\\n                if(!st.empty())\\n                {\\n                result.push_back(i);\\n                }\\n                st.push(i);\\n            }\\n            else{\\n                st.pop();\\n                if(!st.empty())\\n                {\\n                    result.push_back(i);\\n                }\\n            }\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string result;\\n        stack <char> st;\\n        for(int i:s)\\n        {\\n            if(i==\\'(\\')\\n            {\\n                if(!st.empty())\\n                {\\n                result.push_back(i);\\n                }\\n                st.push(i);\\n            }\\n            else{\\n                st.pop();\\n                if(!st.empty())\\n                {\\n                    result.push_back(i);\\n                }\\n            }\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627545,
                "title": "remove-outermost-parentheses-cpp-easy-way",
                "content": "```\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int count = 0;\\n        string ans = \"\";\\n        for(int i=0;i<s.length();i++){\\n            if( s[i]==\\'(\\' && count == 0){\\n                count++;\\n            }\\n            else\\n                if(s[i]==\\'(\\' && count>0){\\n                    count++;\\n                    ans+=s[i];\\n                }\\n            else if(s[i]==\\')\\'){\\n                count--;\\n                if(count>0)ans+=s[i];\\n            } \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n```",
                "solutionTags": [],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1949936,
                "title": "simple-short-and-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string str) {\\n        string ans = \"\";\\n        stack<char> s;\\n        \\n        for(char c : str){\\n            if(c == \\'(\\') s.push(c);\\n            if(s.size() > 1) ans += c;\\n            if(c == \\')\\') s.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string str) {\\n        string ans = \"\";\\n        stack<char> s;\\n        \\n        for(char c : str){\\n            if(c == \\'(\\') s.push(c);\\n            if(s.size() > 1) ans += c;\\n            if(c == \\')\\') s.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338577,
                "title": "python-solution-beats-99",
                "content": "Traverse the string `S` from left to right. Time: O(N).\\n\\nUse the variable `net` to record the current net number of parenthese -- \\'(\\' contributes +1 and \\')\\' contributes -1. \\n\\nThe variable \\'start\\' is to store the starting index of the next primitive part in \\'S\\'.\\n\\nWhenever \\'net\\' becomes 0, one concludes that from the start position to the current position we have a primitive part. Update `res` by adding this primitive part without the starting \\'(\\' and the ending \\')\\'. Also, reset `start`.\\n\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        net, res, start = 0 , \\'\\', 0\\n        for i in range(len(S)):\\n            \\n            if S[i] == \\'(\\':\\n                net += 1\\n            else:\\n                net -= 1\\n            \\n            if net == 0:\\n                res += S[start+1:i]\\n                start = i + 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        net, res, start = 0 , \\'\\', 0\\n        for i in range(len(S)):\\n            \\n            if S[i] == \\'(\\':\\n                net += 1\\n            else:\\n                net -= 1\\n            \\n            if net == 0:\\n                res += S[start+1:i]\\n                start = i + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398832,
                "title": "c-and-c-very-easy-solution",
                "content": "# Intuition:First of all,we have to find outer parentheses and after that we have to add other parentheses to a new string.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:Each pair has a couple of parenthese.So we use stack to declare which parenthese is either opener or cleser.\\n<!-- Describe your approach to solving the problem. -->\\n![photo_2023-04-10_05-40-10.jpg](https://assets.leetcode.com/users/images/399e55fc-74f8-4ba0-809c-086907be6e71_1681087371.7124531.jpeg)\\n\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string result;\\n        int index = 0;\\n        for (char x : s) {\\n           switch(x){\\n               case \\'(\\':\\n               if(index++>0)result+=x;\\n               break;\\n               case \\')\\':\\n               if(index-->1)result+=x;\\n               break;\\n           }\\n        }\\n        return result;\\n    }\\n};\\n```\\n```C# []\\npublic class Solution {\\n    public string RemoveOuterParentheses(string s) {\\n        StringBuilder result=new();\\n        int index = 0;\\n        foreach (char x in s) {\\n            if (x == \\'(\\' && index++ > 0) \\n            result.Append(x);\\n            else if (x == \\')\\' && index-- > 1) \\n            result.Append(x);\\n        }\\n        return result.ToString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C#",
                    "String",
                    "Stack"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string result;\\n        int index = 0;\\n        for (char x : s) {\\n           switch(x){\\n               case \\'(\\':\\n               if(index++>0)result+=x;\\n               break;\\n               case \\')\\':\\n               if(index-->1)result+=x;\\n               break;\\n           }\\n        }\\n        return result;\\n    }\\n};\\n```\n```C# []\\npublic class Solution {\\n    public string RemoveOuterParentheses(string s) {\\n        StringBuilder result=new();\\n        int index = 0;\\n        foreach (char x in s) {\\n            if (x == \\'(\\' && index++ > 0) \\n            result.Append(x);\\n            else if (x == \\')\\' && index-- > 1) \\n            result.Append(x);\\n        }\\n        return result.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109592,
                "title": "best-o-n-solution",
                "content": "\\n\\n# Approach\\nBest Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int count = 0;\\n        string ans = \"\";\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'(\\') {\\n                if (count > 0)\\n                    ans += s[i]; \\n                count++;\\n            }\\n            if (s[i] == \\')\\') {\\n                if (count > 1)\\n                    ans += s[i];\\n                count--;\\n            }       \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int count = 0;\\n        string ans = \"\";\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'(\\') {\\n                if (count > 0)\\n                    ans += s[i]; \\n                count++;\\n            }\\n            if (s[i] == \\')\\') {\\n                if (count > 1)\\n                    ans += s[i];\\n                count--;\\n            }       \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062859,
                "title": "java-without-using-stack-simple-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n       String res=\"\";\\n       int k=0;\\n       int op=0;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           if(s.charAt(i)==\\'(\\')op++;\\n           else op--;\\n           if(op==0){\\n               res+=help(s.substring(k,i+1));\\n               k=i+1;\\n           }\\n       }\\n       return res;\\n    }\\n\\n    public static String help(String str)\\n    {\\n        return str.substring(1,str.length()-1);\\n    }\\n}\\n\\n/*\\n s = \"(  ()()   )    (  ()   )\"\\n int k=0;\\n open=0;close=0;\\n ( op=1  ( op=1\\n (op=2   ( op=2\\n )op=1   ) op=1\\n (op=2   ) op=0\\n )op=1\\n)op=0\\nwhen op becomes 0 (op=0) , we gonna found one decompose string and removing it\\'s outer most parenthese\\n*/\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n       String res=\"\";\\n       int k=0;\\n       int op=0;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           if(s.charAt(i)==\\'(\\')op++;\\n           else op--;\\n           if(op==0){\\n               res+=help(s.substring(k,i+1));\\n               k=i+1;\\n           }\\n       }\\n       return res;\\n    }\\n\\n    public static String help(String str)\\n    {\\n        return str.substring(1,str.length()-1);\\n    }\\n}\\n\\n/*\\n s = \"(  ()()   )    (  ()   )\"\\n int k=0;\\n open=0;close=0;\\n ( op=1  ( op=1\\n (op=2   ( op=2\\n )op=1   ) op=1\\n (op=2   ) op=0\\n )op=1\\n)op=0\\nwhen op becomes 0 (op=0) , we gonna found one decompose string and removing it\\'s outer most parenthese\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009037,
                "title": "without-stack-beats-100-6-lines-solution-c",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n    int cnt = 0;\\n    string res;\\n    for(char x : s)\\n    { \\n        if(x == \\'(\\'&& cnt++ > 0) res += x;\\n        if (x == \\')\\' && cnt-- > 1) res += x;\\n    }\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n    int cnt = 0;\\n    string res;\\n    for(char x : s)\\n    { \\n        if(x == \\'(\\'&& cnt++ > 0) res += x;\\n        if (x == \\')\\' && cnt-- > 1) res += x;\\n    }\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834889,
                "title": "java-faster-solution-99-85-big-o-n-without-stack",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count = 0;\\n        StringBuilder str = new StringBuilder();\\n\\n        for(int i = 0; i<s.length(); i++){\\n            if( s.charAt(i) == \\'(\\'){\\n                count++;\\n                if(count>=2) str.append(\\'(\\');\\n            }else {\\n                if(count>=2) str.append(\\')\\');\\n                count--;\\n            }\\n        }\\n\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count = 0;\\n        StringBuilder str = new StringBuilder();\\n\\n        for(int i = 0; i<s.length(); i++){\\n            if( s.charAt(i) == \\'(\\'){\\n                count++;\\n                if(count>=2) str.append(\\'(\\');\\n            }else {\\n                if(count>=2) str.append(\\')\\');\\n                count--;\\n            }\\n        }\\n\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859843,
                "title": "c-easy-understandable-solution-using-stack",
                "content": "```\\nstring removeOuterParentheses(string s) {\\n        stack<char>s1;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                if(s1.size()>0)\\n                    ans+=\\'(\\';\\n                s1.push(\\'(\\');\\n            }else\\n            {\\n                if(s1.size()>1)\\n                    ans+=\\')\\';\\n                s1.pop();\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nstring removeOuterParentheses(string s) {\\n        stack<char>s1;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                if(s1.size()>0)\\n                    ans+=\\'(\\';\\n                s1.push(\\'(\\');\\n            }else\\n            {\\n                if(s1.size()>1)\\n                    ans+=\\')\\';\\n                s1.pop();\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1487636,
                "title": "100-fastest-solution-explained-every-line-efficient-easy-to-understand-cpp-o-n",
                "content": "100% fastest solution | Explained every line | Efficient | Easy to understand | cpp | O(n)\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) \\n    {\\n        string ans;\\n        stack<char> st;\\n\\n        for(auto x: s)\\n        {\\n            if(x==\\'(\\')   // 1. ->add to stack    2. -> add to ans if not outermost\\n            {\\n                if(st.size()>0)\\n                    ans.push_back(x);\\n                st.push(x);\\n            }\\n            else  // 1. -> pop    2. -> add to ans if not empty\\n            {\\n                st.pop();\\n                if(!st.empty())\\n                    ans.push_back(x);\\n            }\\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) \\n    {\\n        string ans;\\n        stack<char> st;\\n\\n        for(auto x: s)\\n        {\\n            if(x==\\'(\\')   // 1. ->add to stack    2. -> add to ans if not outermost\\n            {\\n                if(st.size()>0)\\n                    ans.push_back(x);\\n                st.push(x);\\n            }\\n            else  // 1. -> pop    2. -> add to ans if not empty\\n            {\\n                st.pop();\\n                if(!st.empty())\\n                    ans.push_back(x);\\n            }\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1209415,
                "title": "python-simple-solution-speed-98-46-and-memory-99-39",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        ans = []\\n        l = []\\n        count = 0\\n        for i in S:\\n            l.append(i)\\n            if i == \\'(\\':\\n                count+= 1\\n            else:\\n                count -= 1\\n            if count == 0:\\n                ans.extend(l[1:-1])\\n                l = []\\n        return \"\".join(ans)\\n\\t\\t\\n\\t# Kindly upvote if you find it useful !!\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        ans = []\\n        l = []\\n        count = 0\\n        for i in S:\\n            l.append(i)\\n            if i == \\'(\\':\\n                count+= 1\\n            else:\\n                count -= 1\\n            if count == 0:\\n                ans.extend(l[1:-1])\\n                l = []\\n        return \"\".join(ans)\\n\\t\\t\\n\\t# Kindly upvote if you find it useful !!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1020703,
                "title": "python-simple-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        result =  \\'\\'\\n        depth = 0\\n        for index in range(0, len(S) - 1):\\n            char = S[index]\\n            if depth != 0:\\n                result += char\\n            if char == \"(\" and S[index + 1] == \"(\":\\n                depth += 1\\n            elif char == \")\" and S[index + 1] == \")\":\\n                depth -= 1\\n        return result\\n```\\n\\nThe **depth** variable represents how many levels into the primitive parentheses the current parenthesis is in. A depth value of zero represents a paraenteses belonging to a set primitive parentheses.\\n\\n## Logic\\n- Subsequent opening parentheses will result in depth increasing by one\\n- Subsequent closing parentheses will result in depth decreasing by one\\n-  A switch from closing to opening parenthesis \\'(\\' -> \\')\\' will not change the depth value\\n-  If the depth value is not 0 (i.e. not an outer parenthesis) add the current parenthesis to the result\\n-  The last parenthesis in the string S will always be a closing parenthesis [i.e. \")\" ]\\n\\n\\n### Example 1\\n| Depth Value | 0 | 1 | 2 | 2 | 1 | 0 |\\n|:-----------:|:-:|---|---|---|---|---|\\n| char in S      | ( | ( | ( | ) | ) | ) |\\n\\n\\n### Example 2\\n| Depth Value | 0 | 1 | 1 | 0 | 0 | 1 | 1 | 0 |\\n|:-----------:|:-:|---|---|---|---|---|---|---|\\n| char in S  | ( | ( | ) | ) | ( | ( | ) | ) |\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        result =  \\'\\'\\n        depth = 0\\n        for index in range(0, len(S) - 1):\\n            char = S[index]\\n            if depth != 0:\\n                result += char\\n            if char == \"(\" and S[index + 1] == \"(\":\\n                depth += 1\\n            elif char == \")\" and S[index + 1] == \")\":\\n                depth -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955525,
                "title": "c-faster-than-100-easy",
                "content": "A simple iterative program that iterates on the string.\\nWe use a variable flag to cound the number of left parenthesis. Since we just have to remove one parenthesis only, we check if the flag value is greater than 1, and then add characters to the resultant string.\\n\\n```\\nConsider the following test case\\n\\n\\tS = \"(()())(())\"\\n\\t\\t\\n\\t\\t\\t1. S[i] = \"(\"  , flag = 1, result = \"\";\\n\\t\\t\\t2. S[i] = \"(\"  , flag = 2, result = \"(\";\\n\\t\\t\\t3. S[i] = \")\"  , flag = 1, result = \"()\";\\n\\t\\t\\t4. S[i] = \"(\"  , flag = 2, result = \"()(\";\\n\\t\\t\\t5. S[i] = \")\"  , flag = 1, result = \"()()\";\\n\\t\\t\\t6. S[i] = \")\"  , flag = 0, result = \"()()\";\\n\\t\\t\\t7. S[i] = \"(\"  , flag = 1, result = \"()()\";\\n\\t\\t\\t8. S[i] = \"(\"  , flag = 2, result = \"()()(\";\\n\\t\\t\\t9. S[i] = \")\"  , flag = 1, result = \"()()()\";\\n\\t\\t\\t10. S[i] = \")\"  , flag = 0, result = \"()()()\";\\n\\t\\t\\t\\n\\t\\t\\tresult = \"()()()\";\\n\\t\\t\\treturn result;\\n```\\n\\n```\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        int flag = 0,l = int(S.length());\\n        string result;\\n        for(int i = 0;i < l;i++){\\n            if(S[i] == \\'(\\'){\\n                flag += 1;\\n                result += flag > 1 ? \"(\" : \"\";\\n            } else {\\n                flag -= 1;\\n                result += flag > 0 ? \")\" : \"\";\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/66145b21-665b-4402-ae74-2c6565dceefe_1606804144.1577873.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nConsider the following test case\\n\\n\\tS = \"(()())(())\"\\n\\t\\t\\n\\t\\t\\t1. S[i] = \"(\"  , flag = 1, result = \"\";\\n\\t\\t\\t2. S[i] = \"(\"  , flag = 2, result = \"(\";\\n\\t\\t\\t3. S[i] = \")\"  , flag = 1, result = \"()\";\\n\\t\\t\\t4. S[i] = \"(\"  , flag = 2, result = \"()(\";\\n\\t\\t\\t5. S[i] = \")\"  , flag = 1, result = \"()()\";\\n\\t\\t\\t6. S[i] = \")\"  , flag = 0, result = \"()()\";\\n\\t\\t\\t7. S[i] = \"(\"  , flag = 1, result = \"()()\";\\n\\t\\t\\t8. S[i] = \"(\"  , flag = 2, result = \"()()(\";\\n\\t\\t\\t9. S[i] = \")\"  , flag = 1, result = \"()()()\";\\n\\t\\t\\t10. S[i] = \")\"  , flag = 0, result = \"()()()\";\\n\\t\\t\\t\\n\\t\\t\\tresult = \"()()()\";\\n\\t\\t\\treturn result;\\n```\n```\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        int flag = 0,l = int(S.length());\\n        string result;\\n        for(int i = 0;i < l;i++){\\n            if(S[i] == \\'(\\'){\\n                flag += 1;\\n                result += flag > 1 ? \"(\" : \"\";\\n            } else {\\n                flag -= 1;\\n                result += flag > 0 ? \")\" : \"\";\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783755,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        \\n    \\tchar [] chars=S.toCharArray();\\n    \\tStringBuilder sb=new  StringBuilder();\\n    \\tStack<Character> st= new Stack<>();\\n    \\tint startindex=0;\\n    \\tfor ( int i=0;i<chars.length;i++ ) {\\n    \\t\\tchar c= chars[i];\\n    \\t\\tif(c==\\'(\\') {\\n    \\t\\t\\tst.push(\\'(\\');\\n    \\t\\t}else if(c==\\')\\') {\\n    \\t\\t\\tst.pop();\\n    \\t\\t}\\n    \\t\\tif(st.isEmpty()) {\\n    \\t\\t\\tsb.append(S.substring((startindex+1),i));\\n    \\t\\t\\tstartindex=i+1;\\n    \\t\\t}\\n    \\t\\t\\n    \\t}\\n    \\t\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        \\n    \\tchar [] chars=S.toCharArray();\\n    \\tStringBuilder sb=new  StringBuilder();\\n    \\tStack<Character> st= new Stack<>();\\n    \\tint startindex=0;\\n    \\tfor ( int i=0;i<chars.length;i++ ) {\\n    \\t\\tchar c= chars[i];\\n    \\t\\tif(c==\\'(\\') {\\n    \\t\\t\\tst.push(\\'(\\');\\n    \\t\\t}else if(c==\\')\\') {\\n    \\t\\t\\tst.pop();\\n    \\t\\t}\\n    \\t\\tif(st.isEmpty()) {\\n    \\t\\t\\tsb.append(S.substring((startindex+1),i));\\n    \\t\\t\\tstartindex=i+1;\\n    \\t\\t}\\n    \\t\\t\\n    \\t}\\n    \\t\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651147,
                "title": "simple-string-operation-no-stacks-used-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        String k=\"\",s=\"\";int c=0,d=0;// c-> to count no. of \\'(\\' and d->no. of \\')\\' \\n        for(int i=0;i<S.length();i++)\\n        {\\n            if(S.charAt(i)==\\'(\\'){\\n            s=s+\\'(\\';\\n                c++;\\n            }\\n            else if(S.charAt(i)==\\')\\')\\n            {\\n                s=s+\\')\\';\\n                d++;\\n            }\\n            if(c==d)// when c==d means one complete bracket series ended....eg: (()()) c==d for this.... \\n            {\\n                k=k+s.substring(1,s.length()-1);// select the string execpt first and last portion 1 -> s.length()-1,which gives ()()\\n                s=\"\";//this for next bracket series\\n                c=d=0;//for next bracket series....\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        String k=\"\",s=\"\";int c=0,d=0;// c-> to count no. of \\'(\\' and d->no. of \\')\\' \\n        for(int i=0;i<S.length();i++)\\n        {\\n            if(S.charAt(i)==\\'(\\'){\\n            s=s+\\'(\\';\\n                c++;\\n            }\\n            else if(S.charAt(i)==\\')\\')\\n            {\\n                s=s+\\')\\';\\n                d++;\\n            }\\n            if(c==d)// when c==d means one complete bracket series ended....eg: (()()) c==d for this.... \\n            {\\n                k=k+s.substring(1,s.length()-1);// select the string execpt first and last portion 1 -> s.length()-1,which gives ()()\\n                s=\"\";//this for next bracket series\\n                c=d=0;//for next bracket series....\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485690,
                "title": "c-solution",
                "content": "```\\nchar * removeOuterParentheses(char * S){\\n    char *str = malloc(sizeof(char) * strlen(S));\\n    int flag = 0,p = 0;\\n    for (int i = 0;i < strlen(S); i++) {\\n        if (S[i]==\\'(\\') {\\n            flag++;\\n            if (flag != 1) {\\n                str[p++] = S[i];\\n            }\\n        }else{\\n            flag--;\\n            if(flag!=0){\\n                str[p++] = S[i];\\n            }\\n        }\\n    }\\n    str[p] = 0;\\n    return str;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nchar * removeOuterParentheses(char * S){\\n    char *str = malloc(sizeof(char) * strlen(S));\\n    int flag = 0,p = 0;\\n    for (int i = 0;i < strlen(S); i++) {\\n        if (S[i]==\\'(\\') {\\n            flag++;\\n            if (flag != 1) {\\n                str[p++] = S[i];\\n            }\\n        }else{\\n            flag--;\\n            if(flag!=0){\\n                str[p++] = S[i];\\n            }\\n        }\\n    }\\n    str[p] = 0;\\n    return str;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 270763,
                "title": "javascript",
                "content": "```\\nvar removeOuterParentheses = function(S) {\\n    let res = \\'\\',\\n        leftNum = 0;\\n    for(let i = 0; i < S.length; ++i) {\\n        if(S.charAt(i) == \\'(\\') {\\n            leftNum ++;\\n            if(leftNum == 2) {\\n                while(leftNum > 0) {\\n                    res += S.charAt(i);\\n                    S.charAt(++i) == \\'(\\' ? leftNum ++ : leftNum --;\\n                    \\n                }\\n            }\\n        } else\\n            leftNum --;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar removeOuterParentheses = function(S) {\\n    let res = \\'\\',\\n        leftNum = 0;\\n    for(let i = 0; i < S.length; ++i) {\\n        if(S.charAt(i) == \\'(\\') {\\n            leftNum ++;\\n            if(leftNum == 2) {\\n                while(leftNum > 0) {\\n                    res += S.charAt(i);\\n                    S.charAt(++i) == \\'(\\' ? leftNum ++ : leftNum --;\\n                    \\n                }\\n            }\\n        } else\\n            leftNum --;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 269958,
                "title": "python-c-haskell-solutions",
                "content": "**Video Explanation:** https://www.youtube.com/watch?v=ekdNNn3vOqQ\\n\\n1. Group by parentheses substring when LEFT = RIGHT\\n2. Then just shave off the first and last parentheses of each group and rejoin\\n\\n**Python Solution 1:**\\n```\\ndef group(S):\\n\\tt, a, l = 0, 0, []\\n    for i in range(len(S)):\\n        t = t + 1 if S[i] == \\'(\\' else t - 1\\n        if t == 0:\\n            l.append(S[a:i+1])\\n            a = i + 1\\n    return l\\n\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        return \\'\\'.join(sub[1:-1] for sub in group(S))\\n```\\n**Python Solution 2 (Functional Programming):**\\n```\\ndef group(S: str) -> str:\\n    a = [1 if i == \\'(\\' else -1 for i in S]    \\n    b = [0] + [i+1 for i, j in enumerate(itertools.accumulate(a)) if j == 0]\\n    return [S[i:j] for i, j in zip(b[:-1], b[1:])]\\n\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        return \\'\\'.join(sub[1:-1] for sub in group(S))\\n```\\n**Haskell:**\\n```\\nremoveOuterParentheses s = concat $ map (tail . init) primitives\\n    where primitives = map (map fst) $ init $ segmentAfter ((==0) . snd) (zip s (parenCount s))\\n          parenCount = scanl1 (+) . map (\\\\e -> if e == \\'(\\' then 1 else -1)\\n```\\n**C++:**\\n```\\nstring removeOuterParentheses(string S) {\\n   vector<int> a(S.size()), b(S.size());\\n   transform(S.begin(), S.end(), a.begin(), [](auto c) { return c == \\'(\\' ? 1 : -1; });\\n   partial_sum(a.begin(), a.end(), b.begin());\\n   return accumulate(b.begin(), b.end(), string(),\\n      [&S, t = string(), i = 0](auto s, auto e) mutable {\\n      e == 0 ? s += t.substr(1, t.size() - 1), t = \"\" : t += S[i]; ++i;\\n      return s;\\n   });\\n}\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\ndef group(S):\\n\\tt, a, l = 0, 0, []\\n    for i in range(len(S)):\\n        t = t + 1 if S[i] == \\'(\\' else t - 1\\n        if t == 0:\\n            l.append(S[a:i+1])\\n            a = i + 1\\n    return l\\n\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        return \\'\\'.join(sub[1:-1] for sub in group(S))\\n```\n```\\ndef group(S: str) -> str:\\n    a = [1 if i == \\'(\\' else -1 for i in S]    \\n    b = [0] + [i+1 for i, j in enumerate(itertools.accumulate(a)) if j == 0]\\n    return [S[i:j] for i, j in zip(b[:-1], b[1:])]\\n\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        return \\'\\'.join(sub[1:-1] for sub in group(S))\\n```\n```\\nremoveOuterParentheses s = concat $ map (tail . init) primitives\\n    where primitives = map (map fst) $ init $ segmentAfter ((==0) . snd) (zip s (parenCount s))\\n          parenCount = scanl1 (+) . map (\\\\e -> if e == \\'(\\' then 1 else -1)\\n```\n```\\nstring removeOuterParentheses(string S) {\\n   vector<int> a(S.size()), b(S.size());\\n   transform(S.begin(), S.end(), a.begin(), [](auto c) { return c == \\'(\\' ? 1 : -1; });\\n   partial_sum(a.begin(), a.end(), b.begin());\\n   return accumulate(b.begin(), b.end(), string(),\\n      [&S, t = string(), i = 0](auto s, auto e) mutable {\\n      e == 0 ? s += t.substr(1, t.size() - 1), t = \"\" : t += S[i]; ++i;\\n      return s;\\n   });\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886659,
                "title": "c-beats-100-with-explaination-o-n-time-o-1-space",
                "content": "# Intuition\\nOpening parenthesis decreases the counter and closing parenthesis increases the counter\\n```\\n   (  (  )  (  ) )  (  (  ) )\\n0 -1 -2 -1 -2 -1 0 -1 -2 -1 0\\n```\\n\\nThere is always a primitive string after a zero till next zero.\\nWe just need to remove first and last character of primitive string.\\n\\nSo the intution is...\\nIf you get c=0 do not take that character and the character next to it.\\n\\n# Approach\\nIf you encounter c=0, it means previous substring was primitive. So the position at which you are currently, must be opening parenthesis. Make c= -1 and continue.\\n```\\n if (c == 0) {\\n        c--;\\n        continue;\\n      }\\n```\\n\\nIf you got Opening parenthesis decreases the counter else for closing parenthesis increases the counter.\\n```\\n      if (s[i] == \\'(\\') c--;\\n      else c++;\\n```\\n\\nIf you got c=0, this is last character of primitive parenthesis. Therefore do not push it into ans str.\\n```\\n      if (c == 0) continue;\\n```\\n\\nElse push it into ans string.\\n```\\n      str.push_back(s[i]);\\n```\\n\\n# Code\\n```\\nclass Solution {\\n  public: string removeOuterParentheses(string s) {\\n    string str;\\n    int c = 0;\\n    for (int i = 0; i < s.size(); i++) {\\n      if (c == 0) {\\n        c--;\\n        continue;\\n      }\\n      if (s[i] == \\'(\\') c--;\\n      else c++;\\n      if (c == 0) continue;\\n      str.push_back(s[i]);\\n    }\\n    return str;\\n  }\\n};\\n```\\n\\n# Complexity\\n```\\n- Time complexity: O(n)\\n```\\n\\n```\\n- Space complexity: O(1)\\n```\\n\\n    if(helpful) Upvote++ ;\\n    \\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D\\n\\n ![image.png](https://assets.leetcode.com/users/images/56a4f661-44cb-4e7b-98be-49a7b8604658_1691592068.1438534.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n   (  (  )  (  ) )  (  (  ) )\\n0 -1 -2 -1 -2 -1 0 -1 -2 -1 0\\n```\n```\\n if (c == 0) {\\n        c--;\\n        continue;\\n      }\\n```\n```\\n      if (s[i] == \\'(\\') c--;\\n      else c++;\\n```\n```\\n      if (c == 0) continue;\\n```\n```\\n      str.push_back(s[i]);\\n```\n```\\nclass Solution {\\n  public: string removeOuterParentheses(string s) {\\n    string str;\\n    int c = 0;\\n    for (int i = 0; i < s.size(); i++) {\\n      if (c == 0) {\\n        c--;\\n        continue;\\n      }\\n      if (s[i] == \\'(\\') c--;\\n      else c++;\\n      if (c == 0) continue;\\n      str.push_back(s[i]);\\n    }\\n    return str;\\n  }\\n};\\n```\n```\\n- Time complexity: O(n)\\n```\n```\\n- Space complexity: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823992,
                "title": "c-solution-explained",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        // to store the ans\\n        string ans = \"\";\\n        // to keep the track of valid parenthesis we have initialized count variable\\n        // valid parenthesis contains equal number of \\n        int count = 0;\\n        for(char ch: s){\\n            if(ch == \\'(\\' && count == 0){\\n                // this bracket is a part of outermost parenthesis\\n                // dont add it to the ans, skip it\\n                count++;\\n            }else if(ch == \\'(\\' && count >= 1){\\n                // this bracket is a part of inner parenthesis\\n                // add it to the ans\\n                ans += ch;\\n                count++;\\n                \\n            }else if(ch == \\')\\' && count > 1){\\n                // this bracket is a part of inner parenthesis\\n                // add it to the ans, and decrease the count\\n                ans += ch;\\n                count--;\\n            }else if(ch == \\')\\' && count == 1){\\n                // this bracket is a part of outer parenthesis\\n                // avoid it\\n                count--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        // to store the ans\\n        string ans = \"\";\\n        // to keep the track of valid parenthesis we have initialized count variable\\n        // valid parenthesis contains equal number of \\n        int count = 0;\\n        for(char ch: s){\\n            if(ch == \\'(\\' && count == 0){\\n                // this bracket is a part of outermost parenthesis\\n                // dont add it to the ans, skip it\\n                count++;\\n            }else if(ch == \\'(\\' && count >= 1){\\n                // this bracket is a part of inner parenthesis\\n                // add it to the ans\\n                ans += ch;\\n                count++;\\n                \\n            }else if(ch == \\')\\' && count > 1){\\n                // this bracket is a part of inner parenthesis\\n                // add it to the ans, and decrease the count\\n                ans += ch;\\n                count--;\\n            }else if(ch == \\')\\' && count == 1){\\n                // this bracket is a part of outer parenthesis\\n                // avoid it\\n                count--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778885,
                "title": "explained-optimized-interview-question-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nitna to samjh aa jaata hai saab, 350 ques karne k baad\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust use the stack \\n\\n# Complexity\\n- Time complexity:\\nO(n), n is size of given string\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//see- https://www.youtube.com/watch?v=MLfAFCkzChU\\n/* algo:\\n   1. check stack empty ? if true then put the 1st char and this will be not ans as it\\'s    outermost.\\n\\n   2. add another cha, check stack is empty or not, if not then it means this char should be in our ans string add it their and then place it inside stack.\\n\\n   3. add another char if it\\'s a closing bracket then remove it\\'s opening bracket from stack and check if stack gets empty after this or not, if yes then it was outermost don\\'t add in ans, if not empty the this can be added to ans string.\\n*/\\n\\n    string removeOuterParentheses(string s) {\\n        stack<char> st;\\n        if(s==\"\" || s==\"()\") return \"\";\\n        string ans=\"\";\\n        int n=s.size();\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(s[i]);\\n                \\n            }\\n            else\\n            {\\n                if(s[i]==\\'(\\')\\n                {\\n                    ans+=s[i];\\n                    st.push(s[i]);\\n                    \\n                }\\n                else\\n                {\\n                    st.pop();\\n                    if(!st.empty()) ans+=s[i];\\n                }\\n            }\\n            i++;\\n        }\\n        return ans;\\n// PLEASE UPVOTE THANK YOU\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//see- https://www.youtube.com/watch?v=MLfAFCkzChU\\n/* algo:\\n   1. check stack empty ? if true then put the 1st char and this will be not ans as it\\'s    outermost.\\n\\n   2. add another cha, check stack is empty or not, if not then it means this char should be in our ans string add it their and then place it inside stack.\\n\\n   3. add another char if it\\'s a closing bracket then remove it\\'s opening bracket from stack and check if stack gets empty after this or not, if yes then it was outermost don\\'t add in ans, if not empty the this can be added to ans string.\\n*/\\n\\n    string removeOuterParentheses(string s) {\\n        stack<char> st;\\n        if(s==\"\" || s==\"()\") return \"\";\\n        string ans=\"\";\\n        int n=s.size();\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(s[i]);\\n                \\n            }\\n            else\\n            {\\n                if(s[i]==\\'(\\')\\n                {\\n                    ans+=s[i];\\n                    st.push(s[i]);\\n                    \\n                }\\n                else\\n                {\\n                    st.pop();\\n                    if(!st.empty()) ans+=s[i];\\n                }\\n            }\\n            i++;\\n        }\\n        return ans;\\n// PLEASE UPVOTE THANK YOU\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752187,
                "title": "easy-way-without-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int cnt = 0;\\n        string res;\\n\\n        for (auto c: s) {\\n            if (cnt == 0 && c == \\'(\\') cnt--;\\n            else if (cnt == -1 && c == \\')\\') cnt++;\\n            else {\\n                res.push_back(c);\\n                if (c == \\'(\\') cnt--;\\n                else cnt++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**compact code**\\n\\n---\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int cnt = 0;\\n        string res;\\n\\n        for (auto c: s) {\\n            if (c == \\'(\\' && cnt++ > 0 ) res.push_back(c);\\n            if (c == \\')\\' && cnt-- > 1 ) res.push_back(c);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int cnt = 0;\\n        string res;\\n\\n        for (auto c: s) {\\n            if (cnt == 0 && c == \\'(\\') cnt--;\\n            else if (cnt == -1 && c == \\')\\') cnt++;\\n            else {\\n                res.push_back(c);\\n                if (c == \\'(\\') cnt--;\\n                else cnt++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int cnt = 0;\\n        string res;\\n\\n        for (auto c: s) {\\n            if (c == \\'(\\' && cnt++ > 0 ) res.push_back(c);\\n            if (c == \\')\\' && cnt-- > 1 ) res.push_back(c);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691237,
                "title": "c-easy-and-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' && st.empty()){\\n                st.push(s[i]);\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(s[i]);\\n                res+=s[i];\\n            }\\n            else{\\n                st.pop();\\n                if(st.size()){\\n                    res+=s[i];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' && st.empty()){\\n                st.push(s[i]);\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(s[i]);\\n                res+=s[i];\\n            }\\n            else{\\n                st.pop();\\n                if(st.size()){\\n                    res+=s[i];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272641,
                "title": "o-n-solution-using-stack-beats-100-c",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n\\n        stack<char> st;\\n        string ans=\"\";\\n\\n        for(auto c: s){\\n\\n            if(!st.empty()) ans+=c;\\n            if(c==\\'(\\') st.push(c);\\n            else {\\n                st.pop();\\n                 if(st.empty()) ans.pop_back();\\n            }\\n           \\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n\\n        stack<char> st;\\n        string ans=\"\";\\n\\n        for(auto c: s){\\n\\n            if(!st.empty()) ans+=c;\\n            if(c==\\'(\\') st.push(c);\\n            else {\\n                st.pop();\\n                 if(st.empty()) ans.pop_back();\\n            }\\n           \\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169732,
                "title": "clean-readable-code-c",
                "content": "# Intuition\\nEasy one-liner in C++\\n\\n# Approach\\nYou don\\'t need Python, when you know C++ like me\\n\\n# Complexity\\n- Time complexity: O(-1)\\n\\n- Space complexity: O(inf)\\n\\n# Code\\n```\\nclass Solution {public:string removeOuterParentheses(string s) {string output;int count = 0;for (auto c : s) {if (c == \\')\\') count--;if (count != 0) output += c;if (c == \\'(\\') count++;}return output;}};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {public:string removeOuterParentheses(string s) {string output;int count = 0;for (auto c : s) {if (c == \\')\\') count--;if (count != 0) output += c;if (c == \\'(\\') count++;}return output;}};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094732,
                "title": "simple-cpp-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) \\n    {\\n        string ans=\"\";\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(st.empty()&&s[i]==\\'(\\')\\n            {\\n                st.push(\\'(\\');\\n            }\\n            else\\n            {\\n                if(st.size()>0 &&s[i]==\\'(\\')\\n                {\\n                    st.push(\\'(\\');\\n                    ans+=\\'(\\';\\n                }\\n                else if(st.size()>1 && s[i]==\\')\\')\\n                {\\n                    st.pop();\\n                    ans+=\\')\\';\\n                }\\n                else\\n                {\\n                    st.pop();\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) \\n    {\\n        string ans=\"\";\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(st.empty()&&s[i]==\\'(\\')\\n            {\\n                st.push(\\'(\\');\\n            }\\n            else\\n            {\\n                if(st.size()>0 &&s[i]==\\'(\\')\\n                {\\n                    st.push(\\'(\\');\\n                    ans+=\\'(\\';\\n                }\\n                else if(st.size()>1 && s[i]==\\')\\')\\n                {\\n                    st.pop();\\n                    ans+=\\')\\';\\n                }\\n                else\\n                {\\n                    st.pop();\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819789,
                "title": "python-96-77-faster-explained-without-stack-o-n-solution",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        c,j,n=0,0,len(s)\\n        ans=[]\\n        for i in range(n):\\n            if s[i]==\\'(\\':\\n                c+=1 #If there is opening paranthesis we increment the counter variable\\n            else:\\n                c-=1 #If there is closing paranthesis we decrement the counter variable\\n#If counter variable is 0 it means that No. of opening paranthesis = No. of closing paranthesis and we get a set of valid parethesis \\n\\t\\t\\t\\tif c==0:\\n#Once we get a valid set of parenthesis we store it in the list where j is the starting index of the valid parenthesis set and i is the last index.\\n#j+1 will remove the opening parenthesis and slicing the string till i(i.e., i-1) will store the valid set of parethesis in list after removing the outermost parenthis\\n                    ans.append(s[j+1:i])\\n                    j=i+1 #Changing the value of starting index for next valid set of parenthesis\\n        return \\'\\'.join(ans) #It will change the list into string\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**\\n            \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        c,j,n=0,0,len(s)\\n        ans=[]\\n        for i in range(n):\\n            if s[i]==\\'(\\':\\n                c+=1 #If there is opening paranthesis we increment the counter variable\\n            else:\\n                c-=1 #If there is closing paranthesis we decrement the counter variable\\n#If counter variable is 0 it means that No. of opening paranthesis = No. of closing paranthesis and we get a set of valid parethesis \\n\\t\\t\\t\\tif c==0:\\n#Once we get a valid set of parenthesis we store it in the list where j is the starting index of the valid parenthesis set and i is the last index.\\n#j+1 will remove the opening parenthesis and slicing the string till i(i.e., i-1) will store the valid set of parethesis in list after removing the outermost parenthis\\n                    ans.append(s[j+1:i])\\n                    j=i+1 #Changing the value of starting index for next valid set of parenthesis\\n        return \\'\\'.join(ans) #It will change the list into string\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518109,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count=0, start=0;\\n        StringBuilder res= new StringBuilder();\\n        \\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==\\'(\\')\\n                count++;\\n            else\\n                count--;\\n\\t\\t\\t\\t\\n            if(count==0){\\n                res.append(s.substring(start+1,i));\\n                start=i+1;\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count=0, start=0;\\n        StringBuilder res= new StringBuilder();\\n        \\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==\\'(\\')\\n                count++;\\n            else\\n                count--;\\n\\t\\t\\t\\t\\n            if(count==0){\\n                res.append(s.substring(start+1,i));\\n                start=i+1;\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361682,
                "title": "java-solution-5-lines-faster-and-less-memory-than-99-example-also-in-c-python",
                "content": "Although this problem is labeled as \\'easy\\' it can seem quite difficult at first, especially due to the way the writeup was written.\\n\\nHere is an advice, which has always helped me break down parenthesis problems. There is something called Catalan structures or Catalan numbers. Now, bear with me! This might seem awfully complicated since Catalan numbers is something abstract and mathematical. But take a look at table 2 on page 2 in this paper:\\n http://www.geometer.org/mathcircles/catalan.pdf\\n\\nSee these \\'Mountain Ranges\\'? These can be thought of as matches. Where you would add an upwards leaning match for an open parenthesis and a downwards leaning match for a closing parenthesis. Here is the important part: A Mountain range like this, where we start at the bottom and end at the bottom is a valid parenthesis.\\n\\nNow, if you draw on a piece of paper the three examples given in the write-up. You can see that the problem is only asking you to remove the lowest level of each \\'mountain\\'. Since that is the case, the only thing we need is a counter while we iterate through the characters forming the parenthesis string. For each level we go up (open parenthesis) we increment the counter while we decrement it while we go down. So you can think of the counter as keeping track of the elevation in the mountain range.\\n\\nNow, what I did in my solution was to initialize a counter and a string builder. Whenever there was an open parenthesis at levels other than zero I added the char to the string builder. Whenever there was a closing parenthesis at a level other than 1, I added the parenthesis to the string builder. This effectively removes the bottom level for each mountain in the mountain range\\n\\nWhy does this work? Try drawing it out!\\n\\n**Java**\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n        for(char c : s.toCharArray())\\n            if      (c == \\'(\\' && count++ != 0) sb.append(c);\\n            else if (c == \\')\\' && count-- != 1) sb.append(c);\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n**c++**\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) \\n        \\n        int count = 0;            // count elevation\\n        char output[s.length()];  // the output string\\n        int head = 0;             // write head of buffer\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            char c = s[i];\\n            if      (c == \\'(\\' && count++ > 0) output[head++] = c;\\n            else if (c == \\')\\' && count-- > 1) output[head++] = c;\\n        }\\n        \\n        // null terminate the string and return\\n        output[head] = 0;\\n        return output;\\n    }\\n};\\n```\\n\\n**Python 3**\\nNote that using an array, keeps the running time linear (amortized) appending strings would result in O(N^2)\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        output = []\\n        count = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                if count > 0: output.append(c)\\n                count += 1\\n            if c == \\')\\':\\n                if count > 1: output.append(c)\\n                count -= 1\\n        return \"\".join(output)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n        for(char c : s.toCharArray())\\n            if      (c == \\'(\\' && count++ != 0) sb.append(c);\\n            else if (c == \\')\\' && count-- != 1) sb.append(c);\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) \\n        \\n        int count = 0;            // count elevation\\n        char output[s.length()];  // the output string\\n        int head = 0;             // write head of buffer\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            char c = s[i];\\n            if      (c == \\'(\\' && count++ > 0) output[head++] = c;\\n            else if (c == \\')\\' && count-- > 1) output[head++] = c;\\n        }\\n        \\n        // null terminate the string and return\\n        output[head] = 0;\\n        return output;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        output = []\\n        count = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                if count > 0: output.append(c)\\n                count += 1\\n            if c == \\')\\':\\n                if count > 1: output.append(c)\\n                count -= 1\\n        return \"\".join(output)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307181,
                "title": "javascript-stack-oriented-solution",
                "content": "var removeOuterParentheses = function(S) {\\n\\n    let stack = [];\\n    let result = \\'\\';\\n    for (const s of S) {\\n       if( s === \\'(\\') {\\n           if (stack.length) {\\n               result+=s;\\n           }\\n           stack.push(s);\\n       } else {\\n           stack.pop();\\n           if (stack.length) {\\n               result+=s;\\n           }\\n       }\\n    }\\n\\n    return result;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var removeOuterParentheses = function(S) {\\n\\n    let stack = [];\\n    let result = \\'\\';\\n    for (const s of S) {\\n       if( s === \\'(\\') {\\n           if (stack.length) {\\n               result+=s;\\n           }\\n           stack.push(s);\\n       } else {\\n           stack.pop();\\n           if (stack.length) {\\n               result+=s;\\n           }\\n       }\\n    }\\n\\n    return result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1045167,
                "title": "simple-go-and-java-solutions",
                "content": "Java:\\n\\n```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder s = new StringBuilder();\\n\\tStack<Character> h = new Stack<>();\\n\\n\\tfor (int i = 0; i < S.length(); i++) {\\n\\t\\tif (h.size() == 1 && S.charAt(i) == \\')\\'){\\n\\t\\t\\th.pop();\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\telse if (h.size() == 0 && S.charAt(i) == \\'(\\'){\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\')\\'){\\n\\t\\t\\ts.append(\")\");\\n\\t\\t\\th.pop();\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\'(\\'){\\n\\t\\t\\ts.append(\"(\");\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t}\\n\\treturn s.toString();\\n}\\n```\\n\\nGolang:\\n\\n```\\nfunc removeOuterParentheses(S string) string {\\n\\ts := \"\"\\n\\th := []string{}\\n\\n\\tfor _, i2 := range S {\\n\\t\\tif string(i2) == \"(\" {\\n\\t\\t\\tif len(h) != 0 {\\n\\t\\t\\t\\ts += \"(\"\\n\\t\\t\\t}\\n\\t\\t\\th = append(h, \"(\")\\n\\t\\t} else {\\n\\t\\t\\tif len(h) != 1 {\\n\\t\\t\\t\\ts += \")\"\\n\\t\\t\\t}\\n\\t\\t\\th = h[:len(h)-1]\\n\\t\\t}\\n\\t}\\n\\treturn s\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Go"
                ],
                "code": "```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder s = new StringBuilder();\\n\\tStack<Character> h = new Stack<>();\\n\\n\\tfor (int i = 0; i < S.length(); i++) {\\n\\t\\tif (h.size() == 1 && S.charAt(i) == \\')\\'){\\n\\t\\t\\th.pop();\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\telse if (h.size() == 0 && S.charAt(i) == \\'(\\'){\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\')\\'){\\n\\t\\t\\ts.append(\")\");\\n\\t\\t\\th.pop();\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\'(\\'){\\n\\t\\t\\ts.append(\"(\");\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t}\\n\\treturn s.toString();\\n}\\n```\n```\\nfunc removeOuterParentheses(S string) string {\\n\\ts := \"\"\\n\\th := []string{}\\n\\n\\tfor _, i2 := range S {\\n\\t\\tif string(i2) == \"(\" {\\n\\t\\t\\tif len(h) != 0 {\\n\\t\\t\\t\\ts += \"(\"\\n\\t\\t\\t}\\n\\t\\t\\th = append(h, \"(\")\\n\\t\\t} else {\\n\\t\\t\\tif len(h) != 1 {\\n\\t\\t\\t\\ts += \")\"\\n\\t\\t\\t}\\n\\t\\t\\th = h[:len(h)-1]\\n\\t\\t}\\n\\t}\\n\\treturn s\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 967051,
                "title": "java-solution-with-stack-and-explanation",
                "content": "This works because if the parentheses is outer most and it is a closing parenthese then the size of the stack has to be equal to one. If the parenthese is opening then the size should be 0. Other wise they are inear parentheses.\\n```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder s = new StringBuilder();\\n\\tStack<Character> h = new Stack<>();\\n\\n\\tfor (int i = 0; i < S.length(); i++) {\\n\\t\\tif (h.size() == 1 && S.charAt(i) == \\')\\'){\\n\\t\\t\\th.pop();\\n\\t\\t}\\n\\t\\telse if (h.size() == 0 && S.charAt(i) == \\'(\\'){\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\')\\'){\\n\\t\\t\\ts.append(\")\");\\n\\t\\t\\th.pop();\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\'(\\'){\\n\\t\\t\\ts.append(\"(\");\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t}\\n\\treturn s.toString();\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder s = new StringBuilder();\\n\\tStack<Character> h = new Stack<>();\\n\\n\\tfor (int i = 0; i < S.length(); i++) {\\n\\t\\tif (h.size() == 1 && S.charAt(i) == \\')\\'){\\n\\t\\t\\th.pop();\\n\\t\\t}\\n\\t\\telse if (h.size() == 0 && S.charAt(i) == \\'(\\'){\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\')\\'){\\n\\t\\t\\ts.append(\")\");\\n\\t\\t\\th.pop();\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\'(\\'){\\n\\t\\t\\ts.append(\"(\");\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t}\\n\\treturn s.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935016,
                "title": "easy-way-explanation-every-step",
                "content": "# if your current char is \\'(\\' then two things happen one is stack is empty then don\\'t add char in result means it indicates no outer parentheses is present.if your stack is not empty then definitely have a outer parentheses this time add char into results\\n```\\nif c == \\'(\\':\\n                if stack:\\n                    res.append(c)\\n                stack.append(c)\\n\\n```\\n# when current char is \")\" and popfrom a stack \"(\" .two things happen if your stack is empty it means no outer parentheses.if not empty then outer parentheses is present.so add into result .\\n```\\nelse:\\n                stack.pop()\\n                if stack:\\n                    res.append(c)\\n```\\n# Easy example\\n```\\nYour input\\n\"()()()()\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= )  stack=  [\\'(\\']\\nresult= \\n\\nposition= 2  current char= (  stack=  []\\nresult= \\n\\nposition= 3  current char= )  stack=  [\\'(\\']\\nresult= \\n\\nposition= 4  current char= (  stack=  []\\nresult= \\n\\nposition= 5  current char= )  stack=  [\\'(\\']\\nresult= \\n\\nposition= 6  current char= (  stack=  []\\nresult= \\n\\nposition= 7  current char= )  stack=  [\\'(\\']\\nresult= \\n\\n\\nOutput\\n\"\"\\n\\n\\n```\\n# simple Example\\n```\\nYour input\\n\"(())\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= (  stack=  [\\'(\\']\\nresult= (\\n\\nposition= 2  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()\\n\\nposition= 3  current char= )  stack=  [\\'(\\']\\nresult= ()\\n\\n\\nOutput\\n\"()\"\\nExpected\\n\"()\"\\n```\\n# hard example\\n```\\n\"(((())))\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= (  stack=  [\\'(\\']\\nresult= (\\n\\nposition= 2  current char= (  stack=  [\\'(\\', \\'(\\']\\nresult= ((\\n\\nposition= 3  current char= (  stack=  [\\'(\\', \\'(\\', \\'(\\']\\nresult= (((\\n\\nposition= 4  current char= )  stack=  [\\'(\\', \\'(\\', \\'(\\', \\'(\\']\\nresult= ((()\\n\\nposition= 5  current char= )  stack=  [\\'(\\', \\'(\\', \\'(\\']\\nresult= ((())\\n\\nposition= 6  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ((()))\\n\\nposition= 7  current char= )  stack=  [\\'(\\']\\nresult= ((()))\\n\\n\\nOutput\\n\"((()))\"\\nExpected\\n\"((()))\"\\n```\\n# complex example\\n```\\nYour input\\n\"(()())(())\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= (  stack=  [\\'(\\']\\nresult= (\\n\\nposition= 2  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()\\n\\nposition= 3  current char= (  stack=  [\\'(\\']\\nresult= ()(\\n\\nposition= 4  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()()\\n\\nposition= 5  current char= )  stack=  [\\'(\\']\\nresult= ()()\\nposition= 6  current char= (  stack=  []\\nresult= ()()\\n\\nposition= 7  current char= (  stack=  [\\'(\\']\\nresult= ()()(\\n\\nposition= 8  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()()()\\n\\nposition= 9  current char= )  stack=  [\\'(\\']\\nresult= ()()()\\n\\nOutput\\n\"()()()\"\\nExpected\\n\"()()()\"\\n\\n```\\n\\n```\\n\\nclass Solution(object):\\n    def removeOuterParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        res,stack = [],[]\\n        for i,c in enumerate (S):\\n            \\n            if c == \\'(\\':\\n                if stack:\\n                    res.append(c)\\n                stack.append(c)\\n            else:\\n                stack.pop()\\n                if stack:\\n                    res.append(c)\\n           \\n        return \\'\\'.join(res)\\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nif c == \\'(\\':\\n                if stack:\\n                    res.append(c)\\n                stack.append(c)\\n\\n```\n```\\nelse:\\n                stack.pop()\\n                if stack:\\n                    res.append(c)\\n```\n```\\nYour input\\n\"()()()()\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= )  stack=  [\\'(\\']\\nresult= \\n\\nposition= 2  current char= (  stack=  []\\nresult= \\n\\nposition= 3  current char= )  stack=  [\\'(\\']\\nresult= \\n\\nposition= 4  current char= (  stack=  []\\nresult= \\n\\nposition= 5  current char= )  stack=  [\\'(\\']\\nresult= \\n\\nposition= 6  current char= (  stack=  []\\nresult= \\n\\nposition= 7  current char= )  stack=  [\\'(\\']\\nresult= \\n\\n\\nOutput\\n\"\"\\n\\n\\n```\n```\\nYour input\\n\"(())\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= (  stack=  [\\'(\\']\\nresult= (\\n\\nposition= 2  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()\\n\\nposition= 3  current char= )  stack=  [\\'(\\']\\nresult= ()\\n\\n\\nOutput\\n\"()\"\\nExpected\\n\"()\"\\n```\n```\\n\"(((())))\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= (  stack=  [\\'(\\']\\nresult= (\\n\\nposition= 2  current char= (  stack=  [\\'(\\', \\'(\\']\\nresult= ((\\n\\nposition= 3  current char= (  stack=  [\\'(\\', \\'(\\', \\'(\\']\\nresult= (((\\n\\nposition= 4  current char= )  stack=  [\\'(\\', \\'(\\', \\'(\\', \\'(\\']\\nresult= ((()\\n\\nposition= 5  current char= )  stack=  [\\'(\\', \\'(\\', \\'(\\']\\nresult= ((())\\n\\nposition= 6  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ((()))\\n\\nposition= 7  current char= )  stack=  [\\'(\\']\\nresult= ((()))\\n\\n\\nOutput\\n\"((()))\"\\nExpected\\n\"((()))\"\\n```\n```\\nYour input\\n\"(()())(())\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= (  stack=  [\\'(\\']\\nresult= (\\n\\nposition= 2  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()\\n\\nposition= 3  current char= (  stack=  [\\'(\\']\\nresult= ()(\\n\\nposition= 4  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()()\\n\\nposition= 5  current char= )  stack=  [\\'(\\']\\nresult= ()()\\nposition= 6  current char= (  stack=  []\\nresult= ()()\\n\\nposition= 7  current char= (  stack=  [\\'(\\']\\nresult= ()()(\\n\\nposition= 8  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()()()\\n\\nposition= 9  current char= )  stack=  [\\'(\\']\\nresult= ()()()\\n\\nOutput\\n\"()()()\"\\nExpected\\n\"()()()\"\\n\\n```\n```\\n\\nclass Solution(object):\\n    def removeOuterParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        res,stack = [],[]\\n        for i,c in enumerate (S):\\n            \\n            if c == \\'(\\':\\n                if stack:\\n                    res.append(c)\\n                stack.append(c)\\n            else:\\n                stack.pop()\\n                if stack:\\n                    res.append(c)\\n           \\n        return \\'\\'.join(res)\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 570594,
                "title": "concept-of-these-kind-of-problems-simple",
                "content": "problem similar to Google Hashcode 2020 Qualification round\\nThe key in these types of problems is to have a variable named depth, and increment and decrement it accordingly [ \\'(\\' depth increases ] \\nHere whenver the depth is currently zero we ignore it, and when it is again going to be zero after a series of open and closing parenthesis we ignore it again. \\n\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        int depth=0;\\n        string p;\\n        for(int i=0;i<S.length();i++){\\n            if (S[i]==\\'(\\') {\\n\\t\\t\\t\\tif (depth!=0){\\n                    p+=\\'(\\';\\n\\t\\t\\t\\t}\\n                depth+=1;\\n\\t\\t\\t}\\n            if (S[i]==\\')\\'){\\n\\t\\t\\t\\tif (depth-1!=0){\\n                    p+=\\')\\';\\n\\t\\t\\t\\t}\\n                depth-=1;\\n\\t\\t\\t}    \\n        }\\n        return p;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        int depth=0;\\n        string p;\\n        for(int i=0;i<S.length();i++){\\n            if (S[i]==\\'(\\') {\\n\\t\\t\\t\\tif (depth!=0){\\n                    p+=\\'(\\';\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 483874,
                "title": "c-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char> ss;\\n        string ans = \"\";\\n        \\n        for(char c: S) {\\n            if(ss.empty() && c==\\'(\\') {\\n                ss.push(c);\\n            } else if(ss.size() == 1 && c==\\')\\') {\\n                ss.pop();\\n            } else if(c==\\'(\\') {\\n                ss.push(c);\\n                ans+=c;\\n            } else if(c==\\')\\') {\\n                ss.pop();\\n                ans+=c;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char> ss;\\n        string ans = \"\";\\n        \\n        for(char c: S) {\\n            if(ss.empty() && c==\\'(\\') {\\n                ss.push(c);\\n            } else if(ss.size() == 1 && c==\\')\\') {\\n                ss.pop();\\n            } else if(c==\\'(\\') {\\n                ss.push(c);\\n                ans+=c;\\n            } else if(c==\\')\\') {\\n                ss.pop();\\n                ans+=c;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467915,
                "title": "c",
                "content": "```\\npublic string RemoveOuterParentheses(string S) {\\n\\tvar str = new StringBuilder();\\n\\tvar i = 0;\\n\\n\\tforeach (var c in S.ToCharArray()) {\\n\\t\\ti += c == \\'(\\' ? 1 : -1;\\n\\n\\t\\tif (c == \\'(\\' && i > 1 || c == \\')\\' && i > 0)\\n\\t\\t\\tstr.Append(c);\\n\\t}\\n\\n\\treturn str.ToString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic string RemoveOuterParentheses(string S) {\\n\\tvar str = new StringBuilder();\\n\\tvar i = 0;\\n\\n\\tforeach (var c in S.ToCharArray()) {\\n\\t\\ti += c == \\'(\\' ? 1 : -1;\\n\\n\\t\\tif (c == \\'(\\' && i > 1 || c == \\')\\' && i > 0)\\n\\t\\t\\tstr.Append(c);\\n\\t}\\n\\n\\treturn str.ToString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 358034,
                "title": "haskell-wins-1-liner",
                "content": "This is why Haskell is so beautiful:\\n```\\nsolve :: String -> String\\nsolve = concat \\n      . map (tail . init) \\n      . groupBy (\\\\a b -> [a,b] /= \")(\")\\n```\\nThe one-liner would be:\\n```\\nsolve = concat . map (tail . init) . groupBy (\\\\a b -> [a,b] /= \")(\")\\n```",
                "solutionTags": [],
                "code": "```\\nsolve :: String -> String\\nsolve = concat \\n      . map (tail . init) \\n      . groupBy (\\\\a b -> [a,b] /= \")(\")\\n```\n```\\nsolve = concat . map (tail . init) . groupBy (\\\\a b -> [a,b] /= \")(\")\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324746,
                "title": "python3-40ms-beas-93",
                "content": "time complexity : O(n)\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        if len(S) <= 2:\\n            return \"\"\\n        \\n        ans = \"\"\\n        count = 0\\n        for c in S:\\n            if c == \"(\":\\n                count += 1\\n                if count > 1:\\n                    ans += c\\n            else:\\n                count -= 1\\n                if count > 0:\\n                    ans += c\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        if len(S) <= 2:\\n            return \"\"\\n        \\n        ans = \"\"\\n        count = 0\\n        for c in S:\\n            if c == \"(\":\\n                count += 1\\n                if count > 1:\\n                    ans += c\\n            else:\\n                count -= 1\\n                if count > 0:\\n                    ans += c\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316971,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        if(S == null) return \"\";\\n        char[] chars = S.toCharArray();\\n        int stack = 0;\\n\\n        StringBuilder builder = new StringBuilder();\\n        for(int i=0; i<chars.length; i++){\\n            if (chars[i] == 40) {\\n                stack ++;\\n                if(stack != 1) builder.append(chars[i]);\\n            } else if (chars[i] == 41) {\\n                stack --;\\n                if(stack != 0) builder.append(chars[i]);\\n            }\\n        }\\n\\n        return builder.toString();\\n    }\\n}\\n```\\n\\n\\nI use an \\u201Cint stack\\u201D to simulate the use of the stack.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        if(S == null) return \"\";\\n        char[] chars = S.toCharArray();\\n        int stack = 0;\\n\\n        StringBuilder builder = new StringBuilder();\\n        for(int i=0; i<chars.length; i++){\\n            if (chars[i] == 40) {\\n                stack ++;\\n                if(stack != 1) builder.append(chars[i]);\\n            } else if (chars[i] == 41) {\\n                stack --;\\n                if(stack != 0) builder.append(chars[i]);\\n            }\\n        }\\n\\n        return builder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658776,
                "title": "c-2-solutions-using-stack-i-without-stack",
                "content": "\\n# Code\\n```\\n# WITHOUTSTACK\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans=\"\";\\n        int open=0;\\n        for(int i=0;i<s.size();i++){\\n        if(s[i] == \\'(\\'){\\n            if(open>0)\\n            ans+=\\'(\\';\\n             open++;\\n        }\\n\\n        if(s[i] == \\')\\'){\\n            if(open>1){\\n                ans+=\\')\\';\\n            }\\n        open--;\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\n# STACK\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans=\"\";\\n        stack<char>st;\\n        for(int i=0;i<s.size();i++){\\n        if(s[i] == \\'(\\'){\\n            if(st.size()>0)\\n            ans+=\\'(\\';\\n             st.push(\\'(\\');\\n        }\\n\\n        if(s[i] == \\')\\'){\\n                if(st.size() > 1){\\n                    ans+=\\')\\';\\n                }\\n            st.pop();\\n\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n# WITHOUTSTACK\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans=\"\";\\n        int open=0;\\n        for(int i=0;i<s.size();i++){\\n        if(s[i] == \\'(\\'){\\n            if(open>0)\\n            ans+=\\'(\\';\\n             open++;\\n        }\\n\\n        if(s[i] == \\')\\'){\\n            if(open>1){\\n                ans+=\\')\\';\\n            }\\n        open--;\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478488,
                "title": "python-simple-clean-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        ans, cnt = [], 0\\n        for ch in s:\\n            if ch == \\'(\\' and cnt > 0: ans.append(ch)\\n            if ch == \\')\\' and cnt > 1: ans.append(ch)\\n            cnt += 1 if ch == \\'(\\' else -1\\n        return \"\".join(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        ans, cnt = [], 0\\n        for ch in s:\\n            if ch == \\'(\\' and cnt > 0: ans.append(ch)\\n            if ch == \\')\\' and cnt > 1: ans.append(ch)\\n            cnt += 1 if ch == \\'(\\' else -1\\n        return \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444614,
                "title": "easily-understandable-java-stack-without-stack-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n         StringBuilder sb = new StringBuilder();\\n\\n//               STACK SOLUTION\\n\\n        //  Stack<Character> st = new Stack<>();\\n        //  for(int i=0;i<s.length();i++){\\n        //      char ch = s.charAt(i);\\n        //      if(ch == \\'(\\'){\\n        //          if(!st.isEmpty()){\\n        //              sb.append(ch);\\n        //          }\\n        //          st.push(ch);                  \\n        //      }else{\\n        //          st.pop();\\n        //          if(!st.isEmpty()){\\n        //              sb.append(ch);\\n        //          }\\n        //      }\\n        //  }\\n        // return sb.toString();\\n             \\n         int con=0;\\n         for(char c:s.toCharArray()){\\n             if(c==\\'(\\' && con++>0 )sb.append(c);\\n             if(c==\\')\\' && con-->1 )sb.append(c);\\n         }\\n         return sb.toString();\\n    }\\n}\\n/*  \\n-->Solve without using stack:\\nKeep a counter c = 0\\nIncrement when ( found and decrement when ) found\\nif c = 1 means ( is outer most, don\\'t add it to answer\\nif c = 0 means ) is outer most, don\\'t add it to answer\\nelse keep adding parenthesis to answer\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n         StringBuilder sb = new StringBuilder();\\n\\n//               STACK SOLUTION\\n\\n        //  Stack<Character> st = new Stack<>();\\n        //  for(int i=0;i<s.length();i++){\\n        //      char ch = s.charAt(i);\\n        //      if(ch == \\'(\\'){\\n        //          if(!st.isEmpty()){\\n        //              sb.append(ch);\\n        //          }\\n        //          st.push(ch);                  \\n        //      }else{\\n        //          st.pop();\\n        //          if(!st.isEmpty()){\\n        //              sb.append(ch);\\n        //          }\\n        //      }\\n        //  }\\n        // return sb.toString();\\n             \\n         int con=0;\\n         for(char c:s.toCharArray()){\\n             if(c==\\'(\\' && con++>0 )sb.append(c);\\n             if(c==\\')\\' && con-->1 )sb.append(c);\\n         }\\n         return sb.toString();\\n    }\\n}\\n/*  \\n-->Solve without using stack:\\nKeep a counter c = 0\\nIncrement when ( found and decrement when ) found\\nif c = 1 means ( is outer most, don\\'t add it to answer\\nif c = 0 means ) is outer most, don\\'t add it to answer\\nelse keep adding parenthesis to answer\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401631,
                "title": "go-golang-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc removeOuterParentheses(s string) string {\\n    var result string\\n    var index int\\n\\n    for _, x := range s {\\n        switch x {\\n        case \\'(\\':\\n            if index > 0 {\\n                result += string(x)\\n            }\\n            index++\\n        case \\')\\':\\n            index--\\n            if index > 0 {\\n                result += string(x)\\n            }\\n        }\\n    }\\n\\n    return result\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Array"
                ],
                "code": "```\\nfunc removeOuterParentheses(s string) string {\\n    var result string\\n    var index int\\n\\n    for _, x := range s {\\n        switch x {\\n        case \\'(\\':\\n            if index > 0 {\\n                result += string(x)\\n            }\\n            index++\\n        case \\')\\':\\n            index--\\n            if index > 0 {\\n                result += string(x)\\n            }\\n        }\\n    }\\n\\n    return result\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3352798,
                "title": "c-0ms-solution",
                "content": "Time Complexity: O(n)\\nSpace Complexity: O(n)\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int sum = 1;\\n        string ans = \"\";\\n        // \"we will count the opening and closing bracket\"\\n        int open = 1;\\n        int end = 0;\\n        for(int i = 1; i<s.size(); i++){\\n            if(s[i] == \\'(\\'){\\n                open++;\\n            }else{\\n                end++;\\n            }\\n            if(s[i] == \\')\\' && open == end ){\\n                open = 0;\\n                end = 0;\\n            }else if(open > 1){\\n                ans += s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int sum = 1;\\n        string ans = \"\";\\n        // \"we will count the opening and closing bracket\"\\n        int open = 1;\\n        int end = 0;\\n        for(int i = 1; i<s.size(); i++){\\n            if(s[i] == \\'(\\'){\\n                open++;\\n            }else{\\n                end++;\\n            }\\n            if(s[i] == \\')\\' && open == end ){\\n                open = 0;\\n                end = 0;\\n            }else if(open > 1){\\n                ans += s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109543,
                "title": "easy-c-without-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n   int n=s.size();\\n   string p;\\n   int c=0;\\n   for(int i=0;i<n;i++)\\n   {\\n       if(s[i]==\\'(\\')\\n       {c++;}\\n       else if(s[i]==\\')\\')\\n       {c--;}\\n        if( c!=1 && s[i]==\\'(\\')\\n        {p+=s[i];}\\n        else if(c!=0 && s[i]==\\')\\')\\n        {\\n            p+=s[i];\\n        }\\n   }\\n   return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n   int n=s.size();\\n   string p;\\n   int c=0;\\n   for(int i=0;i<n;i++)\\n   {\\n       if(s[i]==\\'(\\')\\n       {c++;}\\n       else if(s[i]==\\')\\')\\n       {c--;}\\n        if( c!=1 && s[i]==\\'(\\')\\n        {p+=s[i];}\\n        else if(c!=0 && s[i]==\\')\\')\\n        {\\n            p+=s[i];\\n        }\\n   }\\n   return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953073,
                "title": "without-stack-c-simple-100-fastest",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n![Capture.PNG](https://assets.leetcode.com/users/images/65e175ad-14eb-4977-863f-c412c1d53620_1672049199.2318532.png)\\n\\n# Approach \\n    Keep a counter c = 0\\n    Increment when ( found \\n    decrement when ) found\\n    if c = 1 &&  ( is outer most, don\\'t add it to answer\\n    if c = 0 && ) is outer most, don\\'t add it to answer\\n    else keep adding parenthesis to answer\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        if(s.length()==0) return \"\";\\n        if(s.length()==2) return \"\";\\n        string ans=\"\";\\n        stack<char>st;\\n        int counter=0;\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s[i]==\\'(\\') counter++;\\n            else if(s[i]==\\')\\') counter--;\\n            if(s[i]==\\'(\\' && counter!=1) ans+=s[i];\\n            else if(s[i]==\\')\\' && counter!=0) ans+=s[i];\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        if(s.length()==0) return \"\";\\n        if(s.length()==2) return \"\";\\n        string ans=\"\";\\n        stack<char>st;\\n        int counter=0;\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s[i]==\\'(\\') counter++;\\n            else if(s[i]==\\')\\') counter--;\\n            if(s[i]==\\'(\\' && counter!=1) ans+=s[i];\\n            else if(s[i]==\\')\\' && counter!=0) ans+=s[i];\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837110,
                "title": "c-faster-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string res=\"\";\\n        stack<char> st;\\n        int i=0;\\n        while(i<s.size()){\\n            char ch = s[i];\\n            if(ch ==\\'(\\'){\\n                if(st.size()>0)\\n                res += ch;\\n                st.push(ch);\\n            }\\n            else{\\n                if(st.size()>1){\\n                    res +=\\')\\';\\n                }\\n                st.pop();\\n            }\\n          \\n\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string res=\"\";\\n        stack<char> st;\\n        int i=0;\\n        while(i<s.size()){\\n            char ch = s[i];\\n            if(ch ==\\'(\\'){\\n                if(st.size()>0)\\n                res += ch;\\n                st.push(ch);\\n            }\\n            else{\\n                if(st.size()>1){\\n                    res +=\\')\\';\\n                }\\n                st.pop();\\n            }\\n          \\n\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846566,
                "title": "javascript-easy-stepwise",
                "content": "\\n    let count = 0, outer = \"\"\\n    \\n    for(let i = 0 ; i < s.length; i++) {\\n        if(s[i] === \"(\") {\\n            count++\\n        }\\n         if(count > 1) {\\n            outer += s[i]\\n        }\\n        if(s[i] === \")\") {\\n            count--\\n        }\\n    }\\n    return outer\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n    let count = 0, outer = \"\"\\n    \\n    for(let i = 0 ; i < s.length; i++) {\\n        if(s[i] === \"(\") {\\n            count++\\n        }\\n         if(count > 1) {\\n            outer += s[i]\\n        }\\n        if(s[i] === \")\") {\\n            count--\\n        }\\n    }\\n    return outer\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1804384,
                "title": "without-stack-simple-solution-c",
                "content": "**My Approach**\\n\\nMaintain  a counter that counts the incoming open parenthesis \\'(\\'  \\nif count is 0 then we ignore it o/w add it to o/p string \\nsimilar case is for closing parenthesis :\\nif count is 0 we ignore o/w add it to the o/p string.\\n\\n**Time Complexity : O(N)**\\n\\nCode :\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans=\"\";\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\' && count++)\\n                ans+=\"(\";\\n            else if(s[i]==\\')\\'&& (--count))\\n                ans+=\")\";\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Please Upvote \\uD83D\\uDC4D\\uD83C\\uDFFB and Spread Motivation !!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans=\"\";\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\' && count++)\\n                ans+=\"(\";\\n            else if(s[i]==\\')\\'&& (--count))\\n                ans+=\")\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637392,
                "title": "python-idea-of-stack",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        stack = 0\\n        start = 0\\n        answer = \\'\\'\\n\\n        for i,j in enumerate(s):\\n            if j == \"(\":\\n                stack+= 1\\n            elif j == \")\":\\n                stack -= 1\\n            if stack == 0:\\n                answer += s[start+1:i:]\\n                start = i+1\\n\\n        return answer\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        stack = 0\\n        start = 0\\n        answer = \\'\\'\\n\\n        for i,j in enumerate(s):\\n            if j == \"(\":\\n                stack+= 1\\n            elif j == \")\":\\n                stack -= 1\\n            if stack == 0:\\n                answer += s[start+1:i:]\\n                start = i+1\\n\\n        return answer\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1425905,
                "title": "clean-solution-using-stack",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        ans = \"\"\\n        stack = []\\n        \\n        for br in s:\\n            if br == \\'(\\':\\n                if stack:\\n                    ans+=br\\n                stack.append(br)\\n            else:\\n                ch = stack.pop()\\n                if stack:\\n                    ans+=br\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        ans = \"\"\\n        stack = []\\n        \\n        for br in s:\\n            if br == \\'(\\':\\n                if stack:\\n                    ans+=br\\n                stack.append(br)\\n            else:\\n                ch = stack.pop()\\n                if stack:\\n                    ans+=br\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1381567,
                "title": "c-tc-o-n-sc-o-n",
                "content": "**Feel free to post your doubts in comment**\\n```\\nstring removeOuterParentheses(string s) {\\n        int n=s.size();\\n        string ans=\"\";\\n        int co=0, cc=0;\\n        int start=0;\\n        for(int i=0; i<n; i++){\\n            if(s[i]==\\'(\\') co++;\\n            else cc++;\\n            if(co==cc){\\n                for(int j=start+1; j<i; j++)\\n                    ans+=s[j];\\n                start=i+1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring removeOuterParentheses(string s) {\\n        int n=s.size();\\n        string ans=\"\";\\n        int co=0, cc=0;\\n        int start=0;\\n        for(int i=0; i<n; i++){\\n            if(s[i]==\\'(\\') co++;\\n            else cc++;\\n            if(co==cc){\\n                for(int j=start+1; j<i; j++)\\n                    ans+=s[j];\\n                start=i+1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1374386,
                "title": "be-water-my-friend-time-o-n-no-substring-function-c",
                "content": "*Runtime: 0 ms, faster than 100.00% of C++ online submissions for Remove Outermost Parentheses.*\\n\\nJust keep incrementing and decrementing number of open bracket and take decisions.\\n\\n1st Decision: The current character will be part of the result if you have seen at least 1 opening bracket.\\n2nd Decision: As we are first decrementing we have to handle the last valid closing bracket explicitely.\\n\\nThat\\'s it.\\nStraightforward.\\n\\n```\\nstring removeOuterParentheses(string str) {\\n    int open = 0;\\n    string result = \"\";\\n    for (auto bracket : str) {\\n        bracket == \\'(\\' ? ++open : --open;\\n        if (open > 1 || (open == 1 && bracket == \\')\\')) {\\n            result += bracket;\\n        }\\n    }\\n    return result;\\n}\\n```\\n\\nIf you are having problem understanding do one dry run on your own\\n\\n**My Dry Run**\\n**str = ( ( ) ) ( )**\\n\\nstrSeen = ( \\nresult = \"\"\\nopen = 1\\n\\nstrSeen = ( (\\nresult = \"(\"\\nopen = 2\\n\\nstrSeen = ( ( ) \\nresult = \"()\"\\nopen = 1\\n\\nstrSeen = ( ( ) )\\nresult = \"()\"\\nopen = 0\\n\\nstrSeen = ( ( ) ) (\\nresult = \"()\"\\nopen = 1\\n\\nstrSeen = ( ( ) ) ( )\\nresult = \"()\"\\nopen = 0",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring removeOuterParentheses(string str) {\\n    int open = 0;\\n    string result = \"\";\\n    for (auto bracket : str) {\\n        bracket == \\'(\\' ? ++open : --open;\\n        if (open > 1 || (open == 1 && bracket == \\')\\')) {\\n            result += bracket;\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1059557,
                "title": "cpp-use-counter-to-record-the-unmatched-pairs",
                "content": "## Analysis\\n\\nIn order to identify which parenthesis to be included inside our return string, we need to check two cases:\\n\\n1. If current **open parenthesis** is the first parenthesis in the block of the decomposition, we should not add it. This means the current **unmatched pairs** in block is 1.\\n2. If current **close parenthesis** is the last parenthesis in the block of the decomposition, we should not add it. This means the current **unmatched pairs** in block is 0.\\n\\nLet\\'s walk through an example:\\n\\nThe left most column represents the current processing parthesis\\n\\n```\\nFor \"(()(()))\":\\n(    (|()(())): we have 1 unmatched pair -> \"\" don\\'t do anything here\\n(    ((|)(())): we have 2 unmatched pair -> \"(\"\\n)    (()|(())): we have 1 unmatched pair -> \"()\"\\n(    (()(|())): we have 2 unmatched pair -> \"()(\"\\n(    (()((|))): we have 3 unmatched pair -> \"()((\"\\n)    (()(()|)): we have 2 unmatched pair -> \"()(()\"\\n)    (()(())|): we have 1 unmatched pair -> \"()(())\"\\n)    (()(()))|: we have 0 unmatched pair -> \"()(())\" don\\'t do anything here\\n```\\n\\nFrom this example, we can see that all we need is to count the number of unmatched pairs as well as the current processing parenthesis.\\n\\nTime: $O(n)$\\n\\nSpace: $O(1)$\\n\\n## Code\\n\\n```c++\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string res;\\n        int cnt = 0;\\n        for (char& c : S) {\\n            if (c == \\'(\\' && ++cnt != 1)\\n                res += c;\\n            if (c == \\')\\' && --cnt != 0)\\n                res += c;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nNote that since the input is always valid (no mismatch), we can just use != instead of >= to check the unmatched pairs.\\n\\nThis analysis is included in: https://peterchen.xyz/Leetcode/1021.-Remove-Outermost-Parentheses/\\nIf you want to check my other analysis, please visit https://peterchen.xyz/\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nFor \"(()(()))\":\\n(    (|()(())): we have 1 unmatched pair -> \"\" don\\'t do anything here\\n(    ((|)(())): we have 2 unmatched pair -> \"(\"\\n)    (()|(())): we have 1 unmatched pair -> \"()\"\\n(    (()(|())): we have 2 unmatched pair -> \"()(\"\\n(    (()((|))): we have 3 unmatched pair -> \"()((\"\\n)    (()(()|)): we have 2 unmatched pair -> \"()(()\"\\n)    (()(())|): we have 1 unmatched pair -> \"()(())\"\\n)    (()(()))|: we have 0 unmatched pair -> \"()(())\" don\\'t do anything here\\n```\n```c++\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string res;\\n        int cnt = 0;\\n        for (char& c : S) {\\n            if (c == \\'(\\' && ++cnt != 1)\\n                res += c;\\n            if (c == \\')\\' && --cnt != 0)\\n                res += c;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053939,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        int leftBracket = 0;\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(char currChar:S.toCharArray())\\n        {\\n            if(currChar==\\'(\\')\\n            {\\n                if(leftBracket!=0)\\n                {\\n                    sb.append(currChar);\\n                }\\n                leftBracket++;\\n            }\\n            else\\n            {\\n                leftBracket--;\\n                if(leftBracket!=0)\\n                {\\n                    sb.append(currChar);\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        int leftBracket = 0;\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(char currChar:S.toCharArray())\\n        {\\n            if(currChar==\\'(\\')\\n            {\\n                if(leftBracket!=0)\\n                {\\n                    sb.append(currChar);\\n                }\\n                leftBracket++;\\n            }\\n            else\\n            {\\n                leftBracket--;\\n                if(leftBracket!=0)\\n                {\\n                    sb.append(currChar);\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 615583,
                "title": "python-3-easy-solution-with-explanation-20ms-99-95-speed",
                "content": "maintain a pointer variable to point which index you encountered, if the value of the variable is 0, you\\'re pointing to the opening of the outer braces, then you don\\'t append it to the result. \\nEach time we encounter a left brace we increment the value of ptr by 1, for a right brace we decrement it by 1. I\\'ll just explain this segment: \"(()())\" \\nnow look:\\n( => ptr = 0, don\\'t append to res; increment it and you get ptr = 1\\n( => ptr = 1, append to res; increment it and you get ptr = 2, \\n) => ptr = 2, decrement it and you get ptr = 1, append to res\\n( => ptr = 1, append to res; increment it and you get ptr = 2, \\n) => ptr = 2,  decrement it and you get ptr = 1, append to res\\n) => ptr = 1,  decrement it and you get ptr = 0, don\\'t append to res\\nthus you proceed\\n\\n```\\ndef removeOuterParentheses(self, S: str) -> str:\\n        res = \"\"\\n        ptr = 0\\n        for c in S:\\n            if c==\\')\\':\\n                ptr-=1\\n            if ptr:\\n                res+=c\\n            if c==\\'(\\': \\n                ptr+=1\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef removeOuterParentheses(self, S: str) -> str:\\n        res = \"\"\\n        ptr = 0\\n        for c in S:\\n            if c==\\')\\':\\n                ptr-=1\\n            if ptr:\\n                res+=c\\n            if c==\\'(\\': \\n                ptr+=1\\n            \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 584245,
                "title": "stack-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char>s;\\n        vector<int>partitions;\\n        for(int i=0;i<S.length();i++){\\n            if(S[i]==\\'(\\') s.push(S[i]);\\n            else {\\n                s.pop();\\n                if(s.empty()) partitions.push_back(i);\\n            }\\n        }\\n        int start = 1;\\n        string ans = \"\";\\n        for(int i=0;i<partitions.size();i++){\\n            string yo = S.substr(start,partitions[i]-start);\\n            ans += yo;\\n            start = partitions[i]+2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char>s;\\n        vector<int>partitions;\\n        for(int i=0;i<S.length();i++){\\n            if(S[i]==\\'(\\') s.push(S[i]);\\n            else {\\n                s.pop();\\n                if(s.empty()) partitions.push_back(i);\\n            }\\n        }\\n        int start = 1;\\n        string ans = \"\";\\n        for(int i=0;i<partitions.size();i++){\\n            string yo = S.substr(start,partitions[i]-start);\\n            ans += yo;\\n            start = partitions[i]+2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513253,
                "title": "python-o-n-time-o-1-space",
                "content": "Somewhat counter intuitive, but hey it works\\n```python\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        \\n        parentheses = 0 \\n        result = \"\"\\n        for c in S:\\n            if(c == \"(\"):\\n                parentheses += 1\\n            \\n            if(parentheses > 1):\\n                result += c\\n            \\n            if(c == \")\"):\\n                parentheses -= 1\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        \\n        parentheses = 0 \\n        result = \"\"\\n        for c in S:\\n            if(c == \"(\"):\\n                parentheses += 1\\n            \\n            if(parentheses > 1):\\n                result += c\\n            \\n            if(c == \")\"):\\n                parentheses -= 1\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504575,
                "title": "python-simple-solution",
                "content": "```\\n\\n```#40 ms, faster than 42.94% of Python3 online submissions for Remove Outermost Parentheses.\\n#12.9 MB, less than 100.00% of Python3 online submissions for Remove Outermost Parentheses.\\n\\nclass Solution:\\n\\tdef removeOuterParentheses(self, S: str) -> str:\\n        stacks = []\\n        result = \\'\\'\\n        for ch in S:\\n            stacks.append(ch)\\n            if (stacks.count(\\'(\\') == stacks.count(\\')\\')):\\n                result += (\\'\\'.join(stacks[1:-1]))\\n                stacks.clear()\\n        return (result)\\n",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 459604,
                "title": "java-very-easy-solution",
                "content": "Use the depth of parentheses.\\n\\n```java\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder result = new StringBuilder();\\n        int depth = 0;\\n\\n        for (Character character : S.toCharArray()) {\\n            if (character == \\'(\\') {\\n                depth += 1;\\n            }\\n\\n            if (depth > 1) {\\n                result.append(character);\\n            }\\n\\n            if (character == \\')\\') {\\n                depth -= 1;\\n            }\\n        }\\n\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder result = new StringBuilder();\\n        int depth = 0;\\n\\n        for (Character character : S.toCharArray()) {\\n            if (character == \\'(\\') {\\n                depth += 1;\\n            }\\n\\n            if (depth > 1) {\\n                result.append(character);\\n            }\\n\\n            if (character == \\')\\') {\\n                depth -= 1;\\n            }\\n        }\\n\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416446,
                "title": "java-stack-solution",
                "content": "\\t\\t public String removeOuterParentheses(String S) {\\n\\t\\t\\tStack<Character> stack = new Stack<>();\\n\\t        stack.push(S.charAt(0));\\n\\t\\t\\t\\t   String ans = \"\";\\n\\t\\t\\t\\t   for(int i=1;i<S.length();i++) {\\n\\t\\t\\t\\tif(S.charAt(i) == \\'(\\' && stack.isEmpty()) {\\n\\t\\t\\t\\t\\tstack.push(S.charAt(i));\\n\\t\\t\\t\\t} else if(S.charAt(i) == \\'(\\') {\\n\\t\\t\\t\\tstack.push(S.charAt(i));\\n\\t\\t\\t\\tans+=S.charAt(i);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\t\\tif(!stack.isEmpty())\\n\\t\\t\\t\\t\\tans+=S.charAt(i);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}",
                "solutionTags": [],
                "code": "\\t\\t public String removeOuterParentheses(String S) {\\n\\t\\t\\tStack<Character> stack = new Stack<>();\\n\\t        stack.push(S.charAt(0));\\n\\t\\t\\t\\t   String ans = \"\";\\n\\t\\t\\t\\t   for(int i=1;i<S.length();i++) {\\n\\t\\t\\t\\tif(S.charAt(i) == \\'(\\' && stack.isEmpty()) {\\n\\t\\t\\t\\t\\tstack.push(S.charAt(i));\\n\\t\\t\\t\\t} else if(S.charAt(i) == \\'(\\') {\\n\\t\\t\\t\\tstack.push(S.charAt(i));\\n\\t\\t\\t\\tans+=S.charAt(i);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\t\\tif(!stack.isEmpty())\\n\\t\\t\\t\\t\\tans+=S.charAt(i);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 371270,
                "title": "java-100-runtime-and-memory-9-lines",
                "content": "```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder SB = new StringBuilder();\\n\\tint currDepth = 0;\\n\\tfor(char curr : S.toCharArray()) {\\n\\t\\tif(curr == \\'(\\' && (currDepth += 1) > 1) SB.append(curr);\\n\\t\\telse if (curr == \\')\\' && (currDepth -= 1) >= 1) SB.append(curr);\\n\\t}\\n\\treturn SB.toString();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder SB = new StringBuilder();\\n\\tint currDepth = 0;\\n\\tfor(char curr : S.toCharArray()) {\\n\\t\\tif(curr == \\'(\\' && (currDepth += 1) > 1) SB.append(curr);\\n\\t\\telse if (curr == \\')\\' && (currDepth -= 1) >= 1) SB.append(curr);\\n\\t}\\n\\treturn SB.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 306738,
                "title": "easy-python-solution-using-stack",
                "content": "```\\n# Main idea is to use stack, we push the character to stack and pop when stack is not empty and character is \\')\\'\\n# If there is only one character \\'(\\' and the current character in string is \\')\\', then pop the stack and append the substring : S[j+1:i] to result and update\\n# j to i+1\\n# Return result string\\n\\nclass Solution(object):\\n    def removeOuterParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        res,j = \"\",0\\n        my_stack = []\\n        for i in range(len(S)):\\n            if my_stack and S[i]==\\')\\':\\n                if len(my_stack)==1:\\n                    my_stack.pop() \\n                    res+=S[j+1:i] #To ignore first character which is \\'(\\' in order to remove-outermost-parentheses\\n                    j=i+1\\n                else:\\n                    my_stack.pop()\\n            else:\\n                my_stack.append(S[i])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\n# Main idea is to use stack, we push the character to stack and pop when stack is not empty and character is \\')\\'\\n# If there is only one character \\'(\\' and the current character in string is \\')\\', then pop the stack and append the substring : S[j+1:i] to result and update\\n# j to i+1\\n# Return result string\\n\\nclass Solution(object):\\n    def removeOuterParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        res,j = \"\",0\\n        my_stack = []\\n        for i in range(len(S)):\\n            if my_stack and S[i]==\\')\\':\\n                if len(my_stack)==1:\\n                    my_stack.pop() \\n                    res+=S[j+1:i] #To ignore first character which is \\'(\\' in order to remove-outermost-parentheses\\n                    j=i+1\\n                else:\\n                    my_stack.pop()\\n            else:\\n                my_stack.append(S[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281068,
                "title": "python-beats-95-of-the-solutions",
                "content": "Python Solution \\n\\n```\\nclass Solution(object):\\n    def removeOuterParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        count = 0 \\n        output_S = []\\n        for c in S:\\n            if c == \\')\\':\\n                count -= 1\\n            \\n            if count > 0:\\n                output_S.append(c)\\n            \\n            if c == \\'(\\':\\n                count += 1\\n        \\n        return \\'\\'.join(output_S)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeOuterParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        count = 0 \\n        output_S = []\\n        for c in S:\\n            if c == \\')\\':\\n                count -= 1\\n            \\n            if count > 0:\\n                output_S.append(c)\\n            \\n            if c == \\'(\\':\\n                count += 1\\n        \\n        return \\'\\'.join(output_S)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270143,
                "title": "c-solution-using-one-stack-and-one-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char> open;\\n        queue<char> primitive;\\n        string output;\\n        for(int i=0; i<S.length(); i++) {\\n            primitive.push(S[i]);\\n            if(S[i] == \\'(\\') {\\n                open.push(S[i]);\\n            }\\n            else {\\n                open.pop();\\n                if(open.empty()) {\\n                    primitive.pop();\\n                    while(!primitive.empty()) {\\n                        output.push_back(primitive.front());\\n                        primitive.pop();\\n                    }\\n                    output.pop_back();\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```\\n\\nStack stores the opening brackets. Once the stack is empty, we found one primitive. Primitives are stored in queue. We remove the outer brackets and store in output.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char> open;\\n        queue<char> primitive;\\n        string output;\\n        for(int i=0; i<S.length(); i++) {\\n            primitive.push(S[i]);\\n            if(S[i] == \\'(\\') {\\n                open.push(S[i]);\\n            }\\n            else {\\n                open.pop();\\n                if(open.empty()) {\\n                    primitive.pop();\\n                    while(!primitive.empty()) {\\n                        output.push_back(primitive.front());\\n                        primitive.pop();\\n                    }\\n                    output.pop_back();\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 269960,
                "title": "python-straightforward-concise-valid-paranthesis",
                "content": "* Check valid paranthesis as usual.\\n* When it is balanced, add to res.\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        l = r = 0\\n        res = cur = \\'\\'\\n        for s in S:\\n            cur += s\\n            l += s == \\'(\\'\\n            r += s == \\')\\'\\n            if l == r:\\n                res += cur[1:-1]\\n                cur = \\'\\'\\n        return res \\n```\\n\\nTime complexity: O(N)\\nSpace complexity: O(N)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        l = r = 0\\n        res = cur = \\'\\'\\n        for s in S:\\n            cur += s\\n            l += s == \\'(\\'\\n            r += s == \\')\\'\\n            if l == r:\\n                res += cur[1:-1]\\n                cur = \\'\\'\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 269955,
                "title": "simple-python-counter",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        result = []\\n        counter = 1\\n        i = 1\\n        while i < len(S):\\n            counter += 1 if S[i] == \"(\" else -1\\n            if counter != 0:\\n                result.append(S[i])\\n            else:\\n                counter = 1\\n                i += 1\\n            i += 1\\n        return \"\".join(result)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        result = []\\n        counter = 1\\n        i = 1\\n        while i < len(S):\\n            counter += 1 if S[i] == \"(\" else -1\\n            if counter != 0:\\n                result.append(S[i])\\n            else:\\n                counter = 1\\n                i += 1\\n            i += 1\\n        return \"\".join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 269954,
                "title": "my-8-lines-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string res = \"\";\\n        int cnt = 0, start = 0, n = S.size();\\n        for (int i = 0; i < n; ++i) {\\n            (S[i] == \\'(\\') ? ++cnt : --cnt;\\n            if (cnt != 0) continue;\\n            res += S.substr(start + 1, i - start - 1);\\n            start = i + 1;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string res = \"\";\\n        int cnt = 0, start = 0, n = S.size();\\n        for (int i = 0; i < n; ++i) {\\n            (S[i] == \\'(\\') ? ++cnt : --cnt;\\n            if (cnt != 0) continue;\\n            res += S.substr(start + 1, i - start - 1);\\n            start = i + 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4008513,
                "title": "js-simple-beats-95-easy-approach",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeOuterParentheses = function (s) {\\n    let openCount = 0;\\n    let output = \"\";\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \"(\") {\\n            if (openCount) output += s[i];\\n            openCount++;\\n        }\\n        else if (s[i] === \")\") {\\n            openCount--;\\n            if (openCount) output += s[i];\\n        }\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeOuterParentheses = function (s) {\\n    let openCount = 0;\\n    let output = \"\";\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \"(\") {\\n            if (openCount) output += s[i];\\n            openCount++;\\n        }\\n        else if (s[i] === \")\") {\\n            openCount--;\\n            if (openCount) output += s[i];\\n        }\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3816879,
                "title": "single-pass-c-solution-without-extra-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string a=\"\";\\n        int balanced=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                if(balanced>0)\\n                {\\n                    a+=s[i];\\n                }\\n                balanced++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                balanced--;\\n                if(balanced>0)\\n                {\\n                    a+=s[i];\\n                }\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string a=\"\";\\n        int balanced=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                if(balanced>0)\\n                {\\n                    a+=s[i];\\n                }\\n                balanced++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                balanced--;\\n                if(balanced>0)\\n                {\\n                    a+=s[i];\\n                }\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804317,
                "title": "c-o-n-tc-o-1-sc",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        //keeping track of opened\\n        //opened --> represent no. of opened without closed \\n        //\"(()())(())\"\\n        // \"((\" --> opened=2; \\n        // \"(()\"  --> opened=1; \\n        string ans;\\n        int opened=0;\\n        for(auto i:s){\\n            if(i==\\'(\\' && opened++>0)    ans+=i;\\n            if(i==\\')\\' && opened-->1)    ans+=i;    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        //keeping track of opened\\n        //opened --> represent no. of opened without closed \\n        //\"(()())(())\"\\n        // \"((\" --> opened=2; \\n        // \"(()\"  --> opened=1; \\n        string ans;\\n        int opened=0;\\n        for(auto i:s){\\n            if(i==\\'(\\' && opened++>0)    ans+=i;\\n            if(i==\\')\\' && opened-->1)    ans+=i;    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711986,
                "title": "c-easy-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int n=s.length();\\n        string ans;\\n        int count=0;\\n        int j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                if(count==0)count++;\\n                else\\n                {\\n                    count++;\\n                    ans.push_back(s[i]);\\n                }\\n            }\\n            else\\n            {\\n                if(count==1)\\n                {\\n                    count--;\\n                }\\n                else\\n                {\\n                    count--;\\n                    ans.push_back(s[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int n=s.length();\\n        string ans;\\n        int count=0;\\n        int j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                if(count==0)count++;\\n                else\\n                {\\n                    count++;\\n                    ans.push_back(s[i]);\\n                }\\n            }\\n            else\\n            {\\n                if(count==1)\\n                {\\n                    count--;\\n                }\\n                else\\n                {\\n                    count--;\\n                    ans.push_back(s[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585998,
                "title": "problem-1021-remove-outer-parentheses-solwed-with-stack-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public string RemoveOuterParentheses(string s) {\\n        var stk = new Stack<char>();\\n        var qavslar = \"\";\\n        foreach (char c in s)\\n        {\\n            if(c == \\'(\\') stk.Push(c);\\n            if(stk.Count > 1) qavslar += c;\\n            if(c == \\')\\') stk.Pop();\\n        }\\n        return qavslar;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string RemoveOuterParentheses(string s) {\\n        var stk = new Stack<char>();\\n        var qavslar = \"\";\\n        foreach (char c in s)\\n        {\\n            if(c == \\'(\\') stk.Push(c);\\n            if(stk.Count > 1) qavslar += c;\\n            if(c == \\')\\') stk.Pop();\\n        }\\n        return qavslar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487236,
                "title": "stack-c-beats-90",
                "content": "# Code\\n```\\nusing System.Text;\\n\\npublic class Solution \\n{\\n    public string RemoveOuterParentheses(string s) \\n    {\\n        Stack<char> stack = new Stack<char>();\\n        StringBuilder ans = new(\"\");\\n\\n        foreach (char c in s.ToCharArray())\\n        {\\n            if (c is \\'(\\')\\n            {\\n                if (stack.Count > 0)\\n                {\\n                    ans.Append(\\'(\\');\\n                }\\n\\n                stack.Push(c);\\n            }\\n            else\\n            {\\n                if (stack.Count > 1)\\n                {\\n                    ans.Append(\\')\\');\\n\\n                }\\n\\n                stack.Pop();\\n            }\\n        }\\n\\n        return ans.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nusing System.Text;\\n\\npublic class Solution \\n{\\n    public string RemoveOuterParentheses(string s) \\n    {\\n        Stack<char> stack = new Stack<char>();\\n        StringBuilder ans = new(\"\");\\n\\n        foreach (char c in s.ToCharArray())\\n        {\\n            if (c is \\'(\\')\\n            {\\n                if (stack.Count > 0)\\n                {\\n                    ans.Append(\\'(\\');\\n                }\\n\\n                stack.Push(c);\\n            }\\n            else\\n            {\\n                if (stack.Count > 1)\\n                {\\n                    ans.Append(\\')\\');\\n\\n                }\\n\\n                stack.Pop();\\n            }\\n        }\\n\\n        return ans.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477847,
                "title": "simplest-method-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string str;\\n        int cnt = 0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                cnt++;\\n            }\\n            else\\n            {\\n                cnt--;\\n            }\\n            if((s[i]==\\'(\\' && cnt==1) || (s[i]==\\')\\'&& cnt==0))\\n            {\\n                continue;\\n            }\\n            str.push_back(s[i]);\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string str;\\n        int cnt = 0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                cnt++;\\n            }\\n            else\\n            {\\n                cnt--;\\n            }\\n            if((s[i]==\\'(\\' && cnt==1) || (s[i]==\\')\\'&& cnt==0))\\n            {\\n                continue;\\n            }\\n            str.push_back(s[i]);\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411357,
                "title": "c-without-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int st=0;\\n        string ans;\\n        for(auto a: s)\\n        {\\n            if(a == \\'(\\')\\n            {\\n                if(st>0)\\n                {\\n                    ans+=\\'(\\';\\n                }\\n                st++;\\n            }\\n            else\\n            {\\n                if(st>1)\\n                {\\n                    ans+=\\')\\';\\n                }\\n                st--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int st=0;\\n        string ans;\\n        for(auto a: s)\\n        {\\n            if(a == \\'(\\')\\n            {\\n                if(st>0)\\n                {\\n                    ans+=\\'(\\';\\n                }\\n                st++;\\n            }\\n            else\\n            {\\n                if(st>1)\\n                {\\n                    ans+=\\')\\';\\n                }\\n                st--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392528,
                "title": "one-pass-o-1-space-simplest-just-count-parenthesis",
                "content": "If you find this solution helpful, **Upvote**. \\uD83D\\uDC4D \\n\\n```\\n  string removeOuterParentheses(string s) {\\n     int count=0;\\n     int j=0;\\n     for(int i=0;i<s.size();i++){   \\n        \\n         if(s[i]==\\'(\\')count++;\\n         if(s[i]==\\')\\')count--;\\n         if(s[i]==\\')\\' and count==0){\\n\\t\\t \\n             s.erase(i,1);         //rightmost parenthesis.\\n             s.erase(j,1);        //leftmost parenthesis.\\n             i=i-2;                //adjusting i after deletion\\n             j=i+1;                //intializing starting parenthesis\\n\\t\\t\\t \\n         }      \\n     }\\n        return s;\\n    }",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "If you find this solution helpful, **Upvote**. \\uD83D\\uDC4D \\n\\n```\\n  string removeOuterParentheses(string s) {\\n     int count=0;\\n     int j=0;\\n     for(int i=0;i<s.size();i++){   \\n        \\n         if(s[i]==\\'(\\')count++;\\n         if(s[i]==\\')\\')count--;\\n         if(s[i]==\\')\\' and count==0){\\n\\t\\t \\n             s.erase(i,1);         //rightmost parenthesis.\\n             s.erase(j,1);        //leftmost parenthesis.\\n             i=i-2;                //adjusting i after deletion\\n             j=i+1;                //intializing starting parenthesis\\n\\t\\t\\t \\n         }      \\n     }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3181745,
                "title": "c-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n     stack<char> a;\\n     string q;\\n     for(int i=0;i<s.length();i++){\\n         if(s[i]==\\'(\\'){\\n             if(a.size()>0){\\n             q.push_back(s[i]);\\n             }\\n             a.push(s[i]);\\n         }\\n         else{\\n             a.pop();\\n             if(!a.empty())\\n             q.push_back(s[i]);\\n         }\\n     \\n     } \\n     return q;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n     stack<char> a;\\n     string q;\\n     for(int i=0;i<s.length();i++){\\n         if(s[i]==\\'(\\'){\\n             if(a.size()>0){\\n             q.push_back(s[i]);\\n             }\\n             a.push(s[i]);\\n         }\\n         else{\\n             a.pop();\\n             if(!a.empty())\\n             q.push_back(s[i]);\\n         }\\n     \\n     } \\n     return q;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181729,
                "title": "easiest-c-code-using-for-loop-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int n=s.size();\\n        int c=0;\\n        string str=\"\";\\n        for(int i=0;i<n;i++){\\n                if(s[i]==\\'(\\'){\\n                    if(c>0){ str+=s[i];}\\n                    c++;\\n                    }\\n                else{\\n                    if(c>1){ str+=s[i];}\\n                    c--;\\n                    }\\n            }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int n=s.size();\\n        int c=0;\\n        string str=\"\";\\n        for(int i=0;i<n;i++){\\n                if(s[i]==\\'(\\'){\\n                    if(c>0){ str+=s[i];}\\n                    c++;\\n                    }\\n                else{\\n                    if(c>1){ str+=s[i];}\\n                    c--;\\n                    }\\n            }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181672,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> tem;\\n        string re;\\n        for(int i=0; i<s.length(); i++){\\n           if(s[i]==\\'(\\'){\\n               if(tem.size()>0) re.push_back(s[i]);\\n               tem.push(s[i]);\\n           }\\n           else{\\n               tem.pop();\\n               if(!tem.empty()) re.push_back(s[i]);\\n           }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> tem;\\n        string re;\\n        for(int i=0; i<s.length(); i++){\\n           if(s[i]==\\'(\\'){\\n               if(tem.size()>0) re.push_back(s[i]);\\n               tem.push(s[i]);\\n           }\\n           else{\\n               tem.pop();\\n               if(!tem.empty()) re.push_back(s[i]);\\n           }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140108,
                "title": "java-optimal-approach-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int counter = 0;\\n\\n        for(char c : s.toCharArray()){\\n            if(c == \\'(\\'){\\n                if(counter != 0) sb.append(c);\\n                counter++;\\n            }\\n            else{\\n                counter--;\\n                if(counter != 0) sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int counter = 0;\\n\\n        for(char c : s.toCharArray()){\\n            if(c == \\'(\\'){\\n                if(counter != 0) sb.append(c);\\n                counter++;\\n            }\\n            else{\\n                counter--;\\n                if(counter != 0) sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059333,
                "title": "c-no-extra-space",
                "content": "\\n\\n### Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int last = s.size() - 1, balanced = 0;\\n        for(int i = last; i >= 0; i--) {            \\n            if(s[i] == \\')\\') balanced++;\\n            else {\\n                balanced--;\\n                if(balanced == 0) {\\n                    s.erase(last,1);\\n                    s.erase(i, 1);\\n                    last = i - 1;\\n                }\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int last = s.size() - 1, balanced = 0;\\n        for(int i = last; i >= 0; i--) {            \\n            if(s[i] == \\')\\') balanced++;\\n            else {\\n                balanced--;\\n                if(balanced == 0) {\\n                    s.erase(last,1);\\n                    s.erase(i, 1);\\n                    last = i - 1;\\n                }\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862199,
                "title": "golang-efficient-two-pointers-solution-using-strings-builder-o-n-time-o-n-memory",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we only have one type of parentheses and the input sequence is guaranteed to be valid, let\\'s use a counter (called \"balance\" in my code) instead of a stack. As we iterate through the input string and get \\'(\\', then we increment by balance 1 and decrement it by 1 in case we get \\')\\'.\\nWhen the balance becomes equal to zero, we are sure that we got a perfectly valid parentheses string.\\n\\nLet\\'s use two pointers to know where the valid \"atomic\" parentheses sequence starts and ends. Lets call these pointers \"slow\" and \"fast\".\\n\\nFirst we suppose that the input string contains at least two parentheses, so we could place the pointers separately. Then we move the fast pointer and update the balance variable based on the value where the fast pointer is at.\\n\\nWhen the balance becomes equal to 0, we just need to remove the outer brackets. We go through the non-inclusive interval (slow, fast) with a new pointer and add all the parentheses to the answer variable.\\n\\nBecause of immutability of strings, it\\'s inefficient to use the sum operation to concatenate strings in a loop. Instead we use the [strings.Builder](https://pkg.go.dev/strings#Builder) type, which is used to efficiently build strings using several Write methods, as it minimizes memory copying.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe loop through the input string and then loop through the every valid segment we encounter. Basically, it\\'s $O(2n)$ in the worst case.\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe linear memory is used only to construct the answer storing it inside strings.Builder.\\n\\n# Code\\n```\\nimport (\\n    \"strings\"\\n)\\n\\nfunc removeOuterParentheses(s string) string {\\n    if s == \"\" {\\n        return \"\"\\n    }\\n\\n    var sb strings.Builder\\n\\n    slow := 0\\n    balance := 1 // assuming that the first character of the string is always (\\n    for fast := 1; fast < len(s); fast++ {\\n        if s[fast] == \\'(\\' {\\n            balance++\\n        } else if s[fast] == \\')\\' {\\n            balance--\\n        }\\n\\n        if balance == 0 {\\n            for c := slow + 1; c < fast; c++ {\\n                sb.WriteByte(s[c])\\n            }\\n\\n            slow = fast + 1\\n            fast++\\n            balance = 1\\n        }\\n    }\\n\\n    return sb.String()\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nimport (\\n    \"strings\"\\n)\\n\\nfunc removeOuterParentheses(s string) string {\\n    if s == \"\" {\\n        return \"\"\\n    }\\n\\n    var sb strings.Builder\\n\\n    slow := 0\\n    balance := 1 // assuming that the first character of the string is always (\\n    for fast := 1; fast < len(s); fast++ {\\n        if s[fast] == \\'(\\' {\\n            balance++\\n        } else if s[fast] == \\')\\' {\\n            balance--\\n        }\\n\\n        if balance == 0 {\\n            for c := slow + 1; c < fast; c++ {\\n                sb.WriteByte(s[c])\\n            }\\n\\n            slow = fast + 1\\n            fast++\\n            balance = 1\\n        }\\n    }\\n\\n    return sb.String()\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2800575,
                "title": "easy-python3-solution-using-two-pointer-concept",
                "content": "Approach:\\nUsing Two pointers concept we can remove the outer most parentheses by keep tracking the count of opening and closing parentheses.\\n```\\ndef removeOuterParentheses(self, s: str) -> str:\\n\\ti=j=1\\n\\tn = len(s)\\n\\topening_count = 1\\n\\tclosing_count = 0\\n\\tresult = \"\"\\n\\twhile j<n: \\n\\t\\tif  opening_count != closing_count:\\n\\t\\t\\tif s[j] == \"(\":\\n\\t\\t\\t\\topening_count +=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tclosing_count +=1\\n\\t\\t\\tj +=1\\n\\t\\t\\tif j ==n and  opening_count == closing_count :\\n\\t\\t\\t\\tresult += s[i:j-1]\\n\\t\\telse:\\n\\t\\t\\tresult += s[i:j-1]\\n\\t\\t\\tj += 1\\n\\t\\t\\ti = j\\n\\t\\t\\topening_count = 1\\n\\t\\t\\tclosing_count = 0\\n\\treturn result",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "Approach:\\nUsing Two pointers concept we can remove the outer most parentheses by keep tracking the count of opening and closing parentheses.\\n```\\ndef removeOuterParentheses(self, s: str) -> str:\\n\\ti=j=1\\n\\tn = len(s)\\n\\topening_count = 1\\n\\tclosing_count = 0\\n\\tresult = \"\"\\n\\twhile j<n: \\n\\t\\tif  opening_count != closing_count:\\n\\t\\t\\tif s[j] == \"(\":\\n\\t\\t\\t\\topening_count +=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tclosing_count +=1\\n\\t\\t\\tj +=1\\n\\t\\t\\tif j ==n and  opening_count == closing_count :\\n\\t\\t\\t\\tresult += s[i:j-1]\\n\\t\\telse:\\n\\t\\t\\tresult += s[i:j-1]\\n\\t\\t\\tj += 1\\n\\t\\t\\ti = j\\n\\t\\t\\topening_count = 1\\n\\t\\t\\tclosing_count = 0\\n\\treturn result",
                "codeTag": "Python3"
            },
            {
                "id": 2667158,
                "title": "java-without-using-stack",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int n=s.length();\\n        int a=0;\\n        String str=\"\";\\n        for(int i=0;i<n;i++){\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\'){\\n                if(a!=0){\\n                    str=str+ch;\\n                }\\n                a++;\\n            }\\n            else{\\n                if(a!=1){\\n                    str=str+ch;\\n                }\\n                a--;\\n            }\\n        }\\n        \\n       return str;\\n      \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String removeOuterParentheses(String s) {\\n        int n=s.length();\\n        int a=0;\\n        String str=\"\";\\n        for(int i=0;i<n;i++){\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\'){\\n                if(a!=0){\\n                    str=str+ch;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2654107,
                "title": "c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n       stack<int> st;\\n       string ans = \"\";\\n        int start = 0 ;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           if(s[i] == \\'(\\') st.push(s[i]) , ans.push_back(s[i]);\\n           else if(s[i] == \\')\\') st.pop() , ans.push_back(s[i]);\\n           \\n           if(st.empty())\\n           {\\n               ans.pop_back();\\n               ans.erase(start,1);\\n               start = ans.length();\\n           }\\n       }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n       stack<int> st;\\n       string ans = \"\";\\n        int start = 0 ;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           if(s[i] == \\'(\\') st.push(s[i]) , ans.push_back(s[i]);\\n           else if(s[i] == \\')\\') st.pop() , ans.push_back(s[i]);\\n           \\n           if(st.empty())\\n           {\\n               ans.pop_back();\\n               ans.erase(start,1);\\n               start = ans.length();\\n           }\\n       }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557192,
                "title": "js-with-explanation-easy-to-understand-63ms",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/09/1021-remove-outermost-parentheses-stack.html\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeOuterParentheses = function(s) {\\n    let result = [];\\n    let stack = new Stack()\\n    for(let i=0;i<s.length;i++){\\n        let char  = s[i];\\n         if (stack.isEmpty()){\\n             if (char==\\'(\\'){\\n                 stack.push(\\'(\\');\\n             }\\n         }else {\\n            if(char == \\')\\' && stack.size() == 1){\\n                stack.pop();\\n            }else{\\n                result.push(char);\\n                if(char == \\'(\\'){\\n                   stack.push(char);\\n                }else{\\n                    stack.pop()\\n                }\\n            }\\n         }\\n    }\\n    return result.join(\"\");\\n};\\n\\nclass Stack {\\n    constructor() {\\n        this.stack = []\\n    }\\n    push(a) {\\n        this.stack.push(a)\\n    }\\n    pop() {\\n        return this.stack.pop()\\n    }\\n    peek() {\\n        return this.stack[this.stack.length - 1]\\n    }\\n    size() {\\n        return this.stack.length\\n    }\\n    toString(){\\n      return this.stack.join(\"\");  \\n    }\\n    isEmpty() {\\n        return this.stack.length == 0\\n    }\\n}\\n```\\n\\n```\\nRuntime: 63 ms, faster than 97.88% of JavaScript online submissions for Remove Outermost Parentheses.\\nMemory Usage: 43.7 MB, less than 68.18% of JavaScript online submissions for Remove Outermost Parentheses.\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Stack"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeOuterParentheses = function(s) {\\n    let result = [];\\n    let stack = new Stack()\\n    for(let i=0;i<s.length;i++){\\n        let char  = s[i];\\n         if (stack.isEmpty()){\\n             if (char==\\'(\\'){\\n                 stack.push(\\'(\\');\\n             }\\n         }else {\\n            if(char == \\')\\' && stack.size() == 1){\\n                stack.pop();\\n            }else{\\n                result.push(char);\\n                if(char == \\'(\\'){\\n                   stack.push(char);\\n                }else{\\n                    stack.pop()\\n                }\\n            }\\n         }\\n    }\\n    return result.join(\"\");\\n};\\n\\nclass Stack {\\n    constructor() {\\n        this.stack = []\\n    }\\n    push(a) {\\n        this.stack.push(a)\\n    }\\n    pop() {\\n        return this.stack.pop()\\n    }\\n    peek() {\\n        return this.stack[this.stack.length - 1]\\n    }\\n    size() {\\n        return this.stack.length\\n    }\\n    toString(){\\n      return this.stack.join(\"\");  \\n    }\\n    isEmpty() {\\n        return this.stack.length == 0\\n    }\\n}\\n```\n```\\nRuntime: 63 ms, faster than 97.88% of JavaScript online submissions for Remove Outermost Parentheses.\\nMemory Usage: 43.7 MB, less than 68.18% of JavaScript online submissions for Remove Outermost Parentheses.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554567,
                "title": "java-o-n-tc",
                "content": "```\\n\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n       \\n\\t    StringBuilder sb = new StringBuilder(); \\n        int sum = 0;\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'(\\') {\\n                sum += 1;\\n                if(sum > 1) {\\n                    sb.append(\"(\");\\n                }\\n            } else {\\n                sum -= 1;\\n                if(sum > 0) {\\n                    sb.append(\")\");\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n       \\n\\t    StringBuilder sb = new StringBuilder(); \\n        int sum = 0;\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'(\\') {\\n                sum += 1;\\n                if(sum > 1) {\\n                    sb.append(\"(\");\\n                }\\n            } else {\\n                sum -= 1;\\n                if(sum > 0) {\\n                    sb.append(\")\");\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543307,
                "title": "java-stringbuilder-counting-easy-approach",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count=0;\\n        StringBuilder str = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                count++;\\n                if(count!=1)\\n                    str.append(s.charAt(i));\\n            }\\n            else if(s.charAt(i)==\\')\\'){\\n                count--;\\n                if(count!=0)\\n                    str.append(s.charAt(i));\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count=0;\\n        StringBuilder str = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                count++;\\n                if(count!=1)\\n                    str.append(s.charAt(i));\\n            }\\n            else if(s.charAt(i)==\\')\\'){\\n                count--;\\n                if(count!=0)\\n                    str.append(s.charAt(i));\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524647,
                "title": "c-easy-fast",
                "content": "```\\nstring removeOuterParentheses(string s) {\\n        string ans;\\n        stack<char> st;\\n        for(int i=0; i<s.size(); i++){\\n            char sb = s[i];\\n            if(sb==\\'(\\'){\\n              if(st.size()>0){\\n                ans.push_back(sb);  \\n              }\\n              st.push(sb);  \\n            }\\n            else{\\n                st.pop();\\n                if(st.size()>0){\\n                   ans.push_back(sb); \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nstring removeOuterParentheses(string s) {\\n        string ans;\\n        stack<char> st;\\n        for(int i=0; i<s.size(); i++){\\n            char sb = s[i];\\n            if(sb==\\'(\\'){\\n              if(st.size()>0){\\n                ans.push_back(sb);  \\n              }\\n              st.push(sb);  \\n            }\\n            else{\\n                st.pop();\\n                if(st.size()>0){\\n                   ans.push_back(sb); \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2524511,
                "title": "easy-to-understand-python",
                "content": "```\\nclass Solution:\\n    \\n    def removeOuterParentheses(self, s: str) -> str:\\n    \\n        val = 0 \\n        ans = []\\n        idx = 0 \\n        for i in range(0,len(s)):\\n\\n            if(i == 0):\\n\\n                val += 1 \\n\\n                continue \\n\\n\\n            elif(s[i] == \"(\"):\\n\\n                val += 1 \\n\\n            else: \\n\\n                val -= 1 \\n\\n\\n\\n            if(val == 0 ):\\n\\n                ans.append(s[idx:i+1])\\n\\n\\n                idx = i + 1 \\n\\n        t = \"\"\\n\\n\\n      \\n        for par in ans:\\n\\n            n = len(par)\\n\\n            t += par[1:n-1]\\n\\n\\n        return t \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def removeOuterParentheses(self, s: str) -> str:\\n    \\n        val = 0 \\n        ans = []\\n        idx = 0 \\n        for i in range(0,len(s)):\\n\\n            if(i == 0):\\n\\n                val += 1 \\n\\n                continue \\n\\n\\n            elif(s[i] == \"(\"):\\n\\n                val += 1 \\n\\n            else: \\n\\n                val -= 1 \\n\\n\\n\\n            if(val == 0 ):\\n\\n                ans.append(s[idx:i+1])\\n\\n\\n                idx = i + 1 \\n\\n        t = \"\"\\n\\n\\n      \\n        for par in ans:\\n\\n            n = len(par)\\n\\n            t += par[1:n-1]\\n\\n\\n        return t \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516105,
                "title": "easiest-python-solution-o-n-solution",
                "content": "```\\ndef removeOuterParentheses(self, s: str) -> str:\\n        countOpen = 0\\n        res = \"\"\\n        \\n        for ch in s:\\n            if ch == \\'(\\' :\\n                countOpen += 1\\n                if countOpen > 1 :\\n                    res += ch                \\n            \\n            if ch == \\')\\' :\\n                countOpen -= 1\\n                if countOpen > 0 :\\n                    res += ch\\n                  \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef removeOuterParentheses(self, s: str) -> str:\\n        countOpen = 0\\n        res = \"\"\\n        \\n        for ch in s:\\n            if ch == \\'(\\' :\\n                countOpen += 1\\n                if countOpen > 1 :\\n                    res += ch                \\n            \\n            if ch == \\')\\' :\\n                countOpen -= 1\\n                if countOpen > 0 :\\n                    res += ch\\n                  \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2514370,
                "title": "self-made-simple-logic-cpp-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring removeOuterParentheses(string s) {\\n\\t\\t\\tint c=0;\\n\\t\\t\\tstring ns=\"\";\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar ch=s.at(i);\\n\\t\\t\\t\\tif(ch==\\')\\')\\n\\t\\t\\t\\t\\tc--;\\n\\t\\t\\t\\tif(c>0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tns+=ch;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(ch==\\'(\\')\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t}\\n\\t\\t\\treturn ns;\\n\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring removeOuterParentheses(string s) {\\n\\t\\t\\tint c=0;\\n\\t\\t\\tstring ns=\"\";\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar ch=s.at(i);\\n\\t\\t\\t\\tif(ch==\\')\\')\\n\\t\\t\\t\\t\\tc--;\\n\\t\\t\\t\\tif(c>0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tns+=ch;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2375032,
                "title": "c-simple-o-n-solution-beats-100",
                "content": "The question seems to be difficult but its rather easy to understand.\\nThe main idea here is to understand that the given string is already a valid parenthesis and the main requirement is to just remove the outermost bracket of the simplest valid parenthesis that can be done using the **counting method** what it means is that the number of opening brackets is same as closing bracket for a given sub valid parenthesis string.\\nTake two pointer i and j both at zero and start counting the opening brackets and reducing the count on closing bracket once the count reaches zero that means we have a valid parenthesis and we can now remove the given set of brackets and then update i to j+1 to the next opening bracket if it exits and then also incrementing j so that the above initial step can be repeated.\\n\\nC++ \\n```\\nstring removeOuterParentheses(string s) {\\n        int i=0,j=0,countOfBrackets=0;\\n        while(j<s.length())\\n        {\\n            if(s[j]==\\'(\\')\\n            {\\n                countOfBrackets++;\\n                j++;\\n            }else{\\n                countOfBrackets--;\\n                if(countOfBrackets==0)\\n                {\\n                    s[i]=\\'0\\';\\n                    s[j]=\\'0\\';\\n                    i=j+1;\\n                }\\n                j++;\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.at(i)!=\\'0\\')\\n                ans+=s[i];\\n        }\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring removeOuterParentheses(string s) {\\n        int i=0,j=0,countOfBrackets=0;\\n        while(j<s.length())\\n        {\\n            if(s[j]==\\'(\\')\\n            {\\n                countOfBrackets++;\\n                j++;\\n            }else{\\n                countOfBrackets--;\\n                if(countOfBrackets==0)\\n                {\\n                    s[i]=\\'0\\';\\n                    s[j]=\\'0\\';\\n                    i=j+1;\\n                }\\n                j++;\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.at(i)!=\\'0\\')\\n                ans+=s[i];\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2366578,
                "title": "python-o-1-space-easy-explanation",
                "content": "Success\\nDetails \\nRuntime: 55 ms, faster than **61.98%** of Python3 online submissions.\\nMemory Usage: 13.9 MB, less than **92.46%** of Python3 online submissions.\\n\\n1. Create an empty result string. res=\\'\\'\\n\\n2. I have take temp variable C which is intially zero.\\n3. Itterate over the string.\\n4. When we find \\'(\\' increament C and when we find \\')\\' decrement C.\\n5. So whenever C becmoes 0, we will be outside the paranthessis.\\n6. So, while iterating the string, when the current element is \\'(\\' append \\'(\\' to out result except when c==0 and while current element is \\')\\' append \\')\\' to our result except when c==1. (because after this we will decrement C to zero )\\n\\n***If this helps, Please leave an upvote!!!***\\n\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        c=0\\n        res=\\'\\'\\n        for i in s:\\n            if i==\\')\\' and c==1:\\n                c=c-1\\n            elif i==\\'(\\' and c==0:\\n                c=c+1\\n            elif i==\\'(\\':\\n                res=res+\\'(\\'\\n                c=c+1\\n            elif i==\\')\\':\\n                res=res+\\')\\'\\n                c=c-1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        c=0\\n        res=\\'\\'\\n        for i in s:\\n            if i==\\')\\' and c==1:\\n                c=c-1\\n            elif i==\\'(\\' and c==0:\\n                c=c+1\\n            elif i==\\'(\\':\\n                res=res+\\'(\\'\\n                c=c+1\\n            elif i==\\')\\':\\n                res=res+\\')\\'\\n                c=c-1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334680,
                "title": "solution-in-c-using-stack-and-without-stack",
                "content": "```\\n// using stack :- Time: O(n) ,  space: O(n)\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string str;\\n        stack<char> st;\\n        for(char c: s){\\n            if(c == \\'(\\'){\\n                if(!st.empty()){\\n                    str += \\'(\\';\\n                }\\n                st.push(c);\\n            }\\n            else {\\n                st.pop();\\n                if(!st.empty()){\\n                    str += \")\";\\n                }\\n            }\\n            \\n        }\\n        return str;\\n    }\\n};\\n\\n//without stack Time: O(n),  space: O(1)\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int count = 0;\\n        string str;\\n        for(char c : s){\\n            if (c == \\'(\\' && count++) str += \\'(\\';\\n            else if ( c == \\')\\' && --count) str+= \\')\\';\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n// using stack :- Time: O(n) ,  space: O(n)\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string str;\\n        stack<char> st;\\n        for(char c: s){\\n            if(c == \\'(\\'){\\n                if(!st.empty()){\\n                    str += \\'(\\';\\n                }\\n                st.push(c);\\n            }\\n            else {\\n                st.pop();\\n                if(!st.empty()){\\n                    str += \")\";\\n                }\\n            }\\n            \\n        }\\n        return str;\\n    }\\n};\\n\\n//without stack Time: O(n),  space: O(1)\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int count = 0;\\n        string str;\\n        for(char c : s){\\n            if (c == \\'(\\' && count++) str += \\'(\\';\\n            else if ( c == \\')\\' && --count) str+= \\')\\';\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269720,
                "title": "simple-java-solution-o-n",
                "content": "class Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        StringBuilder res = new StringBuilder();\\n        \\n        int count=0;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            \\n            char c=s.charAt(i);\\n            int prev=count;\\n            if(c==\\'(\\') count++;\\n            else count--;\\n            \\n            if(prev==0 && count==1) continue; // if it is a starting \\'(\\' of outer most parentheses then continue\\n            else if(prev==1 && count==0) continue; // if it is a ending \\')\\' of the outer most parentheses then continue\\n            \\n            res.append(c); // else append it to result\\n        }\\n        \\n        return res.toString();\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        StringBuilder res = new StringBuilder();\\n        \\n        int count=0;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            \\n            char c=s.charAt(i);\\n            int prev=count;\\n            if(c==\\'(\\') count++;\\n            else count--;\\n            \\n            if(prev==0 && count==1) continue; // if it is a starting \\'(\\' of outer most parentheses then continue\\n            else if(prev==1 && count==0) continue; // if it is a ending \\')\\' of the outer most parentheses then continue\\n            \\n            res.append(c); // else append it to result\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2040897,
                "title": "java-solution-using-stack",
                "content": "# java Solution\\n```\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder stb=new StringBuilder();\\n        Stack<Character> stack= new Stack();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                if(stack.size()>=1){\\n                    stb.append(\\'(\\');\\n                }\\n                stack.push(\\'(\\');\\n            }else{\\n                if(stack.size()>1){\\n                    stb.append(\\')\\');\\n                }\\n                stack.pop();\\n            }\\n           \\n        }\\n        return stb.toString();\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "String",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder stb=new StringBuilder();\\n        Stack<Character> stack= new Stack();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                if(stack.size()>=1){\\n                    stb.append(\\'(\\');\\n                }\\n                stack.push(\\'(\\');\\n            }else{\\n                if(stack.size()>1){\\n                    stb.append(\\')\\');\\n                }\\n                stack.pop();\\n            }\\n           \\n        }\\n        return stb.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2008555,
                "title": "simple-and-small-c-stack",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    string removeOuterParentheses(string s)\\n    {\\n        stack<char> st;\\n        string ans = \"\", cur = \"\";\\n        for (auto it : s)\\n        {\\n            if (st.empty())\\n            {\\n                st.push(it);\\n                cur += it;\\n            }\\n            else if (st.top() == \\'(\\' && it == \\')\\' && st.size() == 1)\\n            {\\n                st.pop();\\n                ans += cur.substr(1);\\n                cur = \"\";\\n            }\\n            else if (st.top() == \\'(\\' && it == \\')\\')\\n            {\\n                st.pop();\\n                cur += it;\\n            }\\n            else\\n            {\\n                st.push(it);\\n                cur += it;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    string removeOuterParentheses(string s)\\n    {\\n        stack<char> st;\\n        string ans = \"\", cur = \"\";\\n        for (auto it : s)\\n        {\\n            if (st.empty())\\n            {\\n                st.push(it);\\n                cur += it;\\n            }\\n            else if (st.top() == \\'(\\' && it == \\')\\' && st.size() == 1)\\n            {\\n                st.pop();\\n                ans += cur.substr(1);\\n                cur = \"\";\\n            }\\n            else if (st.top() == \\'(\\' && it == \\')\\')\\n            {\\n                st.pop();\\n                cur += it;\\n            }\\n            else\\n            {\\n                st.push(it);\\n                cur += it;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981458,
                "title": "c-without-stack-and-without-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans = \"\";\\n        int sum = 0, lastIndex=0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == \\'(\\') {\\n                sum++;\\n            } else if(s[i] == \\')\\') {\\n                sum--;\\n            }\\n            if(sum == 0) {\\n                ans +=  s.substr(lastIndex+1, i-lastIndex-1);\\n                lastIndex = i+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans = \"\";\\n        int sum = 0, lastIndex=0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == \\'(\\') {\\n                sum++;\\n            } else if(s[i] == \\')\\') {\\n                sum--;\\n            }\\n            if(sum == 0) {\\n                ans +=  s.substr(lastIndex+1, i-lastIndex-1);\\n                lastIndex = i+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935363,
                "title": "java-simple-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int f=0,l=0;\\n        StringBuilder res = new StringBuilder(\"\");\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\')\\'){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n            if(stack.empty()){\\n                res.append(s.substring(f+1,i));\\n                f = i+1;\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int f=0,l=0;\\n        StringBuilder res = new StringBuilder(\"\");\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\')\\'){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n            if(stack.empty()){\\n                res.append(s.substring(f+1,i));\\n                f = i+1;\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794873,
                "title": "easy-java-solution-without-stack",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int counter = 0;   \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\'){\\n                if (counter++ > 0)\\n                    sb.append(c);\\n            } else {\\n                if (--counter > 0) \\n                    sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int counter = 0;   \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\'){\\n                if (counter++ > 0)\\n                    sb.append(c);\\n            } else {\\n                if (--counter > 0) \\n                    sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749419,
                "title": "c-0ms-100-0",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string res=\"\", temp=\"\";\\n        int n=s.size();\\n        int open=0, clos=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            temp+=s[i];\\n            if(s[i]==\\'(\\')\\n                open++;\\n            else\\n                clos++;\\n            if(open==clos)\\n            {\\n                res+=temp.substr(1, temp.size()-2);\\n                temp=\"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string res=\"\", temp=\"\";\\n        int n=s.size();\\n        int open=0, clos=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            temp+=s[i];\\n            if(s[i]==\\'(\\')\\n                open++;\\n            else\\n                clos++;\\n            if(open==clos)\\n            {\\n                res+=temp.substr(1, temp.size()-2);\\n                temp=\"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734763,
                "title": "java-both-with-without-extra-space-fast-100",
                "content": "**Approach 1 : With using extra space** \\nWith using Stack, we are appending in resultant string if at any point our stack becomes empty :\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Integer> stk = new Stack<>() ;\\n        StringBuilder res = new StringBuilder() ;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                stk.push(i);\\n            }\\n            else{\\n                int j = stk.pop() ;\\n                if(stk.isEmpty()){\\n                    res.append(s.substring(j+1,i));\\n                }\\n            }    \\n        }\\n        return res.toString() ;\\n    }\\n}\\n```\\n\\n**Approach 2 : Without using extra space**\\nIf we encounter an open bracket we will just increase the open count similarly for closeing bracket we are dereasing the count.\\nIf at any point `open` becomes 0 that means we need  substring from start of` open` = 0 to end `open` = 0 .\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        int open = 0 ;\\n        StringBuilder res = new StringBuilder() ;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                open++;\\n                if(open > 1) res.append(ch);\\n            }\\n            else{\\n                 open-- ;\\n                if(open > 0) res.append(ch);\\n            }\\n        }\\n        return res.toString() ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Integer> stk = new Stack<>() ;\\n        StringBuilder res = new StringBuilder() ;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                stk.push(i);\\n            }\\n            else{\\n                int j = stk.pop() ;\\n                if(stk.isEmpty()){\\n                    res.append(s.substring(j+1,i));\\n                }\\n            }    \\n        }\\n        return res.toString() ;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        int open = 0 ;\\n        StringBuilder res = new StringBuilder() ;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                open++;\\n                if(open > 1) res.append(ch);\\n            }\\n            else{\\n                 open-- ;\\n                if(open > 0) res.append(ch);\\n            }\\n        }\\n        return res.toString() ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732284,
                "title": "100-faster-java-solution-without-using-stack",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        int op=0;\\n        int cl=0;\\n        int si=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                op++;\\n            }else{\\n                cl++;\\n            }\\n            if(op==cl){\\n                for(int j=si+1;j<i;j++){\\n                    sb.append(s.charAt(j));\\n                }\\n                op=0;\\n                cl=0;\\n                si=i+1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        int op=0;\\n        int cl=0;\\n        int si=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                op++;\\n            }else{\\n                cl++;\\n            }\\n            if(op==cl){\\n                for(int j=si+1;j<i;j++){\\n                    sb.append(s.charAt(j));\\n                }\\n                op=0;\\n                cl=0;\\n                si=i+1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730020,
                "title": "c-solution",
                "content": "string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\')\\')\\n                str.pop();\\n            if(str.size()!=0)\\n                ans=ans+s[i];\\n            if(s[i]==\\'(\\')\\n                str.push(s[i]);\\n        }\\n        return ans;\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\')\\')\\n                str.pop();\\n            if(str.size()!=0)\\n                ans=ans+s[i];\\n            if(s[i]==\\'(\\')\\n                str.push(s[i]);\\n        }\\n        return ans;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1691784,
                "title": "the-best-possible-solution-without-using-stack-that-run-in-0ms",
                "content": "class Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        \\n        string str = \"\";\\n        int i = 0;\\n        \\n        for(int j=1; j<s.size(); j++)\\n        {\\n            char ch = s[j];\\n            if(ch == \\'(\\')\\n                i++;\\n            if(i>0)\\n                str += ch;\\n            if(ch == \\')\\')\\n                i--;\\n        }\\n        \\n        \\n        \\n        return str;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        \\n        string str = \"\";\\n        int i = 0;\\n        \\n        for(int j=1; j<s.size(); j++)\\n        {\\n            char ch = s[j];\\n            if(ch == \\'(\\')\\n                i++;\\n            if(i>0)\\n                str += ch;\\n            if(ch == \\')\\')\\n                i--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1686263,
                "title": "java-using-stack-and-without-using-stack",
                "content": "**USING STACK O(N)** \\n```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        Stack<Character> st=new Stack();\\n        StringBuilder sb=new StringBuilder();\\n        for(char ch:S.toCharArray())  //convert string into character array\\n        {\\n            if(ch==\\'(\\')\\n            {\\n                 if(st.size()>=1)  //check if stack is empty or not i.e its first opening bracket or not\\n                 {\\n                     sb.append(ch);  // adds to sb if opening bracket but not first\\n                 }\\n                st.push(ch);  //push element into stack\\n            }\\n            else{\\n                if(st.size()>1)  // if stack is empty doesn\\'t append \\n                 {\\n                     sb.append(ch);\\n                 }\\n                st.pop(); //pop out of stack\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n**WITHOUT USING STACK O(N)**\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String str) {\\n          StringBuilder sb= new StringBuilder();\\n        \\n        int opened= 0;\\n        for( char c:str.toCharArray()){\\n            \\n            if(c==\\'(\\'){\\n                if(opened>0) sb.append(c);\\n                opened++;\\n            }else{\\n                if(opened>1)sb.append(c);\\n                opened--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n**Hope you  like it**\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        Stack<Character> st=new Stack();\\n        StringBuilder sb=new StringBuilder();\\n        for(char ch:S.toCharArray())  //convert string into character array\\n        {\\n            if(ch==\\'(\\')\\n            {\\n                 if(st.size()>=1)  //check if stack is empty or not i.e its first opening bracket or not\\n                 {\\n                     sb.append(ch);  // adds to sb if opening bracket but not first\\n                 }\\n                st.push(ch);  //push element into stack\\n            }\\n            else{\\n                if(st.size()>1)  // if stack is empty doesn\\'t append \\n                 {\\n                     sb.append(ch);\\n                 }\\n                st.pop(); //pop out of stack\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String removeOuterParentheses(String str) {\\n          StringBuilder sb= new StringBuilder();\\n        \\n        int opened= 0;\\n        for( char c:str.toCharArray()){\\n            \\n            if(c==\\'(\\'){\\n                if(opened>0) sb.append(c);\\n                opened++;\\n            }else{\\n                if(opened>1)sb.append(c);\\n                opened--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677664,
                "title": "easiest-solution-using-stack-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<int> st;\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\')\\')\\n                st.pop();\\n            if(st.size()!=0)\\n                ans+=s[i];\\n            if(s[i]==\\'(\\')\\n                st.push(s[i]);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<int> st;\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\')\\')\\n                st.pop();\\n            if(st.size()!=0)\\n                ans+=s[i];\\n            if(s[i]==\\'(\\')\\n                st.push(s[i]);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611056,
                "title": "without-stack-solution-o-n-single-pass",
                "content": "````    public String removeOuterParentheses(String s) {\\n        int sb = 0;\\n        int eb = 0;int sp = 0;\\n        StringBuilder str1 = new StringBuilder(\"\");\\n        for(int i = 0;i < s.length() ;i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                sb++;\\n            }else{\\n                eb++;\\n            }\\n            if(sb == eb ){\\n                str1.append(s.substring(sp+1,i));\\n                sb = 0;eb = 0;sp = i+1;\\n            }\\n        }\\n\\n        return str1.toString();\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "````    public String removeOuterParentheses(String s) {\\n        int sb = 0;\\n        int eb = 0;int sp = 0;\\n        StringBuilder str1 = new StringBuilder(\"\");\\n        for(int i = 0;i < s.length() ;i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                sb++;\\n            }else{\\n                eb++;\\n            }\\n            if(sb == eb ){\\n                str1.append(s.substring(sp+1,i));\\n                sb = 0;eb = 0;sp = i+1;\\n            }\\n        }\\n\\n        return str1.toString();\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1506586,
                "title": "clean-solution-using-stack-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int countLeft = 0, countRight = 0;\\n        string ans = \"\";\\n        stack<char> st;\\n        \\n        for(int i =0;i<s.size(); i++){\\n            if(s[i] == \\'(\\'){\\n                countLeft++;\\n                if(countLeft > 1){\\n                    st.push(s[i]);\\n                }\\n            }else if(countLeft == countRight+1){\\n                countLeft = 0;\\n                countRight = 0;\\n                continue;\\n            }else if(s[i] == \\')\\'){\\n                st.push(s[i]);\\n                countRight++;\\n            }\\n        }\\n        \\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int countLeft = 0, countRight = 0;\\n        string ans = \"\";\\n        stack<char> st;\\n        \\n        for(int i =0;i<s.size(); i++){\\n            if(s[i] == \\'(\\'){\\n                countLeft++;\\n                if(countLeft > 1){\\n                    st.push(s[i]);\\n                }\\n            }else if(countLeft == countRight+1){\\n                countLeft = 0;\\n                countRight = 0;\\n                continue;\\n            }else if(s[i] == \\')\\'){\\n                st.push(s[i]);\\n                countRight++;\\n            }\\n        }\\n        \\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469321,
                "title": "java-easy-solution-using-stack-o-n",
                "content": "Simply use a stack follow if-else laddar conditions:-\\n\\n```class Solution {``\\n    public String removeOuterParentheses(String s) {\\n        String str=\"\";\\n    Stack<Character> st=new Stack<>();\\n    for(int i=0;i<s.length();i++){\\n        char ch=s.charAt(i);\\n        if(ch==\\'(\\'){\\n            st.push(ch);\\n            if(st.size()>1){\\n                str+=ch;\\n            }\\n        }\\n        else if(ch==\\')\\'){\\n            if( st.size()>1 && st.peek()==\\'(\\'){\\n                str+=ch;\\n                st.pop();\\n            }\\n            else if(st.size()==1 && st.peek()==\\'(\\' ){\\n                st.pop();\\n            }\\n        }\\n        \\n    }\\n    return str;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {``\\n    public String removeOuterParentheses(String s) {\\n        String str=\"\";\\n    Stack<Character> st=new Stack<>();\\n    for(int i=0;i<s.length();i++){\\n        char ch=s.charAt(i);\\n        if(ch==\\'(\\'){\\n            st.push(ch);\\n            if(st.size()>1){\\n                str+=ch;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1433045,
                "title": "simple-solution-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string str) {\\n        stack<char>s;\\n        string ans=\"\";\\n        \\n        for(auto x:str){\\n            \\n            if(x==\\'(\\'){\\n                \\n                if(!s.empty())  ans+=\\'(\\';\\n                 \\n                s.push(\\'(\\');\\n            \\n            } \\n            \\n            else{\\n                \\n                s.pop();\\n                \\n                if(!s.empty()) ans+=\\')\\';\\n                          \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string removeOuterParentheses(string str) {\\n        stack<char>s;\\n        string ans=\"\";\\n        \\n        for(auto x:str){\\n            \\n            if(x==\\'(\\'){\\n                \\n                if(!s.empty())  ans+=\\'(\\';\\n                 \\n                s.push(\\'(\\');\\n            \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1414500,
                "title": "java-using-stack-5ms",
                "content": "class Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> st=new Stack<>();\\n        StringBuilder sb= new StringBuilder();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\')\\n            {\\n                if(st.size()>0)//to check if the stack is empty or not\\n                {\\n                    sb.append(ch);\\n                }\\n                st.push(ch);\\n            }\\n            else\\n            {\\n                st.pop();\\n                if(st.size()>0)\\n                {\\n                    sb.append(ch);\\n                }\\n                    \\n            }\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> st=new Stack<>();\\n        StringBuilder sb= new StringBuilder();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\')\\n            {\\n                if(st.size()>0)//to check if the stack is empty or not\\n                {\\n                    sb.append(ch);\\n                }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1749987,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1944035,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1568298,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 2019757,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1752088,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1717947,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1935039,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1907179,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1846855,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1574537,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1749987,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1944035,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1568298,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 2019757,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1752088,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1717947,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1935039,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1907179,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1846855,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1574537,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1801906,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2074725,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2059542,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2037140,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2036139,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2034017,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2030162,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2029746,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2004957,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 1963340,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            }
        ]
    },
    {
        "title": "Running Sum of 1d Array",
        "question_content": "<p>Given an array <code>nums</code>. We define a running sum of an array as&nbsp;<code>runningSum[i] = sum(nums[0]&hellip;nums[i])</code>.</p>\r\n\r\n<p>Return the running sum of <code>nums</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,2,3,4]\r\n<strong>Output:</strong> [1,3,6,10]\r\n<strong>Explanation:</strong> Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,1,1,1,1]\r\n<strong>Output:</strong> [1,2,3,4,5]\r\n<strong>Explanation:</strong> Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].</pre>\r\n\r\n<p><strong class=\"example\">Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [3,1,2,10,1]\r\n<strong>Output:</strong> [3,4,6,16,17]\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\r\n\t<li><code>-10^6&nbsp;&lt;= nums[i] &lt;=&nbsp;10^6</code></li>\r\n</ul>",
        "solutions": [
            {
                "id": 3167663,
                "title": "simple-solution-java-cpp-python-c-language-runtime-1-ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```java []\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n\\n        for(int i=1;i<nums.length;i++){\\n            nums[i]=nums[i-1]+nums[i];\\n\\n        }\\n        return nums;\\n    }\\n}\\n```\\n```Cpp []\\nclass Solution {\\n\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1;i<nums.size();i++){\\n\\n            nums[i]+=nums[i-1];\\n\\n        }\\n\\n        return nums;\\n    }\\n};\\n```\\n```Python []\\nclass Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(1,len(nums)):\\n            nums[i]+=nums[i-1]\\n        return nums\\n```\\n```C []\\n\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    int sum=0;\\n    *returnSize = numsSize; //size for the new array to be returned\\n    \\nfor(int i=1;i<numsSize;i++)\\n    {\\n        nums[i]+=nums[i-1];\\n    }\\n    return nums;\\n}\\n```\\n\\n\\n\\n![478xve.jpg](https://assets.leetcode.com/users/images/bec6803b-0214-4a33-be9e-f8c4b459d23e_1676026371.8625238.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Array"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n\\n        for(int i=1;i<nums.length;i++){\\n            nums[i]=nums[i-1]+nums[i];\\n\\n        }\\n        return nums;\\n    }\\n}\\n```\n```Cpp []\\nclass Solution {\\n\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1;i<nums.size();i++){\\n\\n            nums[i]+=nums[i-1];\\n\\n        }\\n\\n        return nums;\\n    }\\n};\\n```\n```Python []\\nclass Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(1,len(nums)):\\n            nums[i]+=nums[i-1]\\n        return nums\\n```\n```C []\\n\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    int sum=0;\\n    *returnSize = numsSize; //size for the new array to be returned\\n    \\nfor(int i=1;i<numsSize;i++)\\n    {\\n        nums[i]+=nums[i-1];\\n    }\\n    return nums;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635285,
                "title": "comprehensive-python-explanation-4-methods",
                "content": "**Intuition**\\nTo solve this problem we need to create an array that will store the running sum up to that index. There are many ways to do this, starting from the most basic brute force to a neat single pass.\\n\\n**Method 1: Pure Brute Force; Time: O(N^2), Space: O(N)**\\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\tanswer = [] #array to keep track of our answer\\n\\tfor i in range(len(nums)): #iterate through all the elements in nums\\n\\t\\trunningSum = 0 #this will keep track of the running sum up to index i\\n\\t\\tfor j in range(i+1): \\n\\t\\t\\trunningSum += nums[j] #sum all the elements leading up to nums[i]\\n\\t\\tanswer.append(runningSum) #add the sum to our answer array\\n\\treturn answer\\n```\\nThe idea behind this method is that for every index i in nums, we will iterate from 0 to i and sum the elements in nums to get the running sum. The time complexity is O(N^2) since we need to iterate up to index i for every value of i between 0 and N. The space complexity is O(N) since our answer array has length N (where N is the length of nums).\\n\\n **Method 2: Brute Force with List Comprehension; Time: O(N^2), Space: O(N)**\\n ```\\n def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [sum(nums[:i+1]) for i in range(len(nums))]\\n```\\nThis method works the same as Method 1 but is a neat one liner. ```sum(nums[:i+1])``` performs the same function as our nested for loop in method 1, finding the running sum up to that point. \\n\\n**Improving from Brute Force**\\nBoth of these methods are accepted, but when we find a working solution, we should always ask if we can think of a better one. In this case, there is a way to complete the function in one pass, lowering the time complexity from O(N^2) to O(N).\\n\\n**Method 3: One Pass; Time: O(N), Space: O(N)**\\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\trunSum = [nums[0]] #our answer array starts with nums[0], which is the 0th running sum\\n\\tfor i in range(1,len(nums)):\\n\\t\\trunSum.append(runSum[i-1]+nums[i]) #the running sum up to index i is the sum of nums[i] and the running sum up to index i-1\\n\\treturn runSum\\n```\\nThe key insight here is that the running sum up to index i is the sum of nums[i] and the running sum up to index i-1. Here is a more detailled explanation:\\nWe know that ```runningSum[i] = nums[0] + nums[1] + ... + nums[i-1] + nums[i]```. \\nHowever, ```runningSum[i-1] = nums[0] + nums[1] + ... + nums[i-1]```, so we can rewrite the first expression to get that ```runningSum[i] = runningSum[i-1] + nums[i]```!\\n\\nThis code has a time complexity of O(N) since it only takes one pass, which will make the program run much faster when given a very large nums array. However, there is still a way to optimize the space we use.\\n\\n**Method 4: One Pass, In-Place Solution; Time: O(N), Space: O(1)**\\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\tfor i in range(1,len(nums)):\\n\\t\\tnums[i] = nums[i-1] + nums[i]\\n\\treturn nums\\n```\\nThis method uses the same insight as Method 3 but does it without using an extra array to store the result!. If we are currently at index i, we can assume ```nums[i-1], nums[i-2]... nums[0]``` have all been visited before and therefore contain the running sum up to that point. This means that ```nums[i-1]``` is actually the same as ```runSum[i-1]``` in the last method! By modifying nums in-place and not using an extra array, we cut down on any unnecessary extra space.\\n\\n\\n**Thanks for Reading!**\\nIf this post has been helpful please consider upvoting! Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\tanswer = [] #array to keep track of our answer\\n\\tfor i in range(len(nums)): #iterate through all the elements in nums\\n\\t\\trunningSum = 0 #this will keep track of the running sum up to index i\\n\\t\\tfor j in range(i+1): \\n\\t\\t\\trunningSum += nums[j] #sum all the elements leading up to nums[i]\\n\\t\\tanswer.append(runningSum) #add the sum to our answer array\\n\\treturn answer\\n```\n```\\n def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [sum(nums[:i+1]) for i in range(len(nums))]\\n```\n```sum(nums[:i+1])```\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\trunSum = [nums[0]] #our answer array starts with nums[0], which is the 0th running sum\\n\\tfor i in range(1,len(nums)):\\n\\t\\trunSum.append(runSum[i-1]+nums[i]) #the running sum up to index i is the sum of nums[i] and the running sum up to index i-1\\n\\treturn runSum\\n```\n```runningSum[i] = nums[0] + nums[1] + ... + nums[i-1] + nums[i]```\n```runningSum[i-1] = nums[0] + nums[1] + ... + nums[i-1]```\n```runningSum[i] = runningSum[i-1] + nums[i]```\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\tfor i in range(1,len(nums)):\\n\\t\\tnums[i] = nums[i-1] + nums[i]\\n\\treturn nums\\n```\n```nums[i-1], nums[i-2]... nums[0]```\n```nums[i-1]```\n```runSum[i-1]```",
                "codeTag": "Python3"
            },
            {
                "id": 686276,
                "title": "c-python-partial-sum",
                "content": "**C++**\\n```cpp\\nvector<int> runningSum(vector<int>& nums) {\\n    partial_sum(begin(nums), end(nums), begin(nums));\\n    return nums;\\n}\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        return accumulate(nums)   \\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> runningSum(vector<int>& nums) {\\n    partial_sum(begin(nums), end(nums), begin(nums));\\n    return nums;\\n}\\n```\n```python\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        return accumulate(nums)   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468388,
                "title": "very-easy-0-ms-100-fully-explained-java-c-python-js-python3",
                "content": "# **Java Solution:**\\n```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Running Sum of 1d Array.\\n// Time Complexity : O(n)\\n// Space Complexity : O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        // Create an output array of size equal to given nums size...\\n        int[] output = new int[nums.length];\\n        // Base case: if the array is empty...\\n        if(nums.length == 0)\\n            return output;\\n        // Set output[0] = nums[0]...\\n        output[0] = nums[0];\\n        // Traverse all elements through the for loop...\\n        for(int idx = 1; idx < nums.length; idx++) {\\n            // Storing the running sum...\\n            output[idx] = output[idx-1]+ nums[idx];\\n        }\\n        return output;      // Return the running sum of nums...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\n// Time Complexity : O(n)\\n// Space Complexity : O(n)\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        // Create an output array of size equal to given nums size...\\n        vector<int> output(nums.size());\\n        // Base case: if the array is empty...\\n        if(nums.size() == 0)\\n            return output;\\n        // Set output[0] = nums[0]...\\n        output[0] = nums[0];\\n        // Traverse all elements through the for loop...\\n        for(int idx = 1; idx < nums.size(); idx++) {\\n            // Storing the running sum...\\n            output[idx] = output[idx-1] + nums[idx];\\n        } return output;     // Return the running sum of nums...\\n    }\\n};\\n```\\n\\n# **Python/Python3 Solution:**\\n```\\n# Time Complexity : O(n)\\n# Space Complexity : O(n)\\nclass Solution(object):\\n    def runningSum(self, nums):\\n        # Create an output array of size equal to given nums size...\\n        output = [0] * len(nums)\\n        # Set output[0] = nums[0]...\\n        output[0] = nums[0]\\n        # Traverse all elements through the for loop...\\n        for idx in range(1, len(nums)):\\n            # Storing the running sum...\\n            output[idx] = output[idx - 1] + nums[idx]\\n        return output       # Return the running sum of nums...\\n```\\n                \\n# **JavaScript Solution:**\\n```\\n// Time Complexity : O(n)\\n// Space Complexity : O(n)\\nvar runningSum = function(nums) {\\n    // Create an output array of size equal to given nums size...\\n    let output = new Array(nums.length)\\n    // Set output[0] = nums[0]...\\n    output[0] = nums[0];\\n    // Traverse all elements through the for loop...\\n    for(let idx = 1; idx < nums.length; idx++) {\\n        // Storing the running sum...\\n        output[idx] = output[idx-1] + nums[idx];\\n    }\\n    return output;      // Return the running sum of nums...\\n};\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Running Sum of 1d Array.\\n// Time Complexity : O(n)\\n// Space Complexity : O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        // Create an output array of size equal to given nums size...\\n        int[] output = new int[nums.length];\\n        // Base case: if the array is empty...\\n        if(nums.length == 0)\\n            return output;\\n        // Set output[0] = nums[0]...\\n        output[0] = nums[0];\\n        // Traverse all elements through the for loop...\\n        for(int idx = 1; idx < nums.length; idx++) {\\n            // Storing the running sum...\\n            output[idx] = output[idx-1]+ nums[idx];\\n        }\\n        return output;      // Return the running sum of nums...\\n    }\\n}\\n```\n```\\n// Time Complexity : O(n)\\n// Space Complexity : O(n)\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        // Create an output array of size equal to given nums size...\\n        vector<int> output(nums.size());\\n        // Base case: if the array is empty...\\n        if(nums.size() == 0)\\n            return output;\\n        // Set output[0] = nums[0]...\\n        output[0] = nums[0];\\n        // Traverse all elements through the for loop...\\n        for(int idx = 1; idx < nums.size(); idx++) {\\n            // Storing the running sum...\\n            output[idx] = output[idx-1] + nums[idx];\\n        } return output;     // Return the running sum of nums...\\n    }\\n};\\n```\n```\\n# Time Complexity : O(n)\\n# Space Complexity : O(n)\\nclass Solution(object):\\n    def runningSum(self, nums):\\n        # Create an output array of size equal to given nums size...\\n        output = [0] * len(nums)\\n        # Set output[0] = nums[0]...\\n        output[0] = nums[0]\\n        # Traverse all elements through the for loop...\\n        for idx in range(1, len(nums)):\\n            # Storing the running sum...\\n            output[idx] = output[idx - 1] + nums[idx]\\n        return output       # Return the running sum of nums...\\n```\n```\\n// Time Complexity : O(n)\\n// Space Complexity : O(n)\\nvar runningSum = function(nums) {\\n    // Create an output array of size equal to given nums size...\\n    let output = new Array(nums.length)\\n    // Set output[0] = nums[0]...\\n    output[0] = nums[0];\\n    // Traverse all elements through the for loop...\\n    for(let idx = 1; idx < nums.length; idx++) {\\n        // Storing the running sum...\\n        output[idx] = output[idx-1] + nums[idx];\\n    }\\n    return output;      // Return the running sum of nums...\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686261,
                "title": "java-c-python-array-time-o-n-space-o-1",
                "content": "**Explanation**\\nLoop once, we can get the sum of subarray starting from the initial point.\\n\\n**Complexity**\\n\\nTime ```O(N)```\\nSpace ```O(1)```\\n\\n**Java:**\\n```\\npublic int[] runningSum(int[] nums) {\\n        int i = 1;\\n        while (i<nums.length){\\n            nums[i]+=nums[i-1];\\n            i++;\\n        }\\n        return nums;\\n    }\\n```\\n**C++**\\n```\\nvector<int> runningSum(vector<int>& nums) {\\n        int i = 1;\\n        while (i<nums.size()){\\n            nums[i]+=nums[i-1];\\n            i++;\\n        }\\n        return nums;\\n    }\\n```\\n\\n@jain_kashish c++ code\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& a) {\\n        for( int i=1 ; i<a.size() ; i++ )\\n            a[i] += a[i-1] ;\\n        return a ;\\n    }\\n};\\n```\\n**Python**\\n```\\n def runningSum(self, nums):\\n        i = 1\\n        while i<len(nums):\\n            nums[i]+=nums[i-1]\\n            i+=1\\n        return nums\\n```\\nWithout modifying the initial array\\n\\nTime ```O(N)```\\nSpace ```O(1)```\\n\\n```\\n def runningSum(self, nums):\\n        res = [nums[0]] + [0] * (len(nums) - 1)\\n        for i, num in enumerate(nums[1:]):\\n            res[i + 1] += res[i] + num\\n        return res\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```O(N)```\n```O(1)```\n```\\npublic int[] runningSum(int[] nums) {\\n        int i = 1;\\n        while (i<nums.length){\\n            nums[i]+=nums[i-1];\\n            i++;\\n        }\\n        return nums;\\n    }\\n```\n```\\nvector<int> runningSum(vector<int>& nums) {\\n        int i = 1;\\n        while (i<nums.size()){\\n            nums[i]+=nums[i-1];\\n            i++;\\n        }\\n        return nums;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& a) {\\n        for( int i=1 ; i<a.size() ; i++ )\\n            a[i] += a[i-1] ;\\n        return a ;\\n    }\\n};\\n```\n```\\n def runningSum(self, nums):\\n        i = 1\\n        while i<len(nums):\\n            nums[i]+=nums[i-1]\\n            i+=1\\n        return nums\\n```\n```O(N)```\n```O(1)```\n```\\n def runningSum(self, nums):\\n        res = [nums[0]] + [0] * (len(nums) - 1)\\n        for i, num in enumerate(nums[1:]):\\n            res[i + 1] += res[i] + num\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694429,
                "title": "javascript-reduce",
                "content": "```\\nconst runningSum = nums => {\\n    nums.reduce((a,c,i,arr) => arr[i] += a)\\n    return nums\\n}\\n```\\n**Remember that assignment is an expression and therefore returns a value.\\nSpecifically, the new value of the variable being assigned something.**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst runningSum = nums => {\\n    nums.reduce((a,c,i,arr) => arr[i] += a)\\n    return nums\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 831397,
                "title": "python-3-2-simple-solutions-o-n-time",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nTime complexity for both the solutions: O(n).\\nSpace complexity in both the solutions: O(n) because we are creating a result list of size n.\\n\\n**Solution 1:**\\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\tresult = []\\n\\ttotal = 0\\n\\tfor i in range(len(nums)):\\n\\t\\ttotal += nums[i]\\n\\t\\tresult.append(total)\\n\\treturn result\\n```\\n\\n**Solution 2: Without using \\'total\\' variable. Just use the last value in result to calculate new sum.**\\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\tresult = []\\n\\tresult.append(nums[0])\\n\\tfor i in range(1, len(nums)):\\n\\t\\tresult.append(result[-1]+nums[i])\\n\\treturn result\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\tresult = []\\n\\ttotal = 0\\n\\tfor i in range(len(nums)):\\n\\t\\ttotal += nums[i]\\n\\t\\tresult.append(total)\\n\\treturn result\\n```\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\tresult = []\\n\\tresult.append(nums[0])\\n\\tfor i in range(1, len(nums)):\\n\\t\\tresult.append(result[-1]+nums[i])\\n\\treturn result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2699842,
                "title": "python-c-java-faster-than-100-simple-short-solution-2-line-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q1480. Running Sum of 1d Array***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            nums[i]+=nums[i-1]\\n        return nums\\n    \\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for(int i=1;i<nums.length;i++)  nums[i]+=nums[i-1];\\n        return nums;\\n    }\\n}\\n```\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n         vector<int> runningSum(vector<int>& a) {\\n        for( int i=1 ; i<a.size() ; i++ )\\n            a[i] += a[i-1] ;\\n        return a ;\\n    }\\n};\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            nums[i]+=nums[i-1]\\n        return nums\\n    \\n```\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for(int i=1;i<nums.length;i++)  nums[i]+=nums[i-1];\\n        return nums;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n         vector<int> runningSum(vector<int>& a) {\\n        for( int i=1 ; i<a.size() ; i++ )\\n            a[i] += a[i-1] ;\\n        return a ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688613,
                "title": "java-clean-and-simple-solution",
                "content": "The simplest solution to this problem (without using streams or other oneliners) is to iterate the input array and perform n[i] += n[i-1], starting at index 1. This works well for arrays with size 1 too, since no iteration is attempted on the for loop (due to int i = 1):\\n\\n```\\n   public int[] runningSum(int[] nums) {       \\n\\t\\t// modify the input array, adding n[i] with n[i-1]\\n        for(int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[i-1];\\n        }      \\n\\t\\t\\n\\t\\t// return the modified array\\n        return nums;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   public int[] runningSum(int[] nums) {       \\n\\t\\t// modify the input array, adding n[i] with n[i-1]\\n        for(int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[i-1];\\n        }      \\n\\t\\t\\n\\t\\t// return the modified array\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 925781,
                "title": "c-2-lines-of-code-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> runningSum(vector<int>& nums) {\\n\\n\\t\\t\\tfor(int i=1;i<nums.size();i++) nums[i] += nums[i-1];\\n\\t\\t\\treturn nums;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> runningSum(vector<int>& nums) {\\n\\n\\t\\t\\tfor(int i=1;i<nums.size();i++) nums[i] += nums[i-1];\\n\\t\\t\\treturn nums;\\n\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2096022,
                "title": "c-short-easy-w-prefix-sum-partial-sum-stl",
                "content": "**Please do upvote if you like the post :)**\\n\\n\\n**Most Intuitive Approach Ever (C++):**\\n```\\nclass Solution {\\npublic:\\n\\t// you can remove the \\'&\\' in case you don\\'t want to update the nums array\\n    vector<int> runningSum(vector<int>& nums) { \\n        for(int i=1;i<nums.size();i++) nums[i]+=nums[i-1]; //prefix sum calculation\\n        return nums;\\n    }\\n};\\n```\\n****\\n**Time Complexity : O(N)**, Where `N` is the size of the `nums`\\n**Space Complexity : O(1)**\\n****\\n****\\n![image](https://assets.leetcode.com/users/images/b2c1e604-038b-450f-ad18-becf9d03b26e_1654052909.841381.png)\\n****\\n\\n[https://en.wikipedia.org/wiki/Prefix_sum](http://) **If you want to know what prefix sum is actually.**\\n****\\n****\\n**STL - Partial_Sum Approach (C++) :**\\n```\\nclass Solution {\\npublic:\\nvector<int> runningSum(vector<int>& nums) {\\n    partial_sum(begin(nums), end(nums), begin(nums));\\n    return nums;\\n\\t}\\n};\\n```\\n****\\n****\\n**Time Complexity : O(N)**, Where `N` is the size of the `nums`\\n**Space Complexity : O(1)**\\n****\\n![image](https://assets.leetcode.com/users/images/87832640-c441-4cf4-b992-bc8f6eacf1cd_1654062822.817285.png)\\n****\\n****\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// you can remove the \\'&\\' in case you don\\'t want to update the nums array\\n    vector<int> runningSum(vector<int>& nums) { \\n        for(int i=1;i<nums.size();i++) nums[i]+=nums[i-1]; //prefix sum calculation\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nvector<int> runningSum(vector<int>& nums) {\\n    partial_sum(begin(nums), end(nums), begin(nums));\\n    return nums;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841274,
                "title": "python-3-multiple-one-liners",
                "content": "Solution 1: \\nIterate through the list and append the sum of **```nums[:i+1]```** at every iteration.\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        return [sum(nums[:i+1]) for i in range(len(nums))]\\n```\\nSolution 2: \\nThe same logic as above, this time using **```enumerate()```**.\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n\\t\\treturn [sum(nums[:i]) for i, e in enumerate(nums, 1)]\\n```\\n\\nSolution 3: \\nUsing in-built function, **```itertools.accumulate()```**.\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n\\t\\treturn accumulate(nums)\\n```\\n\\nSolution 4: \\n**Simple, iterative approach**, cumulative sum by updating each element in the array with the sum of previous elements.\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n\\t\\tfor i in range(1, len(nums)):\\n\\t\\t\\tnums[i] = nums[i] + nums[i-1]\\n        return nums\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```nums[:i+1]```\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        return [sum(nums[:i+1]) for i in range(len(nums))]\\n```\n```enumerate()```\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n\\t\\treturn [sum(nums[:i]) for i, e in enumerate(nums, 1)]\\n```\n```itertools.accumulate()```\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n\\t\\treturn accumulate(nums)\\n```\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n\\t\\tfor i in range(1, len(nums)):\\n\\t\\t\\tnums[i] = nums[i] + nums[i-1]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686373,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar runningSum = function(nums) {\\n    for(let i=1;i<nums.length;i++){\\n        nums[i]+=nums[i-1]\\n    }\\n    return nums\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar runningSum = function(nums) {\\n    for(let i=1;i<nums.length;i++){\\n        nums[i]+=nums[i-1]\\n    }\\n    return nums\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2096870,
                "title": "one-liner-javascript-solution",
                "content": "One Liner\\n``` js\\nvar runningSum = ((nums, val = 0) => nums.map(x => val = val + x))\\n```\\n\\nPlease upvote if helpful!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` js\\nvar runningSum = ((nums, val = 0) => nums.map(x => val = val + x))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3417099,
                "title": "three-lines-of-code-for-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity:99%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:88%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst runningSum = nums => {\\n  let sum = 0;\\n  return nums.map(num => sum += num);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst runningSum = nums => {\\n  let sum = 0;\\n  return nums.map(num => sum += num);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3222530,
                "title": "simple-and-nice-approach-0-ms-runtime-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI thought of just keep on adding sum and return. That gave me error, because I didn\\'t read the question properly xD. I just added 2 extra lines of code to it. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First initialize total sum and return vector. \\n- Then, iterate each element in nums vector. \\n- Keep on adding sum to the iterative value and keep on pushing new sum value to return array\\n- Return the array. WOW!!! Profit!!! Nice :)\\n\\n##### Pls upvote this multilingual solution\\n\\n# Code\\n### C++\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sums = 0;\\n        vector<int> retSums;\\n        for(auto i : nums) {\\n            sums += i;\\n            retSums.push_back(sums);\\n        }\\n        return retSums;\\n    }\\n};\\n```\\n### Python\\n```python\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        sums=0\\n        retSum=[]\\n        for i in nums:\\n            sums+=i\\n            retSum.append(sums)\\n        return retSum\\n```\\n### Rust\\n```rust\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        let mut sum = 0;\\n        let mut retValue:Vec<i32> = Vec::new();\\n        for num in nums {\\n            sum += num;\\n            retValue.push(sum);\\n        }\\n        retValue\\n    }\\n}\\n```\\n### Javascript\\n```js\\nvar runningSum = function(nums) {\\n    let sums = 0;\\n    let retSums = [];\\n    for(let i of nums) {\\n        sums += i;\\n        retSums.push(sums);\\n    }\\n    return retSums;\\n}\\n```\\n### Java\\n```java\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sums = 0;\\n        int[] retSums = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            sums += nums[i];\\n            retSums[i] = sums;\\n        }\\n        return retSums;\\n    }\\n}\\n```\\n![Screenshot 2023-03-31 123451.png](https://assets.leetcode.com/users/images/2d8c6ac2-0d70-4e56-9c24-5d4aee04e91e_1680246415.857811.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Rust"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sums = 0;\\n        vector<int> retSums;\\n        for(auto i : nums) {\\n            sums += i;\\n            retSums.push_back(sums);\\n        }\\n        return retSums;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        sums=0\\n        retSum=[]\\n        for i in nums:\\n            sums+=i\\n            retSum.append(sums)\\n        return retSum\\n```\n```rust\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        let mut sum = 0;\\n        let mut retValue:Vec<i32> = Vec::new();\\n        for num in nums {\\n            sum += num;\\n            retValue.push(sum);\\n        }\\n        retValue\\n    }\\n}\\n```\n```js\\nvar runningSum = function(nums) {\\n    let sums = 0;\\n    let retSums = [];\\n    for(let i of nums) {\\n        sums += i;\\n        retSums.push(sums);\\n    }\\n    return retSums;\\n}\\n```\n```java\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sums = 0;\\n        int[] retSums = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            sums += nums[i];\\n            retSums[i] = sums;\\n        }\\n        return retSums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526051,
                "title": "multiple-c-solution-brute-force-and-using-stl",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Using *****Brute force approach*****\\n- We simply took a counter ***(count)*** to store the sum till the current index.\\n- Run a loop & in every iteration add the current value to count.\\n- Push the value to ans vector.\\n- **Time complexity:** O(n).\\n\\n### Solution 02\\n\\n- Using *****STL function*****\\n- It takes 3 parameters: `first`,\\xA0`last` &`sum`.\\n- **Time complexity:** O(*n\\xD7k*), where\\xA0*n*\\xA0is the distance from\\xA0`first`\\xA0to\\xA0`last`,\\xA0*O(k)*\\xA0is the complexity of\\xA0the function.\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        int n=nums.size();\\n        int count =0;\\n        \\n        for(int i=0; i<n; i++){\\n            count += nums[i];\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        \\n        for(int i=1; i<=nums.size(); i++)\\n            ans.push_back(accumulate(nums.begin(), (nums.begin()+i), 0));\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution** \\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        int n=nums.size();\\n        int count =0;\\n        \\n        for(int i=0; i<n; i++){\\n            count += nums[i];\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        \\n        for(int i=1; i<=nums.size(); i++)\\n            ans.push_back(accumulate(nums.begin(), (nums.begin()+i), 0));\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189005,
                "title": "js-python-java-c-easy-prefix-sum-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nWhile this is not a terribly challenging problem, it\\'s a good introduction to the concept of a **prefix sum array**. Prefix sum arrays have many uses in more complex algorithms and can sometimes help reduce the time complexity of a advanced solution by an order of magnitude.\\n\\nIn a prefix sum array, we will create a duplicate array which contains the running sum of the elements **0** to **i** of our original array (**nums**) for each index **i** of our prefix sum array (**ans**). _(**Note**: We can lower the **space complexity** by using an **in-place** approach with **nums** directly and mutating it into its own prefix sum array, if there is no compelling reason to avoid modifying a function argument.)_\\n\\nSince we\\'ll need to build on a previous running total, we should start our iteration at **i = 1** and copy over the first element from **nums** to **ans**. Then we just iterate through **nums** and add each element (**nums[i]**) to the previous running total (**ans[i-1]**) to create the new running total (**ans[i]**).\\n\\nWhen we\\'re done, we can **return ans**.\\n\\n - _**Time Complexity: O(N)** where **N** is the length of nums_\\n - _**Space Complexity: O(N)** for our running sum array_\\n    - _or **O(1)** with an in-place approach_\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar runningSum = function(nums) {\\n    let ans = new Array(nums.length)\\n    ans[0] = nums[0]\\n    for (let i = 1; i < nums.length; i++)\\n        ans[i] = ans[i-1] + nums[i]\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n```python\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        ans = [0] * len(nums)\\n        ans[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            ans[i] = ans[i-1] + nums[i]\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n    int[] ans = new int[nums.length];\\n    ans[0] = nums[0];\\n    for (int i = 1; i < nums.length; i++)\\n        ans[i] = ans[i-1] + nums[i];\\n    return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        ans[0] = nums[0];\\n        for (int i = 1; i < nums.size(); i++)\\n            ans[i] = ans[i-1] + nums[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar runningSum = function(nums) {\\n    let ans = new Array(nums.length)\\n    ans[0] = nums[0]\\n    for (let i = 1; i < nums.length; i++)\\n        ans[i] = ans[i-1] + nums[i]\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        ans = [0] * len(nums)\\n        ans[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            ans[i] = ans[i-1] + nums[i]\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n    int[] ans = new int[nums.length];\\n    ans[0] = nums[0];\\n    for (int i = 1; i < nums.length; i++)\\n        ans[i] = ans[i-1] + nums[i];\\n    return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        ans[0] = nums[0];\\n        for (int i = 1; i < nums.size(); i++)\\n            ans[i] = ans[i-1] + nums[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535362,
                "title": "100-fast-c-lang",
                "content": "```\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    int sum=0;\\n    *returnSize = numsSize; //size for the new array to be returned\\n    \\nfor(int i=0;i<numsSize;i++)\\n    {\\n       sum=sum+nums[i];\\n        nums[i]=sum;\\n    }\\n    return nums;\\n}\\n```\\ndo upvote if you understand the soluntion.",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    int sum=0;\\n    *returnSize = numsSize; //size for the new array to be returned\\n    \\nfor(int i=0;i<numsSize;i++)\\n    {\\n       sum=sum+nums[i];\\n        nums[i]=sum;\\n    }\\n    return nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2744442,
                "title": "java-runtime-0ms-faster-than-100-memory-usage-less-than-97-1",
                "content": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[i - 1];\\n        }\\n        return nums;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/18ee87a3-e5b1-4980-83ea-dddd559df842_1666751086.5643325.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[i - 1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691189,
                "title": "java-c-python-prefix-sum",
                "content": "# Explanation\\nLet `B[i] = A[0] + A[1] + .. + A[i]`\\n`B[i] = B[i-1] + A[i]`\\n<br>\\n\\n# Complexity\\nTime `O(N)`\\nSpace `O(N)`\\nSpace `O(1)` if changing the input, like in Java.\\n\\n**Java:**\\n```java\\n    public int[] runningSum(int[] A) {\\n        for (int i = 1; i < A.length; ++i)\\n            A[i] += A[i - 1];\\n        return A;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    vector<int> runningSum(vector<int> A) {\\n        partial_sum(begin(A), end(A), begin(A));\\n        return A;\\n    }\\n```\\n\\n**Python3:**\\n1 line, return a list\\n```py\\n    def runningSum(self, A):\\n        return list(itertools.accumulate(A))\\n```\\n0 line, return an iterator\\n```py\\n    runningSum = accumulate\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int[] runningSum(int[] A) {\\n        for (int i = 1; i < A.length; ++i)\\n            A[i] += A[i - 1];\\n        return A;\\n    }\\n```\n```cpp\\n    vector<int> runningSum(vector<int> A) {\\n        partial_sum(begin(A), end(A), begin(A));\\n        return A;\\n    }\\n```\n```py\\n    def runningSum(self, A):\\n        return list(itertools.accumulate(A))\\n```\n```py\\n    runningSum = accumulate\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 687012,
                "title": "java-stream-solution-in-one-line",
                "content": "Runtime: **3 ms**, faster than 100.00% of Java online submissions for Running Sum of 1d Array.\\nMemory Usage: **39.9 MB**, less than 50.00% of Java online submissions for Running Sum of 1d Array.\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        return IntStream.range(0,nums.length).map(i->i==0?nums[i]:(nums[i]+=nums[i-1])).toArray();    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        return IntStream.range(0,nums.length).map(i->i==0?nums[i]:(nums[i]+=nums[i-1])).toArray();    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954633,
                "title": "typescript-solution-easy-map",
                "content": "# Code\\n```\\nfunction runningSum(nums: number[]): number[] {\\n     let result: number = 0;\\n     return nums.map(item => result += item);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction runningSum(nums: number[]): number[] {\\n     let result: number = 0;\\n     return nums.map(item => result += item);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2306599,
                "title": "easy-to-understand-python-solution",
                "content": "#### **Final Code:**\\nTime Complexity: **O(n)**\\n```\\nclass Solution(object):\\n    def runningSum(self, nums):\\n        result = []\\n        current_sum = 0\\n        for i in range(0, len(nums)):\\n            result.append(current_sum + nums[i])\\n            current_sum = result[i]\\n        return result\\n```\\n\\n#### **Steps:**\\n* **Step1:**  \\nCreate a new array which can be returned as our result:\\n```result = [ ]  # empty array```\\n\\n* **Step2:**\\nNow let\\'s keep track of current sum:\\n```current_sum = 0  # It\\'s zero for now```\\n\\n* **Step3:**\\nFor every element we encounter in \\'nums\\', add it with current sum and append it to result, then change the value of current_sum to the current element in result\\n(Because we want to add it in the next iteration):\\n```\\n\\tfor i in range(0, len(nums)):\\n\\t\\tresult.append(current_sum + nums[i])\\n\\t\\tcurrent_sum = result[i]\\n```\\n\\n* **Step4:**\\nFinally return the result:\\n```return result```\\n\\n\\n**I hope that you\\'ve found this useful.**\\n**If so, consider leaving an upvote \\uD83D\\uDE01**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def runningSum(self, nums):\\n        result = []\\n        current_sum = 0\\n        for i in range(0, len(nums)):\\n            result.append(current_sum + nums[i])\\n            current_sum = result[i]\\n        return result\\n```\n```result = [ ]  # empty array```\n```current_sum = 0  # It\\'s zero for now```\n```\\n\\tfor i in range(0, len(nums)):\\n\\t\\tresult.append(current_sum + nums[i])\\n\\t\\tcurrent_sum = result[i]\\n```\n```return result```",
                "codeTag": "Java"
            },
            {
                "id": 2096129,
                "title": "python-almost-one-line-solution-faster-than-97-54",
                "content": "Any one need explanation please ask,\\nHere we also learning how can we use assignment inside comprehension \\uD83D\\uDE01 using `:`\\n\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        s = 0\\n        return [s:=s+v for _, v in enumerate(nums)]\\n```\\n\\n![image](https://assets.leetcode.com/users/images/56798120-f222-4969-8fe1-4ae19e3ed185_1654046926.4836757.png)\\n\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        s = 0\\n        return [s:=s+v for _, v in enumerate(nums)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688524,
                "title": "ruby",
                "content": "```\\ndef running_sum(nums)\\n  total = 0\\n  nums.map { |number| total += number }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef running_sum(nums)\\n  total = 0\\n  nums.map { |number| total += number }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3063821,
                "title": "java-0ms",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907545,
                "title": "c-simple-solution",
                "content": "Fastest possible c# solution\\n```\\npublic int[] RunningSum(int[] nums) \\n{\\n\\tfor (int i = 1; i < nums.Length; ++i) \\n\\t{\\n\\t\\tnums[i] += nums[i - 1]; \\n\\t}\\n\\treturn nums;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] RunningSum(int[] nums) \\n{\\n\\tfor (int i = 1; i < nums.Length; ++i) \\n\\t{\\n\\t\\tnums[i] += nums[i - 1]; \\n\\t}\\n\\treturn nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2330765,
                "title": "golang-faster-than-100-submissions-o-n",
                "content": "```\\nfunc runningSum(nums []int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t    nums[i] = nums[i] + nums[i-1]\\n\\t}\\n\\treturn nums\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc runningSum(nums []int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t    nums[i] = nums[i] + nums[i-1]\\n\\t}\\n\\treturn nums\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1265815,
                "title": "c-faster-than-86-46-using-system-linq",
                "content": "![image](https://assets.leetcode.com/users/images/1fe65e59-608a-493e-b603-b589ad8ac6e6_1623446237.0302718.png)\\n\\n```\\nusing System.Linq;\\npublic class Solution {\\n    public int[] RunningSum(int[] nums) {\\n       int c = 0;\\n       return nums.Select(n => c += n).ToArray();\\n    }\\n}\\n````",
                "solutionTags": [
                    "C",
                    "C#"
                ],
                "code": "```\\nusing System.Linq;\\npublic class Solution {\\n    public int[] RunningSum(int[] nums) {\\n       int c = 0;\\n       return nums.Select(n => c += n).ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 689727,
                "title": "rust-0ms-2-1mb",
                "content": "```\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        let mut pre_sum = 0;\\n        nums.into_iter().map(|num| {\\n            pre_sum += num;\\n            pre_sum\\n        }).collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        let mut pre_sum = 0;\\n        nums.into_iter().map(|num| {\\n            pre_sum += num;\\n            pre_sum\\n        }).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 842159,
                "title": "js-javascript-one-line-solution-with-explanation-and-trace",
                "content": "```js\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar runningSum = function(nums) {\\n/*\\n    The current array index is increamented by the accumlator which is the new value of arr[i]\\n    \\n    Example trace:\\n    \\n    input:\\n    [1,2,3,4]\\n    \\n        acc i  arr                return value\\n        0   0  1,2,3,4            0 + 1 = 1\\n        1   1  1,2,3,4            1 + 2 = 3\\n        3   2  1,3,3,4            3 + 3 = 6\\nend  => 6   3  1,3,6,4            6 + 4 = 10\\n        10  4  1,3,6,10\\n    \\n*/\\n    nums.reduce((acc, _, i, arr) => arr[i] += acc )\\n    return nums\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar runningSum = function(nums) {\\n/*\\n    The current array index is increamented by the accumlator which is the new value of arr[i]\\n    \\n    Example trace:\\n    \\n    input:\\n    [1,2,3,4]\\n    \\n        acc i  arr                return value\\n        0   0  1,2,3,4            0 + 1 = 1\\n        1   1  1,2,3,4            1 + 2 = 3\\n        3   2  1,3,3,4            3 + 3 = 6\\nend  => 6   3  1,3,6,4            6 + 4 = 10\\n        10  4  1,3,6,10\\n    \\n*/\\n    nums.reduce((acc, _, i, arr) => arr[i] += acc )\\n    return nums\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686302,
                "title": "simple-swift-solution",
                "content": "```\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\n    var arr : [Int] = []\\n    var sum = 0\\n    for n in nums{\\n        sum += n\\n        arr.append(sum)\\n    }\\n    return arr\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\n    var arr : [Int] = []\\n    var sum = 0\\n    for n in nums{\\n        sum += n\\n        arr.append(sum)\\n    }\\n    return arr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2680759,
                "title": "c-solution",
                "content": "Tip: never use ```nums[i] = nums[i] + nums[i-1];``` in place of ```nums[i] += nums[i-1];```\\n\\nThe time and space complexity increases in the former case.\\n\\nThis code beats 40% in time & 100% in space complexity\\n\\n*Please upvote to motivate me to write more solutions*\\n\\n# Code [C]\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    *returnSize = numsSize;\\n    for (int i=1; i<numsSize; i++) {\\n        nums[i] += nums[i-1];\\n    }\\n    return nums;\\n}\\n```\\n\\n## Visit my GitHub: https://github.com/crimsonKn1ght",
                "solutionTags": [
                    "C"
                ],
                "code": "```nums[i] = nums[i] + nums[i-1];```\n```nums[i] += nums[i-1];```\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    *returnSize = numsSize;\\n    for (int i=1; i<numsSize; i++) {\\n        nums[i] += nums[i-1];\\n    }\\n    return nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1195474,
                "title": "big-brain-solution",
                "content": "```\\nvar runningSum = function(nums) {\\n    let runningTotal = 0;\\nreturn nums.map(num => runningTotal += num);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar runningSum = function(nums) {\\n    let runningTotal = 0;\\nreturn nums.map(num => runningTotal += num);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1189120,
                "title": "python-oneliner-using-accumulate-explained",
                "content": "In python we can use functionality of language and directly use `accumulate` function, which will give you iterator, which we need to transform to list. And this is all we need to do here. \\n\\n#### Complexity\\nTime and space complexity is `O(n)`, where `n` is the length of `nums`.\\n\\n#### Code\\n```\\nclass Solution:\\n    def runningSum(self, nums):\\n        return list(accumulate(nums))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums):\\n        return list(accumulate(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982633,
                "title": "coderaky-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1;i<nums.size();i++)\\n            nums[i]+=nums[i-1];\\n        return nums;\\n    }\\n};\\n```\\nhttps://github.com/coderaky/leetcoder \\uD83D\\uDE4C",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1;i<nums.size();i++)\\n            nums[i]+=nums[i-1];\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755070,
                "title": "my-python-solution-runtime-93-07-memory-100",
                "content": "Hey!\\n\\nNothing special and not the most elegant approach for sure. I wanted to leave it here anyways. Sometimes I find it hard to understand one-line sophisticated solutions, so I think maybe someone can find this helpful:\\n\\n```\\nclass Solution(object):\\n    def runningSum(self, nums):     \\n        n = len(nums)\\n        result = list()\\n        \\n        if n == 0: return result\\n\\t\\t\\n        currentSum = 0\\n        for i in range(n):\\n            currentSum += nums[i]\\n            result.append(currentSum)\\n        \\n        return result\\n```\\n\\n*Runtime: 24 ms, faster than 93.07% of Python online submissions for Running Sum of 1d Array.\\nMemory Usage: 12.8 MB, less than 100.00% of Python online submissions for Running Sum of 1d Array.*",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def runningSum(self, nums):     \\n        n = len(nums)\\n        result = list()\\n        \\n        if n == 0: return result\\n\\t\\t\\n        currentSum = 0\\n        for i in range(n):\\n            currentSum += nums[i]\\n            result.append(currentSum)\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686348,
                "title": "c-simple-o-n-time-o-1-space-solution",
                "content": "```csharp\\npublic int[] RunningSum(int[] nums) \\n{\\n\\tint sum = 0;\\n\\tint[] result= new int[nums.Length];\\n\\tfor(int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tsum += nums[i];\\n\\t\\tresult[i] = sum;\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int[] RunningSum(int[] nums) \\n{\\n\\tint sum = 0;\\n\\tint[] result= new int[nums.Length];\\n\\tfor(int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tsum += nums[i];\\n\\t\\tresult[i] = sum;\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1300739,
                "title": "go-o-n-memory-o-1-space",
                "content": "```\\nfunc runningSum(nums []int) []int {\\n    for i:= 1; i< len(nums); i++ {\\n        nums[i] += nums[i-1]\\n    }\\n    return nums\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc runningSum(nums []int) []int {\\n    for i:= 1; i< len(nums); i++ {\\n        nums[i] += nums[i-1]\\n    }\\n    return nums\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 712165,
                "title": "python-less-than-100-memory-usage",
                "content": "```\\n\\t\\tlst = []\\n        num = 1\\n        while len(lst) != len(nums):\\n            lst.append(sum((nums[0:num])))\\n            num += 1\\n        return lst\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tlst = []\\n        num = 1\\n        while len(lst) != len(nums):\\n            lst.append(sum((nums[0:num])))\\n            num += 1\\n        return lst\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2868456,
                "title": "rust-two-fast-solutions",
                "content": "# **Hey,Bro! This is my quick solutions**\\nFIRST\\n\\n\\n    impl Solution {\\n        pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n            let (mut result,mut array) = (0,Vec::with_capacity(nums.len()));\\n            for  i in 0..=nums.len()-1 {\\n                result = result + nums[i];\\n                array.push(result);\\n            }\\n            array\\n        }\\n    }\\n\\n\\n\\nSECOND\\n\\n        impl Solution {\\n\\n            pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n\\n            let mut sum = 0;\\n\\n            nums.into_iter().map(|x| {sum += x; sum}).collect::<Vec<i32>>()\\n\\n            }\\n        }\\n\\n# **If you like it ,please, push arrow to lift up solution to the top ,thanks!**",
                "solutionTags": [
                    "Rust",
                    "Array"
                ],
                "code": "# **Hey,Bro! This is my quick solutions**\\nFIRST\\n\\n\\n    impl Solution {\\n        pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n            let (mut result,mut array) = (0,Vec::with_capacity(nums.len()));\\n            for  i in 0..=nums.len()-1 {\\n                result = result + nums[i];\\n                array.push(result);\\n            }\\n            array\\n        }\\n    }\\n\\n\\n\\nSECOND\\n\\n        impl Solution {\\n\\n            pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n\\n            let mut sum = 0;\\n\\n            nums.into_iter().map(|x| {sum += x; sum}).collect::<Vec<i32>>()\\n\\n            }\\n        }\\n\\n# **If you like it ,please, push arrow to lift up solution to the top ,thanks!**",
                "codeTag": "Unknown"
            },
            {
                "id": 2709615,
                "title": "easy-to-understand-c-solution-time-complexity-o-n-space-complexity-o-1",
                "content": "vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1;i<nums.size();i++) nums[i]+=nums[i-1];\\n        return nums;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1;i<nums.size();i++) nums[i]+=nums[i-1];\\n        return nums;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2399466,
                "title": "2-lines-of-code-100-fast-simple-and-easy",
                "content": "**Running Sum of 1d Array Solution :**\\n\\n**In C++ :**\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1; i<nums.size(); i++) nums[i] += nums[i-1];\\n\\t    return nums;\\n    }\\n};\\n```\\n\\n**In Java :**\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for(int i=1; i<nums.length; i++) nums[i] += nums[i-1];\\n\\t    return nums;\\n    }\\n}\\n```\\n\\n**Runtime: 0 ms**, faster than **100.00%** of Java online submissions for Running Sum of 1d Array.\\nMemory Usage: 43.3 MB, less than 48.96% of Java online submissions for Running Sum of 1d Array.\\n\\n\\n**Happy Coding** \\uD83D\\uDE0A!!!\\nIf you get value from this, then show some love by ***upvoting*** it !!\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1; i<nums.size(); i++) nums[i] += nums[i-1];\\n\\t    return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for(int i=1; i<nums.length; i++) nums[i] += nums[i-1];\\n\\t    return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096323,
                "title": "python-one-liner-with-walrus-operator",
                "content": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        return [tot := nums[0]] + [tot := i+tot for i in nums[1:]]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        return [tot := nums[0]] + [tot := i+tot for i in nums[1:]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132235,
                "title": "php-solution",
                "content": "```\\n// Runtime: 4 ms, faster than 97.05% of PHP online submissions for Running Sum of 1d Array.\\n// Memory Usage: 15.8 MB, less than 87.76% of PHP online submissions for Running Sum of 1d Array.\\nfunction runningSum($nums) {\\n    $current[0] = $nums[0];\\n    for($i = 1; $i < sizeof($nums); $i++) {\\n        $current[$i] = $nums[$i] + $current[$i-1];\\n    }\\n\\n    return $current;\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\n// Runtime: 4 ms, faster than 97.05% of PHP online submissions for Running Sum of 1d Array.\\n// Memory Usage: 15.8 MB, less than 87.76% of PHP online submissions for Running Sum of 1d Array.\\nfunction runningSum($nums) {\\n    $current[0] = $nums[0];\\n    for($i = 1; $i < sizeof($nums); $i++) {\\n        $current[$i] = $nums[$i] + $current[$i-1];\\n    }\\n\\n    return $current;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2681627,
                "title": "java-easy-solution-using-for-loop",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n     int sum = 0;\\n     for(int i = 0; i < nums.length; i ++) {\\n         sum += nums[i];\\n         nums[i] = sum; \\n     } \\n     return nums;  \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n     int sum = 0;\\n     for(int i = 0; i < nums.length; i ++) {\\n         sum += nums[i];\\n         nums[i] = sum; \\n     } \\n     return nums;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187158,
                "title": "c-java-c-c-js-ts-scala-kotlin-php-rust-go-swift-ruby-python3-python-easy-solutions",
                "content": "The running sum of numbers upto ith index is the algebric sum of all elements from index 0 to index i inclusive. Insetead of recalculating the sum, we can use the stored value calculated previously.\\n1.\\n```C++  []\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n      for(int i =1; i< nums.size(); i++)\\n          nums[i] += nums[i-1];\\n      return nums;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n      for(int i=1;i<nums.length;i++) \\n          nums[i]+=nums[i-1];\\n      return nums;\\n    }\\n}\\n```\\n```csharp []\\npublic class Solution {\\n    public int[] RunningSum(int[] nums) {\\n      for(int i=1;i<nums.Length;i++) \\n          nums[i]+=nums[i-1];\\n      return nums;\\n    }\\n}\\n```\\n```C []\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for(int i=1;i<numsSize;i++) \\n        nums[i]+=nums[i-1];\\n\\t*returnSize = numsSize;\\n    return nums;\\n}\\n```\\n2.\\n```javascript []\\nvar runningSum = function(nums) {\\n  for(var i =1; i< nums.length; i++)\\n      nums[i] += nums[i-1];\\n  return nums;\\n};\\n```\\n```TypeScript []\\nfunction runningSum(nums: number[]): number[] {\\n  for(var i =1; i< nums.length; i++)\\n      nums[i] += nums[i-1];\\n  return nums;\\n};\\n```\\n```Scala []\\nobject Solution {\\n    def runningSum(nums: Array[Int]): Array[Int] = {\\n        for(i <- 1 until nums.length)\\n            nums(i)+=nums(i-1);\\n        return nums;\\n    }\\n}\\n```\\n```Kotlin []\\nclass Solution {\\n    fun runningSum(nums: IntArray): IntArray {\\n        for (i in 1 until nums.size)\\n            nums[i] +=nums[i-1]\\n        return nums\\n    }\\n}\\n```\\n3.\\n```PHP []\\nclass Solution {\\n    function runningSum($nums) {\\n        for($i = 1; $i < sizeof($nums); $i++)\\n            $nums[$i] += $nums[$i-1];\\n        return $nums;\\n    }\\n}\\n```\\n```Rust []\\nimpl Solution {\\n    pub fn running_sum(mut nums: Vec<i32>) -> Vec<i32> {\\n        for i in 1..nums.len() {\\n            nums[i] += nums[i-1];\\n        }\\n        nums\\n    }\\n}\\n```\\n```Go []\\nfunc runningSum(nums []int) []int {\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tnums[i] += nums[i-1]\\n\\t}\\n\\treturn nums\\n}\\n```\\n```python3 []\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        curr=0\\n        for i in range(len(nums)):\\n            nums[i]+=curr\\n            curr=nums[i]\\n        return nums\\n```\\n4.\\n```python []\\nclass Solution(object):\\n    def runningSum(self, nums):\\n        curr=0\\n        for i in range(len(nums)):\\n            nums[i]+=curr\\n            curr=nums[i]\\n        return nums\\n```\\n```Swift []\\nclass Solution {\\n    func runningSum(_ nums: [Int]) -> [Int] {\\n        var res = nums\\n        for i in 1..<nums.count {\\n            res[i] += res[i-1]\\n        }\\n        return res\\n    }\\n}\\n```\\n```Ruby []\\ndef running_sum(nums)\\n    return_array=[]\\n    counter=0\\n    for i in 0...nums.length\\n        return_array<<counter+=nums[i] \\n    end\\n    return return_array\\nend\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C#",
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```C++  []\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n      for(int i =1; i< nums.size(); i++)\\n          nums[i] += nums[i-1];\\n      return nums;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n      for(int i=1;i<nums.length;i++) \\n          nums[i]+=nums[i-1];\\n      return nums;\\n    }\\n}\\n```\n```csharp []\\npublic class Solution {\\n    public int[] RunningSum(int[] nums) {\\n      for(int i=1;i<nums.Length;i++) \\n          nums[i]+=nums[i-1];\\n      return nums;\\n    }\\n}\\n```\n```C []\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for(int i=1;i<numsSize;i++) \\n        nums[i]+=nums[i-1];\\n\\t*returnSize = numsSize;\\n    return nums;\\n}\\n```\n```javascript []\\nvar runningSum = function(nums) {\\n  for(var i =1; i< nums.length; i++)\\n      nums[i] += nums[i-1];\\n  return nums;\\n};\\n```\n```TypeScript []\\nfunction runningSum(nums: number[]): number[] {\\n  for(var i =1; i< nums.length; i++)\\n      nums[i] += nums[i-1];\\n  return nums;\\n};\\n```\n```Scala []\\nobject Solution {\\n    def runningSum(nums: Array[Int]): Array[Int] = {\\n        for(i <- 1 until nums.length)\\n            nums(i)+=nums(i-1);\\n        return nums;\\n    }\\n}\\n```\n```Kotlin []\\nclass Solution {\\n    fun runningSum(nums: IntArray): IntArray {\\n        for (i in 1 until nums.size)\\n            nums[i] +=nums[i-1]\\n        return nums\\n    }\\n}\\n```\n```PHP []\\nclass Solution {\\n    function runningSum($nums) {\\n        for($i = 1; $i < sizeof($nums); $i++)\\n            $nums[$i] += $nums[$i-1];\\n        return $nums;\\n    }\\n}\\n```\n```Rust []\\nimpl Solution {\\n    pub fn running_sum(mut nums: Vec<i32>) -> Vec<i32> {\\n        for i in 1..nums.len() {\\n            nums[i] += nums[i-1];\\n        }\\n        nums\\n    }\\n}\\n```\n```Go []\\nfunc runningSum(nums []int) []int {\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tnums[i] += nums[i-1]\\n\\t}\\n\\treturn nums\\n}\\n```\n```python3 []\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        curr=0\\n        for i in range(len(nums)):\\n            nums[i]+=curr\\n            curr=nums[i]\\n        return nums\\n```\n```python []\\nclass Solution(object):\\n    def runningSum(self, nums):\\n        curr=0\\n        for i in range(len(nums)):\\n            nums[i]+=curr\\n            curr=nums[i]\\n        return nums\\n```\n```Swift []\\nclass Solution {\\n    func runningSum(_ nums: [Int]) -> [Int] {\\n        var res = nums\\n        for i in 1..<nums.count {\\n            res[i] += res[i-1]\\n        }\\n        return res\\n    }\\n}\\n```\n```Ruby []\\ndef running_sum(nums)\\n    return_array=[]\\n    counter=0\\n    for i in 0...nums.length\\n        return_array<<counter+=nums[i] \\n    end\\n    return return_array\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805438,
                "title": "in-c",
                "content": "```\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    int i;\\n    int* result = (int*)malloc(numsSize*sizeof(int)); \\n    result[i]=0;\\n    result[i] = result[i]+nums[i];\\n    for(i=1;i<numsSize;i++){\\n        result[i] = result[i-1]+nums[i];\\n    }\\n\\t*returnSize = numsSize;\\n    return result;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    int i;\\n    int* result = (int*)malloc(numsSize*sizeof(int)); \\n    result[i]=0;\\n    result[i] = result[i]+nums[i];\\n    for(i=1;i<numsSize;i++){\\n        result[i] = result[i-1]+nums[i];\\n    }\\n\\t*returnSize = numsSize;\\n    return result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3261883,
                "title": "array-in-place-solution-o-1-extra-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar runningSum = function(nums) {\\n    for(let i=1; i<nums.length; i++){\\n        nums[i] = nums[i-1] + nums[i];\\n    }\\n    return nums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar runningSum = function(nums) {\\n    for(let i=1; i<nums.length; i++){\\n        nums[i] = nums[i-1] + nums[i];\\n    }\\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2796847,
                "title": "java-3-lines-100-faster-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[i - 1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[i - 1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734958,
                "title": "solution-in-java-simple-w-explanation-1-ms",
                "content": "Start from the second element, keep adding the previous element in the array while going forward.\\n\\n* Why do we start from second element (`nums[1]`) and not first element (`nums[0]`)?\\n-> This is because the first element will always be the same because it doesn\\'t have any previous element to add it to.\\n* Why do we keep adding the previous element?\\n-> We can have a sum count before we start the loop and keep adding the last element and put it in the sum, then add it to the current element and put it there. But instead we can just count the sum of previous element and current element and put it, then move ahead and we will have the solution.\\n\\t* Example: [1,2,3,4]\\n\\t\\t* Sum method:\\n\\t\\t\\t* sum = 0\\n\\t\\t\\t* At each iteration, sum = 1, 3, 6, 10 and we keep putting these elements in the list\\n\\t\\t* Running sum method\\n\\t\\t\\t* given = [1,2,3,4]\\n\\t\\t\\t* just keep adding the last element and keep putting it, [1,3,6,10] but we do not need an extra sum count here.\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[i-1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[i-1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098250,
                "title": "kotlin-one-liner",
                "content": "```\\n    fun runningSum(nums: IntArray): IntArray =\\n       nums.also { (1..nums.lastIndex).forEach { nums[it] += nums[it-1] } } \\n```\\nP.S. There is a built-in function `runningReduce` but leetcode doesn\\'t support it sadly.",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun runningSum(nums: IntArray): IntArray =\\n       nums.also { (1..nums.lastIndex).forEach { nums[it] += nums[it-1] } } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2096299,
                "title": "c-2-approach-using-prefix-sum",
                "content": "**Solution 1 :**  Using extra memory for storing result\\nThis approach can be used when input array is read-only.\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int length = nums.size();\\n        vector<int> res(length);\\n        res[0] = nums[0];\\n        for(int i = 1; i < length; i++)\\n            res[i] = nums[i] + res[i - 1];\\n        return res;\\n    }\\n};\\n```\\nTC : O(n)\\nSC : O(n)\\n\\n**Solution 2** : Using input array to store result\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i = 1; i < nums.size(); i++)\\n            nums[i] = nums[i] + nums[i - 1];\\n        return nums;\\n    }\\n};\\n```\\nTC : O(n)\\nSC : O(1)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int length = nums.size();\\n        vector<int> res(length);\\n        res[0] = nums[0];\\n        for(int i = 1; i < length; i++)\\n            res[i] = nums[i] + res[i - 1];\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i = 1; i < nums.size(); i++)\\n            nums[i] = nums[i] + nums[i - 1];\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686317,
                "title": "java-python-3-3-1-liner-accumulate",
                "content": "\\n```java\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++)\\n            nums[i] += nums[i - 1];\\n        return nums;\\n    }\\n```\\n```python\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        return list(itertools.accumulate(nums))\\n```\\nBTW, not only \\n```\\n        return [*itertools.accumulate(nums)]\\n```\\nbut also\\n```\\n        return itertools.accumulate(nums) # credit to @todor91\\n```\\nand \\n```\\n        return accumulate(nums) # credit to @todor91\\n```\\naccepted.",
                "solutionTags": [],
                "code": "```java\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++)\\n            nums[i] += nums[i - 1];\\n        return nums;\\n    }\\n```\n```python\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        return list(itertools.accumulate(nums))\\n```\n```\\n        return [*itertools.accumulate(nums)]\\n```\n```\\n        return itertools.accumulate(nums) # credit to @todor91\\n```\n```\\n        return accumulate(nums) # credit to @todor91\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3396738,
                "title": "simple-solution-by-java-in-runtime-3-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int [] sol = new int[nums.length];\\n\\n        for (int i = nums.length-1 ; i >= 0 ; i--) {\\n            for (int j = i; j >= 0 ; j--) {\\n                sol[i] +=nums[j];\\n            }\\n        }\\n\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int [] sol = new int[nums.length];\\n\\n        for (int i = nums.length-1 ; i >= 0 ; i--) {\\n            for (int j = i; j >= 0 ; j--) {\\n                sol[i] +=nums[j];\\n            }\\n        }\\n\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389843,
                "title": "java-solution-with-super-logic",
                "content": "\\n# Java Solution with Super Logic\\n```\\nclass Solution {\\n    public int[] runningSum(int nums[]){\\n        for(int i=0;i<nums.length-1;i++){\\n            nums[i+1]=nums[i]+nums[i+1];\\n        }\\n        return nums;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int nums[]){\\n        for(int i=0;i<nums.length-1;i++){\\n            nums[i+1]=nums[i]+nums[i+1];\\n        }\\n        return nums;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117107,
                "title": "accepted-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        nums[i]+=nums[i-1];\\n        return nums;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        nums[i]+=nums[i-1];\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086350,
                "title": "c-easy-3-line",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] RunningSum(int[] nums) \\n    {\\n        for(int i = 1; i < nums.Length; i++)\\n        {\\n            nums[i] += nums[i - 1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] RunningSum(int[] nums) \\n    {\\n        for(int i = 1; i < nums.Length; i++)\\n        {\\n            nums[i] += nums[i - 1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023839,
                "title": "simple-python-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        # The variable that will have the running sum\\n        tot = 0\\n        # The array that will hold the running su,\\n        ans = []\\n        # For loop\\n        for ele in nums:\\n            # Adding the element\\n            tot += ele\\n            # Appending this running sum to ans\\n            ans.append(tot)\\n        # Return ans\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        # The variable that will have the running sum\\n        tot = 0\\n        # The array that will hold the running su,\\n        ans = []\\n        # For loop\\n        for ele in nums:\\n            # Adding the element\\n            tot += ele\\n            # Appending this running sum to ans\\n            ans.append(tot)\\n        # Return ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618412,
                "title": "brute-force-optimize-c-stl-solution",
                "content": "**Approach: 1** \\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n**Condition:**  *If we not allowed to change the given array.*\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n**Solution : 01**\\n\\n\\n* Using **Brute force approach**\\n* We simply took a counter (sum) to store the sum till the current index.\\n* Run a loop & in every iteration add the current value to sum.\\n* Push the value(sum) to ans vector.\\n* Return the ans vector.\\n\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n**Solution:**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int>ans;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size();i++)\\n        {\\n            sum = sum + nums[i];\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n\\n**Analysis:**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n**Time Complexity** : `O(n) ` -----> As we are iterating through all the elements of the array.\\n**Space Complexity** : `O(n)`  ----> Where n is the size of the Vector we created.\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n**Approach: 2**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\nIf we are allowed to change the given array we can solve this problem in place(i.e without using extra space.)\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\nSolution: \\n\\n------------------------------------------------------------------------------------------------------------------------------\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i = 1; i < n;i++)\\n        {\\n            nums[i] = nums[i] + nums[i-1];\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n\\n**Analysis:**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n**Time Complexity** : `O(n) ` -----> As we are iterating through all the elements of the array.\\n**Space Complexity** : `O(1)`  ----> In place solution (i.e Without using the extra space).\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n**Approach: 3**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\nBy using the **C++ STL partial_sum**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n**solution:**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        partial_sum(begin(nums),end(nums),begin(nums));\\n        return nums;\\n    }\\n};\\n```\\n\\n\\n**Analysis:**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n**Time Complexity** : `O(n) ` -----> As we are iterating through all the elements of the array.\\n**Space Complexity** : `O(1)`  ----> In place solution (i.e Without using the extra space).\\n\\n------------------------------------------------------------------------------------------------------------------------------\\nIf this solution helps you then please` Upvote.`\\n\\n*Thank You!!!*\\n\\nIf any doubt/ mistake feel free to comment.\\n\\n**Keep learning, Keep Growing !!!**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int>ans;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size();i++)\\n        {\\n            sum = sum + nums[i];\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i = 1; i < n;i++)\\n        {\\n            nums[i] = nums[i] + nums[i-1];\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        partial_sum(begin(nums),end(nums),begin(nums));\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329597,
                "title": "python-o-n-simple-solution-easy-and-fast",
                "content": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums)):\\n            nums[i] = nums[i] + nums[i-1]\\n        return nums\\n```\\nUPVOTE if you like ^_^",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums)):\\n            nums[i] = nums[i] + nums[i-1]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189009,
                "title": "running-sum-of-1d-array-js-python-java-c-easy-prefix-sum-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nWhile this is not a terribly challenging problem, it\\'s a good introduction to the concept of a **prefix sum array**. Prefix sum arrays have many uses in more complex algorithms and can sometimes help reduce the time complexity of a advanced solution by an order of magnitude.\\n\\nIn a prefix sum array, we will create a duplicate array which contains the running sum of the elements **0** to **i** of our original array (**nums**) for each index **i** of our prefix sum array (**ans**). _(**Note**: We can lower the **space complexity** by using an **in-place** approach with **nums** directly and mutating it into its own prefix sum array, if there is no compelling reason to avoid modifying a function argument.)_\\n\\nSince we\\'ll need to build on a previous running total, we should start our iteration at **i = 1** and copy over the first element from **nums** to **ans**. Then we just iterate through **nums** and add each element (**nums[i]**) to the previous running total (**ans[i-1]**) to create the new running total (**ans[i]**).\\n\\nWhen we\\'re done, we can **return ans**.\\n\\n - _**Time Complexity: O(N)** where **N** is the length of nums_\\n - _**Space Complexity: O(N)** for our running sum array_\\n    - _or **O(1)** with an in-place approach_\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar runningSum = function(nums) {\\n    let ans = new Array(nums.length)\\n    ans[0] = nums[0]\\n    for (let i = 1; i < nums.length; i++)\\n        ans[i] = ans[i-1] + nums[i]\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n```python\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        ans = [0] * len(nums)\\n        ans[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            ans[i] = ans[i-1] + nums[i]\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n    int[] ans = new int[nums.length];\\n    ans[0] = nums[0];\\n    for (int i = 1; i < nums.length; i++)\\n        ans[i] = ans[i-1] + nums[i];\\n    return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        ans[0] = nums[0];\\n        for (int i = 1; i < nums.size(); i++)\\n            ans[i] = ans[i-1] + nums[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar runningSum = function(nums) {\\n    let ans = new Array(nums.length)\\n    ans[0] = nums[0]\\n    for (let i = 1; i < nums.length; i++)\\n        ans[i] = ans[i-1] + nums[i]\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        ans = [0] * len(nums)\\n        ans[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            ans[i] = ans[i-1] + nums[i]\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n    int[] ans = new int[nums.length];\\n    ans[0] = nums[0];\\n    for (int i = 1; i < nums.length; i++)\\n        ans[i] = ans[i-1] + nums[i];\\n    return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        ans[0] = nums[0];\\n        for (int i = 1; i < nums.size(); i++)\\n            ans[i] = ans[i-1] + nums[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999294,
                "title": "javascript-o-n-time-o-1-space",
                "content": "```\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for (let i in nums) {\\n        sum += nums[i]        \\n        nums[i] = sum\\n    }\\n    return nums\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for (let i in nums) {\\n        sum += nums[i]        \\n        nums[i] = sum\\n    }\\n    return nums\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 927456,
                "title": "kotlin-map",
                "content": "\\nhttps://discuss.kotlinlang.org/t/is-there-a-way-to-accumulate-and-map-in-the-same-operation/1492\\n```\\nfun runningSum(nums: IntArray): IntArray {\\n    var sum = 0\\n    return nums.map(){sum += it; sum}.toIntArray()\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun runningSum(nums: IntArray): IntArray {\\n    var sum = 0\\n    return nums.map(){sum += it; sum}.toIntArray()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 783332,
                "title": "easy-c-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        \\n        for(int i = 1; i < nums.size(); i++){\\n            nums[i] += nums[i - 1];\\n        }\\n        return nums;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\n\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        \\n        for(int i = 1; i < nums.size(); i++){\\n            nums[i] += nums[i - 1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 687833,
                "title": "one-line-swift-solution",
                "content": "One-line Swift solution\\n```\\nclass Solution {\\n    func runningSum(_ nums: [Int]) -> [Int] {\\n        return nums.reduce(into: (Int(0), [Int]()), { $0.0 += $1; $0.1.append($0.0) }).1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func runningSum(_ nums: [Int]) -> [Int] {\\n        return nums.reduce(into: (Int(0), [Int]()), { $0.0 += $1; $0.1.append($0.0) }).1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925525,
                "title": "java-c-c-rust-solutions-with-easy-explanation-0-ms-runtime",
                "content": "# Approach\\nTo calculate the running sum of the given array nums, we can iterate through the array and update each element with the sum of all elements up to that point. This way, each element of the modified array will represent the running sum from the beginning of the original array.\\n\\nIn this solution we start iterating with 1st index, because running sum of 0th is equal to nothing else but itself. So, it doesn\\'t need change.\\n\\n# Complexity\\n\\n## Java solution complexity\\nGot 0 ms runtime in Java\\n![image.png](https://assets.leetcode.com/users/images/01599a48-d492-4472-9c75-db7754dcd351_1692341026.9505627.png)\\n\\n\\n## C# solution complexity\\n![image.png](https://assets.leetcode.com/users/images/fe32dbfd-ffcc-4bfc-9891-e64b8316aac9_1692339570.3382912.png)\\n\\n## Rust solution complexity\\n![image.png](https://assets.leetcode.com/users/images/45555df4-691d-43ed-9c35-023fa30352a5_1692340401.1896594.png)\\n\\n\\n# Code\\n```C# []\\npublic class Solution {\\n    public int[] RunningSum(int[] nums) {\\n        for (int i = 1; i < nums.Length; i++)\\n        {\\n            nums[i] = nums[i - 1] + nums[i];\\n        }\\n\\n        return nums;\\n    }\\n}\\n```\\n```Java []\\npublic class Solution {\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[i] = nums[i - 1] + nums[i];\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for (int i = 1; i < nums.size(); i++) {\\n            nums[i] = nums[i - 1] + nums[i];\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```\\n```Rust []\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        // Create a mutable copy of the input vector\\n        let mut nums = nums;\\n        \\n        for i in 1..nums.len() {\\n            nums[i] = nums[i - 1] + nums[i];\\n        }\\n        \\n        nums\\n    }\\n}\\n```\\n\\n## If you found my solution helpful, please consider giving it an upvote. Happy coding!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C#",
                    "Rust"
                ],
                "code": "```C# []\\npublic class Solution {\\n    public int[] RunningSum(int[] nums) {\\n        for (int i = 1; i < nums.Length; i++)\\n        {\\n            nums[i] = nums[i - 1] + nums[i];\\n        }\\n\\n        return nums;\\n    }\\n}\\n```\n```Java []\\npublic class Solution {\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[i] = nums[i - 1] + nums[i];\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for (int i = 1; i < nums.size(); i++) {\\n            nums[i] = nums[i - 1] + nums[i];\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```\n```Rust []\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        // Create a mutable copy of the input vector\\n        let mut nums = nums;\\n        \\n        for i in 1..nums.len() {\\n            nums[i] = nums[i - 1] + nums[i];\\n        }\\n        \\n        nums\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676873,
                "title": "c-easy-and-100-fast-solution-0ms-beginner-friendly",
                "content": "```\\n            int sum = 0;\\n            for(int i = 0;i<nums.size();i++){\\n                    sum = sum + nums[i];\\n                    nums[i] = sum;\\n            }\\n            return nums;\\n        \\n```",
                "solutionTags": [
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\n            int sum = 0;\\n            for(int i = 0;i<nums.size();i++){\\n                    sum = sum + nums[i];\\n                    nums[i] = sum;\\n            }\\n            return nums;\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2096062,
                "title": "swift-2-lines-of-code",
                "content": "```\\nclass Solution {\\n    func runningSum(_ nums: [Int]) -> [Int] {\\n        return nums.reduce(into: []) { newArr, num in\\n            newArr.append(num + (newArr.last ?? 0))\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func runningSum(_ nums: [Int]) -> [Int] {\\n        return nums.reduce(into: []) { newArr, num in\\n            newArr.append(num + (newArr.last ?? 0))\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1002353,
                "title": "kotlin-solution-faster-than-94-92",
                "content": "```\\nclass Solution {\\n    \\n    fun runningSum(nums: IntArray): IntArray {\\n        \\n        // if array has only one element\\n        if(nums.size == 1) {\\n            return nums\\n        }\\n        \\n        \\n        for (i in 1..nums.size-1) {\\n            nums[i] += nums[i-1]\\n        }\\n        \\n        return nums\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    \\n    fun runningSum(nums: IntArray): IntArray {\\n        \\n        // if array has only one element\\n        if(nums.size == 1) {\\n            return nums\\n        }\\n        \\n        \\n        for (i in 1..nums.size-1) {\\n            nums[i] += nums[i-1]\\n        }\\n        \\n        return nums\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959773,
                "title": "3-java-solutions",
                "content": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        /*Solution 1*/\\n     // int n=nums.length;\\n     // int[] runningSum=new int[n];\\n     // for(int i=0;i<n;i++) {\\n     // for(int j=0;j<=i;j++) {\\n     // runningSum[i]+=nums[j];\\n     // }\\n     // }\\n     // return runningSum;   \\n        \\n     /*Solution 2*/\\n        // for(int i=1;i<nums.length;i++){\\n        //     nums[i]+=nums[i-1];\\n        // }\\n        // return nums;\\n        \\n        /*Solution 3*/\\n        int[] b=new int[nums.length];\\n        int prev=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            b[i]=prev+nums[i];\\n            prev=b[i];\\n        }\\n        b[0]=nums[0];\\n         return b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        /*Solution 1*/\\n     // int n=nums.length;\\n     // int[] runningSum=new int[n];\\n     // for(int i=0;i<n;i++) {\\n     // for(int j=0;j<=i;j++) {\\n     // runningSum[i]+=nums[j];\\n     // }\\n     // }\\n     // return runningSum;   \\n        \\n     /*Solution 2*/\\n        // for(int i=1;i<nums.length;i++){\\n        //     nums[i]+=nums[i-1];\\n        // }\\n        // return nums;\\n        \\n        /*Solution 3*/\\n        int[] b=new int[nums.length];\\n        int prev=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            b[i]=prev+nums[i];\\n            prev=b[i];\\n        }\\n        b[0]=nums[0];\\n         return b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797688,
                "title": "simple-python-approach",
                "content": "Simple python approach \\n\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        sum = 0\\n        for i in range(len(nums)):\\n            sum = sum + nums[i]\\n            nums[i] = sum\\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        sum = 0\\n        for i in range(len(nums)):\\n            sum = sum + nums[i]\\n            nums[i] = sum\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708655,
                "title": "scala-scanleft",
                "content": "```\\nobject Solution {\\n    def runningSum(nums: Array[Int]): Array[Int] = {\\n        nums.scanLeft(0)(_ + _).drop(1)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    def runningSum(nums: Array[Int]): Array[Int] = {\\n        nums.scanLeft(0)(_ + _).drop(1)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 691891,
                "title": "javascript-easy-to-understand-inplace-or-not",
                "content": "The strategy is pretty straight forward. We could maintain a variable as the prefix sum and update the final array with it.\\n\\nHere\\'s a strategy to return a new array:\\n\\n```js\\nconst runningSum = nums => {\\n  const LEN = nums.length;\\n  const ret = new Int32Array(LEN);\\n  ret[0] = nums[0];\\n  for (let i = 1; i < LEN; ++i) {\\n    ret[i] = ret[i - 1] + nums[i];\\n  }\\n  return ret;\\n};\\n```\\n\\nAnd here\\'s an inplace strategy:\\n\\n```js\\nconst runningSum = nums => {\\n  for (let i = 1; i < nums.length; ++i) {\\n    nums[i] += nums[i - 1];\\n  }\\n  return nums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst runningSum = nums => {\\n  const LEN = nums.length;\\n  const ret = new Int32Array(LEN);\\n  ret[0] = nums[0];\\n  for (let i = 1; i < LEN; ++i) {\\n    ret[i] = ret[i - 1] + nums[i];\\n  }\\n  return ret;\\n};\\n```\n```js\\nconst runningSum = nums => {\\n  for (let i = 1; i < nums.length; ++i) {\\n    nums[i] += nums[i - 1];\\n  }\\n  return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686246,
                "title": "easy-c-solution-one-pass",
                "content": "```\\n vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1; i<nums.size(); i++){\\n            nums[i]+=nums[i-1];\\n        }\\n        return nums;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1; i<nums.size(); i++){\\n            nums[i]+=nums[i-1];\\n        }\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3417112,
                "title": "the-fastest-solution-of-all",
                "content": "\\n# Complexity\\n- Time complexity:100%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:88%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc runningSum(nums []int) []int {\\n  sum := 0\\n  sums := make([]int, len(nums))\\n  for i, num := range nums {\\n    sum += num\\n    sums[i] = sum\\n  }\\n  return sums\\n}\\n```\\n\\n# Apply my work for all to see",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc runningSum(nums []int) []int {\\n  sum := 0\\n  sums := make([]int, len(nums))\\n  for i, num := range nums {\\n    sum += num\\n    sums[i] = sum\\n  }\\n  return sums\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3338100,
                "title": "simple-javascript-explanation-100-easy",
                "content": "# Intuition\\nAs you know, we should give back nums array with same length so I decided to overrite array elements with updated one.\\n\\n# Approach\\nThe algorithm iterates through the input array using a single loop, and uses a variable \\'sum\\' to keep track of the running sum. At each iteration, the current element of the array is assigned the current value of the running sum, and the \\'sum\\' variable is updated to include the next element in the array.\\n\\nFinally, the modified input array containing the running sums is returned.\\n\\nOverall, this is a simple and efficient approach to calculate running sums, and it does not require any additional data structures or complex computations.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar runningSum = function(nums) {\\n    //TIME-COMPLEXITY: O(n);\\n    //MEMORY: O(1);\\n    let sum = nums[0];\\n    for(let i = 0; i < nums.length; i++){\\n        nums[i] = sum;\\n        if(i+1 < nums.length){\\n            sum += nums[i+1]\\n        }\\n    }\\n    return nums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar runningSum = function(nums) {\\n    //TIME-COMPLEXITY: O(n);\\n    //MEMORY: O(1);\\n    let sum = nums[0];\\n    for(let i = 0; i < nums.length; i++){\\n        nums[i] = sum;\\n        if(i+1 < nums.length){\\n            sum += nums[i+1]\\n        }\\n    }\\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3297246,
                "title": "c-easy-solution-with-for-loop",
                "content": "\\n# Complexity\\n- Time complexity:141 ms.Beats 64.54% of other solutions.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 42.9 Mb.Beats 63.99% of other solution.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] RunningSum(int[] nums) {\\n       int sum=0;\\n       for(int i=0;i<nums.Length;i++){\\n           sum+=nums[i];\\n           nums[i]=sum;\\n       } \\n       return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] RunningSum(int[] nums) {\\n       int sum=0;\\n       for(int i=0;i<nums.Length;i++){\\n           sum+=nums[i];\\n           nums[i]=sum;\\n       } \\n       return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136461,
                "title": "simple-c-code-easy-beats-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRuns a loop and iterates through each element while increasing the \\'c\\' counter by the value of new \\'i\\' and entering the value of \\'c\\' to the vector. \\n\\nRuntime : Beats 100% \\u270C\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> res;\\n        int c=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            c=c+nums[i];\\n            res.push_back(c);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nHope you liked the implementation of the code, if you like it feel free to upvote \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> res;\\n        int c=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            c=c+nums[i];\\n            res.push_back(c);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959094,
                "title": "100-0-ms-42-mb-java-with-explanation",
                "content": "\\t1. class Solution {\\n\\t\\t\\tpublic int[] runningSum(int[] nums) { //[1,2,3,4]\\n\\t\\t\\t\\tint a=1;\\n\\t\\t\\t\\twhile (nums.length>a){\\n\\t\\t\\t\\t\\t// [1]+[1]...[6]+[4]\\n\\t\\t\\t\\t\\tnums[a]=nums[a]+nums[a-1];\\n\\t\\t\\t\\t\\ta++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn nums;\\n\\t\\t\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic int[] runningSum(int[] nums) { //[1,2,3,4]\\n\\t\\t\\t\\tint a=1;\\n\\t\\t\\t\\twhile (nums.length>a){\\n\\t\\t\\t\\t\\t// [1]+[1]...[6]+[4]\\n\\t\\t\\t\\t\\tnums[a]=nums[a]+nums[a-1];\\n\\t\\t\\t\\t\\ta++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2903772,
                "title": "sss-swift-simple-solutions-2-approaches",
                "content": "**1.a. Straight Approach**\\r\\n\\r\\n- Time complexity: $$O(N)$$\\r\\n- Space complexity: $$O(N)$$\\r\\n\\r\\n```\\r\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\r\\n    var result = [Int](), sum = 0\\r\\n    for n in nums {\\r\\n        sum += n\\r\\n        result.append(sum)\\r\\n    }\\r\\n    return result\\r\\n}\\r\\n```\\r\\n\\r\\n**1.b. In-place Way**\\r\\n\\r\\n- Time complexity: $$O(N)$$\\r\\n- Space complexity: $$O(1)$$\\r\\n\\r\\n```\\r\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\r\\n    var nums = nums, sum = 0\\r\\n    for (i, _) in nums.enumerated() {\\r\\n        sum += nums[i]\\r\\n        nums[i] = sum\\r\\n    }\\r\\n    return nums\\r\\n} \\r\\n```\\r\\n\\r\\n**1.c. Optimal In-place Way**\\r\\n\\r\\n- Time complexity: $$O(N)$$\\r\\n- Space complexity: $$O(1)$$\\r\\n\\r\\n```\\r\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\r\\n    var nums = nums\\r\\n    for i in 1..<nums.count {\\r\\n        nums[i] = nums[i - 1] + nums[i]\\r\\n    }\\r\\n    return nums\\r\\n}\\r\\n```\\r\\n**2. Functional Approach (One-liner)**\\r\\n\\r\\n- Time complexity: $$O(N)$$\\r\\n- Space complexity: $$O(N)$$\\r\\n\\r\\n```\\r\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\r\\n    nums.reduce(into: [Int]()) { result, n in result.append(n + (result.last ?? 0)) }\\r\\n}\\r\\n```\\r\\n\\r\\nor\\r\\n\\r\\n```\\r\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\r\\n    nums.reduce(into: [], { $0.append(($0.last ?? 0) + $1) })\\r\\n}\\r\\n```\\r\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\r\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\r\\n    var result = [Int](), sum = 0\\r\\n    for n in nums {\\r\\n        sum += n\\r\\n        result.append(sum)\\r\\n    }\\r\\n    return result\\r\\n}\\r\\n```\n```\\r\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\r\\n    var nums = nums, sum = 0\\r\\n    for (i, _) in nums.enumerated() {\\r\\n        sum += nums[i]\\r\\n        nums[i] = sum\\r\\n    }\\r\\n    return nums\\r\\n} \\r\\n```\n```\\r\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\r\\n    var nums = nums\\r\\n    for i in 1..<nums.count {\\r\\n        nums[i] = nums[i - 1] + nums[i]\\r\\n    }\\r\\n    return nums\\r\\n}\\r\\n```\n```\\r\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\r\\n    nums.reduce(into: [Int]()) { result, n in result.append(n + (result.last ?? 0)) }\\r\\n}\\r\\n```\n```\\r\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\r\\n    nums.reduce(into: [], { $0.append(($0.last ?? 0) + $1) })\\r\\n}\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2763508,
                "title": "running-sum-of-1d-array-in-c",
                "content": "\\'\\'\\'\\nvector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        ans.push_back(nums[0]);\\n        \\n        for(int i=1; i<nums.size(); i++)\\n            ans.push_back(nums[i] + ans[i-1]);\\n        \\n        return ans;\\n    }\\n\\t\\'\\'\\'",
                "solutionTags": [
                    "Array",
                    "Prefix Sum"
                ],
                "code": "\\'\\'\\'\\nvector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        ans.push_back(nums[0]);\\n        \\n        for(int i=1; i<nums.size(); i++)\\n            ans.push_back(nums[i] + ans[i-1]);\\n        \\n        return ans;\\n    }\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2607693,
                "title": "java-solution-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for(int i=1;i<nums.length;i++){\\n            nums[i]+=nums[i-1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for(int i=1;i<nums.length;i++){\\n            nums[i]+=nums[i-1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447969,
                "title": "0ms-java-solution-100-faster-than-all-submission",
                "content": "**Upvote in if you like tha approach**\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum = 0;\\n        for(int i = 0 ; i < n ; i ++){\\n            sum += nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum = 0;\\n        for(int i = 0 ; i < n ; i ++){\\n            sum += nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398478,
                "title": "scala-solution-with-scan-function",
                "content": "This solution uses the scan function in Scala, which applies a binary operator to create a running total for each element in the collection.\\n\\nThe first argument list is the initial value, which is usually set to zero, but since this element would be the first of the output collection, it seemed pointless to add it and later drop it. For this reason, I use the array\\'s tail (all elements but the first) and then use the first value nums(0) or nums.head as the initial value of the function.\\n\\n```scala\\nobject Solution {\\n    def runningSum(nums: Array[Int]): Array[Int] = nums.tail.scan(nums(0))(_+_)\\n}\\n```\\n\\nOpen to feedback and possible optimizations.",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\nobject Solution {\\n    def runningSum(nums: Array[Int]): Array[Int] = nums.tail.scan(nums(0))(_+_)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2097249,
                "title": "super-easy-python-solution-running-sum-of-1d-array",
                "content": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        sum=0\\n        for i in range(len(nums)):\\n            sum+=nums[i]\\n            nums[i]=sum  \\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        sum=0\\n        for i in range(len(nums)):\\n            sum+=nums[i]\\n            nums[i]=sum  \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096695,
                "title": "c-prefix-sum",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(i > 0) nums[i] += nums[i-1];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(i > 0) nums[i] += nums[i-1];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919382,
                "title": "0ms-java-simple",
                "content": "**Very simple 0ms java solution**\\n```\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 832685,
                "title": "easy-js-solution",
                "content": "```\\nvar runningSum = function(nums) {\\n    for (let i = 1; i < nums.length; i++) nums[i] += nums[i-1];\\n    return nums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar runningSum = function(nums) {\\n    for (let i = 1; i < nums.length; i++) nums[i] += nums[i-1];\\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 694698,
                "title": "c-easy",
                "content": "```\\nRuntime: 4 ms, faster than 93.14% of C++ online submissions for Running Sum of 1d Array.\\nMemory Usage: 8.6 MB, less than 80.00% of C++ online submissions for Running Sum of 1d Array.\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i = 1; i < (int)nums.size(); ++i) \\n            nums[i] += nums[i - 1];\\n        \\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nRuntime: 4 ms, faster than 93.14% of C++ online submissions for Running Sum of 1d Array.\\nMemory Usage: 8.6 MB, less than 80.00% of C++ online submissions for Running Sum of 1d Array.\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i = 1; i < (int)nums.size(); ++i) \\n            nums[i] += nums[i - 1];\\n        \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979191,
                "title": "c-100-fast-solution-easy-to-understand-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse the array and store its ith sum to the new array runningSum at its ith position\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore the sum of all the values of nums array one by one and assign it to the ith index of runningSum.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>runningsum(n);\\n        int sum = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            sum += nums[i];\\n            runningsum[i] = sum;\\n        }\\n        return runningsum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>runningsum(n);\\n        int sum = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            sum += nums[i];\\n            runningsum[i] = sum;\\n        }\\n        return runningsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958439,
                "title": "mathematical-one-line-for-loop-solution",
                "content": "# Intuition\\nAs we know that since every element in the the array is the of sum of all the previous elements in the array , therefore my first thought was to use the sum upto n numbers formula n(n+1)/2 where n is varing ,\\n\\nfor first iteration n = 1, second n = 2 and so on...\\n\\nBut then looking at the example testcases and applying somewhat similar concept we can see that if we sum the (i-1)th elements holds the sum upto (i-1)th term then the sum upto ith element is \\n`sum upto (i-1)th element + nums[i]`\\n\\n# Approach\\nThe first element of the array will remain unchnaged \\nstarting from the next index if we keep on adding the previous index in the current index then we\\'ll have our desired output\\n\\n`nums[i] = nums[i-1] + nums[i];`\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        //vector <long long> ans;\\n        for(auto i=1; i<nums.size(); i++) {\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        //vector <long long> ans;\\n        for(auto i=1; i<nums.size(); i++) {\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830020,
                "title": "c-std-partial-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDo what the problem asks as to do.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing ```std::partial_sum```.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ because we are rewriting the input.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        partial_sum(nums.begin(), nums.end(), nums.begin());\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```std::partial_sum```\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        partial_sum(nums.begin(), nums.end(), nums.begin());\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793276,
                "title": "simple-approach-upvote-if-you-like",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nvector \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n\\n        vector<int> sums;\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum=sum+nums[i];\\n            sums.push_back(sum);\\n        }\\n        return sums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n\\n        vector<int> sums;\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum=sum+nums[i];\\n            sums.push_back(sum);\\n        }\\n        return sums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698023,
                "title": "js-very-easy-solution",
                "content": "```\\nvar runningSum = function(nums) {\\n    const output = [nums[0]];\\n    \\n    for (let i = 1; i < nums.length; i++) {\\n        output.push(output[output.length - 1] + nums[i]);\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar runningSum = function(nums) {\\n    const output = [nums[0]];\\n    \\n    for (let i = 1; i < nums.length; i++) {\\n        output.push(output[output.length - 1] + nums[i]);\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2679612,
                "title": "python-o-n-time-o-1-space",
                "content": "```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            nums[i] = nums[i-1]+nums[i]\\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            nums[i] = nums[i-1]+nums[i]\\n        return nums\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2591195,
                "title": "easy-c-solution-runtime-0-ms-faster-than-100-00-of-c",
                "content": "Please upvote the solution\\uD83D\\uDE4F\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            sum += nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            sum += nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575989,
                "title": "running-sum-1d-array-python3-easy-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums)):\\n            nums[i] = nums[i] + nums[i-1]\\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums)):\\n            nums[i] = nums[i] + nums[i-1]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2367467,
                "title": "python-should-be-the-most-efficient-solution",
                "content": "We notice the ith sum is actually the (i-1)th sum plus the ith element. And we can apply the small trick of using the input list to store our result to further save some space.\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums)):\\n            nums[i] += nums[i - 1]\\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums)):\\n            nums[i] += nums[i - 1]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098759,
                "title": "java-easiest-solution-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sumTillNow = 0;\\n        for(int i=0; i<nums.length; i++){\\n            nums[i] = nums[i] + sumTillNow;\\n            sumTillNow = nums[i];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sumTillNow = 0;\\n        for(int i=0; i<nums.length; i++){\\n            nums[i] = nums[i] + sumTillNow;\\n            sumTillNow = nums[i];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096122,
                "title": "fastest-approach-c-solution-and-approach",
                "content": "See let us see the test cases, they demand to have sum of their previous elements. So in this question, many of us will make the mistake to create a new vector(array) and then thinking of storing values in that array. I\\'ll say that you don\\'t need to create a new array ie. space complexity became O(1) and just rather update the values. for eg if our array has element 1,2,3,4 then run a loop from the 1st index(index after the 0th index) and then add the current and the previous element. \\n1st   index -> 1st index    + 0th index = 2 + 1 = 3 -->  array = 1,3,3,4\\n2nd index ->  2nd index  + 1st index = 3 + 3 = 6 -->   array = 1,3,6,4\\n3rd index  ->  3rd index   + 2nd index = 4 + 6 = 10 -> array = 1,3,6,10\\n\\nHence this was the simplest algorithm in O(n).\\n**And btw why do we start from 1st index only?\\nDrop down in the comments below. And do upvote the solution\\u2764\\uFE0F.**\\n\\n```\\nclass Solution\\n{\\n    public:\\n        vector<int> runningSum(vector<int> &nums)\\n        {\\n            /*lets take a example ->[1,2,3,4]\\n              rather than creating a new array, we should make changes in the  same array itself.\\n            */\\n\\n            for (int i = 1; i < nums.size(); i++)\\n            {\\n                nums[i] = nums[i] + nums[i - 1];\\n            }\\n\\n            return nums;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> runningSum(vector<int> &nums)\\n        {\\n            /*lets take a example ->[1,2,3,4]\\n              rather than creating a new array, we should make changes in the  same array itself.\\n            */\\n\\n            for (int i = 1; i < nums.size(); i++)\\n            {\\n                nums[i] = nums[i] + nums[i - 1];\\n            }\\n\\n            return nums;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003656,
                "title": "python-recursive-memoization-dp-with-explanations",
                "content": "I think that running sum is a very good starting point to understand dynamic programming. To come up with DP solution you always start with brute force recursion (or backtracking):\\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n        \\n        ans = []\\n        \\n        def cumsum(ind):\\n            if ind == 0:\\n                return nums[ind]\\n            \\n            return nums[ind] + cumsum(ind-1)\\n        \\n        for i in range(len(nums)):\\n            ans.append(cumsum(i))\\n        \\n        return ans\\n```\\n\\nAnd here you can clearly see that you are doing a ton of unnecessary work: for each number in the array you repeat all steps down to the end (bottom) of the array. So, this approach is called top-to-bottom. You can improve it with memoization.\\n\\n```\\n def runningSum(self, nums: List[int]) -> List[int]:\\n        \\n        ans = []\\n        \\n        memo = [None] * len(nums)\\n        memo[0] = nums[0]\\n        \\n        def cumsum(ind):\\n            if memo[ind] is None:\\n            \\n                memo[ind] = nums[ind] + cumsum(ind-1)\\n            \\n            return memo[ind]\\n        \\n        for i in range(len(nums)):\\n            ans.append(cumsum(i))\\n        \\n        return ans\\n```\\nNow you avoid doing work that you\\'ve already done: you store your previous useful results in a memo array. And now it could be converted to a bottom-to-top DP solution.\\n\\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n        \\n        dp = [None] * len(nums)\\n        dp[0] = nums[0]\\n        \\n        for i in range(1,len(nums)):\\n            dp[i] = nums[i] + dp[i-1]\\n        \\n        return dp\\n```\\n\\nNow you gradually build your answer and for running sum it is the most intuitive approach that most people would use. So, I think that all DP problems are like building some kind of a bit more complicated running sum.\\n\\nNotice that all above solutions share the same idea: current element plus previous one. In DP they call it a recurrence relation. Here in running sum it is simple and intuitive, but in real DP problems your job is to figure out this recurrence relation.\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n        \\n        ans = []\\n        \\n        def cumsum(ind):\\n            if ind == 0:\\n                return nums[ind]\\n            \\n            return nums[ind] + cumsum(ind-1)\\n        \\n        for i in range(len(nums)):\\n            ans.append(cumsum(i))\\n        \\n        return ans\\n```\n```\\n def runningSum(self, nums: List[int]) -> List[int]:\\n        \\n        ans = []\\n        \\n        memo = [None] * len(nums)\\n        memo[0] = nums[0]\\n        \\n        def cumsum(ind):\\n            if memo[ind] is None:\\n            \\n                memo[ind] = nums[ind] + cumsum(ind-1)\\n            \\n            return memo[ind]\\n        \\n        for i in range(len(nums)):\\n            ans.append(cumsum(i))\\n        \\n        return ans\\n```\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n        \\n        dp = [None] * len(nums)\\n        dp[0] = nums[0]\\n        \\n        for i in range(1,len(nums)):\\n            dp[i] = nums[i] + dp[i-1]\\n        \\n        return dp\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1924101,
                "title": "simple-easy-beginner-friendly-60-ms",
                "content": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        sum1 = [nums[0]]\\n        \\n        for i in range(1,len(nums)):\\n            sum1.append(sum(nums[:i])+nums[i])\\n          \\n        return sum1 \\n\\t\\t\\n```\\t\\t",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        sum1 = [nums[0]]\\n        \\n        for i in range(1,len(nums)):\\n            sum1.append(sum(nums[:i])+nums[i])\\n          \\n        return sum1 \\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503177,
                "title": "100-java",
                "content": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n       \\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            nums[i]+=sum;\\n            sum=nums[i];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n       \\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            nums[i]+=sum;\\n            sum=nums[i];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334814,
                "title": "c-brute-force-efficient-solutions-time-o-n-auxiliary-space-o-1",
                "content": "**Brute Force Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n    // Brute Force Solution Time O(N^2) & Auxiliary Space O(1)\\n    vector<int> result;\\n    int len=nums.size(),sum=0;\\n    for(int i=0;i<len;i++){\\n          sum=0;\\n        for(int j=0;j<=i;j++){\\n              sum+=nums[j];\\n        }\\n        result.push_back(sum);\\n    }\\n        return result;\\n    }\\n};\\n```\\n\\n**Efficient Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n    // Optimal Solution Time O(N) & Auxiliary Space O(1)\\n    int len=nums.size();\\n    for(int i=1;i<len;i++){\\n        nums[i]+=nums[i-1];\\n    }\\n        return nums;  \\n    }\\n};\\n```\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n    // Brute Force Solution Time O(N^2) & Auxiliary Space O(1)\\n    vector<int> result;\\n    int len=nums.size(),sum=0;\\n    for(int i=0;i<len;i++){\\n          sum=0;\\n        for(int j=0;j<=i;j++){\\n              sum+=nums[j];\\n        }\\n        result.push_back(sum);\\n    }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n    // Optimal Solution Time O(N) & Auxiliary Space O(1)\\n    int len=nums.size();\\n    for(int i=1;i<len;i++){\\n        nums[i]+=nums[i-1];\\n    }\\n        return nums;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188952,
                "title": "java-c-python-prefix-sum-logic-explained-o-1-space-o-n-time",
                "content": "*------Please **upvote!** if you like the solution and explanation.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n\\n**EXPLANATION:**\\n\\nBrute force logic will be to take every number 1 by 1 and calculate the sum of numbers before it and add the current number to the sum.  This will take **O (N^2)** time.\\n\\nWe can optimize this to **O (N)** time by precalculating the sum of numbers before the current number using the prefix sum logic.\\n\\n**Prefix sum of an array element is the sum of all the numbers including itself from the start of the array.**\\n\\nSo basically: `prefixSum [i] = prefixSum [i-1] + nums [i]`.  Since there is no number before the first number, `prefixSum [0] = nums [0]` itself.\\n\\nSince, we don\\'t need to do any processing after calculating the prefix sum, we can use the given array itself as the prefix sum array.\\n\\nDo: `nums [i] = nums [i] + nums [i-1]` and simply return `nums` array.\\n\\n**Java** 0 ms:\\n\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++)\\n            nums [i] += nums [i-1];\\n        return nums;\\n    }\\n}\\n```\\n\\n**C++** 4 ms:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for (int i = 1; i < nums.size (); i++)\\n            nums [i] += nums [i-1];\\n        return nums;\\n    }\\n};\\n```\\n\\n**Python** 40 ms:\\n\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range (1, len(nums)):\\n            nums [i] = nums [i] + nums [i-1]\\n        return nums\\n```\\n\\nIf you like the solution and explanation, please **upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++)\\n            nums [i] += nums [i-1];\\n        return nums;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for (int i = 1; i < nums.size (); i++)\\n            nums [i] += nums [i-1];\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range (1, len(nums)):\\n            nums [i] = nums [i] + nums [i-1]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153939,
                "title": "swift-running-sum-of-1d-array",
                "content": "#### Solution\\n\\n```swift\\nclass Solution {\\n    func runningSum(_ nums: [Int]) -> [Int] {\\n        var res = [Int]()\\n        for i in 0..<nums.count where !nums.isEmpty {\\n            i == 0 ? res.append(nums[i]) : res.append(res[i-1] + nums[i])\\n        }\\n        return res\\n    }\\n}\\n```\\n\\n#### Tests:\\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func testExample1() {\\n        XCTAssertEqual(s.runningSum([1,2,3,4]), [1,3,6,10]) // success\\n    }\\n    func testExample2() {\\n        XCTAssertEqual(s.runningSum([1,1,1,1,1]), [1,2,3,4,5]) // success\\n    }\\n    func testExample3() {\\n        XCTAssertEqual(s.runningSum([3,1,2,10,1]), [3,4,6,16,17]) // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func runningSum(_ nums: [Int]) -> [Int] {\\n        var res = [Int]()\\n        for i in 0..<nums.count where !nums.isEmpty {\\n            i == 0 ? res.append(nums[i]) : res.append(res[i-1] + nums[i])\\n        }\\n        return res\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func testExample1() {\\n        XCTAssertEqual(s.runningSum([1,2,3,4]), [1,3,6,10]) // success\\n    }\\n    func testExample2() {\\n        XCTAssertEqual(s.runningSum([1,1,1,1,1]), [1,2,3,4,5]) // success\\n    }\\n    func testExample3() {\\n        XCTAssertEqual(s.runningSum([3,1,2,10,1]), [3,4,6,16,17]) // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027797,
                "title": "python-3-3-liner-o-n-time-o-1-memory",
                "content": "**Uses initial memory and writes over it.**\\n\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            nums[i] += nums[i-1]\\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            nums[i] += nums[i-1]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717785,
                "title": "c-solution",
                "content": "```\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    int i, prev=0;\\n    *returnSize = numsSize;\\n    int* returnSum;\\n    returnSum = (int*)malloc(sizeof(int)*numsSize);\\n    returnSum[0] = nums[0];\\n    for(i=1;i<numsSize;i++)\\n        returnSum[i]=returnSum[i-1] + nums[i];\\n    return returnSum;\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    int i, prev=0;\\n    *returnSize = numsSize;\\n    int* returnSum;\\n    returnSum = (int*)malloc(sizeof(int)*numsSize);\\n    returnSum[0] = nums[0];\\n    for(i=1;i<numsSize;i++)\\n        returnSum[i]=returnSum[i-1] + nums[i];\\n    return returnSum;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 688159,
                "title": "swift-2-line-simple-solution",
                "content": "```\\nvar sum = 0\\nreturn nums.map{(sum+=$0, sum).1}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nvar sum = 0\\nreturn nums.map{(sum+=$0, sum).1}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686902,
                "title": "python-solution-easy-to-undersatnd",
                "content": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        cum_sum = 0 #cummulative sum\\n        for i in range(len(nums)):\\n            cum_sum += nums[i]\\n            nums[i] = cum_sum\\n        return nums",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        cum_sum = 0 #cummulative sum\\n        for i in range(len(nums)):\\n            cum_sum += nums[i]\\n            nums[i] = cum_sum\\n        return nums",
                "codeTag": "Java"
            },
            {
                "id": 686495,
                "title": "functional-programming-one-line-with-rust",
                "content": "```rust\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        nums.iter()\\n            .scan(0, |sum, &v| {\\n                *sum += v;\\n                Some(*sum)\\n            })\\n            .collect::<Vec<i32>>()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        nums.iter()\\n            .scan(0, |sum, &v| {\\n                *sum += v;\\n                Some(*sum)\\n            })\\n            .collect::<Vec<i32>>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686327,
                "title": "java-simple-solution-100-time-in-place",
                "content": "```\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1;i<nums.length;i++){\\n            nums[i] = nums[i] + nums[i-1];\\n        }\\n        return nums;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1;i<nums.length;i++){\\n            nums[i] = nums[i] + nums[i-1];\\n        }\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686233,
                "title": "a-few-solutions",
                "content": "Return the ongoing accumulated `total` of each value `x` of the input array `A`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun runningSum(A: IntArray): IntArray {\\n        var total = 0\\n        return A.map{ total += it; total }!!.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet runningSum = (A, sum = 0) => A.map(x => sum += x);\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def runningSum(self, A: List[int], sum = 0) -> List[int]:\\n        N = len(A)\\n        for i in range (1, N):\\n            A[i] += A[i - 1]\\n        return A\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI runningSum(VI& A, int sum = 0, VI ans = {}) {\\n        transform(A.begin(), A.end(), back_inserter(ans), [&](auto x) { return sum += x; });\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun runningSum(A: IntArray): IntArray {\\n        var total = 0\\n        return A.map{ total += it; total }!!.toIntArray()\\n    }\\n}\\n```\n```\\nlet runningSum = (A, sum = 0) => A.map(x => sum += x);\\n```\n```\\nclass Solution:\\n    def runningSum(self, A: List[int], sum = 0) -> List[int]:\\n        N = len(A)\\n        for i in range (1, N):\\n            A[i] += A[i - 1]\\n        return A\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI runningSum(VI& A, int sum = 0, VI ans = {}) {\\n        transform(A.begin(), A.end(), back_inserter(ans), [&](auto x) { return sum += x; });\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632450,
                "title": "go-solution-great-explanation-and-full-description",
                "content": "# Intuition\\nThe problem asks for a running sum of an array, which means for each element at index `i` in the resultant array, its value is the sum of all elements from index 0 to `i` in the original array. A straightforward approach is to iterate over the array and at each step, add the current element to the sum of all previous elements.\\n\\n# Approach\\nWe create a prefix sum array `prefix` which has length 1 more than the input `nums` array. This is because the prefix sum includes the sum of elements up to and including the current element, and we want the first element to be zero for an easier calculation. We then iterate over the `nums` array and for each element, we add it to the previous prefix sum and store it in the current position of the prefix sum array.\\n\\nFinally, we return all elements from index 1 to the end of the prefix array. This is because the running sum of `nums` starts from the first element, not the zeroth element.\\n\\n# Complexity\\n- Time complexity: The time complexity for this algorithm is O(n), where `n` is the length of the `nums` array. This is because we perform a single pass over the `nums` array.\\n\\n- Space complexity: The space complexity is O(n), as we create a prefix sum array of the same size as the `nums` array. \\n\\n# Code\\n```go\\nfunc runningSum(nums []int) []int {\\n    prefix:=make([]int,len(nums)+1)\\n    for i:=1;i<len(prefix);i++{\\n        prefix[i]=prefix[i-1]+nums[i-1]\\n    }\\n    return prefix[1:]\\n}\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "# Intuition\\nThe problem asks for a running sum of an array, which means for each element at index `i` in the resultant array, its value is the sum of all elements from index 0 to `i` in the original array. A straightforward approach is to iterate over the array and at each step, add the current element to the sum of all previous elements.\\n\\n# Approach\\nWe create a prefix sum array `prefix` which has length 1 more than the input `nums` array. This is because the prefix sum includes the sum of elements up to and including the current element, and we want the first element to be zero for an easier calculation. We then iterate over the `nums` array and for each element, we add it to the previous prefix sum and store it in the current position of the prefix sum array.\\n\\nFinally, we return all elements from index 1 to the end of the prefix array. This is because the running sum of `nums` starts from the first element, not the zeroth element.\\n\\n# Complexity\\n- Time complexity: The time complexity for this algorithm is O(n), where `n` is the length of the `nums` array. This is because we perform a single pass over the `nums` array.\\n\\n- Space complexity: The space complexity is O(n), as we create a prefix sum array of the same size as the `nums` array. \\n\\n# Code\\n```go\\nfunc runningSum(nums []int) []int {\\n    prefix:=make([]int,len(nums)+1)\\n    for i:=1;i<len(prefix);i++{\\n        prefix[i]=prefix[i-1]+nums[i-1]\\n    }\\n    return prefix[1:]\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3500006,
                "title": "easy-java-program-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for(int i=1;i<nums.length;i++){\\n            nums[i]=nums[i]+nums[i-1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for(int i=1;i<nums.length;i++){\\n            nums[i]=nums[i]+nums[i-1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465270,
                "title": "0ms-100-faster-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum[]=new int[nums.length];\\n        sum[0]=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            sum[i]=sum[i-1]+nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum[]=new int[nums.length];\\n        sum[0]=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            sum[i]=sum[i-1]+nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416816,
                "title": "c-code-0-ms-and-beats-100-of-the-c-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will iterate from the **index 1** to **`nums.size() - 1`** of the array **`nums`** and add the previous element **`nums[i - 1]`** to the current element **`nums[i]`** and store it at the same index **`nums[i]`** and return the **`nums`**.\\n\\n![temp1.png](https://assets.leetcode.com/users/images/59324d05-edfd-40c9-9aa4-f4bceb7993f1_1681485544.2118454.png)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        // vector<int> ans = {nums[0]};\\n\\n        for(int i = 1; i < nums.size(); i++) {\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        \\n        return nums;\\n    }\\n};\\n\\n\\n\\n```\\n\\n\\n\\n# **Please Upvote.**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        // vector<int> ans = {nums[0]};\\n\\n        for(int i = 1; i < nums.size(); i++) {\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        \\n        return nums;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303462,
                "title": "simple-approach-i-was-able-to-get-0ms-runtime-with-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nCreate a new vector `ans`.\\n\\nNow, we can simply do :\\n\\n`ans[0] = nums[0]`\\n\\nand now, \\n\\nwe run a loop till end of vector, and use the following formula for populating vactor `ans` :\\n\\n> ans[i] = ans[i - 1] + nums[i]\\n\\njust note to start the loop from `i = 1`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        ans.push_back(nums[0]);\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            ans.push_back(ans[i - 1] + nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        ans.push_back(nums[0]);\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            ans.push_back(ans[i - 1] + nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190932,
                "title": "c-solution-standard-code-must-know",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1;i<nums.size();i++) nums[i]+= nums[i-1];\\n        return nums;\\n    }\\n};\\n```\\n\\n```\\n//if initial array is not allowed to modify\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n\\t\\tvector<int> arr={nums[0]};\\n        for(int i=1;i<nums.size();i++) arr.push_back(nums[i]+arr.back()) ;\\n        return arr;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1;i<nums.size();i++) nums[i]+= nums[i-1];\\n        return nums;\\n    }\\n};\\n```\n```\\n//if initial array is not allowed to modify\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n\\t\\tvector<int> arr={nums[0]};\\n        for(int i=1;i<nums.size();i++) arr.push_back(nums[i]+arr.back()) ;\\n        return arr;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160888,
                "title": "simple-java-prefix-sum-clear-understanding",
                "content": "```\\nExplanation : (Prefix Sum) \\n\\t\\n\\t Here I\\'m taking first example TestCase of leetcode\\n\\t\\n\\t nums = [1, 2, 3, 4]\\n\\t\\n\\t Inner Working of Prefix Sum Approach\\n\\t\\n\\t steps :\\n\\t 1. create prefixSum array with nums array length --> {0, 0, 0,0};\\n\\t 2. add 0th index element of nums array to prefixSum array, prefixSum[0] = nums[0];\\n\\t\\n\\t for (int i = 1; i < nums.length; i++) {\\n\\t\\t prefixSum[i] = prefixSum[i - 1] + nums[i];\\n\\t }\\n\\n\\t how this loop is working ?\\n\\n\\t intial prefixSum array = {1, 0, 0, 0}\\n\\n\\t consider,\\n\\t i = 1;\\n\\t prefixSum[i] = prefixSum[i - 1] + nums[i], it means,\\n\\t prefixSum[1] = prefixSum[1 - 1] + nums[1],\\n\\t prefixSum[1] = prefixSum[0] + nums[1] // calculate answers;\\n\\t prefixSum[1] = 1 + 2;\\n\\t prefixSum[1] = 3;\\n\\t prefixSum array = {1, 3, 0, 0}\\n\\n\\t similarly, for i = 2;\\n\\t prefixSum[i] = prefixSum[i - 1] + nums[i], it means,\\n\\t prefixSum[2] = prefixSum[2 - 1] + nums[2],\\n\\t prefixSum[2] = prefixSum[1] + nums[2] // calculate answers;\\n\\t prefixSum[2] = 3 + 3;\\n\\t prefixSum[2] = 6;\\n\\t prefixSum array = {1, 3, 6, 0}\\n\\n\\t same as for i = 3;\\n\\t prefixSum[i] = prefixSum[i - 1] + nums[i], it means,\\n\\t prefixSum[3] = prefixSum[3 - 1] + nums[3],\\n\\t prefixSum[3] = prefixSum[2] + nums[3] // calculate answers;\\n\\t prefixSum[3] = 6 + 4;\\n\\t prefixSum[3] = 10;\\n\\t prefixSum array = {1, 3, 6, 10}\\n\\n\\t Hope you get the idea behind Prefix Sum. \\uD83D\\uDC95\\n\\t \\nJAVA CODE : \\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        int[] prefixSum = new int[nums.length];\\n        prefixSum[0] = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i];\\n        }\\n        \\n        return prefixSum;\\n    }\\n}\\n\\nTime Complexity : O(N)\\nSpace Complexity : O(N)\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        int[] prefixSum = new int[nums.length];\\n        prefixSum[0] = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3085608,
                "title": "summing-up-a-1d-array-php-solution-4-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst i thought that we can go with a straight forward approach that using to for loops for interating through the array summing up to on new array and returning it. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe best approach is as per explanation & constrain alway first element is same element as in input array , so i started from index 1 & to reduce the memory useage i am using the same array so storing a summing up value & returning it \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nits o(n-1) solution\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nits o(1) solution\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer[]\\n     */\\n    function runningSum($nums) {\\n        \\n        for ($i=1;$count=count($nums),$i<$count;$i++){\\n\\n           $nums[$i]=$nums[$i-1]+$nums[$i];\\n\\n        }\\n       \\n       return $nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer[]\\n     */\\n    function runningSum($nums) {\\n        \\n        for ($i=1;$count=count($nums),$i<$count;$i++){\\n\\n           $nums[$i]=$nums[$i-1]+$nums[$i];\\n\\n        }\\n       \\n       return $nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056570,
                "title": "c-proper-solution-explained",
                "content": "# Intuition\\nThe value of a number is equal to the sum of all the previous numbers and the current number.\\n\\n# Approach\\n- Sum keeps the track of the sum of all the previous numbers.\\n- Traverse through numbers, add the value of current number to the sum and then update the number of the array to sum.\\n  \\n- Example \\nConside nums= {1,2,3,4}\\nInitially sum=0;\\nsum=sum+nums[0]=0+1=1, nums[0]=1\\nsum=sum+nums[1]=1+2=3, nums[1]=3\\nsum=sum+nums[2]=3+3=6, nums[2]=6\\nsum=sum+nums[3]=6+4=10, nums[3]=10\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n    int sum=0;\\n    for(int i=0;i<nums.size();i++){\\n        sum=sum+nums[i];\\n        nums[i]=sum;\\n    }    \\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n    int sum=0;\\n    for(int i=0;i<nums.size();i++){\\n        sum=sum+nums[i];\\n        nums[i]=sum;\\n    }    \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052302,
                "title": "quick-and-short-solution",
                "content": "# Intuition\\nIterative Approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstart from index 1 and assign the sum of current element and previous element to current position\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(n)\\n# Code\\n```\\nclass Solution {\\n    fun runningSum(nums: IntArray): IntArray {\\n        for(i in 1 until nums.size){\\n            nums[i] = nums[i-1]+nums[i]\\n        }\\n        return nums\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun runningSum(nums: IntArray): IntArray {\\n        for(i in 1 until nums.size){\\n            nums[i] = nums[i-1]+nums[i]\\n        }\\n        return nums\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912299,
                "title": "sc-100-and-tc-98-java-and-python",
                "content": "# Java Solutions with SC----->O(1)\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){\\n            nums[i+1]=nums[i]+nums[i+1];\\n        }\\n        return nums;\\n        \\n    }\\n}\\n```\\n# Python Solutions SC------>O(1)\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            nums[i]=nums[i]+nums[i-1]\\n        return nums\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){\\n            nums[i+1]=nums[i]+nums[i+1];\\n        }\\n        return nums;\\n        \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            nums[i]=nums[i]+nums[i-1]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880685,
                "title": "c-o-n-easy-to-understand-with-in-depth-explanation-and-examples",
                "content": "#### Table of Contents\\n\\n- [TL;DR](#tldr)\\n  - [Code](#code)\\n  - [Complexity](#complexity)\\n- [In Depth Analysis](#in-depth-analysis)\\n  - [Intuition](#intuition)\\n  - [Approach](#approach)\\n  - [Example](#example)\\n\\n# TL;DR\\n\\nUse the original array to hold the running sum\\n\\n## Code\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        const int n = nums.size();\\n        for (int i = 1; i < n; i++)\\n            nums[i] += nums[i - 1];\\n\\n        return nums;\\n    }\\n};\\n```\\n\\n## Complexity\\n\\n**Time Complexity:** $$O(N)$$\\n**Space Complexity:** $$O(1)$$\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**\\n\\n---\\n\\n# In Depth Analysis\\n\\n## Intuition\\n\\nRefer to the [TL;DR](#tldr)\\n\\n## Approach \\n\\nThe first index will just be itself, then from index 1 to n, it will be `nums[i] += nums[i - 1]` since you just want to add the previous value onto the current value continuously till the end. Then you just return the original array that was passed in.\\n\\n## Example\\n\\nLet\\'s use the third example, where `nums = [3,1,2,10,1]`\\n\\n* i = 1\\n`nums[i] += nums[i - 1]` $$\\\\rightarrow$$ `nums[1] = nums[1] + nums[0] = 1 + 3 = 4`\\n\\n* i = 2\\n`nums[i] += nums[i - 1]` $$\\\\rightarrow$$ `nums[2] = nums[2] + nums[1] = 2 + 4 = 6` (remember we just updated `nums[i]` in the last bullet)\\n\\n* i = 3\\n`nums[i] += nums[i - 1]` $$\\\\rightarrow$$ `nums[3] = nums[3] + nums[2] = 10 + 6 = 16`\\n\\n* i = 4\\n`nums[i] += nums[i - 1]` $$\\\\rightarrow$$ `nums[4] = nums[4] + nums[3] = 1 + 16 = 17`\\n\\n* Final Result = `[3,4,6,16,17]` which is the solution\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        const int n = nums.size();\\n        for (int i = 1; i < n; i++)\\n            nums[i] += nums[i - 1];\\n\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782064,
                "title": "0ms-beats-100-easy-to-understand-c-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//...Please upvote if it helps...\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1;i<nums.size();++i){\\n            nums[i]+=nums[i-1];\\n        }return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\n//...Please upvote if it helps...\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1;i<nums.size();++i){\\n            nums[i]+=nums[i-1];\\n        }return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709619,
                "title": "c-short-easy-solution-o-n-time-o-1-space",
                "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1; i<nums.size(); i++) \\n\\t\\t    nums[i] += nums[i-1];\\n            \\n\\t\\treturn nums;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1; i<nums.size(); i++) \\n\\t\\t    nums[i] += nums[i-1];\\n            \\n\\t\\treturn nums;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2682544,
                "title": "javascript-map-o-n-faster-than-85",
                "content": "```\\nconst runningSum = (nums) => {\\n    nums.map((num,index)=>{    \\n        if(index!=0){\\n            return nums[index] = num + nums[index-1];\\n        }\\n    })\\n    return nums;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst runningSum = (nums) => {\\n    nums.map((num,index)=>{    \\n        if(index!=0){\\n            return nums[index] = num + nums[index-1];\\n        }\\n    })\\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2548476,
                "title": "very-easy-and-simple-java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        arr[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) { \\n            arr[i] = arr[i-1] + nums[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        arr[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) { \\n            arr[i] = arr[i-1] + nums[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544167,
                "title": "simple-java-solution-runtime-0-ms-faster-than-100-00-of-java",
                "content": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        for(int i=1; i<n; i++){    // notes you don\\'t put i=0, because we need nums[i-1]= nums[0-1] || So, ans is nums[-1] but we have no index of nums[-1] but have nums[0] is present so, we are put starting value of i=1.\\n            nums[i] = nums[i] + nums[i-1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        for(int i=1; i<n; i++){    // notes you don\\'t put i=0, because we need nums[i-1]= nums[0-1] || So, ans is nums[-1] but we have no index of nums[-1] but have nums[0] is present so, we are put starting value of i=1.\\n            nums[i] = nums[i] + nums[i-1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2539371,
                "title": "leetcode-the-hard-way-three-solutions-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. I\\'ll explain my solution line by line daily. \\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n**Solution 1: Prefix Sum**\\n\\nExtracted from my tutorial [here](https://wingkwong.github.io/leetcode-the-hard-way/tutorials/basic-topics/prefix-sum).\\n\\n![image](https://assets.leetcode.com/users/images/8e660152-4785-4334-aa2d-b5b888b90085_1662458446.9801016.png)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // for full tutorial, please go to\\n    // https://wingkwong.github.io/leetcode-the-hard-way/tutorials/basic-topics/prefix-sum\\n    vector<int> generatePrefixSum(vector<int>& a) {\\n        int n = a.size();\\n\\t\\t// we need a vector of size n\\n        vector<int> pref(n);\\n\\t\\t// the first element is same as that in `a`\\n        pref[0] = a[0];\\n\\t\\t// starting the second one, we add the prefix sum `pref[i - 1]` and the current value `a[i]`\\n        for (int i = 1; i < n; i++) pref[i] = pref[i - 1] + a[i];\\n        return pref;\\n    }\\n    \\n    vector<int> runningSum(vector<int>& nums) {\\n\\t    // use the pre-defined function directly\\n        return generatePrefixSum(nums);\\n    }\\n};\\n```\\n\\n**Solution 2: Partial Sum**\\n\\nThis STL basically does the same thing I mention above. See [here](https://cplusplus.com/reference/numeric/partial_sum/) for more details.\\n\\n```\\ny0 = x0\\ny1 = x0 + x1\\ny2 = x0 + x1 + x2\\ny3 = x0 + x1 + x2 + x3\\ny4 = x0 + x1 + x2 + x3 + x4\\n```\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n\\t\\t// use STL directly\\n        partial_sum(nums.begin(), nums.end(), nums.begin());\\n        return nums;\\n    }\\n};\\n```\\n\\n**Solution 3: In-place Modification**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n\\t\\t// we don\\'t actually need to generate a prefix sum vector\\n\\t\\t// instead we can modify the value in place.\\n        for(int i = 1; i < nums.size(); i++) {\\n            // add the previous result to the current element.\\n            nums[i] += nums[i - 1];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // for full tutorial, please go to\\n    // https://wingkwong.github.io/leetcode-the-hard-way/tutorials/basic-topics/prefix-sum\\n    vector<int> generatePrefixSum(vector<int>& a) {\\n        int n = a.size();\\n\\t\\t// we need a vector of size n\\n        vector<int> pref(n);\\n\\t\\t// the first element is same as that in `a`\\n        pref[0] = a[0];\\n\\t\\t// starting the second one, we add the prefix sum `pref[i - 1]` and the current value `a[i]`\\n        for (int i = 1; i < n; i++) pref[i] = pref[i - 1] + a[i];\\n        return pref;\\n    }\\n    \\n    vector<int> runningSum(vector<int>& nums) {\\n\\t    // use the pre-defined function directly\\n        return generatePrefixSum(nums);\\n    }\\n};\\n```\n```\\ny0 = x0\\ny1 = x0 + x1\\ny2 = x0 + x1 + x2\\ny3 = x0 + x1 + x2 + x3\\ny4 = x0 + x1 + x2 + x3 + x4\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n\\t\\t// use STL directly\\n        partial_sum(nums.begin(), nums.end(), nums.begin());\\n        return nums;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n\\t\\t// we don\\'t actually need to generate a prefix sum vector\\n\\t\\t// instead we can modify the value in place.\\n        for(int i = 1; i < nums.size(); i++) {\\n            // add the previous result to the current element.\\n            nums[i] += nums[i - 1];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498971,
                "title": "c-prefix-sum-beginner-friendly",
                "content": "**Approach 1: Prefix Sum \\u2705**\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       for(int i=1;i<nums.size();i++) nums[i]+=nums[i-1]; //prefix sum calculation\\n        return nums;\\n    }\\n};\\n```\\n\\n**Approach 2: Partial Sum (C++ STL)\\u2705**\\n```\\nclass Solution {\\npublic:\\nvector<int> runningSum(vector<int>& nums) {\\n    partial_sum(begin(nums), end(nums), begin(nums));\\n    return nums;\\n\\t}\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       for(int i=1;i<nums.size();i++) nums[i]+=nums[i-1]; //prefix sum calculation\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nvector<int> runningSum(vector<int>& nums) {\\n    partial_sum(begin(nums), end(nums), begin(nums));\\n    return nums;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469092,
                "title": "python-easy-solution",
                "content": "```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n        final_list = []\\n        for i in range(len(nums)):\\n            final_list.append(sum(nums[:i+1]))\\n        return final_list\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n        final_list = []\\n        for i in range(len(nums)):\\n            final_list.append(sum(nums[:i+1]))\\n        return final_list\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2321846,
                "title": "python-simple-faster-solution-prefix-sum",
                "content": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        result = [nums[0]]\\n        for i in range(1,len(nums)):\\n            result.append(result[i-1] + nums[i])\\n        return result\\n```\\nPlease UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        result = [nums[0]]\\n        for i in range(1,len(nums)):\\n            result.append(result[i-1] + nums[i])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291984,
                "title": "ruby-96-faster-solution",
                "content": "```\\n@param {Integer[]} nums\\n@return {Integer[]}\\ndef running_sum(nums)\\n    (nums.length).times do |i|\\n        if i >= 1\\n            nums[i] += nums[i - 1] \\n        end\\n    end\\n    nums\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n@param {Integer[]} nums\\n@return {Integer[]}\\ndef running_sum(nums)\\n    (nums.length).times do |i|\\n        if i >= 1\\n            nums[i] += nums[i - 1] \\n        end\\n    end\\n    nums\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2219705,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums)):\\n            nums[i] += nums[i - 1]\\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums)):\\n            nums[i] += nums[i - 1]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099271,
                "title": "c-prefix-solution-o-n-dlc-1-june",
                "content": "**Please do upvote if u like the solution:)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        int sum = 0;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            sum += nums[i];\\n            ans.push_back(sum);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        int sum = 0;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            sum += nums[i];\\n            ans.push_back(sum);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099257,
                "title": "c-easy-and-short-solution-prefix-sum",
                "content": "This is quite simple and intitutive approach\\n\\nIn this solution we iterate through our vector and add previous index value to current index value and store it in current index\\n\\nTime complexity for given solution is O(N) and Space complexity is O(1)\\nN = size of nums \\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i=1;i<n;i++) {\\n            nums[i]+=nums[i-1];\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\nHowever there can be a variation of this question as vector nums is passed by reference \\nSo if question mentions that we do not have to update original vector we can move forward with another solution\\n\\nHere we create a another vector of same size of vector nums and intialize it with 0\\nwe iterate through nums vector and add previous index value of res and current index value of nums and store it in current index of res \\n\\nTime complexity for this solution is O(N) and space complexity for this is also O(N)\\nN = size of nums\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        res.assign(n,0);\\n        res[0] = nums[0];\\n        for (int i=1;i<n;i++) {\\n            res[i] = nums[i] + res[i-1];\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThanks",
                "solutionTags": [
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i=1;i<n;i++) {\\n            nums[i]+=nums[i-1];\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        res.assign(n,0);\\n        res[0] = nums[0];\\n        for (int i=1;i<n;i++) {\\n            res[i] = nums[i] + res[i-1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097323,
                "title": "rust-four-styles",
                "content": "I took this as a drill in different coding styles:\\n\\n1. Destructive | Functional Style - Using `scan()` to have an accumulator state, and the idiom `for_each(drop)` to consume the iterator without using it ([https://github.com/rust-lang/rust/pull/48945](https://github.com/rust-lang/rust/pull/48945)).\\n\\n```\\nimpl Solution {\\n    pub fn running_sum(mut nums: Vec<i32>) -> Vec<i32> {\\n        nums.iter_mut()\\n            .scan(0, |prev, curr| {\\n                *curr += *prev;\\n                *prev = *curr;\\n                Some(())\\n            })\\n            .for_each(drop);\\n        nums\\n    }\\n}\\n```\\n\\n2. Non-destructive | Functional - OK, `nums` is owned by `running_sum()`, so it\\'s destroyed anyway when it goes out of scope, but say you wanted to continue using `nums` later on, this is the way to do it.\\n\\n```\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        nums.into_iter()\\n            .scan(0, |prev, curr| {\\n                *prev += curr;\\n                Some(*prev)\\n            })\\n            .collect()\\n    }\\n}\\n```\\n\\n3. Destructive | Imperative - We are a person who likes manual indexing. We think we know better than the compiler how things should be done efficiently. :) Since we own `nums`, why not use it for the return value to avoid allocating another vector?\\n\\n```\\nimpl Solution {\\n    pub fn running_sum(mut nums: Vec<i32>) -> Vec<i32> {\\n        for i in 1..nums.len() {\\n            nums[i] += nums[i-1];\\n        }\\n        nums\\n    }\\n}\\n```\\n\\n4. Non-destructive | Imperative - We want to contine using `nums` and we like loops. We preallocate `rez` to avoid reallocations, and we use iterators to avoid manual indexing.\\n\\n```\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        let mut rez = vec![0; nums.len()];\\n        let mut acc = 0;\\n        for (src, dst) in nums.iter().zip(rez.iter_mut()) {\\n            acc += *src;\\n            *dst = acc;\\n        }\\n        rez\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn running_sum(mut nums: Vec<i32>) -> Vec<i32> {\\n        nums.iter_mut()\\n            .scan(0, |prev, curr| {\\n                *curr += *prev;\\n                *prev = *curr;\\n                Some(())\\n            })\\n            .for_each(drop);\\n        nums\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        nums.into_iter()\\n            .scan(0, |prev, curr| {\\n                *prev += curr;\\n                Some(*prev)\\n            })\\n            .collect()\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn running_sum(mut nums: Vec<i32>) -> Vec<i32> {\\n        for i in 1..nums.len() {\\n            nums[i] += nums[i-1];\\n        }\\n        nums\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        let mut rez = vec![0; nums.len()];\\n        let mut acc = 0;\\n        for (src, dst) in nums.iter().zip(rez.iter_mut()) {\\n            acc += *src;\\n            *dst = acc;\\n        }\\n        rez\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2012935,
                "title": "python-3-line-solution",
                "content": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            nums[i] += nums[i-1]\\n            \\n        return nums\\n            \\n    \\n```\\nIf it worked for you kindly upvote",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            nums[i] += nums[i-1]\\n            \\n        return nums\\n            \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863520,
                "title": "c-easy-solution-o-n-time-1480-running-sum-of-1d-array",
                "content": "**Code**\\n\\t\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t   vector<int> runningSum(vector<int>& nums) {\\n\\t\\t   vector<int>ans;\\n\\t\\t   int sum=0;\\n\\t\\t   for(int i=0;i<nums.size();i++)\\n\\t\\t   {\\n\\t\\t\\t   sum+=nums[i];\\n\\t\\t\\t   ans.push_back(sum);\\n\\t\\t   }\\n\\t\\t   return ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t   vector<int> runningSum(vector<int>& nums) {\\n\\t\\t   vector<int>ans;\\n\\t\\t   int sum=0;\\n\\t\\t   for(int i=0;i<nums.size();i++)\\n\\t\\t   {\\n\\t\\t\\t   sum+=nums[i];\\n\\t\\t\\t   ans.push_back(sum);\\n\\t\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 1551659,
                "title": "python-simple-solution",
                "content": "**Python :**\\n\\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\tres = [0] * len(nums)\\n\\trun_sum = sum(nums)\\n\\n\\tfor i in range(len(nums) - 1, -1, -1):\\n\\t\\tres[i] = run_sum\\n\\t\\trun_sum -= nums[i]\\n\\n\\treturn res\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\tres = [0] * len(nums)\\n\\trun_sum = sum(nums)\\n\\n\\tfor i in range(len(nums) - 1, -1, -1):\\n\\t\\tres[i] = run_sum\\n\\t\\trun_sum -= nums[i]\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1273236,
                "title": "weeb-does-python-in-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/baf3d537-de83-46b0-8d66-c7d6aafbfea0_1623725784.182452.png)\\n\\n\\tclass Solution:\\n\\t\\tdef runningSum(self, nums: List[int]) -> List[int]:\\n\\t\\t\\tresult, count = [], 0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tresult.append(count+nums[i])\\n\\t\\t\\t\\tcount+=nums[i]\\n\\t\\t\\treturn result\\n\\nAight coders, its time for some anime recommendations\\nCheck out **Dorohedoro**\\n\\n# Episodes: 12 + 1 OVA (might change in the future if Season 2 is confirmed)\\n# Genre: Action, Comedy, Fantasy, Horror, Seinen\\n\\nThis is a cool anime so grab ur popcorn and start binge watching this show",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/baf3d537-de83-46b0-8d66-c7d6aafbfea0_1623725784.182452.png)\\n\\n\\tclass Solution:\\n\\t\\tdef runningSum(self, nums: List[int]) -> List[int]:\\n\\t\\t\\tresult, count = [], 0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tresult.append(count+nums[i])\\n\\t\\t\\t\\tcount+=nums[i]\\n\\t\\t\\treturn result\\n\\nAight coders, its time for some anime recommendations\\nCheck out **Dorohedoro**\\n\\n# Episodes: 12 + 1 OVA (might change in the future if Season 2 is confirmed)\\n# Genre: Action, Comedy, Fantasy, Horror, Seinen\\n\\nThis is a cool anime so grab ur popcorn and start binge watching this show",
                "codeTag": "Java"
            },
            {
                "id": 1264327,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        if (nums.size() <= 1) return nums;\\n        for (int i = 1; i < nums.size(); i++) {\\n            nums[i] += nums[i-1];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        if (nums.size() <= 1) return nums;\\n        for (int i = 1; i < nums.size(); i++) {\\n            nums[i] += nums[i-1];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256180,
                "title": "python-2-pointer",
                "content": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        lp = 0\\n        rp = 1\\n        while(rp<len(nums)):\\n            sums = nums[lp] + nums[rp]\\n            nums[rp] = sums\\n            rp+=1\\n            lp = rp -1\\n        return nums\\n        \\n   \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        lp = 0\\n        rp = 1\\n        while(rp<len(nums)):\\n            sums = nums[lp] + nums[rp]\\n            nums[rp] = sums\\n            rp+=1\\n            lp = rp -1\\n        return nums\\n        \\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182604,
                "title": "javascript-with-map-doesn-t-modify-original-array-76-ms",
                "content": "Pretty straightforward solution, but since many of the solutions up involve modifying the input array, I wanted to put one up that returns a new array. \\n\\nRuntime: 76 ms, faster than 88.80% of JavaScript online submissions.\\nMemory Usage: 38.7 MB, less than 95.38% of JavaScript online submissions.\\n\\nTime: O(n)\\nSpace: O(n)\\n\\n```\\nconst runningSum = nums => {\\n    let total = 0;\\n    \\n    return nums.map(num => total += num);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst runningSum = nums => {\\n    let total = 0;\\n    \\n    return nums.map(num => total += num);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1135616,
                "title": "simple-java-solution-with-o-n-time-complexity-and-o-1-space-100-summited",
                "content": "class Solution {\\n    \\n    public int[] runningSum(int[] nums) {\\n       for (int i = 1; i < nums.length; i++) {\\n\\t\\t\\tnums[i] = nums[i - 1] + nums[i];\\n\\t\\t}\\n\\t\\treturn nums;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public int[] runningSum(int[] nums) {\\n       for (int i = 1; i < nums.length; i++) {\\n\\t\\t\\tnums[i] = nums[i - 1] + nums[i];\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1117894,
                "title": "faster-than-100-recursive-c",
                "content": "I notice most people did this iteratively, but you could also use recursion:\\n\\nAnother note, I\\'m seeing people use an accumulator outside their loops to track the sum. You don\\'t need that, just start on the second element, index 1, and sum the current element with the previous one. There\\'s never a need to iterate over the first element, because the running sum at that element is already equal to the element itself. For that reason we can simply check for inputs of size 1 (or 0) and return them as is.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        if(nums.size() <= 1) {\\n            return nums;\\n        }\\n        recur(nums, 1);\\n        return nums;\\n    }\\n    \\n    void recur(vector<int>& nums, int count) {\\n        if(count == nums.size()) {\\n            return;\\n        }\\n        nums.at(count) = nums.at(count) + nums.at(count - 1);\\n        recur(nums, count+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        if(nums.size() <= 1) {\\n            return nums;\\n        }\\n        recur(nums, 1);\\n        return nums;\\n    }\\n    \\n    void recur(vector<int>& nums, int count) {\\n        if(count == nums.size()) {\\n            return;\\n        }\\n        nums.at(count) = nums.at(count) + nums.at(count - 1);\\n        recur(nums, count+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1669397,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1706950,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1575473,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1655887,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1566060,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1701614,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1577000,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1673678,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1645448,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1714764,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1669397,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1706950,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1575473,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1655887,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1566060,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1701614,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1577000,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1673678,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1645448,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1714764,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1984312,
                "content": [
                    {
                        "username": "dariolabrador",
                        "content": "** REMINDER**\\nFor all absolute beginners like me,\\nLearn to identify whether it\\'s a logical error or a syntax error. This may sound obvious for most, but if your solution throws an error, it could be due to a symbol in the wrong place. And therefore, it could be the reason why you think you are a bad programmer. \\nJust do some research on the methods you want for your solution, and you will be much closer to your goal. \\nTake care yall :)"
                    },
                    {
                        "username": "AlaSaiHarsha",
                        "content": "Hey Guys here is the java code \\nif u are struck\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "cc672012",
                        "content": "For C, you can do it in place without having to `malloc` the new array.\\n\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize; // This is the size of the runningSum array. It does not matter for our solution\\n                                            // but our code will fail if we do not set this.\\n    for (int i = 0; i < numsSize; ++i) {\\n        nums[i] = i ? nums[i] + nums[i - 1] : nums[i];\\n    }\\n    return nums;\\n}\\n```"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I got same problem without assigning *returnSize."
                    },
                    {
                        "username": "Drako_Rexon",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<=i; j++) {\\n                sum += nums[j];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "Hey, your code is logically correct, but for it automatically starts from 0 but we have to start it from first element. Thats why sum = nums[i];"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So, the wrap-up bar graph display. Am I right that my python solution is being compared to submissions in languages other than python?"
                    },
                    {
                        "username": "akashnagar10",
                        "content": "EASY C++ SOLUTION\\n\\nvector<int> runningSum(vector<int>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "Tom_PB",
                        "content": "def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [num+sum(nums[:i]) for i, num in enumerate(nums)]"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "damn i feel like a chad i solved it fast lol, for my solution i just use an variable that gonna hold the sum, something like this sum += nums[i], and I made a new array that is gonna hold the sum result and thats it "
                    },
                    {
                        "username": "machodave",
                        "content": "oh lord"
                    },
                    {
                        "username": "farfromweak413",
                        "content": "This is my second problem after adding two numbers and I have seen C tutorials and am familiar with most of the C concepts some times I need to take a look at my notes but still I can code most of the beginners program but here I am just unable to first of all understand what variable is for what use the code that I wrote is this  `your inline code...your inline code...`\\nand in line 7 it is saying insufficient space so are other problems on this site the same type cause if so then I find it very hard that I would be able to practice here it is kinda frustating as sometimes I think it is just because I\\'m not using Vsc that these problems are happening.\\nShould I practice here or are there some other easier sites.I\\'m also exploring some sites on my own "
                    },
                    {
                        "username": "SaadMohammed",
                        "content": "try solving basic qs from hackerrank or go with strivers a2z dsa course\\n"
                    }
                ]
            },
            {
                "id": 1809740,
                "content": [
                    {
                        "username": "dariolabrador",
                        "content": "** REMINDER**\\nFor all absolute beginners like me,\\nLearn to identify whether it\\'s a logical error or a syntax error. This may sound obvious for most, but if your solution throws an error, it could be due to a symbol in the wrong place. And therefore, it could be the reason why you think you are a bad programmer. \\nJust do some research on the methods you want for your solution, and you will be much closer to your goal. \\nTake care yall :)"
                    },
                    {
                        "username": "AlaSaiHarsha",
                        "content": "Hey Guys here is the java code \\nif u are struck\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "cc672012",
                        "content": "For C, you can do it in place without having to `malloc` the new array.\\n\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize; // This is the size of the runningSum array. It does not matter for our solution\\n                                            // but our code will fail if we do not set this.\\n    for (int i = 0; i < numsSize; ++i) {\\n        nums[i] = i ? nums[i] + nums[i - 1] : nums[i];\\n    }\\n    return nums;\\n}\\n```"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I got same problem without assigning *returnSize."
                    },
                    {
                        "username": "Drako_Rexon",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<=i; j++) {\\n                sum += nums[j];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "Hey, your code is logically correct, but for it automatically starts from 0 but we have to start it from first element. Thats why sum = nums[i];"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So, the wrap-up bar graph display. Am I right that my python solution is being compared to submissions in languages other than python?"
                    },
                    {
                        "username": "akashnagar10",
                        "content": "EASY C++ SOLUTION\\n\\nvector<int> runningSum(vector<int>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "Tom_PB",
                        "content": "def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [num+sum(nums[:i]) for i, num in enumerate(nums)]"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "damn i feel like a chad i solved it fast lol, for my solution i just use an variable that gonna hold the sum, something like this sum += nums[i], and I made a new array that is gonna hold the sum result and thats it "
                    },
                    {
                        "username": "machodave",
                        "content": "oh lord"
                    },
                    {
                        "username": "farfromweak413",
                        "content": "This is my second problem after adding two numbers and I have seen C tutorials and am familiar with most of the C concepts some times I need to take a look at my notes but still I can code most of the beginners program but here I am just unable to first of all understand what variable is for what use the code that I wrote is this  `your inline code...your inline code...`\\nand in line 7 it is saying insufficient space so are other problems on this site the same type cause if so then I find it very hard that I would be able to practice here it is kinda frustating as sometimes I think it is just because I\\'m not using Vsc that these problems are happening.\\nShould I practice here or are there some other easier sites.I\\'m also exploring some sites on my own "
                    },
                    {
                        "username": "SaadMohammed",
                        "content": "try solving basic qs from hackerrank or go with strivers a2z dsa course\\n"
                    }
                ]
            },
            {
                "id": 1681772,
                "content": [
                    {
                        "username": "dariolabrador",
                        "content": "** REMINDER**\\nFor all absolute beginners like me,\\nLearn to identify whether it\\'s a logical error or a syntax error. This may sound obvious for most, but if your solution throws an error, it could be due to a symbol in the wrong place. And therefore, it could be the reason why you think you are a bad programmer. \\nJust do some research on the methods you want for your solution, and you will be much closer to your goal. \\nTake care yall :)"
                    },
                    {
                        "username": "AlaSaiHarsha",
                        "content": "Hey Guys here is the java code \\nif u are struck\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "cc672012",
                        "content": "For C, you can do it in place without having to `malloc` the new array.\\n\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize; // This is the size of the runningSum array. It does not matter for our solution\\n                                            // but our code will fail if we do not set this.\\n    for (int i = 0; i < numsSize; ++i) {\\n        nums[i] = i ? nums[i] + nums[i - 1] : nums[i];\\n    }\\n    return nums;\\n}\\n```"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I got same problem without assigning *returnSize."
                    },
                    {
                        "username": "Drako_Rexon",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<=i; j++) {\\n                sum += nums[j];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "Hey, your code is logically correct, but for it automatically starts from 0 but we have to start it from first element. Thats why sum = nums[i];"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So, the wrap-up bar graph display. Am I right that my python solution is being compared to submissions in languages other than python?"
                    },
                    {
                        "username": "akashnagar10",
                        "content": "EASY C++ SOLUTION\\n\\nvector<int> runningSum(vector<int>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "Tom_PB",
                        "content": "def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [num+sum(nums[:i]) for i, num in enumerate(nums)]"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "damn i feel like a chad i solved it fast lol, for my solution i just use an variable that gonna hold the sum, something like this sum += nums[i], and I made a new array that is gonna hold the sum result and thats it "
                    },
                    {
                        "username": "machodave",
                        "content": "oh lord"
                    },
                    {
                        "username": "farfromweak413",
                        "content": "This is my second problem after adding two numbers and I have seen C tutorials and am familiar with most of the C concepts some times I need to take a look at my notes but still I can code most of the beginners program but here I am just unable to first of all understand what variable is for what use the code that I wrote is this  `your inline code...your inline code...`\\nand in line 7 it is saying insufficient space so are other problems on this site the same type cause if so then I find it very hard that I would be able to practice here it is kinda frustating as sometimes I think it is just because I\\'m not using Vsc that these problems are happening.\\nShould I practice here or are there some other easier sites.I\\'m also exploring some sites on my own "
                    },
                    {
                        "username": "SaadMohammed",
                        "content": "try solving basic qs from hackerrank or go with strivers a2z dsa course\\n"
                    }
                ]
            },
            {
                "id": 1803170,
                "content": [
                    {
                        "username": "dariolabrador",
                        "content": "** REMINDER**\\nFor all absolute beginners like me,\\nLearn to identify whether it\\'s a logical error or a syntax error. This may sound obvious for most, but if your solution throws an error, it could be due to a symbol in the wrong place. And therefore, it could be the reason why you think you are a bad programmer. \\nJust do some research on the methods you want for your solution, and you will be much closer to your goal. \\nTake care yall :)"
                    },
                    {
                        "username": "AlaSaiHarsha",
                        "content": "Hey Guys here is the java code \\nif u are struck\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "cc672012",
                        "content": "For C, you can do it in place without having to `malloc` the new array.\\n\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize; // This is the size of the runningSum array. It does not matter for our solution\\n                                            // but our code will fail if we do not set this.\\n    for (int i = 0; i < numsSize; ++i) {\\n        nums[i] = i ? nums[i] + nums[i - 1] : nums[i];\\n    }\\n    return nums;\\n}\\n```"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I got same problem without assigning *returnSize."
                    },
                    {
                        "username": "Drako_Rexon",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<=i; j++) {\\n                sum += nums[j];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "Hey, your code is logically correct, but for it automatically starts from 0 but we have to start it from first element. Thats why sum = nums[i];"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So, the wrap-up bar graph display. Am I right that my python solution is being compared to submissions in languages other than python?"
                    },
                    {
                        "username": "akashnagar10",
                        "content": "EASY C++ SOLUTION\\n\\nvector<int> runningSum(vector<int>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "Tom_PB",
                        "content": "def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [num+sum(nums[:i]) for i, num in enumerate(nums)]"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "damn i feel like a chad i solved it fast lol, for my solution i just use an variable that gonna hold the sum, something like this sum += nums[i], and I made a new array that is gonna hold the sum result and thats it "
                    },
                    {
                        "username": "machodave",
                        "content": "oh lord"
                    },
                    {
                        "username": "farfromweak413",
                        "content": "This is my second problem after adding two numbers and I have seen C tutorials and am familiar with most of the C concepts some times I need to take a look at my notes but still I can code most of the beginners program but here I am just unable to first of all understand what variable is for what use the code that I wrote is this  `your inline code...your inline code...`\\nand in line 7 it is saying insufficient space so are other problems on this site the same type cause if so then I find it very hard that I would be able to practice here it is kinda frustating as sometimes I think it is just because I\\'m not using Vsc that these problems are happening.\\nShould I practice here or are there some other easier sites.I\\'m also exploring some sites on my own "
                    },
                    {
                        "username": "SaadMohammed",
                        "content": "try solving basic qs from hackerrank or go with strivers a2z dsa course\\n"
                    }
                ]
            },
            {
                "id": 1773245,
                "content": [
                    {
                        "username": "dariolabrador",
                        "content": "** REMINDER**\\nFor all absolute beginners like me,\\nLearn to identify whether it\\'s a logical error or a syntax error. This may sound obvious for most, but if your solution throws an error, it could be due to a symbol in the wrong place. And therefore, it could be the reason why you think you are a bad programmer. \\nJust do some research on the methods you want for your solution, and you will be much closer to your goal. \\nTake care yall :)"
                    },
                    {
                        "username": "AlaSaiHarsha",
                        "content": "Hey Guys here is the java code \\nif u are struck\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "cc672012",
                        "content": "For C, you can do it in place without having to `malloc` the new array.\\n\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize; // This is the size of the runningSum array. It does not matter for our solution\\n                                            // but our code will fail if we do not set this.\\n    for (int i = 0; i < numsSize; ++i) {\\n        nums[i] = i ? nums[i] + nums[i - 1] : nums[i];\\n    }\\n    return nums;\\n}\\n```"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I got same problem without assigning *returnSize."
                    },
                    {
                        "username": "Drako_Rexon",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<=i; j++) {\\n                sum += nums[j];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "Hey, your code is logically correct, but for it automatically starts from 0 but we have to start it from first element. Thats why sum = nums[i];"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So, the wrap-up bar graph display. Am I right that my python solution is being compared to submissions in languages other than python?"
                    },
                    {
                        "username": "akashnagar10",
                        "content": "EASY C++ SOLUTION\\n\\nvector<int> runningSum(vector<int>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "Tom_PB",
                        "content": "def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [num+sum(nums[:i]) for i, num in enumerate(nums)]"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "damn i feel like a chad i solved it fast lol, for my solution i just use an variable that gonna hold the sum, something like this sum += nums[i], and I made a new array that is gonna hold the sum result and thats it "
                    },
                    {
                        "username": "machodave",
                        "content": "oh lord"
                    },
                    {
                        "username": "farfromweak413",
                        "content": "This is my second problem after adding two numbers and I have seen C tutorials and am familiar with most of the C concepts some times I need to take a look at my notes but still I can code most of the beginners program but here I am just unable to first of all understand what variable is for what use the code that I wrote is this  `your inline code...your inline code...`\\nand in line 7 it is saying insufficient space so are other problems on this site the same type cause if so then I find it very hard that I would be able to practice here it is kinda frustating as sometimes I think it is just because I\\'m not using Vsc that these problems are happening.\\nShould I practice here or are there some other easier sites.I\\'m also exploring some sites on my own "
                    },
                    {
                        "username": "SaadMohammed",
                        "content": "try solving basic qs from hackerrank or go with strivers a2z dsa course\\n"
                    }
                ]
            },
            {
                "id": 1752181,
                "content": [
                    {
                        "username": "dariolabrador",
                        "content": "** REMINDER**\\nFor all absolute beginners like me,\\nLearn to identify whether it\\'s a logical error or a syntax error. This may sound obvious for most, but if your solution throws an error, it could be due to a symbol in the wrong place. And therefore, it could be the reason why you think you are a bad programmer. \\nJust do some research on the methods you want for your solution, and you will be much closer to your goal. \\nTake care yall :)"
                    },
                    {
                        "username": "AlaSaiHarsha",
                        "content": "Hey Guys here is the java code \\nif u are struck\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "cc672012",
                        "content": "For C, you can do it in place without having to `malloc` the new array.\\n\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize; // This is the size of the runningSum array. It does not matter for our solution\\n                                            // but our code will fail if we do not set this.\\n    for (int i = 0; i < numsSize; ++i) {\\n        nums[i] = i ? nums[i] + nums[i - 1] : nums[i];\\n    }\\n    return nums;\\n}\\n```"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I got same problem without assigning *returnSize."
                    },
                    {
                        "username": "Drako_Rexon",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<=i; j++) {\\n                sum += nums[j];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "Hey, your code is logically correct, but for it automatically starts from 0 but we have to start it from first element. Thats why sum = nums[i];"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So, the wrap-up bar graph display. Am I right that my python solution is being compared to submissions in languages other than python?"
                    },
                    {
                        "username": "akashnagar10",
                        "content": "EASY C++ SOLUTION\\n\\nvector<int> runningSum(vector<int>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "Tom_PB",
                        "content": "def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [num+sum(nums[:i]) for i, num in enumerate(nums)]"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "damn i feel like a chad i solved it fast lol, for my solution i just use an variable that gonna hold the sum, something like this sum += nums[i], and I made a new array that is gonna hold the sum result and thats it "
                    },
                    {
                        "username": "machodave",
                        "content": "oh lord"
                    },
                    {
                        "username": "farfromweak413",
                        "content": "This is my second problem after adding two numbers and I have seen C tutorials and am familiar with most of the C concepts some times I need to take a look at my notes but still I can code most of the beginners program but here I am just unable to first of all understand what variable is for what use the code that I wrote is this  `your inline code...your inline code...`\\nand in line 7 it is saying insufficient space so are other problems on this site the same type cause if so then I find it very hard that I would be able to practice here it is kinda frustating as sometimes I think it is just because I\\'m not using Vsc that these problems are happening.\\nShould I practice here or are there some other easier sites.I\\'m also exploring some sites on my own "
                    },
                    {
                        "username": "SaadMohammed",
                        "content": "try solving basic qs from hackerrank or go with strivers a2z dsa course\\n"
                    }
                ]
            },
            {
                "id": 1576953,
                "content": [
                    {
                        "username": "dariolabrador",
                        "content": "** REMINDER**\\nFor all absolute beginners like me,\\nLearn to identify whether it\\'s a logical error or a syntax error. This may sound obvious for most, but if your solution throws an error, it could be due to a symbol in the wrong place. And therefore, it could be the reason why you think you are a bad programmer. \\nJust do some research on the methods you want for your solution, and you will be much closer to your goal. \\nTake care yall :)"
                    },
                    {
                        "username": "AlaSaiHarsha",
                        "content": "Hey Guys here is the java code \\nif u are struck\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "cc672012",
                        "content": "For C, you can do it in place without having to `malloc` the new array.\\n\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize; // This is the size of the runningSum array. It does not matter for our solution\\n                                            // but our code will fail if we do not set this.\\n    for (int i = 0; i < numsSize; ++i) {\\n        nums[i] = i ? nums[i] + nums[i - 1] : nums[i];\\n    }\\n    return nums;\\n}\\n```"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I got same problem without assigning *returnSize."
                    },
                    {
                        "username": "Drako_Rexon",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<=i; j++) {\\n                sum += nums[j];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "Hey, your code is logically correct, but for it automatically starts from 0 but we have to start it from first element. Thats why sum = nums[i];"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So, the wrap-up bar graph display. Am I right that my python solution is being compared to submissions in languages other than python?"
                    },
                    {
                        "username": "akashnagar10",
                        "content": "EASY C++ SOLUTION\\n\\nvector<int> runningSum(vector<int>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "Tom_PB",
                        "content": "def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [num+sum(nums[:i]) for i, num in enumerate(nums)]"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "damn i feel like a chad i solved it fast lol, for my solution i just use an variable that gonna hold the sum, something like this sum += nums[i], and I made a new array that is gonna hold the sum result and thats it "
                    },
                    {
                        "username": "machodave",
                        "content": "oh lord"
                    },
                    {
                        "username": "farfromweak413",
                        "content": "This is my second problem after adding two numbers and I have seen C tutorials and am familiar with most of the C concepts some times I need to take a look at my notes but still I can code most of the beginners program but here I am just unable to first of all understand what variable is for what use the code that I wrote is this  `your inline code...your inline code...`\\nand in line 7 it is saying insufficient space so are other problems on this site the same type cause if so then I find it very hard that I would be able to practice here it is kinda frustating as sometimes I think it is just because I\\'m not using Vsc that these problems are happening.\\nShould I practice here or are there some other easier sites.I\\'m also exploring some sites on my own "
                    },
                    {
                        "username": "SaadMohammed",
                        "content": "try solving basic qs from hackerrank or go with strivers a2z dsa course\\n"
                    }
                ]
            },
            {
                "id": 2062008,
                "content": [
                    {
                        "username": "dariolabrador",
                        "content": "** REMINDER**\\nFor all absolute beginners like me,\\nLearn to identify whether it\\'s a logical error or a syntax error. This may sound obvious for most, but if your solution throws an error, it could be due to a symbol in the wrong place. And therefore, it could be the reason why you think you are a bad programmer. \\nJust do some research on the methods you want for your solution, and you will be much closer to your goal. \\nTake care yall :)"
                    },
                    {
                        "username": "AlaSaiHarsha",
                        "content": "Hey Guys here is the java code \\nif u are struck\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "cc672012",
                        "content": "For C, you can do it in place without having to `malloc` the new array.\\n\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize; // This is the size of the runningSum array. It does not matter for our solution\\n                                            // but our code will fail if we do not set this.\\n    for (int i = 0; i < numsSize; ++i) {\\n        nums[i] = i ? nums[i] + nums[i - 1] : nums[i];\\n    }\\n    return nums;\\n}\\n```"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I got same problem without assigning *returnSize."
                    },
                    {
                        "username": "Drako_Rexon",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<=i; j++) {\\n                sum += nums[j];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "Hey, your code is logically correct, but for it automatically starts from 0 but we have to start it from first element. Thats why sum = nums[i];"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So, the wrap-up bar graph display. Am I right that my python solution is being compared to submissions in languages other than python?"
                    },
                    {
                        "username": "akashnagar10",
                        "content": "EASY C++ SOLUTION\\n\\nvector<int> runningSum(vector<int>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "Tom_PB",
                        "content": "def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [num+sum(nums[:i]) for i, num in enumerate(nums)]"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "damn i feel like a chad i solved it fast lol, for my solution i just use an variable that gonna hold the sum, something like this sum += nums[i], and I made a new array that is gonna hold the sum result and thats it "
                    },
                    {
                        "username": "machodave",
                        "content": "oh lord"
                    },
                    {
                        "username": "farfromweak413",
                        "content": "This is my second problem after adding two numbers and I have seen C tutorials and am familiar with most of the C concepts some times I need to take a look at my notes but still I can code most of the beginners program but here I am just unable to first of all understand what variable is for what use the code that I wrote is this  `your inline code...your inline code...`\\nand in line 7 it is saying insufficient space so are other problems on this site the same type cause if so then I find it very hard that I would be able to practice here it is kinda frustating as sometimes I think it is just because I\\'m not using Vsc that these problems are happening.\\nShould I practice here or are there some other easier sites.I\\'m also exploring some sites on my own "
                    },
                    {
                        "username": "SaadMohammed",
                        "content": "try solving basic qs from hackerrank or go with strivers a2z dsa course\\n"
                    }
                ]
            },
            {
                "id": 2020940,
                "content": [
                    {
                        "username": "dariolabrador",
                        "content": "** REMINDER**\\nFor all absolute beginners like me,\\nLearn to identify whether it\\'s a logical error or a syntax error. This may sound obvious for most, but if your solution throws an error, it could be due to a symbol in the wrong place. And therefore, it could be the reason why you think you are a bad programmer. \\nJust do some research on the methods you want for your solution, and you will be much closer to your goal. \\nTake care yall :)"
                    },
                    {
                        "username": "AlaSaiHarsha",
                        "content": "Hey Guys here is the java code \\nif u are struck\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "cc672012",
                        "content": "For C, you can do it in place without having to `malloc` the new array.\\n\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize; // This is the size of the runningSum array. It does not matter for our solution\\n                                            // but our code will fail if we do not set this.\\n    for (int i = 0; i < numsSize; ++i) {\\n        nums[i] = i ? nums[i] + nums[i - 1] : nums[i];\\n    }\\n    return nums;\\n}\\n```"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I got same problem without assigning *returnSize."
                    },
                    {
                        "username": "Drako_Rexon",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<=i; j++) {\\n                sum += nums[j];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "Hey, your code is logically correct, but for it automatically starts from 0 but we have to start it from first element. Thats why sum = nums[i];"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So, the wrap-up bar graph display. Am I right that my python solution is being compared to submissions in languages other than python?"
                    },
                    {
                        "username": "akashnagar10",
                        "content": "EASY C++ SOLUTION\\n\\nvector<int> runningSum(vector<int>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "Tom_PB",
                        "content": "def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [num+sum(nums[:i]) for i, num in enumerate(nums)]"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "damn i feel like a chad i solved it fast lol, for my solution i just use an variable that gonna hold the sum, something like this sum += nums[i], and I made a new array that is gonna hold the sum result and thats it "
                    },
                    {
                        "username": "machodave",
                        "content": "oh lord"
                    },
                    {
                        "username": "farfromweak413",
                        "content": "This is my second problem after adding two numbers and I have seen C tutorials and am familiar with most of the C concepts some times I need to take a look at my notes but still I can code most of the beginners program but here I am just unable to first of all understand what variable is for what use the code that I wrote is this  `your inline code...your inline code...`\\nand in line 7 it is saying insufficient space so are other problems on this site the same type cause if so then I find it very hard that I would be able to practice here it is kinda frustating as sometimes I think it is just because I\\'m not using Vsc that these problems are happening.\\nShould I practice here or are there some other easier sites.I\\'m also exploring some sites on my own "
                    },
                    {
                        "username": "SaadMohammed",
                        "content": "try solving basic qs from hackerrank or go with strivers a2z dsa course\\n"
                    }
                ]
            },
            {
                "id": 2018805,
                "content": [
                    {
                        "username": "dariolabrador",
                        "content": "** REMINDER**\\nFor all absolute beginners like me,\\nLearn to identify whether it\\'s a logical error or a syntax error. This may sound obvious for most, but if your solution throws an error, it could be due to a symbol in the wrong place. And therefore, it could be the reason why you think you are a bad programmer. \\nJust do some research on the methods you want for your solution, and you will be much closer to your goal. \\nTake care yall :)"
                    },
                    {
                        "username": "AlaSaiHarsha",
                        "content": "Hey Guys here is the java code \\nif u are struck\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "cc672012",
                        "content": "For C, you can do it in place without having to `malloc` the new array.\\n\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize; // This is the size of the runningSum array. It does not matter for our solution\\n                                            // but our code will fail if we do not set this.\\n    for (int i = 0; i < numsSize; ++i) {\\n        nums[i] = i ? nums[i] + nums[i - 1] : nums[i];\\n    }\\n    return nums;\\n}\\n```"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I got same problem without assigning *returnSize."
                    },
                    {
                        "username": "Drako_Rexon",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<=i; j++) {\\n                sum += nums[j];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "Hey, your code is logically correct, but for it automatically starts from 0 but we have to start it from first element. Thats why sum = nums[i];"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So, the wrap-up bar graph display. Am I right that my python solution is being compared to submissions in languages other than python?"
                    },
                    {
                        "username": "akashnagar10",
                        "content": "EASY C++ SOLUTION\\n\\nvector<int> runningSum(vector<int>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "Tom_PB",
                        "content": "def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [num+sum(nums[:i]) for i, num in enumerate(nums)]"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "damn i feel like a chad i solved it fast lol, for my solution i just use an variable that gonna hold the sum, something like this sum += nums[i], and I made a new array that is gonna hold the sum result and thats it "
                    },
                    {
                        "username": "machodave",
                        "content": "oh lord"
                    },
                    {
                        "username": "farfromweak413",
                        "content": "This is my second problem after adding two numbers and I have seen C tutorials and am familiar with most of the C concepts some times I need to take a look at my notes but still I can code most of the beginners program but here I am just unable to first of all understand what variable is for what use the code that I wrote is this  `your inline code...your inline code...`\\nand in line 7 it is saying insufficient space so are other problems on this site the same type cause if so then I find it very hard that I would be able to practice here it is kinda frustating as sometimes I think it is just because I\\'m not using Vsc that these problems are happening.\\nShould I practice here or are there some other easier sites.I\\'m also exploring some sites on my own "
                    },
                    {
                        "username": "SaadMohammed",
                        "content": "try solving basic qs from hackerrank or go with strivers a2z dsa course\\n"
                    }
                ]
            },
            {
                "id": 2014818,
                "content": [
                    {
                        "username": "riteshpatil_01",
                        "content": "why it is giving memory limit exceeded error?"
                    },
                    {
                        "username": "erenyeager1",
                        "content": "i dont get it , what is the argument int* retrunsize? \\ni get that *num is the array ant numsize is the num size hahah\\nbut what is the retrunsize exactly? is a pointer but for what? \\nand what should i retrun ? a pointer to the running sum array or what?? its really unclear!!"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "Time Complexity =O(n) , Space complexity = O(n)\\nThis question is super easy \\n\\nfollow these step :\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int temp = nums[0];\\n        int arr[]= new int [n];\\n        arr[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            arr[i]= temp+nums[i];\\n            temp = arr[i];\\n        }\\n        return arr;\\n    }\\n}[leetcode](https://leetcode.com) [@LeetCode](/LeetCode) `your inline code...your inline code...`\\n"
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "Is there better way to solve this problem without using a 2nd array ?\\nplz help me .."
                    },
                    {
                        "username": "syntaxtee",
                        "content": "public static int[] runningSum(int[] nums){\\nint sum = 0;\\nfor (int i = 0; i < nums.length; i++) {\\nsum = sum + nums[i];\\nnums[i] = sum;\\n}\\nreturn nums;\\n}\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "codefreak10",
                        "content": "Can anyone give me some hints and ideas in building my logic?\\nI stuck at the easiest problems, although i do get the knack of how to solve the problem but unable to approach it practically on my own."
                    },
                    {
                        "username": "syntaxtee",
                        "content": " public static int[] runningSum(int[] nums){\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "liuzheng1990",
                        "content": "I think the question should state whether it\\'s acceptable for user to mutate the `nums` parameter. It makes a huge difference for spatial complexity."
                    },
                    {
                        "username": "SumanKumarSP",
                        "content": "The problem statement has below constraints to check the value of nums[i];\\n\\nConstraints:\\n-10^6 <= nums[i] <= 10^6\\n\\nHow can we check if the value of nums[i] falls within this range in c programming?"
                    },
                    {
                        "username": "sarath480",
                        "content": "loop over the array and then add the elements from the first index to current index in another loop "
                    },
                    {
                        "username": "Scientifik",
                        "content": "I got the answer to this right away but I have a question about the big O space complexity. I chose the in place solution when solving it myself because I figured it would have better space complexity due to not creating an additional array. However when I watched the video answer to this after solving it I was surprised to find the space complexity to the answer when making an array to hold all the values and then returning it was also O(1). \\n\\nThings like this is where big O trips me up. When you make a new array to hold as many values as the input array why wouldn\\'t you need space complexity of O(n)? Is this because of garbage collection? \\n\\nFor example let\\'s say you ran that code on a total potato and that computer only had 1.5n total memory space where n was the size of the array you were trying to work with. You create a list of size n so now you are left with .5n memory. You now run that through the function which makes a new array to store the value. When we are in this function wouldn\\'t we run out of memory as we are filling the new array with values because the scope we are in would hold both the input array to the function which is called and now an array that is being filled by the logic of our loop?"
                    }
                ]
            },
            {
                "id": 1999939,
                "content": [
                    {
                        "username": "riteshpatil_01",
                        "content": "why it is giving memory limit exceeded error?"
                    },
                    {
                        "username": "erenyeager1",
                        "content": "i dont get it , what is the argument int* retrunsize? \\ni get that *num is the array ant numsize is the num size hahah\\nbut what is the retrunsize exactly? is a pointer but for what? \\nand what should i retrun ? a pointer to the running sum array or what?? its really unclear!!"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "Time Complexity =O(n) , Space complexity = O(n)\\nThis question is super easy \\n\\nfollow these step :\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int temp = nums[0];\\n        int arr[]= new int [n];\\n        arr[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            arr[i]= temp+nums[i];\\n            temp = arr[i];\\n        }\\n        return arr;\\n    }\\n}[leetcode](https://leetcode.com) [@LeetCode](/LeetCode) `your inline code...your inline code...`\\n"
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "Is there better way to solve this problem without using a 2nd array ?\\nplz help me .."
                    },
                    {
                        "username": "syntaxtee",
                        "content": "public static int[] runningSum(int[] nums){\\nint sum = 0;\\nfor (int i = 0; i < nums.length; i++) {\\nsum = sum + nums[i];\\nnums[i] = sum;\\n}\\nreturn nums;\\n}\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "codefreak10",
                        "content": "Can anyone give me some hints and ideas in building my logic?\\nI stuck at the easiest problems, although i do get the knack of how to solve the problem but unable to approach it practically on my own."
                    },
                    {
                        "username": "syntaxtee",
                        "content": " public static int[] runningSum(int[] nums){\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "liuzheng1990",
                        "content": "I think the question should state whether it\\'s acceptable for user to mutate the `nums` parameter. It makes a huge difference for spatial complexity."
                    },
                    {
                        "username": "SumanKumarSP",
                        "content": "The problem statement has below constraints to check the value of nums[i];\\n\\nConstraints:\\n-10^6 <= nums[i] <= 10^6\\n\\nHow can we check if the value of nums[i] falls within this range in c programming?"
                    },
                    {
                        "username": "sarath480",
                        "content": "loop over the array and then add the elements from the first index to current index in another loop "
                    },
                    {
                        "username": "Scientifik",
                        "content": "I got the answer to this right away but I have a question about the big O space complexity. I chose the in place solution when solving it myself because I figured it would have better space complexity due to not creating an additional array. However when I watched the video answer to this after solving it I was surprised to find the space complexity to the answer when making an array to hold all the values and then returning it was also O(1). \\n\\nThings like this is where big O trips me up. When you make a new array to hold as many values as the input array why wouldn\\'t you need space complexity of O(n)? Is this because of garbage collection? \\n\\nFor example let\\'s say you ran that code on a total potato and that computer only had 1.5n total memory space where n was the size of the array you were trying to work with. You create a list of size n so now you are left with .5n memory. You now run that through the function which makes a new array to store the value. When we are in this function wouldn\\'t we run out of memory as we are filling the new array with values because the scope we are in would hold both the input array to the function which is called and now an array that is being filled by the logic of our loop?"
                    }
                ]
            },
            {
                "id": 1979798,
                "content": [
                    {
                        "username": "riteshpatil_01",
                        "content": "why it is giving memory limit exceeded error?"
                    },
                    {
                        "username": "erenyeager1",
                        "content": "i dont get it , what is the argument int* retrunsize? \\ni get that *num is the array ant numsize is the num size hahah\\nbut what is the retrunsize exactly? is a pointer but for what? \\nand what should i retrun ? a pointer to the running sum array or what?? its really unclear!!"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "Time Complexity =O(n) , Space complexity = O(n)\\nThis question is super easy \\n\\nfollow these step :\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int temp = nums[0];\\n        int arr[]= new int [n];\\n        arr[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            arr[i]= temp+nums[i];\\n            temp = arr[i];\\n        }\\n        return arr;\\n    }\\n}[leetcode](https://leetcode.com) [@LeetCode](/LeetCode) `your inline code...your inline code...`\\n"
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "Is there better way to solve this problem without using a 2nd array ?\\nplz help me .."
                    },
                    {
                        "username": "syntaxtee",
                        "content": "public static int[] runningSum(int[] nums){\\nint sum = 0;\\nfor (int i = 0; i < nums.length; i++) {\\nsum = sum + nums[i];\\nnums[i] = sum;\\n}\\nreturn nums;\\n}\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "codefreak10",
                        "content": "Can anyone give me some hints and ideas in building my logic?\\nI stuck at the easiest problems, although i do get the knack of how to solve the problem but unable to approach it practically on my own."
                    },
                    {
                        "username": "syntaxtee",
                        "content": " public static int[] runningSum(int[] nums){\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "liuzheng1990",
                        "content": "I think the question should state whether it\\'s acceptable for user to mutate the `nums` parameter. It makes a huge difference for spatial complexity."
                    },
                    {
                        "username": "SumanKumarSP",
                        "content": "The problem statement has below constraints to check the value of nums[i];\\n\\nConstraints:\\n-10^6 <= nums[i] <= 10^6\\n\\nHow can we check if the value of nums[i] falls within this range in c programming?"
                    },
                    {
                        "username": "sarath480",
                        "content": "loop over the array and then add the elements from the first index to current index in another loop "
                    },
                    {
                        "username": "Scientifik",
                        "content": "I got the answer to this right away but I have a question about the big O space complexity. I chose the in place solution when solving it myself because I figured it would have better space complexity due to not creating an additional array. However when I watched the video answer to this after solving it I was surprised to find the space complexity to the answer when making an array to hold all the values and then returning it was also O(1). \\n\\nThings like this is where big O trips me up. When you make a new array to hold as many values as the input array why wouldn\\'t you need space complexity of O(n)? Is this because of garbage collection? \\n\\nFor example let\\'s say you ran that code on a total potato and that computer only had 1.5n total memory space where n was the size of the array you were trying to work with. You create a list of size n so now you are left with .5n memory. You now run that through the function which makes a new array to store the value. When we are in this function wouldn\\'t we run out of memory as we are filling the new array with values because the scope we are in would hold both the input array to the function which is called and now an array that is being filled by the logic of our loop?"
                    }
                ]
            },
            {
                "id": 1958614,
                "content": [
                    {
                        "username": "riteshpatil_01",
                        "content": "why it is giving memory limit exceeded error?"
                    },
                    {
                        "username": "erenyeager1",
                        "content": "i dont get it , what is the argument int* retrunsize? \\ni get that *num is the array ant numsize is the num size hahah\\nbut what is the retrunsize exactly? is a pointer but for what? \\nand what should i retrun ? a pointer to the running sum array or what?? its really unclear!!"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "Time Complexity =O(n) , Space complexity = O(n)\\nThis question is super easy \\n\\nfollow these step :\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int temp = nums[0];\\n        int arr[]= new int [n];\\n        arr[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            arr[i]= temp+nums[i];\\n            temp = arr[i];\\n        }\\n        return arr;\\n    }\\n}[leetcode](https://leetcode.com) [@LeetCode](/LeetCode) `your inline code...your inline code...`\\n"
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "Is there better way to solve this problem without using a 2nd array ?\\nplz help me .."
                    },
                    {
                        "username": "syntaxtee",
                        "content": "public static int[] runningSum(int[] nums){\\nint sum = 0;\\nfor (int i = 0; i < nums.length; i++) {\\nsum = sum + nums[i];\\nnums[i] = sum;\\n}\\nreturn nums;\\n}\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "codefreak10",
                        "content": "Can anyone give me some hints and ideas in building my logic?\\nI stuck at the easiest problems, although i do get the knack of how to solve the problem but unable to approach it practically on my own."
                    },
                    {
                        "username": "syntaxtee",
                        "content": " public static int[] runningSum(int[] nums){\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "liuzheng1990",
                        "content": "I think the question should state whether it\\'s acceptable for user to mutate the `nums` parameter. It makes a huge difference for spatial complexity."
                    },
                    {
                        "username": "SumanKumarSP",
                        "content": "The problem statement has below constraints to check the value of nums[i];\\n\\nConstraints:\\n-10^6 <= nums[i] <= 10^6\\n\\nHow can we check if the value of nums[i] falls within this range in c programming?"
                    },
                    {
                        "username": "sarath480",
                        "content": "loop over the array and then add the elements from the first index to current index in another loop "
                    },
                    {
                        "username": "Scientifik",
                        "content": "I got the answer to this right away but I have a question about the big O space complexity. I chose the in place solution when solving it myself because I figured it would have better space complexity due to not creating an additional array. However when I watched the video answer to this after solving it I was surprised to find the space complexity to the answer when making an array to hold all the values and then returning it was also O(1). \\n\\nThings like this is where big O trips me up. When you make a new array to hold as many values as the input array why wouldn\\'t you need space complexity of O(n)? Is this because of garbage collection? \\n\\nFor example let\\'s say you ran that code on a total potato and that computer only had 1.5n total memory space where n was the size of the array you were trying to work with. You create a list of size n so now you are left with .5n memory. You now run that through the function which makes a new array to store the value. When we are in this function wouldn\\'t we run out of memory as we are filling the new array with values because the scope we are in would hold both the input array to the function which is called and now an array that is being filled by the logic of our loop?"
                    }
                ]
            },
            {
                "id": 1952949,
                "content": [
                    {
                        "username": "riteshpatil_01",
                        "content": "why it is giving memory limit exceeded error?"
                    },
                    {
                        "username": "erenyeager1",
                        "content": "i dont get it , what is the argument int* retrunsize? \\ni get that *num is the array ant numsize is the num size hahah\\nbut what is the retrunsize exactly? is a pointer but for what? \\nand what should i retrun ? a pointer to the running sum array or what?? its really unclear!!"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "Time Complexity =O(n) , Space complexity = O(n)\\nThis question is super easy \\n\\nfollow these step :\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int temp = nums[0];\\n        int arr[]= new int [n];\\n        arr[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            arr[i]= temp+nums[i];\\n            temp = arr[i];\\n        }\\n        return arr;\\n    }\\n}[leetcode](https://leetcode.com) [@LeetCode](/LeetCode) `your inline code...your inline code...`\\n"
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "Is there better way to solve this problem without using a 2nd array ?\\nplz help me .."
                    },
                    {
                        "username": "syntaxtee",
                        "content": "public static int[] runningSum(int[] nums){\\nint sum = 0;\\nfor (int i = 0; i < nums.length; i++) {\\nsum = sum + nums[i];\\nnums[i] = sum;\\n}\\nreturn nums;\\n}\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "codefreak10",
                        "content": "Can anyone give me some hints and ideas in building my logic?\\nI stuck at the easiest problems, although i do get the knack of how to solve the problem but unable to approach it practically on my own."
                    },
                    {
                        "username": "syntaxtee",
                        "content": " public static int[] runningSum(int[] nums){\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "liuzheng1990",
                        "content": "I think the question should state whether it\\'s acceptable for user to mutate the `nums` parameter. It makes a huge difference for spatial complexity."
                    },
                    {
                        "username": "SumanKumarSP",
                        "content": "The problem statement has below constraints to check the value of nums[i];\\n\\nConstraints:\\n-10^6 <= nums[i] <= 10^6\\n\\nHow can we check if the value of nums[i] falls within this range in c programming?"
                    },
                    {
                        "username": "sarath480",
                        "content": "loop over the array and then add the elements from the first index to current index in another loop "
                    },
                    {
                        "username": "Scientifik",
                        "content": "I got the answer to this right away but I have a question about the big O space complexity. I chose the in place solution when solving it myself because I figured it would have better space complexity due to not creating an additional array. However when I watched the video answer to this after solving it I was surprised to find the space complexity to the answer when making an array to hold all the values and then returning it was also O(1). \\n\\nThings like this is where big O trips me up. When you make a new array to hold as many values as the input array why wouldn\\'t you need space complexity of O(n)? Is this because of garbage collection? \\n\\nFor example let\\'s say you ran that code on a total potato and that computer only had 1.5n total memory space where n was the size of the array you were trying to work with. You create a list of size n so now you are left with .5n memory. You now run that through the function which makes a new array to store the value. When we are in this function wouldn\\'t we run out of memory as we are filling the new array with values because the scope we are in would hold both the input array to the function which is called and now an array that is being filled by the logic of our loop?"
                    }
                ]
            },
            {
                "id": 1949707,
                "content": [
                    {
                        "username": "riteshpatil_01",
                        "content": "why it is giving memory limit exceeded error?"
                    },
                    {
                        "username": "erenyeager1",
                        "content": "i dont get it , what is the argument int* retrunsize? \\ni get that *num is the array ant numsize is the num size hahah\\nbut what is the retrunsize exactly? is a pointer but for what? \\nand what should i retrun ? a pointer to the running sum array or what?? its really unclear!!"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "Time Complexity =O(n) , Space complexity = O(n)\\nThis question is super easy \\n\\nfollow these step :\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int temp = nums[0];\\n        int arr[]= new int [n];\\n        arr[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            arr[i]= temp+nums[i];\\n            temp = arr[i];\\n        }\\n        return arr;\\n    }\\n}[leetcode](https://leetcode.com) [@LeetCode](/LeetCode) `your inline code...your inline code...`\\n"
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "Is there better way to solve this problem without using a 2nd array ?\\nplz help me .."
                    },
                    {
                        "username": "syntaxtee",
                        "content": "public static int[] runningSum(int[] nums){\\nint sum = 0;\\nfor (int i = 0; i < nums.length; i++) {\\nsum = sum + nums[i];\\nnums[i] = sum;\\n}\\nreturn nums;\\n}\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "codefreak10",
                        "content": "Can anyone give me some hints and ideas in building my logic?\\nI stuck at the easiest problems, although i do get the knack of how to solve the problem but unable to approach it practically on my own."
                    },
                    {
                        "username": "syntaxtee",
                        "content": " public static int[] runningSum(int[] nums){\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "liuzheng1990",
                        "content": "I think the question should state whether it\\'s acceptable for user to mutate the `nums` parameter. It makes a huge difference for spatial complexity."
                    },
                    {
                        "username": "SumanKumarSP",
                        "content": "The problem statement has below constraints to check the value of nums[i];\\n\\nConstraints:\\n-10^6 <= nums[i] <= 10^6\\n\\nHow can we check if the value of nums[i] falls within this range in c programming?"
                    },
                    {
                        "username": "sarath480",
                        "content": "loop over the array and then add the elements from the first index to current index in another loop "
                    },
                    {
                        "username": "Scientifik",
                        "content": "I got the answer to this right away but I have a question about the big O space complexity. I chose the in place solution when solving it myself because I figured it would have better space complexity due to not creating an additional array. However when I watched the video answer to this after solving it I was surprised to find the space complexity to the answer when making an array to hold all the values and then returning it was also O(1). \\n\\nThings like this is where big O trips me up. When you make a new array to hold as many values as the input array why wouldn\\'t you need space complexity of O(n)? Is this because of garbage collection? \\n\\nFor example let\\'s say you ran that code on a total potato and that computer only had 1.5n total memory space where n was the size of the array you were trying to work with. You create a list of size n so now you are left with .5n memory. You now run that through the function which makes a new array to store the value. When we are in this function wouldn\\'t we run out of memory as we are filling the new array with values because the scope we are in would hold both the input array to the function which is called and now an array that is being filled by the logic of our loop?"
                    }
                ]
            },
            {
                "id": 1939996,
                "content": [
                    {
                        "username": "riteshpatil_01",
                        "content": "why it is giving memory limit exceeded error?"
                    },
                    {
                        "username": "erenyeager1",
                        "content": "i dont get it , what is the argument int* retrunsize? \\ni get that *num is the array ant numsize is the num size hahah\\nbut what is the retrunsize exactly? is a pointer but for what? \\nand what should i retrun ? a pointer to the running sum array or what?? its really unclear!!"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "Time Complexity =O(n) , Space complexity = O(n)\\nThis question is super easy \\n\\nfollow these step :\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int temp = nums[0];\\n        int arr[]= new int [n];\\n        arr[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            arr[i]= temp+nums[i];\\n            temp = arr[i];\\n        }\\n        return arr;\\n    }\\n}[leetcode](https://leetcode.com) [@LeetCode](/LeetCode) `your inline code...your inline code...`\\n"
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "Is there better way to solve this problem without using a 2nd array ?\\nplz help me .."
                    },
                    {
                        "username": "syntaxtee",
                        "content": "public static int[] runningSum(int[] nums){\\nint sum = 0;\\nfor (int i = 0; i < nums.length; i++) {\\nsum = sum + nums[i];\\nnums[i] = sum;\\n}\\nreturn nums;\\n}\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "codefreak10",
                        "content": "Can anyone give me some hints and ideas in building my logic?\\nI stuck at the easiest problems, although i do get the knack of how to solve the problem but unable to approach it practically on my own."
                    },
                    {
                        "username": "syntaxtee",
                        "content": " public static int[] runningSum(int[] nums){\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "liuzheng1990",
                        "content": "I think the question should state whether it\\'s acceptable for user to mutate the `nums` parameter. It makes a huge difference for spatial complexity."
                    },
                    {
                        "username": "SumanKumarSP",
                        "content": "The problem statement has below constraints to check the value of nums[i];\\n\\nConstraints:\\n-10^6 <= nums[i] <= 10^6\\n\\nHow can we check if the value of nums[i] falls within this range in c programming?"
                    },
                    {
                        "username": "sarath480",
                        "content": "loop over the array and then add the elements from the first index to current index in another loop "
                    },
                    {
                        "username": "Scientifik",
                        "content": "I got the answer to this right away but I have a question about the big O space complexity. I chose the in place solution when solving it myself because I figured it would have better space complexity due to not creating an additional array. However when I watched the video answer to this after solving it I was surprised to find the space complexity to the answer when making an array to hold all the values and then returning it was also O(1). \\n\\nThings like this is where big O trips me up. When you make a new array to hold as many values as the input array why wouldn\\'t you need space complexity of O(n)? Is this because of garbage collection? \\n\\nFor example let\\'s say you ran that code on a total potato and that computer only had 1.5n total memory space where n was the size of the array you were trying to work with. You create a list of size n so now you are left with .5n memory. You now run that through the function which makes a new array to store the value. When we are in this function wouldn\\'t we run out of memory as we are filling the new array with values because the scope we are in would hold both the input array to the function which is called and now an array that is being filled by the logic of our loop?"
                    }
                ]
            },
            {
                "id": 1915618,
                "content": [
                    {
                        "username": "riteshpatil_01",
                        "content": "why it is giving memory limit exceeded error?"
                    },
                    {
                        "username": "erenyeager1",
                        "content": "i dont get it , what is the argument int* retrunsize? \\ni get that *num is the array ant numsize is the num size hahah\\nbut what is the retrunsize exactly? is a pointer but for what? \\nand what should i retrun ? a pointer to the running sum array or what?? its really unclear!!"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "Time Complexity =O(n) , Space complexity = O(n)\\nThis question is super easy \\n\\nfollow these step :\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int temp = nums[0];\\n        int arr[]= new int [n];\\n        arr[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            arr[i]= temp+nums[i];\\n            temp = arr[i];\\n        }\\n        return arr;\\n    }\\n}[leetcode](https://leetcode.com) [@LeetCode](/LeetCode) `your inline code...your inline code...`\\n"
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "Is there better way to solve this problem without using a 2nd array ?\\nplz help me .."
                    },
                    {
                        "username": "syntaxtee",
                        "content": "public static int[] runningSum(int[] nums){\\nint sum = 0;\\nfor (int i = 0; i < nums.length; i++) {\\nsum = sum + nums[i];\\nnums[i] = sum;\\n}\\nreturn nums;\\n}\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "codefreak10",
                        "content": "Can anyone give me some hints and ideas in building my logic?\\nI stuck at the easiest problems, although i do get the knack of how to solve the problem but unable to approach it practically on my own."
                    },
                    {
                        "username": "syntaxtee",
                        "content": " public static int[] runningSum(int[] nums){\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "liuzheng1990",
                        "content": "I think the question should state whether it\\'s acceptable for user to mutate the `nums` parameter. It makes a huge difference for spatial complexity."
                    },
                    {
                        "username": "SumanKumarSP",
                        "content": "The problem statement has below constraints to check the value of nums[i];\\n\\nConstraints:\\n-10^6 <= nums[i] <= 10^6\\n\\nHow can we check if the value of nums[i] falls within this range in c programming?"
                    },
                    {
                        "username": "sarath480",
                        "content": "loop over the array and then add the elements from the first index to current index in another loop "
                    },
                    {
                        "username": "Scientifik",
                        "content": "I got the answer to this right away but I have a question about the big O space complexity. I chose the in place solution when solving it myself because I figured it would have better space complexity due to not creating an additional array. However when I watched the video answer to this after solving it I was surprised to find the space complexity to the answer when making an array to hold all the values and then returning it was also O(1). \\n\\nThings like this is where big O trips me up. When you make a new array to hold as many values as the input array why wouldn\\'t you need space complexity of O(n)? Is this because of garbage collection? \\n\\nFor example let\\'s say you ran that code on a total potato and that computer only had 1.5n total memory space where n was the size of the array you were trying to work with. You create a list of size n so now you are left with .5n memory. You now run that through the function which makes a new array to store the value. When we are in this function wouldn\\'t we run out of memory as we are filling the new array with values because the scope we are in would hold both the input array to the function which is called and now an array that is being filled by the logic of our loop?"
                    }
                ]
            },
            {
                "id": 1906122,
                "content": [
                    {
                        "username": "riteshpatil_01",
                        "content": "why it is giving memory limit exceeded error?"
                    },
                    {
                        "username": "erenyeager1",
                        "content": "i dont get it , what is the argument int* retrunsize? \\ni get that *num is the array ant numsize is the num size hahah\\nbut what is the retrunsize exactly? is a pointer but for what? \\nand what should i retrun ? a pointer to the running sum array or what?? its really unclear!!"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "Time Complexity =O(n) , Space complexity = O(n)\\nThis question is super easy \\n\\nfollow these step :\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int temp = nums[0];\\n        int arr[]= new int [n];\\n        arr[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            arr[i]= temp+nums[i];\\n            temp = arr[i];\\n        }\\n        return arr;\\n    }\\n}[leetcode](https://leetcode.com) [@LeetCode](/LeetCode) `your inline code...your inline code...`\\n"
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "Is there better way to solve this problem without using a 2nd array ?\\nplz help me .."
                    },
                    {
                        "username": "syntaxtee",
                        "content": "public static int[] runningSum(int[] nums){\\nint sum = 0;\\nfor (int i = 0; i < nums.length; i++) {\\nsum = sum + nums[i];\\nnums[i] = sum;\\n}\\nreturn nums;\\n}\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "codefreak10",
                        "content": "Can anyone give me some hints and ideas in building my logic?\\nI stuck at the easiest problems, although i do get the knack of how to solve the problem but unable to approach it practically on my own."
                    },
                    {
                        "username": "syntaxtee",
                        "content": " public static int[] runningSum(int[] nums){\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "liuzheng1990",
                        "content": "I think the question should state whether it\\'s acceptable for user to mutate the `nums` parameter. It makes a huge difference for spatial complexity."
                    },
                    {
                        "username": "SumanKumarSP",
                        "content": "The problem statement has below constraints to check the value of nums[i];\\n\\nConstraints:\\n-10^6 <= nums[i] <= 10^6\\n\\nHow can we check if the value of nums[i] falls within this range in c programming?"
                    },
                    {
                        "username": "sarath480",
                        "content": "loop over the array and then add the elements from the first index to current index in another loop "
                    },
                    {
                        "username": "Scientifik",
                        "content": "I got the answer to this right away but I have a question about the big O space complexity. I chose the in place solution when solving it myself because I figured it would have better space complexity due to not creating an additional array. However when I watched the video answer to this after solving it I was surprised to find the space complexity to the answer when making an array to hold all the values and then returning it was also O(1). \\n\\nThings like this is where big O trips me up. When you make a new array to hold as many values as the input array why wouldn\\'t you need space complexity of O(n)? Is this because of garbage collection? \\n\\nFor example let\\'s say you ran that code on a total potato and that computer only had 1.5n total memory space where n was the size of the array you were trying to work with. You create a list of size n so now you are left with .5n memory. You now run that through the function which makes a new array to store the value. When we are in this function wouldn\\'t we run out of memory as we are filling the new array with values because the scope we are in would hold both the input array to the function which is called and now an array that is being filled by the logic of our loop?"
                    }
                ]
            },
            {
                "id": 1905304,
                "content": [
                    {
                        "username": "riteshpatil_01",
                        "content": "why it is giving memory limit exceeded error?"
                    },
                    {
                        "username": "erenyeager1",
                        "content": "i dont get it , what is the argument int* retrunsize? \\ni get that *num is the array ant numsize is the num size hahah\\nbut what is the retrunsize exactly? is a pointer but for what? \\nand what should i retrun ? a pointer to the running sum array or what?? its really unclear!!"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "Time Complexity =O(n) , Space complexity = O(n)\\nThis question is super easy \\n\\nfollow these step :\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int temp = nums[0];\\n        int arr[]= new int [n];\\n        arr[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            arr[i]= temp+nums[i];\\n            temp = arr[i];\\n        }\\n        return arr;\\n    }\\n}[leetcode](https://leetcode.com) [@LeetCode](/LeetCode) `your inline code...your inline code...`\\n"
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "Is there better way to solve this problem without using a 2nd array ?\\nplz help me .."
                    },
                    {
                        "username": "syntaxtee",
                        "content": "public static int[] runningSum(int[] nums){\\nint sum = 0;\\nfor (int i = 0; i < nums.length; i++) {\\nsum = sum + nums[i];\\nnums[i] = sum;\\n}\\nreturn nums;\\n}\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "codefreak10",
                        "content": "Can anyone give me some hints and ideas in building my logic?\\nI stuck at the easiest problems, although i do get the knack of how to solve the problem but unable to approach it practically on my own."
                    },
                    {
                        "username": "syntaxtee",
                        "content": " public static int[] runningSum(int[] nums){\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "liuzheng1990",
                        "content": "I think the question should state whether it\\'s acceptable for user to mutate the `nums` parameter. It makes a huge difference for spatial complexity."
                    },
                    {
                        "username": "SumanKumarSP",
                        "content": "The problem statement has below constraints to check the value of nums[i];\\n\\nConstraints:\\n-10^6 <= nums[i] <= 10^6\\n\\nHow can we check if the value of nums[i] falls within this range in c programming?"
                    },
                    {
                        "username": "sarath480",
                        "content": "loop over the array and then add the elements from the first index to current index in another loop "
                    },
                    {
                        "username": "Scientifik",
                        "content": "I got the answer to this right away but I have a question about the big O space complexity. I chose the in place solution when solving it myself because I figured it would have better space complexity due to not creating an additional array. However when I watched the video answer to this after solving it I was surprised to find the space complexity to the answer when making an array to hold all the values and then returning it was also O(1). \\n\\nThings like this is where big O trips me up. When you make a new array to hold as many values as the input array why wouldn\\'t you need space complexity of O(n)? Is this because of garbage collection? \\n\\nFor example let\\'s say you ran that code on a total potato and that computer only had 1.5n total memory space where n was the size of the array you were trying to work with. You create a list of size n so now you are left with .5n memory. You now run that through the function which makes a new array to store the value. When we are in this function wouldn\\'t we run out of memory as we are filling the new array with values because the scope we are in would hold both the input array to the function which is called and now an array that is being filled by the logic of our loop?"
                    }
                ]
            },
            {
                "id": 1896444,
                "content": [
                    {
                        "username": "Vertfromage",
                        "content": "Since Java is call by sharing wouldn\\'t that mean that the original nums array would be modified outside the method and therefore not the best practice unless you wanted to overwrite the original array? I thought it was bad practice to modify the imputed variables?"
                    },
                    {
                        "username": "taganrog85",
                        "content": "in Python I wrote my solution like this, but it writes that it is not correct\\nnums = [1, 2, 3, 4]\\nrunningSum = []\\ncount = 0\\ncount1 = 0\\nfor i in nums:\\n    count += i\\n    count1 = count\\n    runningSum.append(count1)\\nprint(runningSum)\\n"
                    },
                    {
                        "username": "ajay8766",
                        "content": "very easy"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`li = [sum(i) for i in accounts]\\n        return max(li)`"
                    },
                    {
                        "username": "syedsubhan0304",
                        "content": "i didn\\'t understand their question what it said!\\n"
                    },
                    {
                        "username": "Ursma",
                        "content": "Explain me, please, why in Intelliji IDEA this code works, but in this console: error: variable nums is already defined in method runningSum(int[])\n        int[] nums ={1, 3, 5, 7, 8};\nMy code:\n public class Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 3, 5, 7, 8};\n        int[] runningSum = new int[nums.length];\n        int sum = 0;\n        for (int i = 0; i < runningSum.length; i++) {\n            sum += nums[i];\n            runningSum[i] += sum;\n            System.out.println(runningSum[i]);\n        }\n    }\n}"
                    },
                    {
                        "username": "ygg-m",
                        "content": "My code works (solution is there, posting only to show that it works in other places): https://jsfiddle.net/nf1r5vg2/\\n\\nBut it\\'s throwing me this error: https://i.imgur.com/jfwRCOd.png\\n\\nAnyone know what\\'s happening?"
                    },
                    {
                        "username": "shuubhhaammm",
                        "content": "why i am not able to use return in this question"
                    },
                    {
                        "username": "RagulTK",
                        "content": "I got desired output  both these logic which is (nums[i]=nums[i]+nums[i-1]) and also (nums[i]+=nums[i-1])...But i got a undesired output even i wrote the code wrongly (i.e) (nums[i]=+nums[i-1]).....i also got a desired the output when i was using+=+ these combinaton of operator......what am i asking is? why i got output when i wrote code wrongly........Actaully\\nwhat happens on operators..Can you anyone please clear my doubt.  "
                    },
                    {
                        "username": "Nithish_kumar_S",
                        "content": "int* runningSum(int* nums, int numsSize, int* returnSize){\\nint i;\\nfor (i=1;i<numsSize;i++)\\n{\\n    nums[i]=+nums[i-1];\\n}\\nreturn nums;\\n}\\nwhats wrong with the above code the output is simply \"[ ]\""
                    }
                ]
            },
            {
                "id": 1890406,
                "content": [
                    {
                        "username": "Vertfromage",
                        "content": "Since Java is call by sharing wouldn\\'t that mean that the original nums array would be modified outside the method and therefore not the best practice unless you wanted to overwrite the original array? I thought it was bad practice to modify the imputed variables?"
                    },
                    {
                        "username": "taganrog85",
                        "content": "in Python I wrote my solution like this, but it writes that it is not correct\\nnums = [1, 2, 3, 4]\\nrunningSum = []\\ncount = 0\\ncount1 = 0\\nfor i in nums:\\n    count += i\\n    count1 = count\\n    runningSum.append(count1)\\nprint(runningSum)\\n"
                    },
                    {
                        "username": "ajay8766",
                        "content": "very easy"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`li = [sum(i) for i in accounts]\\n        return max(li)`"
                    },
                    {
                        "username": "syedsubhan0304",
                        "content": "i didn\\'t understand their question what it said!\\n"
                    },
                    {
                        "username": "Ursma",
                        "content": "Explain me, please, why in Intelliji IDEA this code works, but in this console: error: variable nums is already defined in method runningSum(int[])\n        int[] nums ={1, 3, 5, 7, 8};\nMy code:\n public class Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 3, 5, 7, 8};\n        int[] runningSum = new int[nums.length];\n        int sum = 0;\n        for (int i = 0; i < runningSum.length; i++) {\n            sum += nums[i];\n            runningSum[i] += sum;\n            System.out.println(runningSum[i]);\n        }\n    }\n}"
                    },
                    {
                        "username": "ygg-m",
                        "content": "My code works (solution is there, posting only to show that it works in other places): https://jsfiddle.net/nf1r5vg2/\\n\\nBut it\\'s throwing me this error: https://i.imgur.com/jfwRCOd.png\\n\\nAnyone know what\\'s happening?"
                    },
                    {
                        "username": "shuubhhaammm",
                        "content": "why i am not able to use return in this question"
                    },
                    {
                        "username": "RagulTK",
                        "content": "I got desired output  both these logic which is (nums[i]=nums[i]+nums[i-1]) and also (nums[i]+=nums[i-1])...But i got a undesired output even i wrote the code wrongly (i.e) (nums[i]=+nums[i-1]).....i also got a desired the output when i was using+=+ these combinaton of operator......what am i asking is? why i got output when i wrote code wrongly........Actaully\\nwhat happens on operators..Can you anyone please clear my doubt.  "
                    },
                    {
                        "username": "Nithish_kumar_S",
                        "content": "int* runningSum(int* nums, int numsSize, int* returnSize){\\nint i;\\nfor (i=1;i<numsSize;i++)\\n{\\n    nums[i]=+nums[i-1];\\n}\\nreturn nums;\\n}\\nwhats wrong with the above code the output is simply \"[ ]\""
                    }
                ]
            },
            {
                "id": 1842630,
                "content": [
                    {
                        "username": "Vertfromage",
                        "content": "Since Java is call by sharing wouldn\\'t that mean that the original nums array would be modified outside the method and therefore not the best practice unless you wanted to overwrite the original array? I thought it was bad practice to modify the imputed variables?"
                    },
                    {
                        "username": "taganrog85",
                        "content": "in Python I wrote my solution like this, but it writes that it is not correct\\nnums = [1, 2, 3, 4]\\nrunningSum = []\\ncount = 0\\ncount1 = 0\\nfor i in nums:\\n    count += i\\n    count1 = count\\n    runningSum.append(count1)\\nprint(runningSum)\\n"
                    },
                    {
                        "username": "ajay8766",
                        "content": "very easy"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`li = [sum(i) for i in accounts]\\n        return max(li)`"
                    },
                    {
                        "username": "syedsubhan0304",
                        "content": "i didn\\'t understand their question what it said!\\n"
                    },
                    {
                        "username": "Ursma",
                        "content": "Explain me, please, why in Intelliji IDEA this code works, but in this console: error: variable nums is already defined in method runningSum(int[])\n        int[] nums ={1, 3, 5, 7, 8};\nMy code:\n public class Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 3, 5, 7, 8};\n        int[] runningSum = new int[nums.length];\n        int sum = 0;\n        for (int i = 0; i < runningSum.length; i++) {\n            sum += nums[i];\n            runningSum[i] += sum;\n            System.out.println(runningSum[i]);\n        }\n    }\n}"
                    },
                    {
                        "username": "ygg-m",
                        "content": "My code works (solution is there, posting only to show that it works in other places): https://jsfiddle.net/nf1r5vg2/\\n\\nBut it\\'s throwing me this error: https://i.imgur.com/jfwRCOd.png\\n\\nAnyone know what\\'s happening?"
                    },
                    {
                        "username": "shuubhhaammm",
                        "content": "why i am not able to use return in this question"
                    },
                    {
                        "username": "RagulTK",
                        "content": "I got desired output  both these logic which is (nums[i]=nums[i]+nums[i-1]) and also (nums[i]+=nums[i-1])...But i got a undesired output even i wrote the code wrongly (i.e) (nums[i]=+nums[i-1]).....i also got a desired the output when i was using+=+ these combinaton of operator......what am i asking is? why i got output when i wrote code wrongly........Actaully\\nwhat happens on operators..Can you anyone please clear my doubt.  "
                    },
                    {
                        "username": "Nithish_kumar_S",
                        "content": "int* runningSum(int* nums, int numsSize, int* returnSize){\\nint i;\\nfor (i=1;i<numsSize;i++)\\n{\\n    nums[i]=+nums[i-1];\\n}\\nreturn nums;\\n}\\nwhats wrong with the above code the output is simply \"[ ]\""
                    }
                ]
            },
            {
                "id": 1842299,
                "content": [
                    {
                        "username": "Vertfromage",
                        "content": "Since Java is call by sharing wouldn\\'t that mean that the original nums array would be modified outside the method and therefore not the best practice unless you wanted to overwrite the original array? I thought it was bad practice to modify the imputed variables?"
                    },
                    {
                        "username": "taganrog85",
                        "content": "in Python I wrote my solution like this, but it writes that it is not correct\\nnums = [1, 2, 3, 4]\\nrunningSum = []\\ncount = 0\\ncount1 = 0\\nfor i in nums:\\n    count += i\\n    count1 = count\\n    runningSum.append(count1)\\nprint(runningSum)\\n"
                    },
                    {
                        "username": "ajay8766",
                        "content": "very easy"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`li = [sum(i) for i in accounts]\\n        return max(li)`"
                    },
                    {
                        "username": "syedsubhan0304",
                        "content": "i didn\\'t understand their question what it said!\\n"
                    },
                    {
                        "username": "Ursma",
                        "content": "Explain me, please, why in Intelliji IDEA this code works, but in this console: error: variable nums is already defined in method runningSum(int[])\n        int[] nums ={1, 3, 5, 7, 8};\nMy code:\n public class Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 3, 5, 7, 8};\n        int[] runningSum = new int[nums.length];\n        int sum = 0;\n        for (int i = 0; i < runningSum.length; i++) {\n            sum += nums[i];\n            runningSum[i] += sum;\n            System.out.println(runningSum[i]);\n        }\n    }\n}"
                    },
                    {
                        "username": "ygg-m",
                        "content": "My code works (solution is there, posting only to show that it works in other places): https://jsfiddle.net/nf1r5vg2/\\n\\nBut it\\'s throwing me this error: https://i.imgur.com/jfwRCOd.png\\n\\nAnyone know what\\'s happening?"
                    },
                    {
                        "username": "shuubhhaammm",
                        "content": "why i am not able to use return in this question"
                    },
                    {
                        "username": "RagulTK",
                        "content": "I got desired output  both these logic which is (nums[i]=nums[i]+nums[i-1]) and also (nums[i]+=nums[i-1])...But i got a undesired output even i wrote the code wrongly (i.e) (nums[i]=+nums[i-1]).....i also got a desired the output when i was using+=+ these combinaton of operator......what am i asking is? why i got output when i wrote code wrongly........Actaully\\nwhat happens on operators..Can you anyone please clear my doubt.  "
                    },
                    {
                        "username": "Nithish_kumar_S",
                        "content": "int* runningSum(int* nums, int numsSize, int* returnSize){\\nint i;\\nfor (i=1;i<numsSize;i++)\\n{\\n    nums[i]=+nums[i-1];\\n}\\nreturn nums;\\n}\\nwhats wrong with the above code the output is simply \"[ ]\""
                    }
                ]
            },
            {
                "id": 1826099,
                "content": [
                    {
                        "username": "Vertfromage",
                        "content": "Since Java is call by sharing wouldn\\'t that mean that the original nums array would be modified outside the method and therefore not the best practice unless you wanted to overwrite the original array? I thought it was bad practice to modify the imputed variables?"
                    },
                    {
                        "username": "taganrog85",
                        "content": "in Python I wrote my solution like this, but it writes that it is not correct\\nnums = [1, 2, 3, 4]\\nrunningSum = []\\ncount = 0\\ncount1 = 0\\nfor i in nums:\\n    count += i\\n    count1 = count\\n    runningSum.append(count1)\\nprint(runningSum)\\n"
                    },
                    {
                        "username": "ajay8766",
                        "content": "very easy"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`li = [sum(i) for i in accounts]\\n        return max(li)`"
                    },
                    {
                        "username": "syedsubhan0304",
                        "content": "i didn\\'t understand their question what it said!\\n"
                    },
                    {
                        "username": "Ursma",
                        "content": "Explain me, please, why in Intelliji IDEA this code works, but in this console: error: variable nums is already defined in method runningSum(int[])\n        int[] nums ={1, 3, 5, 7, 8};\nMy code:\n public class Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 3, 5, 7, 8};\n        int[] runningSum = new int[nums.length];\n        int sum = 0;\n        for (int i = 0; i < runningSum.length; i++) {\n            sum += nums[i];\n            runningSum[i] += sum;\n            System.out.println(runningSum[i]);\n        }\n    }\n}"
                    },
                    {
                        "username": "ygg-m",
                        "content": "My code works (solution is there, posting only to show that it works in other places): https://jsfiddle.net/nf1r5vg2/\\n\\nBut it\\'s throwing me this error: https://i.imgur.com/jfwRCOd.png\\n\\nAnyone know what\\'s happening?"
                    },
                    {
                        "username": "shuubhhaammm",
                        "content": "why i am not able to use return in this question"
                    },
                    {
                        "username": "RagulTK",
                        "content": "I got desired output  both these logic which is (nums[i]=nums[i]+nums[i-1]) and also (nums[i]+=nums[i-1])...But i got a undesired output even i wrote the code wrongly (i.e) (nums[i]=+nums[i-1]).....i also got a desired the output when i was using+=+ these combinaton of operator......what am i asking is? why i got output when i wrote code wrongly........Actaully\\nwhat happens on operators..Can you anyone please clear my doubt.  "
                    },
                    {
                        "username": "Nithish_kumar_S",
                        "content": "int* runningSum(int* nums, int numsSize, int* returnSize){\\nint i;\\nfor (i=1;i<numsSize;i++)\\n{\\n    nums[i]=+nums[i-1];\\n}\\nreturn nums;\\n}\\nwhats wrong with the above code the output is simply \"[ ]\""
                    }
                ]
            },
            {
                "id": 1820889,
                "content": [
                    {
                        "username": "Vertfromage",
                        "content": "Since Java is call by sharing wouldn\\'t that mean that the original nums array would be modified outside the method and therefore not the best practice unless you wanted to overwrite the original array? I thought it was bad practice to modify the imputed variables?"
                    },
                    {
                        "username": "taganrog85",
                        "content": "in Python I wrote my solution like this, but it writes that it is not correct\\nnums = [1, 2, 3, 4]\\nrunningSum = []\\ncount = 0\\ncount1 = 0\\nfor i in nums:\\n    count += i\\n    count1 = count\\n    runningSum.append(count1)\\nprint(runningSum)\\n"
                    },
                    {
                        "username": "ajay8766",
                        "content": "very easy"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`li = [sum(i) for i in accounts]\\n        return max(li)`"
                    },
                    {
                        "username": "syedsubhan0304",
                        "content": "i didn\\'t understand their question what it said!\\n"
                    },
                    {
                        "username": "Ursma",
                        "content": "Explain me, please, why in Intelliji IDEA this code works, but in this console: error: variable nums is already defined in method runningSum(int[])\n        int[] nums ={1, 3, 5, 7, 8};\nMy code:\n public class Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 3, 5, 7, 8};\n        int[] runningSum = new int[nums.length];\n        int sum = 0;\n        for (int i = 0; i < runningSum.length; i++) {\n            sum += nums[i];\n            runningSum[i] += sum;\n            System.out.println(runningSum[i]);\n        }\n    }\n}"
                    },
                    {
                        "username": "ygg-m",
                        "content": "My code works (solution is there, posting only to show that it works in other places): https://jsfiddle.net/nf1r5vg2/\\n\\nBut it\\'s throwing me this error: https://i.imgur.com/jfwRCOd.png\\n\\nAnyone know what\\'s happening?"
                    },
                    {
                        "username": "shuubhhaammm",
                        "content": "why i am not able to use return in this question"
                    },
                    {
                        "username": "RagulTK",
                        "content": "I got desired output  both these logic which is (nums[i]=nums[i]+nums[i-1]) and also (nums[i]+=nums[i-1])...But i got a undesired output even i wrote the code wrongly (i.e) (nums[i]=+nums[i-1]).....i also got a desired the output when i was using+=+ these combinaton of operator......what am i asking is? why i got output when i wrote code wrongly........Actaully\\nwhat happens on operators..Can you anyone please clear my doubt.  "
                    },
                    {
                        "username": "Nithish_kumar_S",
                        "content": "int* runningSum(int* nums, int numsSize, int* returnSize){\\nint i;\\nfor (i=1;i<numsSize;i++)\\n{\\n    nums[i]=+nums[i-1];\\n}\\nreturn nums;\\n}\\nwhats wrong with the above code the output is simply \"[ ]\""
                    }
                ]
            },
            {
                "id": 1810967,
                "content": [
                    {
                        "username": "Vertfromage",
                        "content": "Since Java is call by sharing wouldn\\'t that mean that the original nums array would be modified outside the method and therefore not the best practice unless you wanted to overwrite the original array? I thought it was bad practice to modify the imputed variables?"
                    },
                    {
                        "username": "taganrog85",
                        "content": "in Python I wrote my solution like this, but it writes that it is not correct\\nnums = [1, 2, 3, 4]\\nrunningSum = []\\ncount = 0\\ncount1 = 0\\nfor i in nums:\\n    count += i\\n    count1 = count\\n    runningSum.append(count1)\\nprint(runningSum)\\n"
                    },
                    {
                        "username": "ajay8766",
                        "content": "very easy"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`li = [sum(i) for i in accounts]\\n        return max(li)`"
                    },
                    {
                        "username": "syedsubhan0304",
                        "content": "i didn\\'t understand their question what it said!\\n"
                    },
                    {
                        "username": "Ursma",
                        "content": "Explain me, please, why in Intelliji IDEA this code works, but in this console: error: variable nums is already defined in method runningSum(int[])\n        int[] nums ={1, 3, 5, 7, 8};\nMy code:\n public class Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 3, 5, 7, 8};\n        int[] runningSum = new int[nums.length];\n        int sum = 0;\n        for (int i = 0; i < runningSum.length; i++) {\n            sum += nums[i];\n            runningSum[i] += sum;\n            System.out.println(runningSum[i]);\n        }\n    }\n}"
                    },
                    {
                        "username": "ygg-m",
                        "content": "My code works (solution is there, posting only to show that it works in other places): https://jsfiddle.net/nf1r5vg2/\\n\\nBut it\\'s throwing me this error: https://i.imgur.com/jfwRCOd.png\\n\\nAnyone know what\\'s happening?"
                    },
                    {
                        "username": "shuubhhaammm",
                        "content": "why i am not able to use return in this question"
                    },
                    {
                        "username": "RagulTK",
                        "content": "I got desired output  both these logic which is (nums[i]=nums[i]+nums[i-1]) and also (nums[i]+=nums[i-1])...But i got a undesired output even i wrote the code wrongly (i.e) (nums[i]=+nums[i-1]).....i also got a desired the output when i was using+=+ these combinaton of operator......what am i asking is? why i got output when i wrote code wrongly........Actaully\\nwhat happens on operators..Can you anyone please clear my doubt.  "
                    },
                    {
                        "username": "Nithish_kumar_S",
                        "content": "int* runningSum(int* nums, int numsSize, int* returnSize){\\nint i;\\nfor (i=1;i<numsSize;i++)\\n{\\n    nums[i]=+nums[i-1];\\n}\\nreturn nums;\\n}\\nwhats wrong with the above code the output is simply \"[ ]\""
                    }
                ]
            },
            {
                "id": 1807373,
                "content": [
                    {
                        "username": "Vertfromage",
                        "content": "Since Java is call by sharing wouldn\\'t that mean that the original nums array would be modified outside the method and therefore not the best practice unless you wanted to overwrite the original array? I thought it was bad practice to modify the imputed variables?"
                    },
                    {
                        "username": "taganrog85",
                        "content": "in Python I wrote my solution like this, but it writes that it is not correct\\nnums = [1, 2, 3, 4]\\nrunningSum = []\\ncount = 0\\ncount1 = 0\\nfor i in nums:\\n    count += i\\n    count1 = count\\n    runningSum.append(count1)\\nprint(runningSum)\\n"
                    },
                    {
                        "username": "ajay8766",
                        "content": "very easy"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`li = [sum(i) for i in accounts]\\n        return max(li)`"
                    },
                    {
                        "username": "syedsubhan0304",
                        "content": "i didn\\'t understand their question what it said!\\n"
                    },
                    {
                        "username": "Ursma",
                        "content": "Explain me, please, why in Intelliji IDEA this code works, but in this console: error: variable nums is already defined in method runningSum(int[])\n        int[] nums ={1, 3, 5, 7, 8};\nMy code:\n public class Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 3, 5, 7, 8};\n        int[] runningSum = new int[nums.length];\n        int sum = 0;\n        for (int i = 0; i < runningSum.length; i++) {\n            sum += nums[i];\n            runningSum[i] += sum;\n            System.out.println(runningSum[i]);\n        }\n    }\n}"
                    },
                    {
                        "username": "ygg-m",
                        "content": "My code works (solution is there, posting only to show that it works in other places): https://jsfiddle.net/nf1r5vg2/\\n\\nBut it\\'s throwing me this error: https://i.imgur.com/jfwRCOd.png\\n\\nAnyone know what\\'s happening?"
                    },
                    {
                        "username": "shuubhhaammm",
                        "content": "why i am not able to use return in this question"
                    },
                    {
                        "username": "RagulTK",
                        "content": "I got desired output  both these logic which is (nums[i]=nums[i]+nums[i-1]) and also (nums[i]+=nums[i-1])...But i got a undesired output even i wrote the code wrongly (i.e) (nums[i]=+nums[i-1]).....i also got a desired the output when i was using+=+ these combinaton of operator......what am i asking is? why i got output when i wrote code wrongly........Actaully\\nwhat happens on operators..Can you anyone please clear my doubt.  "
                    },
                    {
                        "username": "Nithish_kumar_S",
                        "content": "int* runningSum(int* nums, int numsSize, int* returnSize){\\nint i;\\nfor (i=1;i<numsSize;i++)\\n{\\n    nums[i]=+nums[i-1];\\n}\\nreturn nums;\\n}\\nwhats wrong with the above code the output is simply \"[ ]\""
                    }
                ]
            },
            {
                "id": 1804374,
                "content": [
                    {
                        "username": "Vertfromage",
                        "content": "Since Java is call by sharing wouldn\\'t that mean that the original nums array would be modified outside the method and therefore not the best practice unless you wanted to overwrite the original array? I thought it was bad practice to modify the imputed variables?"
                    },
                    {
                        "username": "taganrog85",
                        "content": "in Python I wrote my solution like this, but it writes that it is not correct\\nnums = [1, 2, 3, 4]\\nrunningSum = []\\ncount = 0\\ncount1 = 0\\nfor i in nums:\\n    count += i\\n    count1 = count\\n    runningSum.append(count1)\\nprint(runningSum)\\n"
                    },
                    {
                        "username": "ajay8766",
                        "content": "very easy"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`li = [sum(i) for i in accounts]\\n        return max(li)`"
                    },
                    {
                        "username": "syedsubhan0304",
                        "content": "i didn\\'t understand their question what it said!\\n"
                    },
                    {
                        "username": "Ursma",
                        "content": "Explain me, please, why in Intelliji IDEA this code works, but in this console: error: variable nums is already defined in method runningSum(int[])\n        int[] nums ={1, 3, 5, 7, 8};\nMy code:\n public class Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 3, 5, 7, 8};\n        int[] runningSum = new int[nums.length];\n        int sum = 0;\n        for (int i = 0; i < runningSum.length; i++) {\n            sum += nums[i];\n            runningSum[i] += sum;\n            System.out.println(runningSum[i]);\n        }\n    }\n}"
                    },
                    {
                        "username": "ygg-m",
                        "content": "My code works (solution is there, posting only to show that it works in other places): https://jsfiddle.net/nf1r5vg2/\\n\\nBut it\\'s throwing me this error: https://i.imgur.com/jfwRCOd.png\\n\\nAnyone know what\\'s happening?"
                    },
                    {
                        "username": "shuubhhaammm",
                        "content": "why i am not able to use return in this question"
                    },
                    {
                        "username": "RagulTK",
                        "content": "I got desired output  both these logic which is (nums[i]=nums[i]+nums[i-1]) and also (nums[i]+=nums[i-1])...But i got a undesired output even i wrote the code wrongly (i.e) (nums[i]=+nums[i-1]).....i also got a desired the output when i was using+=+ these combinaton of operator......what am i asking is? why i got output when i wrote code wrongly........Actaully\\nwhat happens on operators..Can you anyone please clear my doubt.  "
                    },
                    {
                        "username": "Nithish_kumar_S",
                        "content": "int* runningSum(int* nums, int numsSize, int* returnSize){\\nint i;\\nfor (i=1;i<numsSize;i++)\\n{\\n    nums[i]=+nums[i-1];\\n}\\nreturn nums;\\n}\\nwhats wrong with the above code the output is simply \"[ ]\""
                    }
                ]
            },
            {
                "id": 1795633,
                "content": [
                    {
                        "username": "Vertfromage",
                        "content": "Since Java is call by sharing wouldn\\'t that mean that the original nums array would be modified outside the method and therefore not the best practice unless you wanted to overwrite the original array? I thought it was bad practice to modify the imputed variables?"
                    },
                    {
                        "username": "taganrog85",
                        "content": "in Python I wrote my solution like this, but it writes that it is not correct\\nnums = [1, 2, 3, 4]\\nrunningSum = []\\ncount = 0\\ncount1 = 0\\nfor i in nums:\\n    count += i\\n    count1 = count\\n    runningSum.append(count1)\\nprint(runningSum)\\n"
                    },
                    {
                        "username": "ajay8766",
                        "content": "very easy"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`li = [sum(i) for i in accounts]\\n        return max(li)`"
                    },
                    {
                        "username": "syedsubhan0304",
                        "content": "i didn\\'t understand their question what it said!\\n"
                    },
                    {
                        "username": "Ursma",
                        "content": "Explain me, please, why in Intelliji IDEA this code works, but in this console: error: variable nums is already defined in method runningSum(int[])\n        int[] nums ={1, 3, 5, 7, 8};\nMy code:\n public class Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 3, 5, 7, 8};\n        int[] runningSum = new int[nums.length];\n        int sum = 0;\n        for (int i = 0; i < runningSum.length; i++) {\n            sum += nums[i];\n            runningSum[i] += sum;\n            System.out.println(runningSum[i]);\n        }\n    }\n}"
                    },
                    {
                        "username": "ygg-m",
                        "content": "My code works (solution is there, posting only to show that it works in other places): https://jsfiddle.net/nf1r5vg2/\\n\\nBut it\\'s throwing me this error: https://i.imgur.com/jfwRCOd.png\\n\\nAnyone know what\\'s happening?"
                    },
                    {
                        "username": "shuubhhaammm",
                        "content": "why i am not able to use return in this question"
                    },
                    {
                        "username": "RagulTK",
                        "content": "I got desired output  both these logic which is (nums[i]=nums[i]+nums[i-1]) and also (nums[i]+=nums[i-1])...But i got a undesired output even i wrote the code wrongly (i.e) (nums[i]=+nums[i-1]).....i also got a desired the output when i was using+=+ these combinaton of operator......what am i asking is? why i got output when i wrote code wrongly........Actaully\\nwhat happens on operators..Can you anyone please clear my doubt.  "
                    },
                    {
                        "username": "Nithish_kumar_S",
                        "content": "int* runningSum(int* nums, int numsSize, int* returnSize){\\nint i;\\nfor (i=1;i<numsSize;i++)\\n{\\n    nums[i]=+nums[i-1];\\n}\\nreturn nums;\\n}\\nwhats wrong with the above code the output is simply \"[ ]\""
                    }
                ]
            },
            {
                "id": 1791336,
                "content": [
                    {
                        "username": "Arif1_2",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n       int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        \\n        return nums;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            su=sum(nums[0:i+1])\\n            k.append(su)\\n        return k"
                    },
                    {
                        "username": "AzuSumiye",
                        "content": "Chat gpt said the answer to this question is \\n\\ndef runningSum(nums):\\n    running_sum = []\\n    current_sum = 0\\n    for num in nums:\\n        current_sum += num\\n        running_sum.append(current_sum)\\n    return running_sum\\n yet it turns up runtime error. rip chat gpt"
                    },
                    {
                        "username": "Sudharsan07",
                        "content": "JAVA 0 ms Solution\\n\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "A simple and efficient solution: (with 0 ms runtime)\n\n\nclass Solution {\n    public int[] runningSum(int[] nums) {\n    int temp=0;\n        for(int i=0;i<nums.length;i++){\n\n            nums[i]=temp+nums[i];\n            temp=nums[i]; \n    }\n    return nums;\n}\n}"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% fast in java || very easy\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int sum = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sanithshetty41",
                        "content": "this solution ran in 0ms\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            arr[i]=nums[i]+sum;\\n            sum=arr[i];\\n\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "iamdhev",
                        "content": "Hi I am getting wrong answer due to below output, please help me\\n\\nExpected\\n[3,4,6,16,17]\\nStdout\\n[3, 4, 6, 16, 17]"
                    },
                    {
                        "username": "nikhilalugu",
                        "content": "I have a query ,In the solution for python how to take the list input "
                    },
                    {
                        "username": "Maharshi92",
                        "content": "Simple one loop solution\\n\\n ```public int[] runningSum(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        int sum =0;\\n        for (int i =0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }```"
                    }
                ]
            },
            {
                "id": 1787393,
                "content": [
                    {
                        "username": "Arif1_2",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n       int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        \\n        return nums;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            su=sum(nums[0:i+1])\\n            k.append(su)\\n        return k"
                    },
                    {
                        "username": "AzuSumiye",
                        "content": "Chat gpt said the answer to this question is \\n\\ndef runningSum(nums):\\n    running_sum = []\\n    current_sum = 0\\n    for num in nums:\\n        current_sum += num\\n        running_sum.append(current_sum)\\n    return running_sum\\n yet it turns up runtime error. rip chat gpt"
                    },
                    {
                        "username": "Sudharsan07",
                        "content": "JAVA 0 ms Solution\\n\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "A simple and efficient solution: (with 0 ms runtime)\n\n\nclass Solution {\n    public int[] runningSum(int[] nums) {\n    int temp=0;\n        for(int i=0;i<nums.length;i++){\n\n            nums[i]=temp+nums[i];\n            temp=nums[i]; \n    }\n    return nums;\n}\n}"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% fast in java || very easy\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int sum = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sanithshetty41",
                        "content": "this solution ran in 0ms\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            arr[i]=nums[i]+sum;\\n            sum=arr[i];\\n\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "iamdhev",
                        "content": "Hi I am getting wrong answer due to below output, please help me\\n\\nExpected\\n[3,4,6,16,17]\\nStdout\\n[3, 4, 6, 16, 17]"
                    },
                    {
                        "username": "nikhilalugu",
                        "content": "I have a query ,In the solution for python how to take the list input "
                    },
                    {
                        "username": "Maharshi92",
                        "content": "Simple one loop solution\\n\\n ```public int[] runningSum(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        int sum =0;\\n        for (int i =0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }```"
                    }
                ]
            },
            {
                "id": 1786541,
                "content": [
                    {
                        "username": "Arif1_2",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n       int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        \\n        return nums;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            su=sum(nums[0:i+1])\\n            k.append(su)\\n        return k"
                    },
                    {
                        "username": "AzuSumiye",
                        "content": "Chat gpt said the answer to this question is \\n\\ndef runningSum(nums):\\n    running_sum = []\\n    current_sum = 0\\n    for num in nums:\\n        current_sum += num\\n        running_sum.append(current_sum)\\n    return running_sum\\n yet it turns up runtime error. rip chat gpt"
                    },
                    {
                        "username": "Sudharsan07",
                        "content": "JAVA 0 ms Solution\\n\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "A simple and efficient solution: (with 0 ms runtime)\n\n\nclass Solution {\n    public int[] runningSum(int[] nums) {\n    int temp=0;\n        for(int i=0;i<nums.length;i++){\n\n            nums[i]=temp+nums[i];\n            temp=nums[i]; \n    }\n    return nums;\n}\n}"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% fast in java || very easy\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int sum = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sanithshetty41",
                        "content": "this solution ran in 0ms\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            arr[i]=nums[i]+sum;\\n            sum=arr[i];\\n\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "iamdhev",
                        "content": "Hi I am getting wrong answer due to below output, please help me\\n\\nExpected\\n[3,4,6,16,17]\\nStdout\\n[3, 4, 6, 16, 17]"
                    },
                    {
                        "username": "nikhilalugu",
                        "content": "I have a query ,In the solution for python how to take the list input "
                    },
                    {
                        "username": "Maharshi92",
                        "content": "Simple one loop solution\\n\\n ```public int[] runningSum(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        int sum =0;\\n        for (int i =0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }```"
                    }
                ]
            },
            {
                "id": 1784928,
                "content": [
                    {
                        "username": "Arif1_2",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n       int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        \\n        return nums;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            su=sum(nums[0:i+1])\\n            k.append(su)\\n        return k"
                    },
                    {
                        "username": "AzuSumiye",
                        "content": "Chat gpt said the answer to this question is \\n\\ndef runningSum(nums):\\n    running_sum = []\\n    current_sum = 0\\n    for num in nums:\\n        current_sum += num\\n        running_sum.append(current_sum)\\n    return running_sum\\n yet it turns up runtime error. rip chat gpt"
                    },
                    {
                        "username": "Sudharsan07",
                        "content": "JAVA 0 ms Solution\\n\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "A simple and efficient solution: (with 0 ms runtime)\n\n\nclass Solution {\n    public int[] runningSum(int[] nums) {\n    int temp=0;\n        for(int i=0;i<nums.length;i++){\n\n            nums[i]=temp+nums[i];\n            temp=nums[i]; \n    }\n    return nums;\n}\n}"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% fast in java || very easy\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int sum = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sanithshetty41",
                        "content": "this solution ran in 0ms\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            arr[i]=nums[i]+sum;\\n            sum=arr[i];\\n\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "iamdhev",
                        "content": "Hi I am getting wrong answer due to below output, please help me\\n\\nExpected\\n[3,4,6,16,17]\\nStdout\\n[3, 4, 6, 16, 17]"
                    },
                    {
                        "username": "nikhilalugu",
                        "content": "I have a query ,In the solution for python how to take the list input "
                    },
                    {
                        "username": "Maharshi92",
                        "content": "Simple one loop solution\\n\\n ```public int[] runningSum(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        int sum =0;\\n        for (int i =0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }```"
                    }
                ]
            },
            {
                "id": 1783728,
                "content": [
                    {
                        "username": "Arif1_2",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n       int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        \\n        return nums;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            su=sum(nums[0:i+1])\\n            k.append(su)\\n        return k"
                    },
                    {
                        "username": "AzuSumiye",
                        "content": "Chat gpt said the answer to this question is \\n\\ndef runningSum(nums):\\n    running_sum = []\\n    current_sum = 0\\n    for num in nums:\\n        current_sum += num\\n        running_sum.append(current_sum)\\n    return running_sum\\n yet it turns up runtime error. rip chat gpt"
                    },
                    {
                        "username": "Sudharsan07",
                        "content": "JAVA 0 ms Solution\\n\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "A simple and efficient solution: (with 0 ms runtime)\n\n\nclass Solution {\n    public int[] runningSum(int[] nums) {\n    int temp=0;\n        for(int i=0;i<nums.length;i++){\n\n            nums[i]=temp+nums[i];\n            temp=nums[i]; \n    }\n    return nums;\n}\n}"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% fast in java || very easy\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int sum = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sanithshetty41",
                        "content": "this solution ran in 0ms\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            arr[i]=nums[i]+sum;\\n            sum=arr[i];\\n\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "iamdhev",
                        "content": "Hi I am getting wrong answer due to below output, please help me\\n\\nExpected\\n[3,4,6,16,17]\\nStdout\\n[3, 4, 6, 16, 17]"
                    },
                    {
                        "username": "nikhilalugu",
                        "content": "I have a query ,In the solution for python how to take the list input "
                    },
                    {
                        "username": "Maharshi92",
                        "content": "Simple one loop solution\\n\\n ```public int[] runningSum(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        int sum =0;\\n        for (int i =0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }```"
                    }
                ]
            },
            {
                "id": 1782379,
                "content": [
                    {
                        "username": "Arif1_2",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n       int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        \\n        return nums;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            su=sum(nums[0:i+1])\\n            k.append(su)\\n        return k"
                    },
                    {
                        "username": "AzuSumiye",
                        "content": "Chat gpt said the answer to this question is \\n\\ndef runningSum(nums):\\n    running_sum = []\\n    current_sum = 0\\n    for num in nums:\\n        current_sum += num\\n        running_sum.append(current_sum)\\n    return running_sum\\n yet it turns up runtime error. rip chat gpt"
                    },
                    {
                        "username": "Sudharsan07",
                        "content": "JAVA 0 ms Solution\\n\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "A simple and efficient solution: (with 0 ms runtime)\n\n\nclass Solution {\n    public int[] runningSum(int[] nums) {\n    int temp=0;\n        for(int i=0;i<nums.length;i++){\n\n            nums[i]=temp+nums[i];\n            temp=nums[i]; \n    }\n    return nums;\n}\n}"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% fast in java || very easy\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int sum = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sanithshetty41",
                        "content": "this solution ran in 0ms\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            arr[i]=nums[i]+sum;\\n            sum=arr[i];\\n\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "iamdhev",
                        "content": "Hi I am getting wrong answer due to below output, please help me\\n\\nExpected\\n[3,4,6,16,17]\\nStdout\\n[3, 4, 6, 16, 17]"
                    },
                    {
                        "username": "nikhilalugu",
                        "content": "I have a query ,In the solution for python how to take the list input "
                    },
                    {
                        "username": "Maharshi92",
                        "content": "Simple one loop solution\\n\\n ```public int[] runningSum(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        int sum =0;\\n        for (int i =0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }```"
                    }
                ]
            },
            {
                "id": 1777632,
                "content": [
                    {
                        "username": "Arif1_2",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n       int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        \\n        return nums;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            su=sum(nums[0:i+1])\\n            k.append(su)\\n        return k"
                    },
                    {
                        "username": "AzuSumiye",
                        "content": "Chat gpt said the answer to this question is \\n\\ndef runningSum(nums):\\n    running_sum = []\\n    current_sum = 0\\n    for num in nums:\\n        current_sum += num\\n        running_sum.append(current_sum)\\n    return running_sum\\n yet it turns up runtime error. rip chat gpt"
                    },
                    {
                        "username": "Sudharsan07",
                        "content": "JAVA 0 ms Solution\\n\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "A simple and efficient solution: (with 0 ms runtime)\n\n\nclass Solution {\n    public int[] runningSum(int[] nums) {\n    int temp=0;\n        for(int i=0;i<nums.length;i++){\n\n            nums[i]=temp+nums[i];\n            temp=nums[i]; \n    }\n    return nums;\n}\n}"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% fast in java || very easy\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int sum = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sanithshetty41",
                        "content": "this solution ran in 0ms\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            arr[i]=nums[i]+sum;\\n            sum=arr[i];\\n\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "iamdhev",
                        "content": "Hi I am getting wrong answer due to below output, please help me\\n\\nExpected\\n[3,4,6,16,17]\\nStdout\\n[3, 4, 6, 16, 17]"
                    },
                    {
                        "username": "nikhilalugu",
                        "content": "I have a query ,In the solution for python how to take the list input "
                    },
                    {
                        "username": "Maharshi92",
                        "content": "Simple one loop solution\\n\\n ```public int[] runningSum(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        int sum =0;\\n        for (int i =0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }```"
                    }
                ]
            },
            {
                "id": 1776455,
                "content": [
                    {
                        "username": "Arif1_2",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n       int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        \\n        return nums;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            su=sum(nums[0:i+1])\\n            k.append(su)\\n        return k"
                    },
                    {
                        "username": "AzuSumiye",
                        "content": "Chat gpt said the answer to this question is \\n\\ndef runningSum(nums):\\n    running_sum = []\\n    current_sum = 0\\n    for num in nums:\\n        current_sum += num\\n        running_sum.append(current_sum)\\n    return running_sum\\n yet it turns up runtime error. rip chat gpt"
                    },
                    {
                        "username": "Sudharsan07",
                        "content": "JAVA 0 ms Solution\\n\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "A simple and efficient solution: (with 0 ms runtime)\n\n\nclass Solution {\n    public int[] runningSum(int[] nums) {\n    int temp=0;\n        for(int i=0;i<nums.length;i++){\n\n            nums[i]=temp+nums[i];\n            temp=nums[i]; \n    }\n    return nums;\n}\n}"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% fast in java || very easy\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int sum = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sanithshetty41",
                        "content": "this solution ran in 0ms\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            arr[i]=nums[i]+sum;\\n            sum=arr[i];\\n\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "iamdhev",
                        "content": "Hi I am getting wrong answer due to below output, please help me\\n\\nExpected\\n[3,4,6,16,17]\\nStdout\\n[3, 4, 6, 16, 17]"
                    },
                    {
                        "username": "nikhilalugu",
                        "content": "I have a query ,In the solution for python how to take the list input "
                    },
                    {
                        "username": "Maharshi92",
                        "content": "Simple one loop solution\\n\\n ```public int[] runningSum(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        int sum =0;\\n        for (int i =0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }```"
                    }
                ]
            },
            {
                "id": 1775283,
                "content": [
                    {
                        "username": "Arif1_2",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n       int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        \\n        return nums;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            su=sum(nums[0:i+1])\\n            k.append(su)\\n        return k"
                    },
                    {
                        "username": "AzuSumiye",
                        "content": "Chat gpt said the answer to this question is \\n\\ndef runningSum(nums):\\n    running_sum = []\\n    current_sum = 0\\n    for num in nums:\\n        current_sum += num\\n        running_sum.append(current_sum)\\n    return running_sum\\n yet it turns up runtime error. rip chat gpt"
                    },
                    {
                        "username": "Sudharsan07",
                        "content": "JAVA 0 ms Solution\\n\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "A simple and efficient solution: (with 0 ms runtime)\n\n\nclass Solution {\n    public int[] runningSum(int[] nums) {\n    int temp=0;\n        for(int i=0;i<nums.length;i++){\n\n            nums[i]=temp+nums[i];\n            temp=nums[i]; \n    }\n    return nums;\n}\n}"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% fast in java || very easy\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int sum = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sanithshetty41",
                        "content": "this solution ran in 0ms\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            arr[i]=nums[i]+sum;\\n            sum=arr[i];\\n\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "iamdhev",
                        "content": "Hi I am getting wrong answer due to below output, please help me\\n\\nExpected\\n[3,4,6,16,17]\\nStdout\\n[3, 4, 6, 16, 17]"
                    },
                    {
                        "username": "nikhilalugu",
                        "content": "I have a query ,In the solution for python how to take the list input "
                    },
                    {
                        "username": "Maharshi92",
                        "content": "Simple one loop solution\\n\\n ```public int[] runningSum(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        int sum =0;\\n        for (int i =0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }```"
                    }
                ]
            },
            {
                "id": 1773303,
                "content": [
                    {
                        "username": "Arif1_2",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n       int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        \\n        return nums;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            su=sum(nums[0:i+1])\\n            k.append(su)\\n        return k"
                    },
                    {
                        "username": "AzuSumiye",
                        "content": "Chat gpt said the answer to this question is \\n\\ndef runningSum(nums):\\n    running_sum = []\\n    current_sum = 0\\n    for num in nums:\\n        current_sum += num\\n        running_sum.append(current_sum)\\n    return running_sum\\n yet it turns up runtime error. rip chat gpt"
                    },
                    {
                        "username": "Sudharsan07",
                        "content": "JAVA 0 ms Solution\\n\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "A simple and efficient solution: (with 0 ms runtime)\n\n\nclass Solution {\n    public int[] runningSum(int[] nums) {\n    int temp=0;\n        for(int i=0;i<nums.length;i++){\n\n            nums[i]=temp+nums[i];\n            temp=nums[i]; \n    }\n    return nums;\n}\n}"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% fast in java || very easy\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int sum = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sanithshetty41",
                        "content": "this solution ran in 0ms\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            arr[i]=nums[i]+sum;\\n            sum=arr[i];\\n\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "iamdhev",
                        "content": "Hi I am getting wrong answer due to below output, please help me\\n\\nExpected\\n[3,4,6,16,17]\\nStdout\\n[3, 4, 6, 16, 17]"
                    },
                    {
                        "username": "nikhilalugu",
                        "content": "I have a query ,In the solution for python how to take the list input "
                    },
                    {
                        "username": "Maharshi92",
                        "content": "Simple one loop solution\\n\\n ```public int[] runningSum(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        int sum =0;\\n        for (int i =0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }```"
                    }
                ]
            },
            {
                "id": 1771326,
                "content": [
                    {
                        "username": "shrutisisodiya2021",
                        "content": "Here\\'s my solution to this problem! \\n\\n`class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n};`"
                    },
                    {
                        "username": "feed0",
                        "content": "Updating/overriding the input seems faster, but In which real cases that wouldn\\u2019t result in any further problems? That is, do you any real case where the input is somehow disposable?"
                    },
                    {
                        "username": "bansi_32",
                        "content": "My first solution took O(n2) as I came up with the following solution:\n`int arr[]=new int[nums.length];`\n        `arr[0]=nums[0];`\n       ` int ans=0;`\n        `for(int j=1;j<nums.length;j++)`\n        `{`\n          `  int i=0;`\n           ` ans=0`;\n            `while(i<=j)`\n            `{`\n                `ans+=nums[i++];`\n           ` }`\n           ` arr[j]=ans;`\n       ` }`"
                    },
                    {
                        "username": "bansi_32",
                        "content": "Following is my optimized solution:\\nint arr[]=new int[nums.length];\\n        arr[0]=nums[0];\\n        int ans=arr[0];\\n        for(int j=1;j<nums.length;j++)\\n        {\\n            ans+=nums[j];\\n            arr[j]=ans;\\n        }"
                    },
                    {
                        "username": "sajidalijhu",
                        "content": "hi i am a beginner so do not know whether it is an optimized code or not so my suggestion is that read the question properly you need sum(num[0]...num[i])\\nthat mean you have to add the previous elements so store it in a variable and add it to appropriate index."
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " vector<int> runningSum(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            res.push_back(nums[i] + res[res.size()-1]);\\n        return res;\\n    }"
                    },
                    {
                        "username": "SriyaKan",
                        "content": "Hi. When I read the problem description, I didn't think we would be allowed to modify nums and instead took the approach of creating a new array to store the running sums. But I get an IndexError: list assignment index out of range with this code: Can someone help me figure out why I get this error?\n\nclass Solution(object):\n    def runningSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [] \n        for i in range(len(nums)):\n            result[i] = nums[i]\n        for i in range(len(result) - 1):\n            result[i + 1] += result[i]\n        return result"
                    },
                    {
                        "username": "Squeky_squirrel",
                        "content": "why adding {} in for loop makes my code wrong. "
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        a = 0\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] + a\\n            a = nums[i]\\n        return nums"
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": "def runningSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return [reduce(lambda x, y: x+y, nums[:x+1]) for x in range(len(nums))]"
                    },
                    {
                        "username": "mc1350",
                        "content": "For anyone using Kotlin trying to use runningFold or scan:\\n\\n LeetCode has not updated Kotlin for a long time and the version is pre runningFold and scan"
                    }
                ]
            },
            {
                "id": 1767854,
                "content": [
                    {
                        "username": "shrutisisodiya2021",
                        "content": "Here\\'s my solution to this problem! \\n\\n`class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n};`"
                    },
                    {
                        "username": "feed0",
                        "content": "Updating/overriding the input seems faster, but In which real cases that wouldn\\u2019t result in any further problems? That is, do you any real case where the input is somehow disposable?"
                    },
                    {
                        "username": "bansi_32",
                        "content": "My first solution took O(n2) as I came up with the following solution:\n`int arr[]=new int[nums.length];`\n        `arr[0]=nums[0];`\n       ` int ans=0;`\n        `for(int j=1;j<nums.length;j++)`\n        `{`\n          `  int i=0;`\n           ` ans=0`;\n            `while(i<=j)`\n            `{`\n                `ans+=nums[i++];`\n           ` }`\n           ` arr[j]=ans;`\n       ` }`"
                    },
                    {
                        "username": "bansi_32",
                        "content": "Following is my optimized solution:\\nint arr[]=new int[nums.length];\\n        arr[0]=nums[0];\\n        int ans=arr[0];\\n        for(int j=1;j<nums.length;j++)\\n        {\\n            ans+=nums[j];\\n            arr[j]=ans;\\n        }"
                    },
                    {
                        "username": "sajidalijhu",
                        "content": "hi i am a beginner so do not know whether it is an optimized code or not so my suggestion is that read the question properly you need sum(num[0]...num[i])\\nthat mean you have to add the previous elements so store it in a variable and add it to appropriate index."
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " vector<int> runningSum(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            res.push_back(nums[i] + res[res.size()-1]);\\n        return res;\\n    }"
                    },
                    {
                        "username": "SriyaKan",
                        "content": "Hi. When I read the problem description, I didn't think we would be allowed to modify nums and instead took the approach of creating a new array to store the running sums. But I get an IndexError: list assignment index out of range with this code: Can someone help me figure out why I get this error?\n\nclass Solution(object):\n    def runningSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [] \n        for i in range(len(nums)):\n            result[i] = nums[i]\n        for i in range(len(result) - 1):\n            result[i + 1] += result[i]\n        return result"
                    },
                    {
                        "username": "Squeky_squirrel",
                        "content": "why adding {} in for loop makes my code wrong. "
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        a = 0\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] + a\\n            a = nums[i]\\n        return nums"
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": "def runningSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return [reduce(lambda x, y: x+y, nums[:x+1]) for x in range(len(nums))]"
                    },
                    {
                        "username": "mc1350",
                        "content": "For anyone using Kotlin trying to use runningFold or scan:\\n\\n LeetCode has not updated Kotlin for a long time and the version is pre runningFold and scan"
                    }
                ]
            },
            {
                "id": 1764216,
                "content": [
                    {
                        "username": "shrutisisodiya2021",
                        "content": "Here\\'s my solution to this problem! \\n\\n`class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n};`"
                    },
                    {
                        "username": "feed0",
                        "content": "Updating/overriding the input seems faster, but In which real cases that wouldn\\u2019t result in any further problems? That is, do you any real case where the input is somehow disposable?"
                    },
                    {
                        "username": "bansi_32",
                        "content": "My first solution took O(n2) as I came up with the following solution:\n`int arr[]=new int[nums.length];`\n        `arr[0]=nums[0];`\n       ` int ans=0;`\n        `for(int j=1;j<nums.length;j++)`\n        `{`\n          `  int i=0;`\n           ` ans=0`;\n            `while(i<=j)`\n            `{`\n                `ans+=nums[i++];`\n           ` }`\n           ` arr[j]=ans;`\n       ` }`"
                    },
                    {
                        "username": "bansi_32",
                        "content": "Following is my optimized solution:\\nint arr[]=new int[nums.length];\\n        arr[0]=nums[0];\\n        int ans=arr[0];\\n        for(int j=1;j<nums.length;j++)\\n        {\\n            ans+=nums[j];\\n            arr[j]=ans;\\n        }"
                    },
                    {
                        "username": "sajidalijhu",
                        "content": "hi i am a beginner so do not know whether it is an optimized code or not so my suggestion is that read the question properly you need sum(num[0]...num[i])\\nthat mean you have to add the previous elements so store it in a variable and add it to appropriate index."
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " vector<int> runningSum(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            res.push_back(nums[i] + res[res.size()-1]);\\n        return res;\\n    }"
                    },
                    {
                        "username": "SriyaKan",
                        "content": "Hi. When I read the problem description, I didn't think we would be allowed to modify nums and instead took the approach of creating a new array to store the running sums. But I get an IndexError: list assignment index out of range with this code: Can someone help me figure out why I get this error?\n\nclass Solution(object):\n    def runningSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [] \n        for i in range(len(nums)):\n            result[i] = nums[i]\n        for i in range(len(result) - 1):\n            result[i + 1] += result[i]\n        return result"
                    },
                    {
                        "username": "Squeky_squirrel",
                        "content": "why adding {} in for loop makes my code wrong. "
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        a = 0\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] + a\\n            a = nums[i]\\n        return nums"
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": "def runningSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return [reduce(lambda x, y: x+y, nums[:x+1]) for x in range(len(nums))]"
                    },
                    {
                        "username": "mc1350",
                        "content": "For anyone using Kotlin trying to use runningFold or scan:\\n\\n LeetCode has not updated Kotlin for a long time and the version is pre runningFold and scan"
                    }
                ]
            },
            {
                "id": 1762095,
                "content": [
                    {
                        "username": "shrutisisodiya2021",
                        "content": "Here\\'s my solution to this problem! \\n\\n`class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n};`"
                    },
                    {
                        "username": "feed0",
                        "content": "Updating/overriding the input seems faster, but In which real cases that wouldn\\u2019t result in any further problems? That is, do you any real case where the input is somehow disposable?"
                    },
                    {
                        "username": "bansi_32",
                        "content": "My first solution took O(n2) as I came up with the following solution:\n`int arr[]=new int[nums.length];`\n        `arr[0]=nums[0];`\n       ` int ans=0;`\n        `for(int j=1;j<nums.length;j++)`\n        `{`\n          `  int i=0;`\n           ` ans=0`;\n            `while(i<=j)`\n            `{`\n                `ans+=nums[i++];`\n           ` }`\n           ` arr[j]=ans;`\n       ` }`"
                    },
                    {
                        "username": "bansi_32",
                        "content": "Following is my optimized solution:\\nint arr[]=new int[nums.length];\\n        arr[0]=nums[0];\\n        int ans=arr[0];\\n        for(int j=1;j<nums.length;j++)\\n        {\\n            ans+=nums[j];\\n            arr[j]=ans;\\n        }"
                    },
                    {
                        "username": "sajidalijhu",
                        "content": "hi i am a beginner so do not know whether it is an optimized code or not so my suggestion is that read the question properly you need sum(num[0]...num[i])\\nthat mean you have to add the previous elements so store it in a variable and add it to appropriate index."
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " vector<int> runningSum(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            res.push_back(nums[i] + res[res.size()-1]);\\n        return res;\\n    }"
                    },
                    {
                        "username": "SriyaKan",
                        "content": "Hi. When I read the problem description, I didn't think we would be allowed to modify nums and instead took the approach of creating a new array to store the running sums. But I get an IndexError: list assignment index out of range with this code: Can someone help me figure out why I get this error?\n\nclass Solution(object):\n    def runningSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [] \n        for i in range(len(nums)):\n            result[i] = nums[i]\n        for i in range(len(result) - 1):\n            result[i + 1] += result[i]\n        return result"
                    },
                    {
                        "username": "Squeky_squirrel",
                        "content": "why adding {} in for loop makes my code wrong. "
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        a = 0\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] + a\\n            a = nums[i]\\n        return nums"
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": "def runningSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return [reduce(lambda x, y: x+y, nums[:x+1]) for x in range(len(nums))]"
                    },
                    {
                        "username": "mc1350",
                        "content": "For anyone using Kotlin trying to use runningFold or scan:\\n\\n LeetCode has not updated Kotlin for a long time and the version is pre runningFold and scan"
                    }
                ]
            },
            {
                "id": 1760564,
                "content": [
                    {
                        "username": "shrutisisodiya2021",
                        "content": "Here\\'s my solution to this problem! \\n\\n`class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n};`"
                    },
                    {
                        "username": "feed0",
                        "content": "Updating/overriding the input seems faster, but In which real cases that wouldn\\u2019t result in any further problems? That is, do you any real case where the input is somehow disposable?"
                    },
                    {
                        "username": "bansi_32",
                        "content": "My first solution took O(n2) as I came up with the following solution:\n`int arr[]=new int[nums.length];`\n        `arr[0]=nums[0];`\n       ` int ans=0;`\n        `for(int j=1;j<nums.length;j++)`\n        `{`\n          `  int i=0;`\n           ` ans=0`;\n            `while(i<=j)`\n            `{`\n                `ans+=nums[i++];`\n           ` }`\n           ` arr[j]=ans;`\n       ` }`"
                    },
                    {
                        "username": "bansi_32",
                        "content": "Following is my optimized solution:\\nint arr[]=new int[nums.length];\\n        arr[0]=nums[0];\\n        int ans=arr[0];\\n        for(int j=1;j<nums.length;j++)\\n        {\\n            ans+=nums[j];\\n            arr[j]=ans;\\n        }"
                    },
                    {
                        "username": "sajidalijhu",
                        "content": "hi i am a beginner so do not know whether it is an optimized code or not so my suggestion is that read the question properly you need sum(num[0]...num[i])\\nthat mean you have to add the previous elements so store it in a variable and add it to appropriate index."
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " vector<int> runningSum(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            res.push_back(nums[i] + res[res.size()-1]);\\n        return res;\\n    }"
                    },
                    {
                        "username": "SriyaKan",
                        "content": "Hi. When I read the problem description, I didn't think we would be allowed to modify nums and instead took the approach of creating a new array to store the running sums. But I get an IndexError: list assignment index out of range with this code: Can someone help me figure out why I get this error?\n\nclass Solution(object):\n    def runningSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [] \n        for i in range(len(nums)):\n            result[i] = nums[i]\n        for i in range(len(result) - 1):\n            result[i + 1] += result[i]\n        return result"
                    },
                    {
                        "username": "Squeky_squirrel",
                        "content": "why adding {} in for loop makes my code wrong. "
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        a = 0\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] + a\\n            a = nums[i]\\n        return nums"
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": "def runningSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return [reduce(lambda x, y: x+y, nums[:x+1]) for x in range(len(nums))]"
                    },
                    {
                        "username": "mc1350",
                        "content": "For anyone using Kotlin trying to use runningFold or scan:\\n\\n LeetCode has not updated Kotlin for a long time and the version is pre runningFold and scan"
                    }
                ]
            },
            {
                "id": 1757942,
                "content": [
                    {
                        "username": "shrutisisodiya2021",
                        "content": "Here\\'s my solution to this problem! \\n\\n`class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n};`"
                    },
                    {
                        "username": "feed0",
                        "content": "Updating/overriding the input seems faster, but In which real cases that wouldn\\u2019t result in any further problems? That is, do you any real case where the input is somehow disposable?"
                    },
                    {
                        "username": "bansi_32",
                        "content": "My first solution took O(n2) as I came up with the following solution:\n`int arr[]=new int[nums.length];`\n        `arr[0]=nums[0];`\n       ` int ans=0;`\n        `for(int j=1;j<nums.length;j++)`\n        `{`\n          `  int i=0;`\n           ` ans=0`;\n            `while(i<=j)`\n            `{`\n                `ans+=nums[i++];`\n           ` }`\n           ` arr[j]=ans;`\n       ` }`"
                    },
                    {
                        "username": "bansi_32",
                        "content": "Following is my optimized solution:\\nint arr[]=new int[nums.length];\\n        arr[0]=nums[0];\\n        int ans=arr[0];\\n        for(int j=1;j<nums.length;j++)\\n        {\\n            ans+=nums[j];\\n            arr[j]=ans;\\n        }"
                    },
                    {
                        "username": "sajidalijhu",
                        "content": "hi i am a beginner so do not know whether it is an optimized code or not so my suggestion is that read the question properly you need sum(num[0]...num[i])\\nthat mean you have to add the previous elements so store it in a variable and add it to appropriate index."
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " vector<int> runningSum(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            res.push_back(nums[i] + res[res.size()-1]);\\n        return res;\\n    }"
                    },
                    {
                        "username": "SriyaKan",
                        "content": "Hi. When I read the problem description, I didn't think we would be allowed to modify nums and instead took the approach of creating a new array to store the running sums. But I get an IndexError: list assignment index out of range with this code: Can someone help me figure out why I get this error?\n\nclass Solution(object):\n    def runningSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [] \n        for i in range(len(nums)):\n            result[i] = nums[i]\n        for i in range(len(result) - 1):\n            result[i + 1] += result[i]\n        return result"
                    },
                    {
                        "username": "Squeky_squirrel",
                        "content": "why adding {} in for loop makes my code wrong. "
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        a = 0\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] + a\\n            a = nums[i]\\n        return nums"
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": "def runningSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return [reduce(lambda x, y: x+y, nums[:x+1]) for x in range(len(nums))]"
                    },
                    {
                        "username": "mc1350",
                        "content": "For anyone using Kotlin trying to use runningFold or scan:\\n\\n LeetCode has not updated Kotlin for a long time and the version is pre runningFold and scan"
                    }
                ]
            },
            {
                "id": 1749729,
                "content": [
                    {
                        "username": "shrutisisodiya2021",
                        "content": "Here\\'s my solution to this problem! \\n\\n`class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n};`"
                    },
                    {
                        "username": "feed0",
                        "content": "Updating/overriding the input seems faster, but In which real cases that wouldn\\u2019t result in any further problems? That is, do you any real case where the input is somehow disposable?"
                    },
                    {
                        "username": "bansi_32",
                        "content": "My first solution took O(n2) as I came up with the following solution:\n`int arr[]=new int[nums.length];`\n        `arr[0]=nums[0];`\n       ` int ans=0;`\n        `for(int j=1;j<nums.length;j++)`\n        `{`\n          `  int i=0;`\n           ` ans=0`;\n            `while(i<=j)`\n            `{`\n                `ans+=nums[i++];`\n           ` }`\n           ` arr[j]=ans;`\n       ` }`"
                    },
                    {
                        "username": "bansi_32",
                        "content": "Following is my optimized solution:\\nint arr[]=new int[nums.length];\\n        arr[0]=nums[0];\\n        int ans=arr[0];\\n        for(int j=1;j<nums.length;j++)\\n        {\\n            ans+=nums[j];\\n            arr[j]=ans;\\n        }"
                    },
                    {
                        "username": "sajidalijhu",
                        "content": "hi i am a beginner so do not know whether it is an optimized code or not so my suggestion is that read the question properly you need sum(num[0]...num[i])\\nthat mean you have to add the previous elements so store it in a variable and add it to appropriate index."
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " vector<int> runningSum(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            res.push_back(nums[i] + res[res.size()-1]);\\n        return res;\\n    }"
                    },
                    {
                        "username": "SriyaKan",
                        "content": "Hi. When I read the problem description, I didn't think we would be allowed to modify nums and instead took the approach of creating a new array to store the running sums. But I get an IndexError: list assignment index out of range with this code: Can someone help me figure out why I get this error?\n\nclass Solution(object):\n    def runningSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [] \n        for i in range(len(nums)):\n            result[i] = nums[i]\n        for i in range(len(result) - 1):\n            result[i + 1] += result[i]\n        return result"
                    },
                    {
                        "username": "Squeky_squirrel",
                        "content": "why adding {} in for loop makes my code wrong. "
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        a = 0\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] + a\\n            a = nums[i]\\n        return nums"
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": "def runningSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return [reduce(lambda x, y: x+y, nums[:x+1]) for x in range(len(nums))]"
                    },
                    {
                        "username": "mc1350",
                        "content": "For anyone using Kotlin trying to use runningFold or scan:\\n\\n LeetCode has not updated Kotlin for a long time and the version is pre runningFold and scan"
                    }
                ]
            },
            {
                "id": 1748704,
                "content": [
                    {
                        "username": "shrutisisodiya2021",
                        "content": "Here\\'s my solution to this problem! \\n\\n`class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n};`"
                    },
                    {
                        "username": "feed0",
                        "content": "Updating/overriding the input seems faster, but In which real cases that wouldn\\u2019t result in any further problems? That is, do you any real case where the input is somehow disposable?"
                    },
                    {
                        "username": "bansi_32",
                        "content": "My first solution took O(n2) as I came up with the following solution:\n`int arr[]=new int[nums.length];`\n        `arr[0]=nums[0];`\n       ` int ans=0;`\n        `for(int j=1;j<nums.length;j++)`\n        `{`\n          `  int i=0;`\n           ` ans=0`;\n            `while(i<=j)`\n            `{`\n                `ans+=nums[i++];`\n           ` }`\n           ` arr[j]=ans;`\n       ` }`"
                    },
                    {
                        "username": "bansi_32",
                        "content": "Following is my optimized solution:\\nint arr[]=new int[nums.length];\\n        arr[0]=nums[0];\\n        int ans=arr[0];\\n        for(int j=1;j<nums.length;j++)\\n        {\\n            ans+=nums[j];\\n            arr[j]=ans;\\n        }"
                    },
                    {
                        "username": "sajidalijhu",
                        "content": "hi i am a beginner so do not know whether it is an optimized code or not so my suggestion is that read the question properly you need sum(num[0]...num[i])\\nthat mean you have to add the previous elements so store it in a variable and add it to appropriate index."
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " vector<int> runningSum(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            res.push_back(nums[i] + res[res.size()-1]);\\n        return res;\\n    }"
                    },
                    {
                        "username": "SriyaKan",
                        "content": "Hi. When I read the problem description, I didn't think we would be allowed to modify nums and instead took the approach of creating a new array to store the running sums. But I get an IndexError: list assignment index out of range with this code: Can someone help me figure out why I get this error?\n\nclass Solution(object):\n    def runningSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [] \n        for i in range(len(nums)):\n            result[i] = nums[i]\n        for i in range(len(result) - 1):\n            result[i + 1] += result[i]\n        return result"
                    },
                    {
                        "username": "Squeky_squirrel",
                        "content": "why adding {} in for loop makes my code wrong. "
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        a = 0\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] + a\\n            a = nums[i]\\n        return nums"
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": "def runningSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return [reduce(lambda x, y: x+y, nums[:x+1]) for x in range(len(nums))]"
                    },
                    {
                        "username": "mc1350",
                        "content": "For anyone using Kotlin trying to use runningFold or scan:\\n\\n LeetCode has not updated Kotlin for a long time and the version is pre runningFold and scan"
                    }
                ]
            },
            {
                "id": 1744779,
                "content": [
                    {
                        "username": "shrutisisodiya2021",
                        "content": "Here\\'s my solution to this problem! \\n\\n`class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n};`"
                    },
                    {
                        "username": "feed0",
                        "content": "Updating/overriding the input seems faster, but In which real cases that wouldn\\u2019t result in any further problems? That is, do you any real case where the input is somehow disposable?"
                    },
                    {
                        "username": "bansi_32",
                        "content": "My first solution took O(n2) as I came up with the following solution:\n`int arr[]=new int[nums.length];`\n        `arr[0]=nums[0];`\n       ` int ans=0;`\n        `for(int j=1;j<nums.length;j++)`\n        `{`\n          `  int i=0;`\n           ` ans=0`;\n            `while(i<=j)`\n            `{`\n                `ans+=nums[i++];`\n           ` }`\n           ` arr[j]=ans;`\n       ` }`"
                    },
                    {
                        "username": "bansi_32",
                        "content": "Following is my optimized solution:\\nint arr[]=new int[nums.length];\\n        arr[0]=nums[0];\\n        int ans=arr[0];\\n        for(int j=1;j<nums.length;j++)\\n        {\\n            ans+=nums[j];\\n            arr[j]=ans;\\n        }"
                    },
                    {
                        "username": "sajidalijhu",
                        "content": "hi i am a beginner so do not know whether it is an optimized code or not so my suggestion is that read the question properly you need sum(num[0]...num[i])\\nthat mean you have to add the previous elements so store it in a variable and add it to appropriate index."
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " vector<int> runningSum(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            res.push_back(nums[i] + res[res.size()-1]);\\n        return res;\\n    }"
                    },
                    {
                        "username": "SriyaKan",
                        "content": "Hi. When I read the problem description, I didn't think we would be allowed to modify nums and instead took the approach of creating a new array to store the running sums. But I get an IndexError: list assignment index out of range with this code: Can someone help me figure out why I get this error?\n\nclass Solution(object):\n    def runningSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [] \n        for i in range(len(nums)):\n            result[i] = nums[i]\n        for i in range(len(result) - 1):\n            result[i + 1] += result[i]\n        return result"
                    },
                    {
                        "username": "Squeky_squirrel",
                        "content": "why adding {} in for loop makes my code wrong. "
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        a = 0\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] + a\\n            a = nums[i]\\n        return nums"
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": "def runningSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return [reduce(lambda x, y: x+y, nums[:x+1]) for x in range(len(nums))]"
                    },
                    {
                        "username": "mc1350",
                        "content": "For anyone using Kotlin trying to use runningFold or scan:\\n\\n LeetCode has not updated Kotlin for a long time and the version is pre runningFold and scan"
                    }
                ]
            },
            {
                "id": 1741988,
                "content": [
                    {
                        "username": "shrutisisodiya2021",
                        "content": "Here\\'s my solution to this problem! \\n\\n`class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n};`"
                    },
                    {
                        "username": "feed0",
                        "content": "Updating/overriding the input seems faster, but In which real cases that wouldn\\u2019t result in any further problems? That is, do you any real case where the input is somehow disposable?"
                    },
                    {
                        "username": "bansi_32",
                        "content": "My first solution took O(n2) as I came up with the following solution:\n`int arr[]=new int[nums.length];`\n        `arr[0]=nums[0];`\n       ` int ans=0;`\n        `for(int j=1;j<nums.length;j++)`\n        `{`\n          `  int i=0;`\n           ` ans=0`;\n            `while(i<=j)`\n            `{`\n                `ans+=nums[i++];`\n           ` }`\n           ` arr[j]=ans;`\n       ` }`"
                    },
                    {
                        "username": "bansi_32",
                        "content": "Following is my optimized solution:\\nint arr[]=new int[nums.length];\\n        arr[0]=nums[0];\\n        int ans=arr[0];\\n        for(int j=1;j<nums.length;j++)\\n        {\\n            ans+=nums[j];\\n            arr[j]=ans;\\n        }"
                    },
                    {
                        "username": "sajidalijhu",
                        "content": "hi i am a beginner so do not know whether it is an optimized code or not so my suggestion is that read the question properly you need sum(num[0]...num[i])\\nthat mean you have to add the previous elements so store it in a variable and add it to appropriate index."
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " vector<int> runningSum(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            res.push_back(nums[i] + res[res.size()-1]);\\n        return res;\\n    }"
                    },
                    {
                        "username": "SriyaKan",
                        "content": "Hi. When I read the problem description, I didn't think we would be allowed to modify nums and instead took the approach of creating a new array to store the running sums. But I get an IndexError: list assignment index out of range with this code: Can someone help me figure out why I get this error?\n\nclass Solution(object):\n    def runningSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [] \n        for i in range(len(nums)):\n            result[i] = nums[i]\n        for i in range(len(result) - 1):\n            result[i + 1] += result[i]\n        return result"
                    },
                    {
                        "username": "Squeky_squirrel",
                        "content": "why adding {} in for loop makes my code wrong. "
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        a = 0\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] + a\\n            a = nums[i]\\n        return nums"
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": "def runningSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return [reduce(lambda x, y: x+y, nums[:x+1]) for x in range(len(nums))]"
                    },
                    {
                        "username": "mc1350",
                        "content": "For anyone using Kotlin trying to use runningFold or scan:\\n\\n LeetCode has not updated Kotlin for a long time and the version is pre runningFold and scan"
                    }
                ]
            },
            {
                "id": 1741464,
                "content": [
                    {
                        "username": "PrateekDoliya",
                        "content": "OPTIMISED JAVA CODE\\nTime Complexity = O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum[] = new int[n];\\n        sum[0] = nums[0];\\n        for(int i=1 ; i < n ; i++) {\\n            sum[i] = sum[i-1] + nums[i]; \\n        }\\n        return sum;\\n    }\\n}\\n "
                    },
                    {
                        "username": "abhishtt2110",
                        "content": "Easy Solution in Java\\n`class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum =0;\\n        int n= nums.length;\\n        int[] sums = new int[n];\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            sums[i]=sum;\\n        }\\n        return sums;\\n    }\\n}`"
                    },
                    {
                        "username": "LordOfDeadbush",
                        "content": "A fun challenge is to only use one variable in the solution: The solution vector. "
                    },
                    {
                        "username": "helloabhi004",
                        "content": "//I want to solve this problem using C language but can\\'t seem to find proper solution to it please help?\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for (int i=0; i<numsSize; i++){\\n        returnSize= nums[i] + nums[i+1];\\n        printf(\"%d\", returnSize);\\n    }\\n}\\n\\nint main(){\\n    int nums, size, arr[];\\n    arrSize=(int returnSize*)malloc(sizeof(int returnSize));\\n    printf(\"\\\\nEnter the size of array\\\\n\");\\n    scanf(\"%d\",&size);\\n    for(int i=0; i<size; i++){\\n        printf(\"Enter the element\\\\n\")\\n        scanf(\"%d\", &arr[num]);\\n    }\\n    printf(\"Output:\", runningSum(arr[num], size, returnSize));\\n} "
                    },
                    {
                        "username": "durveshpal538",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = nums[0];\\n        int n = nums.size();\\n        for(int i=1; i<n;i++)\\n        {\\n            nums[i] =nums[i]+sum ;\\n            sum  = nums[i];\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Krishnkant_singh",
                        "content": "The problem statement is pretty easy and understandable. I will tell you how you can do it through iterative approach. My solution came in at 4ms.\\nHere we will use for loop and will add element in a variable iteratively and store it an another vector and then we will return it.\\n\\nfor(int i =0; i<n; i++){\\n          sum = sum + nums[i];\\n          arrtemp.push_back(sum);\\n      } \\n      \\n"
                    },
                    {
                        "username": "BhushanBK",
                        "content": "//in JAVA\npublic int[] runningSum(int[] nums) {\n        int[] ans=new int[nums.length];\n        for(int i=0;i<nums.length;i++)\n            ans[i]=sum(nums,i);\n        return ans;\n    }\n    public int sum(int[] num,int end){\n        int sum=0;\n        for(int i=0;i<=end;i++)\n            sum+=num[i];\n        return sum;\n\n    }"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "class Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(len(nums)-1):\\n            nums[i+1]+= nums[i]\\n        return nums"
                    },
                    {
                        "username": "abdulbasitkhan2733",
                        "content": "how can i solve this problem please help me."
                    },
                    {
                        "username": "Eagle_eye",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n     for(auto it=nums[i].begin;it!=nums[i].end();it++)\\n     {\\n         int i=0,z=0;\\n         vector<int> xrr[100];\\n         z=z+*it\\n         xrr[i].push_back(z);\\n         i=i+1;\\n     }   \\n    }\\n    return xrr;\\n};\\n\\nI dont know what is the problem in this code , the error is in return type but I tried all the method plz let me know :)"
                    }
                ]
            },
            {
                "id": 1741426,
                "content": [
                    {
                        "username": "PrateekDoliya",
                        "content": "OPTIMISED JAVA CODE\\nTime Complexity = O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum[] = new int[n];\\n        sum[0] = nums[0];\\n        for(int i=1 ; i < n ; i++) {\\n            sum[i] = sum[i-1] + nums[i]; \\n        }\\n        return sum;\\n    }\\n}\\n "
                    },
                    {
                        "username": "abhishtt2110",
                        "content": "Easy Solution in Java\\n`class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum =0;\\n        int n= nums.length;\\n        int[] sums = new int[n];\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            sums[i]=sum;\\n        }\\n        return sums;\\n    }\\n}`"
                    },
                    {
                        "username": "LordOfDeadbush",
                        "content": "A fun challenge is to only use one variable in the solution: The solution vector. "
                    },
                    {
                        "username": "helloabhi004",
                        "content": "//I want to solve this problem using C language but can\\'t seem to find proper solution to it please help?\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for (int i=0; i<numsSize; i++){\\n        returnSize= nums[i] + nums[i+1];\\n        printf(\"%d\", returnSize);\\n    }\\n}\\n\\nint main(){\\n    int nums, size, arr[];\\n    arrSize=(int returnSize*)malloc(sizeof(int returnSize));\\n    printf(\"\\\\nEnter the size of array\\\\n\");\\n    scanf(\"%d\",&size);\\n    for(int i=0; i<size; i++){\\n        printf(\"Enter the element\\\\n\")\\n        scanf(\"%d\", &arr[num]);\\n    }\\n    printf(\"Output:\", runningSum(arr[num], size, returnSize));\\n} "
                    },
                    {
                        "username": "durveshpal538",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = nums[0];\\n        int n = nums.size();\\n        for(int i=1; i<n;i++)\\n        {\\n            nums[i] =nums[i]+sum ;\\n            sum  = nums[i];\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Krishnkant_singh",
                        "content": "The problem statement is pretty easy and understandable. I will tell you how you can do it through iterative approach. My solution came in at 4ms.\\nHere we will use for loop and will add element in a variable iteratively and store it an another vector and then we will return it.\\n\\nfor(int i =0; i<n; i++){\\n          sum = sum + nums[i];\\n          arrtemp.push_back(sum);\\n      } \\n      \\n"
                    },
                    {
                        "username": "BhushanBK",
                        "content": "//in JAVA\npublic int[] runningSum(int[] nums) {\n        int[] ans=new int[nums.length];\n        for(int i=0;i<nums.length;i++)\n            ans[i]=sum(nums,i);\n        return ans;\n    }\n    public int sum(int[] num,int end){\n        int sum=0;\n        for(int i=0;i<=end;i++)\n            sum+=num[i];\n        return sum;\n\n    }"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "class Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(len(nums)-1):\\n            nums[i+1]+= nums[i]\\n        return nums"
                    },
                    {
                        "username": "abdulbasitkhan2733",
                        "content": "how can i solve this problem please help me."
                    },
                    {
                        "username": "Eagle_eye",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n     for(auto it=nums[i].begin;it!=nums[i].end();it++)\\n     {\\n         int i=0,z=0;\\n         vector<int> xrr[100];\\n         z=z+*it\\n         xrr[i].push_back(z);\\n         i=i+1;\\n     }   \\n    }\\n    return xrr;\\n};\\n\\nI dont know what is the problem in this code , the error is in return type but I tried all the method plz let me know :)"
                    }
                ]
            },
            {
                "id": 1737364,
                "content": [
                    {
                        "username": "PrateekDoliya",
                        "content": "OPTIMISED JAVA CODE\\nTime Complexity = O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum[] = new int[n];\\n        sum[0] = nums[0];\\n        for(int i=1 ; i < n ; i++) {\\n            sum[i] = sum[i-1] + nums[i]; \\n        }\\n        return sum;\\n    }\\n}\\n "
                    },
                    {
                        "username": "abhishtt2110",
                        "content": "Easy Solution in Java\\n`class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum =0;\\n        int n= nums.length;\\n        int[] sums = new int[n];\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            sums[i]=sum;\\n        }\\n        return sums;\\n    }\\n}`"
                    },
                    {
                        "username": "LordOfDeadbush",
                        "content": "A fun challenge is to only use one variable in the solution: The solution vector. "
                    },
                    {
                        "username": "helloabhi004",
                        "content": "//I want to solve this problem using C language but can\\'t seem to find proper solution to it please help?\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for (int i=0; i<numsSize; i++){\\n        returnSize= nums[i] + nums[i+1];\\n        printf(\"%d\", returnSize);\\n    }\\n}\\n\\nint main(){\\n    int nums, size, arr[];\\n    arrSize=(int returnSize*)malloc(sizeof(int returnSize));\\n    printf(\"\\\\nEnter the size of array\\\\n\");\\n    scanf(\"%d\",&size);\\n    for(int i=0; i<size; i++){\\n        printf(\"Enter the element\\\\n\")\\n        scanf(\"%d\", &arr[num]);\\n    }\\n    printf(\"Output:\", runningSum(arr[num], size, returnSize));\\n} "
                    },
                    {
                        "username": "durveshpal538",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = nums[0];\\n        int n = nums.size();\\n        for(int i=1; i<n;i++)\\n        {\\n            nums[i] =nums[i]+sum ;\\n            sum  = nums[i];\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Krishnkant_singh",
                        "content": "The problem statement is pretty easy and understandable. I will tell you how you can do it through iterative approach. My solution came in at 4ms.\\nHere we will use for loop and will add element in a variable iteratively and store it an another vector and then we will return it.\\n\\nfor(int i =0; i<n; i++){\\n          sum = sum + nums[i];\\n          arrtemp.push_back(sum);\\n      } \\n      \\n"
                    },
                    {
                        "username": "BhushanBK",
                        "content": "//in JAVA\npublic int[] runningSum(int[] nums) {\n        int[] ans=new int[nums.length];\n        for(int i=0;i<nums.length;i++)\n            ans[i]=sum(nums,i);\n        return ans;\n    }\n    public int sum(int[] num,int end){\n        int sum=0;\n        for(int i=0;i<=end;i++)\n            sum+=num[i];\n        return sum;\n\n    }"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "class Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(len(nums)-1):\\n            nums[i+1]+= nums[i]\\n        return nums"
                    },
                    {
                        "username": "abdulbasitkhan2733",
                        "content": "how can i solve this problem please help me."
                    },
                    {
                        "username": "Eagle_eye",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n     for(auto it=nums[i].begin;it!=nums[i].end();it++)\\n     {\\n         int i=0,z=0;\\n         vector<int> xrr[100];\\n         z=z+*it\\n         xrr[i].push_back(z);\\n         i=i+1;\\n     }   \\n    }\\n    return xrr;\\n};\\n\\nI dont know what is the problem in this code , the error is in return type but I tried all the method plz let me know :)"
                    }
                ]
            },
            {
                "id": 1736257,
                "content": [
                    {
                        "username": "PrateekDoliya",
                        "content": "OPTIMISED JAVA CODE\\nTime Complexity = O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum[] = new int[n];\\n        sum[0] = nums[0];\\n        for(int i=1 ; i < n ; i++) {\\n            sum[i] = sum[i-1] + nums[i]; \\n        }\\n        return sum;\\n    }\\n}\\n "
                    },
                    {
                        "username": "abhishtt2110",
                        "content": "Easy Solution in Java\\n`class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum =0;\\n        int n= nums.length;\\n        int[] sums = new int[n];\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            sums[i]=sum;\\n        }\\n        return sums;\\n    }\\n}`"
                    },
                    {
                        "username": "LordOfDeadbush",
                        "content": "A fun challenge is to only use one variable in the solution: The solution vector. "
                    },
                    {
                        "username": "helloabhi004",
                        "content": "//I want to solve this problem using C language but can\\'t seem to find proper solution to it please help?\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for (int i=0; i<numsSize; i++){\\n        returnSize= nums[i] + nums[i+1];\\n        printf(\"%d\", returnSize);\\n    }\\n}\\n\\nint main(){\\n    int nums, size, arr[];\\n    arrSize=(int returnSize*)malloc(sizeof(int returnSize));\\n    printf(\"\\\\nEnter the size of array\\\\n\");\\n    scanf(\"%d\",&size);\\n    for(int i=0; i<size; i++){\\n        printf(\"Enter the element\\\\n\")\\n        scanf(\"%d\", &arr[num]);\\n    }\\n    printf(\"Output:\", runningSum(arr[num], size, returnSize));\\n} "
                    },
                    {
                        "username": "durveshpal538",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = nums[0];\\n        int n = nums.size();\\n        for(int i=1; i<n;i++)\\n        {\\n            nums[i] =nums[i]+sum ;\\n            sum  = nums[i];\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Krishnkant_singh",
                        "content": "The problem statement is pretty easy and understandable. I will tell you how you can do it through iterative approach. My solution came in at 4ms.\\nHere we will use for loop and will add element in a variable iteratively and store it an another vector and then we will return it.\\n\\nfor(int i =0; i<n; i++){\\n          sum = sum + nums[i];\\n          arrtemp.push_back(sum);\\n      } \\n      \\n"
                    },
                    {
                        "username": "BhushanBK",
                        "content": "//in JAVA\npublic int[] runningSum(int[] nums) {\n        int[] ans=new int[nums.length];\n        for(int i=0;i<nums.length;i++)\n            ans[i]=sum(nums,i);\n        return ans;\n    }\n    public int sum(int[] num,int end){\n        int sum=0;\n        for(int i=0;i<=end;i++)\n            sum+=num[i];\n        return sum;\n\n    }"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "class Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(len(nums)-1):\\n            nums[i+1]+= nums[i]\\n        return nums"
                    },
                    {
                        "username": "abdulbasitkhan2733",
                        "content": "how can i solve this problem please help me."
                    },
                    {
                        "username": "Eagle_eye",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n     for(auto it=nums[i].begin;it!=nums[i].end();it++)\\n     {\\n         int i=0,z=0;\\n         vector<int> xrr[100];\\n         z=z+*it\\n         xrr[i].push_back(z);\\n         i=i+1;\\n     }   \\n    }\\n    return xrr;\\n};\\n\\nI dont know what is the problem in this code , the error is in return type but I tried all the method plz let me know :)"
                    }
                ]
            },
            {
                "id": 1734300,
                "content": [
                    {
                        "username": "PrateekDoliya",
                        "content": "OPTIMISED JAVA CODE\\nTime Complexity = O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum[] = new int[n];\\n        sum[0] = nums[0];\\n        for(int i=1 ; i < n ; i++) {\\n            sum[i] = sum[i-1] + nums[i]; \\n        }\\n        return sum;\\n    }\\n}\\n "
                    },
                    {
                        "username": "abhishtt2110",
                        "content": "Easy Solution in Java\\n`class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum =0;\\n        int n= nums.length;\\n        int[] sums = new int[n];\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            sums[i]=sum;\\n        }\\n        return sums;\\n    }\\n}`"
                    },
                    {
                        "username": "LordOfDeadbush",
                        "content": "A fun challenge is to only use one variable in the solution: The solution vector. "
                    },
                    {
                        "username": "helloabhi004",
                        "content": "//I want to solve this problem using C language but can\\'t seem to find proper solution to it please help?\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for (int i=0; i<numsSize; i++){\\n        returnSize= nums[i] + nums[i+1];\\n        printf(\"%d\", returnSize);\\n    }\\n}\\n\\nint main(){\\n    int nums, size, arr[];\\n    arrSize=(int returnSize*)malloc(sizeof(int returnSize));\\n    printf(\"\\\\nEnter the size of array\\\\n\");\\n    scanf(\"%d\",&size);\\n    for(int i=0; i<size; i++){\\n        printf(\"Enter the element\\\\n\")\\n        scanf(\"%d\", &arr[num]);\\n    }\\n    printf(\"Output:\", runningSum(arr[num], size, returnSize));\\n} "
                    },
                    {
                        "username": "durveshpal538",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = nums[0];\\n        int n = nums.size();\\n        for(int i=1; i<n;i++)\\n        {\\n            nums[i] =nums[i]+sum ;\\n            sum  = nums[i];\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Krishnkant_singh",
                        "content": "The problem statement is pretty easy and understandable. I will tell you how you can do it through iterative approach. My solution came in at 4ms.\\nHere we will use for loop and will add element in a variable iteratively and store it an another vector and then we will return it.\\n\\nfor(int i =0; i<n; i++){\\n          sum = sum + nums[i];\\n          arrtemp.push_back(sum);\\n      } \\n      \\n"
                    },
                    {
                        "username": "BhushanBK",
                        "content": "//in JAVA\npublic int[] runningSum(int[] nums) {\n        int[] ans=new int[nums.length];\n        for(int i=0;i<nums.length;i++)\n            ans[i]=sum(nums,i);\n        return ans;\n    }\n    public int sum(int[] num,int end){\n        int sum=0;\n        for(int i=0;i<=end;i++)\n            sum+=num[i];\n        return sum;\n\n    }"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "class Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(len(nums)-1):\\n            nums[i+1]+= nums[i]\\n        return nums"
                    },
                    {
                        "username": "abdulbasitkhan2733",
                        "content": "how can i solve this problem please help me."
                    },
                    {
                        "username": "Eagle_eye",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n     for(auto it=nums[i].begin;it!=nums[i].end();it++)\\n     {\\n         int i=0,z=0;\\n         vector<int> xrr[100];\\n         z=z+*it\\n         xrr[i].push_back(z);\\n         i=i+1;\\n     }   \\n    }\\n    return xrr;\\n};\\n\\nI dont know what is the problem in this code , the error is in return type but I tried all the method plz let me know :)"
                    }
                ]
            },
            {
                "id": 1732627,
                "content": [
                    {
                        "username": "PrateekDoliya",
                        "content": "OPTIMISED JAVA CODE\\nTime Complexity = O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum[] = new int[n];\\n        sum[0] = nums[0];\\n        for(int i=1 ; i < n ; i++) {\\n            sum[i] = sum[i-1] + nums[i]; \\n        }\\n        return sum;\\n    }\\n}\\n "
                    },
                    {
                        "username": "abhishtt2110",
                        "content": "Easy Solution in Java\\n`class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum =0;\\n        int n= nums.length;\\n        int[] sums = new int[n];\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            sums[i]=sum;\\n        }\\n        return sums;\\n    }\\n}`"
                    },
                    {
                        "username": "LordOfDeadbush",
                        "content": "A fun challenge is to only use one variable in the solution: The solution vector. "
                    },
                    {
                        "username": "helloabhi004",
                        "content": "//I want to solve this problem using C language but can\\'t seem to find proper solution to it please help?\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for (int i=0; i<numsSize; i++){\\n        returnSize= nums[i] + nums[i+1];\\n        printf(\"%d\", returnSize);\\n    }\\n}\\n\\nint main(){\\n    int nums, size, arr[];\\n    arrSize=(int returnSize*)malloc(sizeof(int returnSize));\\n    printf(\"\\\\nEnter the size of array\\\\n\");\\n    scanf(\"%d\",&size);\\n    for(int i=0; i<size; i++){\\n        printf(\"Enter the element\\\\n\")\\n        scanf(\"%d\", &arr[num]);\\n    }\\n    printf(\"Output:\", runningSum(arr[num], size, returnSize));\\n} "
                    },
                    {
                        "username": "durveshpal538",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = nums[0];\\n        int n = nums.size();\\n        for(int i=1; i<n;i++)\\n        {\\n            nums[i] =nums[i]+sum ;\\n            sum  = nums[i];\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Krishnkant_singh",
                        "content": "The problem statement is pretty easy and understandable. I will tell you how you can do it through iterative approach. My solution came in at 4ms.\\nHere we will use for loop and will add element in a variable iteratively and store it an another vector and then we will return it.\\n\\nfor(int i =0; i<n; i++){\\n          sum = sum + nums[i];\\n          arrtemp.push_back(sum);\\n      } \\n      \\n"
                    },
                    {
                        "username": "BhushanBK",
                        "content": "//in JAVA\npublic int[] runningSum(int[] nums) {\n        int[] ans=new int[nums.length];\n        for(int i=0;i<nums.length;i++)\n            ans[i]=sum(nums,i);\n        return ans;\n    }\n    public int sum(int[] num,int end){\n        int sum=0;\n        for(int i=0;i<=end;i++)\n            sum+=num[i];\n        return sum;\n\n    }"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "class Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(len(nums)-1):\\n            nums[i+1]+= nums[i]\\n        return nums"
                    },
                    {
                        "username": "abdulbasitkhan2733",
                        "content": "how can i solve this problem please help me."
                    },
                    {
                        "username": "Eagle_eye",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n     for(auto it=nums[i].begin;it!=nums[i].end();it++)\\n     {\\n         int i=0,z=0;\\n         vector<int> xrr[100];\\n         z=z+*it\\n         xrr[i].push_back(z);\\n         i=i+1;\\n     }   \\n    }\\n    return xrr;\\n};\\n\\nI dont know what is the problem in this code , the error is in return type but I tried all the method plz let me know :)"
                    }
                ]
            },
            {
                "id": 1728780,
                "content": [
                    {
                        "username": "PrateekDoliya",
                        "content": "OPTIMISED JAVA CODE\\nTime Complexity = O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum[] = new int[n];\\n        sum[0] = nums[0];\\n        for(int i=1 ; i < n ; i++) {\\n            sum[i] = sum[i-1] + nums[i]; \\n        }\\n        return sum;\\n    }\\n}\\n "
                    },
                    {
                        "username": "abhishtt2110",
                        "content": "Easy Solution in Java\\n`class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum =0;\\n        int n= nums.length;\\n        int[] sums = new int[n];\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            sums[i]=sum;\\n        }\\n        return sums;\\n    }\\n}`"
                    },
                    {
                        "username": "LordOfDeadbush",
                        "content": "A fun challenge is to only use one variable in the solution: The solution vector. "
                    },
                    {
                        "username": "helloabhi004",
                        "content": "//I want to solve this problem using C language but can\\'t seem to find proper solution to it please help?\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for (int i=0; i<numsSize; i++){\\n        returnSize= nums[i] + nums[i+1];\\n        printf(\"%d\", returnSize);\\n    }\\n}\\n\\nint main(){\\n    int nums, size, arr[];\\n    arrSize=(int returnSize*)malloc(sizeof(int returnSize));\\n    printf(\"\\\\nEnter the size of array\\\\n\");\\n    scanf(\"%d\",&size);\\n    for(int i=0; i<size; i++){\\n        printf(\"Enter the element\\\\n\")\\n        scanf(\"%d\", &arr[num]);\\n    }\\n    printf(\"Output:\", runningSum(arr[num], size, returnSize));\\n} "
                    },
                    {
                        "username": "durveshpal538",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = nums[0];\\n        int n = nums.size();\\n        for(int i=1; i<n;i++)\\n        {\\n            nums[i] =nums[i]+sum ;\\n            sum  = nums[i];\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Krishnkant_singh",
                        "content": "The problem statement is pretty easy and understandable. I will tell you how you can do it through iterative approach. My solution came in at 4ms.\\nHere we will use for loop and will add element in a variable iteratively and store it an another vector and then we will return it.\\n\\nfor(int i =0; i<n; i++){\\n          sum = sum + nums[i];\\n          arrtemp.push_back(sum);\\n      } \\n      \\n"
                    },
                    {
                        "username": "BhushanBK",
                        "content": "//in JAVA\npublic int[] runningSum(int[] nums) {\n        int[] ans=new int[nums.length];\n        for(int i=0;i<nums.length;i++)\n            ans[i]=sum(nums,i);\n        return ans;\n    }\n    public int sum(int[] num,int end){\n        int sum=0;\n        for(int i=0;i<=end;i++)\n            sum+=num[i];\n        return sum;\n\n    }"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "class Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(len(nums)-1):\\n            nums[i+1]+= nums[i]\\n        return nums"
                    },
                    {
                        "username": "abdulbasitkhan2733",
                        "content": "how can i solve this problem please help me."
                    },
                    {
                        "username": "Eagle_eye",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n     for(auto it=nums[i].begin;it!=nums[i].end();it++)\\n     {\\n         int i=0,z=0;\\n         vector<int> xrr[100];\\n         z=z+*it\\n         xrr[i].push_back(z);\\n         i=i+1;\\n     }   \\n    }\\n    return xrr;\\n};\\n\\nI dont know what is the problem in this code , the error is in return type but I tried all the method plz let me know :)"
                    }
                ]
            },
            {
                "id": 1726005,
                "content": [
                    {
                        "username": "PrateekDoliya",
                        "content": "OPTIMISED JAVA CODE\\nTime Complexity = O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum[] = new int[n];\\n        sum[0] = nums[0];\\n        for(int i=1 ; i < n ; i++) {\\n            sum[i] = sum[i-1] + nums[i]; \\n        }\\n        return sum;\\n    }\\n}\\n "
                    },
                    {
                        "username": "abhishtt2110",
                        "content": "Easy Solution in Java\\n`class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum =0;\\n        int n= nums.length;\\n        int[] sums = new int[n];\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            sums[i]=sum;\\n        }\\n        return sums;\\n    }\\n}`"
                    },
                    {
                        "username": "LordOfDeadbush",
                        "content": "A fun challenge is to only use one variable in the solution: The solution vector. "
                    },
                    {
                        "username": "helloabhi004",
                        "content": "//I want to solve this problem using C language but can\\'t seem to find proper solution to it please help?\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for (int i=0; i<numsSize; i++){\\n        returnSize= nums[i] + nums[i+1];\\n        printf(\"%d\", returnSize);\\n    }\\n}\\n\\nint main(){\\n    int nums, size, arr[];\\n    arrSize=(int returnSize*)malloc(sizeof(int returnSize));\\n    printf(\"\\\\nEnter the size of array\\\\n\");\\n    scanf(\"%d\",&size);\\n    for(int i=0; i<size; i++){\\n        printf(\"Enter the element\\\\n\")\\n        scanf(\"%d\", &arr[num]);\\n    }\\n    printf(\"Output:\", runningSum(arr[num], size, returnSize));\\n} "
                    },
                    {
                        "username": "durveshpal538",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = nums[0];\\n        int n = nums.size();\\n        for(int i=1; i<n;i++)\\n        {\\n            nums[i] =nums[i]+sum ;\\n            sum  = nums[i];\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Krishnkant_singh",
                        "content": "The problem statement is pretty easy and understandable. I will tell you how you can do it through iterative approach. My solution came in at 4ms.\\nHere we will use for loop and will add element in a variable iteratively and store it an another vector and then we will return it.\\n\\nfor(int i =0; i<n; i++){\\n          sum = sum + nums[i];\\n          arrtemp.push_back(sum);\\n      } \\n      \\n"
                    },
                    {
                        "username": "BhushanBK",
                        "content": "//in JAVA\npublic int[] runningSum(int[] nums) {\n        int[] ans=new int[nums.length];\n        for(int i=0;i<nums.length;i++)\n            ans[i]=sum(nums,i);\n        return ans;\n    }\n    public int sum(int[] num,int end){\n        int sum=0;\n        for(int i=0;i<=end;i++)\n            sum+=num[i];\n        return sum;\n\n    }"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "class Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(len(nums)-1):\\n            nums[i+1]+= nums[i]\\n        return nums"
                    },
                    {
                        "username": "abdulbasitkhan2733",
                        "content": "how can i solve this problem please help me."
                    },
                    {
                        "username": "Eagle_eye",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n     for(auto it=nums[i].begin;it!=nums[i].end();it++)\\n     {\\n         int i=0,z=0;\\n         vector<int> xrr[100];\\n         z=z+*it\\n         xrr[i].push_back(z);\\n         i=i+1;\\n     }   \\n    }\\n    return xrr;\\n};\\n\\nI dont know what is the problem in this code , the error is in return type but I tried all the method plz let me know :)"
                    }
                ]
            },
            {
                "id": 1723628,
                "content": [
                    {
                        "username": "PrateekDoliya",
                        "content": "OPTIMISED JAVA CODE\\nTime Complexity = O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum[] = new int[n];\\n        sum[0] = nums[0];\\n        for(int i=1 ; i < n ; i++) {\\n            sum[i] = sum[i-1] + nums[i]; \\n        }\\n        return sum;\\n    }\\n}\\n "
                    },
                    {
                        "username": "abhishtt2110",
                        "content": "Easy Solution in Java\\n`class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum =0;\\n        int n= nums.length;\\n        int[] sums = new int[n];\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            sums[i]=sum;\\n        }\\n        return sums;\\n    }\\n}`"
                    },
                    {
                        "username": "LordOfDeadbush",
                        "content": "A fun challenge is to only use one variable in the solution: The solution vector. "
                    },
                    {
                        "username": "helloabhi004",
                        "content": "//I want to solve this problem using C language but can\\'t seem to find proper solution to it please help?\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for (int i=0; i<numsSize; i++){\\n        returnSize= nums[i] + nums[i+1];\\n        printf(\"%d\", returnSize);\\n    }\\n}\\n\\nint main(){\\n    int nums, size, arr[];\\n    arrSize=(int returnSize*)malloc(sizeof(int returnSize));\\n    printf(\"\\\\nEnter the size of array\\\\n\");\\n    scanf(\"%d\",&size);\\n    for(int i=0; i<size; i++){\\n        printf(\"Enter the element\\\\n\")\\n        scanf(\"%d\", &arr[num]);\\n    }\\n    printf(\"Output:\", runningSum(arr[num], size, returnSize));\\n} "
                    },
                    {
                        "username": "durveshpal538",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = nums[0];\\n        int n = nums.size();\\n        for(int i=1; i<n;i++)\\n        {\\n            nums[i] =nums[i]+sum ;\\n            sum  = nums[i];\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Krishnkant_singh",
                        "content": "The problem statement is pretty easy and understandable. I will tell you how you can do it through iterative approach. My solution came in at 4ms.\\nHere we will use for loop and will add element in a variable iteratively and store it an another vector and then we will return it.\\n\\nfor(int i =0; i<n; i++){\\n          sum = sum + nums[i];\\n          arrtemp.push_back(sum);\\n      } \\n      \\n"
                    },
                    {
                        "username": "BhushanBK",
                        "content": "//in JAVA\npublic int[] runningSum(int[] nums) {\n        int[] ans=new int[nums.length];\n        for(int i=0;i<nums.length;i++)\n            ans[i]=sum(nums,i);\n        return ans;\n    }\n    public int sum(int[] num,int end){\n        int sum=0;\n        for(int i=0;i<=end;i++)\n            sum+=num[i];\n        return sum;\n\n    }"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "class Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(len(nums)-1):\\n            nums[i+1]+= nums[i]\\n        return nums"
                    },
                    {
                        "username": "abdulbasitkhan2733",
                        "content": "how can i solve this problem please help me."
                    },
                    {
                        "username": "Eagle_eye",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n     for(auto it=nums[i].begin;it!=nums[i].end();it++)\\n     {\\n         int i=0,z=0;\\n         vector<int> xrr[100];\\n         z=z+*it\\n         xrr[i].push_back(z);\\n         i=i+1;\\n     }   \\n    }\\n    return xrr;\\n};\\n\\nI dont know what is the problem in this code , the error is in return type but I tried all the method plz let me know :)"
                    }
                ]
            },
            {
                "id": 1719413,
                "content": [
                    {
                        "username": "PrateekDoliya",
                        "content": "OPTIMISED JAVA CODE\\nTime Complexity = O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum[] = new int[n];\\n        sum[0] = nums[0];\\n        for(int i=1 ; i < n ; i++) {\\n            sum[i] = sum[i-1] + nums[i]; \\n        }\\n        return sum;\\n    }\\n}\\n "
                    },
                    {
                        "username": "abhishtt2110",
                        "content": "Easy Solution in Java\\n`class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum =0;\\n        int n= nums.length;\\n        int[] sums = new int[n];\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            sums[i]=sum;\\n        }\\n        return sums;\\n    }\\n}`"
                    },
                    {
                        "username": "LordOfDeadbush",
                        "content": "A fun challenge is to only use one variable in the solution: The solution vector. "
                    },
                    {
                        "username": "helloabhi004",
                        "content": "//I want to solve this problem using C language but can\\'t seem to find proper solution to it please help?\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for (int i=0; i<numsSize; i++){\\n        returnSize= nums[i] + nums[i+1];\\n        printf(\"%d\", returnSize);\\n    }\\n}\\n\\nint main(){\\n    int nums, size, arr[];\\n    arrSize=(int returnSize*)malloc(sizeof(int returnSize));\\n    printf(\"\\\\nEnter the size of array\\\\n\");\\n    scanf(\"%d\",&size);\\n    for(int i=0; i<size; i++){\\n        printf(\"Enter the element\\\\n\")\\n        scanf(\"%d\", &arr[num]);\\n    }\\n    printf(\"Output:\", runningSum(arr[num], size, returnSize));\\n} "
                    },
                    {
                        "username": "durveshpal538",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = nums[0];\\n        int n = nums.size();\\n        for(int i=1; i<n;i++)\\n        {\\n            nums[i] =nums[i]+sum ;\\n            sum  = nums[i];\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Krishnkant_singh",
                        "content": "The problem statement is pretty easy and understandable. I will tell you how you can do it through iterative approach. My solution came in at 4ms.\\nHere we will use for loop and will add element in a variable iteratively and store it an another vector and then we will return it.\\n\\nfor(int i =0; i<n; i++){\\n          sum = sum + nums[i];\\n          arrtemp.push_back(sum);\\n      } \\n      \\n"
                    },
                    {
                        "username": "BhushanBK",
                        "content": "//in JAVA\npublic int[] runningSum(int[] nums) {\n        int[] ans=new int[nums.length];\n        for(int i=0;i<nums.length;i++)\n            ans[i]=sum(nums,i);\n        return ans;\n    }\n    public int sum(int[] num,int end){\n        int sum=0;\n        for(int i=0;i<=end;i++)\n            sum+=num[i];\n        return sum;\n\n    }"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "class Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(len(nums)-1):\\n            nums[i+1]+= nums[i]\\n        return nums"
                    },
                    {
                        "username": "abdulbasitkhan2733",
                        "content": "how can i solve this problem please help me."
                    },
                    {
                        "username": "Eagle_eye",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n     for(auto it=nums[i].begin;it!=nums[i].end();it++)\\n     {\\n         int i=0,z=0;\\n         vector<int> xrr[100];\\n         z=z+*it\\n         xrr[i].push_back(z);\\n         i=i+1;\\n     }   \\n    }\\n    return xrr;\\n};\\n\\nI dont know what is the problem in this code , the error is in return type but I tried all the method plz let me know :)"
                    }
                ]
            },
            {
                "id": 1718528,
                "content": [
                    {
                        "username": "savkul",
                        "content": "Compile Error\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int> nums) {\\n\\n\\n        vector<int> runningSum;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i = i + 1)\\n        sum = sum + nums[i];\\n        runningSum.push_back(sum);\\n        cout << \"i = \" << i << \" nums[i] = \"; <<nums[i] << \"; sum = \" << sum << endl;\\n     }\\n     return runningSum;\\n};\\n"
                    },
                    {
                        "username": "ugiun1059",
                        "content": "Hello all, I am using C++, but how can we check the members of the class vector?"
                    },
                    {
                        "username": "Yani02",
                        "content": "Hy  i have a solution in c that works in replit but not in leet code ????? did you know why ?\\n\\n\\n \\n"
                    },
                    {
                        "username": "Yani02",
                        "content": "there is my solution : \\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n     int *m = malloc(sizeof(int)*numsSize);\\n    m[0]=nums[0];\\nfor(int i = 1; numsSize; i++){\\n    m[i]=nums[i]+m[i-1];\\n}\\nreturn m;\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "***************************************************************\\nPython Working Code:\\n\\n[ sum ( nums [ : i+1 ] ) for i in range ( len ( nums ) ) ]\\n\\n**************************************************************"
                    },
                    {
                        "username": "tanishq16",
                        "content": "Is the best optimal solution has TC = O(n) and SC = O(n)?? or is there any more optimal soln.\\n"
                    },
                    {
                        "username": "pawankumar100",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        int[]ans= new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n}\\n \\n        \\n    \\n"
                    },
                    {
                        "username": "gentleman_ghost",
                        "content": "While coding the solution in C the judge seems not to read any value from the array. I declare the  `int* ret` array then allocate memory to it `malloc(numsSize * sizeof(int)` . Then after completing the task I get info that the array is empty, even though I check it while the program runs and I can print out every element of it. Output I get is:  `]`"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "umar630492866",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n            {\\n\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                nums[i]=sum;\\n            }\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "Ajmal_ali",
                        "content": "This approach is in javaScript\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++){\\n        sum += nums[i]\\n        nums[i] = sum\\n    }\\n    return nums\\n};\\nSpace complexity O(1)"
                    },
                    {
                        "username": "SunayanaT",
                        "content": "For a solution in Java, why is it taking 0ms when you use for loop and 1ms when you use while loop for the same code? Is while loop faster than for loop? I know that it depends on compiler and running background processes if any. Although, I wanted to know if there is any specific reason for the same."
                    }
                ]
            },
            {
                "id": 1717424,
                "content": [
                    {
                        "username": "savkul",
                        "content": "Compile Error\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int> nums) {\\n\\n\\n        vector<int> runningSum;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i = i + 1)\\n        sum = sum + nums[i];\\n        runningSum.push_back(sum);\\n        cout << \"i = \" << i << \" nums[i] = \"; <<nums[i] << \"; sum = \" << sum << endl;\\n     }\\n     return runningSum;\\n};\\n"
                    },
                    {
                        "username": "ugiun1059",
                        "content": "Hello all, I am using C++, but how can we check the members of the class vector?"
                    },
                    {
                        "username": "Yani02",
                        "content": "Hy  i have a solution in c that works in replit but not in leet code ????? did you know why ?\\n\\n\\n \\n"
                    },
                    {
                        "username": "Yani02",
                        "content": "there is my solution : \\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n     int *m = malloc(sizeof(int)*numsSize);\\n    m[0]=nums[0];\\nfor(int i = 1; numsSize; i++){\\n    m[i]=nums[i]+m[i-1];\\n}\\nreturn m;\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "***************************************************************\\nPython Working Code:\\n\\n[ sum ( nums [ : i+1 ] ) for i in range ( len ( nums ) ) ]\\n\\n**************************************************************"
                    },
                    {
                        "username": "tanishq16",
                        "content": "Is the best optimal solution has TC = O(n) and SC = O(n)?? or is there any more optimal soln.\\n"
                    },
                    {
                        "username": "pawankumar100",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        int[]ans= new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n}\\n \\n        \\n    \\n"
                    },
                    {
                        "username": "gentleman_ghost",
                        "content": "While coding the solution in C the judge seems not to read any value from the array. I declare the  `int* ret` array then allocate memory to it `malloc(numsSize * sizeof(int)` . Then after completing the task I get info that the array is empty, even though I check it while the program runs and I can print out every element of it. Output I get is:  `]`"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "umar630492866",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n            {\\n\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                nums[i]=sum;\\n            }\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "Ajmal_ali",
                        "content": "This approach is in javaScript\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++){\\n        sum += nums[i]\\n        nums[i] = sum\\n    }\\n    return nums\\n};\\nSpace complexity O(1)"
                    },
                    {
                        "username": "SunayanaT",
                        "content": "For a solution in Java, why is it taking 0ms when you use for loop and 1ms when you use while loop for the same code? Is while loop faster than for loop? I know that it depends on compiler and running background processes if any. Although, I wanted to know if there is any specific reason for the same."
                    }
                ]
            },
            {
                "id": 1716453,
                "content": [
                    {
                        "username": "savkul",
                        "content": "Compile Error\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int> nums) {\\n\\n\\n        vector<int> runningSum;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i = i + 1)\\n        sum = sum + nums[i];\\n        runningSum.push_back(sum);\\n        cout << \"i = \" << i << \" nums[i] = \"; <<nums[i] << \"; sum = \" << sum << endl;\\n     }\\n     return runningSum;\\n};\\n"
                    },
                    {
                        "username": "ugiun1059",
                        "content": "Hello all, I am using C++, but how can we check the members of the class vector?"
                    },
                    {
                        "username": "Yani02",
                        "content": "Hy  i have a solution in c that works in replit but not in leet code ????? did you know why ?\\n\\n\\n \\n"
                    },
                    {
                        "username": "Yani02",
                        "content": "there is my solution : \\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n     int *m = malloc(sizeof(int)*numsSize);\\n    m[0]=nums[0];\\nfor(int i = 1; numsSize; i++){\\n    m[i]=nums[i]+m[i-1];\\n}\\nreturn m;\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "***************************************************************\\nPython Working Code:\\n\\n[ sum ( nums [ : i+1 ] ) for i in range ( len ( nums ) ) ]\\n\\n**************************************************************"
                    },
                    {
                        "username": "tanishq16",
                        "content": "Is the best optimal solution has TC = O(n) and SC = O(n)?? or is there any more optimal soln.\\n"
                    },
                    {
                        "username": "pawankumar100",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        int[]ans= new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n}\\n \\n        \\n    \\n"
                    },
                    {
                        "username": "gentleman_ghost",
                        "content": "While coding the solution in C the judge seems not to read any value from the array. I declare the  `int* ret` array then allocate memory to it `malloc(numsSize * sizeof(int)` . Then after completing the task I get info that the array is empty, even though I check it while the program runs and I can print out every element of it. Output I get is:  `]`"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "umar630492866",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n            {\\n\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                nums[i]=sum;\\n            }\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "Ajmal_ali",
                        "content": "This approach is in javaScript\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++){\\n        sum += nums[i]\\n        nums[i] = sum\\n    }\\n    return nums\\n};\\nSpace complexity O(1)"
                    },
                    {
                        "username": "SunayanaT",
                        "content": "For a solution in Java, why is it taking 0ms when you use for loop and 1ms when you use while loop for the same code? Is while loop faster than for loop? I know that it depends on compiler and running background processes if any. Although, I wanted to know if there is any specific reason for the same."
                    }
                ]
            },
            {
                "id": 1715558,
                "content": [
                    {
                        "username": "savkul",
                        "content": "Compile Error\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int> nums) {\\n\\n\\n        vector<int> runningSum;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i = i + 1)\\n        sum = sum + nums[i];\\n        runningSum.push_back(sum);\\n        cout << \"i = \" << i << \" nums[i] = \"; <<nums[i] << \"; sum = \" << sum << endl;\\n     }\\n     return runningSum;\\n};\\n"
                    },
                    {
                        "username": "ugiun1059",
                        "content": "Hello all, I am using C++, but how can we check the members of the class vector?"
                    },
                    {
                        "username": "Yani02",
                        "content": "Hy  i have a solution in c that works in replit but not in leet code ????? did you know why ?\\n\\n\\n \\n"
                    },
                    {
                        "username": "Yani02",
                        "content": "there is my solution : \\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n     int *m = malloc(sizeof(int)*numsSize);\\n    m[0]=nums[0];\\nfor(int i = 1; numsSize; i++){\\n    m[i]=nums[i]+m[i-1];\\n}\\nreturn m;\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "***************************************************************\\nPython Working Code:\\n\\n[ sum ( nums [ : i+1 ] ) for i in range ( len ( nums ) ) ]\\n\\n**************************************************************"
                    },
                    {
                        "username": "tanishq16",
                        "content": "Is the best optimal solution has TC = O(n) and SC = O(n)?? or is there any more optimal soln.\\n"
                    },
                    {
                        "username": "pawankumar100",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        int[]ans= new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n}\\n \\n        \\n    \\n"
                    },
                    {
                        "username": "gentleman_ghost",
                        "content": "While coding the solution in C the judge seems not to read any value from the array. I declare the  `int* ret` array then allocate memory to it `malloc(numsSize * sizeof(int)` . Then after completing the task I get info that the array is empty, even though I check it while the program runs and I can print out every element of it. Output I get is:  `]`"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "umar630492866",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n            {\\n\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                nums[i]=sum;\\n            }\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "Ajmal_ali",
                        "content": "This approach is in javaScript\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++){\\n        sum += nums[i]\\n        nums[i] = sum\\n    }\\n    return nums\\n};\\nSpace complexity O(1)"
                    },
                    {
                        "username": "SunayanaT",
                        "content": "For a solution in Java, why is it taking 0ms when you use for loop and 1ms when you use while loop for the same code? Is while loop faster than for loop? I know that it depends on compiler and running background processes if any. Although, I wanted to know if there is any specific reason for the same."
                    }
                ]
            },
            {
                "id": 1715006,
                "content": [
                    {
                        "username": "savkul",
                        "content": "Compile Error\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int> nums) {\\n\\n\\n        vector<int> runningSum;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i = i + 1)\\n        sum = sum + nums[i];\\n        runningSum.push_back(sum);\\n        cout << \"i = \" << i << \" nums[i] = \"; <<nums[i] << \"; sum = \" << sum << endl;\\n     }\\n     return runningSum;\\n};\\n"
                    },
                    {
                        "username": "ugiun1059",
                        "content": "Hello all, I am using C++, but how can we check the members of the class vector?"
                    },
                    {
                        "username": "Yani02",
                        "content": "Hy  i have a solution in c that works in replit but not in leet code ????? did you know why ?\\n\\n\\n \\n"
                    },
                    {
                        "username": "Yani02",
                        "content": "there is my solution : \\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n     int *m = malloc(sizeof(int)*numsSize);\\n    m[0]=nums[0];\\nfor(int i = 1; numsSize; i++){\\n    m[i]=nums[i]+m[i-1];\\n}\\nreturn m;\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "***************************************************************\\nPython Working Code:\\n\\n[ sum ( nums [ : i+1 ] ) for i in range ( len ( nums ) ) ]\\n\\n**************************************************************"
                    },
                    {
                        "username": "tanishq16",
                        "content": "Is the best optimal solution has TC = O(n) and SC = O(n)?? or is there any more optimal soln.\\n"
                    },
                    {
                        "username": "pawankumar100",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        int[]ans= new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n}\\n \\n        \\n    \\n"
                    },
                    {
                        "username": "gentleman_ghost",
                        "content": "While coding the solution in C the judge seems not to read any value from the array. I declare the  `int* ret` array then allocate memory to it `malloc(numsSize * sizeof(int)` . Then after completing the task I get info that the array is empty, even though I check it while the program runs and I can print out every element of it. Output I get is:  `]`"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "umar630492866",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n            {\\n\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                nums[i]=sum;\\n            }\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "Ajmal_ali",
                        "content": "This approach is in javaScript\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++){\\n        sum += nums[i]\\n        nums[i] = sum\\n    }\\n    return nums\\n};\\nSpace complexity O(1)"
                    },
                    {
                        "username": "SunayanaT",
                        "content": "For a solution in Java, why is it taking 0ms when you use for loop and 1ms when you use while loop for the same code? Is while loop faster than for loop? I know that it depends on compiler and running background processes if any. Although, I wanted to know if there is any specific reason for the same."
                    }
                ]
            },
            {
                "id": 1707902,
                "content": [
                    {
                        "username": "savkul",
                        "content": "Compile Error\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int> nums) {\\n\\n\\n        vector<int> runningSum;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i = i + 1)\\n        sum = sum + nums[i];\\n        runningSum.push_back(sum);\\n        cout << \"i = \" << i << \" nums[i] = \"; <<nums[i] << \"; sum = \" << sum << endl;\\n     }\\n     return runningSum;\\n};\\n"
                    },
                    {
                        "username": "ugiun1059",
                        "content": "Hello all, I am using C++, but how can we check the members of the class vector?"
                    },
                    {
                        "username": "Yani02",
                        "content": "Hy  i have a solution in c that works in replit but not in leet code ????? did you know why ?\\n\\n\\n \\n"
                    },
                    {
                        "username": "Yani02",
                        "content": "there is my solution : \\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n     int *m = malloc(sizeof(int)*numsSize);\\n    m[0]=nums[0];\\nfor(int i = 1; numsSize; i++){\\n    m[i]=nums[i]+m[i-1];\\n}\\nreturn m;\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "***************************************************************\\nPython Working Code:\\n\\n[ sum ( nums [ : i+1 ] ) for i in range ( len ( nums ) ) ]\\n\\n**************************************************************"
                    },
                    {
                        "username": "tanishq16",
                        "content": "Is the best optimal solution has TC = O(n) and SC = O(n)?? or is there any more optimal soln.\\n"
                    },
                    {
                        "username": "pawankumar100",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        int[]ans= new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n}\\n \\n        \\n    \\n"
                    },
                    {
                        "username": "gentleman_ghost",
                        "content": "While coding the solution in C the judge seems not to read any value from the array. I declare the  `int* ret` array then allocate memory to it `malloc(numsSize * sizeof(int)` . Then after completing the task I get info that the array is empty, even though I check it while the program runs and I can print out every element of it. Output I get is:  `]`"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "umar630492866",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n            {\\n\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                nums[i]=sum;\\n            }\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "Ajmal_ali",
                        "content": "This approach is in javaScript\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++){\\n        sum += nums[i]\\n        nums[i] = sum\\n    }\\n    return nums\\n};\\nSpace complexity O(1)"
                    },
                    {
                        "username": "SunayanaT",
                        "content": "For a solution in Java, why is it taking 0ms when you use for loop and 1ms when you use while loop for the same code? Is while loop faster than for loop? I know that it depends on compiler and running background processes if any. Although, I wanted to know if there is any specific reason for the same."
                    }
                ]
            },
            {
                "id": 1707761,
                "content": [
                    {
                        "username": "savkul",
                        "content": "Compile Error\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int> nums) {\\n\\n\\n        vector<int> runningSum;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i = i + 1)\\n        sum = sum + nums[i];\\n        runningSum.push_back(sum);\\n        cout << \"i = \" << i << \" nums[i] = \"; <<nums[i] << \"; sum = \" << sum << endl;\\n     }\\n     return runningSum;\\n};\\n"
                    },
                    {
                        "username": "ugiun1059",
                        "content": "Hello all, I am using C++, but how can we check the members of the class vector?"
                    },
                    {
                        "username": "Yani02",
                        "content": "Hy  i have a solution in c that works in replit but not in leet code ????? did you know why ?\\n\\n\\n \\n"
                    },
                    {
                        "username": "Yani02",
                        "content": "there is my solution : \\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n     int *m = malloc(sizeof(int)*numsSize);\\n    m[0]=nums[0];\\nfor(int i = 1; numsSize; i++){\\n    m[i]=nums[i]+m[i-1];\\n}\\nreturn m;\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "***************************************************************\\nPython Working Code:\\n\\n[ sum ( nums [ : i+1 ] ) for i in range ( len ( nums ) ) ]\\n\\n**************************************************************"
                    },
                    {
                        "username": "tanishq16",
                        "content": "Is the best optimal solution has TC = O(n) and SC = O(n)?? or is there any more optimal soln.\\n"
                    },
                    {
                        "username": "pawankumar100",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        int[]ans= new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n}\\n \\n        \\n    \\n"
                    },
                    {
                        "username": "gentleman_ghost",
                        "content": "While coding the solution in C the judge seems not to read any value from the array. I declare the  `int* ret` array then allocate memory to it `malloc(numsSize * sizeof(int)` . Then after completing the task I get info that the array is empty, even though I check it while the program runs and I can print out every element of it. Output I get is:  `]`"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "umar630492866",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n            {\\n\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                nums[i]=sum;\\n            }\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "Ajmal_ali",
                        "content": "This approach is in javaScript\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++){\\n        sum += nums[i]\\n        nums[i] = sum\\n    }\\n    return nums\\n};\\nSpace complexity O(1)"
                    },
                    {
                        "username": "SunayanaT",
                        "content": "For a solution in Java, why is it taking 0ms when you use for loop and 1ms when you use while loop for the same code? Is while loop faster than for loop? I know that it depends on compiler and running background processes if any. Although, I wanted to know if there is any specific reason for the same."
                    }
                ]
            },
            {
                "id": 1704405,
                "content": [
                    {
                        "username": "savkul",
                        "content": "Compile Error\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int> nums) {\\n\\n\\n        vector<int> runningSum;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i = i + 1)\\n        sum = sum + nums[i];\\n        runningSum.push_back(sum);\\n        cout << \"i = \" << i << \" nums[i] = \"; <<nums[i] << \"; sum = \" << sum << endl;\\n     }\\n     return runningSum;\\n};\\n"
                    },
                    {
                        "username": "ugiun1059",
                        "content": "Hello all, I am using C++, but how can we check the members of the class vector?"
                    },
                    {
                        "username": "Yani02",
                        "content": "Hy  i have a solution in c that works in replit but not in leet code ????? did you know why ?\\n\\n\\n \\n"
                    },
                    {
                        "username": "Yani02",
                        "content": "there is my solution : \\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n     int *m = malloc(sizeof(int)*numsSize);\\n    m[0]=nums[0];\\nfor(int i = 1; numsSize; i++){\\n    m[i]=nums[i]+m[i-1];\\n}\\nreturn m;\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "***************************************************************\\nPython Working Code:\\n\\n[ sum ( nums [ : i+1 ] ) for i in range ( len ( nums ) ) ]\\n\\n**************************************************************"
                    },
                    {
                        "username": "tanishq16",
                        "content": "Is the best optimal solution has TC = O(n) and SC = O(n)?? or is there any more optimal soln.\\n"
                    },
                    {
                        "username": "pawankumar100",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        int[]ans= new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n}\\n \\n        \\n    \\n"
                    },
                    {
                        "username": "gentleman_ghost",
                        "content": "While coding the solution in C the judge seems not to read any value from the array. I declare the  `int* ret` array then allocate memory to it `malloc(numsSize * sizeof(int)` . Then after completing the task I get info that the array is empty, even though I check it while the program runs and I can print out every element of it. Output I get is:  `]`"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "umar630492866",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n            {\\n\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                nums[i]=sum;\\n            }\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "Ajmal_ali",
                        "content": "This approach is in javaScript\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++){\\n        sum += nums[i]\\n        nums[i] = sum\\n    }\\n    return nums\\n};\\nSpace complexity O(1)"
                    },
                    {
                        "username": "SunayanaT",
                        "content": "For a solution in Java, why is it taking 0ms when you use for loop and 1ms when you use while loop for the same code? Is while loop faster than for loop? I know that it depends on compiler and running background processes if any. Although, I wanted to know if there is any specific reason for the same."
                    }
                ]
            },
            {
                "id": 1693943,
                "content": [
                    {
                        "username": "savkul",
                        "content": "Compile Error\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int> nums) {\\n\\n\\n        vector<int> runningSum;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i = i + 1)\\n        sum = sum + nums[i];\\n        runningSum.push_back(sum);\\n        cout << \"i = \" << i << \" nums[i] = \"; <<nums[i] << \"; sum = \" << sum << endl;\\n     }\\n     return runningSum;\\n};\\n"
                    },
                    {
                        "username": "ugiun1059",
                        "content": "Hello all, I am using C++, but how can we check the members of the class vector?"
                    },
                    {
                        "username": "Yani02",
                        "content": "Hy  i have a solution in c that works in replit but not in leet code ????? did you know why ?\\n\\n\\n \\n"
                    },
                    {
                        "username": "Yani02",
                        "content": "there is my solution : \\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n     int *m = malloc(sizeof(int)*numsSize);\\n    m[0]=nums[0];\\nfor(int i = 1; numsSize; i++){\\n    m[i]=nums[i]+m[i-1];\\n}\\nreturn m;\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "***************************************************************\\nPython Working Code:\\n\\n[ sum ( nums [ : i+1 ] ) for i in range ( len ( nums ) ) ]\\n\\n**************************************************************"
                    },
                    {
                        "username": "tanishq16",
                        "content": "Is the best optimal solution has TC = O(n) and SC = O(n)?? or is there any more optimal soln.\\n"
                    },
                    {
                        "username": "pawankumar100",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        int[]ans= new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n}\\n \\n        \\n    \\n"
                    },
                    {
                        "username": "gentleman_ghost",
                        "content": "While coding the solution in C the judge seems not to read any value from the array. I declare the  `int* ret` array then allocate memory to it `malloc(numsSize * sizeof(int)` . Then after completing the task I get info that the array is empty, even though I check it while the program runs and I can print out every element of it. Output I get is:  `]`"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "umar630492866",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n            {\\n\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                nums[i]=sum;\\n            }\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "Ajmal_ali",
                        "content": "This approach is in javaScript\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++){\\n        sum += nums[i]\\n        nums[i] = sum\\n    }\\n    return nums\\n};\\nSpace complexity O(1)"
                    },
                    {
                        "username": "SunayanaT",
                        "content": "For a solution in Java, why is it taking 0ms when you use for loop and 1ms when you use while loop for the same code? Is while loop faster than for loop? I know that it depends on compiler and running background processes if any. Although, I wanted to know if there is any specific reason for the same."
                    }
                ]
            },
            {
                "id": 1693335,
                "content": [
                    {
                        "username": "savkul",
                        "content": "Compile Error\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int> nums) {\\n\\n\\n        vector<int> runningSum;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i = i + 1)\\n        sum = sum + nums[i];\\n        runningSum.push_back(sum);\\n        cout << \"i = \" << i << \" nums[i] = \"; <<nums[i] << \"; sum = \" << sum << endl;\\n     }\\n     return runningSum;\\n};\\n"
                    },
                    {
                        "username": "ugiun1059",
                        "content": "Hello all, I am using C++, but how can we check the members of the class vector?"
                    },
                    {
                        "username": "Yani02",
                        "content": "Hy  i have a solution in c that works in replit but not in leet code ????? did you know why ?\\n\\n\\n \\n"
                    },
                    {
                        "username": "Yani02",
                        "content": "there is my solution : \\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n     int *m = malloc(sizeof(int)*numsSize);\\n    m[0]=nums[0];\\nfor(int i = 1; numsSize; i++){\\n    m[i]=nums[i]+m[i-1];\\n}\\nreturn m;\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "***************************************************************\\nPython Working Code:\\n\\n[ sum ( nums [ : i+1 ] ) for i in range ( len ( nums ) ) ]\\n\\n**************************************************************"
                    },
                    {
                        "username": "tanishq16",
                        "content": "Is the best optimal solution has TC = O(n) and SC = O(n)?? or is there any more optimal soln.\\n"
                    },
                    {
                        "username": "pawankumar100",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        int[]ans= new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n}\\n \\n        \\n    \\n"
                    },
                    {
                        "username": "gentleman_ghost",
                        "content": "While coding the solution in C the judge seems not to read any value from the array. I declare the  `int* ret` array then allocate memory to it `malloc(numsSize * sizeof(int)` . Then after completing the task I get info that the array is empty, even though I check it while the program runs and I can print out every element of it. Output I get is:  `]`"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "umar630492866",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n            {\\n\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                nums[i]=sum;\\n            }\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "Ajmal_ali",
                        "content": "This approach is in javaScript\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++){\\n        sum += nums[i]\\n        nums[i] = sum\\n    }\\n    return nums\\n};\\nSpace complexity O(1)"
                    },
                    {
                        "username": "SunayanaT",
                        "content": "For a solution in Java, why is it taking 0ms when you use for loop and 1ms when you use while loop for the same code? Is while loop faster than for loop? I know that it depends on compiler and running background processes if any. Although, I wanted to know if there is any specific reason for the same."
                    }
                ]
            }
        ]
    }
]