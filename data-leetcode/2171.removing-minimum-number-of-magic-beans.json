[
    {
        "title": "Removing Minimum Number of Magic Beans",
        "question_content": "You are given an array of positive integers beans, where each integer represents the number of magic beans found in a particular magic bag.\nRemove any number of beans (possibly none) from each bag such that the number of beans in each remaining non-empty bag (still containing at least one bean) is equal. Once a bean has been removed from a bag, you are not allowed to return it to any of the bags.\nReturn the minimum number of magic beans that you have to remove.\n&nbsp;\nExample 1:\n\nInput: beans = [4,1,6,5]\nOutput: 4\nExplanation: \n- We remove 1 bean from the bag with only 1 bean.\n  This results in the remaining bags: [4,0,6,5]\n- Then we remove 2 beans from the bag with 6 beans.\n  This results in the remaining bags: [4,0,4,5]\n- Then we remove 1 bean from the bag with 5 beans.\n  This results in the remaining bags: [4,0,4,4]\nWe removed a total of 1 + 2 + 1 = 4 beans to make the remaining non-empty bags have an equal number of beans.\nThere are no other solutions that remove 4 beans or fewer.\n\nExample 2:\n\nInput: beans = [2,10,3,2]\nOutput: 7\nExplanation:\n- We remove 2 beans from one of the bags with 2 beans.\n  This results in the remaining bags: [0,10,3,2]\n- Then we remove 2 beans from the other bag with 2 beans.\n  This results in the remaining bags: [0,10,3,0]\n- Then we remove 3 beans from the bag with 3 beans. \n  This results in the remaining bags: [0,10,0,0]\nWe removed a total of 2 + 2 + 3 = 7 beans to make the remaining non-empty bags have an equal number of beans.\nThere are no other solutions that removes 7 beans or fewer.\n\n&nbsp;\nConstraints:\n\n\t1 <= beans.length <= 105\n\t1 <= beans[i] <= 105",
        "solutions": [
            {
                "id": 1766764,
                "title": "c-java-python3-sorting-4-lines",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Sorting\\n\\nSort the original array `A`.\\n\\nIf we select `A[i]` as the number of beans in a non-empty bag, the number of removals needed is `sum(A) - (N - i) * A[i]`.\\n\\n**Meaning of equation**\\n\\nFor all `A[j] (j < i)`, they are completely removed, contributing `A[0] + .. + A[i-1]` removals.\\n\\nFor all `A[j] (j >= i)`, they become all `A[i]`s, contributing `A[i] + .. + A[N-1] - (N-i) * A[i]` removals.\\n\\nSumming these two up, we get `sum(A) - (N - i) * A[i]`.\\n\\nAnother way to think this is to remove every thing and recover `(N - i) * A[i]` beans that shouldn\\'t be removed.\\n\\n**Why we should pick the number from `A`?**\\n\\nAssume `A  = [1,5,10]`. If we pick a number that is not in `A`, say `3`, `A` becomes `[0,3,3]`. This is definitely not better than picking `A[i] = 5` resulting in `[0,5,5]`. So, a solution picking a non-existent number is always dominated by another solution picking an existing number.\\n\\n**Example:**\\n\\n`A = [1,4,5,6]`, `sum(A) = 16`\\n\\n* If we pick `A[0] = 1`, the result array is `[1,1,1,1]`, # of removals is `16 - (4 - 0) * 1 = 12`.\\n* If we pick `A[1] = 4`, the result array is `[0,4,4,4]`, # of removals is `16 - (4 - 1) * 4 = 4`.\\n* If we pick `A[2] = 5`, the result array is `[0,0,5,5]`, # of removals is `16 - (4 - 2) * 5 = 6`.\\n* If we pick `A[3] = 6`, the result array is `[0,0,0,6]`, # of removals is `16 - (4 - 3) * 6 = 10`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-280/problems/removing-minimum-number-of-magic-beans/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& A) {\\n        long N = A.size(), ans = LLONG_MAX, sum = accumulate(begin(A), end(A), 0L);\\n        sort(begin(A), end(A));\\n        for (int i = 0; i < N; ++i) ans = min(ans, sum - (N - i) * A[i]);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public long minimumRemoval(int[] A) {\\n        long N = A.length, ans = Long.MAX_VALUE, sum = 0;\\n        for (int n : A) sum += n;\\n        Arrays.sort(A);\\n        for (int i = 0; i < N; ++i) ans = Math.min(ans, sum - (N - i) * A[i]);\\n        return ans;\\n    }\\n}\\n```\\n\\n**Python3**\\n```python\\nclass Solution:\\n    def minimumRemoval(self, A: List[int]) -> int:\\n        return sum(A) - max((len(A) - i) * n for i, n in enumerate(sorted(A)))\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-280/problems/removing-minimum-number-of-magic-beans/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& A) {\\n        long N = A.size(), ans = LLONG_MAX, sum = accumulate(begin(A), end(A), 0L);\\n        sort(begin(A), end(A));\\n        for (int i = 0; i < N; ++i) ans = min(ans, sum - (N - i) * A[i]);\\n        return ans;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public long minimumRemoval(int[] A) {\\n        long N = A.length, ans = Long.MAX_VALUE, sum = 0;\\n        for (int n : A) sum += n;\\n        Arrays.sort(A);\\n        for (int i = 0; i < N; ++i) ans = Math.min(ans, sum - (N - i) * A[i]);\\n        return ans;\\n    }\\n}\\n```\n```python\\nclass Solution:\\n    def minimumRemoval(self, A: List[int]) -> int:\\n        return sum(A) - max((len(A) - i) * n for i, n in enumerate(sorted(A)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766868,
                "title": "simple-java-solution-using-sort",
                "content": "nums = a, b, c, d ( a < b < c < d )\\nif make nums [a, a, a, a] remove beans (b - a) + (c - a) + (d - a) == b + c + d - 3a\\nif make nums [0, b, b, b] remove beans a + (c - b) + (d - b) == a + c + d - 2b\\nif make nums [0, 0, c, c] remove beans a + b + (d - c) == a + b + d - c\\nif make nums [0, 0, 0, d] remove beans a + b + c\\n\\nb + c + d - 3a == (a + b + c + d) - 4a\\na + c + d - 2b == (a + b + c + d) - 3b\\na + b + d -c == (a + b + c + d) - 2c\\na + b + c == (a + b + c + d) - d\\n\\n```\\n\\tpublic long minimumRemoval(int[] beans) {\\n        Arrays.sort(beans);\\n        long sum = 0;\\n        for (int bean : beans) {\\n            sum += bean;\\n        }\\n        long result = Long.MAX_VALUE;\\n        long m = beans.length;\\n        for (int i = 0; i < beans.length; i++, m--) {\\n            result = Math.min(result, sum - m * beans[i]);\\n        }\\n        return result;\\n    }\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n\\tpublic long minimumRemoval(int[] beans) {\\n        Arrays.sort(beans);\\n        long sum = 0;\\n        for (int bean : beans) {\\n            sum += bean;\\n        }\\n        long result = Long.MAX_VALUE;\\n        long m = beans.length;\\n        for (int i = 0; i < beans.length; i++, m--) {\\n            result = Math.min(result, sum - m * beans[i]);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1766795,
                "title": "java-python-3-sort-then-1-pass-find-max-rectangle-w-graph-explanation-and-analysis",
                "content": "**Intuition**\\nThe problem asks us to get the minimum beans by removing part or all from any individual bean bag(s), in order to make remaining bean bags homogeneous in terms of the number of beans. \\n\\nTherefore, we can sort input first, then remove smallest bags by whole and largest bags by part, in order to get the biggest rectangle. After computing the area of biggest rectangle, we can subtract it from the total number of beans to get the required minimum beans.\\n\\n----\\n\\nAfter sorting the input, what we need is to find the largest rectangle from the histogram formed by the `beans`. Please refer to different rectangles (not show all of them, just several ones for illustration purpose) in the 2nd picture.\\n![image](https://assets.leetcode.com/users/images/ed47e750-e72c-4c5c-bdfd-f077a0fe98a7_1644777924.0936713.png)\\n\\n![image](https://assets.leetcode.com/users/images/ee5d4124-b703-4c10-b6bc-43fb8a4030ea_1644771925.9303663.png)\\n\\n\\n**Java**\\n\\n```java\\n    public long minimumRemoval(int[] beans) {\\n        long mx = 0, sum = 0;\\n        Arrays.sort(beans)\\n        for (int i = 0, n = beans.length; i < n; ++i) {\\n            sum += beans[i];\\n            mx = Math.max(mx, (long)beans[i] * (n - i));\\n        }\\n        return sum - mx;\\n    }\\n```\\nAnother style of Java code:\\n```java\\n    public long minimumRemoval(int[] beans) {\\n        long mx = 0, sum = 0, i = 0;\\n        Arrays.sort(beans);\\n        for (int bean : beans) {\\n            sum += bean;\\n            mx = Math.max(mx, bean * (beans.length - i++));\\n        }\\n        return sum - mx;\\n    }\\n```\\n\\n----\\n\\n**Python 3**\\n```python\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        mx, n = 0, len(beans)\\n        for i, bean in enumerate(sorted(beans)):\\n            mx = max(mx, bean * (n - i))\\n        return sum(beans) - mx\\n```\\n\\n**Analysis:**\\n\\nTime: `O(nlogn)`, space: `O(n)` - including sorting space.\\n\\n----\\n\\n**Q & A**\\n*Q1:* Why we have to find the \"largest rectangle\" from the histogram?\\n*A1:* We are required to remove minimum # of beans to make the remaining bags having same #, and those remaining bags can form a \"rectangle\". There are `n` options to form rectangles, which one should we choose? The largest one, which need to remove only minimum # of beans.\\n\\n*Q2*: Which categories or tags does such a problem come from? Greedy or Math?\\n*A2*: The purpose of sorting is to remove the whole of smallest bags and remove part of biggest bags. Hence the part of the sorting can be regarded as **Greedy**; The computing and finding the largest rectangle part can be regarded as **Math**.\\n\\n*Q3*: Is [453. Minimum Moves to Equal Array Elements](https://leetcode.com/problems/minimum-moves-to-equal-array-elements) similar to this problem?\\n*A3*: It is a bit similar.\\n\\n1. For 453, after a brain teaser we only need to compute the area of the shortest (or lowest) and widest rectangle of dimension `min(nums) * n`;\\n2. For this problem, we need to go one step further: compute the areas of all possible rectangles, `beans[i] * (number of beans[k] >= beans[i])`, where `n = beans.length, 0 <= i, k < n`, then find the max area out of them.\\n\\n**End of Q**",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long minimumRemoval(int[] beans) {\\n        long mx = 0, sum = 0;\\n        Arrays.sort(beans)\\n        for (int i = 0, n = beans.length; i < n; ++i) {\\n            sum += beans[i];\\n            mx = Math.max(mx, (long)beans[i] * (n - i));\\n        }\\n        return sum - mx;\\n    }\\n```\n```java\\n    public long minimumRemoval(int[] beans) {\\n        long mx = 0, sum = 0, i = 0;\\n        Arrays.sort(beans);\\n        for (int bean : beans) {\\n            sum += bean;\\n            mx = Math.max(mx, bean * (beans.length - i++));\\n        }\\n        return sum - mx;\\n    }\\n```\n```python\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        mx, n = 0, len(beans)\\n        for i, bean in enumerate(sorted(beans)):\\n            mx = max(mx, bean * (n - i))\\n        return sum(beans) - mx\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1767034,
                "title": "count-remaining-beans",
                "content": "**Intuition:** how many beans are left after the removal? \\n\\nIf we have `beans[i]` remaining in each bag, there are `beans[i] * count(beans[j] >= beans[i])` total beans left. The rest of the beans needs to be removed.\\n\\nTo make this calculation efficient, we can just sort the input array. This is an example for ` [4,1,6,5]` (total number of beans is 16):\\n\\n![image](https://assets.leetcode.com/users/images/1ec4839a-7d57-4e75-b4c4-d18e8ce3667d_1644726560.8990245.png)\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        return sum(beans) - max(b * (i + 1) for i, b in enumerate(sorted(beans, reverse=True)))\\n```\\n\\n**C++**\\n```cpp\\nlong long minimumRemoval(vector<int>& b) {\\n    sort(begin(b), end(b));\\n    long long remaining = 0, sz = b.size();\\n    for (int i = 0; i < sz; ++i)\\n        remaining = max(remaining, b[i] * (sz - i));\\n    return accumulate(begin(b), end(b), 0LL) - remaining;\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        return sum(beans) - max(b * (i + 1) for i, b in enumerate(sorted(beans, reverse=True)))\\n```\n```cpp\\nlong long minimumRemoval(vector<int>& b) {\\n    sort(begin(b), end(b));\\n    long long remaining = 0, sz = b.size();\\n    for (int i = 0; i < sz; ++i)\\n        remaining = max(remaining, b[i] * (sz - i));\\n    return accumulate(begin(b), end(b), 0LL) - remaining;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766742,
                "title": "eight-languages-eight-1-liners-o-nlogn",
                "content": "* Only the last `N - i` indexes contribute to the answer with a value of `beans[i]` after sorting the beans array, rest of the beans are removed\\n* We have to maximize `(N - i) * beans[i]`, these are the beans that we will be keeping\\n* Formula for removed beans: `Total beans - max((N - i) * beans[i])`\\n* Return the total removed beans\\n<iframe src=\"https://leetcode.com/playground/ZjCoYVxv/shared\" frameBorder=\"0\" width=\"930\" height=\"100\"></iframe>\\n\\nThese are some of the 1 liners I was able to come up with. Feel free to add your own in the comments :)\\n",
                "solutionTags": [],
                "code": "* Only the last `N - i` indexes contribute to the answer with a value of `beans[i]` after sorting the beans array, rest of the beans are removed\\n* We have to maximize `(N - i) * beans[i]`, these are the beans that we will be keeping\\n* Formula for removed beans: `Total beans - max((N - i) * beans[i])`\\n* Return the total removed beans\\n<iframe src=\"https://leetcode.com/playground/ZjCoYVxv/shared\" frameBorder=\"0\" width=\"930\" height=\"100\"></iframe>\\n\\nThese are some of the 1 liners I was able to come up with. Feel free to add your own in the comments :)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1766752,
                "title": "c-easy-sorting-o-1-space",
                "content": "Approach would be to calculate total amount of Beans and sort bags in **descending order**\\nLoop from 0 to n-1, at each index do , If I make **all the values equal to current Bean** then-\\n1) How many Beans I saved which is **savedBeans=(a[i]*(i+1))**\\n2) How many Beans I have to remove which is **removedBeans= totalBeans - savedBeans;**\\n3) Take **minimum from all the possible removedBeans**.\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& a)\\n\\t{\\n        sort(a.begin(),a.end());\\n        reverse(a.begin(),a.end());\\n        long long mini = 99999999999999;\\n        long long totalBeans =0;\\n        for(auto bean : a)\\n        {\\n            totalBeans += (1LL)*bean;\\n        }\\n        long long n = 1LL*(int(a.size()));\\n        for(long long i=0;i<n;i++)\\n        {\\n            long long savedBeans = (1LL*a[i])*(1LL*(i+1));\\n            long long removedBeans = totalBeans - savedBeans;\\n            mini = min(mini , removedBeans);\\n        }\\n        return mini;\\n    }\\n};\\n```\\nNote : I changed all the values to long long otherwise it will throw runtime error , always remember if you think answer / calculation is out of range of INT then change it to long long by multiplying with **1LL**. (Due to this I got 1 penalty)",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& a)\\n\\t{\\n        sort(a.begin(),a.end());\\n        reverse(a.begin(),a.end());\\n        long long mini = 99999999999999;\\n        long long totalBeans =0;\\n        for(auto bean : a)\\n        {\\n            totalBeans += (1LL)*bean;\\n        }\\n        long long n = 1LL*(int(a.size()));\\n        for(long long i=0;i<n;i++)\\n        {\\n            long long savedBeans = (1LL*a[i])*(1LL*(i+1));\\n            long long removedBeans = totalBeans - savedBeans;\\n            mini = min(mini , removedBeans);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766998,
                "title": "python-clear-and-concise-explanation",
                "content": "If you want to make all the numbers the same inside an array (only decreasing is allowed)\\nyou need to make `sum(arr) - len(arr) * min(arr)` operations overall as you need to decrease all elements by `arr[i] - min(arr)` where `0<=i<len(arr)`\\n\\nAs described in problem statement we can decrease number of beans in the bag and when it becomes `0` we dont need to make all other bags `0` to make them equal (We just ignore `0` bags, which simply means length of array also decreases).\\n\\n\\nApproach:\\n-\\n- Sort beans\\n- Calculate number of operations for every element in beans\\n\\n```\\ndef minimumRemoval(self, beans: List[int]) -> int:\\n\\tbeans.sort()\\n\\ts = sum(beans)\\n\\tl = len(beans)\\n\\tres = float(\\'inf\\')\\n\\n\\tfor i in range(len(beans)):\\n\\t\\tres = min(res, s - l * beans[i])\\n\\t\\tl -= 1\\n\\t\\t\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef minimumRemoval(self, beans: List[int]) -> int:\\n\\tbeans.sort()\\n\\ts = sum(beans)\\n\\tl = len(beans)\\n\\tres = float(\\'inf\\')\\n\\n\\tfor i in range(len(beans)):\\n\\t\\tres = min(res, s - l * beans[i])\\n\\t\\tl -= 1\\n\\t\\t\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1768161,
                "title": "c-simple-solution-explained-by-colorful-picture",
                "content": "\\n# Observation\\nAfter we sorted the nums [4,1,6,5] into\\n[1,4,5,6] \\nthe following blue area is the  area of [1,4,5,6]. that\\'s mean summation of nums.\\n![image](https://assets.leetcode.com/users/images/017bdb74-68b1-4330-9bd1-e20f70abb5ce_1644756869.433025.png)\\n\\nAnd what we want is find the value i=c such that red area will be the smallest\\n![image](https://assets.leetcode.com/users/images/16679400-8fb9-4ee2-a17b-8426dffc94ed_1644756947.4843166.png)\\n\\nIn this example, \\n[0,4,4,4] would be the green area to make the red area become smallest\\n![image](https://assets.leetcode.com/users/images/d7f1bfc7-eab3-41ef-9dd7-45273f03dacb_1644757044.6250587.png)\\n\\nThere are n number of possibilities of green area. \\nAnd we know blue area - green area  = red area. \\nWe want to find the smallest red area from the n possibility of green area.\\n\\n\\n\\n# Solution \\n```C++\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n\\t    //I use nums here to match above picture. \\n\\t\\tvector<int> num& = beans;\\n        int n = nums.size(); \\n        sort(nums.begin(), nums.end());\\n        long long sum = accumulate(nums.begin(), nums.end(), (long long)0); \\n\\t\\t//sum is blue area\\n        long long mini = LONG_LONG_MAX;\\n        for(long long i = 0 ; i < n; i++) {\\n            mini = min(mini, sum - nums[i]*(n-i));\\n\\t\\t\\t//nums[i]*(n-i) is green area\\n\\t\\t\\t//mini is red area\\n\\t\\t}\\n\\t\\t\\n        return mini; //Here, mini would be the smallest red area\\n    }\\n};\\n```\\n\\nBy the way, \\n```C++\\naccumulate(nums.begin(), nums.end(), (long long)0);\\n```\\nbeans is int vector  but using (long long) for 0 can enforce compiler to using long long template version of accumulate. \\nYou need to use it to avoid overflow for some large test-case.",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n\\t    //I use nums here to match above picture. \\n\\t\\tvector<int> num& = beans;\\n        int n = nums.size(); \\n        sort(nums.begin(), nums.end());\\n        long long sum = accumulate(nums.begin(), nums.end(), (long long)0); \\n\\t\\t//sum is blue area\\n        long long mini = LONG_LONG_MAX;\\n        for(long long i = 0 ; i < n; i++) {\\n            mini = min(mini, sum - nums[i]*(n-i));\\n\\t\\t\\t//nums[i]*(n-i) is green area\\n\\t\\t\\t//mini is red area\\n\\t\\t}\\n\\t\\t\\n        return mini; //Here, mini would be the smallest red area\\n    }\\n};\\n```\n```C++\\naccumulate(nums.begin(), nums.end(), (long long)0);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766910,
                "title": "c-time-o-nlogn-space-o-n-o-1",
                "content": "**I.** **Time: O(NLogN) || Space: O(N)**\\n\\n\\n**Intuition:**\\nTo calculate the minimum number of operations for a particular index such as **i** (in the sorted array),\\nwe need to make all the entries before it as **0** (as all the entries in this range are smaller than **v[i]**, so we can\\'t increase the beans, hence we have to make all of them **zero**) and all the entries from index **i** to the end of the array equal to **v[i]** (by `sumOfElementsInRange  -  numberOfElementsInRange * v[i]`)\\n\\n**Steps:** \\n1. Sort the array.\\n2. Calculate prefix and suffix sums.\\n3. Iterate over the array, and consider each v[i] as the resulting same number.\\n\\n\\n```\\n    long long minimumRemoval(vector<int>& v) \\n    {\\n        int n = v.size();\\n        sort(v.begin(), v.end());\\n        if(n == 1) return 0;    \\n\\t\\t\\n\\t\\t// Calculating prefix and suffix sums\\n        vector<long long> pref(n, 0), suf(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i == 0) \\n                pref[i] = v[i];\\n            else \\n                pref[i] = pref[i-1] + v[i];\\n        }\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            if(i == n-1) \\n                suf[i] = v[i];\\n            else \\n                suf[i] = suf[i+1] + v[i];\\n        }\\n       \\n\\t\\tlong long res = 1e13;\\n       \\n\\t\\t// Required calculation for minimum number of operations\\n\\t\\tfor(int i = 0; i < n; i++)\\n        {\\n            long long prevSum = ((i == 0) ? 0 : pref[i-1]);\\n            long long aheadSum = suf[i];\\n            long long temp = prevSum + aheadSum - (long long)(n-i)*(long long)v[i];\\n            res = min(res, temp);\\n        }\\n        return res;\\n    }\\n```\\n\\n**II. Time: O(NLogN) || Space: O(1): Optimising to constant space:**\\nIn the above approach, we are using prefix and suffix sums for finding the **sums** for subarrays `v[0] -> v[i-1]` and `v[i] -> v[n-1]`, where `n = v.size()`.\\nBut, we could also do this in constant space using the **left sum** and **right sum**.\\n\\n```\\n    long long minimumRemoval(vector<int>& v) \\n    {\\n        int n = v.size();\\n        sort(v.begin(), v.end());\\n        \\n\\t\\t//rightSum = total sum of elements, leftSum = 0 at start\\n\\t\\tlong long rightSum = accumulate(v.begin(), v.end(), 0LL), leftSum = 0, res = 1e13;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n\\t\\t\\t// leftSum for making the preceding elements to zero\\n\\t\\t\\t// rightSum - (n-i)*(v[i]) for making the succeeding elements equal to v[i]\\n\\t\\t\\t// In short we could also use total sum instead of leftSum and rightSum.\\n\\t\\t\\t\\n            long long temp = leftSum + rightSum - (n-i)*(long long)v[i];\\n            res = min(res, temp);\\n            leftSum += v[i];\\n            rightSum -= v[i];\\n        }\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\n    long long minimumRemoval(vector<int>& v) \\n    {\\n        int n = v.size();\\n        sort(v.begin(), v.end());\\n        if(n == 1) return 0;    \\n\\t\\t\\n\\t\\t// Calculating prefix and suffix sums\\n        vector<long long> pref(n, 0), suf(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i == 0) \\n                pref[i] = v[i];\\n            else \\n                pref[i] = pref[i-1] + v[i];\\n        }\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            if(i == n-1) \\n                suf[i] = v[i];\\n            else \\n                suf[i] = suf[i+1] + v[i];\\n        }\\n       \\n\\t\\tlong long res = 1e13;\\n       \\n\\t\\t// Required calculation for minimum number of operations\\n\\t\\tfor(int i = 0; i < n; i++)\\n        {\\n            long long prevSum = ((i == 0) ? 0 : pref[i-1]);\\n            long long aheadSum = suf[i];\\n            long long temp = prevSum + aheadSum - (long long)(n-i)*(long long)v[i];\\n            res = min(res, temp);\\n        }\\n        return res;\\n    }\\n```\n```\\n    long long minimumRemoval(vector<int>& v) \\n    {\\n        int n = v.size();\\n        sort(v.begin(), v.end());\\n        \\n\\t\\t//rightSum = total sum of elements, leftSum = 0 at start\\n\\t\\tlong long rightSum = accumulate(v.begin(), v.end(), 0LL), leftSum = 0, res = 1e13;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n\\t\\t\\t// leftSum for making the preceding elements to zero\\n\\t\\t\\t// rightSum - (n-i)*(v[i]) for making the succeeding elements equal to v[i]\\n\\t\\t\\t// In short we could also use total sum instead of leftSum and rightSum.\\n\\t\\t\\t\\n            long long temp = leftSum + rightSum - (n-i)*(long long)v[i];\\n            res = min(res, temp);\\n            leftSum += v[i];\\n            rightSum -= v[i];\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1768762,
                "title": "python-visual-explain-for-beginners-o-nlogn-100-beat",
                "content": "**Thought Process:**\\nAt any given point of number, for number less than current number should be => 0. For number greater than current number should be current number. So **sorting will make easier** so that at any given point, number less than current will be on left-side, and number greater than current will be on right-side\\n\\nSo with more detailed explains under the drawing, I came up with the equation\\n**prevSum + [ totalSum - prevSum - [ (arrLen - currIdx) * currNum ] ]**\\nWhich simplifies to **totalSum - [ (arrLen - currIdx) * currNum ]**\\nAnd we want the minimum results of the calculation for every position\\n\\nNote: Duplicated number doesn\\'t affect the result as we already have calculated minimum value at first visit for the number\\n\\n![image](https://assets.leetcode.com/users/images/9035c7a9-aa43-497c-a6a5-929a7549121d_1644774445.7645504.png)\\n\\nprevSum => beans on the left => meaning beans we want to remove\\n\\ntotalSum - prevSum => sum of number on the right side include itself\\n20 - 1 = 19\\n\\n(arrLen - currIdx) * currNum => the number of integers on the right side include itself multiplied by current number => meaning that the **number of beans we want to keep**\\n(5 - 1) * 4 = 16\\n\\nso the first equation ...\\nprevSum + [ totalSum - prevSum - [ (arrLen - currIdx) * currNum ] ]\\n**# of every beans on leftside(to be removed)  + # of every beans on the right side - # of beans we want to keep**\\n\\nThis simplifies to ...\\n**totalSum - [ (arrLen - currIdx) * currNum ]** which is just\\n      20       - [ (     5     -     1     )   *         4       ] = 4\\n\\t  \\n**Steps:**\\n1. find totalSum, length\\n2. sort the beans array\\n3. iterate over every position and keep the minimum value from the equation\\n\\n**TimeComplexity** - O(nlogn) sorting,  O(n) for sum(beans), O(n) for iteration =>**O(nlogn)**\\n**SpaceComplexity** - O(1)\\n\\n\\n```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        totalSum = sum(beans)\\n        beanLen = len(beans)\\n        beans.sort()\\n        minRm = float(\\'inf\\')\\n        for i, bean in enumerate(beans):\\n            minRm = min(minRm, totalSum - (beanLen - i) * bean)\\n        return minRm\\n```\\n\\nPlease correct me if I am wrong !\\nPlease **UPVOTE** if you find this solution helpful !\\nHappy algo!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        totalSum = sum(beans)\\n        beanLen = len(beans)\\n        beans.sort()\\n        minRm = float(\\'inf\\')\\n        for i, bean in enumerate(beans):\\n            minRm = min(minRm, totalSum - (beanLen - i) * bean)\\n        return minRm\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766980,
                "title": "simple-using-prefix-sum-explanation-using-diagram",
                "content": "Using **Prefix sum**\\n\\nStep 1 : Sort the array\\nStep 2: Find cumulative sum till each position in array\\nStep 3: Using the below formula remove all the elements  calculate the number of beans needed to be removed \\nafter certain value say X.\\n temp = (cs[n] - cs[j+1]) - ((long long)beans[i]*(n-(j+1)));\\n\\nStep 4 : Reduce the number of bins to 0 for number less than X\\n\\nRefer figure below\\n![image](https://assets.leetcode.com/users/images/8ab1a97f-d4f9-492e-8113-276ea03b88ac_1644745631.0193708.png)\\n\\n\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        \\n        sort(beans.begin(),beans.end());\\n        int n =beans.size();\\n        long long sum=0;\\n        long long temp;\\n        long long ans ;\\n        \\n        vector<long long > cs;\\n        cs.push_back(0);\\n        for(auto i:beans)\\n        {\\n            sum = (long long)sum+(long long)i;\\n            cs.push_back(sum);\\n        }\\n        int j;\\n        ans = cs[n];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(j=i+1;j<n;j++)\\n            {\\n                if(beans[i] != beans[j])\\n                    break;\\n            }\\n            j--;\\n            \\n            temp = (long long)(cs[n] - cs[j+1]) - (long long)((long long)beans[i]*(long long)(n-(j+1)));\\n            \\n            \\n            ans = min(ans, (long long)(temp+cs[i]));\\n            \\n            i=j;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        \\n        sort(beans.begin(),beans.end());\\n        int n =beans.size();\\n        long long sum=0;\\n        long long temp;\\n        long long ans ;\\n        \\n        vector<long long > cs;\\n        cs.push_back(0);\\n        for(auto i:beans)\\n        {\\n            sum = (long long)sum+(long long)i;\\n            cs.push_back(sum);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1770303,
                "title": "c-simple-greedy-solution-one-pass-fully-explained",
                "content": "This might have troubled a lot of you in the weekly contest 280 of Leetcode. As a rule of thumb, I learnt that if a function returns long long integer, you can avoid a lot of runtime errors by declaring all int variables as long long int in your code!\\nNow, coming to the logic, you just need to follow your guts - go greedy. Sort the array, because you will start by removing the least amount possible. Now, since we can\\'t add beans to any bag, the lower bound of this bag would be the amount of beans that all bags are going to end up with. How many beans does that remove? This can be done with a simple calculation:\\nIf the number of beans (ith bag) is going to be the baseline amount of beans in all the remaining bags, we need to remove all the bags before ith index, and (sizeof(beans) - i)* beans[i] from the total amount of beans across all bags. \\nIf it wasn\\'t clear, think in this way - remaining number of bags are sizeof(beans)-i, and each of them are going to have beans[i] which is our decided baseline amount. Remove the rest beans from all the bags. \\nNow, if you pass over the sorted array keeping track of the minimum number of removed beans, you will arrive at your answer. Even though the algorithm is single pass, the time complexity is bounded by O(nlogn) due to sorting, where n is the size of beans array.\\nUntil next time, cheers! (Do leave a comment if something remains unclear)\\n\\nHere\\'s the code for the same, in c++:\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(), beans.end());\\n        long long sum = 0;\\n        for(auto b : beans) sum += b; // total number of beans\\n        \\n        long long minrem = LLONG_MAX; //maximum possible value in long long\\n        for(int i = 0; i < beans.size(); i++)\\n        {\\n            long long temp = sum;\\n            temp -= (beans.size() - i)*beans[i];\\n            if(minrem > temp) minrem = temp;\\n        }\\n        return minrem;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(), beans.end());\\n        long long sum = 0;\\n        for(auto b : beans) sum += b; // total number of beans\\n        \\n        long long minrem = LLONG_MAX; //maximum possible value in long long\\n        for(int i = 0; i < beans.size(); i++)\\n        {\\n            long long temp = sum;\\n            temp -= (beans.size() - i)*beans[i];\\n            if(minrem > temp) minrem = temp;\\n        }\\n        return minrem;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766749,
                "title": "java-sorting-simple-explanation",
                "content": "**Explanation:**\\nConsider [4, 1, 6, 5], after sorting it becomes [1, 4, 5, 6] and total would be 16.\\nIf we want to make all elements equal to x  => make all elements less than x to zero(sum of smaller elements) + make larger elements equal to x(sum of larger elements - number of larger elements * x)\\n\\nLet x be 5, so if we want to make all elements equal to 5\\n=> 1 + 4 + (6 - 1 * 5) = 6\\n\\nSimilarly if x is 4 => 1 + (11 - 2  * 4) = 4.\\n\\n**Solution:**\\n\\n```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n        long total = 0;\\n        for (int num: beans) {\\n            total += num;\\n        }\\n        \\n        \\n        long sumSoFar = 0, output = Long.MAX_VALUE;\\n        Arrays.sort(beans);\\n        for (int i = 0; i < beans.length; ++ i) {\\n            long current = sumSoFar;\\n            while (i + 1 < beans.length && beans[i] == beans[i + 1]) {\\n                sumSoFar += beans[i];\\n                ++ i;\\n            }\\n            sumSoFar += beans[i];\\n            current += total - sumSoFar - (long)(beans.length - i - 1) * beans[i];\\n            \\n            output = Math.min(current, output);\\n        }\\n        \\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n        long total = 0;\\n        for (int num: beans) {\\n            total += num;\\n        }\\n        \\n        \\n        long sumSoFar = 0, output = Long.MAX_VALUE;\\n        Arrays.sort(beans);\\n        for (int i = 0; i < beans.length; ++ i) {\\n            long current = sumSoFar;\\n            while (i + 1 < beans.length && beans[i] == beans[i + 1]) {\\n                sumSoFar += beans[i];\\n                ++ i;\\n            }\\n            sumSoFar += beans[i];\\n            current += total - sumSoFar - (long)(beans.length - i - 1) * beans[i];\\n            \\n            output = Math.min(current, output);\\n        }\\n        \\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770322,
                "title": "c-sorting-10-lines-greedy",
                "content": "```\\nlong long minimumRemoval(vector<int>& beans) {\\n        long long ans=1e18;\\n        int n=beans.size();\\n        sort(beans.begin(),beans.end());\\n        long long sum=accumulate(beans.begin(),beans.end(),0LL);\\n        for(int i=0;i<beans.size();i++){\\n            long long temp=sum-(long long)beans[i]*(n-i);\\n            if(temp<ans){\\n                ans=temp;\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nlong long minimumRemoval(vector<int>& beans) {\\n        long long ans=1e18;\\n        int n=beans.size();\\n        sort(beans.begin(),beans.end());\\n        long long sum=accumulate(beans.begin(),beans.end(),0LL);\\n        for(int i=0;i<beans.size();i++){\\n            long long temp=sum-(long long)beans[i]*(n-i);\\n            if(temp<ans){\\n                ans=temp;\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1768062,
                "title": "remove-minimum-number-of-magic-beans",
                "content": "**Simple Observation no need to any algorithm**\\n\\n**1 . sort the array  For an example i take the array is -[1,6,2,4]**\\nAfter sort the array looks [1,2,4,6]\\n\\nloop over all the items pick one by one and try to convert entire array as \\nselected item\\n\\n**First choose 1 convert entire array as 1 How many operation**\\nfor 1 no of operation needed\\nfor 6 no of operation is (6-1)=5\\nfor 2 no of operation is (2-1)=1\\nfor 4 no of operation is (4-1) =3\\n\\nSo the total operation is (5+1+3)\\nif you look carefully\\n\\nthe pattern (6-1)+(2-1)+(4-1) we can written -- 6+2+4 -(3times 1)\\n                                      also can be written as  --  6+2+4+1 -(4times 1) \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  ans (6+2+4+1 ) is Sum of the elements \\n\\t\\t\\t\\n\\t\\t\\t**Now the formula looks like **\\n\\t\\t\\t (sum of all the beans) - number of contribution of i\\'th element\\n\\t\\t\\t \\n\\t\\t\\t if i = 0\\n\\t\\t\\t sum - (n-i)*beans[i] {why n-i because all elements before i\\'th is smaller than beans[i]}\\n\\t\\t\\t only whatever items are present after beans[i] is considered \\n\\n\\n```\\nclass Solution {\\npublic:  \\n    long long minimumRemoval(vector<int>& beans) {\\n       long long  h = 0;\\n       sort(beans.begin() , beans.end());\\n        for(int i : beans) h+=i;\\n        long long n = beans.size();\\n        long long ans = h;\\n        for(int i = 0 ; i < beans.size() ; i++){\\n          long long curr = h-(n-i)*beans[i];\\n           if(curr < ans){\\n             ans = curr;\\n           }\\n        }    \\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:  \\n    long long minimumRemoval(vector<int>& beans) {\\n       long long  h = 0;\\n       sort(beans.begin() , beans.end());\\n        for(int i : beans) h+=i;\\n        long long n = beans.size();\\n        long long ans = h;\\n        for(int i = 0 ; i < beans.size() ; i++){\\n          long long curr = h-(n-i)*beans[i];\\n           if(curr < ans){\\n             ans = curr;\\n           }\\n        }    \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766873,
                "title": "python3-2-line",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/2506277d2af78559a0e58d2130fdbe87beab42b5) for solutions of weekly 280. \\n\\n```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        beans.sort()\\n        return sum(beans) - max((len(beans)-i)*x for i, x in enumerate(beans))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        beans.sort()\\n        return sum(beans) - max((len(beans)-i)*x for i, x in enumerate(beans))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766805,
                "title": "using-leftsum-rightsum-c",
                "content": "According to the Question we have to choose a number from the array and ***decrease all the numbers to zero  which are lower than that number*** and **decrease all the numbers  which are greater than the choosen Number such that they became equal to the given number**. We have to choose the number such that the **sum of decrement** in the array should be **minimum**.\\n\\n\\nEx:  **[4,1,5,6]**\\n\\n     If we choose 5 total decrement will be  \\n     4+1+(6-5)=6  (4 and 1 are smaller than 5 ,while 6 is greater )\\n\\t \\n     but if we choose 4 then total decrement will be \\n\\t 1+(5-4) + (6-4)= 4 \\n\\t \\n\\t which is smaller than any poosible total decrement for the given array.\\n\\t\\n\\tSo, the ans is 4.\\n\\nTo Do this calculation easily ,\\nFirst sort the array so that the smaller numbers reamin at left and larger element remain at right.\\n\\nThen we will **pre calculate the sum of values which are smaller and sum of values which are larger for each values in leftSum & rightSum array**.\\n\\nThen check for each element\\n\\n**sum of smaller values + ( sum of larger values- ((choosen value)*(no. of larger value))  )**\\n\\nthe minimum one will be our answer.\\n\\n\\t \\n\\t\\n\\t \\n\\n```\\n long long minimumRemoval(vector<int>& beans) {\\n        int n=beans.size();\\n        sort(beans.begin(),beans.end());\\n        long long rightSum[n];\\n        long long leftSum[n];\\n        leftSum[0]=0;\\n        rightSum[n-1]=0;\\n        \\n        for(int i=1;i<n;i++){\\n            leftSum[i]=beans[i-1]+leftSum[i-1];\\n        }\\n         for(int i=n-2;i>=0;i--){\\n            rightSum[i]=beans[i+1]+rightSum[i+1];\\n        }\\n        \\n        long long mi=LLONG_MAX;\\n        \\n        for(long long i=0;i<n;i++){\\n          \\n            mi=min( mi,leftSum[i] + (rightSum[i]-((long long)beans[i]*(long long)(n-i-1))) );  \\n        }\\n        \\n        return mi;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n long long minimumRemoval(vector<int>& beans) {\\n        int n=beans.size();\\n        sort(beans.begin(),beans.end());\\n        long long rightSum[n];\\n        long long leftSum[n];\\n        leftSum[0]=0;\\n        rightSum[n-1]=0;\\n        \\n        for(int i=1;i<n;i++){\\n            leftSum[i]=beans[i-1]+leftSum[i-1];\\n        }\\n         for(int i=n-2;i>=0;i--){\\n            rightSum[i]=beans[i+1]+rightSum[i+1];\\n        }\\n        \\n        long long mi=LLONG_MAX;\\n        \\n        for(long long i=0;i<n;i++){\\n          \\n            mi=min( mi,leftSum[i] + (rightSum[i]-((long long)beans[i]*(long long)(n-i-1))) );  \\n        }\\n        \\n        return mi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1766748,
                "title": "c-sort-prefix-greedy-explained",
                "content": "pre[i-1]  => all left beans\\npre[n-1]-pre[i] => all right beans\\nn-i-1 => cnt of right beans\\ncnt x bean[i]  => if all right beans => curr bean\\nall right beans - (cnt x bean[i]) => extra beans from right to be removed\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long long n = beans.size();\\n        if(n == 1)\\n            return 0;\\n        vector<long long> pre(n, 0);\\n        sort(beans.begin(), beans.end());\\n        pre[0] = 1LL*beans[0];\\n        for(int i=1; i<n; i++){\\n            pre[i] += pre[i-1]+beans[i];\\n        }\\n        long long ans = pre[n-1] - beans[0] - ((n-1)*beans[0]);\\n        for(int i=1; i<n; i++){\\n            // for evrey index, remove all left beans (=> pre[i-1]) + remove extra beans from right (bean[r]-bean[i], i<r<n) \\n            long long tmp = (long long)(pre[i-1] + (pre[n-1] - pre[i] - (beans[i]*(n-i-1)))); \\n            ans = min(ans, tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long long n = beans.size();\\n        if(n == 1)\\n            return 0;\\n        vector<long long> pre(n, 0);\\n        sort(beans.begin(), beans.end());\\n        pre[0] = 1LL*beans[0];\\n        for(int i=1; i<n; i++){\\n            pre[i] += pre[i-1]+beans[i];\\n        }\\n        long long ans = pre[n-1] - beans[0] - ((n-1)*beans[0]);\\n        for(int i=1; i<n; i++){\\n            // for evrey index, remove all left beans (=> pre[i-1]) + remove extra beans from right (bean[r]-bean[i], i<r<n) \\n            long long tmp = (long long)(pre[i-1] + (pre[n-1] - pre[i] - (beans[i]*(n-i-1)))); \\n            ans = min(ans, tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304302,
                "title": "easy-simple-math",
                "content": "```\\nclass Solution {\\n\\tpublic long minimumRemoval(int[] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tArrays.sort(arr);\\n\\t\\tlong sum = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tsum += arr[i];\\n\\t\\t}\\n\\t\\tlong res = Long.MAX_VALUE;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tres = Math.min(res, sum - ((long) arr[i] * (n - i)));\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic long minimumRemoval(int[] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tArrays.sort(arr);\\n\\t\\tlong sum = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tsum += arr[i];\\n\\t\\t}\\n\\t\\tlong res = Long.MAX_VALUE;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tres = Math.min(res, sum - ((long) arr[i] * (n - i)));\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239704,
                "title": "c-easy",
                "content": "```\\n #define anoop long long\\n    long long minimumRemoval(vector<int>& arr) {\\n        anoop ans=(anoop)INT_MAX+INT_MAX;\\n        sort(arr.begin(),arr.end());\\n        anoop n=arr.size();\\n        vector<anoop> pref(n);\\n        pref[0]=arr[0];\\n        for(anoop i=1;i<n;i++)\\n            pref[i]=pref[i-1]+arr[i];\\n     /*    4  1  6  5   arr\\n         1  4  5  6   sorted\\n         1  5  10 16   prefsum\\n            i     n-i\\n         0  1   2  3   indexes\\n         0  5   5  5  final form of our array\\n             final ans for every arr[i] will be suffix cost - prfix cost\\n                 suppose we are at index of 5 what all we have to do is \\n               to make every element 0 before 5 and to make every element 5 after 5\\n                in first task our cost will be equal to prefixCost=prefixSum till i-1\\n                and in 2nd task we will calculate suffixCost = isuffixsum-finalsuffixsum\\n                                                  suffixCost(5)=      11         -     10\\n                                                              = pref(n-1)-pref(i)-(n-i-1)*arr[i]\\n            we can do this for every index and minimise our answer\\n                                                              */\\n                                                                    \\n             \\n        for(anoop i=0;i<n;i++){\\n            anoop prefCost= i==0?0:pref[i-1];\\n            anoop isuffixsum= pref[n-1]-pref[i];\\n            anoop finalsuffixsum= i==n-1?0:(n-i-1)*arr[i];\\n            anoop suffixCost=isuffixsum-finalsuffixsum;\\n            ans=min(ans,prefCost+suffixCost);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\n #define anoop long long\\n    long long minimumRemoval(vector<int>& arr) {\\n        anoop ans=(anoop)INT_MAX+INT_MAX;\\n        sort(arr.begin(),arr.end());\\n        anoop n=arr.size();\\n        vector<anoop> pref(n);\\n        pref[0]=arr[0];\\n        for(anoop i=1;i<n;i++)\\n            pref[i]=pref[i-1]+arr[i];\\n     /*    4  1  6  5   arr\\n         1  4  5  6   sorted\\n         1  5  10 16   prefsum\\n            i     n-i\\n         0  1   2  3   indexes\\n         0  5   5  5  final form of our array\\n             final ans for every arr[i] will be suffix cost - prfix cost\\n                 suppose we are at index of 5 what all we have to do is \\n               to make every element 0 before 5 and to make every element 5 after 5\\n                in first task our cost will be equal to prefixCost=prefixSum till i-1\\n                and in 2nd task we will calculate suffixCost = isuffixsum-finalsuffixsum\\n                                                  suffixCost(5)=      11         -     10\\n                                                              = pref(n-1)-pref(i)-(n-i-1)*arr[i]\\n            we can do this for every index and minimise our answer\\n                                                              */\\n                                                                    \\n             \\n        for(anoop i=0;i<n;i++){\\n            anoop prefCost= i==0?0:pref[i-1];\\n            anoop isuffixsum= pref[n-1]-pref[i];\\n            anoop finalsuffixsum= i==n-1?0:(n-i-1)*arr[i];\\n            anoop suffixCost=isuffixsum-finalsuffixsum;\\n            ans=min(ans,prefCost+suffixCost);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1767106,
                "title": "c-easy-solution-explained",
                "content": "Use **prefix array** to calculate number of beans to remove.\\n**Number of beans required to convert the whole array to x = sum of numbers > x - (count of numbers > x * x) + sum of number < x;**\\n\\nJust **use this logic** and **find minium removals** to **convert whole array to any value** in array.\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& copy) {\\n        \\n        int n(size(copy));\\n        long long res(LLONG_MAX);\\n        sort(begin(copy), end(copy));\\n        vector<long long> beans(begin(copy), end(copy));\\n        \\n        for (int i=1; i<n; i++) \\n            beans[i] += beans[i-1];\\n        \\n        for (int i=0; i<n; i++) {\\n            long long pre = (i) ? beans[i-1] : 0;\\n            while (i+1 < n and copy[i] == copy[i+1])    i++;\\n            long long reqSum = (long long)copy[i] * (long long)(n-1-i);\\n            long long totalSum = beans.back() - beans[i];\\n            long long remove = totalSum - reqSum + pre;\\n            if (res > remove)  res = remove;\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& copy) {\\n        \\n        int n(size(copy));\\n        long long res(LLONG_MAX);\\n        sort(begin(copy), end(copy));\\n        vector<long long> beans(begin(copy), end(copy));\\n        \\n        for (int i=1; i<n; i++) \\n            beans[i] += beans[i-1];\\n        \\n        for (int i=0; i<n; i++) {\\n            long long pre = (i) ? beans[i-1] : 0;\\n            while (i+1 < n and copy[i] == copy[i+1])    i++;\\n            long long reqSum = (long long)copy[i] * (long long)(n-1-i);\\n            long long totalSum = beans.back() - beans[i];\\n            long long remove = totalSum - reqSum + pre;\\n            if (res > remove)  res = remove;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767102,
                "title": "why-my-binary-search-approach-is-failing",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int ans=1e6;\\n    bool check(int tar,vector<int>arr)\\n    {\\n        int cnt=0;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(tar>arr[i])//if my tar is greater than arr[i] then add arr[i] to cnt because in that case i will make that arr[i] to 0\\n                cnt+=arr[i];\\n            else if(tar<arr[i])/* if my tar is less than arr[i] then add the remaining number to cnt. because my target is to make that arr[i] equal to tar*/\\n            {\\n                int k=arr[i]-tar;\\n                cnt+=k;\\n            }\\n//if my tar and arr[i] is equal then skip it\\n        }\\n        bool f=true;\\n        if(ans<cnt)f=false;\\n        if(ans>cnt)\\n         ans=tar;\\n        return f;\\n    }\\n    \\n    long long minimumRemoval(vector<int>& beans) {\\n        int n=beans.size();\\n        if(n==0||n==1)return 0;\\n        int h=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            h+=beans[i];\\n        }\\n       \\n        int l=0,r=1e5;\\n        while(l<r)\\n        {\\n            int mid=(l+r)/2;//taking the possible answer in my mid\\n            if(check(mid,beans))/*checking if my mid is smaller than ans (ans is defined globally) if it is smaller than the ans then update ans in the check function and return true*/ \\n            {\\n                r=mid;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int ans=1e6;\\n    bool check(int tar,vector<int>arr)\\n    {\\n        int cnt=0;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(tar>arr[i])//if my tar is greater than arr[i] then add arr[i] to cnt because in that case i will make that arr[i] to 0\\n                cnt+=arr[i];\\n            else if(tar<arr[i])/* if my tar is less than arr[i] then add the remaining number to cnt. because my target is to make that arr[i] equal to tar*/\\n            {\\n                int k=arr[i]-tar;\\n                cnt+=k;\\n            }\\n//if my tar and arr[i] is equal then skip it\\n        }\\n        bool f=true;\\n        if(ans<cnt)f=false;\\n        if(ans>cnt)\\n         ans=tar;\\n        return f;\\n    }\\n    \\n    long long minimumRemoval(vector<int>& beans) {\\n        int n=beans.size();\\n        if(n==0||n==1)return 0;\\n        int h=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            h+=beans[i];\\n        }\\n       \\n        int l=0,r=1e5;\\n        while(l<r)\\n        {\\n            int mid=(l+r)/2;//taking the possible answer in my mid\\n            if(check(mid,beans))/*checking if my mid is smaller than ans (ans is defined globally) if it is smaller than the ans then update ans in the check function and return true*/ \\n            {\\n                r=mid;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767009,
                "title": "javascript-easy-sorting-o-1-space",
                "content": "Sort the original array A.\\n\\nIf we select A[i] as the number of beans in a non-empty bag, all elements before it will be zero (A[0] + .. + A[i-1] = 0) and the number of removals needed is (original sum - new sum) i.e sum(A) - (N - i) * A[i].\\n\\nExample:\\n\\nA = [1,4,5,6], sum(A) = 16\\n\\nIf we pick A[0] = 1, the result array is [1,1,1,1], # of removals is 16 - (4 - 0) * 1 = 12.\\nIf we pick A[1] = 4, the result array is [0,4,4,4], # of removals is 16 - (4 - 1) * 4 = 4.\\nIf we pick A[2] = 5, the result array is [0,0,5,5], # of removals is 16 - (4 - 2) * 5 = 6.\\nIf we pick A[3] = 6, the result array is [0,0,0,6], # of removals is 16 - (4 - 3) * 6 = 10.\\n```\\n/**\\n * @param {number[]} beans\\n * @return {number}\\n */\\nvar minimumRemoval = function(beans) {\\n    const N = beans.length;\\n    const sum = beans.reduce((acc, c) => c + acc, 0);\\n\\n    beans.sort((a,b) => a - b);\\n\\n    let ans = Infinity;\\n    for(let i = 0 ; i < beans.length; i++) {\\n        ans = Math.min(ans, sum - (N - i) * beans[i])\\n    }\\n\\n    return ans;\\n};\\n// TC: O(NlogN) for sorting\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[]} beans\\n * @return {number}\\n */\\nvar minimumRemoval = function(beans) {\\n    const N = beans.length;\\n    const sum = beans.reduce((acc, c) => c + acc, 0);\\n\\n    beans.sort((a,b) => a - b);\\n\\n    let ans = Infinity;\\n    for(let i = 0 ; i < beans.length; i++) {\\n        ans = Math.min(ans, sum - (N - i) * beans[i])\\n    }\\n\\n    return ans;\\n};\\n// TC: O(NlogN) for sorting\\n// SC: O(1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1766949,
                "title": "simple-java-solution-o-1-space",
                "content": "```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n        Arrays.parallelSort(beans);\\n        long sum=0,min=Long.MAX_VALUE;\\n        int n=beans.length;\\n        for(int i:beans)\\n            sum+=i;\\n        for(int i=0;i<n;i++)\\n        {\\n            long temp=sum-((n-i+0L)*beans[i]);\\n            min=(long)Math.min(min,temp);\\n           \\n        }\\n        return min;\\n        \\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public long minimumRemoval(int[] beans) {\\n        Arrays.parallelSort(beans);\\n        long sum=0,min=Long.MAX_VALUE;\\n        int n=beans.length;\\n        for(int i:beans)\\n            sum+=i;\\n        for(int i=0;i<n;i++)\\n        {\\n            long temp=sum-((n-i+0L)*beans[i]);\\n            min=(long)Math.min(min,temp);\\n           \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3687945,
                "title": "simple-prefix-sum-sorting-c-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSelect an element from the array and count the number of operations required to make all elements equal to the selected element. This can be done using **prefix sum array** that\\'s why first **sort** the array and **calculate prefix sum** now select an element with **minimum number of operation.**\\n# Complexity\\n- Time complexity:O(N*log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    long long minimumRemoval(vector<int>& arr) {\\n        int n = arr.size();\\n        long long ans = LONG_MAX,left,right,op;\\n        sort(arr.begin(),arr.end());\\n        vector<long long> presum(n,0);\\n        presum[0] = arr[0];\\n\\n        for(int i = 1;i<n;i++)\\n        presum[i] = presum[i-1]+arr[i];\\n        for(int i = 0;i<n;i++)\\n        {\\n            left = presum[i]-arr[i],right = presum[n-1]-presum[i];\\n            op = left+(right-arr[i]*(long long)(n-i-1));\\n            ans = min(ans,op);\\n        }\\n        return ans;       \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/1ef03546-c00a-4d8d-9d57-9eb429b151bd_1687849975.5768478.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    long long minimumRemoval(vector<int>& arr) {\\n        int n = arr.size();\\n        long long ans = LONG_MAX,left,right,op;\\n        sort(arr.begin(),arr.end());\\n        vector<long long> presum(n,0);\\n        presum[0] = arr[0];\\n\\n        for(int i = 1;i<n;i++)\\n        presum[i] = presum[i-1]+arr[i];\\n        for(int i = 0;i<n;i++)\\n        {\\n            left = presum[i]-arr[i],right = presum[n-1]-presum[i];\\n            op = left+(right-arr[i]*(long long)(n-i-1));\\n            ans = min(ans,op);\\n        }\\n        return ans;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792019,
                "title": "java-prefix-sum-approach-simple-and-easy-to-understand",
                "content": "Below is the implementation in JAVA using Prefix Sum Approach:\\n```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n        Arrays.sort(beans);\\n        int n = beans.length;\\n        long sum = 0;\\n        for(int i=0; i<n; i++){\\n            sum += beans[i];\\n        }\\n        long minbeans = Long.MAX_VALUE;\\n        long prefix = 0, suffix = 0;\\n        long count = 0;\\n        for(int i=0; i<n; i++){\\n            prefix += beans[i];\\n            suffix = sum - prefix;\\n            count = (prefix - beans[i]) + (suffix - beans[i] * (n - i - 1L));\\n            if(count < minbeans)\\n               minbeans = count;\\n        }\\n        return minbeans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n        Arrays.sort(beans);\\n        int n = beans.length;\\n        long sum = 0;\\n        for(int i=0; i<n; i++){\\n            sum += beans[i];\\n        }\\n        long minbeans = Long.MAX_VALUE;\\n        long prefix = 0, suffix = 0;\\n        long count = 0;\\n        for(int i=0; i<n; i++){\\n            prefix += beans[i];\\n            suffix = sum - prefix;\\n            count = (prefix - beans[i]) + (suffix - beans[i] * (n - i - 1L));\\n            if(count < minbeans)\\n               minbeans = count;\\n        }\\n        return minbeans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772220,
                "title": "c-sufix-array-and-prefix-array-greedy-approach-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long long n = beans.size();       \\n        sort(beans.begin(),beans.end());\\n        vector<long long> sufix(n,0);\\n        \\n        sufix[n-1] = 0;\\n        \\n        for(long long i=n-2;i>=0;i--){\\n            sufix[i] = sufix[i+1] + beans[i+1];\\n        }\\n        \\n        vector<long long> prefix(n,0);\\n        prefix[0] = 0;\\n        \\n        for(long long i=1;i<n;i++){\\n            prefix[i] = prefix[i-1] + beans[i-1];\\n        }\\n        \\n        // Maximum value for a variable of type long long...         \\n        long long ans = 9223372036854775807;\\n        \\n        for(long long i=0;i<n;i++){\\n            long long a = prefix[i];\\n            long long b = sufix[i];\\n            \\n            long long x = n-(i+1);\\n            \\n            long long c =  a + b-(beans[i]*x);\\n            ans = min(ans,c);\\n            \\n            \\n        }\\n        \\n        \\n       return ans;\\n    \\n       \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long long n = beans.size();       \\n        sort(beans.begin(),beans.end());\\n        vector<long long> sufix(n,0);\\n        \\n        sufix[n-1] = 0;\\n        \\n        for(long long i=n-2;i>=0;i--){\\n            sufix[i] = sufix[i+1] + beans[i+1];\\n        }\\n        \\n        vector<long long> prefix(n,0);\\n        prefix[0] = 0;\\n        \\n        for(long long i=1;i<n;i++){\\n            prefix[i] = prefix[i-1] + beans[i-1];\\n        }\\n        \\n        // Maximum value for a variable of type long long...         \\n        long long ans = 9223372036854775807;\\n        \\n        for(long long i=0;i<n;i++){\\n            long long a = prefix[i];\\n            long long b = sufix[i];\\n            \\n            long long x = n-(i+1);\\n            \\n            long long c =  a + b-(beans[i]*x);\\n            ans = min(ans,c);\\n            \\n            \\n        }\\n        \\n        \\n       return ans;\\n    \\n       \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770226,
                "title": "c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        map<long long int,long long int> fir;\\n        long long int sum=0;\\n        int maxi=0;\\n        sort(beans.begin(),beans.end());\\n        for(int i=0;i<beans.size();i++)\\n        {\\n            sum+=beans[i];\\n            fir[beans[i]]++;\\n            maxi=max(maxi,beans[i]);\\n        }\\n        int sub=0;\\n        long long int prev=0,con=0;\\n        long long int ans=sum;\\n        long long int n=beans.size();\\n        for(long long int i=0;i<n;i++)\\n        {\\n            prev=beans[i]-prev;\\n            sum-=(((n-i)*prev));\\n            prev=beans[i];\\n            ans=min(ans,sum);   \\n            con=(fir[beans[i]]*beans[i]);\\n            sum+=con;\\n            i+=(fir[beans[i]]-1);\\n        }\\n        return min(ans,sum);\\n    }\\n};\\n```\\n\\n**prev:** difference between 2 consecutive beans which are supposed to be substracted from sum by number of beans greater than the bean[i], as its values contributing to sum will change in the next iteration.\\n**con:** When we pass a bean, then its value contributing to sum will become constant (which is bean\\'s real value-0).\\n\\nSuggestions are Welcomed.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        map<long long int,long long int> fir;\\n        long long int sum=0;\\n        int maxi=0;\\n        sort(beans.begin(),beans.end());\\n        for(int i=0;i<beans.size();i++)\\n        {\\n            sum+=beans[i];\\n            fir[beans[i]]++;\\n            maxi=max(maxi,beans[i]);\\n        }\\n        int sub=0;\\n        long long int prev=0,con=0;\\n        long long int ans=sum;\\n        long long int n=beans.size();\\n        for(long long int i=0;i<n;i++)\\n        {\\n            prev=beans[i]-prev;\\n            sum-=(((n-i)*prev));\\n            prev=beans[i];\\n            ans=min(ans,sum);   \\n            con=(fir[beans[i]]*beans[i]);\\n            sum+=con;\\n            i+=(fir[beans[i]]-1);\\n        }\\n        return min(ans,sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769759,
                "title": "c-easy-map",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int \\n    long long minimumRemoval(vector<int>& a) {\\n        int n  = a.size();\\n        sort(a.begin(),a.end());\\n        map<int,int>mp;\\n        ll  tot =0 ;\\n        for(int i = 0 ; i < n ;i++)\\n        {\\n            tot += a[i];\\n            mp[a[i]]++;\\n        }\\n        ll ans = 1e15;int pos=0;ll prev = 0 ; ll res = 0 ;\\n        for(auto i : mp)\\n        {\\n            pos += i.second;\\n            res = prev ;\\n            tot-=((ll)i.first*(ll)i.second);\\n            ll rempos = n-pos;\\n            ll  totcal = rempos*i.first;\\n            ll oper = tot-totcal;\\n          //  cout<<res<<\" \";\\n            ans = min(ans,oper+res);\\n            prev +=((ll)i.first*(ll)i.second);\\n            \\n        }\\n        return ans;\\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    #define ll long long int \\n    long long minimumRemoval(vector<int>& a) {\\n        int n  = a.size();\\n        sort(a.begin(),a.end());\\n        map<int,int>mp;\\n        ll  tot =0 ;\\n        for(int i = 0 ; i < n ;i++)\\n        {\\n            tot += a[i];\\n            mp[a[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1767501,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n      long long n = beans.size();\\n      sort(beans.begin(), beans.end());\\n      long long sum = 0;\\n            for(int i=0; i<n; i++)\\n            {\\n                    sum += beans[i];\\n            }\\n       long long ans = sum;\\n       for(int i=0; i<n; i++)\\n       {\\n            long long curr = sum - (n-i)*beans[i];\\n            if(ans > curr)\\n            ans = curr;\\n       }\\n      return ans;      \\n    }    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n      long long n = beans.size();\\n      sort(beans.begin(), beans.end());\\n      long long sum = 0;\\n            for(int i=0; i<n; i++)\\n            {\\n                    sum += beans[i];\\n            }\\n       long long ans = sum;\\n       for(int i=0; i<n; i++)\\n       {\\n            long long curr = sum - (n-i)*beans[i];\\n            if(ans > curr)\\n            ans = curr;\\n       }\\n      return ans;      \\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993302,
                "title": "prefix-suffix-sum-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(), beans.end());\\n        long long ans = LONG_LONG_MAX, ps = 0, n = beans.size(), ts = accumulate(beans.begin(), beans.end(), 0ll);\\n\\n        for(int i=0; i<n; i++) {\\n            ans = min(ans, ps + ts - beans[i] * (n - i));\\n            ps += beans[i];\\n            ts -= beans[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(), beans.end());\\n        long long ans = LONG_LONG_MAX, ps = 0, n = beans.size(), ts = accumulate(beans.begin(), beans.end(), 0ll);\\n\\n        for(int i=0; i<n; i++) {\\n            ans = min(ans, ps + ts - beans[i] * (n - i));\\n            ps += beans[i];\\n            ts -= beans[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754530,
                "title": "java-solution-counting-sort-faster-than-100",
                "content": "```java\\n//Method 1 --> Counting-Sort\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n        int max=0;\\n        for(int x:beans)\\n            if(x>max)\\n                max=x;\\n    \\n        int[] a = new int[max+1];\\n        long total=0;\\n        \\n        for(int x:beans){\\n            total+=x;\\n            a[x]++;\\n        }\\n        \\n        long min=Long.MAX_VALUE;\\n        int i=0;\\n        int freq=0;\\n        for(int x:a)\\n        {\\n            if(x>0){\\n            long res=(total-i)-((long)(beans.length-1-freq)*i);\\n            if(min>res)\\n                min=res;\\n            freq+=x;\\n            }\\n            i++;\\n        }\\n        return min;\\n    }\\n}\\n\\n\\n//Method 2 --> O(nlogn) sorting\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n        Arrays.sort(beans);\\n        long total=0;\\n        for(int x:beans)\\n           total+=x;\\n        long min=Long.MAX_VALUE;\\n        int i=0;\\n        for(int x:beans)\\n        {\\n            long res=(total-x)-((long)(beans.length-1-i++)*x);\\n            if(min>res)\\n                min=res;\\n        }\\n        return min;\\n    }\\n}",
                "solutionTags": [
                    "Counting Sort"
                ],
                "code": "class Solution {\\n    public long minimumRemoval(int[] beans) {\\n        int max=0;\\n        for(int x:beans)\\n            if(x>max)\\n                max=x;\\n    \\n        int[] a = new int[max+1];\\n        long total=0;\\n        \\n        for(int x:beans){\\n            total+=x;\\n            a[x]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2650179,
                "title": "scala-solution",
                "content": "```\\n  def minimumRemoval(beans: Array[Int]): Long = {\\n    val t = beans.map(_.toLong).sum\\n    (beans.sorted zip (beans.length to 1 by -1)).map(n => t - n._2.toLong * n._1).min\\n  }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n  def minimumRemoval(beans: Array[Int]): Long = {\\n    val t = beans.map(_.toLong).sum\\n    (beans.sorted zip (beans.length to 1 by -1)).map(n => t - n._2.toLong * n._1).min\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2316036,
                "title": "100-0ms-java",
                "content": "```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {  \\n        Arrays.sort(beans);\\n        int n=beans.length;\\n        long sum=0;\\n        long max=0;\\n        for(int i=0;i<n;i++){\\n            sum+=beans[i];\\n            max = max<((long)beans[i] * (n-i)) ? ((long)beans[i] * (n-i)) : max;\\n        }\\n        return sum-max;\\n    }\\n}    \\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {  \\n        Arrays.sort(beans);\\n        int n=beans.length;\\n        long sum=0;\\n        long max=0;\\n        for(int i=0;i<n;i++){\\n            sum+=beans[i];\\n            max = max<((long)beans[i] * (n-i)) ? ((long)beans[i] * (n-i)) : max;\\n        }\\n        return sum-max;\\n    }\\n}    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305937,
                "title": "swift-one-liner-fully-explained",
                "content": "```\\nclass Solution {\\n    func minimumRemoval(_ beans: [Int]) -> Int {\\n        beans.reduce(0, +) - beans.sorted().enumerated().reduce(0) { max($0, (beans.count - $1.0) * $1.1) }\\n    }\\n}\\n```\\n\\n**Solution**\\n\\n**Rewrite Problem Statement**\\n\\nThe problem description is confusingly written, making harder to understand what the solution should be. A clearer problem statement:\\n\\na) Select a bag. For this bag, no beans will be removed. For every other bag, if there are fewer beans than the selected bag, remove all beans; if there are more beans, remove the excess so it contains an equal amount of beans as the selected bag. Count total beans removed.\\n\\nb) Select every bag in turn, and note for each the total beans removed. Keep track of minimum total beans removed and report this number after evaluating all bags.\\n\\n**Implementation**\\n\\n**a) Sort the array of bean counts**\\nWhen we select a bag, we need to partition the other bags into two groups: those bags with fewer number of beans and those bags with more. Since we need to evaluate all bags, sorting the array will allow quick partitioning for each evaluation.  Note that the sorted values outside of the selected bag mean nothing, we\\'re only interested in how many bags have fewer or greater number of beans than the selected bag. Duplicate bean counts are OK.\\n\\n**b) For any selected bag, determine end state (remaining bean count)**\\nThis evaluation is straightforward. Remaining bean count is zero for all bags with fewer beans than the selected bag, and an equal number of beans (per problem statement) as the selected bag for the other bags. The end state (remaining bean count) then becomes a simple multiplication of: [how many bags contain at least as many beans as the selected bag, including selected bag] X [number of beans in the selected bag].\\n\\n**c) Select every bag and evaluate end state (remaining bean count). Keep track of MAXIMUM remaining bean count.**\\n\\n**d) Subtract MAXIMUM remaining bean count (optimal end state) from TOTAL bean count (start state) to determine MINIMUM beans to remove.**\\n**Done!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func minimumRemoval(_ beans: [Int]) -> Int {\\n        beans.reduce(0, +) - beans.sorted().enumerated().reduce(0) { max($0, (beans.count - $1.0) * $1.1) }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291036,
                "title": "c-time-o-1-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n     int n=beans.size();\\n     sort(beans.begin(),beans.end());\\n     long long total=0;\\n     for(int i=0;i<n;i++)\\n     {\\n         total+=beans[i];\\n     }\\n     long long res=total;\\n     long long unused=0;\\n     for(long long i=0;i<n;i++)\\n     {\\n        unused=total-(n-i)*beans[i];\\n        res=min(unused,res);\\n     }\\n     return res;  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n     int n=beans.size();\\n     sort(beans.begin(),beans.end());\\n     long long total=0;\\n     for(int i=0;i<n;i++)\\n     {\\n         total+=beans[i];\\n     }\\n     long long res=total;\\n     long long unused=0;\\n     for(long long i=0;i<n;i++)\\n     {\\n        unused=total-(n-i)*beans[i];\\n        res=min(unused,res);\\n     }\\n     return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290271,
                "title": "python-simple-maths",
                "content": "\\n    def minimumRemoval(self, beans):\\n        beans.sort()\\n        n, max_ = len(beans), 0\\n        \\n        for idx, bean in enumerate(beans):\\n            max_ = max(max_, bean*(n - idx))\\n            \\n        return sum(beans) - max_",
                "solutionTags": [],
                "code": "\\n    def minimumRemoval(self, beans):\\n        beans.sort()\\n        n, max_ = len(beans), 0\\n        \\n        for idx, bean in enumerate(beans):\\n            max_ = max(max_, bean*(n - idx))\\n            \\n        return sum(beans) - max_",
                "codeTag": "Python3"
            },
            {
                "id": 2263690,
                "title": "simple-approach-c",
                "content": "Idea is to find the min beans can remove by comparing all possible cases \\n\\n Calculating how much beans are going to removed by following logic \\n*  Sort array \\n* Every bag which is on the left has less beans than a current bag, and every bag which is on the right of the current has more beans \\n* For every \\u2018i\\u2019 we will keep track of the minimum beans to be removed\\n* For every bag, we remove all the beans on its left and some amount of beans from all the bag on its right (they have more )\\n* Amount  removed can be calculated using **(totalbeans - beans[i]*(beans.size()-i).**\\n\\n\\n\\t\\tlong long minimumRemoval(vector<int>& beans)\\n\\t\\t{\\n         sort(beans.begin(), beans.end());\\n         long long totalbeans=0;\\n        for(int i=0;i<beans.size();i++)\\n        {\\n            totalbeans=totalbeans+beans[i];\\n        }\\n\\t\\t\\n        long long remove=totalbeans;  //you can max remove all elements :)\\n        \\n        for(int j=0;j<beans.size();j++)\\n        {\\n            long long beansleft=beans[j]*(beans.size()-j);  //beans left after removing \\n            remove= min(remove,(totalbeans-beansleft));\\n           // cout<<remove;\\n        }\\n        \\n        return remove;\\n    }",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "Idea is to find the min beans can remove by comparing all possible cases \\n\\n Calculating how much beans are going to removed by following logic \\n*  Sort array \\n* Every bag which is on the left has less beans than a current bag, and every bag which is on the right of the current has more beans \\n* For every \\u2018i\\u2019 we will keep track of the minimum beans to be removed\\n* For every bag, we remove all the beans on its left and some amount of beans from all the bag on its right (they have more )\\n* Amount  removed can be calculated using **(totalbeans - beans[i]*(beans.size()-i).**\\n\\n\\n\\t\\tlong long minimumRemoval(vector<int>& beans)\\n\\t\\t{\\n         sort(beans.begin(), beans.end());\\n         long long totalbeans=0;\\n        for(int i=0;i<beans.size();i++)\\n        {\\n            totalbeans=totalbeans+beans[i];\\n        }\\n\\t\\t\\n        long long remove=totalbeans;  //you can max remove all elements :)\\n        \\n        for(int j=0;j<beans.size();j++)\\n        {\\n            long long beansleft=beans[j]*(beans.size()-j);  //beans left after removing \\n            remove= min(remove,(totalbeans-beansleft));\\n           // cout<<remove;\\n        }\\n        \\n        return remove;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2183467,
                "title": "python-sort",
                "content": "Sort the nums. For each num, you can remove every thing on the left, and reduce every thing on the right to curr num. \\n\\n```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        \\n        beans.sort()\\n        \\n        n = len(beans)\\n        \\n        prefix = [0]\\n        \\n        for num in beans:\\n            prefix.append(prefix[-1] + num)\\n            \\n        ans = prefix[-1]\\n        \\n        for i in range(n):\\n            remove_left = prefix[i]\\n            remove_right = prefix[-1] - prefix[i] - (n-i) * beans[i]\\n            \\n            ans = min(ans, remove_left+remove_right)\\n\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        \\n        beans.sort()\\n        \\n        n = len(beans)\\n        \\n        prefix = [0]\\n        \\n        for num in beans:\\n            prefix.append(prefix[-1] + num)\\n            \\n        ans = prefix[-1]\\n        \\n        for i in range(n):\\n            remove_left = prefix[i]\\n            remove_right = prefix[-1] - prefix[i] - (n-i) * beans[i]\\n            \\n            ans = min(ans, remove_left+remove_right)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136951,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Approach 1 : Using Prefix Sum***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        vector<long long> prefix(n, 0);\\n        \\n        prefix[0] = arr[0];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            prefix[i] = prefix[i - 1] + arr[i];\\n        }\\n        \\n        long long total_sum = prefix[n - 1];\\n        \\n        long long mini = LLONG_MAX;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            long long curr_removal = 0;\\n\\t\\t\\t\\n\\t\\t\\t// make left element equal to zero\\n            \\n            if(i > 0)\\n            {\\n                curr_removal += prefix[i - 1];\\n            }\\n            \\n            long long right_sum = total_sum - prefix[i];\\n\\t\\t\\t\\n\\t\\t\\t// element right to curr index make equal to curr element\\n            \\n            curr_removal += right_sum - (long long)(n - i - 1) * (long long) arr[i];\\n            \\n            mini = min(mini, curr_removal);\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```\\n\\n* ***Approach 2 : Without Using Prefix Array***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        long long total_sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            total_sum += arr[i];\\n        }\\n        \\n        long long mini = LLONG_MAX;\\n        \\n        long long curr_sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            curr_sum += arr[i];\\n            \\n            long long curr_removal = 0;\\n            \\n            long long left_sum = curr_sum - arr[i];\\n            \\n            curr_removal += left_sum;\\n            \\n            long long right_sum = total_sum - curr_sum;\\n            \\n            curr_removal += right_sum - (long long) (n - i - 1) * (long long) (arr[i]);\\n            \\n            mini = min(mini, curr_removal);\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        vector<long long> prefix(n, 0);\\n        \\n        prefix[0] = arr[0];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            prefix[i] = prefix[i - 1] + arr[i];\\n        }\\n        \\n        long long total_sum = prefix[n - 1];\\n        \\n        long long mini = LLONG_MAX;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            long long curr_removal = 0;\\n\\t\\t\\t\\n\\t\\t\\t// make left element equal to zero\\n            \\n            if(i > 0)\\n            {\\n                curr_removal += prefix[i - 1];\\n            }\\n            \\n            long long right_sum = total_sum - prefix[i];\\n\\t\\t\\t\\n\\t\\t\\t// element right to curr index make equal to curr element\\n            \\n            curr_removal += right_sum - (long long)(n - i - 1) * (long long) arr[i];\\n            \\n            mini = min(mini, curr_removal);\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        long long total_sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            total_sum += arr[i];\\n        }\\n        \\n        long long mini = LLONG_MAX;\\n        \\n        long long curr_sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            curr_sum += arr[i];\\n            \\n            long long curr_removal = 0;\\n            \\n            long long left_sum = curr_sum - arr[i];\\n            \\n            curr_removal += left_sum;\\n            \\n            long long right_sum = total_sum - curr_sum;\\n            \\n            curr_removal += right_sum - (long long) (n - i - 1) * (long long) (arr[i]);\\n            \\n            mini = min(mini, curr_removal);\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838219,
                "title": "python-sorting-solution",
                "content": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        beans = sorted(beans)\\n        S = sum(beans)\\n        min_operations = []\\n        for i in range(len(beans)):\\n            min_operations.append(S - beans[i] * (len(beans) - i))\\n            \\n        return sorted(min_operations)[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        beans = sorted(beans)\\n        S = sum(beans)\\n        min_operations = []\\n        for i in range(len(beans)):\\n            min_operations.append(S - beans[i] * (len(beans) - i))\\n            \\n        return sorted(min_operations)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836172,
                "title": "python-2-lines-explained",
                "content": "If the final beans number (in a non-empty bags) is **n**, the number of all left beans is:\\n* **Left_beans_number = (number of bags that have at least n beans) x n**\\n\\nSo we need to remove \\n* **Remove_number = Original_beans_number - Left_beans_number**\\n\\n```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        beans.sort(reverse = True)\\n        return sum(beans) - max(n*(i+1) for i, n in enumerate(beans))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        beans.sort(reverse = True)\\n        return sum(beans) - max(n*(i+1) for i, n in enumerate(beans))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828174,
                "title": "c-simple-solution-o-n",
                "content": "Comment down if you want an explanation of code\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        if(beans.size()==1)\\n            return 0;\\n        \\n        long long min_beans;\\n        sort(beans.begin(),beans.end());\\n        long long sum = 0;\\n        \\n        for(auto b:beans)\\n            sum+=b;\\n        \\n        min_beans = sum;\\n        long long previous = 0;\\n        \\n        for(int i=0;i<beans.size();i++)\\n        {\\n            if(i!=0)\\n            {\\n                sum -= beans[i-1];\\n                previous += beans[i-1];\\n            }\\n            long long actual = beans[i]*(beans.size()-i);\\n            long long removed = sum - actual + previous;\\n            min_beans = min(min_beans,removed);\\n            \\n            \\n        }\\n        return min_beans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        if(beans.size()==1)\\n            return 0;\\n        \\n        long long min_beans;\\n        sort(beans.begin(),beans.end());\\n        long long sum = 0;\\n        \\n        for(auto b:beans)\\n            sum+=b;\\n        \\n        min_beans = sum;\\n        long long previous = 0;\\n        \\n        for(int i=0;i<beans.size();i++)\\n        {\\n            if(i!=0)\\n            {\\n                sum -= beans[i-1];\\n                previous += beans[i-1];\\n            }\\n            long long actual = beans[i]*(beans.size()-i);\\n            long long removed = sum - actual + previous;\\n            min_beans = min(min_beans,removed);\\n            \\n            \\n        }\\n        return min_beans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788244,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& a) {\\n        long long i,n=a.size(), ans=1e11, res=1e11;\\n        if(n==1) return 0;\\n        sort(a.begin(), a.end());\\n        vector<long long> l(n,0); l[0]=a[0];\\n        vector<long long> r(n,0); r[n-1]=a[n-1];\\n        for(i=1;i<n;i++) l[i]+=(l[i-1]+a[i]);\\n        for(i=n-2;i>=0;i--) r[i]+=(r[i+1]+a[i]);\\n        for(i=0;i<n;i++){\\n            if(i==0) {\\n                res=r[1]-((n-1)*a[0]);\\n            }\\n            else if(i==n-1) {\\n                res=l[n-2];\\n            }\\n            else {\\n                res=(l[i-1])+(r[i+1]-(n-i-1)*a[i]);\\n            }\\n            ans=min(res, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& a) {\\n        long long i,n=a.size(), ans=1e11, res=1e11;\\n        if(n==1) return 0;\\n        sort(a.begin(), a.end());\\n        vector<long long> l(n,0); l[0]=a[0];\\n        vector<long long> r(n,0); r[n-1]=a[n-1];\\n        for(i=1;i<n;i++) l[i]+=(l[i-1]+a[i]);\\n        for(i=n-2;i>=0;i--) r[i]+=(r[i+1]+a[i]);\\n        for(i=0;i<n;i++){\\n            if(i==0) {\\n                res=r[1]-((n-1)*a[0]);\\n            }\\n            else if(i==n-1) {\\n                res=l[n-2];\\n            }\\n            else {\\n                res=(l[i-1])+(r[i+1]-(n-i-1)*a[i]);\\n            }\\n            ans=min(res, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777820,
                "title": "c-simple-code-sorting-and-checking",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n       ll ans;\\n        ll n=beans.size();\\n        ll total=accumulate(beans.begin(),beans.end(),(ll)0);\\n        sort(beans.begin(),beans.end());\\n        for(ll i=0;i<n;i++)\\n        {\\n          ans=min(ans,total-(n-i)*beans[i]);  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n       ll ans;\\n        ll n=beans.size();\\n        ll total=accumulate(beans.begin(),beans.end(),(ll)0);\\n        sort(beans.begin(),beans.end());\\n        for(ll i=0;i<n;i++)\\n        {\\n          ans=min(ans,total-(n-i)*beans[i]);  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776021,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long minimumRemoval(vector<int>& bs) {\\n        sort(bs.begin(),bs.end());\\n        ll ans=LLONG_MAX;\\n        ll su=0;\\n        for(ll i=0;i<bs.size();i++)su+=bs[i];\\n        ans=min(ans,su);\\n        ll sum=0;\\n        for(ll i=0;i<bs.size();i++){\\n            sum+=bs[i];\\n            ll k=(ll)bs[i]*(bs.size()-i-1);\\n            ll j=su-sum-k;\\n            ans=min(ans,j+sum-bs[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long minimumRemoval(vector<int>& bs) {\\n        sort(bs.begin(),bs.end());\\n        ll ans=LLONG_MAX;\\n        ll su=0;\\n        for(ll i=0;i<bs.size();i++)su+=bs[i];\\n        ans=min(ans,su);\\n        ll sum=0;\\n        for(ll i=0;i<bs.size();i++){\\n            sum+=bs[i];\\n            ll k=(ll)bs[i]*(bs.size()-i-1);\\n            ll j=su-sum-k;\\n            ans=min(ans,j+sum-bs[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772896,
                "title": "nice-prefix-sum-question-little-tricky-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long long c=LLONG_MAX,n=beans.size();\\n        sort(beans.begin(),beans.end());\\n        vector<long long> pref(n,0);\\n        pref[0]=beans[0];\\n        for(int i=1;i<n;i++){\\n            pref[i]=pref[i-1]+beans[i];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                c=min(c,pref[n-1]-pref[0]-(n-1)*beans[i]);\\n            }else if(i==n-1){\\n                c=min(c,pref[n-2]);\\n            }else{\\n                c=min(c,pref[i-1]+pref[n-1]-pref[i]-(n-i-1)*beans[i]);\\n            }\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long long c=LLONG_MAX,n=beans.size();\\n        sort(beans.begin(),beans.end());\\n        vector<long long> pref(n,0);\\n        pref[0]=beans[0];\\n        for(int i=1;i<n;i++){\\n            pref[i]=pref[i-1]+beans[i];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                c=min(c,pref[n-1]-pref[0]-(n-1)*beans[i]);\\n            }else if(i==n-1){\\n                c=min(c,pref[n-2]);\\n            }else{\\n                c=min(c,pref[i-1]+pref[n-1]-pref[i]-(n-i-1)*beans[i]);\\n            }\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1771381,
                "title": "c-easy-solution-time-o-nlogn-space-o-1-sorting",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& a) {\\n        \\n        long long n = a.size() , sum =0, h , k ,ans;\\n        \\n        for(int i=0;i<n;i++)\\n            sum += a[i];\\n        \\n        //sum = accumulate(a.begin(),a.end(),0);\\n        sort(a.begin(),a.end());\\n        \\n        ans = sum;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            k = sum-(a[i]*(n-i));\\n            ans= min(k,ans);\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& a) {\\n        \\n        long long n = a.size() , sum =0, h , k ,ans;\\n        \\n        for(int i=0;i<n;i++)\\n            sum += a[i];\\n        \\n        //sum = accumulate(a.begin(),a.end(),0);\\n        sort(a.begin(),a.end());\\n        \\n        ans = sum;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            k = sum-(a[i]*(n-i));\\n            ans= min(k,ans);\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768835,
                "title": "c-2171-removing-minimum-number-of-magic-beans",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(), beans.end()); \\n        long most = 0; \\n        for (int i = 0, n = beans.size(); i < n; ++i) most = max(most, (long)(n-i)*beans[i]); \\n        return accumulate(beans.begin(), beans.end(), 0l) - most; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(), beans.end()); \\n        long most = 0; \\n        for (int i = 0, n = beans.size(); i < n; ++i) most = max(most, (long)(n-i)*beans[i]); \\n        return accumulate(beans.begin(), beans.end(), 0l) - most; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768793,
                "title": "easy-c-solution-nlogn-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long long count=1e18;\\n        long long totsum=0;\\n        long long int n=beans.size();\\n        sort(beans.begin(),beans.end());\\n        for(long long int i=0;i<beans.size();i++)\\n        {\\n            totsum+=beans[i];\\n        }\\n        for(long long int i=0;i<beans.size();i++)\\n        {\\n            count=min(count,totsum-(n-i)*beans[i]);\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long long count=1e18;\\n        long long totsum=0;\\n        long long int n=beans.size();\\n        sort(beans.begin(),beans.end());\\n        for(long long int i=0;i<beans.size();i++)\\n        {\\n            totsum+=beans[i];\\n        }\\n        for(long long int i=0;i<beans.size();i++)\\n        {\\n            count=min(count,totsum-(n-i)*beans[i]);\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768261,
                "title": "simple-java-solution-o-nlogn",
                "content": "\\n        \\n        \\n        Arrays.sort(beans);\\n        long sum=0;\\n        for(int i=0;i<beans.length;i++)\\n            sum+=beans[i];\\n        long min=Long.MAX_VALUE;\\n        int n=beans.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            long t=(long)beans[i];\\n            long y=(long)(n-i);\\n            long x=t*y;\\n            long tmp=sum-x;\\n            min=(long)Math.min(min,tmp);\\n        }\\n        return min;\\n        \\n    \\n",
                "solutionTags": [],
                "code": "\\n        \\n        \\n        Arrays.sort(beans);\\n        long sum=0;\\n        for(int i=0;i<beans.length;i++)\\n            sum+=beans[i];\\n        long min=Long.MAX_VALUE;\\n        int n=beans.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            long t=(long)beans[i];\\n            long y=(long)(n-i);\\n            long x=t*y;\\n            long tmp=sum-x;\\n            min=(long)Math.min(min,tmp);\\n        }\\n        return min;\\n        \\n    \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1768243,
                "title": "c-prefix-suffix-sum-easy-to-understand-o-nlogn",
                "content": "**Solution:**\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        \\n        sort(beans.begin(), beans.end());\\n        \\n        const int MAX_SIZE = 100001;\\n        long long prefix[MAX_SIZE] = {0}, suffix[MAX_SIZE] = {0};\\n        \\n        long long n = beans.size();\\n        prefix[0] = beans[0];\\n        \\n        for(int i = 1; i < n; i++) prefix[i] = prefix[i-1] + beans[i];\\n        for(int i = n-1; i >= 0; i--) suffix[i] = suffix[i+1] + beans[i];\\n        \\n        long long ans = prefix[n-1] - (n * beans[0]);\\n        \\n        for(int i = 1; i < n; i++) {\\n            long long a = prefix[i-1] + suffix[i+1];\\n            long long b = (n-i-1) * beans[i];\\n            ans = min(ans, a-b);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        \\n        sort(beans.begin(), beans.end());\\n        \\n        const int MAX_SIZE = 100001;\\n        long long prefix[MAX_SIZE] = {0}, suffix[MAX_SIZE] = {0};\\n        \\n        long long n = beans.size();\\n        prefix[0] = beans[0];\\n        \\n        for(int i = 1; i < n; i++) prefix[i] = prefix[i-1] + beans[i];\\n        for(int i = n-1; i >= 0; i--) suffix[i] = suffix[i+1] + beans[i];\\n        \\n        long long ans = prefix[n-1] - (n * beans[0]);\\n        \\n        for(int i = 1; i < n; i++) {\\n            long long a = prefix[i-1] + suffix[i+1];\\n            long long b = (n-i-1) * beans[i];\\n            ans = min(ans, a-b);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768171,
                "title": "c-o-nlogn-sorting-prefix-sum-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n    \\n    \\n    // nnnnnyyyy\\n    int searchFirstLargerPos(vector<int> &A, int l, int r, int ref) {\\n        while(l < r) {\\n            int m = (l + r) / 2;\\n            if(A[m] > ref) {\\n                r = m;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    long long minimumRemoval(vector<int>& beans) {\\n        // sort --> try making from left to right --> [0, or smallest no , next smaller no....]\\n        // in case of 0 --> wait till only last remaining values are same.\\n        // in case of other nos. --> make all numbers same as these numbers...\\n        int n = beans.size();\\n        sort(beans.begin(), beans.end());\\n        int mx = beans[n - 1];\\n        int64 min_count = LONG_MAX;\\n        \\n        vector<int64> prefixSum(n, 0);\\n        prefixSum[0] = beans[0];\\n        for(int i = 1; i < n; i++) {\\n            prefixSum[i] = beans[i] + prefixSum[i - 1];\\n        }\\n        \\n        map<int, int64> mp; // map {ref --> count}\\n        \\n        // special case of 0\\n        for(int i = 0; i < n; i++) {\\n            if(beans[i] == mx) {\\n                break;\\n            }\\n            mp[0] += beans[i];\\n        }\\n        \\n        map<int, bool> visited;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(visited[beans[i]]) {\\n                continue;\\n            }\\n            visited[beans[i]] = true;\\n            int64 preSum = (i >= 1) ? prefixSum[i - 1] : 0;\\n            int nextIdx = searchFirstLargerPos(beans, i, n - 1, beans[i]);\\n            int64 postSum = (prefixSum[n - 1] - ((nextIdx > 0) ? prefixSum[nextIdx - 1] : 0));\\n            postSum -= (int64 (n - nextIdx) * beans[i]);\\n            mp[beans[i]] = preSum + postSum;\\n        }\\n        \\n        for(auto it = mp.begin(); it != mp.end(); it++) {\\n            min_count = min(min_count, it->second);\\n        }\\n        return min_count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n    \\n    \\n    // nnnnnyyyy\\n    int searchFirstLargerPos(vector<int> &A, int l, int r, int ref) {\\n        while(l < r) {\\n            int m = (l + r) / 2;\\n            if(A[m] > ref) {\\n                r = m;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    long long minimumRemoval(vector<int>& beans) {\\n        // sort --> try making from left to right --> [0, or smallest no , next smaller no....]\\n        // in case of 0 --> wait till only last remaining values are same.\\n        // in case of other nos. --> make all numbers same as these numbers...\\n        int n = beans.size();\\n        sort(beans.begin(), beans.end());\\n        int mx = beans[n - 1];\\n        int64 min_count = LONG_MAX;\\n        \\n        vector<int64> prefixSum(n, 0);\\n        prefixSum[0] = beans[0];\\n        for(int i = 1; i < n; i++) {\\n            prefixSum[i] = beans[i] + prefixSum[i - 1];\\n        }\\n        \\n        map<int, int64> mp; // map {ref --> count}\\n        \\n        // special case of 0\\n        for(int i = 0; i < n; i++) {\\n            if(beans[i] == mx) {\\n                break;\\n            }\\n            mp[0] += beans[i];\\n        }\\n        \\n        map<int, bool> visited;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(visited[beans[i]]) {\\n                continue;\\n            }\\n            visited[beans[i]] = true;\\n            int64 preSum = (i >= 1) ? prefixSum[i - 1] : 0;\\n            int nextIdx = searchFirstLargerPos(beans, i, n - 1, beans[i]);\\n            int64 postSum = (prefixSum[n - 1] - ((nextIdx > 0) ? prefixSum[nextIdx - 1] : 0));\\n            postSum -= (int64 (n - nextIdx) * beans[i]);\\n            mp[beans[i]] = preSum + postSum;\\n        }\\n        \\n        for(auto it = mp.begin(); it != mp.end(); it++) {\\n            min_count = min(min_count, it->second);\\n        }\\n        return min_count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767959,
                "title": "java-solution-with-png-explanation",
                "content": "``` \\t\\npublic long minimumRemoval(int[] beans) {\\n        long total = 0;\\n        long len = beans.length;\\n        for(int i:beans) {\\n            total += i;\\n        }\\n        Arrays.sort(beans);\\n        long count = Long.MAX_VALUE;\\n        for(int i=0;i<beans.length;i++) {\\n            long c = total - len*beans[i];\\n            count = Math.min(count, c);\\n            len--;\\n        }\\n        return count;\\n    }\\n\\t\\n\\t![image](https://assets.leetcode.com/users/images/ceb33868-c1fe-4084-909f-8fc0bcede051_1644749927.1033432.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` \\t\\npublic long minimumRemoval(int[] beans) {\\n        long total = 0;\\n        long len = beans.length;\\n        for(int i:beans) {\\n            total += i;\\n        }\\n        Arrays.sort(beans);\\n        long count = Long.MAX_VALUE;\\n        for(int i=0;i<beans.length;i++) {\\n            long c = total - len*beans[i];\\n            count = Math.min(count, c);\\n            len--;\\n        }\\n        return count;\\n    }\\n\\t\\n\\t![image](https://assets.leetcode.com/users/images/ceb33868-c1fe-4084-909f-8fc0bcede051_1644749927.1033432.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1767887,
                "title": "c-short-and-simple",
                "content": "check the minimum removal by doing all the  elements greater than element zero and all the greater elements  equal to our current element\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>&A) {\\n        \\n        long long n = A.size();\\n        long long  sum = 0;\\n        long long count = LLONG_MAX;\\n        sort(A.begin(),A.end());\\n        long long cur_sum = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            sum += 1ll*A[i];\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            long long cur_count = cur_sum + (sum - cur_sum - A[i])  - (n - i - 1) * A[i];\\n            cur_sum += A[i];\\n            count = min(count,cur_count);\\n        }\\n        return count;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>&A) {\\n        \\n        long long n = A.size();\\n        long long  sum = 0;\\n        long long count = LLONG_MAX;\\n        sort(A.begin(),A.end());\\n        long long cur_sum = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            sum += 1ll*A[i];\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            long long cur_count = cur_sum + (sum - cur_sum - A[i])  - (n - i - 1) * A[i];\\n            cur_sum += A[i];\\n            count = min(count,cur_count);\\n        }\\n        return count;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767588,
                "title": "golang-sort-solution",
                "content": "```go\\nfunc minimumRemoval(beans []int) int64 {\\n\\tsummary := 0\\n\\tremoval := math.MaxInt64\\n\\tsort.Ints(beans)\\n\\tfor _, v := range beans {\\n\\t\\tsummary += v\\n\\t}\\n\\tfor i, v := range beans {\\n\\t\\tif current := summary - (len(beans)-i) * v; current < removal {\\n\\t\\t\\tremoval = current\\n\\t\\t}\\n\\t}\\n\\treturn int64(removal)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sorting"
                ],
                "code": "```go\\nfunc minimumRemoval(beans []int) int64 {\\n\\tsummary := 0\\n\\tremoval := math.MaxInt64\\n\\tsort.Ints(beans)\\n\\tfor _, v := range beans {\\n\\t\\tsummary += v\\n\\t}\\n\\tfor i, v := range beans {\\n\\t\\tif current := summary - (len(beans)-i) * v; current < removal {\\n\\t\\t\\tremoval = current\\n\\t\\t}\\n\\t}\\n\\treturn int64(removal)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1767456,
                "title": "c-detailed-explanation-using-example",
                "content": "# Explanation\\n\\nLet\\'s use the example where `A = [4, 1, 4, 5, 6, 4]`, and the _**base**_ is the number of beans in the remaning non-empty bags.\\n\\nThe problem can be simplified to calculating the total to be removed for numbers less and greater than the *base* value as we can\\'t add anything back. So the array is first sorted to make this much easier, \\n\\n`A = [1, 4, 4, 4, 5, 6]`.\\n\\nTo calculate the amount to be removed, we first find the sum of the entire array, `sum = 24`. This is equivalent to the number of beans to remove if we had a 0 at the start of the array, and letting 0 be the *base* value.\\n\\nWe follow by calculating the prefix sum for each *base* value. For each iteration, we subtract the difference between current and previous base values *(num - base)* and add back the sum of the previous base values *(num - 0)*. \\n\\n**Example Walkthrough:**\\n\\nBase = 1, i = 0\\n**1** 4 4 4 5 6\\n1 1 1 1 1 1\\n`sum = sum - (n-i) * (base - prevBase) + prevBaseSum = 24 - 6 * 1 + 0 = 18`\\n\\nBase = 4, i = 1\\n1 **4 4 4** 5 6\\n0 4 4 4 4 4 \\n`sum = sum - (n-i) * (base - prevBase) + prevBaseSum = 18 - 5 * 3 + 1 = 4`\\n\\nBase = 5, i = 4\\n1 4 4 4 **5** 6\\n0 0 0 0 5 5\\n`sum = sum - (n-i) * (base - prevBase) + prevBaseSum = 4 - 2 * 1 + 12 = 14`\\n\\nBase = 6, i = 5\\n1 4 4 4 5 **6**\\n0 0 0 0  0 6\\n`sum = sum - (n-i) * (base - prevBase) + prevBaseSum = 14 - 1 *1 + 5 = 18`\\n\\nThe minimum value is 4 which is the solution for this example.\\n\\n# Solution\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        if (beans.size() == 1) return 0;\\n        int n = beans.size();\\n        sort(beans.begin(), beans.end());\\n        \\n        long long sum = 0;\\n        for (int i = 0; i < n; i++)\\n            sum += beans[i];\\n        \\n        long long minRemove = sum; \\n        int prevBase = 0; \\n        long long prevBaseSum = 0; \\n        int i = 0;\\n        while(i < n) {\\n            int base = beans[i];\\n            sum = sum - (long long)(n-i) * (long long)(base - prevBase) + prevBaseSum;\\n            minRemove = min(minRemove, sum);\\n            \\n            prevBaseSum = 0;\\n            while(i < n-1 && beans[i] == beans[i+1]) \\n                prevBaseSum += beans[i++];\\n            prevBaseSum += beans[i++];\\n            \\n            prevBase = base;\\n        }\\n        return minRemove;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        if (beans.size() == 1) return 0;\\n        int n = beans.size();\\n        sort(beans.begin(), beans.end());\\n        \\n        long long sum = 0;\\n        for (int i = 0; i < n; i++)\\n            sum += beans[i];\\n        \\n        long long minRemove = sum; \\n        int prevBase = 0; \\n        long long prevBaseSum = 0; \\n        int i = 0;\\n        while(i < n) {\\n            int base = beans[i];\\n            sum = sum - (long long)(n-i) * (long long)(base - prevBase) + prevBaseSum;\\n            minRemove = min(minRemove, sum);\\n            \\n            prevBaseSum = 0;\\n            while(i < n-1 && beans[i] == beans[i+1]) \\n                prevBaseSum += beans[i++];\\n            prevBaseSum += beans[i++];\\n            \\n            prevBase = base;\\n        }\\n        return minRemove;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767450,
                "title": "python-no-sort-needed-faster-than-100",
                "content": "```\\nclass Solution(object):\\n    def minimumRemoval(self, beans):\\n        \"\"\"\\n        :type beans: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count = Counter(beans)\\n        n = len(beans)\\n        total = sum(beans)\\n        cur = total\\n        res = total\\n        for i in range(1, max(beans) + 1):\\n            cur -= n\\n            res = min(res, cur)\\n            if count[i]:\\n                n -= count[i]\\n                cur += count[i] * i\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumRemoval(self, beans):\\n        \"\"\"\\n        :type beans: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count = Counter(beans)\\n        n = len(beans)\\n        total = sum(beans)\\n        cur = total\\n        res = total\\n        for i in range(1, max(beans) + 1):\\n            cur -= n\\n            res = min(res, cur)\\n            if count[i]:\\n                n -= count[i]\\n                cur += count[i] * i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767285,
                "title": "removing-minimum-number-of-magic-beans",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long helper(int num, vector<int>b){\\n        long long ans=0;\\n        for(int i=0; i<b.size(); i++){\\n            if(num<b[i]){\\n                ans+=(b[i]-num);\\n                b[i]-=num;\\n            }else if(num>b[i]){\\n                ans+=b[i];\\n                b[i]=0;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    long long minimumRemoval(vector<int>& beans) {\\n        long long ans=INT_MAX;\\n        unordered_set<int>st;\\n        for(int i=0; i<beans.size(); i++){\\n            st.insert(beans[i]);\\n        }\\n        \\n        for(auto i:st){\\n            ans=min(ans, helper(i, beans));\\n            \\n        }\\n        \\n        return ans;\\n               \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long helper(int num, vector<int>b){\\n        long long ans=0;\\n        for(int i=0; i<b.size(); i++){\\n            if(num<b[i]){\\n                ans+=(b[i]-num);\\n                b[i]-=num;\\n            }else if(num>b[i]){\\n                ans+=b[i];\\n                b[i]=0;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    long long minimumRemoval(vector<int>& beans) {\\n        long long ans=INT_MAX;\\n        unordered_set<int>st;\\n        for(int i=0; i<beans.size(); i++){\\n            st.insert(beans[i]);\\n        }\\n        \\n        for(auto i:st){\\n            ans=min(ans, helper(i, beans));\\n            \\n        }\\n        \\n        return ans;\\n               \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767209,
                "title": "c-sort",
                "content": "- Sort the array.\\n- Traverse the array from right to left and keep track of the difference of that element with all the other elements after it.\\n- Traverse from left to right keep track of the sum of elements before the current element.\\n- Take the minimum of step 2 and 3s sum.\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& b) {\\n        sort(b.begin(),b.end());\\n        int n = b.size();\\n        vector<long long> vec (n,0);\\n        for(int i = n-2;i >= 0;i--){\\n            long long d = b[i+1] - b[i];\\n            vec[i] =  vec[i+1] + d*(n-(i+1));\\n        }\\n        \\n        long long p = 0;\\n        long long minn = vec[0];\\n        for(int i = 0;i < n;i++){\\n            vec[i]+= p;\\n            minn = min(minn,vec[i]);\\n            // cout << vec[i] << endl;\\n            p+=b[i];\\n        }\\n        return minn;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& b) {\\n        sort(b.begin(),b.end());\\n        int n = b.size();\\n        vector<long long> vec (n,0);\\n        for(int i = n-2;i >= 0;i--){\\n            long long d = b[i+1] - b[i];\\n            vec[i] =  vec[i+1] + d*(n-(i+1));\\n        }\\n        \\n        long long p = 0;\\n        long long minn = vec[0];\\n        for(int i = 0;i < n;i++){\\n            vec[i]+= p;\\n            minn = min(minn,vec[i]);\\n            // cout << vec[i] << endl;\\n            p+=b[i];\\n        }\\n        return minn;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1767208,
                "title": "c-explanation",
                "content": "=>we check for each cur elem  \\n  (all elems occuring after cur be equated to cur elem and elems occuring before cur elem to 0) \\n  \\n=>so for elems occuring before an elem we can keep sum and for occ after the cur elem\\n  (we do sum of all those elems - cur*(no. of  elems occ after cur ) )\\n    \\n=>for example for 4 ... we equate before elems to 0 (ie 1) and\\n  equate 6,5 to 4 (ie (5-4) + (6-4) ==> (5+6)-(4+4) )  \\n ```   \\na    = 1  4  5  6\\nsuff = 16 15 11 6 0    \\n```   \\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long minimumRemoval(vector<int>& a) {\\n        ll n = a.size(); vector<ll> suff(n+1); sort(begin(a),end(a));\\n        suff[n-1] = a[n-1];\\n        for(int i = n-2;i>=0;i--){\\n            suff[i] = a[i] +  suff[i+1]; \\n        }\\n    \\n        //intialise ans with case where we would reduce all elems to 0 except the max one\\n        int maxi = INT_MIN; for(auto &e:a) maxi = max(maxi,e);\\n        ll c = 0; for(auto &e:a) if(e!=maxi) c+=e;\\n    \\n        ll ans = c,sum = 0 ; c=0;\\n      \\n        for(int i = 0;i<a.size();i++){\\n            c = (suff[i+1] - a[i]*(n-i-1)) + sum;  \\n            \\n            sum+=a[i];\\n            ans = min(ans,c);\\n        }\\n        return ans;\\n    }\\n};\\n    \\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```   \\na    = 1  4  5  6\\nsuff = 16 15 11 6 0    \\n```\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long minimumRemoval(vector<int>& a) {\\n        ll n = a.size(); vector<ll> suff(n+1); sort(begin(a),end(a));\\n        suff[n-1] = a[n-1];\\n        for(int i = n-2;i>=0;i--){\\n            suff[i] = a[i] +  suff[i+1]; \\n        }\\n    \\n        //intialise ans with case where we would reduce all elems to 0 except the max one\\n        int maxi = INT_MIN; for(auto &e:a) maxi = max(maxi,e);\\n        ll c = 0; for(auto &e:a) if(e!=maxi) c+=e;\\n    \\n        ll ans = c,sum = 0 ; c=0;\\n      \\n        for(int i = 0;i<a.size();i++){\\n            c = (suff[i+1] - a[i]*(n-i-1)) + sum;  \\n            \\n            sum+=a[i];\\n            ans = min(ans,c);\\n        }\\n        return ans;\\n    }\\n};\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767020,
                "title": "simple-solution",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        map<long,long> mp;\\n        long long n=beans.size(),ans=0,mini=0,sum=0;\\n        for(auto &i:beans) {\\n            mp[i]++;\\n            sum+=i;\\n        }\\n        for(auto&i:mp) {\\n            ans=max(ans,(n-mini)*i.first);\\n            mini+=i.second;\\n        }\\n        return sum-ans;\\n    }\\n};``",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1766940,
                "title": "python-faster-solution-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def minimumRemoval(self, beans):\\n        \"\"\"\\n        :type beans: List[int]\\n        :rtype: int\\n        \"\"\"\\n        tot=sum(beans)\\n        beans.sort()\\n        tt=0\\n        l=[]\\n        n=len(beans)\\n        for i in range(n):\\n            nx=tot-(n-i)*beans[i]\\n            l.append(nx+tt)\\n            tt+=beans[i]\\n            tot-=beans[i]\\n        return min(l)\\n```\\n     O(nlog(n)) solution\\n     Sort the function so it becomes 1 4 5 6\\n     Then if you choose a number x, we want to make elements in left side as 0\\n    and right side elements as the number x\\n    so if x=4\\n    sum of left elements is 1\\n    and the sum after making the elements to x in right side = (5-4)+(6-2) =3\\n    Therefore, 3+1=4\\n    like that whole list is traversed and the minimum is returned\\n    # choose x\\n    # taking the total sum so we can subract no of times the element remain right side * 8\\n    # that is (len(nums)-i)*x\\n    # and the sum of left elements is in tt",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minimumRemoval(self, beans):\\n        \"\"\"\\n        :type beans: List[int]\\n        :rtype: int\\n        \"\"\"\\n        tot=sum(beans)\\n        beans.sort()\\n        tt=0\\n        l=[]\\n        n=len(beans)\\n        for i in range(n):\\n            nx=tot-(n-i)*beans[i]\\n            l.append(nx+tt)\\n            tt+=beans[i]\\n            tot-=beans[i]\\n        return min(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766923,
                "title": "best-c-sort-prefix-sum",
                "content": "class Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        \\n        sort(beans.begin(), beans.end());\\n        int n=beans.size();\\n        \\n        long long int ans, sum=0, pre=0;\\n        \\n        for(int i=0; i<n; i++) sum+=beans[i];\\n        ans=sum;  // maximum value of answer will be sum\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            pre+=beans[i];     // stores the sum of array till ith element\\n            int nl=n-i;      // length of array left\\n            \\n            long long int t=sum-1ll*(nl)*1ll*(beans[i]); \\n            ans=min(ans, t);\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        \\n        sort(beans.begin(), beans.end());\\n        int n=beans.size();\\n        \\n        long long int ans, sum=0, pre=0;\\n        \\n        for(int i=0; i<n; i++) sum+=beans[i];\\n        ans=sum;  // maximum value of answer will be sum\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            pre+=beans[i];     // stores the sum of array till ith element\\n            int nl=n-i;      // length of array left\\n            \\n            long long int t=sum-1ll*(nl)*1ll*(beans[i]); \\n            ans=min(ans, t);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1766828,
                "title": "o-n-log-n-using-sorting-and-prefix-sum",
                "content": "```csharp\\npublic long MinimumRemoval(int[] beans) \\n{\\n\\tArray.Sort(beans);\\n\\t\\n\\tlong[] prefixSum = new long[beans.Length + 1];\\n\\tfor (int i = 0; i < beans.Length; i++)\\n\\t{\\n\\t\\tprefixSum[i + 1] = prefixSum[i] + beans[i];\\n\\t}\\n\\n\\tlong result = prefixSum[^1];\\n\\tfor(int j = 0; j < beans.Length; j++)\\n\\t{\\n\\t\\tlong current = 0;\\n\\t\\tcurrent += prefixSum[j];\\n\\t\\tcurrent += (prefixSum[^1] - prefixSum[j]) - (1L * beans[j] * (beans.Length - j));\\n\\t\\tresult = Math.Min(result, current);\\n\\t}\\n\\n\\treturn result;\\n}\\n```\\n\\nThis can be further optimised to use O(1) space\\n```csharp\\npublic long MinimumRemoval(int[] beans) \\n{\\n\\tArray.Sort(beans);\\n\\n\\tlong result = long.MaxValue;\\n\\tlong sum = 0;\\n\\tfor (int i = 0; i < beans.Length; i++)\\n\\t{\\n\\t\\tsum += beans[i];\\n\\t}\\n\\n\\tfor (int i = 0; i < beans.Length; i++)\\n\\t{\\n\\t\\tlong current = (sum - (1L * beans[i] * (beans.Length - i)));\\n\\t\\tresult = Math.Min(result, current);\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic long MinimumRemoval(int[] beans) \\n{\\n\\tArray.Sort(beans);\\n\\t\\n\\tlong[] prefixSum = new long[beans.Length + 1];\\n\\tfor (int i = 0; i < beans.Length; i++)\\n\\t{\\n\\t\\tprefixSum[i + 1] = prefixSum[i] + beans[i];\\n\\t}\\n\\n\\tlong result = prefixSum[^1];\\n\\tfor(int j = 0; j < beans.Length; j++)\\n\\t{\\n\\t\\tlong current = 0;\\n\\t\\tcurrent += prefixSum[j];\\n\\t\\tcurrent += (prefixSum[^1] - prefixSum[j]) - (1L * beans[j] * (beans.Length - j));\\n\\t\\tresult = Math.Min(result, current);\\n\\t}\\n\\n\\treturn result;\\n}\\n```\n```csharp\\npublic long MinimumRemoval(int[] beans) \\n{\\n\\tArray.Sort(beans);\\n\\n\\tlong result = long.MaxValue;\\n\\tlong sum = 0;\\n\\tfor (int i = 0; i < beans.Length; i++)\\n\\t{\\n\\t\\tsum += beans[i];\\n\\t}\\n\\n\\tfor (int i = 0; i < beans.Length; i++)\\n\\t{\\n\\t\\tlong current = (sum - (1L * beans[i] * (beans.Length - i)));\\n\\t\\tresult = Math.Min(result, current);\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1766822,
                "title": "python-sort-dp",
                "content": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        n = len(beans)\\n        beans.sort()\\n        ps = [0 for _ in range(n+1)]\\n        for i in range(n):\\n            ps[i+1] = ps[i] + beans[i];\\n    \\n        ans = ps[n];\\n        i = 0\\n        while i < n:\\n            j = i\\n            foo = ps[i]; # sum of everything before i;\\n            while j < n and beans[i] == beans[j]:\\n                j += 1\\n            \\n            f =  beans[i];\\n            ans = min(ans, foo + (ps[n] - ps[j]) - f*(n - j))\\n            i = j;\\n        \\n        return ans;\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        n = len(beans)\\n        beans.sort()\\n        ps = [0 for _ in range(n+1)]\\n        for i in range(n):\\n            ps[i+1] = ps[i] + beans[i];\\n    \\n        ans = ps[n];\\n        i = 0\\n        while i < n:\\n            j = i\\n            foo = ps[i]; # sum of everything before i;\\n            while j < n and beans[i] == beans[j]:\\n                j += 1\\n            \\n            f =  beans[i];\\n            ans = min(ans, foo + (ps[n] - ps[j]) - f*(n - j))\\n            i = j;\\n        \\n        return ans;\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1766818,
                "title": "c-o-n-solution",
                "content": "```C++\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long long remainingBean = 0, n = beans.size();\\n        long long dropBeans = 0, upperBeanCnt = n;\\n        map<long long, long long> beanCount;\\n        for(int i = 0; i < n; i++) {\\n            remainingBean += beans[i];\\n            beanCount[beans[i]]++;\\n        }\\n        long long res = remainingBean;\\n        for(auto [bean, cnt] : beanCount) {\\n            upperBeanCnt -= cnt;\\n            remainingBean -= bean * cnt;\\n            res = min(res, dropBeans + remainingBean - upperBeanCnt * bean);\\n            dropBeans += bean * cnt;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long long remainingBean = 0, n = beans.size();\\n        long long dropBeans = 0, upperBeanCnt = n;\\n        map<long long, long long> beanCount;\\n        for(int i = 0; i < n; i++) {\\n            remainingBean += beans[i];\\n            beanCount[beans[i]]++;\\n        }\\n        long long res = remainingBean;\\n        for(auto [bean, cnt] : beanCount) {\\n            upperBeanCnt -= cnt;\\n            remainingBean -= bean * cnt;\\n            res = min(res, dropBeans + remainingBean - upperBeanCnt * bean);\\n            dropBeans += bean * cnt;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766781,
                "title": "c-sorting-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n          long long total_sum = 0;\\n        \\n          for(int ele : beans){\\n              total_sum = total_sum + (long long) ele;\\n          }\\n          sort(beans.begin(), beans.end());\\n        \\n         long long cur_sum =0;\\n        \\n         long long ans = LLONG_MAX;\\n         int n = beans.size();\\n          for(int i=0; i<n; i++){\\n              \\n               long long cur_moves = total_sum - (long long) (n - i) * (long long) beans[i];\\n               ans = min(ans, cur_moves);\\n              cur_sum = cur_sum + (long long) beans[i];\\n          }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n          long long total_sum = 0;\\n        \\n          for(int ele : beans){\\n              total_sum = total_sum + (long long) ele;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1766775,
                "title": "c-sorting-and-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(), beans.end());\\n        \\n        vector<unsigned long long> prefixSum;\\n        unsigned long long sum = 0;\\n        \\n        for(int bean : beans) {\\n            sum += bean;\\n            prefixSum.push_back(sum);\\n        }\\n        \\n        unsigned long long ans = ULLONG_MAX;\\n        \\n        int n = beans.size();\\n        \\n        for(int i=0;i<n;i++) {\\n            unsigned long long temp = 0;\\n            if(i == 0) {\\n                unsigned long long x = (unsigned long long)beans[i]*(n-1);\\n                temp = prefixSum[n-1] - prefixSum[0] - x;\\n            }\\n            \\n            else {\\n                unsigned long long x  = (unsigned long long)beans[i]*(n-1-i);\\n                temp = prefixSum[i-1];\\n                temp += (prefixSum[n-1] - prefixSum[i] - x);\\n            }\\n            \\n            if(temp<ans) ans = temp;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(), beans.end());\\n        \\n        vector<unsigned long long> prefixSum;\\n        unsigned long long sum = 0;\\n        \\n        for(int bean : beans) {\\n            sum += bean;\\n            prefixSum.push_back(sum);\\n        }\\n        \\n        unsigned long long ans = ULLONG_MAX;\\n        \\n        int n = beans.size();\\n        \\n        for(int i=0;i<n;i++) {\\n            unsigned long long temp = 0;\\n            if(i == 0) {\\n                unsigned long long x = (unsigned long long)beans[i]*(n-1);\\n                temp = prefixSum[n-1] - prefixSum[0] - x;\\n            }\\n            \\n            else {\\n                unsigned long long x  = (unsigned long long)beans[i]*(n-1-i);\\n                temp = prefixSum[i-1];\\n                temp += (prefixSum[n-1] - prefixSum[i] - x);\\n            }\\n            \\n            if(temp<ans) ans = temp;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766771,
                "title": "similar-to-largest-rectangle-in-histogram",
                "content": "https://leetcode.com/problems/largest-rectangle-in-histogram/\\n\\n```\\nclass Solution:\\n    def minimumRemoval(self, nums: List[int]) -> int:\\n        nums.sort()\\n        s = sum(nums)\\n        stack = [-1]\\n        max_area = 0\\n        for i in range(len(nums)):\\n            while stack[-1] != -1 and nums[stack[-1]] >= nums[i]:\\n                current_h = nums[stack.pop()]\\n                current_w = i - stack[-1] - 1\\n                max_area = max(max_area, current_h * current_w)\\n            stack.append(i)\\n        while stack[-1] != -1:\\n            current_h = nums[stack.pop()]\\n            current_w = len(nums) - stack[-1] - 1\\n            max_area = max(max_area, current_h * current_w)\\n        return s - max_area\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRemoval(self, nums: List[int]) -> int:\\n        nums.sort()\\n        s = sum(nums)\\n        stack = [-1]\\n        max_area = 0\\n        for i in range(len(nums)):\\n            while stack[-1] != -1 and nums[stack[-1]] >= nums[i]:\\n                current_h = nums[stack.pop()]\\n                current_w = i - stack[-1] - 1\\n                max_area = max(max_area, current_h * current_w)\\n            stack.append(i)\\n        while stack[-1] != -1:\\n            current_h = nums[stack.pop()]\\n            current_w = len(nums) - stack[-1] - 1\\n            max_area = max(max_area, current_h * current_w)\\n        return s - max_area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766759,
                "title": "sort-c-clean-code-code-self-explain",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) \\n    {\\n        sort(beans.begin(), beans.end());\\n        long long sum = 0;\\n        \\n        for(int a: beans)\\n            sum += a;\\n        \\n        int n = beans.size();\\n        long long curr = 0;\\n        \\n        long long ans = sum; // Removing all the beans is maximum ans\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            // current = remove all the small and making rest right values equal to current\\n            \\n            long long val = (long long )sum - (long long )(n - i) * (long long )beans[i];\\n            \\n            // update ans\\n            if(ans > val)\\n                ans = val;\\n            \\n            curr += beans[i];\\n        }\\n        \\n        // i == n handled when we start out ans = sum (all(beans))\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) \\n    {\\n        sort(beans.begin(), beans.end());\\n        long long sum = 0;\\n        \\n        for(int a: beans)\\n            sum += a;\\n        \\n        int n = beans.size();\\n        long long curr = 0;\\n        \\n        long long ans = sum; // Removing all the beans is maximum ans\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            // current = remove all the small and making rest right values equal to current\\n            \\n            long long val = (long long )sum - (long long )(n - i) * (long long )beans[i];\\n            \\n            // update ans\\n            if(ans > val)\\n                ans = val;\\n            \\n            curr += beans[i];\\n        }\\n        \\n        // i == n handled when we start out ans = sum (all(beans))\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069989,
                "title": "the-most-intuitive-solution-for-this-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) \\n    {\\n        long long int  res = 9999999999999 ; \\n        sort(beans.begin(),beans.end());\\n\\n        long long int lsum =0, sum=0, n = beans.size();\\n        sum = accumulate(beans.begin(),beans.end(),sum);\\n\\n        // lsum is the sum of elements on the left of the an index \\n        // rsum is the sum of elements on the right side of the index\\n        // for each index we will try to covert all its left part to zero\\n        // and all it right elements to the currrent value\\n        // of all possible option we will choose the minimun\\n        \\n        for(int i  =0;i<beans.size();i++)\\n        {\\n            long long  rsum = sum-lsum-beans[i];// sum of elements on the right side of the index \\n            if(res>lsum + rsum -(n-i-1)*(long long)beans[i])\\n            res = lsum + rsum -(n-i-1)*(long long )beans[i];\\n            lsum += beans[i];\\n        }\\n        return res; \\n    }\\n};\\n            \\n\\n\\n\\n\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) \\n    {\\n        long long int  res = 9999999999999 ; \\n        sort(beans.begin(),beans.end());\\n\\n        long long int lsum =0, sum=0, n = beans.size();\\n        sum = accumulate(beans.begin(),beans.end(),sum);\\n\\n        // lsum is the sum of elements on the left of the an index \\n        // rsum is the sum of elements on the right side of the index\\n        // for each index we will try to covert all its left part to zero\\n        // and all it right elements to the currrent value\\n        // of all possible option we will choose the minimun\\n        \\n        for(int i  =0;i<beans.size();i++)\\n        {\\n            long long  rsum = sum-lsum-beans[i];// sum of elements on the right side of the index \\n            if(res>lsum + rsum -(n-i-1)*(long long)beans[i])\\n            res = lsum + rsum -(n-i-1)*(long long )beans[i];\\n            lsum += beans[i];\\n        }\\n        return res; \\n    }\\n};\\n            \\n\\n\\n\\n\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049927,
                "title": "c-prefix-sum-approach-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long minimumRemoval(vector<int>& beans) \\n    {\\n        long long min_beans = LLONG_MAX, prefix_sum = 0, current_sum = 0;\\n        sort(beans.begin(), beans.end());\\n        \\n        for(auto bean: beans) prefix_sum += bean;\\n\\n        for(int i=0; i<beans.size(); i++)\\n        {\\n            prefix_sum -= beans[i];\\n\\n            if(prefix_sum - (beans.size()-i-1)*beans[i] + current_sum < min_beans)\\n                min_beans = prefix_sum - (beans.size()-i-1)*beans[i] + current_sum;   \\n\\n            current_sum += beans[i];\\n        }\\n        \\n        return min_beans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long minimumRemoval(vector<int>& beans) \\n    {\\n        long long min_beans = LLONG_MAX, prefix_sum = 0, current_sum = 0;\\n        sort(beans.begin(), beans.end());\\n        \\n        for(auto bean: beans) prefix_sum += bean;\\n\\n        for(int i=0; i<beans.size(); i++)\\n        {\\n            prefix_sum -= beans[i];\\n\\n            if(prefix_sum - (beans.size()-i-1)*beans[i] + current_sum < min_beans)\\n                min_beans = prefix_sum - (beans.size()-i-1)*beans[i] + current_sum;   \\n\\n            current_sum += beans[i];\\n        }\\n        \\n        return min_beans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046821,
                "title": "simple-solution-using-simple-math-and-sorting",
                "content": "# Intuition\\n***Simple solution using simple math and sorting***\\n\\n# Approach\\n**proper explanation**\\n         nums = a, b, c, d ( a < b < c < d )\\n         if make nums [a, a, a, a] remove beans (b - a) + (c - a) + (d - a) == b + c + d - 3a\\n         if make nums [0, b, b, b] remove beans a + (c - b) + (d - b) == a + c + d - 2b\\n         if make nums [0, 0, c, c] remove beans a + b + (d - c) == a + b + d - c\\n         if make nums [0, 0, 0, d] remove beans a + b + c\\n\\n         b + c + d - 3a == (a + b + c + d) - 4a\\n         a + c + d - 2b == (a + b + c + d) - 3b\\n         a + b + d -c == (a + b + c + d) - 2c\\n         a + b + c == (a + b + c + d) - d\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n\\n        \\n\\n        long sum=0;\\n        Arrays.sort(beans);\\n        long ans=Long.MAX_VALUE;\\n\\n        for(int i:beans){\\n            sum+=i;\\n        }\\n\\n        long m=beans.length;\\n\\n        for(int i=0;i<beans.length;i++){\\n            ans=Math.min(sum-m*beans[i],ans);\\n            m--;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n\\n        \\n\\n        long sum=0;\\n        Arrays.sort(beans);\\n        long ans=Long.MAX_VALUE;\\n\\n        for(int i:beans){\\n            sum+=i;\\n        }\\n\\n        long m=beans.length;\\n\\n        for(int i=0;i<beans.length;i++){\\n            ans=Math.min(sum-m*beans[i],ans);\\n            m--;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980073,
                "title": "just-one-observation-easy",
                "content": "\\n\\n# Approach\\nStore the given array in a new array and sort the new array.\\nNow apply prefix sum on the new array.\\nNow one by one check every element.\\n\\n# Complexity\\n- Time complexity:\\no(nlogn)\\n- Space complexity:\\no(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long minimumRemoval(vector<int>& beans) {\\n        long long ans=LONG_MAX;\\n        sort(beans.begin(),beans.end());\\n\\n        int n=beans.size();\\n\\n       vector<long long >arr(n);\\n       for(int i=0;i<n;i++)\\n       {\\n           arr[i]=beans[i];\\n       }\\n\\n       for(int i=1;i<n;i++)\\n       {\\n           arr[i]+=arr[i-1];\\n       }\\n\\n      long long   pre=0;\\n      long long  next=0;\\n       for(int i=0;i<n;i++)\\n       {\\n           if(i==0)\\n           pre=0;\\n           else\\n           pre=arr[i-1];\\n\\n          if(i==n-1)\\n          next=0;\\n          else\\n          next=(long long)(arr[n-1]-arr[i]-(long long)(n-i-1)*beans[i]);\\n\\n          if(ans>(pre+next))\\n          ans=(pre+next);\\n\\n       }\\n\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long minimumRemoval(vector<int>& beans) {\\n        long long ans=LONG_MAX;\\n        sort(beans.begin(),beans.end());\\n\\n        int n=beans.size();\\n\\n       vector<long long >arr(n);\\n       for(int i=0;i<n;i++)\\n       {\\n           arr[i]=beans[i];\\n       }\\n\\n       for(int i=1;i<n;i++)\\n       {\\n           arr[i]+=arr[i-1];\\n       }\\n\\n      long long   pre=0;\\n      long long  next=0;\\n       for(int i=0;i<n;i++)\\n       {\\n           if(i==0)\\n           pre=0;\\n           else\\n           pre=arr[i-1];\\n\\n          if(i==n-1)\\n          next=0;\\n          else\\n          next=(long long)(arr[n-1]-arr[i]-(long long)(n-i-1)*beans[i]);\\n\\n          if(ans>(pre+next))\\n          ans=(pre+next);\\n\\n       }\\n\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797192,
                "title": "c-prefix-sum-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nApproach:Prefix Sum\\n\\n# Complexity\\n\\nT.C.=T.C. for sorting the array+T.C. for calculating prefix Sum +T.C. for calculating suffix sum+T.C. for calculating beans to be removed\\nT.C.=O(nlog(n))+O(n)+O(n)+O(n)\\nOverall T.C.=O(nlogn)\\n\\n- Space complexity:\\nO(2n)=O(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MinimumRemoval(int[] beans) \\n    {\\n     long[] prefixSum=new long[beans.Length];\\n     long[] suffixSum=new long[beans.Length];\\n     long  n=beans.Length;\\n     long ans=long.MaxValue;\\n     \\n     if(n==1)\\n     {\\n         return 0;\\n     }\\n     Array.Sort(beans);\\n     \\n     //Build prefixSum array\\n     prefixSum[0]=beans[0];\\n     for(long i=1;i<n;i++)    \\n     {\\n         prefixSum[i]=prefixSum[i-1]+beans[i];\\n     }\\n\\n   \\n     \\n     //Build SuffixSum array\\n     suffixSum[n-1]=beans[n-1];\\n     for(long i=n-2;i>=0;i--)\\n     {\\n         suffixSum[i]=suffixSum[i+1]+beans[i];\\n     }\\n    \\n    //Traverse the beans array and calculate the no of beans required to be removed for each magic bag\\n  \\n   long beanCount=0;\\n     for(long i=0;i<beans.Length;i++)\\n     {\\n         if(i==0)\\n         {\\n             beanCount=suffixSum[i+1]-(n-i-1)*beans[i];\\n         }\\n         else if(i==n-1)\\n         {\\n             beanCount=prefixSum[i-1];\\n         }\\n         else\\n         {\\n             beanCount=prefixSum[i-1]+suffixSum[i+1]-(n-i-1)*beans[i];\\n         }\\n\\n         ans=Math.Min(ans,beanCount);\\n     }\\n     return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long MinimumRemoval(int[] beans) \\n    {\\n     long[] prefixSum=new long[beans.Length];\\n     long[] suffixSum=new long[beans.Length];\\n     long  n=beans.Length;\\n     long ans=long.MaxValue;\\n     \\n     if(n==1)\\n     {\\n         return 0;\\n     }\\n     Array.Sort(beans);\\n     \\n     //Build prefixSum array\\n     prefixSum[0]=beans[0];\\n     for(long i=1;i<n;i++)    \\n     {\\n         prefixSum[i]=prefixSum[i-1]+beans[i];\\n     }\\n\\n   \\n     \\n     //Build SuffixSum array\\n     suffixSum[n-1]=beans[n-1];\\n     for(long i=n-2;i>=0;i--)\\n     {\\n         suffixSum[i]=suffixSum[i+1]+beans[i];\\n     }\\n    \\n    //Traverse the beans array and calculate the no of beans required to be removed for each magic bag\\n  \\n   long beanCount=0;\\n     for(long i=0;i<beans.Length;i++)\\n     {\\n         if(i==0)\\n         {\\n             beanCount=suffixSum[i+1]-(n-i-1)*beans[i];\\n         }\\n         else if(i==n-1)\\n         {\\n             beanCount=prefixSum[i-1];\\n         }\\n         else\\n         {\\n             beanCount=prefixSum[i-1]+suffixSum[i+1]-(n-i-1)*beans[i];\\n         }\\n\\n         ans=Math.Min(ans,beanCount);\\n     }\\n     return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784686,
                "title": "100-time-and-space-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} beans\\n * @return {number}\\n */\\n // time complexity -> O(NlogN) and Space is O(logN) due to sorting. \\n var minimumRemoval = function(beans) {\\n    beans.sort((a, b) => a - b);\\n    let frontSum = beans.reduce((sum , a) => sum + a, 0);\\n    let backSum = 0;\\n    let done = 0;\\n    let result = Number.MAX_SAFE_INTEGER;\\n    for(let j = beans.length - 1; j >= 0; j--){\\n        frontSum -= beans[j];\\n        count = frontSum + (backSum - (beans[j] * done));\\n        result = Math.min(result, count);\\n        done++;\\n        backSum += beans[j];\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} beans\\n * @return {number}\\n */\\n // time complexity -> O(NlogN) and Space is O(logN) due to sorting. \\n var minimumRemoval = function(beans) {\\n    beans.sort((a, b) => a - b);\\n    let frontSum = beans.reduce((sum , a) => sum + a, 0);\\n    let backSum = 0;\\n    let done = 0;\\n    let result = Number.MAX_SAFE_INTEGER;\\n    for(let j = beans.length - 1; j >= 0; j--){\\n        frontSum -= beans[j];\\n        count = frontSum + (backSum - (beans[j] * done));\\n        result = Math.min(result, count);\\n        done++;\\n        backSum += beans[j];\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3765497,
                "title": "sorting-one-pass",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n       sort(beans.begin(),beans.end());\\n       int n = beans.size();\\n       long long sum = 0, ans = 1e18;\\n        for(auto it : beans) \\n          sum += it;\\n        for(int i=0; i<n; i++) \\n          ans = min(ans,sum - 1LL*beans[i]*(n-i));\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n       sort(beans.begin(),beans.end());\\n       int n = beans.size();\\n       long long sum = 0, ans = 1e18;\\n        for(auto it : beans) \\n          sum += it;\\n        for(int i=0; i<n; i++) \\n          ans = min(ans,sum - 1LL*beans[i]*(n-i));\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757468,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n        int n=beans.length;\\n        Arrays.sort(beans);\\n        long ans=Long.MAX_VALUE;\\n        long sum=0;\\n        for(int i:beans)sum+=(long)i;\\n        for(int i=0;i<n;i++)\\n        {\\n            long diff=sum-(long)beans[i]-(n-i-1)*(long)beans[i];\\n            ans=Math.min(ans,diff);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n        int n=beans.length;\\n        Arrays.sort(beans);\\n        long ans=Long.MAX_VALUE;\\n        long sum=0;\\n        for(int i:beans)sum+=(long)i;\\n        for(int i=0;i<n;i++)\\n        {\\n            long diff=sum-(long)beans[i]-(n-i-1)*(long)beans[i];\\n            ans=Math.min(ans,diff);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747458,
                "title": "simple-solution-using-sorting-and-prefix-sum",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long long totalSum = accumulate(beans.begin(), beans.end(), (long long)0);\\n        sort(beans.begin(), beans.end());\\n        long long res = LLONG_MAX;\\n        long long x = 0;\\n\\n        for (int i = 0; i < beans.size(); i++) {\\n            if (i > 0 && beans[i] == beans[i - 1]) {\\n                continue;\\n            }\\n            x = totalSum - (beans[i] * (beans.size() - i));\\n            res = min(res, x);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long long totalSum = accumulate(beans.begin(), beans.end(), (long long)0);\\n        sort(beans.begin(), beans.end());\\n        long long res = LLONG_MAX;\\n        long long x = 0;\\n\\n        for (int i = 0; i < beans.size(); i++) {\\n            if (i > 0 && beans[i] == beans[i - 1]) {\\n                continue;\\n            }\\n            x = totalSum - (beans[i] * (beans.size() - i));\\n            res = min(res, x);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728552,
                "title": "o-nlgn-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(),beans.end(),greater<int>());\\n        vector<long long> v(beans.size(),0);\\n        v[0]=0;\\n        for(int i=1;i<beans.size();i++)\\n            v[i]=i*1LL*(beans[i-1]-beans[i])+v[i-1];\\n        long long t=0,util=beans[beans.size()-1],past=0;\\n        for(int i=v.size()-2;i>=0;i--){\\n            if(beans[i]==beans[i+1])\\n                v[i]+=past;\\n            \\n            else\\n                v[i]+=util,past=util;\\n\\n             util+=beans[i];\\n\\n        \\n        }\\n        return *min_element(v.begin(),v.end());\\n     \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(),beans.end(),greater<int>());\\n        vector<long long> v(beans.size(),0);\\n        v[0]=0;\\n        for(int i=1;i<beans.size();i++)\\n            v[i]=i*1LL*(beans[i-1]-beans[i])+v[i-1];\\n        long long t=0,util=beans[beans.size()-1],past=0;\\n        for(int i=v.size()-2;i>=0;i--){\\n            if(beans[i]==beans[i+1])\\n                v[i]+=past;\\n            \\n            else\\n                v[i]+=util,past=util;\\n\\n             util+=beans[i];\\n\\n        \\n        }\\n        return *min_element(v.begin(),v.end());\\n     \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688026,
                "title": "simple-c-solution-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        map<long long,long long>m;\\n        long long sum=0;\\n        long long operations=1e15;\\n        for(int i=0;i<beans.size();i++){\\n            sum=sum+beans[i];\\n            if(m.find(beans[i])==m.end()){\\n                m.insert({beans[i],1});\\n            }\\n            else{\\n                auto it=m.find(beans[i]);\\n                it->second=it->second+1;\\n            }\\n        }\\n        long long till=0;\\n        long long left=beans.size();\\n        while(m.size()!=0){\\n            auto it=m.begin();\\n            long long op1=0;\\n            op1=till+abs(sum-left*(it->first));\\n            operations=min(operations,op1);\\n            till=till+it->first*it->second;\\n            left=left-it->second;\\n            sum=sum-(it->second*it->first);\\n            m.erase(it->first);\\n        }\\n        return operations;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        map<long long,long long>m;\\n        long long sum=0;\\n        long long operations=1e15;\\n        for(int i=0;i<beans.size();i++){\\n            sum=sum+beans[i];\\n            if(m.find(beans[i])==m.end()){\\n                m.insert({beans[i],1});\\n            }\\n            else{\\n                auto it=m.find(beans[i]);\\n                it->second=it->second+1;\\n            }\\n        }\\n        long long till=0;\\n        long long left=beans.size();\\n        while(m.size()!=0){\\n            auto it=m.begin();\\n            long long op1=0;\\n            op1=till+abs(sum-left*(it->first));\\n            operations=min(operations,op1);\\n            till=till+it->first*it->second;\\n            left=left-it->second;\\n            sum=sum-(it->second*it->first);\\n            m.erase(it->first);\\n        }\\n        return operations;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674428,
                "title": "python-solution-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nMy initial response after seeing this question was to sort and pass through the array, making the appropriate changes as we go. However, duplicate values were fairly annoying to deal with, so I decided to use a dictionary instead. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Find the frequency of each value in the list. \\n2. Sort the keys of the dictionary. This will be the order in which we try different final bean values. Although the runtime is still technically NlogN, this should be empirically faster because we are only sorting the keys, which can be fewer than the number of elements in the original list. \\n3. At the start, we assume that all the bags are reduced to 0. \\n4. As we progress through the keys, we modify the number of beans we actually remove to keep all bags at either that key or 0. \\n5. We constantly update the best variable and can return it at the end. \\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minimumRemoval(self, beans):\\n        \"\"\"\\n        :type beans: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        freqs = {}\\n        best = 0\\n        for bean in beans:\\n            freqs[bean] = freqs.get(bean, 0) + 1\\n            best += bean\\n        \\n        keys = sorted(freqs.keys())\\n\\n        reduced = best\\n        remaining = len(beans) # number of bags with 0 or more beans\\n        prev = 0 # previous bean count goal\\n\\n        # Essentially, we choose each key as the goal to have all the bags at, and see how many beans must be removed to reach that state\\n        for key in keys:\\n            reduced -= remaining * (key - prev) \\n            best = min(best, reduced)\\n            reduced += key * freqs[key]\\n            remaining -= freqs[key]\\n            prev = key\\n        \\n        return best # Return the scenario which requires the fewest removals\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumRemoval(self, beans):\\n        \"\"\"\\n        :type beans: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        freqs = {}\\n        best = 0\\n        for bean in beans:\\n            freqs[bean] = freqs.get(bean, 0) + 1\\n            best += bean\\n        \\n        keys = sorted(freqs.keys())\\n\\n        reduced = best\\n        remaining = len(beans) # number of bags with 0 or more beans\\n        prev = 0 # previous bean count goal\\n\\n        # Essentially, we choose each key as the goal to have all the bags at, and see how many beans must be removed to reach that state\\n        for key in keys:\\n            reduced -= remaining * (key - prev) \\n            best = min(best, reduced)\\n            reduced += key * freqs[key]\\n            remaining -= freqs[key]\\n            prev = key\\n        \\n        return best # Return the scenario which requires the fewest removals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668910,
                "title": "easy-c-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(),beans.end());\\n        long long prev = 0;\\n        long long res = LONG_MAX;\\n        long long tsum = 0;\\n        for(int i=0 ; i<beans.size() ; i++){\\n            tsum+=beans[i];\\n        }\\n        int n = beans.size();\\n        for(int i=0 ; i<beans.size() ; i++){\\n     \\n            long long x = n-i;\\n            long long z = beans[i];\\n            long long post = tsum-(x*z);\\n            res = min(res,post+prev);\\n            prev+=beans[i];\\n            tsum-=beans[i];\\n            \\n        }\\n\\n      \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(),beans.end());\\n        long long prev = 0;\\n        long long res = LONG_MAX;\\n        long long tsum = 0;\\n        for(int i=0 ; i<beans.size() ; i++){\\n            tsum+=beans[i];\\n        }\\n        int n = beans.size();\\n        for(int i=0 ; i<beans.size() ; i++){\\n     \\n            long long x = n-i;\\n            long long z = beans[i];\\n            long long post = tsum-(x*z);\\n            res = min(res,post+prev);\\n            prev+=beans[i];\\n            tsum-=beans[i];\\n            \\n        }\\n\\n      \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667055,
                "title": "best-and-easiest-solution-full-explanation-prefix-sum",
                "content": "# Intuition\\nMy first thought was if any number X(which is present in beans) is the required answer then following 2 oberservations can be found :\\n\\nValues smaller than X, they all must be equal to 0.\\nValues larger than X, they all mush be equal to X.\\n\\nfor value<X, we just need to add value to the answer.\\nand for value>=X, we just need to add value \\u2212 X to the answer.\\n\\n# Approach\\n1.Sort(beans)\\n2.Initialize sum with sum of elements in beans.\\n3.Initialize ans with maximum value possible.\\n4.for each i belongs to beans, ans=min(ans,sum\\u2212beans[i]\\u2217(n\\u2212i))\\n5.Return ans.\\n\\n# Complexity\\n- Time complexity:\\nAs the array beansbeansbeans is not sorted, so we have to sort it first, it will take O(nlongn) and all other operations happening in O(n)\\n\\n- Space complexity:\\nAs we see, we are not using any extra array or recursion stack here so overall space complexity will be O(1)\\n\\n# Code\\n```\\n/*\\nfor Left Part (values<X) === pre[i\\u22121].\\nfor Right Part (values>=X) === (pre[n\\u22121] \\u2212 pre[i]) \\u2212 beans[i]\\u2217(n\\u2212i\\u22121)\\n\\nAs we need LeftPart + RightPart\\n= pre[i\\u22121] + (pre[n\\u22121]\\u2212pre[i])\\u2212beans[i]\\u2217(n\\u2212i\\u22121)\\n= (pre[i\\u22121] + beans[i] + pre[n\\u22121] \\u2212 pre[i]) \\u2212 beans[i] \\u2212 beans[i] \\u2217 (n\\u2212i\\u22121)\\n= sum \\u2212 beans[i] \\u2217 (1+n\\u2212i\\u22121)\\n= sum \\u2212 beans[i] \\u2217 (n\\u2212i)\\n*/\\n\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(), beans.end());\\n\\n        long long n = beans.size();\\n        long long sum = 0;\\n\\n        for(long long i : beans){\\n            sum += i;\\n        }\\n\\n        long long ans = LLONG_MAX;\\n\\n        for(int i=0; i<n; i++){\\n            ans = min(ans, sum - (n - i) * beans[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\n/*\\nfor Left Part (values<X) === pre[i\\u22121].\\nfor Right Part (values>=X) === (pre[n\\u22121] \\u2212 pre[i]) \\u2212 beans[i]\\u2217(n\\u2212i\\u22121)\\n\\nAs we need LeftPart + RightPart\\n= pre[i\\u22121] + (pre[n\\u22121]\\u2212pre[i])\\u2212beans[i]\\u2217(n\\u2212i\\u22121)\\n= (pre[i\\u22121] + beans[i] + pre[n\\u22121] \\u2212 pre[i]) \\u2212 beans[i] \\u2212 beans[i] \\u2217 (n\\u2212i\\u22121)\\n= sum \\u2212 beans[i] \\u2217 (1+n\\u2212i\\u22121)\\n= sum \\u2212 beans[i] \\u2217 (n\\u2212i)\\n*/\\n\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(), beans.end());\\n\\n        long long n = beans.size();\\n        long long sum = 0;\\n\\n        for(long long i : beans){\\n            sum += i;\\n        }\\n\\n        long long ans = LLONG_MAX;\\n\\n        for(int i=0; i<n; i++){\\n            ans = min(ans, sum - (n - i) * beans[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651028,
                "title": "solution-with-intuitions-and-explanation-with-images-tc-o-n-logn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought was if any number $$X$$ (which is present in beans) is the required answer then following 2 oberservations can be found :\\n1. Values smaller than X, they all must be equal to 0.\\n2. Values larger than X, they all must be equal to X.\\n\\nSo, for $$value < X$$, we just need to add value to the answer.\\nand for $$value >= X$$, we just need to add $$value - X$$ to the answer.\\n\\n![Untitled Page.png](https://assets.leetcode.com/users/images/35df6de4-1c45-433b-9587-c5bf8b2d20d0_1687065245.5907645.png)\\n\\nHere, we need prefix sum (here i refer as $$pre[i]$$),\\nfor Left Part $$(values < X)$$, it will be $$pre[i-1]$$.\\nfor Right Part $$(values >= X)$$, it will be $$(pre[n-1] - pre[i]) - beans[i] * (n-i-1)$$.\\n\\nBut if we do some maths here, we found out we actually don\\'t need prefix sum.\\nAs we need $$Left Part + Right Part$$\\n    = $$pre[i-1]$$ + $$(pre[n-1] - pre[i]) - beans[i] * (n - i - 1)$$\\n    = $$(pre[i-1] + beans[i] + pre[n-1] - pre[i]) - beans[i] - beans[i]*(n-i-1)$$\\n    = $$sum - beans[i] * (1 + n-i-1)$$\\n    = $$sum - beans[i] * (n - i)$$\\n\\nSo, we find this value for each $$beans[i]$$ $$(0 <= i < n)$$ and take the minimum value among it.\\n\\nNOTE : \\n1. We can do this in O(n) overall complexity only if we have sorted $$beans$$ array. So we have to sort the array first.\\n2. Here, $$n$$ refers to number of elements in $$beans$$.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort(beans)\\n2. Initialize sum with sum of elements in beans.\\n3. Initialize ans with maximum value possible.\\n4. for each $$i$$ belongs to beans, $$ans = min(ans, sum - beans[i] * (n-i))$$\\n5. Return ans.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs the array $$beans$$ is not sorted, so we have to sort it first, it will take $$O(nlongn)$$ and all other operations happening in $$O(n)$$\\n\\nSo, Overall Time Complexity will be $$O(nlogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAs we see, we are not using any extra array or recursion stack here so overall space complexity will be $$O(1)$$.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(), beans.end());\\n        long n = beans.size();\\n\\n        long long sum = 0;\\n        for(long i : beans) sum += i;\\n\\n        long long ans = LLONG_MAX;\\n        for(int i=0 ; i<n ; ++i) ans = min(ans, sum - (n - i) * beans[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(), beans.end());\\n        long n = beans.size();\\n\\n        long long sum = 0;\\n        for(long i : beans) sum += i;\\n\\n        long long ans = LLONG_MAX;\\n        for(int i=0 ; i<n ; ++i) ans = min(ans, sum - (n - i) * beans[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600715,
                "title": "c-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MinimumRemoval(int[] beans) {\\n        Array.Sort(beans);\\n        long sum = 0, min_removals = long.MaxValue;\\n\\n        foreach(var bean in beans)\\n            sum += bean;\\n\\n        for(int idx = 0; idx < beans.Length; idx++)\\n            min_removals = Math.Min(min_removals, sum - (beans.Length - idx) * (long)beans[idx]);\\n\\n        return min_removals;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public long MinimumRemoval(int[] beans) {\\n        Array.Sort(beans);\\n        long sum = 0, min_removals = long.MaxValue;\\n\\n        foreach(var bean in beans)\\n            sum += bean;\\n\\n        for(int idx = 0; idx < beans.Length; idx++)\\n            min_removals = Math.Min(min_removals, sum - (beans.Length - idx) * (long)beans[idx]);\\n\\n        return min_removals;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556334,
                "title": "easy-cpp-simple-prefix-sum",
                "content": "class Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans)\\n    {\\n        long long l=0,r=0,n=beans.size();\\n        sort(beans.begin(),beans.end());\\n        \\n        for(int i=0;i<n;i++)\\n            l=l+(long long)beans[i];\\n        \\n        long long ans=LONG_LONG_MAX;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            l=l-(long long)beans[i];\\n            ans=min(ans,l+(r-(long long)beans[i]*(n-i-1)));\\n            r=r+(long long)beans[i];\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans)\\n    {\\n        long long l=0,r=0,n=beans.size();\\n        sort(beans.begin(),beans.end());\\n        \\n        for(int i=0;i<n;i++)\\n            l=l+(long long)beans[i];\\n        \\n        long long ans=LONG_LONG_MAX;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            l=l-(long long)beans[i];\\n            ans=min(ans,l+(r-(long long)beans[i]*(n-i-1)));\\n            r=r+(long long)beans[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3542878,
                "title": "8-lines-simple-prefix-array-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long long n=beans.size();\\n        sort(beans.begin(),beans.end());\\n        vector<long long>pre(n,0);\\n        pre[0]=beans[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+beans[i];\\n        }\\n        long long ans=1e14;\\n        for(int i=0;i<beans.size();i++){\\n            ans=min(ans,pre[n-1]-((n-i)*beans[i]));\\n        }\\n        return ans;\\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long long n=beans.size();\\n        sort(beans.begin(),beans.end());\\n        vector<long long>pre(n,0);\\n        pre[0]=beans[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+beans[i];\\n        }\\n        long long ans=1e14;\\n        for(int i=0;i<beans.size();i++){\\n            ans=min(ans,pre[n-1]-((n-i)*beans[i]));\\n        }\\n        return ans;\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513256,
                "title": "python3-heap",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRemoval(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        sm=sum(nums)\\n        ans=inf\\n        add=0\\n        \\n        heap=[val for val in nums]\\n        heapify(heap)\\n        \\n        while heap:\\n            \\n            mini=heap[0]\\n            d=add\\n            d+=(sm-mini)-(n-1)*mini\\n            \\n            ans=min(ans,d)\\n            \\n            sm-=mini\\n            n-=1\\n            add+=mini\\n            heappop(heap)\\n            \\n            \\n            \\n        return ans\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRemoval(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        sm=sum(nums)\\n        ans=inf\\n        add=0\\n        \\n        heap=[val for val in nums]\\n        heapify(heap)\\n        \\n        while heap:\\n            \\n            mini=heap[0]\\n            d=add\\n            d+=(sm-mini)-(n-1)*mini\\n            \\n            ans=min(ans,d)\\n            \\n            sm-=mini\\n            n-=1\\n            add+=mini\\n            heappop(heap)\\n            \\n            \\n            \\n        return ans\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493308,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `beans`\\n */\\nclass Solution {\\n public:\\n  long long minimumRemoval(vector<int>& beans) {\\n    const int n = static_cast<int>(beans.size());\\n    sort(beans.begin(), beans.end());\\n    long long presums[n + 1];\\n    presums[0] = 0;\\n    for (int i = 0; i < n; ++i) {\\n      presums[i + 1] = presums[i] + beans[i];\\n    }\\n    \\n    long long ret = numeric_limits<long long>::max();\\n    for (int i = 0; i < n; ++i) {\\n      ret = min(ret, presums[i] + ((presums[n] - presums[i]) - static_cast<long long>(beans[i]) * (n - i)));\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `beans`\\n */\\nclass Solution {\\n public:\\n  long long minimumRemoval(vector<int>& beans) {\\n    const int n = static_cast<int>(beans.size());\\n    sort(beans.begin(), beans.end());\\n    long long presums[n + 1];\\n    presums[0] = 0;\\n    for (int i = 0; i < n; ++i) {\\n      presums[i + 1] = presums[i] + beans[i];\\n    }\\n    \\n    long long ret = numeric_limits<long long>::max();\\n    for (int i = 0; i < n; ++i) {\\n      ret = min(ret, presums[i] + ((presums[n] - presums[i]) - static_cast<long long>(beans[i]) * (n - i)));\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417726,
                "title": "c-prefixsum-readable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(Nlog(N))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& b) {\\n        sort(b.begin(),b.end());\\n        long long ans=LONG_MAX;\\n        long long s=0;\\n        long long sum=0;\\n        for(auto x:b) sum+=x;\\n        int n=b.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            s=s+b[i];\\n            long long leftsum=s-b[i];\\n            long long rightsum=(sum-s)-(n-i-1)*1LL*b[i];\\n            ans=min(ans,leftsum+rightsum);\\n        }\\n        return ans;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& b) {\\n        sort(b.begin(),b.end());\\n        long long ans=LONG_MAX;\\n        long long s=0;\\n        long long sum=0;\\n        for(auto x:b) sum+=x;\\n        int n=b.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            s=s+b[i];\\n            long long leftsum=s-b[i];\\n            long long rightsum=(sum-s)-(n-i-1)*1LL*b[i];\\n            ans=min(ans,leftsum+rightsum);\\n        }\\n        return ans;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402900,
                "title": "c-prefix-and-suffix-sum",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(), beans.end());\\n        vector<long long> less(beans.size());\\n        less[0] = beans[0];\\n        for(int i = 1; i < beans.size(); i++) less[i] = less[i-1] + beans[i];\\n        long long best = LLONG_MAX;\\n        for(int i = beans.size() - 1; i >= 0; i--){\\n            while(i > 0 && beans[i] == beans[i-1]) i--;\\n            long long above = less[beans.size()-1] - less[i];\\n            above -= beans[i] * (beans.size()-1-i);\\n            long long below = less[i] - beans[i];\\n            best = min(best, below + above);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(), beans.end());\\n        vector<long long> less(beans.size());\\n        less[0] = beans[0];\\n        for(int i = 1; i < beans.size(); i++) less[i] = less[i-1] + beans[i];\\n        long long best = LLONG_MAX;\\n        for(int i = beans.size() - 1; i >= 0; i--){\\n            while(i > 0 && beans[i] == beans[i-1]) i--;\\n            long long above = less[beans.size()-1] - less[i];\\n            above -= beans[i] * (beans.size()-1-i);\\n            long long below = less[i] - beans[i];\\n            best = min(best, below + above);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394990,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) \\n    {\\n        int n=beans.size();\\n        sort(beans.begin(),beans.end());\\n        long long ans=LLONG_MAX;\\n        long long rightSum=0;\\n        long long leftSum=0;\\n        for (auto it:beans) rightSum+=it;\\n        for (int i=0;i<beans.size();i++)\\n        {\\n            rightSum=rightSum-beans[i];\\n            long long toRemove=(rightSum-(1LL*(n-i-1)*beans[i])+leftSum);\\n            if (toRemove<ans) ans=toRemove;\\n            leftSum+=beans[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) \\n    {\\n        int n=beans.size();\\n        sort(beans.begin(),beans.end());\\n        long long ans=LLONG_MAX;\\n        long long rightSum=0;\\n        long long leftSum=0;\\n        for (auto it:beans) rightSum+=it;\\n        for (int i=0;i<beans.size();i++)\\n        {\\n            rightSum=rightSum-beans[i];\\n            long long toRemove=(rightSum-(1LL*(n-i-1)*beans[i])+leftSum);\\n            if (toRemove<ans) ans=toRemove;\\n            leftSum+=beans[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378443,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:n(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(),beans.end());\\n        ll n=beans.size();\\n        ll ans=LLONG_MAX,res=0,sum=0;\\n        for(auto x:beans)\\n            sum+=x;\\n        for(ll i=0;i<n;i++){\\n            res=sum-(beans[i]*(n-i));\\n            ans=min(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(),beans.end());\\n        ll n=beans.size();\\n        ll ans=LLONG_MAX,res=0,sum=0;\\n        for(auto x:beans)\\n            sum+=x;\\n        for(ll i=0;i<n;i++){\\n            res=sum-(beans[i]*(n-i));\\n            ans=min(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356531,
                "title": "intuitive-sorting-1d-dynamic-programing-time-o-nlogn-space-o-1",
                "content": "# Intuition\\nAfter sorting, A = [1,4,5,6] becomes A = [6,5,4,1].\\nFor each element A[i],  we can either \\n(1) make A[i] to zero, the total cost is \\nA[i] + cost for A[1,..., i- 1] (a sub problem) \\n(2) keep A[i] unchanged, the total cost is \\nsum(A[1,...,i-1]) - beans[i] * (i-1)\\n# Approach\\n1D dynamic programing\\n# Complexity\\n- Time complexity:\\nTotal: O(nlogn)\\nwhere sorting takes O(nlogn), dp costs O(n).\\n\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //zero: dp[i - 1] + beans[i]\\n    //keep unchanged: sum - beans[i] * i\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(), beans.end(), greater<int>());\\n        long long ans = 0, sum = beans[0], dp = 0;\\n        for (int i  = 1; i < beans.size(); i++) {\\n            long long to_take = (long long)beans[i] * (long long)i;\\n            dp = dp + beans[i] < sum -  to_take? dp + beans[i] : sum - to_take;\\n            sum += beans[i]; \\n        }\\n        return dp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //zero: dp[i - 1] + beans[i]\\n    //keep unchanged: sum - beans[i] * i\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(), beans.end(), greater<int>());\\n        long long ans = 0, sum = beans[0], dp = 0;\\n        for (int i  = 1; i < beans.size(); i++) {\\n            long long to_take = (long long)beans[i] * (long long)i;\\n            dp = dp + beans[i] < sum -  to_take? dp + beans[i] : sum - to_take;\\n            sum += beans[i]; \\n        }\\n        return dp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351247,
                "title": "python-sorting-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nwe can count how many beans removed to make number of all of non-empty bags equal to the minimun number of bean of bag,\\nand we can remove the bags which is the minimun number of bean of bag,\\nand repeat previous step again until number of non-empty bags is 1.\\ne.g., beans = [2,10,3,2]\\nsum = 17\\nremoved = 0\\nnonempty = 4\\n1. the minimun number of bean of bag = 2, removed + 10 + 3 - 4 = 9 (make number of all of non-empty bags are equal), then remove the bags which is the minimun number of bean of bag -> removed = 4\\n2. the minimun number of bean of bag = 3, removed + 10 - 3 = 11, then remove the bags which is the minimun number of bean of bag -> removed = 7\\n3.  number of non-empty bags is 1, total beams removed = 7\\n\\'\\'\\'\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        freq = collections.defaultdict(int)\\n        s = 0\\n        for n in beans: \\n            freq[n] += 1\\n            s += n\\n        bags = sorted(freq.keys())\\n        removed, nonEmpty = 0, len(beans)\\n        ans = s\\n        for cur in range(len(bags)-1):\\n            m = bags[cur]\\n            cnt = freq.pop(m)\\n            s -= m * cnt\\n            nonEmpty -= cnt\\n            ans = min(ans, removed + s - nonEmpty * m)\\n            removed += m * cnt\\n        ans = min(ans, removed)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```python\\n\\'\\'\\'\\nwe can count how many beans removed to make number of all of non-empty bags equal to the minimun number of bean of bag,\\nand we can remove the bags which is the minimun number of bean of bag,\\nand repeat previous step again until number of non-empty bags is 1.\\ne.g., beans = [2,10,3,2]\\nsum = 17\\nremoved = 0\\nnonempty = 4\\n1. the minimun number of bean of bag = 2, removed + 10 + 3 - 4 = 9 (make number of all of non-empty bags are equal), then remove the bags which is the minimun number of bean of bag -> removed = 4\\n2. the minimun number of bean of bag = 3, removed + 10 - 3 = 11, then remove the bags which is the minimun number of bean of bag -> removed = 7\\n3.  number of non-empty bags is 1, total beams removed = 7\\n\\'\\'\\'\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        freq = collections.defaultdict(int)\\n        s = 0\\n        for n in beans: \\n            freq[n] += 1\\n            s += n\\n        bags = sorted(freq.keys())\\n        removed, nonEmpty = 0, len(beans)\\n        ans = s\\n        for cur in range(len(bags)-1):\\n            m = bags[cur]\\n            cnt = freq.pop(m)\\n            s -= m * cnt\\n            nonEmpty -= cnt\\n            ans = min(ans, removed + s - nonEmpty * m)\\n            removed += m * cnt\\n        ans = min(ans, removed)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350327,
                "title": "c-sort-clean",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ -->\\n\\n- Space complexity:\\n $$O(1)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& v) {\\n        int n = v.size();\\n        sort(v.begin(), v.end());\\n        \\n\\t\\t//rightSum = total sum of elements, leftSum = 0 at start\\n\\t\\tlong long rightSum = accumulate(v.begin(), v.end(), 0LL), leftSum = 0, res = 1e13;\\n        for(int i=0; i<n; i++){\\n            long long temp = leftSum + rightSum - (n-i)*(long long)v[i];\\n            res = min(res,temp);\\n            leftSum += v[i];\\n            rightSum -= v[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& v) {\\n        int n = v.size();\\n        sort(v.begin(), v.end());\\n        \\n\\t\\t//rightSum = total sum of elements, leftSum = 0 at start\\n\\t\\tlong long rightSum = accumulate(v.begin(), v.end(), 0LL), leftSum = 0, res = 1e13;\\n        for(int i=0; i<n; i++){\\n            long long temp = leftSum + rightSum - (n-i)*(long long)v[i];\\n            res = min(res,temp);\\n            leftSum += v[i];\\n            rightSum -= v[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332805,
                "title": "c-golang-sorting",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long long sum = accumulate(beans.begin(), beans.end(), 0L);\\n        sort(beans.begin(), beans.end());\\n        int n = beans.size();\\n        long long ans = 1e10;\\n        for(int i = 0; i < n; i++) {\\n            ans = min(ans, sum - beans[i] * 1L * (n - i));\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc minimumRemoval(beans []int) int64 {\\n    var sum int64 = 0\\n    for _, bean := range beans {\\n        sum += int64(bean)\\n    }\\n    sort.Ints(beans)\\n    var n int = len(beans)\\n    var ans int64 = 1e10\\n    for i := 0; i < n; i++ {\\n        val := sum - int64(beans[i] * (n - i))\\n        if val < ans {ans = val}\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long long sum = accumulate(beans.begin(), beans.end(), 0L);\\n        sort(beans.begin(), beans.end());\\n        int n = beans.size();\\n        long long ans = 1e10;\\n        for(int i = 0; i < n; i++) {\\n            ans = min(ans, sum - beans[i] * 1L * (n - i));\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc minimumRemoval(beans []int) int64 {\\n    var sum int64 = 0\\n    for _, bean := range beans {\\n        sum += int64(bean)\\n    }\\n    sort.Ints(beans)\\n    var n int = len(beans)\\n    var ans int64 = 1e10\\n    for i := 0; i < n; i++ {\\n        val := sum - int64(beans[i] * (n - i))\\n        if val < ans {ans = val}\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316371,
                "title": "python-sort-explained-w-comments",
                "content": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        total, N, res = sum(beans), len(beans), float(\"inf\")\\n        beans.sort()\\n        for i in range(N):\\n            #If we choose beans[i] to be the number of beans in all non-empty bags,\\n            #we have to change all of the beans before i to 0, and all of the beans after i to beans[i]\\n            #Therefore, we need sum(beans[:i])  +  sum(beans[i:]) - (N-i)*A[i] removals...\\n            #this can be simplified to sum(beans) - (N-i)*beans[i] removals\\n            res = min(res, total - (N-i)*beans[i])\\n        return res\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        total, N, res = sum(beans), len(beans), float(\"inf\")\\n        beans.sort()\\n        for i in range(N):\\n            #If we choose beans[i] to be the number of beans in all non-empty bags,\\n            #we have to change all of the beans before i to 0, and all of the beans after i to beans[i]\\n            #Therefore, we need sum(beans[:i])  +  sum(beans[i:]) - (N-i)*A[i] removals...\\n            #this can be simplified to sum(beans) - (N-i)*beans[i] removals\\n            res = min(res, total - (N-i)*beans[i])\\n        return res\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274303,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(),beans.end());\\n        int n=beans.size();\\n        long long sum=0;\\n        long long curr=0;\\n        long long ans=1e10;\\n        for(int i=0;i<n;i++)\\n        sum+=beans[i];\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            curr=sum-(n-i)*(long long)beans[i];\\n            ans=min(ans,curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(),beans.end());\\n        int n=beans.size();\\n        long long sum=0;\\n        long long curr=0;\\n        long long ans=1e10;\\n        for(int i=0;i<n;i++)\\n        sum+=beans[i];\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            curr=sum-(n-i)*(long long)beans[i];\\n            ans=min(ans,curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269430,
                "title": "java-16ms-beats-100-prefix-sum-logic",
                "content": "# Approach\\n1. [4,1,6,5] The idea is to see how much it would cost the remove all the beans from the bags in order to \"flatten\"/ make equal each bag.\\n2. This process is much more visual when we order the bags: [4,1,6,5] -> [1,4,5,6]\\n3. Iterating over each bag, we can ask \"how much would it cost to make all the other bags equal to this\"\\n    - [1,4,5,6]\\n    - i = 0: In order to make the bags on the right 1, we need to remove (4-1 + 5-1 + 6-1) beans.\\n     This formula can be simplified/cached and deducted as sumOfRightElements - current_element * number_of_right_elemens\\n    eg: 15 - (3*1) = 12. So we need to eliminate 12 beans.\\n                Total = 12\\n    - i = 1. On left side we have 1 bean to eliminate, as we cannot make 1 bean be 4 beans.\\n    On right we have 11 - 2 * 4 = 3 beans.  \\n    Total = 1+3;\\n    - i = 2. Left : 1+4 = 5\\n    Right: 6-5 = 1;\\n    Total = 6;\\n    - i = 3; Left : 1+4+5 = 9.\\n    Right = 0; Total 9.\\n    The min is 4.\\n4. DO NOT APPLY step #3 just like that, but to all the consecutive numbers between min and max.\\n    - eg: a,b,c,d  => The solution might be to lower all numbers to c-1 and eliminate a and b.  \\n5. So count/group the beans into an int[100_001]. Also retain the min and max.\\n6. Iterate from i = min to max.\\n   - Keep track of how many numbers you have parsed so far. This will help to know how many numbers you still have.\\n   - The sum of numbers of the right is totalSum - sumSoFar.\\n    - The numberOfBEans you need to eliminate from right side is sumOnRight - (numberOfRemainingBeans * currentBeanValue)\\n    - The beans on the left will all be eliminated/made 0.\\n7. Return the min of the operations.  \\n\\n# Complexity\\n- Time complexity:$$O(n + max-min)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(100001)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n        long minRemoval = Long.MAX_VALUE;\\n        long totalSum = 0;\\n        int[] count = new int[100_001];\\n        int min = 100_000, max = -1;\\n        int numsEncountered = 0;\\n        for(int bean : beans) {\\n            totalSum += bean;\\n            count[bean]++;\\n            min = Math.min(min, bean);\\n            max = Math.max(max, bean);\\n        }\\n        long currentSum = 0, sumOnRight, toRemoveFromRight;\\n        for (int i = min; i <= max; i++) {\\n            numsEncountered += count[i];\\n            sumOnRight = totalSum - (currentSum + (long)i * count[i]);\\n            toRemoveFromRight = sumOnRight - ((beans.length - numsEncountered) * (long)i);\\n            minRemoval = Math.min(minRemoval, currentSum + toRemoveFromRight);\\n            currentSum += ((long)count[i] * i);\\n        }\\n        return minRemoval;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n        long minRemoval = Long.MAX_VALUE;\\n        long totalSum = 0;\\n        int[] count = new int[100_001];\\n        int min = 100_000, max = -1;\\n        int numsEncountered = 0;\\n        for(int bean : beans) {\\n            totalSum += bean;\\n            count[bean]++;\\n            min = Math.min(min, bean);\\n            max = Math.max(max, bean);\\n        }\\n        long currentSum = 0, sumOnRight, toRemoveFromRight;\\n        for (int i = min; i <= max; i++) {\\n            numsEncountered += count[i];\\n            sumOnRight = totalSum - (currentSum + (long)i * count[i]);\\n            toRemoveFromRight = sumOnRight - ((beans.length - numsEncountered) * (long)i);\\n            minRemoval = Math.min(minRemoval, currentSum + toRemoveFromRight);\\n            currentSum += ((long)count[i] * i);\\n        }\\n        return minRemoval;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254792,
                "title": "c-easy-prefix-sum-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& b) {\\n        if(b.size()==1)\\n        return 0;\\n        sort(b.begin(),b.end());\\n        long long ans = 1e10;\\n        int n = b.size();\\n        vector<long long> pref(n);\\n        pref[0] = b[0];\\n        for(int i=1;i<n;i++)\\n        pref[i] = pref[i-1]+(long long)b[i];\\n        for(int i=0;i<n;i++)\\n        {\\n            long long idx2 = upper_bound(b.begin(),b.end(),b[i])-b.begin();\\n            idx2--;\\n            long long a1=0,b1=0;\\n            if(idx2>=0)\\n            {\\n                a1 = pref[n-1]-pref[idx2];\\n                a1-=(n-(idx2+1))*((long long)b[i]);\\n            }\\n            int idx1 = lower_bound(b.begin(),b.end(),b[i])-b.begin();\\n            if(idx1-1>=0)\\n            {\\n                b1 = pref[idx1-1];\\n            }\\n            long long tmp = a1+b1;\\n            ans = min(ans,tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& b) {\\n        if(b.size()==1)\\n        return 0;\\n        sort(b.begin(),b.end());\\n        long long ans = 1e10;\\n        int n = b.size();\\n        vector<long long> pref(n);\\n        pref[0] = b[0];\\n        for(int i=1;i<n;i++)\\n        pref[i] = pref[i-1]+(long long)b[i];\\n        for(int i=0;i<n;i++)\\n        {\\n            long long idx2 = upper_bound(b.begin(),b.end(),b[i])-b.begin();\\n            idx2--;\\n            long long a1=0,b1=0;\\n            if(idx2>=0)\\n            {\\n                a1 = pref[n-1]-pref[idx2];\\n                a1-=(n-(idx2+1))*((long long)b[i]);\\n            }\\n            int idx1 = lower_bound(b.begin(),b.end(),b[i])-b.begin();\\n            if(idx1-1>=0)\\n            {\\n                b1 = pref[idx1-1];\\n            }\\n            long long tmp = a1+b1;\\n            ans = min(ans,tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230192,
                "title": "c-sorting-easy-to-undersatand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans)\\n    {\\n        sort(beans.begin(),beans.end());\\n        long long n=beans.size();\\n        long long ans=LLONG_MAX,sum=accumulate(beans.begin(),beans.end(),0L);\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(ans,sum-(n-i)*beans[i]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\nIf you like the solution plz  upvote.",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans)\\n    {\\n        sort(beans.begin(),beans.end());\\n        long long n=beans.size();\\n        long long ans=LLONG_MAX,sum=accumulate(beans.begin(),beans.end(),0L);\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(ans,sum-(n-i)*beans[i]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210377,
                "title": "python-time-complexity-o-nlogn-space-o-logn",
                "content": "class Solution(object):\\n    def minimumRemoval(self, beans):\\n        \"\"\"\\n        :type beans: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n        if len(beans) == 1:\\n            return 0\\n        \\n        beans.sort()\\n        set_to_zero = 0\\n        i = 0\\n        total = sum(beans)\\n        res = total\\n        \\n        n = len(beans)\\n        #print beans\\n        while i < n:\\n            if i == 0 or beans[i] != beans[i-1]:\\n                cur = (total - (n-i)*beans[i])\\n\\t\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t\\tAt i, we have removed all the beans till index i-1 and we want to remove\\n\\t\\t\\t\\tany excess beans on the right of i to ensure bean numbers are the same (beans[i])\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tbeans removed so far= (beans[0]+ beans[1]....beans[i-1])\\n\\t\\t\\t\\tbeans to remove such that all remaining bean bags are equal to beans[i] =\\n\\t\\t\\t\\t(beans[i] + beans[i+1] + beans[i+2] .... beans[n-1]) - (n-i)* beans[i]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tSum of them = (beans[0] + beans[1] + beans[2]....beans[i-1]) + (beans[i] + beans[i+1] + beans[i+2] .... beans[n-1]) - (n-i)*beans[i]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t= sum(beans) - (n-i)* beans[i]\\n\\t\\t\\t\\t\\'\\'\\'\\n                #print i, cur\\n                res = min(res, cur)\\n            \\n            i += 1\\n        return res",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution(object):\\n    def minimumRemoval(self, beans):\\n        \"\"\"\\n        :type beans: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n        if len(beans) == 1:\\n            return 0\\n        \\n        beans.sort()\\n        set_to_zero = 0\\n        i = 0\\n        total = sum(beans)\\n        res = total\\n        \\n        n = len(beans)\\n        #print beans\\n        while i < n:\\n            if i == 0 or beans[i] != beans[i-1]:\\n                cur = (total - (n-i)*beans[i])\\n\\t\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t\\tAt i, we have removed all the beans till index i-1 and we want to remove\\n\\t\\t\\t\\tany excess beans on the right of i to ensure bean numbers are the same (beans[i])\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tbeans removed so far= (beans[0]+ beans[1]....beans[i-1])\\n\\t\\t\\t\\tbeans to remove such that all remaining bean bags are equal to beans[i] =\\n\\t\\t\\t\\t(beans[i] + beans[i+1] + beans[i+2] .... beans[n-1]) - (n-i)* beans[i]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tSum of them = (beans[0] + beans[1] + beans[2]....beans[i-1]) + (beans[i] + beans[i+1] + beans[i+2] .... beans[n-1]) - (n-i)*beans[i]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t= sum(beans) - (n-i)* beans[i]\\n\\t\\t\\t\\t\\'\\'\\'\\n                #print i, cur\\n                res = min(res, cur)\\n            \\n            i += 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 3207286,
                "title": "prefix-sum-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n        int n = beans.length;\\n        long[] left = new long[n];\\n        long[] right = new long[n];\\n        Arrays.sort(beans);\\n        left[0] = 0;\\n        right[n-1] = 0;\\n        for(int i=1;i<n;i++){\\n            left[i] = left[i-1]+beans[i-1];\\n        }\\n        long cnt=beans[n-1];\\n        long j=1;\\n        for(int i=n-2;i>=0;i--){\\n            right[i] = cnt-(j*beans[i]);\\n            cnt+=beans[i];\\n            j++;\\n        }\\n        long min = Long.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            min = Math.min(min,left[i]+right[i]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n        int n = beans.length;\\n        long[] left = new long[n];\\n        long[] right = new long[n];\\n        Arrays.sort(beans);\\n        left[0] = 0;\\n        right[n-1] = 0;\\n        for(int i=1;i<n;i++){\\n            left[i] = left[i-1]+beans[i-1];\\n        }\\n        long cnt=beans[n-1];\\n        long j=1;\\n        for(int i=n-2;i>=0;i--){\\n            right[i] = cnt-(j*beans[i]);\\n            cnt+=beans[i];\\n            j++;\\n        }\\n        long min = Long.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            min = Math.min(min,left[i]+right[i]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173789,
                "title": "python-just-math-to-calcuate-beans-to-remove-if-keep-each-bag-untouched",
                "content": "Start from the bags with the smallest number of beans.\\n\\nFor each bag, we calculate how many beans we need to remove if the final bean number equal to this bag.\\n(1) all the bags with smaller beans have to be empty\\n(2) all the bags with larger number of beans need to remove the difference\\n\\nAfter iterating all the bags with the above calculation, we can get the min number of beans that should be removed.\\n\\n```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        # sort the beans array\\n        beans.sort()\\n        # calcuate the sum of difference to the first bag\\n        diff_sum = 0\\n        for b in beans:\\n            diff_sum += (b - beans[0])\\n\\n        len_b = len(beans)\\n        if len_b == 1:\\n            return 0\\n\\n        # default answer\\n        ans = float(\\'inf\\')\\n\\n        # running sum from index 0\\n        rs = 0\\n        prev_bean, idx = beans[0], 0\\n        while idx < len_b:\\n            # update the diff sum based on current bean bag index and the difference between two bags\\n            diff_sum -= (beans[idx] - prev_bean) * (len_b - idx)\\n            total_removes = rs + diff_sum\\n            ans = min(ans, total_removes)\\n\\n            prev_bean = beans[idx]\\n            while idx < len_b and beans[idx] == prev_bean:\\n                rs += beans[idx]\\n                idx += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        # sort the beans array\\n        beans.sort()\\n        # calcuate the sum of difference to the first bag\\n        diff_sum = 0\\n        for b in beans:\\n            diff_sum += (b - beans[0])\\n\\n        len_b = len(beans)\\n        if len_b == 1:\\n            return 0\\n\\n        # default answer\\n        ans = float(\\'inf\\')\\n\\n        # running sum from index 0\\n        rs = 0\\n        prev_bean, idx = beans[0], 0\\n        while idx < len_b:\\n            # update the diff sum based on current bean bag index and the difference between two bags\\n            diff_sum -= (beans[idx] - prev_bean) * (len_b - idx)\\n            total_removes = rs + diff_sum\\n            ans = min(ans, total_removes)\\n\\n            prev_bean = beans[idx]\\n            while idx < len_b and beans[idx] == prev_bean:\\n                rs += beans[idx]\\n                idx += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167184,
                "title": "easy-sorting-prefix-sum-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe final number of beans in each non zero bag should be always equal to one of initial beans bag size , otherwise it\\'s not the optimal solution .\\nSo for each bean bag try to find the cost to make all the other bean bags size equal it\\'s size. The smaller bean bags will be made removed and larger bean bags will be trimmed to it\\'s height. So the minimum cost will be the solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the beans size as it will help in calculation of removing smaller bean bags .\\n2. Calculate the prefix sum from both left & right .\\n3. For each bean calc cost = cost to remove all smaller bean bags+ cost to trim all larger bean bags \\n4. return the minimum cost \\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long minimumRemoval(vector<int>& beans) {\\n        \\n        sort(beans.begin(),beans.end());\\n    \\n        int n=beans.size();\\n        vector<long long> leftSum(n,0),rightSum(n,0);\\n        \\n        for(int i=1;i<n;i++){\\n            leftSum[i]=leftSum[i-1]+beans[i-1];\\n            rightSum[n-1-i]=rightSum[n-i]+beans[n-i];\\n        }\\n\\n        long long sol=LLONG_MAX,temp;\\n        for(int i=0;i<n;i++){\\n                temp=0;\\n                temp+=leftSum[i];\\n                temp+=(rightSum[i] - ((long long )n-1-i)*(beans[i]) );\\n                sol=min(sol,temp);\\n        }\\n        return sol;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long minimumRemoval(vector<int>& beans) {\\n        \\n        sort(beans.begin(),beans.end());\\n    \\n        int n=beans.size();\\n        vector<long long> leftSum(n,0),rightSum(n,0);\\n        \\n        for(int i=1;i<n;i++){\\n            leftSum[i]=leftSum[i-1]+beans[i-1];\\n            rightSum[n-1-i]=rightSum[n-i]+beans[n-i];\\n        }\\n\\n        long long sol=LLONG_MAX,temp;\\n        for(int i=0;i<n;i++){\\n                temp=0;\\n                temp+=leftSum[i];\\n                temp+=(rightSum[i] - ((long long )n-1-i)*(beans[i]) );\\n                sol=min(sol,temp);\\n        }\\n        return sol;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139619,
                "title": "rust-simple-solution-31-ms-3-3-mb",
                "content": "# Intuition\\nSort the array in increasing order and calculate the difference of maximum of total beans we can have with respect to beans in current bag after the current index `(beans[i] * beans.len() - curr_index)` from total beans.\\n\\nexample: \\ninput = [4, 1, 6, 5]\\n\\nStep 1:\\nSort the array in ascending order. [1, 4, 5, 6]\\n\\nstep 2:\\ni = 0 -> each bag with 1 beans from index 0, so that\\'s 4\\ni = 1 -> each bag with 4 beans from index 1, so that\\'s 12\\ni = 2 -> each bag with 5 beans from index 2, so that\\'s 10\\ni = 3 -> each bag with 6 beans from index 3, so that\\'s 6\\n\\nResult = total beans - max(beans at each index) = 16 - 12 = 4\\nso, answer is 4\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn minimum_removal(mut beans: Vec<i32>) -> i64 {\\n        beans.sort_unstable();\\n\\n        let mut rem: u128 = 0;\\n        let mut bags: u128 = beans.len() as u128;\\n\\n        (beans.into_iter().enumerate().fold(0, |mut total, (i, n)| {\\n            rem = rem.max(n as u128 * (bags - i as u128));\\n            total + n as u128\\n        }) - rem) as i64\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_removal(mut beans: Vec<i32>) -> i64 {\\n        beans.sort_unstable();\\n\\n        let mut rem: u128 = 0;\\n        let mut bags: u128 = beans.len() as u128;\\n\\n        (beans.into_iter().enumerate().fold(0, |mut total, (i, n)| {\\n            rem = rem.max(n as u128 * (bags - i as u128));\\n            total + n as u128\\n        }) - rem) as i64\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3132519,
                "title": "sorting-partial-sum-typescript-o-nlogn-o-1",
                "content": "# Intuition\\n\\nProblem statement:\\n\\n* Some bags may end up empty\\n* Others must have the same number of beans\\n* From all removals achieving such result, pick the one that removes the smallest amount of beans\\n\\nIdeas:\\n\\n1. We have to remove all extra beans from all bags, to hit minimum\\n2. Or empty some bags of the smaller size, to find better minimum\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the bags, this way we can go through every next minimum\\n2. Start with bag i = 0, remove beans from all next bags to match beans[i].\\n3. Completely empty this bag before next iteration.\\n3. Keep the running tail sum, the sum of beans, from completely bags.\\n4. Keep the running removed beans minimum, update it after each iteration.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction minimumRemoval(beans: number[]): number {\\n    const sortedBeans = beans.sort((a, b) => a > b ? 1 : -1);\\n\\n    let minBeans = Infinity;\\n    let currBeans;\\n    let removedTail = 0;\\n    let baseBeans;\\n\\n    let partialSums = [];\\n\\n    for (let i = sortedBeans.length - 1; i >= 0; i -= 1) {\\n        partialSums[i] = sortedBeans[i];\\n\\n        if (partialSums[i + 1]) {\\n            partialSums[i] += partialSums[i + 1];\\n        }\\n    }\\n\\n    for (let i = 0; i < sortedBeans.length; i += 1) {\\n        if (sortedBeans[i] !== 0) {\\n            baseBeans = sortedBeans[i]; // minimum to match\\n            currBeans = removedTail; // beans from emptied bags\\n\\n            // This trick speeds up counting the number of beans we need to remove\\n            if (partialSums[i + 1]) {\\n                currBeans += partialSums[i + 1] - (sortedBeans.length - i - 1) * baseBeans;\\n            }\\n\\n            // Otherwise we can iterate remaining bags, but this is longer\\n            // for (let j = i + 1; j < sortedBeans.length; j += 1 ) {\\n            //     currBeans += sortedBeans[j] - baseBeans;\\n            // }\\n\\n            minBeans = Math.min(currBeans, minBeans);\\n\\n            removedTail += sortedBeans[i];\\n        }\\n    }\\n\\n    return minBeans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Sorting"
                ],
                "code": "```\\nfunction minimumRemoval(beans: number[]): number {\\n    const sortedBeans = beans.sort((a, b) => a > b ? 1 : -1);\\n\\n    let minBeans = Infinity;\\n    let currBeans;\\n    let removedTail = 0;\\n    let baseBeans;\\n\\n    let partialSums = [];\\n\\n    for (let i = sortedBeans.length - 1; i >= 0; i -= 1) {\\n        partialSums[i] = sortedBeans[i];\\n\\n        if (partialSums[i + 1]) {\\n            partialSums[i] += partialSums[i + 1];\\n        }\\n    }\\n\\n    for (let i = 0; i < sortedBeans.length; i += 1) {\\n        if (sortedBeans[i] !== 0) {\\n            baseBeans = sortedBeans[i]; // minimum to match\\n            currBeans = removedTail; // beans from emptied bags\\n\\n            // This trick speeds up counting the number of beans we need to remove\\n            if (partialSums[i + 1]) {\\n                currBeans += partialSums[i + 1] - (sortedBeans.length - i - 1) * baseBeans;\\n            }\\n\\n            // Otherwise we can iterate remaining bags, but this is longer\\n            // for (let j = i + 1; j < sortedBeans.length; j += 1 ) {\\n            //     currBeans += sortedBeans[j] - baseBeans;\\n            // }\\n\\n            minBeans = Math.min(currBeans, minBeans);\\n\\n            removedTail += sortedBeans[i];\\n        }\\n    }\\n\\n    return minBeans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3105806,
                "title": "easy-best-solution-in-c-prefix-suffix-sum",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long minBeans=LONG_MAX,tmp=0,suffixSum=0,prefixSum=0;\\n        int n=beans.size();\\n        sort(beans.begin(),beans.end());\\n        vector<long> vec(n);\\n        for(int i=n-1;i>=0;i--){\\n            suffixSum+=beans[i];\\n            vec[i]=suffixSum;\\n        }\\n        for(int i=0;i<n;i++){\\n            tmp=vec[i]-(long)(n-i)*beans[i];\\n            minBeans=min(tmp+prefixSum,minBeans);\\n            prefixSum+=beans[i];\\n        }\\n        return minBeans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long minBeans=LONG_MAX,tmp=0,suffixSum=0,prefixSum=0;\\n        int n=beans.size();\\n        sort(beans.begin(),beans.end());\\n        vector<long> vec(n);\\n        for(int i=n-1;i>=0;i--){\\n            suffixSum+=beans[i];\\n            vec[i]=suffixSum;\\n        }\\n        for(int i=0;i<n;i++){\\n            tmp=vec[i]-(long)(n-i)*beans[i];\\n            minBeans=min(tmp+prefixSum,minBeans);\\n            prefixSum+=beans[i];\\n        }\\n        return minBeans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070692,
                "title": "python-one-pass-max-heap-easy-to-understand-o-nlogn",
                "content": "# Code\\n```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        h = []\\n        for b in beans:\\n            heappush(h, -b)\\n        res = sum(beans)\\n        cur = res\\n        last = -h[0]\\n        cnt = 0\\n        while h:\\n            b = heappop(h)\\n            b = -b\\n            cur += (last - b)*cnt\\n            cur -= b\\n            res = min(res, cur)\\n            last = b\\n            cnt += 1\\n        return res\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        h = []\\n        for b in beans:\\n            heappush(h, -b)\\n        res = sum(beans)\\n        cur = res\\n        last = -h[0]\\n        cnt = 0\\n        while h:\\n            b = heappop(h)\\n            b = -b\\n            cur += (last - b)*cnt\\n            cur -= b\\n            res = min(res, cur)\\n            last = b\\n            cnt += 1\\n        return res\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007453,
                "title": "no-prefix-sum-easiest-cpp-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        int n=beans.size();\\n        long long sum=0;\\n        sort(beans.begin(),beans.end());\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            sum+=beans[i];\\n        }\\n        long long mini=sum;\\n        for(int i=0;i<n-1;i++){\\n            long long x=sum-(long long)beans[i+1]*(n-1-i);\\n            if(mini>x)mini=x;\\n\\n        }\\n        long long x=sum-(long long)(n)*beans[0];\\n        mini=min(mini,x);\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        int n=beans.size();\\n        long long sum=0;\\n        sort(beans.begin(),beans.end());\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            sum+=beans[i];\\n        }\\n        long long mini=sum;\\n        for(int i=0;i<n-1;i++){\\n            long long x=sum-(long long)beans[i+1]*(n-1-i);\\n            if(mini>x)mini=x;\\n\\n        }\\n        long long x=sum-(long long)(n)*beans[0];\\n        mini=min(mini,x);\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981626,
                "title": "sort",
                "content": "**time: `O(N)`; space: `O(1)`**\\n```\\nlong long minimumRemoval(vector<int>& b)\\n{\\n\\tsort(begin(b), end(b));\\n\\tlong long out{LONG_MAX}, n(size(b)), S{accumulate(begin(b), end(b), 0ll)};\\n\\tfor(int i{}; i<size(b); ++i, --n)\\n\\t\\tout= min(out, S-b[i]*n);\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nlong long minimumRemoval(vector<int>& b)\\n{\\n\\tsort(begin(b), end(b));\\n\\tlong long out{LONG_MAX}, n(size(b)), S{accumulate(begin(b), end(b), 0ll)};\\n\\tfor(int i{}; i<size(b); ++i, --n)\\n\\t\\tout= min(out, S-b[i]*n);\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2970938,
                "title": "java-using-sorting-and-total-sum-time-o-n-log-n-space-o-1",
                "content": "# Approach\\n1. Sort the beans array in acsending order\\n2. Get total number of beans. This is maximum number of beans that can be removed from bags.\\n3. Iterate the array and calculate the number of beans that will stay in the bags and number of beans that will be removed from bags.\\n\\nHow to calcualte beans to be deleted if beans at [i] are kept.\\n- This means beans[i] is minimum beans in a bag, hence bags that contains smaller number of beans than beans[i] will be removed and bags that contains larger number of beans than beans[i] will be reduced by sum of gap between each bags that bigger than beans[i] and beans[i]\\n- So beans that will be removed are sum of following\\n    - total beans that are smaller than beans[i] (smaller bags than beans[i] will be discared)\\n    -  total number beans that should be removed from bigger bags than beans[i]: total number of beans taht are bigger than beans[i] - (beans[i] * number of remaining bags). This can be caluted by (n-1-i) * beans[i]\\n    \\nLet us assume we calcualte prefixSum array in order to find what is remaining value that bigger than beans[i]\\n-> prefixSum[i-1] + total - prefixSum[i] - (n-1-i) * beans[i]\\n-> total - prefixSum[i] + prefixSum[i-1] + (n-1-i) * beans[i]\\n-> total - (prefixSum[i] - prefixSum[i-1]) + (n-1-i) * beans[i]\\n-> total - (beans[i]) + (n-1-i) * beans[i]\\n\\nIt ends up with that we don\\'t need prefix sum array.\\nWe just need total number of beans.\\n\\n# Complexity\\n- Time complexity:\\nO(N * log N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n        public long minimumRemoval(int[] beans) {\\n            int n = beans.length;\\n            Arrays.sort(beans);\\n\\n            long total = 0;\\n            for(int b : beans)\\n                total+=b;\\n\\n            long min = total;\\n\\n            for(int i = 0; i < n; i++){\\n                long cv = total - beans[i] - ((long)(n-1-i)*beans[i]);\\n                min = Math.min(min, cv);\\n            }\\n\\n            return min;\\n        }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public long minimumRemoval(int[] beans) {\\n            int n = beans.length;\\n            Arrays.sort(beans);\\n\\n            long total = 0;\\n            for(int b : beans)\\n                total+=b;\\n\\n            long min = total;\\n\\n            for(int i = 0; i < n; i++){\\n                long cv = total - beans[i] - ((long)(n-1-i)*beans[i]);\\n                min = Math.min(min, cv);\\n            }\\n\\n            return min;\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916592,
                "title": "c-soluton-100-fast-easy-code-riderop",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long long int n = beans.size();\\n        vector<long long int > sum(n, 0);\\n        sort(beans.begin(), beans.end());\\n        for(int i = 0; i< beans.size(); i++)\\n        {\\n            if(i == 0)\\n            {\\n                sum[i] = beans[i];\\n            }\\n            else{\\n                sum[i] = sum[i-1] + beans[i];\\n            }\\n        }\\n        long long ans = LLONG_MAX;\\n        for(int i = 0; i< n; i++)\\n        {\\n            long long int rs = sum[n-1];\\n            long long int val = beans[i] * (n-i);\\n            if(i !=0)\\n            {\\n                rs -= sum[i-1];\\n            }\\n            long long int remove = (rs - val);\\n            if(i!=0)\\n            {\\n                remove += sum[i-1];\\n            }\\n            ans = min(ans, remove);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long long int n = beans.size();\\n        vector<long long int > sum(n, 0);\\n        sort(beans.begin(), beans.end());\\n        for(int i = 0; i< beans.size(); i++)\\n        {\\n            if(i == 0)\\n            {\\n                sum[i] = beans[i];\\n            }\\n            else{\\n                sum[i] = sum[i-1] + beans[i];\\n            }\\n        }\\n        long long ans = LLONG_MAX;\\n        for(int i = 0; i< n; i++)\\n        {\\n            long long int rs = sum[n-1];\\n            long long int val = beans[i] * (n-i);\\n            if(i !=0)\\n            {\\n                rs -= sum[i-1];\\n            }\\n            long long int remove = (rs - val);\\n            if(i!=0)\\n            {\\n                remove += sum[i-1];\\n            }\\n            ans = min(ans, remove);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830271,
                "title": "c-super-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    long long minimumRemoval(vector<int>& B) {\\n        sort(begin(B), end(B));\\n        ll res = LONG_MAX, sum = accumulate(begin(B), end(B), 0LL);\\n        for(int i = 0; i < B.size(); i++) {\\n            if(i > 0 && B[i] == B[i-1]) continue;\\n            res = min(res, sum - B[i]*((ll)B.size()-i));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    long long minimumRemoval(vector<int>& B) {\\n        sort(begin(B), end(B));\\n        ll res = LONG_MAX, sum = accumulate(begin(B), end(B), 0LL);\\n        for(int i = 0; i < B.size(); i++) {\\n            if(i > 0 && B[i] == B[i-1]) continue;\\n            res = min(res, sum - B[i]*((ll)B.size()-i));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746482,
                "title": "sorting-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(), beans.end());\\n        \\n        int n = beans.size();\\n        long long ans = LONG_LONG_MAX;\\n        \\n        long long tsum = 0;\\n        \\n        long long totalSum = 0;\\n        \\n        for (auto bean : beans) {\\n            totalSum += bean;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            long long tres = tsum;\\n            if (i + 1 < n) {\\n               tres += (totalSum - tsum - beans[i]) * 1LL - (beans[i] * 1LL * (n - i - 1));\\n            }\\n            ans = min(ans, tres);\\n            tsum += beans[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(), beans.end());\\n        \\n        int n = beans.size();\\n        long long ans = LONG_LONG_MAX;\\n        \\n        long long tsum = 0;\\n        \\n        long long totalSum = 0;\\n        \\n        for (auto bean : beans) {\\n            totalSum += bean;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            long long tres = tsum;\\n            if (i + 1 < n) {\\n               tres += (totalSum - tsum - beans[i]) * 1LL - (beans[i] * 1LL * (n - i - 1));\\n            }\\n            ans = min(ans, tres);\\n            tsum += beans[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2728872,
                "title": "python-two-lines-solution",
                "content": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        s, n = sum(beans), len(beans)\\n        return s - max((n - i) * b for i, b in enumerate(sorted(beans)))\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        s, n = sum(beans), len(beans)\\n        return s - max((n - i) * b for i, b in enumerate(sorted(beans)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726871,
                "title": "c-easy-with-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long long int sum = 0;\\n        long long int n = beans.size();\\n        sort(beans.begin(), beans.end());\\n        for(long long int i=0;i<n;i++){\\n            sum+=beans[i];\\n        }\\n        long long int temp = sum;\\n        long long int suma = sum;\\n        vector<long long int> pre1;\\n        vector<long long int> suf;\\n        vector<long long int> pre;\\n        for(long long int i=n-1;i>=0;i--){\\n            temp -= beans[i];\\n            pre1.push_back(temp);\\n        }        \\n        for(long long int i=0;i<n;i++){\\n            sum -= beans[i];\\n            suf.push_back(sum);\\n            pre.push_back(pre1[n-1-i]);\\n        }\\n        long long int min = LLONG_MAX;\\n        for(long long int i=0;i<n;i++){\\n            long long int hel = suf[i]-((n-1-i)*beans[i])+pre[i]; \\n            if(min > hel){\\n                min = hel;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        long long int sum = 0;\\n        long long int n = beans.size();\\n        sort(beans.begin(), beans.end());\\n        for(long long int i=0;i<n;i++){\\n            sum+=beans[i];\\n        }\\n        long long int temp = sum;\\n        long long int suma = sum;\\n        vector<long long int> pre1;\\n        vector<long long int> suf;\\n        vector<long long int> pre;\\n        for(long long int i=n-1;i>=0;i--){\\n            temp -= beans[i];\\n            pre1.push_back(temp);\\n        }        \\n        for(long long int i=0;i<n;i++){\\n            sum -= beans[i];\\n            suf.push_back(sum);\\n            pre.push_back(pre1[n-1-i]);\\n        }\\n        long long int min = LLONG_MAX;\\n        for(long long int i=0;i<n;i++){\\n            long long int hel = suf[i]-((n-1-i)*beans[i])+pre[i]; \\n            if(min > hel){\\n                min = hel;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2705404,
                "title": "go-find-biggest-rectangle",
                "content": "```\\nfunc minimumRemoval(beans []int) int64 {\\n    n := len(beans)\\n    sort.Ints(beans)\\n    totalBeans := 0\\n    maximum := math.MinInt64\\n    \\n    for i, bean := range beans {\\n        totalBeans += bean\\n        maximum = max(maximum, bean * (n - i))\\n    }\\n\\n    return int64(totalBeans - maximum)\\n}\\n\\nfunc max (a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumRemoval(beans []int) int64 {\\n    n := len(beans)\\n    sort.Ints(beans)\\n    totalBeans := 0\\n    maximum := math.MinInt64\\n    \\n    for i, bean := range beans {\\n        totalBeans += bean\\n        maximum = max(maximum, bean * (n - i))\\n    }\\n\\n    return int64(totalBeans - maximum)\\n}\\n\\nfunc max (a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2681225,
                "title": "golang-math-sort-solution",
                "content": "```\\nfunc minimumRemoval(s []int) int64 {\\n    sort.Ints(s)\\n    if s[0] == s[len(s)-1] {\\n        return 0\\n    }\\n    bs := 0\\n    for i := range s {\\n        bs += s[i]\\n    }\\n    pr := 0\\n    g := (1<<32)-1\\n    for i := range s {\\n        cv := pr+((bs-pr-s[i])-((len(s)-i-1)*s[i]))\\n        if cv < g { g = cv }\\n        pr += s[i]\\n    }\\n    return int64(g)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minimumRemoval(s []int) int64 {\\n    sort.Ints(s)\\n    if s[0] == s[len(s)-1] {\\n        return 0\\n    }\\n    bs := 0\\n    for i := range s {\\n        bs += s[i]\\n    }\\n    pr := 0\\n    g := (1<<32)-1\\n    for i := range s {\\n        cv := pr+((bs-pr-s[i])-((len(s)-i-1)*s[i]))\\n        if cv < g { g = cv }\\n        pr += s[i]\\n    }\\n    return int64(g)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2680290,
                "title": "c",
                "content": "```\\nint cmpfunc(const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\n\\nlong long minimumRemoval(int* beans, int beansSize){\\n    int n = beansSize;\\n    if(n == 1)\\n        return 0;\\n    qsort(beans, n, sizeof(int), cmpfunc);\\n    long long* prefix = malloc( n * sizeof(long long));\\n    long long* suffix = malloc( n * sizeof(long long));\\n    prefix[0] = beans[0];\\n    for(int i = 1; i < n; i++){\\n        prefix[i] = prefix[i-1] + beans[i];\\n    }\\n    \\n    suffix[n-1] = beans[n-1];\\n    for(int i = n-2; i >=0; i--){\\n        suffix[i] = suffix[i+1] + beans[i];\\n    }\\n    \\n    long long ans = LONG_MAX;\\n    \\n    ans = suffix[1] - (long long)beans[0]*(n-1);\\n\\n    for(int i = 1; i < (n - 1); i++){\\n        if(beans[i] == beans[i-1])\\n            continue;\\n        long long temp = prefix[i-1] + suffix[i] - (long long)(n -i)*beans[i];\\n        if(temp < ans)\\n            ans = temp;\\n    }\\n    if( prefix[n-2] < ans )\\n        ans = prefix[n-2];\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint cmpfunc(const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\n\\nlong long minimumRemoval(int* beans, int beansSize){\\n    int n = beansSize;\\n    if(n == 1)\\n        return 0;\\n    qsort(beans, n, sizeof(int), cmpfunc);\\n    long long* prefix = malloc( n * sizeof(long long));\\n    long long* suffix = malloc( n * sizeof(long long));\\n    prefix[0] = beans[0];\\n    for(int i = 1; i < n; i++){\\n        prefix[i] = prefix[i-1] + beans[i];\\n    }\\n    \\n    suffix[n-1] = beans[n-1];\\n    for(int i = n-2; i >=0; i--){\\n        suffix[i] = suffix[i+1] + beans[i];\\n    }\\n    \\n    long long ans = LONG_MAX;\\n    \\n    ans = suffix[1] - (long long)beans[0]*(n-1);\\n\\n    for(int i = 1; i < (n - 1); i++){\\n        if(beans[i] == beans[i-1])\\n            continue;\\n        long long temp = prefix[i-1] + suffix[i] - (long long)(n -i)*beans[i];\\n        if(temp < ans)\\n            ans = temp;\\n    }\\n    if( prefix[n-2] < ans )\\n        ans = prefix[n-2];\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2666733,
                "title": "a-solution-without-presum",
                "content": "the problem wanna get the **minimized** removed beans\\nthat means meaking the remaining ones **maximized**\\nthen we just calculate the total beans and make the maximum of the remaining beans and get the difference\\n```\\npublic class Solution {\\n    public long MinimumRemoval(int[] beans) \\n    {\\n        int n = beans.Length;\\n        Array.Sort(beans);\\n        long total = 0;\\n        for (int i = 0; i < n; i++)\\n            total += beans[i];\\n        long answer = 0;\\n        for (int i = 0; i < n; i++)\\n            answer = Math.Max(answer, (long) beans[i] * (n - i));\\n        return total - answer;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public long MinimumRemoval(int[] beans) \\n    {\\n        int n = beans.Length;\\n        Array.Sort(beans);\\n        long total = 0;\\n        for (int i = 0; i < n; i++)\\n            total += beans[i];\\n        long answer = 0;\\n        for (int i = 0; i < n; i++)\\n            answer = Math.Max(answer, (long) beans[i] * (n - i));\\n        return total - answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643462,
                "title": "c-easy-code-to-understand",
                "content": "#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>&b) {\\n        ll n=b.size();\\n        sort(b.begin(),b.end());\\n        reverse(b.begin(),b.end());\\n        ll sm=0;\\n        for(int i=1;i<n;i++){\\n            sm+=b[i];\\n        }\\n        ll ans=sm;\\n        ll k=0,ms=0;\\n        for(ll i=0;i<n-1;i++){\\n            sm-=b[i+1];\\n            k++;\\n            ms+=(b[i]-b[i+1])*k;\\n            ans=min(ans,ms+sm);\\n        }return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    long long minimumRemoval(vector<int>&b) {\\n        ll n=b.size();\\n        sort(b.begin(),b.end());\\n        reverse(b.begin(),b.end());\\n        ll sm=0;\\n        for(int i=1;i<n;i++){\\n            sm+=b[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2640950,
                "title": "c-using-suffix-array-and-sorting",
                "content": "\\n# Intuition\\nwe see that to make all bags equal to x beans we need to remove all beans from bags having less than x and remove such that all the bags with more than x beans have only x left.so sorting comes from the need of having a less than and greater than kind of idea so rest you can understand from implementation.\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& a) {\\n        long long n=a.size();\\n        if(n==1)\\n        {\\n            return 0;\\n        }\\n        long long l[n];\\n        sort(a.begin(),a.end());\\n        l[n-1]=a[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            l[i]=a[i]+l[i+1];\\n        }\\n        long long ans=l[1]-(n-1)*a[0];\\n        long long su=a[0];\\n        for(int i=1;i<n-1;i++)\\n        {\\n            long long x=su+l[i+1]-((n-i-1)*(long long)a[i]);\\n            ans=min(ans,x);\\n            su+=a[i];\\n        }\\n        ans=min(ans,su);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& a) {\\n        long long n=a.size();\\n        if(n==1)\\n        {\\n            return 0;\\n        }\\n        long long l[n];\\n        sort(a.begin(),a.end());\\n        l[n-1]=a[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            l[i]=a[i]+l[i+1];\\n        }\\n        long long ans=l[1]-(n-1)*a[0];\\n        long long su=a[0];\\n        for(int i=1;i<n-1;i++)\\n        {\\n            long long x=su+l[i+1]-((n-i-1)*(long long)a[i]);\\n            ans=min(ans,x);\\n            su+=a[i];\\n        }\\n        ans=min(ans,su);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639613,
                "title": "java-sorting-prefix-sum-optimized-code",
                "content": "```\\n/*\\nLogic: minimum removed = maximum non removed\\n\\nTo understand the code better,\\ndry run for the example test case\\nbeans = [4,1,6,5]\\n*/\\n\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n        Arrays.sort(beans) ;\\n        long totalBeans = 0 ;\\n        long maxNonRemoved = 0 ;\\n        int n = beans.length ;\\n        \\n        for (int i = 0; i < n; i++) {\\n            totalBeans += beans[i] ;\\n            maxNonRemoved = Math.max(maxNonRemoved, beans[i]*(n-i+0L)) ;\\n        }\\n        return (totalBeans - maxNonRemoved) ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nLogic: minimum removed = maximum non removed\\n\\nTo understand the code better,\\ndry run for the example test case\\nbeans = [4,1,6,5]\\n*/\\n\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n        Arrays.sort(beans) ;\\n        long totalBeans = 0 ;\\n        long maxNonRemoved = 0 ;\\n        int n = beans.length ;\\n        \\n        for (int i = 0; i < n; i++) {\\n            totalBeans += beans[i] ;\\n            maxNonRemoved = Math.max(maxNonRemoved, beans[i]*(n-i+0L)) ;\\n        }\\n        return (totalBeans - maxNonRemoved) ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613716,
                "title": "using-maths-over-sorted-array",
                "content": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t#number will always be from the array as any number that is not present will always\\n\\t\\t#have the difference between the sum and new array product to be > than the numbers\\n\\t\\t#present in the array\\n\\t\\t#hence the non-empty bags will contains beans that is present as we are looking for min\\n\\t\\t\\n        beans.sort()\\n        min_removals = float(inf)\\n        total        = sum(beans)\\n        length       = len(beans)\\n        \\n        for target in range(len(beans)):\\n            \\n            bean          = beans[target]\\n            targetProduct = (length - target) * bean\\n            diff          = total - targetProduct\\n            min_removals  = min(min_removals,diff)\\n        \\n        return min_removals\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t#number will always be from the array as any number that is not present will always\\n\\t\\t#have the difference between the sum and new array product to be > than the numbers\\n\\t\\t#present in the array\\n\\t\\t#hence the non-empty bags will contains beans that is present as we are looking for min\\n\\t\\t\\n        beans.sort()\\n        min_removals = float(inf)\\n        total        = sum(beans)\\n        length       = len(beans)\\n        \\n        for target in range(len(beans)):\\n            \\n            bean          = beans[target]\\n            targetProduct = (length - target) * bean\\n            diff          = total - targetProduct\\n            min_removals  = min(min_removals,diff)\\n        \\n        return min_removals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608465,
                "title": "python-easy-solution-math",
                "content": "Let us consider the input as `[2, 10, 3, 2]`. To solve this problem, we first need to sort the input array. The idea is that for every bean bag of size `s`, the answer would be equal to sum of all bean bags with size less than `s` plus the sum of number of beans to remove from bags of size greater than or equal to `s`.\\n\\nOur sorted input is `[2, 2, 3, 10]`. Additionally, we don\\'t want to visit a size that has already been visited. So, we want to skip the index 1, as size 2 has already been visited and solved for at index 0.\\n\\nConsider we are at index = 2, where input[index] = 3. The answer here is `(2 + 2) + ((3 - 3) + (10 - 3)) = 11`. Which mathematically written becomes:\\n![image](https://assets.leetcode.com/users/images/4a92022f-a8a7-48cc-ac7a-a05d31fa8160_1663821852.6629841.png)\\n\\nThus, the answer for each index `i` is `total_beans - (n - i) * beans[i]`. We just need to find the minimum of this. Here is the python code to do that:\\n```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        n = len(beans)\\n        beans.sort()\\n        minRem = math.inf\\n        total_beans = sum(beans)\\n        \\n        for i in range(n):\\n            if i > 0 and beans[i-1] == beans[i]:\\n                continue\\n            minRem = min(minRem, total_beans - beans[i] * (n - i))\\n        return minRem\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        n = len(beans)\\n        beans.sort()\\n        minRem = math.inf\\n        total_beans = sum(beans)\\n        \\n        for i in range(n):\\n            if i > 0 and beans[i-1] == beans[i]:\\n                continue\\n            minRem = min(minRem, total_beans - beans[i] * (n - i))\\n        return minRem\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604349,
                "title": "python-sorting-greedy-solution",
                "content": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        beans.sort()\\n        numBags, numBeans = len(beans), sum(beans)\\n        minBeansToRemove = numBeans - (numBags * beans[0])\\n        for bag in range(1, numBags):\\n            minBeansToRemove = min(minBeansToRemove, numBeans - ((numBags - bag) * beans[bag]))\\n        return minBeansToRemove\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        beans.sort()\\n        numBags, numBeans = len(beans), sum(beans)\\n        minBeansToRemove = numBeans - (numBags * beans[0])\\n        for bag in range(1, numBags):\\n            minBeansToRemove = min(minBeansToRemove, numBeans - ((numBags - bag) * beans[bag]))\\n        return minBeansToRemove\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603279,
                "title": "python-simple-code-not-so-simple-problem",
                "content": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        n = len(beans)\\n        beans.sort()\\n        \\n        s = sum(beans)\\n        minimum_to_remove = sum(beans) - n * beans[0]\\n        \\n        # Where i is the number of bags removed\\n        for i in range(1,n):\\n             \\n            # After \"removing\" the beans at beans[i-1], the\\n            # smallest bag is now at index i. We also\\n            # have n - i bags left.\\n            cand_min = s - (n - i) * beans[i]\\n            if cand_min < minimum_to_remove:\\n                minimum_to_remove = cand_min\\n            \\n        return minimum_to_remove\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        n = len(beans)\\n        beans.sort()\\n        \\n        s = sum(beans)\\n        minimum_to_remove = sum(beans) - n * beans[0]\\n        \\n        # Where i is the number of bags removed\\n        for i in range(1,n):\\n             \\n            # After \"removing\" the beans at beans[i-1], the\\n            # smallest bag is now at index i. We also\\n            # have n - i bags left.\\n            cand_min = s - (n - i) * beans[i]\\n            if cand_min < minimum_to_remove:\\n                minimum_to_remove = cand_min\\n            \\n        return minimum_to_remove\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581946,
                "title": "easy-problem-with-difficult-description",
                "content": "The problem is easy but the overall problem description is hard to understand.It is similar to a tallest building problems.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2574461,
                "title": "c-clean-solution-using-sort",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(),beans.end());\\n        ll sum=0;\\n        for(int x:beans) sum+=(ll)x;\\n        ll ans=sum;\\n        int n= (int)beans.size();\\n        for(int i=0;i<n;++i){\\n            ll sz=n-i;\\n            ans=min(ans,sum-sz*(ll)beans[i]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(),beans.end());\\n        ll sum=0;\\n        for(int x:beans) sum+=(ll)x;\\n        ll ans=sum;\\n        int n= (int)beans.size();\\n        for(int i=0;i<n;++i){\\n            ll sz=n-i;\\n            ans=min(ans,sum-sz*(ll)beans[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2566992,
                "title": "c-most-iniutitive-solution",
                "content": "Hello Guys,\\nInitially After seeing the question I felt like its bit tough to deal with and then came up with the following approaches.\\nApproach 1:\\nInitially I tried finding out the middle element in the vector after sorting and then removed all beans from bags present before mid index and removed beans from indexes after mid such that beans in all bags will be same. \\nBut I find out that this approach is wrong and will work for very few test-cases.\\n\\nSo Like I tried to reformulate the solution as \\nminimum number of beans removed  = maximum numbers of beans left....\\n\\nSo I sorted the vector in ascending order. So all the bags from the given index will be having same number of beans as present in current index and all the indexes before current index will be having no beans left in itself.\\nSo here we try to calculate like what will be the maximum number of beans left after we have removed some beans from the bags(which we dont know)\\nAt last we find the sum of all beans and subtract from it the maximum number of beans left to get the minimum number of beans that has been removed.\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(),beans.end());\\n        long long int maxi = INT_MIN;\\n        int n = beans.size();\\n        long long int sum = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(maxi < (long long)beans[i] * (long long)(n-i))\\n               maxi = (long long)beans[i] * (long long)(n-i);\\n            sum = sum + beans[i];\\n        }\\n        return(sum - maxi);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(),beans.end());\\n        long long int maxi = INT_MIN;\\n        int n = beans.size();\\n        long long int sum = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(maxi < (long long)beans[i] * (long long)(n-i))\\n               maxi = (long long)beans[i] * (long long)(n-i);\\n            sum = sum + beans[i];\\n        }\\n        return(sum - maxi);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475826,
                "title": "crisp-n-clear-o-nlogn-javascript-memory-94-72-meaningful-vars",
                "content": "```\\nvar minimumRemoval = function (beans) {\\n  let min = Infinity;\\n  const length = beans.length;\\n  const sortedBeans = beans.sort((a, b) => a - b);\\n  const sum = sortedBeans.reduce((accumulator, current) => current + accumulator, 0);\\n  for (let index = 0; index < length; index++) {\\n    const temp = (length - 1 - index) * sortedBeans[index] + sortedBeans[index];\\n    if (min > sum - temp) {\\n      min = sum - temp;\\n    }\\n  }\\n  return min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumRemoval = function (beans) {\\n  let min = Infinity;\\n  const length = beans.length;\\n  const sortedBeans = beans.sort((a, b) => a - b);\\n  const sum = sortedBeans.reduce((accumulator, current) => current + accumulator, 0);\\n  for (let index = 0; index < length; index++) {\\n    const temp = (length - 1 - index) * sortedBeans[index] + sortedBeans[index];\\n    if (min > sum - temp) {\\n      min = sum - temp;\\n    }\\n  }\\n  return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2469756,
                "title": "python-greedy-method",
                "content": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        \\n        beans.sort()\\n        lenBeans=len(beans)\\n        sumBeans=sum(beans)\\n        maxMagicBeans=beans[0]*lenBeans\\n        removal=sumBeans-maxMagicBeans\\n        for i in range(1,lenBeans):\\n            \\n            magicBeans=beans[i]*(lenBeans-i)\\n            if magicBeans>maxMagicBeans:\\n                \\n                removal=sumBeans-magicBeans\\n                maxMagicBeans=magicBeans\\n        return removal\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        \\n        beans.sort()\\n        lenBeans=len(beans)\\n        sumBeans=sum(beans)\\n        maxMagicBeans=beans[0]*lenBeans\\n        removal=sumBeans-maxMagicBeans\\n        for i in range(1,lenBeans):\\n            \\n            magicBeans=beans[i]*(lenBeans-i)\\n            if magicBeans>maxMagicBeans:\\n                \\n                removal=sumBeans-magicBeans\\n                maxMagicBeans=magicBeans\\n        return removal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469754,
                "title": "c-sort-and-check",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long minimumRemoval(vector<int>& a) {\\n\\t\\t\\tsort(a.begin(),a.end());\\n\\t\\t\\tvector<long> prefix(a.size());\\n\\t\\t\\tprefix[0]=a[0];\\n\\t\\t\\tfor(int i=1;i<a.size();i++) {\\n\\t\\t\\t\\tprefix[i]=prefix[i-1]+a[i];\\n\\t\\t\\t}\\n\\t\\t\\tint n=a.size();\\n\\t\\t\\tlong sum=prefix[n-1];\\n\\t\\t\\tlong prev=0,res=LONG_MAX;\\n\\t\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\t\\tlong l=sum-prefix[i]-1L*(n-i-1)*a[i]+prev;\\n\\t\\t\\t\\tprev+=a[i];\\n\\t\\t\\t\\tres=min(res,l);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long minimumRemoval(vector<int>& a) {\\n\\t\\t\\tsort(a.begin(),a.end());\\n\\t\\t\\tvector<long> prefix(a.size());\\n\\t\\t\\tprefix[0]=a[0];\\n\\t\\t\\tfor(int i=1;i<a.size();i++) {\\n\\t\\t\\t\\tprefix[i]=prefix[i-1]+a[i];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2457563,
                "title": "java-o-nlogn-sorting-prefix-sums",
                "content": "**Intuition** :\\n* We need to zero down some bean bags and reduce others to a fixed positive number(say `x`)\\n* For `values < x`, they will be emptied (as we cannot increase beans inside bags)\\n* For `values > x`, they will have to be reduced\\n* `x` will never be between two values, consider a sorted array  `[a1,a2,.......ai,aj,....an]` with ( `ai < aj` )\\nif `x` is choosen between `ai` & `aj`, then `removal = ai + (aj -x)`, whereas if `x = aj`, `removalCost = ai`\\nHence, `x` would always be count of magic beans in one of the bags\\n\\n\\n**Approach** : We first sort the array in non-decreasing order, then for each bean count we calculate the total cost of having that as the final non-zero count (i.e `x`). This can be achieved in linear time by precalculating the prefix sums.\\n\\nConsider, `beans[]  = [2, 10, 3, 2]` \\u2192 `[2, 2, 3, 10]`\\n\\nfor `x = 2`, `cost to zero down` = `no of bags < 2` = `0`, `cost to reduce` = `prefix sum ahead` - `(bags with count >= 2) * 2` = `(2 + 3 + 10) - 3 * 2 = 9`\\n\\nFinally,`total cost = zero down cost + reduce cost = 0 +  9` = `9`\\n\\nSimilary, for `x = 2, 3, 10` we have `minimum beans to be removed` = `11,11,7` respectively\\n\\n**Time Complexity** : O(NlogN)\\n**Space Complexity** : O(N)\\n\\n**Implementation**\\n```\\nclass PrefixSum {\\n\\n  private int n;\\n  private List < Long > sum;\\n\\n  public PrefixSum(int[] arr) {\\n\\n    n = arr.length;\\n    sum = new ArrayList < Long > ();\\n\\n    for (int i = 0; i < n; i++) {\\n\\n      if (sum.isEmpty()) {\\n\\n        sum.add((long) arr[i]);\\n\\n      } else {\\n\\n        sum.add(sum.get(i - 1) + arr[i]);\\n      }\\n    }\\n  }\\n\\n  public long get(int idx) {\\n\\n    if (idx < 0 || idx >= n) return 0;\\n\\n    else return sum.get(idx);\\n\\n  }\\n\\n  public long rangeSum(int i, int j) {\\n    return get(j) - get(i - 1);\\n  }\\n\\n}\\n\\nclass Solution {\\n  public long minimumRemoval(int[] beans) {\\n\\n    Arrays.sort(beans);\\n\\n    PrefixSum prefixSum = new PrefixSum(beans);\\n\\n    long ans = Long.MAX_VALUE;\\n\\n    int n = beans.length;\\n\\n    for (int i = 0; i < n; i++) {\\n\\n      long toZero = i == 0 ? 0 : prefixSum.rangeSum(0, i - 1);\\n\\n      long toReduceCount = (n - i - 1);\\n\\n      long toReduce = i == n - 1 ? 0 : prefixSum.rangeSum(i + 1, n - 1) - toReduceCount * beans[i];\\n\\n      ans = Math.min(ans, toReduce + toZero);\\n\\n    }\\n\\n    return ans;\\n\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass PrefixSum {\\n\\n  private int n;\\n  private List < Long > sum;\\n\\n  public PrefixSum(int[] arr) {\\n\\n    n = arr.length;\\n    sum = new ArrayList < Long > ();\\n\\n    for (int i = 0; i < n; i++) {\\n\\n      if (sum.isEmpty()) {\\n\\n        sum.add((long) arr[i]);\\n\\n      } else {\\n\\n        sum.add(sum.get(i - 1) + arr[i]);\\n      }\\n    }\\n  }\\n\\n  public long get(int idx) {\\n\\n    if (idx < 0 || idx >= n) return 0;\\n\\n    else return sum.get(idx);\\n\\n  }\\n\\n  public long rangeSum(int i, int j) {\\n    return get(j) - get(i - 1);\\n  }\\n\\n}\\n\\nclass Solution {\\n  public long minimumRemoval(int[] beans) {\\n\\n    Arrays.sort(beans);\\n\\n    PrefixSum prefixSum = new PrefixSum(beans);\\n\\n    long ans = Long.MAX_VALUE;\\n\\n    int n = beans.length;\\n\\n    for (int i = 0; i < n; i++) {\\n\\n      long toZero = i == 0 ? 0 : prefixSum.rangeSum(0, i - 1);\\n\\n      long toReduceCount = (n - i - 1);\\n\\n      long toReduce = i == n - 1 ? 0 : prefixSum.rangeSum(i + 1, n - 1) - toReduceCount * beans[i];\\n\\n      ans = Math.min(ans, toReduce + toZero);\\n\\n    }\\n\\n    return ans;\\n\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397409,
                "title": "c-explain-with-intution-nlong-n-and-o-1-space",
                "content": "\\n**INTUTION**  -  we will convert all element in number num,  and \\nnum belongs to given array\\n\\nwe check for every element \\n\\n**// if we convert all  elements in a given  number num than total bean that have been removed is  (total bean - remaining bean)**\\n\\n**// total bean == total sum of all elements\\n// remaing bean = (number of bigger element than num) * num;**\\n\\n\\n\\n\\nusing ll = long long;\\n\\nclass Solution {\\npublic:\\n    \\n    ll min(ll a, ll b){\\n        if(a<b) return a;\\n        return b;\\n    }\\n    \\n    long long minimumRemoval(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        ll total_bean = 0;\\n        for(auto bean : nums) total_bean += bean;\\n        \\n        sort(nums.begin(), nums.end());\\n        ll ans = LLONG_MAX;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            ll saved_bean = nums[i];\\n            saved_bean *= (n-i);\\n            ll removed_bean = total_bean - saved_bean;\\n            ans = min(ans, removed_bean);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    ll min(ll a, ll b){\\n        if(a<b) return a;\\n        return b;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2395926,
                "title": "cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        vector<long long int> temp(100005);\\n        long long int total = 0;\\n        long long int prefix_sum = 0;\\n        long long int prefix_count  = 0;\\n        for(int i=0;i<beans.size();i++) {\\n            temp[beans[i]]++;\\n            total += beans[i];\\n        }\\n        long long int ans = total;\\n        for(int i=0;i<=100000;i++) {\\n            long long int cost = total - (beans.size() - prefix_count) * i;\\n            ans = min(ans, cost);\\n            prefix_count += temp[i];\\n            prefix_sum += temp[i] * i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        vector<long long int> temp(100005);\\n        long long int total = 0;\\n        long long int prefix_sum = 0;\\n        long long int prefix_count  = 0;\\n        for(int i=0;i<beans.size();i++) {\\n            temp[beans[i]]++;\\n            total += beans[i];\\n        }\\n        long long int ans = total;\\n        for(int i=0;i<=100000;i++) {\\n            long long int cost = total - (beans.size() - prefix_count) * i;\\n            ans = min(ans, cost);\\n            prefix_count += temp[i];\\n            prefix_sum += temp[i] * i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354683,
                "title": "java-optimized-solution-clean-code",
                "content": "```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n        Arrays.sort(beans) ;\\n        long totalSum = 0, max = Long.MIN_VALUE ;\\n        int n = beans.length ;\\n        \\n        for (int i = 0; i < beans.length; i++) {\\n            totalSum += beans[i] ;\\n            max = max < beans[i]*(n-i+0L) ? beans[i]*(n-i+0L) : max ;\\n        }\\n        \\n        return totalSum-max ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n        Arrays.sort(beans) ;\\n        long totalSum = 0, max = Long.MIN_VALUE ;\\n        int n = beans.length ;\\n        \\n        for (int i = 0; i < beans.length; i++) {\\n            totalSum += beans[i] ;\\n            max = max < beans[i]*(n-i+0L) ? beans[i]*(n-i+0L) : max ;\\n        }\\n        \\n        return totalSum-max ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289974,
                "title": "intuitive-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        \\n        // [1, 4, 5, 6]\\n        //     ^\\n        // all left is removed, and all right is reduced to \\n        // pointed current beans.\\n        // \\n        \\n        sort(beans.begin(), beans.end());\\n        int len = beans.size();\\n        long long total_beans = accumulate(beans.begin(), beans.end(), 0LL);\\n        \\n        long long res = LONG_LONG_MAX;\\n        long long all_removed = 0;\\n        for (int i = 0; i < len; ++i) {\\n            long long cur = beans[i];\\n            long long right_total = total_beans - all_removed - cur;\\n            long long reduced = right_total - cur * (len - i - 1);\\n            res = min(res, all_removed + reduced);\\n            \\n            all_removed += beans[i];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        \\n        // [1, 4, 5, 6]\\n        //     ^\\n        // all left is removed, and all right is reduced to \\n        // pointed current beans.\\n        // \\n        \\n        sort(beans.begin(), beans.end());\\n        int len = beans.size();\\n        long long total_beans = accumulate(beans.begin(), beans.end(), 0LL);\\n        \\n        long long res = LONG_LONG_MAX;\\n        long long all_removed = 0;\\n        for (int i = 0; i < len; ++i) {\\n            long long cur = beans[i];\\n            long long right_total = total_beans - all_removed - cur;\\n            long long reduced = right_total - cur * (len - i - 1);\\n            res = min(res, all_removed + reduced);\\n            \\n            all_removed += beans[i];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289818,
                "title": "java-tc-o-n-logn-sc-o-n",
                "content": "```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n        long minBeansRemoved = Long.MAX_VALUE;\\n        int n = beans.length;\\n        if(n <= 1) {\\n            return minBeansRemoved == Long.MAX_VALUE ? 0 : minBeansRemoved;\\n        }\\n        \\n        Arrays.sort(beans);\\n        \\n        long[] prefix = new long[n];\\n        long pSum = 0;\\n        for(int i=0;i<n;i++) {\\n            pSum += beans[i];\\n            prefix[i] = pSum;\\n        }\\n        \\n        long[] suffix = new long[n];\\n        long sSum = 0; \\n        for(int j=n-1;j>=0;j--) {\\n            sSum += beans[j];\\n            suffix[j] = sSum;\\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            long removalsAtThisStep = 0;\\n            if(i > 0) {\\n                removalsAtThisStep += prefix[i-1];\\n            }\\n            removalsAtThisStep += (suffix[i] - (long)((long)(n-i) * (long)beans[i]));\\n            minBeansRemoved = Math.min(minBeansRemoved, removalsAtThisStep);\\n        }\\n        \\n        return minBeansRemoved == Long.MAX_VALUE ? 0 : minBeansRemoved;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Suffix Array",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n        long minBeansRemoved = Long.MAX_VALUE;\\n        int n = beans.length;\\n        if(n <= 1) {\\n            return minBeansRemoved == Long.MAX_VALUE ? 0 : minBeansRemoved;\\n        }\\n        \\n        Arrays.sort(beans);\\n        \\n        long[] prefix = new long[n];\\n        long pSum = 0;\\n        for(int i=0;i<n;i++) {\\n            pSum += beans[i];\\n            prefix[i] = pSum;\\n        }\\n        \\n        long[] suffix = new long[n];\\n        long sSum = 0; \\n        for(int j=n-1;j>=0;j--) {\\n            sSum += beans[j];\\n            suffix[j] = sSum;\\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            long removalsAtThisStep = 0;\\n            if(i > 0) {\\n                removalsAtThisStep += prefix[i-1];\\n            }\\n            removalsAtThisStep += (suffix[i] - (long)((long)(n-i) * (long)beans[i]));\\n            minBeansRemoved = Math.min(minBeansRemoved, removalsAtThisStep);\\n        }\\n        \\n        return minBeansRemoved == Long.MAX_VALUE ? 0 : minBeansRemoved;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272728,
                "title": "67-tc-and-72-sc-easy-python-solution",
                "content": "```\\ndef minimumRemoval(self, beans: List[int]) -> int:\\n\\tbeans.sort()\\n\\tans = 10000000000\\n\\ts = sum(beans)\\n\\tfor k in range(len(beans)):\\n\\t\\tans = min(ans, s - (len(beans)-k)*beans[k])\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\ndef minimumRemoval(self, beans: List[int]) -> int:\\n\\tbeans.sort()\\n\\tans = 10000000000\\n\\ts = sum(beans)\\n\\tfor k in range(len(beans)):\\n\\t\\tans = min(ans, s - (len(beans)-k)*beans[k])\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2235685,
                "title": "prefix-sum-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(),beans.end());\\n        long long  sum=0;\\n        long long count=0;\\n        map<long long ,long long> m;\\n        for(auto x : beans){\\n            sum+=x;\\n            m[x]++;\\n            count++;\\n        }\\n        long long fsum=0;\\n        long long ans=1e13;\\n        for(auto x : m){\\n            count-=x.second;\\n            ans=min(ans,(sum-((x.first*x.second)+fsum))-x.first*count+fsum);\\n            fsum+=x.first*x.second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(),beans.end());\\n        long long  sum=0;\\n        long long count=0;\\n        map<long long ,long long> m;\\n        for(auto x : beans){\\n            sum+=x;\\n            m[x]++;\\n            count++;\\n        }\\n        long long fsum=0;\\n        long long ans=1e13;\\n        for(auto x : m){\\n            count-=x.second;\\n            ans=min(ans,(sum-((x.first*x.second)+fsum))-x.first*count+fsum);\\n            fsum+=x.first*x.second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227658,
                "title": "easy-java-solution-only-few-lines-of-code",
                "content": "```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n      Long max = 0L;\\n        long sum = 0;\\n        int n = beans.length;\\n        Arrays.sort(beans);\\n        for(int i =0;i<n;i++){\\n            sum +=beans[i];\\n            max = Math.max(max,(beans[i]*(1L)*(n-i)));\\n        }\\n        return sum-max;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n      Long max = 0L;\\n        long sum = 0;\\n        int n = beans.length;\\n        Arrays.sort(beans);\\n        for(int i =0;i<n;i++){\\n            sum +=beans[i];\\n            max = Math.max(max,(beans[i]*(1L)*(n-i)));\\n        }\\n        return sum-max;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2224851,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(),beans.end());\\n        long long sum=0,new_sum=0;\\n        for (int i=0;i<beans.size();i++) {\\n            sum+=beans[i];\\n            if (beans[i]*(beans.size()-i)>new_sum) new_sum=beans[i]*(beans.size()-i);\\n        }\\n        return sum-new_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(),beans.end());\\n        long long sum=0,new_sum=0;\\n        for (int i=0;i<beans.size();i++) {\\n            sum+=beans[i];\\n            if (beans[i]*(beans.size()-i)>new_sum) new_sum=beans[i]*(beans.size()-i);\\n        }\\n        return sum-new_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2224211,
                "title": "easy-faster-efficient-java-soln",
                "content": "```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n        int n = beans.length;\\n        Arrays.sort(beans);\\n        \\n        long sum = 0;\\n        for(int i = 0; i < n; i++){\\n            sum += beans[i];\\n        }\\n        \\n        long ans = Long.MAX_VALUE;\\n        \\n        for(int i = 0; i < n; i++){\\n            long res = sum - (beans[i] * (n - i + 0L));\\n            ans = (long)Math.min(ans, res);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumRemoval(int[] beans) {\\n        int n = beans.length;\\n        Arrays.sort(beans);\\n        \\n        long sum = 0;\\n        for(int i = 0; i < n; i++){\\n            sum += beans[i];\\n        }\\n        \\n        long ans = Long.MAX_VALUE;\\n        \\n        for(int i = 0; i < n; i++){\\n            long res = sum - (beans[i] * (n - i + 0L));\\n            ans = (long)Math.min(ans, res);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223750,
                "title": "python-detailed-examplaination-sorting-clean-code",
                "content": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        \"\"\"\\n        we note that once we choose ith element then all the other elements\\n        of the list have to be same to it or they become zero (in case they are smaller)\\n\\n        then total change[i] = (\\n                sum(e for e in beans if e < beans[i])\\n                        +\\n                sum(e - beans[i] for e in beans if e > beans[i]\\n        )\\n\\n        output = min(change[0], change[1], ... change[n - 1])\\n\\n        to avoid calculating summation multiple times, we sort the array,\\n        let s = sum(beans), now\\n\\n        change[i] = (\\n                            sum(beans[:i])\\n                                  +\\n                        sum(beans) - beans[i] - sum(beans[:i]) - (n - 1 - i) * beans[i]\\n                )\\n                = s - (n - i) * beans[i]\\n\\n        output = min(change[0], change[1], ... change[n - 1])\\n               = min(s - (n - i) * beans[i] for in in range(n))\\n               = s + min(-(n - i) * beans[i] for i in range(n))\\n               = s - max((n - i) * beans[i] for i in range(n))\\n\\n        :param beans:\\n        :return:\\n        \"\"\"\\n        beans.sort()\\n\\n        n = len(beans)\\n\\n        return sum(beans) - max((n - i) * e for i, e in enumerate(beans))\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def minimumRemoval(self, beans: List[int]) -> int:\\n        \"\"\"\\n        we note that once we choose ith element then all the other elements\\n        of the list have to be same to it or they become zero (in case they are smaller)\\n\\n        then total change[i] = (\\n                sum(e for e in beans if e < beans[i])\\n                        +\\n                sum(e - beans[i] for e in beans if e > beans[i]\\n        )\\n\\n        output = min(change[0], change[1], ... change[n - 1])\\n\\n        to avoid calculating summation multiple times, we sort the array,\\n        let s = sum(beans), now\\n\\n        change[i] = (\\n                            sum(beans[:i])\\n                                  +\\n                        sum(beans) - beans[i] - sum(beans[:i]) - (n - 1 - i) * beans[i]\\n                )\\n                = s - (n - i) * beans[i]\\n\\n        output = min(change[0], change[1], ... change[n - 1])\\n               = min(s - (n - i) * beans[i] for in in range(n))\\n               = s + min(-(n - i) * beans[i] for i in range(n))\\n               = s - max((n - i) * beans[i] for i in range(n))\\n\\n        :param beans:\\n        :return:\\n        \"\"\"\\n        beans.sort()\\n\\n        n = len(beans)\\n\\n        return sum(beans) - max((n - i) * e for i, e in enumerate(beans))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220592,
                "title": "c-math-based-formula",
                "content": "long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(),beans.end());\\n        \\n        long long sum = 0;\\n        long long n = beans.size();\\n        \\n        for(int i=0; i<n; i++){\\n            sum = sum + beans[i];\\n        }\\n        \\n        long long ans = LLONG_MAX;\\n        \\n        for(long long i=0; i<beans.size(); i++){\\n            long long curr = sum - ((n-i)*beans[i]);\\n            ans = (long long)min(ans,curr);\\n        }\\n        \\n        return ans;",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "long long minimumRemoval(vector<int>& beans) {\\n        sort(beans.begin(),beans.end());\\n        \\n        long long sum = 0;\\n        long long n = beans.size();\\n        \\n        for(int i=0; i<n; i++){\\n            sum = sum + beans[i];\\n        }\\n        \\n        long long ans = LLONG_MAX;\\n        \\n        for(long long i=0; i<beans.size(); i++){\\n            long long curr = sum - ((n-i)*beans[i]);\\n            ans = (long long)min(ans,curr);\\n        }\\n        \\n        return ans;",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1568728,
                "content": [
                    {
                        "username": "Anilchouhan181",
                        "content": "[https://leetcode.com/problems/removing-minimum-number-of-magic-beans/discuss/1766878/Python-3-Simple-10-lines-sliding-window-solution](http://)"
                    },
                    {
                        "username": "zechengli",
                        "content": "my initial thought was binary seach to find the lowest bound for the amount beans we need to remove: like NNNNYNNYNYN  (Y: work, N: not work), but realized that there is no way we can know either go to left half or right half if we hit the N"
                    },
                    {
                        "username": "Limon020",
                        "content": "I also thought about, and implemented, binary search, but there are a bunch of local minimums that make it not work. There is a \\'parabola\\' between the bags where number of deletions gets more and more until the midway point, and then less and less until the next bag. Like in [12,43,63,94], between 43 and 53 the number deletions climbs, then it descends between 53 and 63. Likewise between 63 and 93. This tricks the binary search into looking right at 53, because res(52) > res(53), but in reality the solution occurs at  43. \\n\\nI definitely need to think more about when I can apply binary search, clearly. "
                    },
                    {
                        "username": "kmp1084",
                        "content": "amazing that Amazon has not asked this question yet!"
                    }
                ]
            },
            {
                "id": 1903496,
                "content": [
                    {
                        "username": "Anilchouhan181",
                        "content": "[https://leetcode.com/problems/removing-minimum-number-of-magic-beans/discuss/1766878/Python-3-Simple-10-lines-sliding-window-solution](http://)"
                    },
                    {
                        "username": "zechengli",
                        "content": "my initial thought was binary seach to find the lowest bound for the amount beans we need to remove: like NNNNYNNYNYN  (Y: work, N: not work), but realized that there is no way we can know either go to left half or right half if we hit the N"
                    },
                    {
                        "username": "Limon020",
                        "content": "I also thought about, and implemented, binary search, but there are a bunch of local minimums that make it not work. There is a \\'parabola\\' between the bags where number of deletions gets more and more until the midway point, and then less and less until the next bag. Like in [12,43,63,94], between 43 and 53 the number deletions climbs, then it descends between 53 and 63. Likewise between 63 and 93. This tricks the binary search into looking right at 53, because res(52) > res(53), but in reality the solution occurs at  43. \\n\\nI definitely need to think more about when I can apply binary search, clearly. "
                    },
                    {
                        "username": "kmp1084",
                        "content": "amazing that Amazon has not asked this question yet!"
                    }
                ]
            },
            {
                "id": 1754291,
                "content": [
                    {
                        "username": "Anilchouhan181",
                        "content": "[https://leetcode.com/problems/removing-minimum-number-of-magic-beans/discuss/1766878/Python-3-Simple-10-lines-sliding-window-solution](http://)"
                    },
                    {
                        "username": "zechengli",
                        "content": "my initial thought was binary seach to find the lowest bound for the amount beans we need to remove: like NNNNYNNYNYN  (Y: work, N: not work), but realized that there is no way we can know either go to left half or right half if we hit the N"
                    },
                    {
                        "username": "Limon020",
                        "content": "I also thought about, and implemented, binary search, but there are a bunch of local minimums that make it not work. There is a \\'parabola\\' between the bags where number of deletions gets more and more until the midway point, and then less and less until the next bag. Like in [12,43,63,94], between 43 and 53 the number deletions climbs, then it descends between 53 and 63. Likewise between 63 and 93. This tricks the binary search into looking right at 53, because res(52) > res(53), but in reality the solution occurs at  43. \\n\\nI definitely need to think more about when I can apply binary search, clearly. "
                    },
                    {
                        "username": "kmp1084",
                        "content": "amazing that Amazon has not asked this question yet!"
                    }
                ]
            }
        ]
    }
]