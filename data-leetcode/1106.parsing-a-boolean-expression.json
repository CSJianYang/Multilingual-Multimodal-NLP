[
    {
        "title": "Parsing A Boolean Expression",
        "question_content": "A boolean expression is an expression that evaluates to either true or false. It can be in one of the following shapes:\n\n\t't' that evaluates to true.\n\t'f' that evaluates to false.\n\t'!(subExpr)' that evaluates to the logical NOT of the inner expression subExpr.\n\t'&(subExpr1, subExpr2, ..., subExprn)' that evaluates to the logical AND of the inner expressions subExpr1, subExpr2, ..., subExprn where n >= 1.\n\t'|(subExpr1, subExpr2, ..., subExprn)' that evaluates to the logical OR of the inner expressions subExpr1, subExpr2, ..., subExprn where n >= 1.\n\nGiven a string expression that represents a boolean expression, return the evaluation of that expression.\nIt is guaranteed that the given expression is valid and follows the given rules.\n&nbsp;\nExample 1:\n\nInput: expression = \"&(|(f))\"\nOutput: false\nExplanation: \nFirst, evaluate |(f) --> f. The expression is now \"&(f)\".\nThen, evaluate &(f) --> f. The expression is now \"f\".\nFinally, return false.\n\nExample 2:\n\nInput: expression = \"|(f,f,f,t)\"\nOutput: true\nExplanation: The evaluation of (false OR false OR false OR true) is true.\n\nExample 3:\n\nInput: expression = \"!(&(f,t))\"\nOutput: true\nExplanation: \nFirst, evaluate &(f,t) --> (false AND true) --> false --> f. The expression is now \"!(f)\".\nThen, evaluate !(f) --> NOT false --> true. We return true.\n\n&nbsp;\nConstraints:\n\n\t1 <= expression.length <= 2 * 104\n\texpression[i] is one following characters: '(', ')', '&', '|', '!', 't', 'f', and ','.",
        "solutions": [
            {
                "id": 323307,
                "title": "python-easy-1-line-cheat",
                "content": "## **Intuition**\\nWell, we can see that `&`, `|` and `!` are just three functions.\\nAnd in python, they are function `all`, `any` and keyword `not`.\\n\\n## **Explanation**\\nFollowing the description,\\nit demands us to evaluate the expression.\\nSo no recursion and no stack, I just `eval` the expression.\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSapce `O(N)`\\nI guess it\\'s not fast compared with string parse, but wow it\\'s `O(N)`.\\n<br>\\n\\n**Python:**\\n```\\n    def parseBoolExpr(self, S, t=True, f=False):\\n        return eval(S.replace(\\'!\\', \\'not |\\').replace(\\'&(\\', \\'all([\\').replace(\\'|(\\', \\'any([\\').replace(\\')\\', \\'])\\'))\\n```",
                "solutionTags": [],
                "code": "```\\n    def parseBoolExpr(self, S, t=True, f=False):\\n        return eval(S.replace(\\'!\\', \\'not |\\').replace(\\'&(\\', \\'all([\\').replace(\\'|(\\', \\'any([\\').replace(\\')\\', \\'])\\'))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 323532,
                "title": "java-python-3-iterative-and-recursive-solutions-w-explanation-and-analysis",
                "content": "**Method 1:** Iterative version - Use Stack and Set.\\n\\nLoop through the input String:\\n1. Use a stack to store chars except `\\',\\'` and `\\')\\'`;\\n2. If we find a `\\')\\'`, keep popping out the chars from the stack till find a `\\'(\\'`; add the popped-out into a Set.\\n3. Pop out the `operator` after popping `\\')\\'`  out, push into stack the corresponding result according to the `operator`.\\n4. repeat the above till the end, and the remaining is the result.\\n\\n**[Java]**\\n\\n```java\\n    public boolean parseBoolExpr(String expression) {\\n        Deque<Character> stk = new ArrayDeque<>();\\n        for (int i = 0; i < expression.length(); ++i) {\\n            char c = expression.charAt(i);\\n            if (c == \\')\\') {\\n                Set<Character> seen = new HashSet<>();\\n                while (stk.peek() != \\'(\\')\\n                    seen.add(stk.pop());\\n                stk.pop();// pop out \\'(\\'.\\n                char operator = stk.pop(); // get operator for current expression.\\n                if (operator == \\'&\\') {\\n                    stk.push(seen.contains(\\'f\\') ? \\'f\\' : \\'t\\'); // if there is any \\'f\\', & expression results to \\'f\\'\\n                }else if (operator == \\'|\\') {\\n                    stk.push(seen.contains(\\'t\\') ? \\'t\\' : \\'f\\'); // if there is any \\'t\\', | expression results to \\'t\\'\\n                }else { // ! expression.\\n                    stk.push(seen.contains(\\'t\\') ? \\'f\\' : \\'t\\'); // Logical NOT flips the expression.\\n                }\\n            }else if (c != \\',\\') {\\n                stk.push(c);\\n            }\\n        }\\n        return stk.pop() == \\'t\\';\\n    }\\n```\\n**[Python 3]** credit to: **@zengfei216 and @cenkay**\\n\\n```python\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        for c in expression:\\n            if c == \\')\\':\\n                seen = set()\\n                while stack[-1] != \\'(\\':\\n                    seen.add(stack.pop())\\n                stack.pop()\\n                operator = stack.pop()\\n                stack.append(all(seen) if operator == \\'&\\' else any(seen) if operator == \\'|\\' else not seen.pop())\\n            elif c != \\',\\':\\n                stack.append(True if c == \\'t\\' else False if c == \\'f\\' else c)\\n        return stack.pop()\\n```\\n----\\n**Method 2:** Recursive version.\\n\\nUse `level` to count the non-matched `(` and `)`, together with `,`, we can delimit valid sub-expression and hence recurse to sub-problem.\\n\\n\\n**[Java]**\\n\\n\\n```java\\n    public boolean parseBoolExpr(String expression) {\\n        return parse(expression, 0, expression.length());\\n    }\\n    private boolean parse(String s, int lo, int hi) {\\n        char c = s.charAt(lo);\\n        if (hi - lo == 1) return c == \\'t\\'; // base case.\\n        boolean ans = c == \\'&\\'; // only when c is &, set ans to true; otherwise false.\\n        for (int i = lo + 2, start = i, level = 0; i < hi; ++i) {\\n            char d = s.charAt(i);\\n            if (level == 0 && (d == \\',\\' || d == \\')\\')) { // locate a valid sub-expression. \\n                boolean cur = parse(s, start, i); // recurse to sub-problem.\\n                start = i + 1; // next sub-expression start index.\\n                if (c == \\'&\\') ans &= cur;\\n                else if (c == \\'|\\') ans |= cur;\\n                else ans = !cur; // c == \\'!\\'.\\n            }\\n            if (d == \\'(\\') ++level;\\n            if (d == \\')\\') --level;\\n        }\\n        return ans;\\n    }\\n```\\n**[Python 3]**\\n\\n```python\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        \\n        def parse(e: str, lo: int, hi: int) -> bool:\\n            if hi - lo == 1: # base case\\n                return e[lo] == \\'t\\'               \\n            ans = e[lo] == \\'&\\' # only when the first char is \\'&\\', ans assigned True.\\n            level, start = 0, lo + 2 # e[lo + 1] must be \\'(\\', so start from lo + 2 to delimit sub-expression.\\n            for i in range(lo + 2, hi):\\n                if level == 0  and e[i] in [\\',\\', \\')\\']: # found a sub-expression.\\n                    cur = parse(e, start, i) # recurse to sub-problem.\\n                    start = i + 1 # start point of next sub-expression.\\n                    if e[lo] == \\'&\\':\\n                        ans &= cur\\n                    elif e[lo] == \\'|\\':\\n                        ans |= cur\\n                    else: # e[lo] is \\'!\\'.\\n                        ans = not cur\\n                if e[i] == \\'(\\':\\n                    level = level + 1\\n                elif e[i] == \\')\\':\\n                    level = level - 1\\n            return ans;        \\n        \\n        return parse(expression, 0, len(expression))\\n```\\n**Analysis:**\\nTime & space: O(n), n = expression.length().\\n\\n",
                "solutionTags": [],
                "code": "```java\\n    public boolean parseBoolExpr(String expression) {\\n        Deque<Character> stk = new ArrayDeque<>();\\n        for (int i = 0; i < expression.length(); ++i) {\\n            char c = expression.charAt(i);\\n            if (c == \\')\\') {\\n                Set<Character> seen = new HashSet<>();\\n                while (stk.peek() != \\'(\\')\\n                    seen.add(stk.pop());\\n                stk.pop();// pop out \\'(\\'.\\n                char operator = stk.pop(); // get operator for current expression.\\n                if (operator == \\'&\\') {\\n                    stk.push(seen.contains(\\'f\\') ? \\'f\\' : \\'t\\'); // if there is any \\'f\\', & expression results to \\'f\\'\\n                }else if (operator == \\'|\\') {\\n                    stk.push(seen.contains(\\'t\\') ? \\'t\\' : \\'f\\'); // if there is any \\'t\\', | expression results to \\'t\\'\\n                }else { // ! expression.\\n                    stk.push(seen.contains(\\'t\\') ? \\'f\\' : \\'t\\'); // Logical NOT flips the expression.\\n                }\\n            }else if (c != \\',\\') {\\n                stk.push(c);\\n            }\\n        }\\n        return stk.pop() == \\'t\\';\\n    }\\n```\n```python\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        for c in expression:\\n            if c == \\')\\':\\n                seen = set()\\n                while stack[-1] != \\'(\\':\\n                    seen.add(stack.pop())\\n                stack.pop()\\n                operator = stack.pop()\\n                stack.append(all(seen) if operator == \\'&\\' else any(seen) if operator == \\'|\\' else not seen.pop())\\n            elif c != \\',\\':\\n                stack.append(True if c == \\'t\\' else False if c == \\'f\\' else c)\\n        return stack.pop()\\n```\n```java\\n    public boolean parseBoolExpr(String expression) {\\n        return parse(expression, 0, expression.length());\\n    }\\n    private boolean parse(String s, int lo, int hi) {\\n        char c = s.charAt(lo);\\n        if (hi - lo == 1) return c == \\'t\\'; // base case.\\n        boolean ans = c == \\'&\\'; // only when c is &, set ans to true; otherwise false.\\n        for (int i = lo + 2, start = i, level = 0; i < hi; ++i) {\\n            char d = s.charAt(i);\\n            if (level == 0 && (d == \\',\\' || d == \\')\\')) { // locate a valid sub-expression. \\n                boolean cur = parse(s, start, i); // recurse to sub-problem.\\n                start = i + 1; // next sub-expression start index.\\n                if (c == \\'&\\') ans &= cur;\\n                else if (c == \\'|\\') ans |= cur;\\n                else ans = !cur; // c == \\'!\\'.\\n            }\\n            if (d == \\'(\\') ++level;\\n            if (d == \\')\\') --level;\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        \\n        def parse(e: str, lo: int, hi: int) -> bool:\\n            if hi - lo == 1: # base case\\n                return e[lo] == \\'t\\'               \\n            ans = e[lo] == \\'&\\' # only when the first char is \\'&\\', ans assigned True.\\n            level, start = 0, lo + 2 # e[lo + 1] must be \\'(\\', so start from lo + 2 to delimit sub-expression.\\n            for i in range(lo + 2, hi):\\n                if level == 0  and e[i] in [\\',\\', \\')\\']: # found a sub-expression.\\n                    cur = parse(e, start, i) # recurse to sub-problem.\\n                    start = i + 1 # start point of next sub-expression.\\n                    if e[lo] == \\'&\\':\\n                        ans &= cur\\n                    elif e[lo] == \\'|\\':\\n                        ans |= cur\\n                    else: # e[lo] is \\'!\\'.\\n                        ans = not cur\\n                if e[i] == \\'(\\':\\n                    level = level + 1\\n                elif e[i] == \\')\\':\\n                    level = level - 1\\n            return ans;        \\n        \\n        return parse(expression, 0, len(expression))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 325228,
                "title": "c-polish-notation",
                "content": "# Intuition\\nWe can parse parentheses and recursivelly evaluate the expression. Or, since the expression is in Poslih notation, we can use a simple stack approach.\\n# Recursive Solution\\nLogical AND and OR expressions are a bit tricky as they have multiple parameters, and a parameter can be an inner expression.\\n\\nSo, to extract parameters, we need to track the number of non-closed parentheses; when we see a comma (\",\") and the number of parentheses is zero, we found an entire parameter.\\n```\\nbool parseBoolExpr(string e) {\\n  if (e.size() == 1) return e == \"t\" ? true : false;\\n  if (e[0] == \\'!\\') return !parseBoolExpr(e.substr(2, e.size() - 3));\\n  bool isAnd = e[0] == \\'&\\' ? true : false, res = isAnd;\\n  for (auto i = 2, j = 2, cnt = 0; res == isAnd && i < e.size(); ++i) {\\n    if (e[i] == \\'(\\') ++cnt;\\n    if (e[i] == \\')\\') --cnt;      \\n    if (i == e.size() - 1 || (e[i] == \\',\\' && cnt == 0)) {\\n      if (isAnd) res &= parseBoolExpr(e.substr(j, i - j));\\n      else res |= parseBoolExpr(e.substr(j, i - j));\\n      j = i + 1;\\n    }\\n  }\\n  return res;\\n}\\n```\\n# Polish Notation\\nPolish notation is very easy to evaluate: push everything to the stack until you get the closing group marker (\\')\\'). Then, pop values from the stack (should be just \\'t\\' and \\'f\\' at this point) until you reach an operator (\\'!\\', \\'|\\' or \\'&\\'). Apply the operator to the values and push the result back to the stack.\\n\\nAdditional observations:\\n\\u2022\\tWe can ignore commas and open parentheses.\\n\\u2022\\tWe do not need to apply the operator to all parameters; we just need to know whether we have one or more \\'t\\', or one or more \\'f\\'.\\n```\\nbool parseBoolExpr(string e) {\\n  stack<char> s;\\n  for (auto ch : e) {\\n    if (ch == \\')\\') {\\n      auto hasT = false, hasF = false;\\n      while (s.top() == \\'t\\' || s.top() == \\'f\\') {\\n        hasT |= s.top() == \\'t\\';\\n        hasF |= s.top() == \\'f\\';\\n        s.pop();\\n      }\\n      auto op = s.top();\\n      s.pop();\\n      s.push(op == \\'!\\' ? hasF ? \\'t\\' : \\'f\\' : op == \\'&\\' ? !hasF ? \\'t\\' : \\'f\\' : hasT ? \\'t\\' : \\'f\\');\\n    }\\n    else if (ch != \\',\\' && ch != \\'(\\') s.push(ch);\\n  }\\n  return s.top() == \\'t\\' ? true : false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool parseBoolExpr(string e) {\\n  if (e.size() == 1) return e == \"t\" ? true : false;\\n  if (e[0] == \\'!\\') return !parseBoolExpr(e.substr(2, e.size() - 3));\\n  bool isAnd = e[0] == \\'&\\' ? true : false, res = isAnd;\\n  for (auto i = 2, j = 2, cnt = 0; res == isAnd && i < e.size(); ++i) {\\n    if (e[i] == \\'(\\') ++cnt;\\n    if (e[i] == \\')\\') --cnt;      \\n    if (i == e.size() - 1 || (e[i] == \\',\\' && cnt == 0)) {\\n      if (isAnd) res &= parseBoolExpr(e.substr(j, i - j));\\n      else res |= parseBoolExpr(e.substr(j, i - j));\\n      j = i + 1;\\n    }\\n  }\\n  return res;\\n}\\n```\n```\\nbool parseBoolExpr(string e) {\\n  stack<char> s;\\n  for (auto ch : e) {\\n    if (ch == \\')\\') {\\n      auto hasT = false, hasF = false;\\n      while (s.top() == \\'t\\' || s.top() == \\'f\\') {\\n        hasT |= s.top() == \\'t\\';\\n        hasF |= s.top() == \\'f\\';\\n        s.pop();\\n      }\\n      auto op = s.top();\\n      s.pop();\\n      s.push(op == \\'!\\' ? hasF ? \\'t\\' : \\'f\\' : op == \\'&\\' ? !hasF ? \\'t\\' : \\'f\\' : hasT ? \\'t\\' : \\'f\\');\\n    }\\n    else if (ch != \\',\\' && ch != \\'(\\') s.push(ch);\\n  }\\n  return s.top() == \\'t\\' ? true : false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323370,
                "title": "c-recursive-descent-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool f_not(const string& s,int& i){\\n        i+=2;\\n        auto ret = f(s,i);\\n        i++;\\n        return !ret;\\n    }\\n    \\n    bool f_and(const string& s,int& i){\\n        i+=2;\\n        bool ret = true;\\n        ret &= f(s,i);\\n        while(s[i]!=\\')\\'){\\n            i++;\\n            ret &= f(s,i);\\n        }\\n        i++;\\n        return ret;\\n    }\\n    \\n    bool f_or(const string& s,int& i){\\n        i+=2;\\n        bool ret = false;\\n        ret |= f(s,i);\\n        while(s[i]!=\\')\\'){\\n            i++;\\n            ret |= f(s,i);\\n        }\\n        i++;\\n        return ret;\\n    }\\n    \\n    bool f(const string& s, int& i){\\n        if(s[i] == \\'t\\'){\\n            i++;\\n            return true;\\n        } else if(s[i] == \\'f\\'){\\n            i++;\\n            return false;\\n        } else if(s[i] == \\'!\\'){\\n            return f_not(s,i);\\n        } else if(s[i] == \\'&\\'){\\n            return f_and(s,i);\\n        } return f_or(s,i);\\n    }\\n    bool parseBoolExpr(string expression) {\\n        int i = 0;\\n        return f(expression,i);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f_not(const string& s,int& i){\\n        i+=2;\\n        auto ret = f(s,i);\\n        i++;\\n        return !ret;\\n    }\\n    \\n    bool f_and(const string& s,int& i){\\n        i+=2;\\n        bool ret = true;\\n        ret &= f(s,i);\\n        while(s[i]!=\\')\\'){\\n            i++;\\n            ret &= f(s,i);\\n        }\\n        i++;\\n        return ret;\\n    }\\n    \\n    bool f_or(const string& s,int& i){\\n        i+=2;\\n        bool ret = false;\\n        ret |= f(s,i);\\n        while(s[i]!=\\')\\'){\\n            i++;\\n            ret |= f(s,i);\\n        }\\n        i++;\\n        return ret;\\n    }\\n    \\n    bool f(const string& s, int& i){\\n        if(s[i] == \\'t\\'){\\n            i++;\\n            return true;\\n        } else if(s[i] == \\'f\\'){\\n            i++;\\n            return false;\\n        } else if(s[i] == \\'!\\'){\\n            return f_not(s,i);\\n        } else if(s[i] == \\'&\\'){\\n            return f_and(s,i);\\n        } return f_or(s,i);\\n    }\\n    bool parseBoolExpr(string expression) {\\n        int i = 0;\\n        return f(expression,i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356645,
                "title": "c-clean-code-smooth-as-f-k-stack",
                "content": "***Almost Spent 2 hrs to solve this one!! So please upvote if you find this solution intuative!!***\\n\\n```\\nclass Solution {\\nprivate:\\n    bool parse_or (vector<int> &res)\\n    {\\n        int mask = res[0];\\n        for(int i=1; i<res.size(); i++)\\n        {\\n            mask |= res[i];\\n        }\\n        return mask;\\n    }\\n    \\n    bool parse_and (vector<int> &res)\\n    {\\n        int mask = res[0];\\n        for(int i=1; i<res.size(); i++)\\n        {\\n            mask &= res[i];\\n        }\\n        return mask;\\n    }\\n    \\npublic:\\n    bool parseBoolExpr(string s) {\\n        int n = s.size();\\n        stack<int> st;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(s[i] == \\',\\') continue;\\n            if(s[i]==\\')\\')\\n            {\\n                vector<int> res;\\n                while(st.top()!=\\'&\\' && st.top()!=\\'|\\' && st.top()!=\\'!\\')\\n                {\\n                    char c = st.top();\\n                    st.pop();\\n                    if(c==\\'t\\') res.push_back(1);\\n                    if(c==\\'f\\') res.push_back(0);\\n                }\\n                char c = st.top();\\n                st.pop();\\n                if(c==\\'&\\')\\n                {\\n                    if(parse_and(res)) st.push(\\'t\\');\\n                    else st.push(\\'f\\');\\n                }\\n                else if(c==\\'|\\') \\n                {\\n                    if(parse_or(res)) st.push(\\'t\\');\\n                    else st.push(\\'f\\');\\n                }\\n                else if(c==\\'!\\')\\n                {\\n                    if(res[0] == 0) st.push(\\'t\\'); \\n                    else st.push(\\'f\\');\\n                }\\n            }\\n            else st.push(s[i]);\\n        }\\n        return (st.top()==\\'t\\');\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool parse_or (vector<int> &res)\\n    {\\n        int mask = res[0];\\n        for(int i=1; i<res.size(); i++)\\n        {\\n            mask |= res[i];\\n        }\\n        return mask;\\n    }\\n    \\n    bool parse_and (vector<int> &res)\\n    {\\n        int mask = res[0];\\n        for(int i=1; i<res.size(); i++)\\n        {\\n            mask &= res[i];\\n        }\\n        return mask;\\n    }\\n    \\npublic:\\n    bool parseBoolExpr(string s) {\\n        int n = s.size();\\n        stack<int> st;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(s[i] == \\',\\') continue;\\n            if(s[i]==\\')\\')\\n            {\\n                vector<int> res;\\n                while(st.top()!=\\'&\\' && st.top()!=\\'|\\' && st.top()!=\\'!\\')\\n                {\\n                    char c = st.top();\\n                    st.pop();\\n                    if(c==\\'t\\') res.push_back(1);\\n                    if(c==\\'f\\') res.push_back(0);\\n                }\\n                char c = st.top();\\n                st.pop();\\n                if(c==\\'&\\')\\n                {\\n                    if(parse_and(res)) st.push(\\'t\\');\\n                    else st.push(\\'f\\');\\n                }\\n                else if(c==\\'|\\') \\n                {\\n                    if(parse_or(res)) st.push(\\'t\\');\\n                    else st.push(\\'f\\');\\n                }\\n                else if(c==\\'!\\')\\n                {\\n                    if(res[0] == 0) st.push(\\'t\\'); \\n                    else st.push(\\'f\\');\\n                }\\n            }\\n            else st.push(s[i]);\\n        }\\n        return (st.top()==\\'t\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325120,
                "title": "a-compiler-front-end-writer-s-solution-recursive-descent-parsing",
                "content": "Compiler front-ends (lexer, parser, AST generators) routinely use recursive descent parsing to parse source code written in language which is defined by a set of (E)BNF grammars. Here\\'s my solution:\\n\\nLet\\'s define a BNF grammar for this language of booleans and we will implement a recursive descent parser for it.\\n\\n```\\n<comma> ::= \",\"\\n<bool> ::= \"t\" | \"f\"\\n<lparen> ::= \"(\"\\n<rparen> ::= \")\"\\n<not_expr> ::= \"!\" <lparen> <expr> <rparen>\\n<and_expr> ::= \"&\" <lparen> <expr> (<comma> <expr>)+ <rparen>\\n<or_expr> ::= \"|\" <lparen> <expr> (<comma> <expr>)+ <rparen>\\n<expr> ::= <bool> | <not_expr> | <and_expr> | <or_expr>\\n```\\n\\nThis grammar can parse any statement written in this language of booleans. The elegance of this is that once you have defined the grammar the parser code is pretty much described by the grammar rules where each non-terminal rule is turned into a method.\\n\\n```\\nclass Solution {\\n    int pos = 0; // a global source code position marker\\n    String src = \"\";\\n    public boolean parseBoolExpr(String expression) {\\n        pos = 0;\\n        src = expression;\\n        return parseExpr(); // call the entry rule\\n    }\\n    private boolean parseExpr() {\\n        if(src.charAt(pos) == \\'t\\') { //<expr> ::= \"t\"\\n            ++pos;\\n            return true;\\n        }\\n        if(src.charAt(pos) == \\'f\\') { //<expr> ::= \"f\"\\n            ++pos;\\n            return false;\\n        }\\n        boolean result = false;\\n        switch(src.charAt(pos)) {\\n\\t\\t//<not_expr> ::= \"!\" <lparen> <expr> <rparen>\\n            case \\'!\\': \\n                pos ++; //eat operator\\n                result = parseNotExpr();\\n                break;\\n\\t\\t//<or_expr> ::= \"|\" <lparen> <expr> (<comma> <expr>)+ <rparen>\\n            case \\'|\\':\\n                pos ++; //eat operator\\n                result = parseOrExpr();\\n                break;\\n\\t\\t//<and_expr> ::= \"&\" <lparen> <expr> (<comma> <expr>)+ <rparen>\\n            case \\'&\\':\\n                pos ++; //eat operator\\n                result = parseAndExpr();\\n                break;\\n        }\\n        return result;\\n    }\\n    private boolean parseNotExpr() {\\n        ++pos; //eat lparen\\n        boolean result = parseExpr();\\n        ++pos; //eat rparen\\n        return !result;\\n    }\\n    private boolean parseOrExpr() {\\n        ++pos; //eat lparen\\n        boolean result = parseExpr();\\n        while(pos < src.length() && src.charAt(pos) != \\')\\') {\\n            if(src.charAt(pos) == \\',\\') ++pos;\\n            else {\\n                result |= parseExpr();\\n            }\\n        }\\n        ++pos; //eat rparen\\n        return result;\\n    }\\n    private boolean parseAndExpr() {\\n        ++pos; //eat lparen\\n        boolean result = parseExpr();\\n        while(pos < src.length() && src.charAt(pos) != \\')\\') {\\n            if(src.charAt(pos) == \\',\\') ++pos;\\n            else {\\n                result &= parseExpr();\\n            }\\n        }\\n        ++pos; //eat rparen\\n        return result;\\n    }\\n}\\n```\\n\\nAs you can see each specific expression (!, & |) is responsible for advancing the position marker and what they do is pretty much exactly as the grammar rule defines.",
                "solutionTags": [],
                "code": "```\\n<comma> ::= \",\"\\n<bool> ::= \"t\" | \"f\"\\n<lparen> ::= \"(\"\\n<rparen> ::= \")\"\\n<not_expr> ::= \"!\" <lparen> <expr> <rparen>\\n<and_expr> ::= \"&\" <lparen> <expr> (<comma> <expr>)+ <rparen>\\n<or_expr> ::= \"|\" <lparen> <expr> (<comma> <expr>)+ <rparen>\\n<expr> ::= <bool> | <not_expr> | <and_expr> | <or_expr>\\n```\n```\\nclass Solution {\\n    int pos = 0; // a global source code position marker\\n    String src = \"\";\\n    public boolean parseBoolExpr(String expression) {\\n        pos = 0;\\n        src = expression;\\n        return parseExpr(); // call the entry rule\\n    }\\n    private boolean parseExpr() {\\n        if(src.charAt(pos) == \\'t\\') { //<expr> ::= \"t\"\\n            ++pos;\\n            return true;\\n        }\\n        if(src.charAt(pos) == \\'f\\') { //<expr> ::= \"f\"\\n            ++pos;\\n            return false;\\n        }\\n        boolean result = false;\\n        switch(src.charAt(pos)) {\\n\\t\\t//<not_expr> ::= \"!\" <lparen> <expr> <rparen>\\n            case \\'!\\': \\n                pos ++; //eat operator\\n                result = parseNotExpr();\\n                break;\\n\\t\\t//<or_expr> ::= \"|\" <lparen> <expr> (<comma> <expr>)+ <rparen>\\n            case \\'|\\':\\n                pos ++; //eat operator\\n                result = parseOrExpr();\\n                break;\\n\\t\\t//<and_expr> ::= \"&\" <lparen> <expr> (<comma> <expr>)+ <rparen>\\n            case \\'&\\':\\n                pos ++; //eat operator\\n                result = parseAndExpr();\\n                break;\\n        }\\n        return result;\\n    }\\n    private boolean parseNotExpr() {\\n        ++pos; //eat lparen\\n        boolean result = parseExpr();\\n        ++pos; //eat rparen\\n        return !result;\\n    }\\n    private boolean parseOrExpr() {\\n        ++pos; //eat lparen\\n        boolean result = parseExpr();\\n        while(pos < src.length() && src.charAt(pos) != \\')\\') {\\n            if(src.charAt(pos) == \\',\\') ++pos;\\n            else {\\n                result |= parseExpr();\\n            }\\n        }\\n        ++pos; //eat rparen\\n        return result;\\n    }\\n    private boolean parseAndExpr() {\\n        ++pos; //eat lparen\\n        boolean result = parseExpr();\\n        while(pos < src.length() && src.charAt(pos) != \\')\\') {\\n            if(src.charAt(pos) == \\',\\') ++pos;\\n            else {\\n                result &= parseExpr();\\n            }\\n        }\\n        ++pos; //eat rparen\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094182,
                "title": "c-easy-to-understand-20-lines",
                "content": "# Approach\\nUse recursive algorithm:\\n\\n* Parse operation\\n    * If it is simple expression (operation is \\'t\\' or \\'f\\') then return value.\\n    * Otherwise, recursively parse all subexpressions and calculate expression.\\n* Return resulting value\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: worse $$O(n)$$, average $$O(1)$$ amortized\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string e) {\\n        auto it = e.begin();\\n        return parse(it);\\n    }\\n\\n    bool parse(string::iterator& it) {\\n        switch (*(it++)) {\\n            case \\'t\\': return true;\\n            case \\'f\\': return false;\\n            case \\'|\\': return parse(it, false, [](bool init, bool val){ return init || val; });\\n            case \\'&\\': return parse(it, true,  [](bool init, bool val){ return init && val; });\\n            case \\'!\\': return parse(it, false, [](bool init, bool val){ return !val; });\\n        }\\n        return false;\\n    }\\n\\n    bool parse(string::iterator& it, bool init, function<bool(bool, bool)> op) {\\n        it++; // skip \\'(\\'\\n        while (true) {\\n            auto b = parse(it);\\n            init = op(init, b);\\n            if (*it == \\')\\') break;\\n            it++; // skip \\',\\'\\n        }\\n        it++; // skip \\')\\'\\n        return init;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string e) {\\n        auto it = e.begin();\\n        return parse(it);\\n    }\\n\\n    bool parse(string::iterator& it) {\\n        switch (*(it++)) {\\n            case \\'t\\': return true;\\n            case \\'f\\': return false;\\n            case \\'|\\': return parse(it, false, [](bool init, bool val){ return init || val; });\\n            case \\'&\\': return parse(it, true,  [](bool init, bool val){ return init && val; });\\n            case \\'!\\': return parse(it, false, [](bool init, bool val){ return !val; });\\n        }\\n        return false;\\n    }\\n\\n    bool parse(string::iterator& it, bool init, function<bool(bool, bool)> op) {\\n        it++; // skip \\'(\\'\\n        while (true) {\\n            auto b = parse(it);\\n            init = op(init, b);\\n            if (*it == \\')\\') break;\\n            it++; // skip \\',\\'\\n        }\\n        it++; // skip \\')\\'\\n        return init;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323367,
                "title": "python-short-solution-using-stack",
                "content": "The idea is as follows:\\n\\n1. When encountering a \"t\" or \"f\", we evaluate it right away\\n2. If its not t or f, then it has to be an operator. In which case, we evaluate everything between \\'(\\' and \\')\\' using recursion and by storing them in a stack.\\n3. once we encounter \\')\\', we simply evaluate &, | and ! by evaluating the operands stored in the stack.\\n4. The one good pattern to follow is, once we finish evaluating a particular expression, we also return the index i+1, to the caller, so that the high level caller can continue evaluating other expressions from this returned index.\\n```\\ndef parseBoolExpr(self, e: str) -> bool:\\n        def ev(i):\\n            if e[i] in [\"t\", \"f\"]:\\n                return True if e[i] == \"t\" else False, i+1\\n            op = e[i]\\n            i, st = i+2, []\\n            while e[i] != \\')\\':\\n                if e[i] == \\',\\': \\n                    i += 1\\n                    continue\\n                res, i = ev(i)\\n                st.append(res)\\n            if op == \\'&\\':\\n                return all(st), i+1\\n            elif op == \\'|\\':\\n                return any(st), i+1\\n            elif op == \\'!\\':\\n                return not st[0], i+1\\n        res, i = ev(0)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef parseBoolExpr(self, e: str) -> bool:\\n        def ev(i):\\n            if e[i] in [\"t\", \"f\"]:\\n                return True if e[i] == \"t\" else False, i+1\\n            op = e[i]\\n            i, st = i+2, []\\n            while e[i] != \\')\\':\\n                if e[i] == \\',\\': \\n                    i += 1\\n                    continue\\n                res, i = ev(i)\\n                st.append(res)\\n            if op == \\'&\\':\\n                return all(st), i+1\\n            elif op == \\'|\\':\\n                return any(st), i+1\\n            elif op == \\'!\\':\\n                return not st[0], i+1\\n        res, i = ev(0)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 685663,
                "title": "python-easy-stack-solution",
                "content": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        func = {\\'&\\' : all, \\'|\\' : any, \\'!\\' : lambda x : not x[0]}\\n        \\n        stack = []\\n        for c in expression:\\n            if c in func:\\n                stack.append(func[c])\\n            elif c == \\'(\\':\\n                stack.append(\\'(\\')\\n            elif c == \\'f\\':\\n                stack.append(False)\\n            elif c == \\'t\\':\\n                stack.append(True)\\n                \\n            elif c == \\')\\':\\n                ss = []\\n                while stack[-1] != \\'(\\':\\n                    ss.append(stack.pop())\\n                stack.pop()\\n                stack.append(stack.pop()(ss))\\n\\n        return stack.pop()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        func = {\\'&\\' : all, \\'|\\' : any, \\'!\\' : lambda x : not x[0]}\\n        \\n        stack = []\\n        for c in expression:\\n            if c in func:\\n                stack.append(func[c])\\n            elif c == \\'(\\':\\n                stack.append(\\'(\\')\\n            elif c == \\'f\\':\\n                stack.append(False)\\n            elif c == \\'t\\':\\n                stack.append(True)\\n                \\n            elif c == \\')\\':\\n                ss = []\\n                while stack[-1] != \\'(\\':\\n                    ss.append(stack.pop())\\n                stack.pop()\\n                stack.append(stack.pop()(ss))\\n\\n        return stack.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548688,
                "title": "java-clean-code-with-iterative-approach-using-stack",
                "content": "```java\\npublic boolean parseBoolExpr(String expression) {\\n\\tif (expression == null || expression.length() == 0) return false;\\n\\n\\tStack<Character> ops = new Stack<>();\\n\\tStack<Boolean> operands = new Stack<>();\\n\\n\\tfor (int i = 0; i < expression.length(); i++) {\\n\\t\\tchar ch = expression.charAt(i);\\n\\n\\t\\tif (ch == \\'f\\')\\n\\t\\t\\toperands.push(false);\\n\\t\\telse if (ch == \\'t\\')\\n\\t\\t\\toperands.push(true);\\n\\t\\telse if (ch == \\'(\\')\\n\\t\\t\\toperands.push(null);\\n\\t\\telse if (ch == \\')\\') {\\n\\t\\t\\tchar operator = ops.pop();\\n\\n\\t\\t\\tboolean res = true;\\n\\t\\t\\tif (operator == \\'|\\')\\n\\t\\t\\t\\tres = false;\\n\\n\\t\\t\\twhile (!operands.isEmpty() && operands.peek() != null) {\\n\\t\\t\\t\\tif (operator == \\'|\\') \\n\\t\\t\\t\\t\\tres |= operands.pop();\\n\\t\\t\\t\\telse if (operator == \\'&\\')\\n\\t\\t\\t\\t\\tres &= operands.pop();\\n\\t\\t\\t\\telse if (operator == \\'!\\')\\n\\t\\t\\t\\t\\tres = !operands.pop(); \\n\\t\\t\\t}\\n\\t\\t\\toperands.pop();\\n\\t\\t\\toperands.push(res);\\n\\n\\t\\t} else if (ch == \\',\\') \\n\\t\\t\\tcontinue;\\n\\t\\telse {\\n\\t\\t\\tops.push(ch);\\n\\t\\t}\\n\\t}\\n\\treturn operands.peek();\\n}",
                "solutionTags": [],
                "code": "```java\\npublic boolean parseBoolExpr(String expression) {\\n\\tif (expression == null || expression.length() == 0) return false;\\n\\n\\tStack<Character> ops = new Stack<>();\\n\\tStack<Boolean> operands = new Stack<>();\\n\\n\\tfor (int i = 0; i < expression.length(); i++) {\\n\\t\\tchar ch = expression.charAt(i);\\n\\n\\t\\tif (ch == \\'f\\')\\n\\t\\t\\toperands.push(false);\\n\\t\\telse if (ch == \\'t\\')\\n\\t\\t\\toperands.push(true);\\n\\t\\telse if (ch == \\'(\\')\\n\\t\\t\\toperands.push(null);\\n\\t\\telse if (ch == \\')\\') {\\n\\t\\t\\tchar operator = ops.pop();\\n\\n\\t\\t\\tboolean res = true;\\n\\t\\t\\tif (operator == \\'|\\')\\n\\t\\t\\t\\tres = false;\\n\\n\\t\\t\\twhile (!operands.isEmpty() && operands.peek() != null) {\\n\\t\\t\\t\\tif (operator == \\'|\\') \\n\\t\\t\\t\\t\\tres |= operands.pop();\\n\\t\\t\\t\\telse if (operator == \\'&\\')\\n\\t\\t\\t\\t\\tres &= operands.pop();\\n\\t\\t\\t\\telse if (operator == \\'!\\')\\n\\t\\t\\t\\t\\tres = !operands.pop(); \\n\\t\\t\\t}\\n\\t\\t\\toperands.pop();\\n\\t\\t\\toperands.push(res);\\n\\n\\t\\t} else if (ch == \\',\\') \\n\\t\\t\\tcontinue;\\n\\t\\telse {\\n\\t\\t\\tops.push(ch);\\n\\t\\t}\\n\\t}\\n\\treturn operands.peek();\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 323341,
                "title": "clean-java-solution",
                "content": "```\\n  public boolean parseBoolExpr(String s) {\\n    if (s.equals(\"t\")) return true;\\n    if (s.equals(\"f\")) return false;\\n    char[] arr = s.toCharArray();\\n    char op = arr[0];\\n    boolean result = op != \\'|\\';\\n    int count = 0;\\n    for (int i = 1, pre = 2; i < arr.length; i++) {\\n      char c = arr[i];\\n      if (c == \\'(\\') count++;\\n      if (c == \\')\\') count--;\\n      if (c == \\',\\' && count == 1 || c == \\')\\' && count == 0) {\\n        boolean next = parseBoolExpr(s.substring(pre, i));\\n        pre = i + 1;\\n        if (op == \\'|\\') result |= next;\\n        else if (op == \\'&\\') result &= next;\\n        else result = !next;\\n      }\\n    }\\n    return result;\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  public boolean parseBoolExpr(String s) {\\n    if (s.equals(\"t\")) return true;\\n    if (s.equals(\"f\")) return false;\\n    char[] arr = s.toCharArray();\\n    char op = arr[0];\\n    boolean result = op != \\'|\\';\\n    int count = 0;\\n    for (int i = 1, pre = 2; i < arr.length; i++) {\\n      char c = arr[i];\\n      if (c == \\'(\\') count++;\\n      if (c == \\')\\') count--;\\n      if (c == \\',\\' && count == 1 || c == \\')\\' && count == 0) {\\n        boolean next = parseBoolExpr(s.substring(pre, i));\\n        pre = i + 1;\\n        if (op == \\'|\\') result |= next;\\n        else if (op == \\'&\\') result &= next;\\n        else result = !next;\\n      }\\n    }\\n    return result;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1366561,
                "title": "c-two-stacks-with-intuition",
                "content": "## Basic Idea of Question\\nThis question is basically a prefix expression evaluation question, with a small modification to include more than two arguments to operands.\\nSo now each operand is followed by a pair of parenthesis, which contain the arguments to the operand separated by commas (,).\\nWe are guaranteed to get a valid expression, so we can avoid doing many preliminary checks like parenthesis matching and number of arguments for each operand, and instead focus on implementing this multi argument system.\\n<br/>\\n## Approach\\nWe start off with the basic solution, with two stacks, one for the operands, and one for the operators and other symbols. For each operand, we have a pair of parenthesis after it, which contains its arguments. So when we encounter any operator (&, ! or |) we just push it to the operators stack. For \\'t\\' or \\'f\\' we push the corresponding boolean value on the operands stack. When we encounter an open bracket we again push it to the operators stack. The same with commas (,). The interesting and most important case is that of the closing bracket ( **\\')\\'** ).\\nHere we need to evaluate the expression uptil the nearest open bracket and push the result onto the operands stack.\\n\\nWe keep pushing the operators stack until we reach an open bracket, counting the number of commas in between. The operator just after it on the stack will be the operator which has all the current arguments. The number of arguments of the operator is given by ```commas + 1```, and we pop that many operands from the stack, performing the required operation on them.\\n\\nFor the & operation, we start from a result of ```true```, since **```true & a = a.```**. Similarly for | operation, we start with a result of ```false``` since **```false | a = a```**. For the ! operation, we don\\'t need to go into the loop, since we know it only has one operand, and hence we handle it separately and then continue to the next iteration.\\n\\nThis method of evaluating closed brackets first guarantees that whenever we iterate backwards to evaluate the expression, the expression only contains simple operands (true or false) separated by commas, since any other expression would have been evaluated to one of these values by then.\\n\\nAt the end of the iteration, we are left with only one operand on the operands stack and that is the result of the entire expression. We return it.\\n<br/>\\n## Code\\n```\\nbool parseBoolExpr(string expression) {\\n\\tint n = expression.size();\\n\\tstack<bool> operands;\\n\\tstack<char> operators;\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tif(expression[i] == \\'!\\' || expression[i] == \\'&\\' || expression[i] == \\'|\\' || expression[i] == \\'(\\' || expression[i] == \\',\\') {\\n\\t\\t\\toperators.push(expression[i]);\\n\\t\\t}\\n\\t\\telse if(expression[i] == \\'t\\' || expression[i] == \\'f\\') {\\n\\t\\t\\tif(expression[i] == \\'t\\') operands.push(true);\\n\\t\\t\\telse operands.push(false);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// \\')\\'\\n\\t\\t\\tint commas = 0;\\n\\t\\t\\twhile(operators.top() != \\'(\\') {\\n\\t\\t\\t\\tchar curr_op =  operators.top();\\n\\t\\t\\t\\toperators.pop();\\n\\t\\t\\t\\tif(curr_op == \\',\\') commas++;\\n\\t\\t\\t}\\n\\t\\t\\toperators.pop();\\n\\t\\t\\tchar curr_op = operators.top();\\n\\t\\t\\toperators.pop();\\n\\t\\t\\tbool result;\\n\\t\\t\\tif(curr_op == \\'!\\') {\\n\\t\\t\\t\\tresult = !operands.top();\\n\\t\\t\\t\\toperands.pop();\\n\\t\\t\\t\\toperands.push(result);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\telse if(curr_op == \\'&\\') {\\n\\t\\t\\t\\tresult = true;\\n\\t\\t\\t}\\n\\t\\t\\telse if(curr_op == \\'|\\') {\\n\\t\\t\\t\\tresult = false;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i<=commas; i++) {\\n\\t\\t\\t\\t//number of commas + 1\\n\\t\\t\\t\\tif(curr_op == \\'&\\') {\\n\\t\\t\\t\\t\\tresult &= operands.top();\\n\\t\\t\\t\\t\\toperands.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(curr_op == \\'|\\') {\\n\\t\\t\\t\\t\\tresult |= operands.top();\\n\\t\\t\\t\\t\\toperands.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\toperands.push(result);\\n\\t\\t}\\n\\t}\\n\\treturn operands.top();\\n}\\n```\\n<br/>\\n\\n## Complexity\\n**Time: O(n)** as every element is iterated over twice, first during the storage phase, and another time while evaluating the expression.\\n**Space: O(n)** which is the stack space required for two stacks.\\n\\nActually the time complexity is proportional to the number of sub expressions to evaluate, which is almost equal to n.\\n<br/>\\nPlease upvote the post if you liked it, and feel free to ask any doubts or suggest any corrections/improvements in the comments.",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```commas + 1```\n```true```\n```true & a = a.```\n```false```\n```false | a = a```\n```\\nbool parseBoolExpr(string expression) {\\n\\tint n = expression.size();\\n\\tstack<bool> operands;\\n\\tstack<char> operators;\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tif(expression[i] == \\'!\\' || expression[i] == \\'&\\' || expression[i] == \\'|\\' || expression[i] == \\'(\\' || expression[i] == \\',\\') {\\n\\t\\t\\toperators.push(expression[i]);\\n\\t\\t}\\n\\t\\telse if(expression[i] == \\'t\\' || expression[i] == \\'f\\') {\\n\\t\\t\\tif(expression[i] == \\'t\\') operands.push(true);\\n\\t\\t\\telse operands.push(false);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// \\')\\'\\n\\t\\t\\tint commas = 0;\\n\\t\\t\\twhile(operators.top() != \\'(\\') {\\n\\t\\t\\t\\tchar curr_op =  operators.top();\\n\\t\\t\\t\\toperators.pop();\\n\\t\\t\\t\\tif(curr_op == \\',\\') commas++;\\n\\t\\t\\t}\\n\\t\\t\\toperators.pop();\\n\\t\\t\\tchar curr_op = operators.top();\\n\\t\\t\\toperators.pop();\\n\\t\\t\\tbool result;\\n\\t\\t\\tif(curr_op == \\'!\\') {\\n\\t\\t\\t\\tresult = !operands.top();\\n\\t\\t\\t\\toperands.pop();\\n\\t\\t\\t\\toperands.push(result);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\telse if(curr_op == \\'&\\') {\\n\\t\\t\\t\\tresult = true;\\n\\t\\t\\t}\\n\\t\\t\\telse if(curr_op == \\'|\\') {\\n\\t\\t\\t\\tresult = false;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i<=commas; i++) {\\n\\t\\t\\t\\t//number of commas + 1\\n\\t\\t\\t\\tif(curr_op == \\'&\\') {\\n\\t\\t\\t\\t\\tresult &= operands.top();\\n\\t\\t\\t\\t\\toperands.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(curr_op == \\'|\\') {\\n\\t\\t\\t\\t\\tresult |= operands.top();\\n\\t\\t\\t\\t\\toperands.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\toperands.push(result);\\n\\t\\t}\\n\\t}\\n\\treturn operands.top();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323709,
                "title": "java-c-python-concise-straightforward-stack-no-recursion",
                "content": "**Java**\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> stack = new Stack<Character>(), cache = new Stack<Character>();\\n        for (char c: expression.toCharArray()) {\\n            if (c == \\')\\') {\\n                cache.clear();\\n                while (stack.peek() != \\'(\\')\\n                    cache.push(stack.pop());\\n                stack.pop();\\n                char cur = stack.pop();\\n                if (cur == \\'&\\')\\n                    stack.push(cache.contains(\\'f\\') ? \\'f\\':\\'t\\');\\n                else if (cur == \\'|\\')\\n                    stack.push(cache.contains(\\'t\\') ? \\'t\\':\\'f\\');\\n                else\\n                    stack.push(cache.pop() == \\'t\\' ? \\'f\\': \\'t\\');\\n            }\\n            else if (c != \\',\\')\\n                stack.push(c);\\n        }\\n        return stack.pop() == \\'t\\' ? true: false;\\n    }\\n}\\n```\\n**C#**\\n```\\npublic class Solution {\\n    public bool ParseBoolExpr(string expression) {\\n        Stack<char> stack = new Stack<char>(), cache = new Stack<char>();\\n        foreach(char c in expression) {\\n            if (c == \\')\\') {\\n                cache.Clear();\\n                while (stack.Peek() != \\'(\\')\\n                    cache.Push(stack.Pop());\\n                stack.Pop();\\n                char cur = stack.Pop();\\n                if (cur == \\'&\\')\\n                    stack.Push(cache.Contains(\\'f\\') ? \\'f\\':\\'t\\');\\n                else if (cur == \\'|\\')\\n                    stack.Push(cache.Contains(\\'t\\') ? \\'t\\':\\'f\\');\\n                else\\n                    stack.Push(cache.Pop() == \\'t\\' ? \\'f\\': \\'t\\');\\n            }\\n            else if (c != \\',\\')\\n                stack.Push(c);\\n        }\\n        return stack.Pop() == \\'t\\' ? true: false;\\n    }\\n}\\n\\n```\\n**Python**\\n```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        for c in expression:\\n            if c == \\')\\':\\n                cache = []\\n                while stack[-1] != \\'(\\':\\n                    cache.append(stack.pop())\\n                stack.pop()\\n                cur = stack.pop()\\n                stack.append(all(cache) if cur == \\'&\\' else any(cache) if cur == \\'|\\' else not cache.pop())\\n            elif c != \\',\\':\\n                stack.append(True if c == \\'t\\' else False if c == \\'f\\' else c)\\n        return stack.pop()        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> stack = new Stack<Character>(), cache = new Stack<Character>();\\n        for (char c: expression.toCharArray()) {\\n            if (c == \\')\\') {\\n                cache.clear();\\n                while (stack.peek() != \\'(\\')\\n                    cache.push(stack.pop());\\n                stack.pop();\\n                char cur = stack.pop();\\n                if (cur == \\'&\\')\\n                    stack.push(cache.contains(\\'f\\') ? \\'f\\':\\'t\\');\\n                else if (cur == \\'|\\')\\n                    stack.push(cache.contains(\\'t\\') ? \\'t\\':\\'f\\');\\n                else\\n                    stack.push(cache.pop() == \\'t\\' ? \\'f\\': \\'t\\');\\n            }\\n            else if (c != \\',\\')\\n                stack.push(c);\\n        }\\n        return stack.pop() == \\'t\\' ? true: false;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public bool ParseBoolExpr(string expression) {\\n        Stack<char> stack = new Stack<char>(), cache = new Stack<char>();\\n        foreach(char c in expression) {\\n            if (c == \\')\\') {\\n                cache.Clear();\\n                while (stack.Peek() != \\'(\\')\\n                    cache.Push(stack.Pop());\\n                stack.Pop();\\n                char cur = stack.Pop();\\n                if (cur == \\'&\\')\\n                    stack.Push(cache.Contains(\\'f\\') ? \\'f\\':\\'t\\');\\n                else if (cur == \\'|\\')\\n                    stack.Push(cache.Contains(\\'t\\') ? \\'t\\':\\'f\\');\\n                else\\n                    stack.Push(cache.Pop() == \\'t\\' ? \\'f\\': \\'t\\');\\n            }\\n            else if (c != \\',\\')\\n                stack.Push(c);\\n        }\\n        return stack.Pop() == \\'t\\' ? true: false;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        for c in expression:\\n            if c == \\')\\':\\n                cache = []\\n                while stack[-1] != \\'(\\':\\n                    cache.append(stack.pop())\\n                stack.pop()\\n                cur = stack.pop()\\n                stack.append(all(cache) if cur == \\'&\\' else any(cache) if cur == \\'|\\' else not cache.pop())\\n            elif c != \\',\\':\\n                stack.append(True if c == \\'t\\' else False if c == \\'f\\' else c)\\n        return stack.pop()        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 356016,
                "title": "c-easy-understanding-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> pac;\\n        for(char ch :expression) {\\n            if(ch == \\',\\') continue;\\n            else if(ch == \\')\\') helper(pac);\\n            else pac.push(ch);\\n        }\\n        return pac.top() == \\'t\\'? true :false ;\\n    }\\n    void helper(stack<char> & pac) {\\n        bool hasf = false;\\n        bool hast = false;\\n        while(pac.top()!=\\'(\\') {\\n            char e = pac.top();\\n            pac.pop();  \\n            if(e == \\'t\\') hast= true;\\n            if(e == \\'f\\') hasf= true;\\n        }\\n        pac.pop();\\n        char exp = pac.top();\\n        pac.pop();\\n        if(exp == \\'!\\') pac.push (hasf? \\'t\\' : \\'f\\');\\n        if(exp == \\'&\\') pac.push (!hasf? \\'t\\' : \\'f\\');\\n        if(exp == \\'|\\') pac.push (hast? \\'t\\' : \\'f\\');\\n    }\\n};\\n````\\ntime O(N)  - one iteration through string  (n) , meanwhile deal with the stack still O(n)\\nspace O(N)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> pac;\\n        for(char ch :expression) {\\n            if(ch == \\',\\') continue;\\n            else if(ch == \\')\\') helper(pac);\\n            else pac.push(ch);\\n        }\\n        return pac.top() == \\'t\\'? true :false ;\\n    }\\n    void helper(stack<char> & pac) {\\n        bool hasf = false;\\n        bool hast = false;\\n        while(pac.top()!=\\'(\\') {\\n            char e = pac.top();\\n            pac.pop();  \\n            if(e == \\'t\\') hast= true;\\n            if(e == \\'f\\') hasf= true;\\n        }\\n        pac.pop();\\n        char exp = pac.top();\\n        pac.pop();\\n        if(exp == \\'!\\') pac.push (hasf? \\'t\\' : \\'f\\');\\n        if(exp == \\'&\\') pac.push (!hasf? \\'t\\' : \\'f\\');\\n        if(exp == \\'|\\') pac.push (hast? \\'t\\' : \\'f\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451429,
                "title": "c-stack",
                "content": "* `find` evaluate the net result of expression.\\n* For  `&` , one false is enough to determine the result (False).\\n* For  `|` , one true is enough to determine the result (True).\\n* For `\\'!\\'`, invert true or false.  \\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool OPERATOR(char ch){\\n        return (ch == \\'&\\' || ch == \\'|\\' || ch == \\'&\\' || ch == \\'!\\') ;\\n    }\\n    \\n    char find(int T , int F , char op){\\n        if(op == \\'!\\') return T ? \\'f\\' : \\'t\\' ;\\n        else if(op == \\'|\\') return T ? \\'t\\' : \\'f\\' ;\\n        else if(op == \\'&\\') return F ? \\'f\\' : \\'t\\' ;\\n        return \\'a\\' ;\\n    }\\n    bool parseBoolExpr(string exp) {\\n        stack<char> st ;\\n        for(int i = 0 ; i < exp.size() ; ++i ){\\n            if(exp[i] == \\',\\') continue ;\\n            \\n            if(OPERATOR(exp[i]) || exp[i] == \\'t\\' || exp[i] == \\'f\\' || exp[i] == \\'(\\') st.push(exp[i]) ;\\n            else if(exp[i] == \\')\\'){\\n                //evaluate and push to top\\n                int T = 0 , F = 0 ;\\n                char op ;\\n                while(st.size() and st.top() != \\'(\\'){\\n                    if(st.top() == \\'t\\') ++T ;\\n                    else if(st.top() == \\'f\\') ++F ;\\n                    st.pop() ;\\n                }\\n                st.pop() ; //remove the opening bracket \\n                op = st.top() ; st.pop() ; //just begin the bracket the operator will be there\\n                st.push(find(T,F,op)) ;\\n            }\\n        }   \\n        return st.top() == \\'t\\' ? ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool OPERATOR(char ch){\\n        return (ch == \\'&\\' || ch == \\'|\\' || ch == \\'&\\' || ch == \\'!\\') ;\\n    }\\n    \\n    char find(int T , int F , char op){\\n        if(op == \\'!\\') return T ? \\'f\\' : \\'t\\' ;\\n        else if(op == \\'|\\') return T ? \\'t\\' : \\'f\\' ;\\n        else if(op == \\'&\\') return F ? \\'f\\' : \\'t\\' ;\\n        return \\'a\\' ;\\n    }\\n    bool parseBoolExpr(string exp) {\\n        stack<char> st ;\\n        for(int i = 0 ; i < exp.size() ; ++i ){\\n            if(exp[i] == \\',\\') continue ;\\n            \\n            if(OPERATOR(exp[i]) || exp[i] == \\'t\\' || exp[i] == \\'f\\' || exp[i] == \\'(\\') st.push(exp[i]) ;\\n            else if(exp[i] == \\')\\'){\\n                //evaluate and push to top\\n                int T = 0 , F = 0 ;\\n                char op ;\\n                while(st.size() and st.top() != \\'(\\'){\\n                    if(st.top() == \\'t\\') ++T ;\\n                    else if(st.top() == \\'f\\') ++F ;\\n                    st.pop() ;\\n                }\\n                st.pop() ; //remove the opening bracket \\n                op = st.top() ; st.pop() ; //just begin the bracket the operator will be there\\n                st.push(find(T,F,op)) ;\\n            }\\n        }   \\n        return st.top() == \\'t\\' ? ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2353598,
                "title": "java-simulation-with-stacks-clean-code",
                "content": "Convert it to infix notation and simulate it. All the `,` becomes the operator that came before it.\\nFor example\\n```\\n\"|(t,f,f)\" -> (true | false | false)\\n\"!(t)\" -> (!true)\\n```\\n\\n#### Java\\n```Java\\n// Time O(n)\\n// Space O(n)\\n// https://en.wikipedia.org/wiki/Shunting_yard_algorithm\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Deque<Boolean> stack = new ArrayDeque<>(); // store the computational result\\n        Deque<Character> op = new ArrayDeque<>();  // store the pending operators\\n        Deque<Character> p  = new ArrayDeque<>();  // store the operator for the current level.\\n        for (char ch : expression.toCharArray()){\\n            switch(ch){\\n                case \\'!\\', \\'&\\', \\'|\\' -> p.push(ch); // enter a new level, update the current operator.\\n                case \\'f\\', \\'t\\' -> stack.push(ch == \\'t\\'); // leaf node, push true or false directly into the stack\\n                case \\'(\\' -> {op.push(ch); if (p.peek() == \\'!\\') op.push(\\'!\\');} // Add ! if the current lvl operator is !\\n                case \\')\\' -> {go(op, stack); op.pop(); p.pop();} // process pending operators and pop off top items from op [\\'(\\'] and p (lvl ended).\\n                default  -> {go(op, stack); op.push(p.peek());} // process pending operators and push current operator onto op.\\n            };\\n        }\\n        go(op, stack); // process remaining operators.\\n        return stack.pop(); // It is guaranteed that there will only be 1 element left on the stack - that\\'s the answer.\\n    }\\n\\n    private void go(Deque<Character> op, Deque<Boolean> stack){\\n        while(!op.isEmpty() && op.peek() != \\'(\\'){\\n            switch(op.pop()){\\n                case \\'|\\' -> stack.push(stack.pop() | stack.pop());\\n                case \\'&\\' -> stack.push(stack.pop() & stack.pop());\\n                default  -> stack.push(!stack.pop());\\n            };\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\"|(t,f,f)\" -> (true | false | false)\\n\"!(t)\" -> (!true)\\n```\n```Java\\n// Time O(n)\\n// Space O(n)\\n// https://en.wikipedia.org/wiki/Shunting_yard_algorithm\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Deque<Boolean> stack = new ArrayDeque<>(); // store the computational result\\n        Deque<Character> op = new ArrayDeque<>();  // store the pending operators\\n        Deque<Character> p  = new ArrayDeque<>();  // store the operator for the current level.\\n        for (char ch : expression.toCharArray()){\\n            switch(ch){\\n                case \\'!\\', \\'&\\', \\'|\\' -> p.push(ch); // enter a new level, update the current operator.\\n                case \\'f\\', \\'t\\' -> stack.push(ch == \\'t\\'); // leaf node, push true or false directly into the stack\\n                case \\'(\\' -> {op.push(ch); if (p.peek() == \\'!\\') op.push(\\'!\\');} // Add ! if the current lvl operator is !\\n                case \\')\\' -> {go(op, stack); op.pop(); p.pop();} // process pending operators and pop off top items from op [\\'(\\'] and p (lvl ended).\\n                default  -> {go(op, stack); op.push(p.peek());} // process pending operators and push current operator onto op.\\n            };\\n        }\\n        go(op, stack); // process remaining operators.\\n        return stack.pop(); // It is guaranteed that there will only be 1 element left on the stack - that\\'s the answer.\\n    }\\n\\n    private void go(Deque<Character> op, Deque<Boolean> stack){\\n        while(!op.isEmpty() && op.peek() != \\'(\\'){\\n            switch(op.pop()){\\n                case \\'|\\' -> stack.push(stack.pop() | stack.pop());\\n                case \\'&\\' -> stack.push(stack.pop() & stack.pop());\\n                default  -> stack.push(!stack.pop());\\n            };\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916944,
                "title": "c-easy-understanding-stack",
                "content": "1> make a stack;\\n2> We don\\'t need \\'(\\' and \\',\\' for calculation;\\n3> rest push everything in stack;\\n4> we will start evaluating the expression when we encounter \\')\\' and push the result back in stack;\\n  a> while evaluating the expression we just need to check if we encoundered one true and one false;\\n  \\n\\n```\\nbool parseBoolExpr(string e) {\\n        stack<char> s;\\n        for(auto x:e){\\n            if(x==\\'(\\' || x==\\',\\') continue;\\n            if(x==\\')\\'){\\n                bool t = false;\\n                bool f = false;\\n                while(s.top() == \\'t\\' || s.top() == \\'f\\'){\\n                    if(s.top() == \\'t\\') t = true;\\n                    if(s.top() == \\'f\\') f = true;\\n                    s.pop();\\n                }\\n                \\n                char ex = s.top();\\n                s.pop();\\n                char p;\\n                if(ex==\\'&\\'){\\n                    p=f?\\'f\\':\\'t\\';\\n                }\\n                else if(ex==\\'|\\'){\\n                    p=t?\\'t\\':\\'f\\';\\n                }\\n                else{\\n                    p=t?\\'f\\':\\'t\\';\\n                }\\n                s.push(p);\\n                continue;\\n            }\\n            s.push(x);\\n        }\\n        return s.top()==\\'t\\'? true:false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nbool parseBoolExpr(string e) {\\n        stack<char> s;\\n        for(auto x:e){\\n            if(x==\\'(\\' || x==\\',\\') continue;\\n            if(x==\\')\\'){\\n                bool t = false;\\n                bool f = false;\\n                while(s.top() == \\'t\\' || s.top() == \\'f\\'){\\n                    if(s.top() == \\'t\\') t = true;\\n                    if(s.top() == \\'f\\') f = true;\\n                    s.pop();\\n                }\\n                \\n                char ex = s.top();\\n                s.pop();\\n                char p;\\n                if(ex==\\'&\\'){\\n                    p=f?\\'f\\':\\'t\\';\\n                }\\n                else if(ex==\\'|\\'){\\n                    p=t?\\'t\\':\\'f\\';\\n                }\\n                else{\\n                    p=t?\\'f\\':\\'t\\';\\n                }\\n                s.push(p);\\n                continue;\\n            }\\n            s.push(x);\\n        }\\n        return s.top()==\\'t\\'? true:false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1582694,
                "title": "one-pass-with-stack-97-speed",
                "content": "![image](https://assets.leetcode.com/users/images/d5ac6556-04fd-440f-9d02-5cc63bc7e299_1637142671.9336207.png)\\n```\\nclass Solution:\\n    operands = {\"!\", \"&\", \"|\", \"t\", \"f\"}\\n    values = {\"t\", \"f\"}\\n\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        for c in expression:\\n            if c == \")\":\\n                val = stack.pop()\\n                args = set()\\n                while val in Solution.values:\\n                    args.add(val)\\n                    val = stack.pop()\\n                if val == \"!\":\\n                    stack.append(\"f\" if \"t\" in args else \"t\")\\n                elif val == \"&\":\\n                    stack.append(\"f\" if \"f\" in args else \"t\")\\n                elif val == \"|\":\\n                    stack.append(\"t\" if \"t\" in args else \"f\")\\n            elif c in Solution.operands:\\n                stack.append(c)\\n        return stack[0] == \"t\"\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    operands = {\"!\", \"&\", \"|\", \"t\", \"f\"}\\n    values = {\"t\", \"f\"}\\n\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        for c in expression:\\n            if c == \")\":\\n                val = stack.pop()\\n                args = set()\\n                while val in Solution.values:\\n                    args.add(val)\\n                    val = stack.pop()\\n                if val == \"!\":\\n                    stack.append(\"f\" if \"t\" in args else \"t\")\\n                elif val == \"&\":\\n                    stack.append(\"f\" if \"f\" in args else \"t\")\\n                elif val == \"|\":\\n                    stack.append(\"t\" if \"t\" in args else \"f\")\\n            elif c in Solution.operands:\\n                stack.append(c)\\n        return stack[0] == \"t\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573286,
                "title": "java-simple-and-short-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> stack = new Stack<Character>();\\n        for (char c : expression.toCharArray()) {\\n            if (c != \\')\\')\\n                stack.push(c);\\n            else {\\n                boolean hasTrue = false, hasFalse = false;\\n                while (stack.peek() != \\'(\\') {\\n                    char ch = stack.pop();\\n                    if (ch == \\'f\\')\\n                        hasFalse = true;\\n                    else if (ch == \\'t\\')\\n                        hasTrue = true;\\n                }\\n                stack.pop();\\n                char symbol = stack.pop();\\n                if (symbol == \\'&\\') {\\n                    if (hasFalse)\\n                        stack.push(\\'f\\');\\n                    else\\n                        stack.push(\\'t\\');\\n                }\\n                else if (symbol == \\'|\\') {\\n                    if (hasTrue)\\n                        stack.push(\\'t\\');\\n                    else\\n                        stack.push(\\'f\\');\\n                }\\n                else {\\n                    if (hasTrue)\\n                        stack.push(\\'f\\');\\n                    else\\n                        stack.push(\\'t\\');\\n                }\\n            }\\n        }\\n        return (stack.pop() == \\'t\\') ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> stack = new Stack<Character>();\\n        for (char c : expression.toCharArray()) {\\n            if (c != \\')\\')\\n                stack.push(c);\\n            else {\\n                boolean hasTrue = false, hasFalse = false;\\n                while (stack.peek() != \\'(\\') {\\n                    char ch = stack.pop();\\n                    if (ch == \\'f\\')\\n                        hasFalse = true;\\n                    else if (ch == \\'t\\')\\n                        hasTrue = true;\\n                }\\n                stack.pop();\\n                char symbol = stack.pop();\\n                if (symbol == \\'&\\') {\\n                    if (hasFalse)\\n                        stack.push(\\'f\\');\\n                    else\\n                        stack.push(\\'t\\');\\n                }\\n                else if (symbol == \\'|\\') {\\n                    if (hasTrue)\\n                        stack.push(\\'t\\');\\n                    else\\n                        stack.push(\\'f\\');\\n                }\\n                else {\\n                    if (hasTrue)\\n                        stack.push(\\'f\\');\\n                    else\\n                        stack.push(\\'t\\');\\n                }\\n            }\\n        }\\n        return (stack.pop() == \\'t\\') ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522838,
                "title": "c-o-n-time-stack-iterative",
                "content": "```\\nclass Solution {\\npublic:\\n    char evaluate(stack<char>&s){\\n        bool has_true=false;\\n        bool has_false=false;\\n        while(s.top()!=\\'&\\' && s.top()!=\\'!\\' && s.top()!=\\'|\\'){\\n            if(s.top()==\\'t\\')\\n                has_true=true;\\n            else\\n                has_false=true;\\n            s.pop();\\n        }\\n        if(s.top()==\\'&\\'){\\n            if(has_false==false)\\n                return \\'t\\';\\n        }\\n        else if(s.top()==\\'!\\'){\\n            if(has_false==true)\\n                return \\'t\\';\\n        }\\n        else{\\n            if(has_true==true)\\n                return \\'t\\';\\n        }\\n        return \\'f\\';\\n    }\\n    bool parseBoolExpr(string expression) {\\n        stack<char>s;\\n        for(auto ch:expression){\\n            if(ch!=\\')\\' && ch!=\\'(\\' && ch!=\\',\\')\\n                s.push(ch);\\n            if(ch==\\')\\'){\\n                char temp=evaluate(s);\\n                s.pop();\\n                s.push(temp);\\n            }\\n        }\\n        return s.top()==\\'t\\'?true:false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char evaluate(stack<char>&s){\\n        bool has_true=false;\\n        bool has_false=false;\\n        while(s.top()!=\\'&\\' && s.top()!=\\'!\\' && s.top()!=\\'|\\'){\\n            if(s.top()==\\'t\\')\\n                has_true=true;\\n            else\\n                has_false=true;\\n            s.pop();\\n        }\\n        if(s.top()==\\'&\\'){\\n            if(has_false==false)\\n                return \\'t\\';\\n        }\\n        else if(s.top()==\\'!\\'){\\n            if(has_false==true)\\n                return \\'t\\';\\n        }\\n        else{\\n            if(has_true==true)\\n                return \\'t\\';\\n        }\\n        return \\'f\\';\\n    }\\n    bool parseBoolExpr(string expression) {\\n        stack<char>s;\\n        for(auto ch:expression){\\n            if(ch!=\\')\\' && ch!=\\'(\\' && ch!=\\',\\')\\n                s.push(ch);\\n            if(ch==\\')\\'){\\n                char temp=evaluate(s);\\n                s.pop();\\n                s.push(temp);\\n            }\\n        }\\n        return s.top()==\\'t\\'?true:false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354946,
                "title": "java-oop-solution-inspired-by-aahmedov",
                "content": "Concept Idea Post: https://leetcode.com/problems/parsing-a-boolean-expression/discuss/343700/Java-OOP-Solution\\n\\n```\\nclass Solution{\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Expr> stack = new Stack<>();\\n        char[] chars = expression.toCharArray();\\n\\n        for(int i = 0; i < chars.length; i ++) {\\n            if(chars[i] == \\'!\\')\\n                stack.push(new Not());\\n            else if(chars[i] == \\'&\\')\\n                stack.push(new And());\\n            else if(chars[i] == \\'|\\')\\n                stack.push(new Or());\\n            else if(chars[i] == \\'t\\')\\n                stack.peek().add(true);\\n            else if(chars[i] == \\'f\\')\\n                stack.peek().add(false);\\n            else if(chars[i] == \\')\\'){\\n                boolean curr = stack.pop().eval();\\n\\n                if(stack.isEmpty())\\n                    return curr;\\n\\n                stack.peek().add(curr);\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private abstract class Expr {\\n        List<Boolean> list;\\n\\n        public Expr(){\\n            list = new ArrayList<>();\\n        }\\n\\n        public void add(boolean b) {\\n            list.add(b);\\n        }\\n\\n        public abstract boolean eval();\\n    }\\n\\n    private class And extends Expr {\\n        public boolean eval(){\\n            for(int i = 0; i < list.size(); i ++) {\\n                if(!list.get(i))\\n                    return false;\\n            }\\n\\n            return true;\\n        }\\n    }\\n\\n    private class Or extends Expr {\\n        public boolean eval(){\\n            for(int i = 0; i < list.size(); i ++) {\\n                if(list.get(i))\\n                    return true;\\n            }\\n\\n            return false;\\n        }\\n    }\\n\\n    private class Not extends Expr {\\n        public boolean eval(){\\n            return !list.get(0);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Expr> stack = new Stack<>();\\n        char[] chars = expression.toCharArray();\\n\\n        for(int i = 0; i < chars.length; i ++) {\\n            if(chars[i] == \\'!\\')\\n                stack.push(new Not());\\n            else if(chars[i] == \\'&\\')\\n                stack.push(new And());\\n            else if(chars[i] == \\'|\\')\\n                stack.push(new Or());\\n            else if(chars[i] == \\'t\\')\\n                stack.peek().add(true);\\n            else if(chars[i] == \\'f\\')\\n                stack.peek().add(false);\\n            else if(chars[i] == \\')\\'){\\n                boolean curr = stack.pop().eval();\\n\\n                if(stack.isEmpty())\\n                    return curr;\\n\\n                stack.peek().add(curr);\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private abstract class Expr {\\n        List<Boolean> list;\\n\\n        public Expr(){\\n            list = new ArrayList<>();\\n        }\\n\\n        public void add(boolean b) {\\n            list.add(b);\\n        }\\n\\n        public abstract boolean eval();\\n    }\\n\\n    private class And extends Expr {\\n        public boolean eval(){\\n            for(int i = 0; i < list.size(); i ++) {\\n                if(!list.get(i))\\n                    return false;\\n            }\\n\\n            return true;\\n        }\\n    }\\n\\n    private class Or extends Expr {\\n        public boolean eval(){\\n            for(int i = 0; i < list.size(); i ++) {\\n                if(list.get(i))\\n                    return true;\\n            }\\n\\n            return false;\\n        }\\n    }\\n\\n    private class Not extends Expr {\\n        public boolean eval(){\\n            return !list.get(0);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329879,
                "title": "python3-easy-to-understand-2-stack-solution",
                "content": "Basically, the idea is to maintain two stacks: \\n1. function stack, storing \"|\", \"&\" or \"!\" function objects\\n2. expression stack, storing cooresponding pools (each pool map to one function in the above func list): True of False\\n\\nThen we loop thru the expression:\\n* when encounter function symbol, we push to the func stack\\n* when encounter boolean symbol (i.e. \"t\" or \"f\"), we push to the corresponding pool of expressions\\n* when encounter \")\", it means we need to evaluate our last pool using our last function, then push back to the pool\\n\\nTime: O(n), where n means the length of the expression\\nSpace: O(2n) -> O(n), where we\\'re using two stacks to store the function objects and boolean values\\n\\n```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        if not expression:\\n            return True\\n        \\n        funcs = [] # stack to store evaluating functions\\n        exprs = [] # stack to store pool(s) of expressions for each eval func in above list\\n        \\n        functions = {\"|\": any, \"!\": lambda x: x[0]^True, \"&\": all}\\n        bools = {\"t\": True, \"f\": False}\\n        \\n        for c in expression:\\n            if c in functions:\\n                exprs.append(list())\\n                funcs.append(functions.get(c)) # append a func obj\\n            elif c in bools:\\n\\t\\t\\t\\tif not len(exprs):\\n\\t\\t\\t\\t\\texprs.append([])\\n                exprs[-1].append(bools.get(c)) # append a bool val\\n            elif c == \")\":\\n                cur = funcs.pop()(exprs.pop())\\n                if len(exprs):\\n                    exprs[-1].append(cur)\\n                else:\\n                    exprs.append([cur])\\n        \\n        return exprs[-1][0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        if not expression:\\n            return True\\n        \\n        funcs = [] # stack to store evaluating functions\\n        exprs = [] # stack to store pool(s) of expressions for each eval func in above list\\n        \\n        functions = {\"|\": any, \"!\": lambda x: x[0]^True, \"&\": all}\\n        bools = {\"t\": True, \"f\": False}\\n        \\n        for c in expression:\\n            if c in functions:\\n                exprs.append(list())\\n                funcs.append(functions.get(c)) # append a func obj\\n            elif c in bools:\\n\\t\\t\\t\\tif not len(exprs):\\n\\t\\t\\t\\t\\texprs.append([])\\n                exprs[-1].append(bools.get(c)) # append a bool val\\n            elif c == \")\":\\n                cur = funcs.pop()(exprs.pop())\\n                if len(exprs):\\n                    exprs[-1].append(cur)\\n                else:\\n                    exprs.append([cur])\\n        \\n        return exprs[-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329224,
                "title": "easy-readable-solution-java-similar-to-polish-notation",
                "content": "```\\npublic boolean parseBoolExpr(String expression) {\\n\\n        Stack<Character> operator = new Stack<>();\\n\\n        for (int i=expression.length()-1;i>=0;i--) {\\n            char c = expression.charAt(i);\\n            if(c==\\')\\' || c==\\'f\\' || c==\\'t\\') {\\n                operator.push(c);\\n            }else if(c==\\'(\\') {\\n                StringBuilder sb = new StringBuilder();\\n                if(i!=0) {\\n                    char op = expression.charAt(i-1);\\n                    while (!operator.empty() && operator.peek()!=\\')\\') {\\n                        char a = operator.pop();\\n                        if(Character.isAlphabetic(a)) {\\n                            sb.append(a);\\n                        }\\n                    }\\n                    operator.pop();\\n                    operator.push(performOperation(sb.toString(), op));\\n                }\\n            }\\n        }\\n\\n        return operator.pop() == \\'t\\';\\n    }\\n\\n    private char performOperation(String s,char op) {\\n        if(op==\\'!\\') {\\n            return s.equals(\"t\")?\\'f\\':\\'t\\';\\n        } else if(op==\\'|\\') {\\n            boolean flag = s.charAt(0) != \\'f\\';\\n            for (int i=1;i<s.length();i++) {\\n                flag = flag | (s.charAt(i) != \\'f\\');\\n            }\\n            return !flag ?\\'f\\':\\'t\\';\\n        } else {\\n            boolean flag = s.charAt(0) != \\'f\\';\\n            for (int i=1;i<s.length();i++) {\\n                flag = flag & (s.charAt(i) != \\'f\\');\\n            }\\n            return !flag ?\\'f\\':\\'t\\';\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean parseBoolExpr(String expression) {\\n\\n        Stack<Character> operator = new Stack<>();\\n\\n        for (int i=expression.length()-1;i>=0;i--) {\\n            char c = expression.charAt(i);\\n            if(c==\\')\\' || c==\\'f\\' || c==\\'t\\') {\\n                operator.push(c);\\n            }else if(c==\\'(\\') {\\n                StringBuilder sb = new StringBuilder();\\n                if(i!=0) {\\n                    char op = expression.charAt(i-1);\\n                    while (!operator.empty() && operator.peek()!=\\')\\') {\\n                        char a = operator.pop();\\n                        if(Character.isAlphabetic(a)) {\\n                            sb.append(a);\\n                        }\\n                    }\\n                    operator.pop();\\n                    operator.push(performOperation(sb.toString(), op));\\n                }\\n            }\\n        }\\n\\n        return operator.pop() == \\'t\\';\\n    }\\n\\n    private char performOperation(String s,char op) {\\n        if(op==\\'!\\') {\\n            return s.equals(\"t\")?\\'f\\':\\'t\\';\\n        } else if(op==\\'|\\') {\\n            boolean flag = s.charAt(0) != \\'f\\';\\n            for (int i=1;i<s.length();i++) {\\n                flag = flag | (s.charAt(i) != \\'f\\');\\n            }\\n            return !flag ?\\'f\\':\\'t\\';\\n        } else {\\n            boolean flag = s.charAt(0) != \\'f\\';\\n            for (int i=1;i<s.length();i++) {\\n                flag = flag & (s.charAt(i) != \\'f\\');\\n            }\\n            return !flag ?\\'f\\':\\'t\\';\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323689,
                "title": "inconsistency-in-test-case-and-description",
                "content": "The problem statement says\\n```\\n\"&(expr1,expr2,...)\", evaluating to the logical AND of 2 or more inner expressions expr1, expr2, ...;\\n\"|(expr1,expr2,...)\", evaluating to the logical OR of 2 or more inner expressions expr1, expr2, ...\\n```\\n\\nBut in the test case `\"!(&(!(t),&(f),|(f)))\"` the last `&` and `|` evaluate a single inner expression.",
                "solutionTags": [],
                "code": "```\\n\"&(expr1,expr2,...)\", evaluating to the logical AND of 2 or more inner expressions expr1, expr2, ...;\\n\"|(expr1,expr2,...)\", evaluating to the logical OR of 2 or more inner expressions expr1, expr2, ...\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323303,
                "title": "java-solution-using-stack",
                "content": "* Declare 2 stacks, one for operands and another for operators. Push all operands including \\'(\\', \\'t\\', \\'f\\' onto operands stack and push all operators including \\'|\\', \\'&\\', \\'!\\' onto operator stack.\\n* Whenever a close bracket is encountered, pop all the elements from operand stack until matching open bracket \\'(\\' is found. Also pop one operator from operator stack.\\n* Append all operands in a string and process with operator. If operator is \\'&\\' and there is a single \\'f\\' found, return false immediately. If operator is \\'!\\', invert operand.\\n* Have a count if there exists atleast 1 \\'t\\', and return true if found so.\\n* Pop the open bracket \\'(\\' from operand stack and add result back into stack.\\n* Finally, pop the last value from stack and return true or false.\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> operands = new Stack<Character>();\\n        Stack<Character> operators = new Stack<Character>();\\n        for(char ch: expression.toCharArray()) {\\n            if(ch == \\',\\') {\\n                continue;\\n            } else if(ch == \\'(\\' || ch == \\'t\\' || ch == \\'f\\') {\\n                operands.push(ch);            \\n            } else if(ch == \\')\\') {\\n                //pop until open bracket\\n                boolean val = false;\\n                char opr = operators.pop();\\n                String popped = \"\";\\n                while(!operands.isEmpty() && operands.peek() != \\'(\\') {\\n                    popped += operands.pop();\\n                }\\n                val = eval(opr, popped);\\n                if(!operands.isEmpty())\\n                    operands.pop();\\n                if(val == true)\\n                    operands.push(\\'t\\');\\n                else \\n                    operands.push(\\'f\\');\\n            } else if(ch == \\'&\\' || ch == \\'|\\' || ch == \\'!\\') {\\n                operators.push(ch);\\n            }\\n        }\\n        char res = operands.pop();\\n        if(res == \\'t\\')\\n            return true;\\n        else\\n            return false;\\n    }\\n    public boolean eval(char opr, String popped) {\\n        int tcount = 0;\\n        for(char ch:popped.toCharArray()) {\\n            if(ch == \\'t\\')\\n                tcount++;\\n            if(opr == \\'&\\' && ch == \\'f\\')\\n                return false;\\n            else if(opr == \\'!\\' && ch == \\'t\\')\\n                return false;\\n            else if(opr == \\'!\\' && ch == \\'f\\')\\n                return true;\\n        } \\n        return tcount > 0? true: false;\\n    }\\n}\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> operands = new Stack<Character>();\\n        Stack<Character> operators = new Stack<Character>();\\n        for(char ch: expression.toCharArray()) {\\n            if(ch == \\',\\') {\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3335785,
                "title": "stack-time-space-90-beats-short-sweet-c",
                "content": "````\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string str) {\\n        vector<char> s;\\n        int f = 0, t = 0,c;\\n        for(auto &i: str){\\n            if(i==\\',\\')continue;\\n            if(i==\\')\\'){\\n                f = 0, t = 0;\\n                c = \\'#\\';\\n                while(s.back() != \\'(\\'){\\n                    if(s.back()==\\'f\\')f++;\\n                    else if(s.back()==\\'t\\')t++;\\n                    s.pop_back();\\n                }\\n                s.pop_back();\\n                c = s.back();\\n                s.pop_back();\\n                if(c==\\'#\\')continue;\\n                if(c==\\'|\\'){\\n                    // cout<<\\'|\\';\\n                    if(t){\\n                       s.push_back(\\'t\\'); \\n                    }else{\\n                        s.push_back(\\'f\\');\\n                    }\\n                }else if(c==\\'!\\'){\\n                    cout<<\\'!\\';\\n                    if(f){\\n                        s.push_back(\\'t\\');\\n                    }else{\\n                        s.push_back(\\'f\\');\\n                    }\\n                }else{\\n                    cout<<\\'&\\';\\n                    if(f){\\n                       s.push_back(\\'f\\'); \\n                    }else{\\n                        s.push_back(\\'t\\');\\n                    }\\n                }\\n                // cout<<\" \"<<s.back()<<\" \"<<s.size()<<endl;\\n            }else{\\n                s.push_back(i);\\n            }\\n        }\\n        return s.back()==\\'f\\'?false:true;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string str) {\\n        vector<char> s;\\n        int f = 0, t = 0,c;\\n        for(auto &i: str){\\n            if(i==\\',\\')continue;\\n            if(i==\\')\\'){\\n                f = 0, t = 0;\\n                c = \\'#\\';\\n                while(s.back() != \\'(\\'){\\n                    if(s.back()==\\'f\\')f++;\\n                    else if(s.back()==\\'t\\')t++;\\n                    s.pop_back();\\n                }\\n                s.pop_back();\\n                c = s.back();\\n                s.pop_back();\\n                if(c==\\'#\\')continue;\\n                if(c==\\'|\\'){\\n                    // cout<<\\'|\\';\\n                    if(t){\\n                       s.push_back(\\'t\\'); \\n                    }else{\\n                        s.push_back(\\'f\\');\\n                    }\\n                }else if(c==\\'!\\'){\\n                    cout<<\\'!\\';\\n                    if(f){\\n                        s.push_back(\\'t\\');\\n                    }else{\\n                        s.push_back(\\'f\\');\\n                    }\\n                }else{\\n                    cout<<\\'&\\';\\n                    if(f){\\n                       s.push_back(\\'f\\'); \\n                    }else{\\n                        s.push_back(\\'t\\');\\n                    }\\n                }\\n                // cout<<\" \"<<s.back()<<\" \"<<s.size()<<endl;\\n            }else{\\n                s.push_back(i);\\n            }\\n        }\\n        return s.back()==\\'f\\'?false:true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2913876,
                "title": "solved-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint closeString(string s, int i){\\n    stack<char> st;\\n    for(i; i<s.length(); i++){\\n        if(s[i]==\\'(\\'){\\n            st.push(\\'(\\');\\n        }\\n        else if(s[i]==\\')\\'){\\n            st.pop();\\n        }\\n        if(st.empty()){\\n            break;\\n        }\\n    }\\n        return i;\\n}\\n\\nbool isRight(string s){\\n    stack<char> st;\\n    for(int i=1; i<s.length(); i++){\\n        if(s[i]==\\'(\\'){\\n            st.push(\\'(\\');\\n        }\\n        else if(s[i]==\\')\\'){\\n            st.pop();\\n        }\\n        if(st.empty() && i!=s.length()-1){\\n            return false;\\n        }\\n    }\\n        return true;\\n}\\n\\n\\nstring check(string s, char a){\\n    if(a==\\'&\\'){\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]==\\'f\\'){\\n                return \"f\";\\n            }\\n        }\\n        return \"t\";\\n    } if(a==\\'|\\'){\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]==\\'t\\'){\\n                return \"t\";\\n            }\\n        }\\n        return \"f\";\\n    }\\n    if(a==\\'!\\'){\\n      if(s[0]==\\'t\\'){\\n        return \"f\";\\n      }\\n    }\\n    return \"t\";\\n}\\nbool isBracket(string s){\\n    for(int j=0; j<s.length(); j++){\\n        if(s[j]==\\'(\\' || s[j]==\\')\\'){\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n\\nstring to_oper(char x){\\n    string op=\"\";\\n    if(x==\\'&\\'){\\n        op=\"&\";\\n    }\\n    else if(x==\\'!\\'){\\n        op=\"!\";\\n    }\\n    else{\\n        op=\"|\";\\n    }\\n    return op;\\n}\\nstring solve(string s){\\n     if(!isBracket(s) || s.length()==0){\\n          return s; \\n      }\\n    char a=s[0];  string c=\"\";\\n    string b=s.substr(2, s.length()-3);\\n\\n    if(isBracket(b)){\\n    int k=closeString(b,1);\\n    string x=\"\"; string y=\"\";\\n    x=b.substr(0,k+1);\\n    string h=\"\";\\n    if(b.length()>k+1){\\n    y=b.substr(k+2, s.length()-k-3);\\n    bool r=isRight(y);\\n    cout<<r<<endl;\\n    if(!r){\\n     y=to_oper(a)+\"(\"+y+\")\";\\n     cout<<y<<endl;\\n    }  \\n   h=\",\"+solve(y);\\n    }\\n    c=solve(x)+h;\\n    c= check(c, a);\\n    }\\n    else{\\n      c=solve(b);\\n       c= check(c, a);\\n    }\\n   // cout<<c<<endl;\\n    return c;\\n}\\n    bool parseBoolExpr(string expression) {\\n        string s;\\n        s=solve(expression);\\n        if(s==\"t\"){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint closeString(string s, int i){\\n    stack<char> st;\\n    for(i; i<s.length(); i++){\\n        if(s[i]==\\'(\\'){\\n            st.push(\\'(\\');\\n        }\\n        else if(s[i]==\\')\\'){\\n            st.pop();\\n        }\\n        if(st.empty()){\\n            break;\\n        }\\n    }\\n        return i;\\n}\\n\\nbool isRight(string s){\\n    stack<char> st;\\n    for(int i=1; i<s.length(); i++){\\n        if(s[i]==\\'(\\'){\\n            st.push(\\'(\\');\\n        }\\n        else if(s[i]==\\')\\'){\\n            st.pop();\\n        }\\n        if(st.empty() && i!=s.length()-1){\\n            return false;\\n        }\\n    }\\n        return true;\\n}\\n\\n\\nstring check(string s, char a){\\n    if(a==\\'&\\'){\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]==\\'f\\'){\\n                return \"f\";\\n            }\\n        }\\n        return \"t\";\\n    } if(a==\\'|\\'){\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]==\\'t\\'){\\n                return \"t\";\\n            }\\n        }\\n        return \"f\";\\n    }\\n    if(a==\\'!\\'){\\n      if(s[0]==\\'t\\'){\\n        return \"f\";\\n      }\\n    }\\n    return \"t\";\\n}\\nbool isBracket(string s){\\n    for(int j=0; j<s.length(); j++){\\n        if(s[j]==\\'(\\' || s[j]==\\')\\'){\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n\\nstring to_oper(char x){\\n    string op=\"\";\\n    if(x==\\'&\\'){\\n        op=\"&\";\\n    }\\n    else if(x==\\'!\\'){\\n        op=\"!\";\\n    }\\n    else{\\n        op=\"|\";\\n    }\\n    return op;\\n}\\nstring solve(string s){\\n     if(!isBracket(s) || s.length()==0){\\n          return s; \\n      }\\n    char a=s[0];  string c=\"\";\\n    string b=s.substr(2, s.length()-3);\\n\\n    if(isBracket(b)){\\n    int k=closeString(b,1);\\n    string x=\"\"; string y=\"\";\\n    x=b.substr(0,k+1);\\n    string h=\"\";\\n    if(b.length()>k+1){\\n    y=b.substr(k+2, s.length()-k-3);\\n    bool r=isRight(y);\\n    cout<<r<<endl;\\n    if(!r){\\n     y=to_oper(a)+\"(\"+y+\")\";\\n     cout<<y<<endl;\\n    }  \\n   h=\",\"+solve(y);\\n    }\\n    c=solve(x)+h;\\n    c= check(c, a);\\n    }\\n    else{\\n      c=solve(b);\\n       c= check(c, a);\\n    }\\n   // cout<<c<<endl;\\n    return c;\\n}\\n    bool parseBoolExpr(string expression) {\\n        string s;\\n        s=solve(expression);\\n        if(s==\"t\"){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2094373,
                "title": "efficient-approach-stack-iterative-or-using-iterator",
                "content": "***Using Stack :*** \\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char>s;\\n        for(auto i: expression){\\n            if(i==\\')\\'){\\n                bool hast{false}, hasf{false};\\n                while(s.top()==\\'t\\' or s.top()==\\'f\\' or s.top()==\\',\\'){\\n                    if(s.top()==\\'t\\') hast=true;\\n                    if(s.top()==\\'f\\') hasf=true;\\n                    s.pop();\\n                }\\n                s.pop();\\n                char op=s.top();\\n                s.pop();\\n                if(op==\\'|\\')\\n                {\\n                    s.push(hast==true?\\'t\\':\\'f\\');\\n                }\\n                else if(op==\\'&\\')\\n                {\\n                    s.push(hasf==false?\\'t\\':\\'f\\');\\n                }\\n                else if(op==\\'!\\')\\n                {\\n                    s.push(hast==true?\\'f\\':\\'t\\');\\n                }\\n            }\\n            else {\\n                s.push(i);\\n            }\\n        }\\n        return s.top()==\\'t\\'?true:false;\\n    }\\n};\\n```\\n\\n***Using Iterator (Most Efficient) :***\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        auto it=expression.begin();\\n        return parse(it);\\n    }\\n    \\n    template <class Iterator>\\n    bool parse(Iterator &it){\\n        char ch=*it++;\\n        \\n        switch(ch){\\n            case \\'t\\':\\n                return true;\\n            case \\'f\\':\\n                return false;\\n            case \\'!\\':{\\n                ++it;\\n                bool arg=parse(it);\\n                ++it;\\n                return !arg;\\n            }\\n            case \\'&\\':{\\n                ++it;\\n                bool result=parse(it);\\n                while(*it==\\',\\'){\\n                    ++it;\\n                    bool rhs=parse(it);\\n                    result = result&&rhs;\\n                }\\n                ++it;\\n                return result;\\n            }\\n            case \\'|\\':{\\n                ++it;\\n                bool result = parse(it);\\n                while(*it==\\',\\'){\\n                    ++it;\\n                    bool rhs=parse(it);\\n                    result = result || rhs;\\n                }\\n                ++it;\\n                return result;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char>s;\\n        for(auto i: expression){\\n            if(i==\\')\\'){\\n                bool hast{false}, hasf{false};\\n                while(s.top()==\\'t\\' or s.top()==\\'f\\' or s.top()==\\',\\'){\\n                    if(s.top()==\\'t\\') hast=true;\\n                    if(s.top()==\\'f\\') hasf=true;\\n                    s.pop();\\n                }\\n                s.pop();\\n                char op=s.top();\\n                s.pop();\\n                if(op==\\'|\\')\\n                {\\n                    s.push(hast==true?\\'t\\':\\'f\\');\\n                }\\n                else if(op==\\'&\\')\\n                {\\n                    s.push(hasf==false?\\'t\\':\\'f\\');\\n                }\\n                else if(op==\\'!\\')\\n                {\\n                    s.push(hast==true?\\'f\\':\\'t\\');\\n                }\\n            }\\n            else {\\n                s.push(i);\\n            }\\n        }\\n        return s.top()==\\'t\\'?true:false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        auto it=expression.begin();\\n        return parse(it);\\n    }\\n    \\n    template <class Iterator>\\n    bool parse(Iterator &it){\\n        char ch=*it++;\\n        \\n        switch(ch){\\n            case \\'t\\':\\n                return true;\\n            case \\'f\\':\\n                return false;\\n            case \\'!\\':{\\n                ++it;\\n                bool arg=parse(it);\\n                ++it;\\n                return !arg;\\n            }\\n            case \\'&\\':{\\n                ++it;\\n                bool result=parse(it);\\n                while(*it==\\',\\'){\\n                    ++it;\\n                    bool rhs=parse(it);\\n                    result = result&&rhs;\\n                }\\n                ++it;\\n                return result;\\n            }\\n            case \\'|\\':{\\n                ++it;\\n                bool result = parse(it);\\n                while(*it==\\',\\'){\\n                    ++it;\\n                    bool rhs=parse(it);\\n                    result = result || rhs;\\n                }\\n                ++it;\\n                return result;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945463,
                "title": "java-stack-solution-simple-with-comments",
                "content": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char c: expression.toCharArray()) {\\n            // Dont pass Open Bracket and comma to stack. \\n            if(c == \\'(\\' || c == \\',\\') {\\n                continue;\\n            } \\n            // If Closing Bracket Evaluate Stack till latest operator\\n            if(c == \\')\\') {\\n                // True and False variables to Know truth Value\\n                boolean True = false, False = false;\\n                // Get Truth Values till latest operator\\n                while(stack.peek() == \\'t\\' || stack.peek() == \\'f\\') {\\n                    if(stack.pop() == \\'t\\') {\\n                        True = true;\\n                    } else {\\n                        False = true;\\n                    }\\n                }\\n                char operator = stack.pop(), result;\\n                if(operator == \\'&\\') {\\n                    // One false in AND operation is always false\\n                    result = False ? \\'f\\' : \\'t\\';\\n                } else if(operator == \\'|\\') {\\n                    // One true in OR operation is always true\\n                    result = True ? \\'t\\' : \\'f\\';\\n                } else {\\n                    // Simple Negation\\n                    result = True ? \\'f\\' : \\'t\\';\\n                }\\n                // Push Back the result of evaluation\\n                stack.push(result);\\n                continue;\\n            }\\n            stack.push(c);\\n        }\\n        return stack.pop() == \\'t\\' ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char c: expression.toCharArray()) {\\n            // Dont pass Open Bracket and comma to stack. \\n            if(c == \\'(\\' || c == \\',\\') {\\n                continue;\\n            } \\n            // If Closing Bracket Evaluate Stack till latest operator\\n            if(c == \\')\\') {\\n                // True and False variables to Know truth Value\\n                boolean True = false, False = false;\\n                // Get Truth Values till latest operator\\n                while(stack.peek() == \\'t\\' || stack.peek() == \\'f\\') {\\n                    if(stack.pop() == \\'t\\') {\\n                        True = true;\\n                    } else {\\n                        False = true;\\n                    }\\n                }\\n                char operator = stack.pop(), result;\\n                if(operator == \\'&\\') {\\n                    // One false in AND operation is always false\\n                    result = False ? \\'f\\' : \\'t\\';\\n                } else if(operator == \\'|\\') {\\n                    // One true in OR operation is always true\\n                    result = True ? \\'t\\' : \\'f\\';\\n                } else {\\n                    // Simple Negation\\n                    result = True ? \\'f\\' : \\'t\\';\\n                }\\n                // Push Back the result of evaluation\\n                stack.push(result);\\n                continue;\\n            }\\n            stack.push(c);\\n        }\\n        return stack.pop() == \\'t\\' ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225977,
                "title": "c-0ms-100-faster-sol-commented-fully",
                "content": "**Please upvote if this helps :)**\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<pair<int,int>> s_v;\\n        //s_v pair first denotes the number of \\'t\\' and second denotes the \\n        //number of \\'f\\' values\\n        stack<char> s_o;\\n        //s_o used to store the operators\\n        for(auto c:expression)\\n        {\\n            if(c==\\'(\\')\\n            {\\n                s_v.push({-1,-1}); //indicating a open bracket\\n                s_v.push({0,0}); \\n            }\\n            else if(c==\\'.\\')\\n            {\\n                //do nothing\\n            }\\n            else if(c==\\'!\\' || c==\\'|\\' || c==\\'&\\')\\n            {\\n                //push to operator stack\\n                s_o.push(c);\\n            }\\n            else if(c==\\'t\\' || c==\\'f\\')\\n            {\\n                if(c==\\'t\\')\\n                {\\n                    s_v.top().first++;\\n                }\\n                else{\\n                    s_v.top().second++;\\n                }\\n            }\\n            else if(c==\\')\\')\\n            {\\n                //evaluate the expression\\n                int numTrue=0,numFalse=0;\\n                while(s_v.top().first!=-1)\\n                {\\n                    //until a open bracket is found\\n                    numTrue+=s_v.top().first;\\n                    numFalse+=s_v.top().second;\\n                    s_v.pop();\\n                }\\n                //remove the opening bracket\\n                s_v.pop();\\n                pair<int,int> temp({0,0});\\n                if(s_o.top()==\\'&\\')\\n                {\\n                    //one false leads to false \\n                    (numFalse>=1) ? temp.second=1 : temp.first=1;\\n                }\\n                else if(s_o.top()==\\'|\\')\\n                {\\n                    //one true leads to true\\n                    (numTrue>=1) ?  temp.first=1 : temp.second=1;\\n                }\\n                else{\\n                    //if it is not operator\\n                        (numTrue==1) ? temp.second=1 : temp.first=1;\\n                }\\n                s_v.push(temp);\\n                s_o.pop(); //remove the last operator\\n            }\\n        }\\n        if(s_v.top().first)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<pair<int,int>> s_v;\\n        //s_v pair first denotes the number of \\'t\\' and second denotes the \\n        //number of \\'f\\' values\\n        stack<char> s_o;\\n        //s_o used to store the operators\\n        for(auto c:expression)\\n        {\\n            if(c==\\'(\\')\\n            {\\n                s_v.push({-1,-1}); //indicating a open bracket\\n                s_v.push({0,0}); \\n            }\\n            else if(c==\\'.\\')\\n            {\\n                //do nothing\\n            }\\n            else if(c==\\'!\\' || c==\\'|\\' || c==\\'&\\')\\n            {\\n                //push to operator stack\\n                s_o.push(c);\\n            }\\n            else if(c==\\'t\\' || c==\\'f\\')\\n            {\\n                if(c==\\'t\\')\\n                {\\n                    s_v.top().first++;\\n                }\\n                else{\\n                    s_v.top().second++;\\n                }\\n            }\\n            else if(c==\\')\\')\\n            {\\n                //evaluate the expression\\n                int numTrue=0,numFalse=0;\\n                while(s_v.top().first!=-1)\\n                {\\n                    //until a open bracket is found\\n                    numTrue+=s_v.top().first;\\n                    numFalse+=s_v.top().second;\\n                    s_v.pop();\\n                }\\n                //remove the opening bracket\\n                s_v.pop();\\n                pair<int,int> temp({0,0});\\n                if(s_o.top()==\\'&\\')\\n                {\\n                    //one false leads to false \\n                    (numFalse>=1) ? temp.second=1 : temp.first=1;\\n                }\\n                else if(s_o.top()==\\'|\\')\\n                {\\n                    //one true leads to true\\n                    (numTrue>=1) ?  temp.first=1 : temp.second=1;\\n                }\\n                else{\\n                    //if it is not operator\\n                        (numTrue==1) ? temp.second=1 : temp.first=1;\\n                }\\n                s_v.push(temp);\\n                s_o.pop(); //remove the last operator\\n            }\\n        }\\n        if(s_v.top().first)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 913012,
                "title": "java-recursive-solution-with-explanations-and-comments",
                "content": "Hi! This is my recursive solution to this problem. I commented almost everything. Give a thumbs up if I helped you!\\n;)\\n\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n\\t\\t//Basic cases\\n        if(expression.equals(\"t\"))return true;\\n        else if(expression.length() == 0||expression.equals(\"f\"))return false;\\n\\t\\t\\n        \\n        char first = expression.charAt(0);//represents the first char of \"expression\". Which\\n\\t\\t//has to be either \\'|\\', \\'&\\', or \\'!\\'. (since the algorithm checked if it is \\'t\\' or \\'f\\' at the start)\\n\\t\\t\\n        String body = expression.substring(2, expression.length() - 1);//discard brackets and\\n        //operators\\n\\t\\t\\n        if(first == \\'!\\')return !parseBoolExpr(body);//Logical NOT case: there is only 1\\n\\t\\t//inner expression. So just recurse with the inner expression, and reverse its evaluated value.\\n\\t\\t\\n        else if(first == \\'&\\'){\\n\\t\\t\\t//Logical AND case. Use recursion to figure out the \"inner\" expression!\\n            List<String> splits = splitProper(body);\\n            for(String part : splits){\\n                if(!parseBoolExpr(part))return false;//In an logical AND expression,\\n\\t\\t\\t\\t//when one of the expressions is false, you return false.\\n            }\\n            return true;//If all expressions evaluates to true, return true.\\n        }\\n        else if(first == \\'|\\'){\\n\\t\\t\\t//Logical OR case. Use recursion to figure out the \"inner\" expression!\\n            List<String> splits = splitProper(body);\\n            for(String part : splits){\\n                if(parseBoolExpr(part))return true;//In an logical OR expression,\\n\\t\\t\\t\\t//when one of the expressions is true, you return true.\\n            }\\n            return false;//When all of the expressions evaluates to false, return false.\\n        }\\n        System.out.println(\"ERROR!\");\\n        return false;\\n    }\\n    \\n    //Split into small expressions. Input str should be like this: \"expr1,expr2,...,exprN\"\\n\\t//and each expr is one of { \"t\", \"f\", \"!(another_expr)\", \"|(another_expr)\", \"&(another_expr)\"}\\n\\t//No recursions in this method. All it does is just splitting into multiple\\n\\t//small expressions :)\\n    public List<String> splitProper(String str){\\n        int bracketsMet = 0;//A very simple \"fake\" stack. bracketsMet = N means\\n\\t\\t//when looping str to index i, you came by N left-brackets or \"(\".\\n\\t\\t//Each time you come by a \"(\", add 1 to it. And similarly each time you\\n\\t\\t//come by a \")\", subtract it by 1. A proper split of str should not have\\n\\t\\t//different numbers of left-brackets and right-brackets. Therefore you can\\n\\t\\t//only split when bracketsMet is 0.\\n\\t\\t\\n        int left = 0;\\n        List<String> split = new ArrayList<>();\\n        for(int i = 0;i < str.length();i++){\\n            char c = str.charAt(i);\\n            if(c == \\'(\\')bracketsMet++;//Met a bracket. Uh oh... You can only split if bracketsMet is 0.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t //Think about it!\\n            else if(c == \\',\\' && bracketsMet == 0){\\n                split.add(str.substring(left, i));\\n                left = i + 1;\\n            }\\n            else if(c == \\')\\')bracketsMet--;\\n        }\\n        \\n        split.add(str.substring(left, str.length()));\\n        return split;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n\\t\\t//Basic cases\\n        if(expression.equals(\"t\"))return true;\\n        else if(expression.length() == 0||expression.equals(\"f\"))return false;\\n\\t\\t\\n        \\n        char first = expression.charAt(0);//represents the first char of \"expression\". Which\\n\\t\\t//has to be either \\'|\\', \\'&\\', or \\'!\\'. (since the algorithm checked if it is \\'t\\' or \\'f\\' at the start)\\n\\t\\t\\n        String body = expression.substring(2, expression.length() - 1);//discard brackets and\\n        //operators\\n\\t\\t\\n        if(first == \\'!\\')return !parseBoolExpr(body);//Logical NOT case: there is only 1\\n\\t\\t//inner expression. So just recurse with the inner expression, and reverse its evaluated value.\\n\\t\\t\\n        else if(first == \\'&\\'){\\n\\t\\t\\t//Logical AND case. Use recursion to figure out the \"inner\" expression!\\n            List<String> splits = splitProper(body);\\n            for(String part : splits){\\n                if(!parseBoolExpr(part))return false;//In an logical AND expression,\\n\\t\\t\\t\\t//when one of the expressions is false, you return false.\\n            }\\n            return true;//If all expressions evaluates to true, return true.\\n        }\\n        else if(first == \\'|\\'){\\n\\t\\t\\t//Logical OR case. Use recursion to figure out the \"inner\" expression!\\n            List<String> splits = splitProper(body);\\n            for(String part : splits){\\n                if(parseBoolExpr(part))return true;//In an logical OR expression,\\n\\t\\t\\t\\t//when one of the expressions is true, you return true.\\n            }\\n            return false;//When all of the expressions evaluates to false, return false.\\n        }\\n        System.out.println(\"ERROR!\");\\n        return false;\\n    }\\n    \\n    //Split into small expressions. Input str should be like this: \"expr1,expr2,...,exprN\"\\n\\t//and each expr is one of { \"t\", \"f\", \"!(another_expr)\", \"|(another_expr)\", \"&(another_expr)\"}\\n\\t//No recursions in this method. All it does is just splitting into multiple\\n\\t//small expressions :)\\n    public List<String> splitProper(String str){\\n        int bracketsMet = 0;//A very simple \"fake\" stack. bracketsMet = N means\\n\\t\\t//when looping str to index i, you came by N left-brackets or \"(\".\\n\\t\\t//Each time you come by a \"(\", add 1 to it. And similarly each time you\\n\\t\\t//come by a \")\", subtract it by 1. A proper split of str should not have\\n\\t\\t//different numbers of left-brackets and right-brackets. Therefore you can\\n\\t\\t//only split when bracketsMet is 0.\\n\\t\\t\\n        int left = 0;\\n        List<String> split = new ArrayList<>();\\n        for(int i = 0;i < str.length();i++){\\n            char c = str.charAt(i);\\n            if(c == \\'(\\')bracketsMet++;//Met a bracket. Uh oh... You can only split if bracketsMet is 0.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t //Think about it!\\n            else if(c == \\',\\' && bracketsMet == 0){\\n                split.add(str.substring(left, i));\\n                left = i + 1;\\n            }\\n            else if(c == \\')\\')bracketsMet--;\\n        }\\n        \\n        split.add(str.substring(left, str.length()));\\n        return split;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 627614,
                "title": "explain-me-this-testcase",
                "content": "```\\n\"!(&(!(&(f)),&(t),|(f,f,t)))\"\\n```\\n& AND | should have 2 or more than 2 parameters a/c to the question.....how is this test case correct \\n",
                "solutionTags": [],
                "code": "```\\n\"!(&(!(&(f)),&(t),|(f,f,t)))\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 351852,
                "title": "python3-solution-without-stack-or-recursion-beats-100-on-memory",
                "content": "```class Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        mapping = {\\n            \\'&\\': \\'all\\',\\n            \\'|\\': \\'any\\',\\n            \\'t\\': \\'True\\',\\n            \\'f\\': \\'False\\',\\n            \\'(\\': \\'([\\',\\n            \\')\\': \\'])\\',\\n            \\'!\\': \\'not any\\',\\n        }\\n        for m, v in mapping. items():\\n            expression = expression.replace(m, v)\\n        return(eval(expression))\\n\\t\\t```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        mapping = {\\n            \\'&\\': \\'all\\',\\n            \\'|\\': \\'any\\',\\n            \\'t\\': \\'True\\',\\n            \\'f\\': \\'False\\',\\n            \\'(\\': \\'([\\',\\n            \\')\\': \\'])\\',\\n            \\'!\\': \\'not any\\',\\n        }\\n        for m, v in mapping. items():\\n            expression = expression.replace(m, v)\\n        return(eval(expression))\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 327764,
                "title": "java-one-pass-one-stack-clean",
                "content": "Solution is based on a direct iteration of parsing the expression string. We use stack to keep parts of expression that we parsed. We add to the stack untill we met \\')\\'. At this point we pop out of stack everything down to the recent \\'(\\' - this way we get all elements of one expression. During poping elements we registering trues and falses in a flag variables. Then depends on the operation - \\'!\\', \\'&\\' or \\'|\\' we analyse those flags and set the signle summary of a single expression back to the stack. \\nComplexities - time is O(length_of_string) - because we do the check every char in the expression string, plus max of same n when poping from the stack.\\nspace - O(length_of_string) for the stack.\\n```\\nStack<Character> state = new Stack();\\n    int N = expression.length();\\n    for (int i = 0; i < N; i++) {\\n      char ch = expression.charAt(i);\\n      if (ch == \\')\\') {\\n        //handle end of expression\\n        boolean hasTrue = false;\\n        boolean hasFalse = false;\\n        while(state.peek() != \\'(\\') {\\n          char next = state.pop();\\n          if (next == \\'t\\')\\n            hasTrue = true;\\n          else\\n            hasFalse = true;\\n        }\\n        //\\'(\\'\\n        state.pop();\\n        //action\\n        char oper = state.pop();\\n        if (oper == \\'&\\') {\\n          state.push(hasFalse ? \\'f\\' : \\'t\\');\\n        } else if (oper == \\'|\\') {\\n          state.push(hasTrue ? \\'t\\' : \\'f\\');\\n        } else {\\n          state.push(hasTrue ? \\'f\\' : \\'t\\');\\n        }\\n\\n      } else if (ch != \\',\\') {\\n        state.push(ch);\\n      }\\n    }\\n\\n    return state.pop() == \\'t\\';\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nStack<Character> state = new Stack();\\n    int N = expression.length();\\n    for (int i = 0; i < N; i++) {\\n      char ch = expression.charAt(i);\\n      if (ch == \\')\\') {\\n        //handle end of expression\\n        boolean hasTrue = false;\\n        boolean hasFalse = false;\\n        while(state.peek() != \\'(\\') {\\n          char next = state.pop();\\n          if (next == \\'t\\')\\n            hasTrue = true;\\n          else\\n            hasFalse = true;\\n        }\\n        //\\'(\\'\\n        state.pop();\\n        //action\\n        char oper = state.pop();\\n        if (oper == \\'&\\') {\\n          state.push(hasFalse ? \\'f\\' : \\'t\\');\\n        } else if (oper == \\'|\\') {\\n          state.push(hasTrue ? \\'t\\' : \\'f\\');\\n        } else {\\n          state.push(hasTrue ? \\'f\\' : \\'t\\');\\n        }\\n\\n      } else if (ch != \\',\\') {\\n        state.push(ch);\\n      }\\n    }\\n\\n    return state.pop() == \\'t\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323288,
                "title": "java-solution",
                "content": "\\n    \\n    public boolean parseBoolExpr(String expression) {\\n        char firstChar = expression.charAt(0);\\n        if (expression.length() == 1) {\\n            return  firstChar == \\'t\\';\\n        }\\n\\n        boolean booleanResult;\\n        List<String> partitions;\\n        switch (firstChar) {\\n            case \\'!\\':\\n                return !parseBoolExpr(expression.substring(1));\\n\\n            case \\'|\\':\\n                partitions = parse(expression.substring(1));\\n                booleanResult = parseBoolExpr(partitions.get(0));\\n                for (int i = 1; i < partitions.size(); i++) {\\n                    booleanResult = booleanResult || parseBoolExpr(partitions.get(i));\\n                }\\n                return booleanResult;\\n\\n            case \\'&\\':\\n                partitions = parse(expression.substring(1));\\n                booleanResult = parseBoolExpr(partitions.get(0));\\n                for (int i = 1; i < partitions.size(); i++) {\\n                    booleanResult = booleanResult && parseBoolExpr(partitions.get(i));\\n                }\\n                return booleanResult;\\n        }\\n\\n        return parseBoolExpr(expression.substring(1, expression.length() - 1));\\n    }\\n\\n    private List<String> parse(String expression) {\\n        List<String> partitions = new ArrayList<>();\\n        int openParenthesisCounter = 0;\\n        int closeParenthesisCounter = 0;\\n        int firstCharOfPartition = 1;\\n        for (int i = 1; i < expression.length() - 1; i++) {\\n            char c = expression.charAt(i);\\n            switch (c) {\\n                case \\'(\\':\\n                    ++openParenthesisCounter;\\n                    break;\\n                case \\')\\':\\n                    ++closeParenthesisCounter;\\n                    break;\\n                case \\',\\':\\n                    if (openParenthesisCounter == closeParenthesisCounter) {\\n                        partitions.add(expression.substring(firstCharOfPartition, i));\\n                        firstCharOfPartition = i + 1;\\n                    }\\n            }\\n        }\\n        partitions.add(expression.substring(firstCharOfPartition, expression.length() - 1));\\n\\n        return partitions;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "\\n    \\n    public boolean parseBoolExpr(String expression) {\\n        char firstChar = expression.charAt(0);\\n        if (expression.length() == 1) {\\n            return  firstChar == \\'t\\';\\n        }\\n\\n        boolean booleanResult;\\n        List<String> partitions;\\n        switch (firstChar) {\\n            case \\'!\\':\\n                return !parseBoolExpr(expression.substring(1));\\n\\n            case \\'|\\':\\n                partitions = parse(expression.substring(1));\\n                booleanResult = parseBoolExpr(partitions.get(0));\\n                for (int i = 1; i < partitions.size(); i++) {\\n                    booleanResult = booleanResult || parseBoolExpr(partitions.get(i));\\n                }\\n                return booleanResult;\\n\\n            case \\'&\\':\\n                partitions = parse(expression.substring(1));\\n                booleanResult = parseBoolExpr(partitions.get(0));\\n                for (int i = 1; i < partitions.size(); i++) {\\n                    booleanResult = booleanResult && parseBoolExpr(partitions.get(i));\\n                }\\n                return booleanResult;\\n        }\\n\\n        return parseBoolExpr(expression.substring(1, expression.length() - 1));\\n    }\\n\\n    private List<String> parse(String expression) {\\n        List<String> partitions = new ArrayList<>();\\n        int openParenthesisCounter = 0;\\n        int closeParenthesisCounter = 0;\\n        int firstCharOfPartition = 1;\\n        for (int i = 1; i < expression.length() - 1; i++) {\\n            char c = expression.charAt(i);\\n            switch (c) {\\n                case \\'(\\':\\n                    ++openParenthesisCounter;\\n                    break;\\n                case \\')\\':\\n                    ++closeParenthesisCounter;\\n                    break;\\n                case \\',\\':\\n                    if (openParenthesisCounter == closeParenthesisCounter) {\\n                        partitions.add(expression.substring(firstCharOfPartition, i));\\n                        firstCharOfPartition = i + 1;\\n                    }\\n            }\\n        }\\n        partitions.add(expression.substring(firstCharOfPartition, expression.length() - 1));\\n\\n        return partitions;\\n    }\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3703033,
                "title": "c-easy-to-understand-using-stack",
                "content": "# Intuition\\n- As insertion and deletion operations are supposed to be executed on our string based on LILO, so stack may be the best possible approach.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We need to calculate the boolean expression soon after the closing parenthesis. For the rest we can keep pushing them in stack.\\n- We can have various conditions based on our understanding in boolean expressions.\\n- we can ignore \\'(\\' and \\',\\' as they will affect our continuity and understanding to calculate the expression. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string exp) {\\n        stack<char> s;\\n        for(int i=0;i<exp.size();i++)\\n        {\\n            if(exp[i]==\\')\\')\\n            {\\n                int t=0,f=0;\\n                while(s.top()==\\'t\\'||s.top()==\\'f\\')\\n                {\\n                    if(s.top()==\\'t\\')\\n                    t=1;\\n                    else\\n                    f=1;\\n                    s.pop();\\n                }\\n                char op=s.top();\\n                s.pop();\\n                if(op==\\'|\\')\\n                {\\n                    if(t)\\n                    s.push(\\'t\\');\\n                    else\\n                    s.push(\\'f\\');\\n                }\\n                if(op==\\'!\\')\\n                {\\n                    if(t)\\n                    s.push(\\'f\\');\\n                    else\\n                    s.push(\\'t\\');\\n                }\\n                if(op==\\'&\\')\\n                {\\n                    if(f)\\n                    s.push(\\'f\\');\\n                    else\\n                    s.push(\\'t\\');\\n                }\\n            }\\n            else if(exp[i]!=\\',\\'&&exp[i]!=\\'(\\')\\n            s.push(exp[i]);\\n        } \\n        if(s.top()==\\'t\\')\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string exp) {\\n        stack<char> s;\\n        for(int i=0;i<exp.size();i++)\\n        {\\n            if(exp[i]==\\')\\')\\n            {\\n                int t=0,f=0;\\n                while(s.top()==\\'t\\'||s.top()==\\'f\\')\\n                {\\n                    if(s.top()==\\'t\\')\\n                    t=1;\\n                    else\\n                    f=1;\\n                    s.pop();\\n                }\\n                char op=s.top();\\n                s.pop();\\n                if(op==\\'|\\')\\n                {\\n                    if(t)\\n                    s.push(\\'t\\');\\n                    else\\n                    s.push(\\'f\\');\\n                }\\n                if(op==\\'!\\')\\n                {\\n                    if(t)\\n                    s.push(\\'f\\');\\n                    else\\n                    s.push(\\'t\\');\\n                }\\n                if(op==\\'&\\')\\n                {\\n                    if(f)\\n                    s.push(\\'f\\');\\n                    else\\n                    s.push(\\'t\\');\\n                }\\n            }\\n            else if(exp[i]!=\\',\\'&&exp[i]!=\\'(\\')\\n            s.push(exp[i]);\\n        } \\n        if(s.top()==\\'t\\')\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198553,
                "title": "python-super-easy-solution-easy-to-understand-override-the-property-very-easy",
                "content": "```\\nclass Solution:\\n    \\n    def oro(self,*args):\\n        ans = False\\n        for elm in args:\\n            ans|=elm\\n        return ans\\n    \\n    def ando(self,*args):\\n        ans = True\\n        for elm in args:\\n            ans&=elm\\n        return ans\\n    \\n    def noto(self,args):\\n        return not args\\n    \\n    def parseBoolExpr(self, e: str) -> bool:\\n        e=e.replace(\\'f\\',\\'False\\').replace(\\'t\\',\\'True\\')\\n        e=e.replace(\\'!\\',\\'self.noto\\').replace(\\'|\\',\\'self.oro\\').replace(\\'&\\',\\'self.ando\\')\\n        return eval(e)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def oro(self,*args):\\n        ans = False\\n        for elm in args:\\n            ans|=elm\\n        return ans\\n    \\n    def ando(self,*args):\\n        ans = True\\n        for elm in args:\\n            ans&=elm\\n        return ans\\n    \\n    def noto(self,args):\\n        return not args\\n    \\n    def parseBoolExpr(self, e: str) -> bool:\\n        e=e.replace(\\'f\\',\\'False\\').replace(\\'t\\',\\'True\\')\\n        e=e.replace(\\'!\\',\\'self.noto\\').replace(\\'|\\',\\'self.oro\\').replace(\\'&\\',\\'self.ando\\')\\n        return eval(e)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969279,
                "title": "simple-soln-with-o-n-time-complexity-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    pair<int, bool> exp(string s,int i,int n)\\n    {\\n        if(s[i]==\\'f\\') return {i,false};\\n        else if(s[i]==\\'t\\') return {i,true};\\n        char x=s[i]; bool y;int k=0;i=i+2;\\n        while(i<n && s[i]!=\\')\\')\\n        {\\n           bool z;\\n           if(s[i]==\\'f\\' || s[i]==\\'t\\')\\n           {\\n               if(s[i]==\\'f\\') z=false;\\n                  else z=true;\\n           }\\n           else if(s[i]==\\'|\\' ||s[i]==\\'&\\' || s[i]==\\'!\\') \\n           {\\n             pair<int, bool>p=exp(s,i,n);\\n             i=p.first;\\n             z=p.second;\\n           }\\n           if(k==0)\\n           {\\n               if(x==\\'!\\') y=!z;\\n               else y=z;\\n               k++;\\n           }\\n           else \\n           {\\n                if(x==\\'!\\') y=!z;\\n                else if(x==\\'&\\') y=y&z;\\n                else y=y|z;\\n           }\\n           i++;\\n        }\\n        return {i,y};\\n    }\\n    bool parseBoolExpr(string s) \\n    {\\n       int n=s.size();\\n      pair<int, bool>p= exp(s,0,n);\\n      return p.second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int, bool> exp(string s,int i,int n)\\n    {\\n        if(s[i]==\\'f\\') return {i,false};\\n        else if(s[i]==\\'t\\') return {i,true};\\n        char x=s[i]; bool y;int k=0;i=i+2;\\n        while(i<n && s[i]!=\\')\\')\\n        {\\n           bool z;\\n           if(s[i]==\\'f\\' || s[i]==\\'t\\')\\n           {\\n               if(s[i]==\\'f\\') z=false;\\n                  else z=true;\\n           }\\n           else if(s[i]==\\'|\\' ||s[i]==\\'&\\' || s[i]==\\'!\\') \\n           {\\n             pair<int, bool>p=exp(s,i,n);\\n             i=p.first;\\n             z=p.second;\\n           }\\n           if(k==0)\\n           {\\n               if(x==\\'!\\') y=!z;\\n               else y=z;\\n               k++;\\n           }\\n           else \\n           {\\n                if(x==\\'!\\') y=!z;\\n                else if(x==\\'&\\') y=y&z;\\n                else y=y|z;\\n           }\\n           i++;\\n        }\\n        return {i,y};\\n    }\\n    bool parseBoolExpr(string s) \\n    {\\n       int n=s.size();\\n      pair<int, bool>p= exp(s,0,n);\\n      return p.second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527812,
                "title": "c-simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    stack<char> st, ex;\\n    void evaluate(string &expr)\\n    {\\n        if(ex.top() == \\'!\\')\\n        {\\n            ex.pop();\\n            if(st.top() == \\'t\\')\\n            {\\n                st.pop();\\n                st.pop();\\n                st.push(\\'f\\');\\n            }\\n            else\\n            {\\n                st.pop();\\n                st.pop();\\n                st.push(\\'t\\');\\n            }\\n        }\\n        else if(ex.top() == \\'|\\')\\n        {\\n            ex.pop();\\n            bool tr = false;\\n            while(st.top() != \\'(\\')\\n            {\\n                if(st.top() == \\'t\\')\\n                    tr = true;\\n                st.pop();\\n            }\\n            st.pop();\\n            if(tr)\\n                st.push(\\'t\\');\\n            else\\n                st.push(\\'f\\');\\n        }\\n        else\\n        {\\n            ex.pop();\\n            bool tr = true;\\n            while(st.top() != \\'(\\')\\n            {\\n                if(st.top() == \\'f\\')\\n                    tr = false;\\n                st.pop();\\n            }\\n            st.pop();\\n            if(tr)\\n                st.push(\\'t\\');\\n            else\\n                st.push(\\'f\\');\\n        }\\n    }\\npublic:\\n    bool parseBoolExpr(string expr) {\\n        int i = 0, n = expr.size();\\n        while(i < n)\\n        {\\n            if(expr[i] == \\'(\\' || expr[i] == \\'t\\' || expr[i] == \\'f\\')\\n                st.push(expr[i]);               \\n            if(expr[i] == \\'|\\' || expr[i] == \\'&\\' || expr[i] == \\'!\\')\\n                ex.push(expr[i]);\\n            else if(expr[i] == \\')\\')\\n                evaluate(expr);\\n            i++;\\n        }\\n        if(st.top() == \\'t\\')\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    stack<char> st, ex;\\n    void evaluate(string &expr)\\n    {\\n        if(ex.top() == \\'!\\')\\n        {\\n            ex.pop();\\n            if(st.top() == \\'t\\')\\n            {\\n                st.pop();\\n                st.pop();\\n                st.push(\\'f\\');\\n            }\\n            else\\n            {\\n                st.pop();\\n                st.pop();\\n                st.push(\\'t\\');\\n            }\\n        }\\n        else if(ex.top() == \\'|\\')\\n        {\\n            ex.pop();\\n            bool tr = false;\\n            while(st.top() != \\'(\\')\\n            {\\n                if(st.top() == \\'t\\')\\n                    tr = true;\\n                st.pop();\\n            }\\n            st.pop();\\n            if(tr)\\n                st.push(\\'t\\');\\n            else\\n                st.push(\\'f\\');\\n        }\\n        else\\n        {\\n            ex.pop();\\n            bool tr = true;\\n            while(st.top() != \\'(\\')\\n            {\\n                if(st.top() == \\'f\\')\\n                    tr = false;\\n                st.pop();\\n            }\\n            st.pop();\\n            if(tr)\\n                st.push(\\'t\\');\\n            else\\n                st.push(\\'f\\');\\n        }\\n    }\\npublic:\\n    bool parseBoolExpr(string expr) {\\n        int i = 0, n = expr.size();\\n        while(i < n)\\n        {\\n            if(expr[i] == \\'(\\' || expr[i] == \\'t\\' || expr[i] == \\'f\\')\\n                st.push(expr[i]);               \\n            if(expr[i] == \\'|\\' || expr[i] == \\'&\\' || expr[i] == \\'!\\')\\n                ex.push(expr[i]);\\n            else if(expr[i] == \\')\\')\\n                evaluate(expr);\\n            i++;\\n        }\\n        if(st.top() == \\'t\\')\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437107,
                "title": "c-clean-concise-solution-with-stack",
                "content": "```\\nclass Solution {\\n    void evaluate(pair<bool, char>& top, const bool& value) {\\n        switch (top.second) {\\n            case \\'!\\': top.first = !value; break;\\n            case \\'&\\': top.first &= value; break;\\n            case \\'|\\': top.first |= value;\\n        }\\n    }\\n    \\npublic:\\n    bool parseBoolExpr(const string& expression) {\\n        stack<pair<bool, char>> st;\\n        st.push({true, \\'&\\'});\\n        \\n        for(const char& c: expression)\\n            switch (c) {\\n                case \\'t\\': evaluate(st.top(), true); break;\\n                case \\'f\\': evaluate(st.top(), false); break;\\n                case \\'!\\': st.push({true, \\'!\\'}); break;\\n                case \\'&\\': st.push({true, \\'&\\'}); break;\\n                case \\'|\\': st.push({false, \\'|\\'}); break;\\n                case \\')\\':\\n                    const bool value = st.top().first;\\n                    st.pop();\\n                    evaluate(st.top(), value);\\n            }\\n        \\n        return st.top().first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    void evaluate(pair<bool, char>& top, const bool& value) {\\n        switch (top.second) {\\n            case \\'!\\': top.first = !value; break;\\n            case \\'&\\': top.first &= value; break;\\n            case \\'|\\': top.first |= value;\\n        }\\n    }\\n    \\npublic:\\n    bool parseBoolExpr(const string& expression) {\\n        stack<pair<bool, char>> st;\\n        st.push({true, \\'&\\'});\\n        \\n        for(const char& c: expression)\\n            switch (c) {\\n                case \\'t\\': evaluate(st.top(), true); break;\\n                case \\'f\\': evaluate(st.top(), false); break;\\n                case \\'!\\': st.push({true, \\'!\\'}); break;\\n                case \\'&\\': st.push({true, \\'&\\'}); break;\\n                case \\'|\\': st.push({false, \\'|\\'}); break;\\n                case \\')\\':\\n                    const bool value = st.top().first;\\n                    st.pop();\\n                    evaluate(st.top(), value);\\n            }\\n        \\n        return st.top().first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788995,
                "title": "python-sol-using-stack",
                "content": "class Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        \\n        for i in expression:\\n            if i != \\',\\':\\n                if i == \\')\\':\\n                    temp = set()\\n                    while stack and stack[-1] != \\'(\\':\\n                        temp.add(stack.pop())\\n                    stack.pop()\\n                    op = stack.pop()\\n\\n                    if op == \\'|\\':\\n                        if \\'t\\' in temp:\\n                            stack.append(\\'t\\')\\n                        else:\\n                            stack.append(\\'f\\')\\n\\n                    elif op == \\'&\\':\\n                        if \\'f\\' in temp:\\n                            stack.append(\\'f\\')\\n                        else:\\n                            stack.append(\\'t\\')\\n\\n                    elif op == \\'!\\':\\n                        if \\'t\\' in temp:\\n                            stack.append(\\'f\\')\\n                        else:\\n                            stack.append(\\'t\\')\\n                else:\\n                    stack.append(i)\\n                \\n        return True if stack.pop() == \\'t\\' else False",
                "solutionTags": [],
                "code": "class Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        \\n        for i in expression:\\n            if i != \\',\\':\\n                if i == \\')\\':\\n                    temp = set()\\n                    while stack and stack[-1] != \\'(\\':\\n                        temp.add(stack.pop())\\n                    stack.pop()\\n                    op = stack.pop()\\n\\n                    if op == \\'|\\':\\n                        if \\'t\\' in temp:\\n                            stack.append(\\'t\\')\\n                        else:\\n                            stack.append(\\'f\\')\\n\\n                    elif op == \\'&\\':\\n                        if \\'f\\' in temp:\\n                            stack.append(\\'f\\')\\n                        else:\\n                            stack.append(\\'t\\')\\n\\n                    elif op == \\'!\\':\\n                        if \\'t\\' in temp:\\n                            stack.append(\\'f\\')\\n                        else:\\n                            stack.append(\\'t\\')\\n                else:\\n                    stack.append(i)\\n                \\n        return True if stack.pop() == \\'t\\' else False",
                "codeTag": "Java"
            },
            {
                "id": 343700,
                "title": "java-oop-solution",
                "content": "```\\n    public boolean parseBoolExpr(String expression) {\\n        String exp = expression.trim();\\n        if(exp.isBlank())\\n            throw new IllegalArgumentException(\"Expression can\\'t be empty\");\\n        if(exp.length() == 1)\\n            return exp.equals(\"t\");\\n\\n        Stack<Expr> stack = new Stack<>();\\n        TrueExpr trueExpr = new TrueExpr();\\n        FalseExpr falseExpr = new FalseExpr();\\n        int idx = 0;\\n        while(idx < exp.length()) {\\n            char c = exp.charAt(idx++);\\n            if(c == \\'|\\') stack.push(new OrExpr());\\n            else if(c == \\'&\\') stack.push(new AndExpr());\\n            else if(c == \\'!\\') stack.push(new NegateExpr());\\n            else if(c == \\'f\\') stack.peek().add(falseExpr);\\n            else if(c == \\'t\\') stack.peek().add(trueExpr);\\n            else if(c == \\')\\') {\\n                boolean res = stack.pop().eval();\\n                if(stack.isEmpty())\\n                    return res;\\n                stack.peek().add(res ? trueExpr : falseExpr);\\n            }\\n        }\\n\\n        throw new IllegalStateException();\\n    }\\n\\n    private static abstract class Expr {\\n        List<Expr> list;\\n\\n        private Expr() {\\n            list = new LinkedList<>();\\n        }\\n\\n        abstract boolean eval();\\n\\n        void add(Expr e) {\\n            list.add(e);\\n        }\\n    }\\n\\n    private static class TrueExpr extends Expr {\\n\\n        @Override\\n        boolean eval() {\\n            return true;\\n        }\\n\\n        @Override\\n        void add(Expr e) {\\n            throw new UnsupportedOperationException();\\n        }\\n    }\\n\\n    private static class FalseExpr extends Expr {\\n\\n        @Override\\n        boolean eval() {\\n            return false;\\n        }\\n\\n        @Override\\n        void add(Expr e) {\\n            throw new UnsupportedOperationException();\\n        }\\n    }\\n\\n    private static class NegateExpr extends Expr {\\n\\n        @Override\\n        boolean eval() {\\n            if(list.size() != 1)\\n                throw new IllegalArgumentException(\"Expected one item, got \" + list.size());\\n\\n            return !list.get(0).eval();\\n        }\\n    }\\n\\n    private static class AndExpr extends Expr {\\n\\n        @Override\\n        boolean eval() {\\n            if(list.isEmpty())\\n                throw new IllegalArgumentException(\"Expected at least one item\");\\n\\n            boolean res = list.get(0).eval();\\n            for(int i = 1; i < list.size(); i++)\\n                res &= list.get(i).eval();\\n\\n            return res;\\n        }\\n    }\\n\\n    private static class OrExpr extends Expr {\\n\\n        @Override\\n        boolean eval() {\\n            if(list.isEmpty())\\n                throw new IllegalArgumentException(\"Expected at least one item\");\\n\\n            boolean res = list.get(0).eval();\\n            for(int i = 1; i < list.size(); i++)\\n                res |= list.get(i).eval();\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean parseBoolExpr(String expression) {\\n        String exp = expression.trim();\\n        if(exp.isBlank())\\n            throw new IllegalArgumentException(\"Expression can\\'t be empty\");\\n        if(exp.length() == 1)\\n            return exp.equals(\"t\");\\n\\n        Stack<Expr> stack = new Stack<>();\\n        TrueExpr trueExpr = new TrueExpr();\\n        FalseExpr falseExpr = new FalseExpr();\\n        int idx = 0;\\n        while(idx < exp.length()) {\\n            char c = exp.charAt(idx++);\\n            if(c == \\'|\\') stack.push(new OrExpr());\\n            else if(c == \\'&\\') stack.push(new AndExpr());\\n            else if(c == \\'!\\') stack.push(new NegateExpr());\\n            else if(c == \\'f\\') stack.peek().add(falseExpr);\\n            else if(c == \\'t\\') stack.peek().add(trueExpr);\\n            else if(c == \\')\\') {\\n                boolean res = stack.pop().eval();\\n                if(stack.isEmpty())\\n                    return res;\\n                stack.peek().add(res ? trueExpr : falseExpr);\\n            }\\n        }\\n\\n        throw new IllegalStateException();\\n    }\\n\\n    private static abstract class Expr {\\n        List<Expr> list;\\n\\n        private Expr() {\\n            list = new LinkedList<>();\\n        }\\n\\n        abstract boolean eval();\\n\\n        void add(Expr e) {\\n            list.add(e);\\n        }\\n    }\\n\\n    private static class TrueExpr extends Expr {\\n\\n        @Override\\n        boolean eval() {\\n            return true;\\n        }\\n\\n        @Override\\n        void add(Expr e) {\\n            throw new UnsupportedOperationException();\\n        }\\n    }\\n\\n    private static class FalseExpr extends Expr {\\n\\n        @Override\\n        boolean eval() {\\n            return false;\\n        }\\n\\n        @Override\\n        void add(Expr e) {\\n            throw new UnsupportedOperationException();\\n        }\\n    }\\n\\n    private static class NegateExpr extends Expr {\\n\\n        @Override\\n        boolean eval() {\\n            if(list.size() != 1)\\n                throw new IllegalArgumentException(\"Expected one item, got \" + list.size());\\n\\n            return !list.get(0).eval();\\n        }\\n    }\\n\\n    private static class AndExpr extends Expr {\\n\\n        @Override\\n        boolean eval() {\\n            if(list.isEmpty())\\n                throw new IllegalArgumentException(\"Expected at least one item\");\\n\\n            boolean res = list.get(0).eval();\\n            for(int i = 1; i < list.size(); i++)\\n                res &= list.get(i).eval();\\n\\n            return res;\\n        }\\n    }\\n\\n    private static class OrExpr extends Expr {\\n\\n        @Override\\n        boolean eval() {\\n            if(list.isEmpty())\\n                throw new IllegalArgumentException(\"Expected at least one item\");\\n\\n            boolean res = list.get(0).eval();\\n            for(int i = 1; i < list.size(); i++)\\n                res |= list.get(i).eval();\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339266,
                "title": "java-short-solution",
                "content": "```\\n    public boolean parseBoolExpr(String e) {\\n        Deque<Character> s = new LinkedList<>();\\n        for(char c : e.toCharArray()) {\\n            if(c == \\')\\') {\\n                Set<Character> seen = new HashSet<>();\\n                while(s.peek() != \\'(\\') seen.add(s.pop());\\n                s.pop();\\n                char op = s.pop();\\n                if(op == \\'&\\') {\\n                    s.push(seen.contains(\\'f\\') ? \\'f\\' : \\'t\\');\\n                } else if(op == \\'|\\') {\\n                    s.push(seen.contains(\\'t\\') ? \\'t\\' : \\'f\\');\\n                } else if(op == \\'!\\') {\\n                    s.push(seen.contains(\\'f\\') ? \\'t\\' : \\'f\\');\\n                }\\n            } else if(c != \\',\\') {\\n                s.push(c);\\n            }\\n        }\\n        return s.peek() == \\'t\\' ? true : false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean parseBoolExpr(String e) {\\n        Deque<Character> s = new LinkedList<>();\\n        for(char c : e.toCharArray()) {\\n            if(c == \\')\\') {\\n                Set<Character> seen = new HashSet<>();\\n                while(s.peek() != \\'(\\') seen.add(s.pop());\\n                s.pop();\\n                char op = s.pop();\\n                if(op == \\'&\\') {\\n                    s.push(seen.contains(\\'f\\') ? \\'f\\' : \\'t\\');\\n                } else if(op == \\'|\\') {\\n                    s.push(seen.contains(\\'t\\') ? \\'t\\' : \\'f\\');\\n                } else if(op == \\'!\\') {\\n                    s.push(seen.contains(\\'f\\') ? \\'t\\' : \\'f\\');\\n                }\\n            } else if(c != \\',\\') {\\n                s.push(c);\\n            }\\n        }\\n        return s.peek() == \\'t\\' ? true : false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4010562,
                "title": "c-easy-to-follow-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Recursion is evident from the fact that there are sub problems (**sub-expressions in each operation**) that are required to be evaluated. \\n2. Each of the **subproblem could be solved with the same structure as the main problem** -> reuse the same functions\\n3. The next part of the problem is how to **parse each sub-problem**, i.e. parse the list of sub expresssions in each operation\\n\\n---\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- To parse the expressions with parentheses, have a counter for the number of current left parentheses\\n\\n[Similar approach to this problem](https://leetcode.com/problems/valid-parentheses/)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> parse(string exp){\\n        // parse the string list of expression into sub expressions\\n        vector<string> exps;\\n        int n = exp.size();\\n        int  cur =0;\\n\\n        // number of current left brackets\\n        int left = 0;\\n\\n        while(cur<n){\\n            if(exp[cur] ==\\'t\\'){\\n                exps.push_back(\"t\");\\n                cur+=2;\\n            }\\n            else if(exp[cur]==\\'f\\'){\\n                exps.push_back(\"f\");\\n                cur+=2;\\n            }\\n            else if(exp[cur]==\\'!\\'){\\n                // find the next )\\n\\n                left = 0;\\n                for(int i=cur+1;i<n;++i){\\n                    if(exp[i]==\\'(\\')++left;\\n                    if(exp[i]==\\')\\'){\\n                        --left;\\n                        if(left ==0 ){\\n                            exps.push_back(exp.substr(cur, (i-cur+1)) );\\n                            cur = i+2;\\n                            break;\\n                        }\\n                    }\\n                }\\n\\n            }\\n            else if( exp[cur]==\\'&\\'){\\n                // find the next )\\n\\n                left = 0;\\n                for(int i=cur+1;i<n;++i){\\n                    if(exp[i]==\\'(\\')++left;\\n                    if(exp[i]==\\')\\'){\\n                        --left;\\n                        if(left ==0 ){\\n                            exps.push_back(exp.substr(cur, (i-cur+1)) );\\n                            cur = i+2;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            else{\\n                // find the next )\\n\\n                left = 0;\\n                for(int i=cur+1;i<n;++i){\\n                    if(exp[i]==\\'(\\')++left;\\n                    if(exp[i]==\\')\\'){\\n                        --left;\\n                        if(left ==0 ){\\n                            exps.push_back(exp.substr(cur, (i-cur+1)) );\\n                            cur = i+2;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return exps;\\n    }\\n    bool valAnd(string exp){\\n        // seperate into list of expressions \\n        // return false from the first false\\n        vector<string> exps = parse(exp);\\n\\n        for(int i=0;i<exps.size();++i){\\n            if(!parseBoolExpr(exps[i]))return false;\\n        }\\n        \\n        return true;\\n    }\\n    bool valOr(string exp){\\n        // seperate into list of expressions\\n        // return true from the first true\\n        vector<string> exps = parse(exp);\\n\\n        for(int i=0;i<exps.size();++i){\\n            if(parseBoolExpr(exps[i]))return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    bool valNot(string exp){\\n        // return the NOT of the expression inside\\n        return !parseBoolExpr(exp);\\n    }\\n\\n    bool parseBoolExpr(string exp) {\\n        // recurstion\\n        // split into sub problems\\n\\n        int n = exp.size();\\n        bool eval =false;\\n\\n        if(n==1)return exp[0]==\\'t\\';\\n\\n        if(exp[0]==\\'&\\'){\\n            // if the operation is AND\\n            eval = valAnd(exp.substr(2,n-3));\\n        }\\n        else if(exp[0]==\\'|\\'){\\n            // if the operation is OR\\n            eval = valOr(exp.substr(2,n-3));\\n        }\\n        else{\\n            // if the operation is NOT\\n            eval = valNot(exp.substr(2, n-3));\\n        }\\n\\n        return eval;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> parse(string exp){\\n        // parse the string list of expression into sub expressions\\n        vector<string> exps;\\n        int n = exp.size();\\n        int  cur =0;\\n\\n        // number of current left brackets\\n        int left = 0;\\n\\n        while(cur<n){\\n            if(exp[cur] ==\\'t\\'){\\n                exps.push_back(\"t\");\\n                cur+=2;\\n            }\\n            else if(exp[cur]==\\'f\\'){\\n                exps.push_back(\"f\");\\n                cur+=2;\\n            }\\n            else if(exp[cur]==\\'!\\'){\\n                // find the next )\\n\\n                left = 0;\\n                for(int i=cur+1;i<n;++i){\\n                    if(exp[i]==\\'(\\')++left;\\n                    if(exp[i]==\\')\\'){\\n                        --left;\\n                        if(left ==0 ){\\n                            exps.push_back(exp.substr(cur, (i-cur+1)) );\\n                            cur = i+2;\\n                            break;\\n                        }\\n                    }\\n                }\\n\\n            }\\n            else if( exp[cur]==\\'&\\'){\\n                // find the next )\\n\\n                left = 0;\\n                for(int i=cur+1;i<n;++i){\\n                    if(exp[i]==\\'(\\')++left;\\n                    if(exp[i]==\\')\\'){\\n                        --left;\\n                        if(left ==0 ){\\n                            exps.push_back(exp.substr(cur, (i-cur+1)) );\\n                            cur = i+2;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            else{\\n                // find the next )\\n\\n                left = 0;\\n                for(int i=cur+1;i<n;++i){\\n                    if(exp[i]==\\'(\\')++left;\\n                    if(exp[i]==\\')\\'){\\n                        --left;\\n                        if(left ==0 ){\\n                            exps.push_back(exp.substr(cur, (i-cur+1)) );\\n                            cur = i+2;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return exps;\\n    }\\n    bool valAnd(string exp){\\n        // seperate into list of expressions \\n        // return false from the first false\\n        vector<string> exps = parse(exp);\\n\\n        for(int i=0;i<exps.size();++i){\\n            if(!parseBoolExpr(exps[i]))return false;\\n        }\\n        \\n        return true;\\n    }\\n    bool valOr(string exp){\\n        // seperate into list of expressions\\n        // return true from the first true\\n        vector<string> exps = parse(exp);\\n\\n        for(int i=0;i<exps.size();++i){\\n            if(parseBoolExpr(exps[i]))return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    bool valNot(string exp){\\n        // return the NOT of the expression inside\\n        return !parseBoolExpr(exp);\\n    }\\n\\n    bool parseBoolExpr(string exp) {\\n        // recurstion\\n        // split into sub problems\\n\\n        int n = exp.size();\\n        bool eval =false;\\n\\n        if(n==1)return exp[0]==\\'t\\';\\n\\n        if(exp[0]==\\'&\\'){\\n            // if the operation is AND\\n            eval = valAnd(exp.substr(2,n-3));\\n        }\\n        else if(exp[0]==\\'|\\'){\\n            // if the operation is OR\\n            eval = valOr(exp.substr(2,n-3));\\n        }\\n        else{\\n            // if the operation is NOT\\n            eval = valNot(exp.substr(2, n-3));\\n        }\\n\\n        return eval;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123797,
                "title": "python-stack-easy-to-understand-using-stack-python-beats-88-89-runtime-in-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* After operator is always (expr1, expr2, ...).\\n* You can solve every operator(\\'f\\', \\'t\\', ....).\\n* Therefore you must solve expr => \\'t\\' or \\'f\\'.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Using stack:\\n    - for each character in str:\\n        - if it is not \\'(\\' push it in stack\\n        - else if it is \\')\\':  => you have subExpr = operator(\\'f\\', \\'t\\', .....)   and you can solve it. Remove subExpr out stack and push result in stack.\\n        - else if it not \\',\\' push it in stack\\n        - Continue do the loop\\n    The answer is the last element in stack\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack1 = []\\n        stack2 = []\\n        top = \\'\\'\\n        for i in expression:\\n            if i == \\',\\':\\n                continue\\n            \\n            elif i == \\')\\':\\n                top = stack1.pop()\\n\\n                while top != \\'(\\':\\n                    stack2.append(top)\\n                    top = stack1.pop()\\n\\n                top = stack1.pop()\\n\\n                if top == \\'|\\':\\n                    stack1.append(\\'t\\' if \\'t\\' in stack2 else \\'f\\')\\n                \\n                elif top == \\'&\\':\\n                    stack1.append(\\'f\\' if \\'f\\' in stack2 else \\'t\\')\\n                \\n                elif top == \\'!\\':\\n                    stack1.append(\\'f\\' if \\'t\\' in stack2 else \\'t\\')\\n                stack2.clear()\\n            else:\\n                stack1.append(i)\\n\\n        return \\'t\\' in stack1\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack1 = []\\n        stack2 = []\\n        top = \\'\\'\\n        for i in expression:\\n            if i == \\',\\':\\n                continue\\n            \\n            elif i == \\')\\':\\n                top = stack1.pop()\\n\\n                while top != \\'(\\':\\n                    stack2.append(top)\\n                    top = stack1.pop()\\n\\n                top = stack1.pop()\\n\\n                if top == \\'|\\':\\n                    stack1.append(\\'t\\' if \\'t\\' in stack2 else \\'f\\')\\n                \\n                elif top == \\'&\\':\\n                    stack1.append(\\'f\\' if \\'f\\' in stack2 else \\'t\\')\\n                \\n                elif top == \\'!\\':\\n                    stack1.append(\\'f\\' if \\'t\\' in stack2 else \\'t\\')\\n                stack2.clear()\\n            else:\\n                stack1.append(i)\\n\\n        return \\'t\\' in stack1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100813,
                "title": "two-stack-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n        \\n            stack<char> st; // STORE THE CHARACTER\\n            stack<char> op; // STORE LAST OPERATOR\\n            char last;\\n            for(char a : s){\\n                    \\n                    if(a == \\',\\') continue;\\n                    \\n                    if(a == \\'|\\' || a == \\'&\\' || a == \\'!\\') op.push(a); ;\\n                    \\n                    if(a != \\')\\')\\n                            st.push(a);\\n                    else{\\n                            int ans = st.top() == \\'f\\' ? 0 : 1;  st.pop();\\n                            last = op.top(); op.pop();        \\n                            while(!st.empty() && st.top() != \\'(\\'){\\n                                    \\n                                    int x = st.top() == \\'f\\' ? 0 : 1; st.pop();\\n                                    if(last == \\'|\\')\\n                                            ans = ans | x;\\n                                    else if(last == \\'&\\')\\n                                            ans = ans & x;\\n                            }\\n                            \\n                            if(last == \\'!\\')\\n                                    ans = !ans;\\n                            st.pop();\\n                            st.pop();\\n                            if(ans == 0) st.push(\\'f\\');\\n                            else st.push(\\'t\\');\\n                    }\\n            }\\n            \\n             return st.top() == \\'f\\'?false:true;\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n        \\n            stack<char> st; // STORE THE CHARACTER\\n            stack<char> op; // STORE LAST OPERATOR\\n            char last;\\n            for(char a : s){\\n                    \\n                    if(a == \\',\\') continue;\\n                    \\n                    if(a == \\'|\\' || a == \\'&\\' || a == \\'!\\') op.push(a); ;\\n                    \\n                    if(a != \\')\\')\\n                            st.push(a);\\n                    else{\\n                            int ans = st.top() == \\'f\\' ? 0 : 1;  st.pop();\\n                            last = op.top(); op.pop();        \\n                            while(!st.empty() && st.top() != \\'(\\'){\\n                                    \\n                                    int x = st.top() == \\'f\\' ? 0 : 1; st.pop();\\n                                    if(last == \\'|\\')\\n                                            ans = ans | x;\\n                                    else if(last == \\'&\\')\\n                                            ans = ans & x;\\n                            }\\n                            \\n                            if(last == \\'!\\')\\n                                    ans = !ans;\\n                            st.pop();\\n                            st.pop();\\n                            if(ans == 0) st.push(\\'f\\');\\n                            else st.push(\\'t\\');\\n                    }\\n            }\\n            \\n             return st.top() == \\'f\\'?false:true;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964217,
                "title": "c-easy-to-understand-easy-to-code-stack-recursion",
                "content": "# It take lots of time to write this solution, so please upvote if you like this solution.\\n# Intuition\\nUsing stack we can easily solve this problem.\\n\\n# Complexity\\n- Time complexity:\\n- O(N^2) in --> worst case.\\n\\n- Space complexity:\\nO(N)+O(N) which is equivalent to O(N).\\n\\n# Code\\n```\\nbool parseBoolExpr(string expression)\\n{\\n    vector<bool> res;\\n    stack<char> st;\\n    int n = expression.length();\\n\\n    for (int i = n - 1; i > 0; i--)\\n    {\\n        char chara = expression[i];\\n        if (chara == \\',\\')\\n        {\\n            continue;\\n        }\\n        else if (chara == \\')\\')\\n        {\\n            st.push(chara);\\n        }\\n        else if (chara == \\'t\\' || chara == \\'f\\')\\n        {\\n            st.push(chara);\\n        }\\n        else if (chara == \\'(\\')\\n        {\\n            char symbol = expression[i - 1];\\n            while (st.top() != \\')\\')\\n            {\\n                if (st.top() == \\'t\\')\\n                {\\n                    res.push_back(1);\\n                }\\n                else if (st.top() == \\'f\\')\\n                {\\n                    res.push_back(0);\\n                }\\n                st.pop();\\n            }\\n            st.pop();\\n            if (symbol == \\'&\\')\\n            {\\n                bool mutex = true;\\n                for (auto element : res)\\n                {\\n                    mutex &= element;\\n                }\\n                mutex ? st.push(\\'t\\') : st.push(\\'f\\');\\n            }\\n            else if (symbol == \\'|\\')\\n            {\\n                bool mutex = false;\\n                for (auto element : res)\\n                {\\n                    mutex |= element;\\n                }\\n                mutex ? st.push(\\'t\\') : st.push(\\'f\\');\\n            }\\n            else if (symbol == \\'!\\')\\n            {\\n                bool element = res[0];\\n                element ? st.push(\\'f\\') : st.push(\\'t\\');\\n            }\\n            res.erase(res.begin(), res.end());\\n        }\\n    }\\n    \\n    return st.top() == \\'t\\';\\n}\\n# Please upvote if you like this solution.\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack",
                    "Recursion",
                    "Monotonic Stack"
                ],
                "code": "```\\nbool parseBoolExpr(string expression)\\n{\\n    vector<bool> res;\\n    stack<char> st;\\n    int n = expression.length();\\n\\n    for (int i = n - 1; i > 0; i--)\\n    {\\n        char chara = expression[i];\\n        if (chara == \\',\\')\\n        {\\n            continue;\\n        }\\n        else if (chara == \\')\\')\\n        {\\n            st.push(chara);\\n        }\\n        else if (chara == \\'t\\' || chara == \\'f\\')\\n        {\\n            st.push(chara);\\n        }\\n        else if (chara == \\'(\\')\\n        {\\n            char symbol = expression[i - 1];\\n            while (st.top() != \\')\\')\\n            {\\n                if (st.top() == \\'t\\')\\n                {\\n                    res.push_back(1);\\n                }\\n                else if (st.top() == \\'f\\')\\n                {\\n                    res.push_back(0);\\n                }\\n                st.pop();\\n            }\\n            st.pop();\\n            if (symbol == \\'&\\')\\n            {\\n                bool mutex = true;\\n                for (auto element : res)\\n                {\\n                    mutex &= element;\\n                }\\n                mutex ? st.push(\\'t\\') : st.push(\\'f\\');\\n            }\\n            else if (symbol == \\'|\\')\\n            {\\n                bool mutex = false;\\n                for (auto element : res)\\n                {\\n                    mutex |= element;\\n                }\\n                mutex ? st.push(\\'t\\') : st.push(\\'f\\');\\n            }\\n            else if (symbol == \\'!\\')\\n            {\\n                bool element = res[0];\\n                element ? st.push(\\'f\\') : st.push(\\'t\\');\\n            }\\n            res.erase(res.begin(), res.end());\\n        }\\n    }\\n    \\n    return st.top() == \\'t\\';\\n}\\n# Please upvote if you like this solution.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2591216,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public boolean f(char[] a, char l, int[] ind){\\n        boolean hasTrue = false;\\n        boolean hasFalse = false;\\n        \\n        while(a[ind[0]]!=\\')\\'){\\n            if(a[ind[0]]==\\'t\\'){\\n                hasTrue = true;\\n            }else if(a[ind[0]]==\\'f\\'){\\n                hasFalse = true;\\n            }else if(a[ind[0]]==\\'|\\' || a[ind[0]]==\\'&\\' || a[ind[0]]==\\'!\\'){\\n                char ch = a[ind[0]];\\n                ind[0]+=2;\\n                if(f(a,ch,ind)) hasTrue = true;\\n                else hasFalse = true;\\n            }\\n            ind[0]++;\\n        }\\n        // System.out.println(l + \" \"+ hasTrue +\" \"+ hasFalse);\\n        if(l == \\'|\\'){\\n            if(hasTrue) return true;\\n            else return false;\\n        }else if(l == \\'&\\'){\\n            if(hasFalse) return false;\\n            else return true;\\n        }else {\\n            if(hasTrue) return false;\\n            else return true;\\n        }\\n    }\\n    \\n    public boolean parseBoolExpr(String exp) {\\n        int[] ind = new int[1];\\n        ind[0]=2;\\n        return f(exp.toCharArray(), exp.charAt(0), ind);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean f(char[] a, char l, int[] ind){\\n        boolean hasTrue = false;\\n        boolean hasFalse = false;\\n        \\n        while(a[ind[0]]!=\\')\\'){\\n            if(a[ind[0]]==\\'t\\'){\\n                hasTrue = true;\\n            }else if(a[ind[0]]==\\'f\\'){\\n                hasFalse = true;\\n            }else if(a[ind[0]]==\\'|\\' || a[ind[0]]==\\'&\\' || a[ind[0]]==\\'!\\'){\\n                char ch = a[ind[0]];\\n                ind[0]+=2;\\n                if(f(a,ch,ind)) hasTrue = true;\\n                else hasFalse = true;\\n            }\\n            ind[0]++;\\n        }\\n        // System.out.println(l + \" \"+ hasTrue +\" \"+ hasFalse);\\n        if(l == \\'|\\'){\\n            if(hasTrue) return true;\\n            else return false;\\n        }else if(l == \\'&\\'){\\n            if(hasFalse) return false;\\n            else return true;\\n        }else {\\n            if(hasTrue) return false;\\n            else return true;\\n        }\\n    }\\n    \\n    public boolean parseBoolExpr(String exp) {\\n        int[] ind = new int[1];\\n        ind[0]=2;\\n        return f(exp.toCharArray(), exp.charAt(0), ind);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583900,
                "title": "python-iterative-o-n-solution",
                "content": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        logics = []\\n        stack = []\\n        \\n        def cal(tmp, top, op):\\n            if op == \\'!\\':\\n                tmp = \\'t\\' if tmp == \\'f\\' else \\'f\\'\\n            elif op == \\'&\\':\\n                tmp = \\'t\\' if (tmp == \\'t\\' and top == \\'t\\') else \\'f\\'\\n            elif op == \\'|\\':\\n                tmp = \\'t\\' if (tmp == \\'t\\' or top == \\'t\\') else \\'f\\'\\n            return tmp\\n\\n        for i in expression:\\n            if i in (\\'!\\', \\'&\\', \\'|\\'):\\n                logics.append(i)\\n            elif i == \\')\\':\\n                op = logics.pop()\\n                tmp = stack.pop()\\n                while stack:\\n                    top = stack.pop()\\n                    # print(tmp, top, op)\\n                    if op == \\'!\\' and top == \\'(\\': tmp = cal(tmp, tmp, op)\\n                    if top == \\'(\\': break\\n                    tmp = cal(tmp, top, op)\\n                stack.append(tmp)\\n            elif i == \\',\\': continue\\n            else:\\n                stack.append(i)\\n            # print(stack, logics, i)\\n        \\n        if logics:\\n            op = logics.pop()\\n            tmp = stack.pop()\\n            while stack:\\n                top = stack.pop()\\n                tmp = cal(tmp, top, op)\\n            stack.append(tmp)\\n        \\n        return True if stack[0] == \\'t\\' else False\\n        \\n                    \\n# Time: O(N)\\n# Space: O(N)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        logics = []\\n        stack = []\\n        \\n        def cal(tmp, top, op):\\n            if op == \\'!\\':\\n                tmp = \\'t\\' if tmp == \\'f\\' else \\'f\\'\\n            elif op == \\'&\\':\\n                tmp = \\'t\\' if (tmp == \\'t\\' and top == \\'t\\') else \\'f\\'\\n            elif op == \\'|\\':\\n                tmp = \\'t\\' if (tmp == \\'t\\' or top == \\'t\\') else \\'f\\'\\n            return tmp\\n\\n        for i in expression:\\n            if i in (\\'!\\', \\'&\\', \\'|\\'):\\n                logics.append(i)\\n            elif i == \\')\\':\\n                op = logics.pop()\\n                tmp = stack.pop()\\n                while stack:\\n                    top = stack.pop()\\n                    # print(tmp, top, op)\\n                    if op == \\'!\\' and top == \\'(\\': tmp = cal(tmp, tmp, op)\\n                    if top == \\'(\\': break\\n                    tmp = cal(tmp, top, op)\\n                stack.append(tmp)\\n            elif i == \\',\\': continue\\n            else:\\n                stack.append(i)\\n            # print(stack, logics, i)\\n        \\n        if logics:\\n            op = logics.pop()\\n            tmp = stack.pop()\\n            while stack:\\n                top = stack.pop()\\n                tmp = cal(tmp, top, op)\\n            stack.append(tmp)\\n        \\n        return True if stack[0] == \\'t\\' else False\\n        \\n                    \\n# Time: O(N)\\n# Space: O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528309,
                "title": "java-1-ms-faster-than-100-00-of-java-recursion",
                "content": "**<------------//VoteUp if you like the solution**\\n![image](https://assets.leetcode.com/users/images/68d9f323-15c8-49bd-842c-db99253c5eaa_1662274342.8303623.png)\\n\\n\\n```\\nclass Solution {\\n    \\n    int pos = 0;\\n    \\n    public boolean parseBoolExpr(String s) {\\n        pos = 0;\\n        return solve(s, \\'-\\');\\n    }\\n    \\n    public boolean solve(String s, char prev_sign) {\\n       \\n        boolean res = s.charAt(pos) == \\'f\\' ? false : true;\\n        char cur_sign = \\' \\';\\n        int flag_res_init = 0;\\n        while(pos < s.length()) {\\n            \\n            char cur_char = s.charAt(pos++);\\n            \\n            if(isExpr(cur_char)){\\n                res = eval(cur_char == \\'t\\'?true:false, res , prev_sign);\\n            }\\n            else if(isSign(cur_char)){\\n                cur_sign = cur_char;\\n            }\\n            else if(cur_char == \\'(\\'){\\n                if(flag_res_init == 1 || prev_sign == \\'!\\')\\n                    res = eval(solve(s, cur_sign), res, prev_sign);\\n                else {\\n                    res = solve(s, cur_sign);\\n                    flag_res_init = 1;\\n                }\\n            }\\n            else if(cur_char == \\')\\'){\\n                 return res;\\n            }\\n            \\n        }\\n       return res;\\n    }\\n    \\n    public boolean isExpr(char c){\\n        return (c == \\'f\\' || c == \\'t\\');\\n    }\\n    \\n    public boolean isSign(char c){\\n        return (c == \\'!\\' || c == \\'&\\' || c == \\'|\\');\\n    }\\n    \\n    public boolean eval(boolean e1, boolean e2, char sign) {\\n     \\n        boolean res = false;\\n        if(sign == \\'!\\')\\n            res = !e1;\\n        \\n        else if(sign == \\'|\\')\\n            res = e1 | e2;\\n        \\n        else if(sign == \\'&\\')\\n            res = e1&e2;\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int pos = 0;\\n    \\n    public boolean parseBoolExpr(String s) {\\n        pos = 0;\\n        return solve(s, \\'-\\');\\n    }\\n    \\n    public boolean solve(String s, char prev_sign) {\\n       \\n        boolean res = s.charAt(pos) == \\'f\\' ? false : true;\\n        char cur_sign = \\' \\';\\n        int flag_res_init = 0;\\n        while(pos < s.length()) {\\n            \\n            char cur_char = s.charAt(pos++);\\n            \\n            if(isExpr(cur_char)){\\n                res = eval(cur_char == \\'t\\'?true:false, res , prev_sign);\\n            }\\n            else if(isSign(cur_char)){\\n                cur_sign = cur_char;\\n            }\\n            else if(cur_char == \\'(\\'){\\n                if(flag_res_init == 1 || prev_sign == \\'!\\')\\n                    res = eval(solve(s, cur_sign), res, prev_sign);\\n                else {\\n                    res = solve(s, cur_sign);\\n                    flag_res_init = 1;\\n                }\\n            }\\n            else if(cur_char == \\')\\'){\\n                 return res;\\n            }\\n            \\n        }\\n       return res;\\n    }\\n    \\n    public boolean isExpr(char c){\\n        return (c == \\'f\\' || c == \\'t\\');\\n    }\\n    \\n    public boolean isSign(char c){\\n        return (c == \\'!\\' || c == \\'&\\' || c == \\'|\\');\\n    }\\n    \\n    public boolean eval(boolean e1, boolean e2, char sign) {\\n     \\n        boolean res = false;\\n        if(sign == \\'!\\')\\n            res = !e1;\\n        \\n        else if(sign == \\'|\\')\\n            res = e1 | e2;\\n        \\n        else if(sign == \\'&\\')\\n            res = e1&e2;\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311895,
                "title": "c-easy-to-understand-simple-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string e) {\\n        int n=e.size();\\n        stack<char> s,sign;\\n        for(int i=0;i<n;i++)\\n        {\\n            char ch=e[i];\\n            if(ch==\\',\\')\\n            continue;\\n            \\n            if(ch!=\\')\\')\\n            {\\n                if(ch==\\'!\\'||ch==\\'&\\'||ch==\\'|\\')\\n                {\\n                    sign.push(ch);\\n                }\\n                else\\n                    s.push(ch);\\n            }\\n            else\\n            {\\n                char op=sign.top();\\n                sign.pop();\\n                int hasT=-1,hasF=-1;\\n                while(s.top()!=\\'(\\')\\n                {\\n                    if(s.top()==\\'t\\')\\n                    {\\n                        hasT=true;\\n                    }\\n                    else\\n                    {\\n                        hasF=true;\\n                    }\\n                    s.pop();\\n                }\\n                s.pop();\\n                if(op==\\'!\\')\\n                {\\n                    if(hasT==1)\\n                    {\\n                        s.push(\\'f\\');\\n                    }\\n                    else if(hasF==1)\\n                    {\\n                        s.push(\\'t\\');\\n                    }\\n                }\\n                else if(op==\\'&\\')\\n                {\\n                    if(hasF==1)\\n                    {\\n                        s.push(\\'f\\');\\n                    }\\n                    else\\n                    {\\n                        s.push(\\'t\\');\\n                    }\\n                }\\n                else\\n                {\\n                    if(hasT==1)\\n                    {\\n                        s.push(\\'t\\');\\n                    }\\n                    else\\n                    {\\n                        s.push(\\'f\\');\\n                    }\\n                }\\n            }\\n        }\\n        return s.top()==\\'t\\';\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string e) {\\n        int n=e.size();\\n        stack<char> s,sign;\\n        for(int i=0;i<n;i++)\\n        {\\n            char ch=e[i];\\n            if(ch==\\',\\')\\n            continue;\\n            \\n            if(ch!=\\')\\')\\n            {\\n                if(ch==\\'!\\'||ch==\\'&\\'||ch==\\'|\\')\\n                {\\n                    sign.push(ch);\\n                }\\n                else\\n                    s.push(ch);\\n            }\\n            else\\n            {\\n                char op=sign.top();\\n                sign.pop();\\n                int hasT=-1,hasF=-1;\\n                while(s.top()!=\\'(\\')\\n                {\\n                    if(s.top()==\\'t\\')\\n                    {\\n                        hasT=true;\\n                    }\\n                    else\\n                    {\\n                        hasF=true;\\n                    }\\n                    s.pop();\\n                }\\n                s.pop();\\n                if(op==\\'!\\')\\n                {\\n                    if(hasT==1)\\n                    {\\n                        s.push(\\'f\\');\\n                    }\\n                    else if(hasF==1)\\n                    {\\n                        s.push(\\'t\\');\\n                    }\\n                }\\n                else if(op==\\'&\\')\\n                {\\n                    if(hasF==1)\\n                    {\\n                        s.push(\\'f\\');\\n                    }\\n                    else\\n                    {\\n                        s.push(\\'t\\');\\n                    }\\n                }\\n                else\\n                {\\n                    if(hasT==1)\\n                    {\\n                        s.push(\\'t\\');\\n                    }\\n                    else\\n                    {\\n                        s.push(\\'f\\');\\n                    }\\n                }\\n            }\\n        }\\n        return s.top()==\\'t\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164769,
                "title": "c-stack-beats-95-simplest-best",
                "content": "**1. Implement a stack of char.\\n2. We store only, {\\'t\\',\\'f\\',\\'&\\',\\'|\\',\\'!\\'} in our stack.\\n3. Now, everytime we get \\')\\', we calculate our expression till that \\')\\'\\n4. Insert this temp_ans in stack and keep iterating\\n5. After all the iterations are complete, we are left with only one char at s.top()\\n6. If s.top()==\\'t\\', return true; else return false\\n7. I have also commented the code for any doubt !!!!\\n8. Hope you like the solution :-)**\\n\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> s;\\n        for(auto x:expression)\\n        {\\n            if(x==\\'(\\' || x==\\',\\') continue;  // we \\'continue\\' our program because we do not want \\'(\\'  && \\',\\' in our stack;\\n            if(x==\\')\\')\\n            {\\n                bool a=false; // a --> checks if we get \\'t\\' or not, if yes \\'a\\' --> true \\n                bool b=false; // b --> checks if we get \\'f\\' or not, if yes \\'b\\' --> true \\n                while(s.top()==\\'t\\' || s.top()==\\'f\\')\\n                {\\n                    if(s.top()==\\'t\\') a=true;  // a --> true ,if, we get \\'t\\' atleast once\\n                    if(s.top()==\\'f\\') b=true; // b --> true ,if, we get \\'f\\' atleast once\\n                    s.pop();\\n                }\\n                char op=s.top(); // op --> stores the operator \\n                s.pop();\\n                char temp_ans;\\n                if(op==\\'&\\')\\n                {\\n                    if(b==true) // for atleast one \\'f\\', the \\'&\\' makes the exp false \\n                    {\\n                        temp_ans=\\'f\\';\\n                    }\\n                    else\\n                    {\\n                        temp_ans=\\'t\\'; // only if \\'b\\' if false ,i.e., no \\'f\\' present\\n                    }\\n                }\\n                else if(op==\\'|\\')\\n                {\\n                    if(a==true) // for atleast one \\'t\\', the \\'|\\' makes the exp true \\n                    {\\n                        temp_ans=\\'t\\';\\n                    }\\n                    else\\n                    {\\n                        temp_ans=\\'f\\'; // only if \\'a\\' if false ,i.e., no \\'t\\' present\\n                    }\\n                }\\n                else\\n                {\\n                    if(a==true) // ! operator changes \\'t\\' --> \\'f\\'\\n                    {\\n                        temp_ans=\\'f\\';\\n                    }\\n                    else\\n                    {\\n                        temp_ans=\\'t\\'; // ! operator changes \\'f\\' --> \\'t\\'\\n                    }\\n                }\\n                s.push(temp_ans);\\n                continue; // we \\'continue\\' our program because we do not want \\')\\' in our stack;\\n            }\\n            s.push(x);\\n        }\\n        if(s.top()==\\'t\\') return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> s;\\n        for(auto x:expression)\\n        {\\n            if(x==\\'(\\' || x==\\',\\') continue;  // we \\'continue\\' our program because we do not want \\'(\\'  && \\',\\' in our stack;\\n            if(x==\\')\\')\\n            {\\n                bool a=false; // a --> checks if we get \\'t\\' or not, if yes \\'a\\' --> true \\n                bool b=false; // b --> checks if we get \\'f\\' or not, if yes \\'b\\' --> true \\n                while(s.top()==\\'t\\' || s.top()==\\'f\\')\\n                {\\n                    if(s.top()==\\'t\\') a=true;  // a --> true ,if, we get \\'t\\' atleast once\\n                    if(s.top()==\\'f\\') b=true; // b --> true ,if, we get \\'f\\' atleast once\\n                    s.pop();\\n                }\\n                char op=s.top(); // op --> stores the operator \\n                s.pop();\\n                char temp_ans;\\n                if(op==\\'&\\')\\n                {\\n                    if(b==true) // for atleast one \\'f\\', the \\'&\\' makes the exp false \\n                    {\\n                        temp_ans=\\'f\\';\\n                    }\\n                    else\\n                    {\\n                        temp_ans=\\'t\\'; // only if \\'b\\' if false ,i.e., no \\'f\\' present\\n                    }\\n                }\\n                else if(op==\\'|\\')\\n                {\\n                    if(a==true) // for atleast one \\'t\\', the \\'|\\' makes the exp true \\n                    {\\n                        temp_ans=\\'t\\';\\n                    }\\n                    else\\n                    {\\n                        temp_ans=\\'f\\'; // only if \\'a\\' if false ,i.e., no \\'t\\' present\\n                    }\\n                }\\n                else\\n                {\\n                    if(a==true) // ! operator changes \\'t\\' --> \\'f\\'\\n                    {\\n                        temp_ans=\\'f\\';\\n                    }\\n                    else\\n                    {\\n                        temp_ans=\\'t\\'; // ! operator changes \\'f\\' --> \\'t\\'\\n                    }\\n                }\\n                s.push(temp_ans);\\n                continue; // we \\'continue\\' our program because we do not want \\')\\' in our stack;\\n            }\\n            s.push(x);\\n        }\\n        if(s.top()==\\'t\\') return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122137,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> stck=new Stack<Character>();\\n        for(int i=expression.length()-1;i>=0;i--)\\n        {\\n            if(expression.charAt(i)==\\')\\')\\n            {\\n                stck.push(\\')\\');\\n            }\\n            else if(expression.charAt(i)==\\',\\')\\n            {\\n                continue;\\n            }\\n            else if(expression.charAt(i)==\\'t\\' || expression.charAt(i)==\\'f\\')\\n            {\\n                stck.push(expression.charAt(i));\\n            }\\n            else if(expression.charAt(i)==\\'(\\')\\n            {\\n                char a=expression.charAt(i-1);\\n                if(a==\\'|\\')\\n                {\\n                    char result=\\'f\\';\\n                    while(stck.peek()!=\\')\\')\\n                    {\\n                        if(stck.pop()==\\'t\\')\\n                        {\\n                            result=\\'t\\';\\n                        }\\n                    }\\n                    stck.pop();\\n                    stck.push(result);\\n                    i=i-1;\\n                }\\n                else if(a==\\'!\\')\\n                {\\n                    if(stck.pop()==\\'t\\')\\n                    {\\n                        stck.pop();\\n                        stck.push(\\'f\\');\\n                    }\\n                    else\\n                    {\\n                        stck.pop();\\n                        stck.push(\\'t\\');\\n                    }\\n                    i=i-1;\\n                }\\n                else\\n                {\\n                    char result=\\'t\\';\\n                    while(stck.peek()!=\\')\\')\\n                    {\\n                        if(stck.pop()==\\'f\\')\\n                        {\\n                            result=\\'f\\';\\n                        }\\n                    }\\n                    stck.pop();\\n                    stck.push(result);\\n                    i=i-1;\\n                }\\n                \\n            }\\n        }\\n        \\n        if(stck.pop()==\\'t\\')\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> stck=new Stack<Character>();\\n        for(int i=expression.length()-1;i>=0;i--)\\n        {\\n            if(expression.charAt(i)==\\')\\')\\n            {\\n                stck.push(\\')\\');\\n            }\\n            else if(expression.charAt(i)==\\',\\')\\n            {\\n                continue;\\n            }\\n            else if(expression.charAt(i)==\\'t\\' || expression.charAt(i)==\\'f\\')\\n            {\\n                stck.push(expression.charAt(i));\\n            }\\n            else if(expression.charAt(i)==\\'(\\')\\n            {\\n                char a=expression.charAt(i-1);\\n                if(a==\\'|\\')\\n                {\\n                    char result=\\'f\\';\\n                    while(stck.peek()!=\\')\\')\\n                    {\\n                        if(stck.pop()==\\'t\\')\\n                        {\\n                            result=\\'t\\';\\n                        }\\n                    }\\n                    stck.pop();\\n                    stck.push(result);\\n                    i=i-1;\\n                }\\n                else if(a==\\'!\\')\\n                {\\n                    if(stck.pop()==\\'t\\')\\n                    {\\n                        stck.pop();\\n                        stck.push(\\'f\\');\\n                    }\\n                    else\\n                    {\\n                        stck.pop();\\n                        stck.push(\\'t\\');\\n                    }\\n                    i=i-1;\\n                }\\n                else\\n                {\\n                    char result=\\'t\\';\\n                    while(stck.peek()!=\\')\\')\\n                    {\\n                        if(stck.pop()==\\'f\\')\\n                        {\\n                            result=\\'f\\';\\n                        }\\n                    }\\n                    stck.pop();\\n                    stck.push(result);\\n                    i=i-1;\\n                }\\n                \\n            }\\n        }\\n        \\n        if(stck.pop()==\\'t\\')\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992936,
                "title": "c-o-n-time-stack-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string e) {\\n        stack<char> s;\\n        for(auto i:e)\\n        {\\n            if(i==\\')\\')\\n            {\\n                bool hast=false,hasf=false;\\n                while(s.top()==\\'t\\' || s.top()==\\'f\\' || s.top()==\\',\\')\\n                {\\n                    if(s.top()==\\'t\\')\\n                        hast=true;\\n                    if(s.top()==\\'f\\')\\n                        hasf=true;\\n                    s.pop();\\n                }\\n                s.pop();\\n                \\n                char op=s.top();\\n                s.pop();\\n                if(op==\\'|\\')\\n                {\\n                    s.push(hast==true?\\'t\\':\\'f\\');\\n                }\\n                else if(op==\\'&\\')\\n                {\\n                    s.push(hasf==false?\\'t\\':\\'f\\');\\n                }\\n                else if(op==\\'!\\')\\n                {\\n                    s.push(hast==true?\\'f\\':\\'t\\');\\n                }\\n            }\\n            else\\n                s.push(i);\\n        }\\n        return s.top()==\\'t\\'?true:false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string e) {\\n        stack<char> s;\\n        for(auto i:e)\\n        {\\n            if(i==\\')\\')\\n            {\\n                bool hast=false,hasf=false;\\n                while(s.top()==\\'t\\' || s.top()==\\'f\\' || s.top()==\\',\\')\\n                {\\n                    if(s.top()==\\'t\\')\\n                        hast=true;\\n                    if(s.top()==\\'f\\')\\n                        hasf=true;\\n                    s.pop();\\n                }\\n                s.pop();\\n                \\n                char op=s.top();\\n                s.pop();\\n                if(op==\\'|\\')\\n                {\\n                    s.push(hast==true?\\'t\\':\\'f\\');\\n                }\\n                else if(op==\\'&\\')\\n                {\\n                    s.push(hasf==false?\\'t\\':\\'f\\');\\n                }\\n                else if(op==\\'!\\')\\n                {\\n                    s.push(hast==true?\\'f\\':\\'t\\');\\n                }\\n            }\\n            else\\n                s.push(i);\\n        }\\n        return s.top()==\\'t\\'?true:false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977669,
                "title": "straightforward-java-implementation",
                "content": "We can let recursion handle all the work.  The only tricky part is handling the manual parsing of the results for AND and OR.  Need to use a StringBuilder and make sure that the parentheses are matched and that we don\\'t call parseBoolExpr with an inavlid string.\\n\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n                \\n        char c = expression.charAt(0);\\n        \\n        if(c == \\'t\\'){\\n            return true;\\n        } else if(c == \\'f\\') {\\n            return false;\\n        } else if(c == \\'!\\'){\\n            return !parseBoolExpr(expression.substring(2, expression.length()-1));\\n        } else {\\n            List<Boolean> results = new ArrayList<>();\\n            StringBuilder sb = new StringBuilder();\\n            int numParens = 0;\\n            \\n            for(int i = 2; i < expression.length()-1; i++){\\n                char innerChar = expression.charAt(i);\\n                \\n                if(innerChar == \\'(\\'){\\n                    numParens++;\\n                } else if(innerChar == \\')\\'){\\n                    numParens--;\\n                } else if(innerChar == \\',\\' && sb.length() == 0){\\n                    continue;\\n                }\\n                sb.append(innerChar);\\n                \\n                if(numParens == 0){    \\n                    if(sb.length() == 1){\\n                        if(sb.toString().equals(\"t\") || sb.toString().equals(\"f\")){\\n                            results.add(parseBoolExpr(sb.toString()));\\n                            sb = new StringBuilder();\\n                        }\\n                    } else {\\n                        results.add(parseBoolExpr(sb.toString()));\\n                        sb = new StringBuilder();  \\n                    }\\n                }\\n            }\\n            \\n            if(c == \\'|\\'){\\n                for(boolean result : results){\\n                    if(result){\\n                        return true;\\n                    }\\n                }\\n                return false;\\n            } else {\\n                //c == &\\n                for(boolean result : results){\\n                    if(!result){\\n                        return false;\\n                    }\\n                }\\n                return true; \\n            }   \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n                \\n        char c = expression.charAt(0);\\n        \\n        if(c == \\'t\\'){\\n            return true;\\n        } else if(c == \\'f\\') {\\n            return false;\\n        } else if(c == \\'!\\'){\\n            return !parseBoolExpr(expression.substring(2, expression.length()-1));\\n        } else {\\n            List<Boolean> results = new ArrayList<>();\\n            StringBuilder sb = new StringBuilder();\\n            int numParens = 0;\\n            \\n            for(int i = 2; i < expression.length()-1; i++){\\n                char innerChar = expression.charAt(i);\\n                \\n                if(innerChar == \\'(\\'){\\n                    numParens++;\\n                } else if(innerChar == \\')\\'){\\n                    numParens--;\\n                } else if(innerChar == \\',\\' && sb.length() == 0){\\n                    continue;\\n                }\\n                sb.append(innerChar);\\n                \\n                if(numParens == 0){    \\n                    if(sb.length() == 1){\\n                        if(sb.toString().equals(\"t\") || sb.toString().equals(\"f\")){\\n                            results.add(parseBoolExpr(sb.toString()));\\n                            sb = new StringBuilder();\\n                        }\\n                    } else {\\n                        results.add(parseBoolExpr(sb.toString()));\\n                        sb = new StringBuilder();  \\n                    }\\n                }\\n            }\\n            \\n            if(c == \\'|\\'){\\n                for(boolean result : results){\\n                    if(result){\\n                        return true;\\n                    }\\n                }\\n                return false;\\n            } else {\\n                //c == &\\n                for(boolean result : results){\\n                    if(!result){\\n                        return false;\\n                    }\\n                }\\n                return true; \\n            }   \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1873672,
                "title": "javascript-solution",
                "content": "Here\\'s my answer to this problem:\\n\\n```javascript\\nconst splitExpression = (expression) => {\\n  const exprs = [];\\n  let lastBreakPoint = -1;\\n  let openedPara = 0;\\n  for (let i = 0; i < expression.length; i++) {\\n    const char = expression[i];\\n    if (char === \\'(\\') openedPara++;\\n    if (char === \\')\\') openedPara--;\\n    if (openedPara === 0 && char === \\',\\') {\\n      exprs.push(expression.slice(lastBreakPoint + 1, i));\\n      lastBreakPoint = i;\\n    }\\n  }\\n  // Add remaining text as last exp\\n  exprs.push(expression.slice(lastBreakPoint + 1));\\n  return exprs;\\n};\\n\\n/**\\n * @param {string} expression\\n * @return {boolean}\\n */\\nvar parseBoolExpr = function (expression) {\\n  if (expression === \\'t\\') return true;\\n  if (expression === \\'f\\') return false;\\n  // remove first char and surrounding parentheses\\n  const innerExpression = expression.slice(2, -1);\\n\\n  if (expression[0] === \\'!\\') return !parseBoolExpr(innerExpression);\\n  const splitExpr = splitExpression(innerExpression);\\n  if (expression[0] === \\'&\\') return splitExpr.every(parseBoolExpr);\\n  if (expression[0] === \\'|\\') return splitExpr.some(parseBoolExpr);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\nconst splitExpression = (expression) => {\\n  const exprs = [];\\n  let lastBreakPoint = -1;\\n  let openedPara = 0;\\n  for (let i = 0; i < expression.length; i++) {\\n    const char = expression[i];\\n    if (char === \\'(\\') openedPara++;\\n    if (char === \\')\\') openedPara--;\\n    if (openedPara === 0 && char === \\',\\') {\\n      exprs.push(expression.slice(lastBreakPoint + 1, i));\\n      lastBreakPoint = i;\\n    }\\n  }\\n  // Add remaining text as last exp\\n  exprs.push(expression.slice(lastBreakPoint + 1));\\n  return exprs;\\n};\\n\\n/**\\n * @param {string} expression\\n * @return {boolean}\\n */\\nvar parseBoolExpr = function (expression) {\\n  if (expression === \\'t\\') return true;\\n  if (expression === \\'f\\') return false;\\n  // remove first char and surrounding parentheses\\n  const innerExpression = expression.slice(2, -1);\\n\\n  if (expression[0] === \\'!\\') return !parseBoolExpr(innerExpression);\\n  const splitExpr = splitExpression(innerExpression);\\n  if (expression[0] === \\'&\\') return splitExpr.every(parseBoolExpr);\\n  if (expression[0] === \\'|\\') return splitExpr.some(parseBoolExpr);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1762748,
                "title": "simple-c-solution-this-is-not-hard-problem-medium-level-runtime-19ms",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    // Hint : Write a function \"parse\" which calls helper functions \"parse_or\", \"parse_and\", \"parse_not\".\\n    \\n    char parse_or(vector<char>&operands){\\n        for(auto ch : operands){\\n            if(ch == \\'t\\')\\n                return \\'t\\';\\n        }\\n        return \\'f\\';\\n    }\\n    \\n    char parse_not(vector<char>&operands){\\n        if (operands[0] == \\'t\\') {\\n            return \\'f\\';\\n        }\\n        return \\'t\\';\\n    }\\n    \\n    char parse_and(vector<char>&operands){\\n        for(auto ch : operands){\\n            if(ch == \\'f\\')\\n                return \\'f\\';\\n        }\\n        return \\'t\\';\\n    }\\n    \\n    bool isOperator(char ch){\\n        return ch == \\'!\\' or ch == \\'&\\' or ch == \\'|\\';\\n    }\\n    \\n    bool parseBoolExpr(string exp) \\n    {    \\n        int n=exp.size();\\n        stack<char>st;\\n        for(int i=n-1;i>=0;i--) // push string in reverse order due to prefix notation\\n        {\\n            char ch = exp[i];\\n            if(ch == \\',\\')\\n                continue;\\n            else if(!isOperator(ch)) // t, f, (, )\\n            {  \\n                st.push(ch);\\n            }\\n            else\\n            {\\n                char operation = ch;\\n                st.pop(); // for (\\n                vector<char>operands;\\n                while(st.top() != \\')\\')\\n                {\\n                    operands.push_back(st.top());\\n                    st.pop();\\n                }\\n                st.pop(); // for )\\n                char result;\\n                if(operation == \\'|\\'){\\n                    result = parse_or(operands);         \\n                }\\n                else if(operation == \\'&\\'){\\n                    result = parse_and(operands);\\n                }\\n                else{\\n                    result = parse_not(operands);\\n                }\\n                st.push(result);\\n            }\\n        }\\n        return st.top() == \\'t\\' ? true : false;\\n    }\\n};\\n```\\n**if you like my approach please don\\'t forget to hit upvote button ! : )**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    // Hint : Write a function \"parse\" which calls helper functions \"parse_or\", \"parse_and\", \"parse_not\".\\n    \\n    char parse_or(vector<char>&operands){\\n        for(auto ch : operands){\\n            if(ch == \\'t\\')\\n                return \\'t\\';\\n        }\\n        return \\'f\\';\\n    }\\n    \\n    char parse_not(vector<char>&operands){\\n        if (operands[0] == \\'t\\') {\\n            return \\'f\\';\\n        }\\n        return \\'t\\';\\n    }\\n    \\n    char parse_and(vector<char>&operands){\\n        for(auto ch : operands){\\n            if(ch == \\'f\\')\\n                return \\'f\\';\\n        }\\n        return \\'t\\';\\n    }\\n    \\n    bool isOperator(char ch){\\n        return ch == \\'!\\' or ch == \\'&\\' or ch == \\'|\\';\\n    }\\n    \\n    bool parseBoolExpr(string exp) \\n    {    \\n        int n=exp.size();\\n        stack<char>st;\\n        for(int i=n-1;i>=0;i--) // push string in reverse order due to prefix notation\\n        {\\n            char ch = exp[i];\\n            if(ch == \\',\\')\\n                continue;\\n            else if(!isOperator(ch)) // t, f, (, )\\n            {  \\n                st.push(ch);\\n            }\\n            else\\n            {\\n                char operation = ch;\\n                st.pop(); // for (\\n                vector<char>operands;\\n                while(st.top() != \\')\\')\\n                {\\n                    operands.push_back(st.top());\\n                    st.pop();\\n                }\\n                st.pop(); // for )\\n                char result;\\n                if(operation == \\'|\\'){\\n                    result = parse_or(operands);         \\n                }\\n                else if(operation == \\'&\\'){\\n                    result = parse_and(operands);\\n                }\\n                else{\\n                    result = parse_not(operands);\\n                }\\n                st.push(result);\\n            }\\n        }\\n        return st.top() == \\'t\\' ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718499,
                "title": "c-stack-simple-clean-explained",
                "content": "## Approach\\nIt is really simple to solve the problem once you figure out how to handle the string. We can always use multiple pointers like other posts, but I\\'d argue that it makes the code unclean and painful to read. So we\\'ll use stacks.\\n\\nOn first glance, we might assume that we can push the characters of the input expression as it is into the stack. But this doesn\\'t work when are faced with expressions nested inside each other. To handle that, we can push the characters in the string in reverse order. Then we will deal with each nested expression from starting from the innermost ones. For example, if we consider the expression `&(t,|(t,f,t))`.\\n\\n<img src=\"https://assets.leetcode.com/users/images/e4009d5b-35a2-4ff8-b28f-3a8a8df9c963_1643110039.4563963.png\" width=\"700\"/>\\n\\n### Steps:\\n- Push the characters in the string in reverse order onto the stack (starting from the last character). Avoid pushing commas.\\n- If you encounter an operator,\\n\\t- Store the operator in some variable, I\\'ve called it ```operation```\\n\\t- Pop the operator (if you\\'d pushed it)\\n\\t- Pop the opening round bracket ```(```\\n\\t- Until you encounter the closing bracket ```)```,\\n\\t\\t- Pop the operands (```t``` or ```f```)\\n\\t\\t- Save it in a vector, let\\'s call it ```operands```\\n\\t- Pop the closing round bracket ```)```\\n\\t- Pass the vector ```operands``` to a compute the result based on the operation to be performed\\n\\t\\t- In my implementation, I have passed the operator and operands to a function named ```parser()```  which is calls the required operation accordingly.\\n\\t\\t- The ```parse_not()```, ```parse_and()``` and ```parse_or()``` functions handle the operations NOT, AND and OR (`!`, `&` and `|`) respectively.\\n\\t- Push the returned result from the operation onto the stack again.\\n\\t- Continue until all characters in the string have been pushed\\n\\t- The topmost element, will then provide the result of the entire boolean expression. \\n\\t\\t- Hence return `true` if calling top() on the stack returns `t` or else return `f`.\\n\\nLogic of boolean operations themselves:\\n- AND -> Result is `false`  even if one of the operands are false, regardless of the number of operands\\n- OR -> Result is `true` even if one of the operands are true, regardless of the number of operands\\n- NOT -> Result is the complement of the boolean value (`!(true) = false`, `!(false) = true`)\\n\\n### C++ Solution\\n```\\nclass Solution {\\npublic:\\n    bool isOperator(char c) {\\n        return c == \\'|\\' || c == \\'&\\' || c == \\'!\\';\\n    }\\n    \\n    char parse_not(vector<char> operands) {\\n        if (operands[0] == \\'t\\') {\\n            return \\'f\\';\\n        }\\n        return \\'t\\';\\n    }\\n    \\n    char parse_or(vector<char> operands) {\\n        for (char o : operands) {\\n            if (o == \\'t\\') {\\n                return \\'t\\';\\n            }\\n        }\\n        return \\'f\\';\\n    }\\n    \\n    char parse_and(vector<char> operands) {\\n        for (char o : operands) {\\n            if (o == \\'f\\') {\\n                return \\'f\\';\\n            }\\n        }\\n        return \\'t\\';\\n    }\\n    \\n    char parser(char op, vector<char> operands) {\\n        if (op == \\'!\\') {\\n            return parse_not(operands);\\n        } else if (op == \\'|\\') {\\n            return parse_or(operands);\\n        } else if (op == \\'&\\') {\\n            return parse_and(operands);\\n        }\\n        return op;\\n    }\\n    \\n    bool parseBoolExpr(string expression) {\\n        stack<char> s;\\n        char operation;\\n        for (int i = expression.size() - 1; i >= 0; i--) {\\n            if (expression[i] != \\',\\') {\\n                s.push(expression[i]); // push character onto stack\\n    \\n                if (isOperator(s.top())) {\\n                    operation = s.top();\\n                    s.pop(); // pop the operator\\n                    s.pop(); // pop the (\\n                    \\n                    vector<char> operands;\\n                    while (s.top() != \\')\\') {\\n                        operands.push_back(s.top()); // push an operand\\n                        s.pop(); // remove the operand\\n                    }\\n                    s.pop(); // pop the )\\n                    s.push(parser(operation, operands));\\n                }\\n            }\\n        }\\n        \\n        if (s.top() == \\'t\\') {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```operation```\n```(```\n```)```\n```t```\n```f```\n```operands```\n```)```\n```operands```\n```parser()```\n```parse_not()```\n```parse_and()```\n```parse_or()```\n```\\nclass Solution {\\npublic:\\n    bool isOperator(char c) {\\n        return c == \\'|\\' || c == \\'&\\' || c == \\'!\\';\\n    }\\n    \\n    char parse_not(vector<char> operands) {\\n        if (operands[0] == \\'t\\') {\\n            return \\'f\\';\\n        }\\n        return \\'t\\';\\n    }\\n    \\n    char parse_or(vector<char> operands) {\\n        for (char o : operands) {\\n            if (o == \\'t\\') {\\n                return \\'t\\';\\n            }\\n        }\\n        return \\'f\\';\\n    }\\n    \\n    char parse_and(vector<char> operands) {\\n        for (char o : operands) {\\n            if (o == \\'f\\') {\\n                return \\'f\\';\\n            }\\n        }\\n        return \\'t\\';\\n    }\\n    \\n    char parser(char op, vector<char> operands) {\\n        if (op == \\'!\\') {\\n            return parse_not(operands);\\n        } else if (op == \\'|\\') {\\n            return parse_or(operands);\\n        } else if (op == \\'&\\') {\\n            return parse_and(operands);\\n        }\\n        return op;\\n    }\\n    \\n    bool parseBoolExpr(string expression) {\\n        stack<char> s;\\n        char operation;\\n        for (int i = expression.size() - 1; i >= 0; i--) {\\n            if (expression[i] != \\',\\') {\\n                s.push(expression[i]); // push character onto stack\\n    \\n                if (isOperator(s.top())) {\\n                    operation = s.top();\\n                    s.pop(); // pop the operator\\n                    s.pop(); // pop the (\\n                    \\n                    vector<char> operands;\\n                    while (s.top() != \\')\\') {\\n                        operands.push_back(s.top()); // push an operand\\n                        s.pop(); // remove the operand\\n                    }\\n                    s.pop(); // pop the )\\n                    s.push(parser(operation, operands));\\n                }\\n            }\\n        }\\n        \\n        if (s.top() == \\'t\\') {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636355,
                "title": "python-sol-stack",
                "content": "```python\\nclass Solution:\\n    def parseBoolExpr(self, e: str) -> bool:\\n        stack = []\\n        op = []\\n        for i in range(len(e)):\\n            if e[i] == \\')\\':\\n                sube = []\\n                while stack[-1] != \\'(\\':\\n                    last = stack.pop()\\n                    if last != \\',\\':\\n                        sube.append(last)\\n                stack.pop()\\n                add = []\\n                assert len(sube) > 0\\n                if stack[-1] == \\'!\\':\\n                    assert len(sube) == 1\\n                    if sube[0] == \\'f\\':\\n                        add.append(\\'t\\')\\n                    else:\\n                        add.append(\\'f\\')\\n                elif stack[-1] == \\'|\\':\\n                    if \\'t\\' in sube:\\n                        add.append(\\'t\\')\\n                    else:\\n                        add.append(\\'f\\')\\n                elif stack[-1] == \\'&\\':\\n                    if \\'f\\' in sube:\\n                        add.append(\\'f\\')\\n                    else:\\n                        add.append(\\'t\\')\\n                stack.pop()\\n                stack.append(add[0])\\n            else:\\n                if e[i] in (\\'!\\', \\'&\\', \\'|\\'):\\n                    op.append(e[i])\\n                stack.append(e[i])\\n        assert len(stack) == 1\\n        if stack[0] == \\'t\\':\\n            return 1\\n        else:\\n            return 0\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def parseBoolExpr(self, e: str) -> bool:\\n        stack = []\\n        op = []\\n        for i in range(len(e)):\\n            if e[i] == \\')\\':\\n                sube = []\\n                while stack[-1] != \\'(\\':\\n                    last = stack.pop()\\n                    if last != \\',\\':\\n                        sube.append(last)\\n                stack.pop()\\n                add = []\\n                assert len(sube) > 0\\n                if stack[-1] == \\'!\\':\\n                    assert len(sube) == 1\\n                    if sube[0] == \\'f\\':\\n                        add.append(\\'t\\')\\n                    else:\\n                        add.append(\\'f\\')\\n                elif stack[-1] == \\'|\\':\\n                    if \\'t\\' in sube:\\n                        add.append(\\'t\\')\\n                    else:\\n                        add.append(\\'f\\')\\n                elif stack[-1] == \\'&\\':\\n                    if \\'f\\' in sube:\\n                        add.append(\\'f\\')\\n                    else:\\n                        add.append(\\'t\\')\\n                stack.pop()\\n                stack.append(add[0])\\n            else:\\n                if e[i] in (\\'!\\', \\'&\\', \\'|\\'):\\n                    op.append(e[i])\\n                stack.append(e[i])\\n        assert len(stack) == 1\\n        if stack[0] == \\'t\\':\\n            return 1\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480431,
                "title": "o-n-stack-solution-java",
                "content": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        int n = expression.length();\\n        Stack<Character> stack = new Stack<>();\\n        for (int i = 0; i < n; i++) {\\n            char c = expression.charAt(i);\\n            if (c == \\')\\') {\\n                StringBuilder sb = new StringBuilder();\\n                while(stack.peek() != \\'(\\') {\\n                    char cc = stack.pop();\\n                    if (cc == \\',\\')\\n                        continue;\\n                    sb.append(cc);\\n                }\\n                stack.pop(); // pop opening parenthesis\\n                char operator = stack.pop();\\n                char result = evaluate(operator, sb.toString());\\n                stack.push(result);\\n            } else {\\n                stack.push(c);\\n            }\\n        }\\n        char result = stack.pop();\\n        return result == \\'t\\';\\n    }\\n    \\n    private char evaluate(char operator, String seq) {\\n        char result = \\'f\\';\\n        switch(operator) {\\n            case \\'&\\': {\\n                result = performAnd(seq);\\n                break;\\n            }\\n            case \\'|\\': {\\n                result = performOr(seq);\\n                break;\\n            }\\n            case \\'!\\': {\\n                result = performNot(seq);\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private char performAnd(String seq) {\\n        for (char c : seq.toCharArray()) {\\n            if (c == \\'f\\')\\n                return \\'f\\';\\n        }\\n        return \\'t\\';\\n    }\\n    \\n    private char performOr(String seq) {\\n        for (char c : seq.toCharArray()) {\\n            if (c == \\'t\\')\\n                return \\'t\\';\\n        }\\n        return \\'f\\';\\n    }\\n    \\n    private char performNot(String seq) {\\n        return seq.charAt(0) == \\'f\\' ? \\'t\\' : \\'f\\';\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        int n = expression.length();\\n        Stack<Character> stack = new Stack<>();\\n        for (int i = 0; i < n; i++) {\\n            char c = expression.charAt(i);\\n            if (c == \\')\\') {\\n                StringBuilder sb = new StringBuilder();\\n                while(stack.peek() != \\'(\\') {\\n                    char cc = stack.pop();\\n                    if (cc == \\',\\')\\n                        continue;\\n                    sb.append(cc);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1473527,
                "title": "python-stack-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = [] # stack[-1] stores the expression evaluation, stack[-2] stores the operator\\n        \\n        def compute(op, ex1, ex2):\\n            if op == \\'!\\':\\n                return not ex1\\n            elif op == \\'&\\':\\n                return ex1 and ex2\\n            elif op == \\'|\\':\\n                return ex1 or ex2\\n        \\n        for c in expression:\\n            if c in \"!|&\":\\n                stack.append(c)\\n                stack.append(False if c == \\'|\\' else True) # caveat: | needs to start with \"False\" as expression evaluation or else it will always evaluate to True\\n            elif c in \\'(,\\':\\n                continue\\n            elif c in \"tf\":\\n                stack[-1] = compute(stack[-2], True if c == \\'t\\' else False, stack[-1])\\n            elif c == \\')\\':\\n                cur_ex = stack[-1]\\n                stack.pop()\\n                stack.pop()\\n                if not stack: return cur_ex\\n                stack[-1] = compute(stack[-2], cur_ex, stack[-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = [] # stack[-1] stores the expression evaluation, stack[-2] stores the operator\\n        \\n        def compute(op, ex1, ex2):\\n            if op == \\'!\\':\\n                return not ex1\\n            elif op == \\'&\\':\\n                return ex1 and ex2\\n            elif op == \\'|\\':\\n                return ex1 or ex2\\n        \\n        for c in expression:\\n            if c in \"!|&\":\\n                stack.append(c)\\n                stack.append(False if c == \\'|\\' else True) # caveat: | needs to start with \"False\" as expression evaluation or else it will always evaluate to True\\n            elif c in \\'(,\\':\\n                continue\\n            elif c in \"tf\":\\n                stack[-1] = compute(stack[-2], True if c == \\'t\\' else False, stack[-1])\\n            elif c == \\')\\':\\n                cur_ex = stack[-1]\\n                stack.pop()\\n                stack.pop()\\n                if not stack: return cur_ex\\n                stack[-1] = compute(stack[-2], cur_ex, stack[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456238,
                "title": "c-4ms-94-faster-sol-recursive-easy-to-understand-but-a-little-lengthy",
                "content": "basic logic behind the code is if while iterating through the code if s[i] becomes equal to !,|,& we create a static stack to avoid re declaration in case recursive call is not made or loop does not end then we push the element at i+1 index into the stack as i is one of the boolean operator the next element is bound to be\\'(\\' then we simply run a while loop till the stack is empty this will make us reach the pos\\'n after the closing bracket(\\')\\')in the string the we create a substring from pos\\'n j+2 j being the initial value of i i.e (operator pos\\'n) for the length i-j-3 and pass the string by reference to appropriate function and do this recursively until whole string is evaluated.\\n```\\nstring And(string &s);\\nstring OR(string &s);\\nstring Not(string &s);\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'!\\'||s[i]==\\'&\\'||s[i]==\\'|\\'){\\n                int j=i;\\n                static stack<char>stk;\\n                stk.push(s[j+1]);\\n                i=j+2;\\n                while(!stk.empty()){\\n                    if(s[i]==\\'(\\'){\\n                        stk.push(s[i]);\\n                        i++;\\n                        continue;\\n                    }\\n                    if(s[i]==\\')\\') {\\n                        stk.pop();\\n                        i++;\\n                        continue;\\n                    }\\n                    i++;\\n                }\\n                if(s[j]==\\'&\\') {\\n                    string str = (s.substr(j + 2, i - j - 3));\\n                    str= And(str);\\n                    if(j!=0){\\n                        s.replace(j,i-j,str);\\n                    }else {\\n                        s.replace(j, i, str);\\n                    }\\n                }\\n                if(s[j]==\\'!\\') {\\n                    string str = (s.substr(j + 2, i - j - 3));\\n                    str=Not(str);\\n                    if(j!=0){\\n                        s.replace(j,i-j,str);\\n                    }else {\\n                        s.replace(j, i, str);\\n                    }\\n                }\\n                if(s[j]==\\'|\\') {\\n                    string str = (s.substr(j + 2, i - j - 3));\\n                    str=OR(str);\\n                    if(j!=0){\\n                        s.replace(j,i-j,str);\\n                    }else {\\n                        s.replace(j, i, str);\\n                    }\\n                }i=-1;continue;//to make the loop again run from start \\n            }\\n        }\\n\\n            if(s[0]==\\'t\\')\\n                return true;\\n            if(s[0]==\\'f\\')\\n                return false;\\n\\n        return \"\";\\n    }\\n};\\n\\nstring OR(string &s) {\\n    for(int i=0;i<s.size();i++){\\n        if(s[i]==\\'!\\'||s[i]==\\'&\\'||s[i]==\\'|\\'){\\n            int j=i;\\n            static stack<char>stk;\\n            stk.push(s[j+1]);\\n            i=j+2;\\n            while(!stk.empty()){\\n                if(s[i]==\\'(\\'){\\n                    stk.push(s[i]);\\n                    i++;\\n                    continue;\\n                }\\n                if(s[i]==\\')\\') {\\n                    stk.pop();\\n                    i++;\\n                    continue;\\n                }\\n                i++;\\n            }\\n            if(s[j]==\\'&\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str= And(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'!\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=Not(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'|\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=OR(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }i=-1;continue;//to make the loop again run from start \\n        }\\n        if(s[i]==\\'t\\')\\n            return \"t\";\\n    }\\n    return \"f\";\\n}\\nstring Not(string &s) {\\n    for(int i=0;i<s.size();i++){\\n        if(s[i]==\\'!\\'||s[i]==\\'&\\'||s[i]==\\'|\\'){\\n            int j=i;\\n            static stack<char>stk;\\n            stk.push(s[j+1]);\\n            i=j+2;\\n            while(!stk.empty()){\\n                if(s[i]==\\'(\\'){\\n                    stk.push(s[i]);\\n                    i++;\\n                    continue;\\n                }\\n                if(s[i]==\\')\\') {\\n                    stk.pop();\\n                    i++;\\n                    continue;\\n                }\\n                i++;\\n            }\\n            if(s[j]==\\'&\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str= And(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'!\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=Not(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'|\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=OR(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }i=-1;continue;//to make the loop again run from start \\n        }\\n        if(s[i]==\\'t\\')\\n            return \"f\";\\n        if(s[i]==\\'f\\')\\n            return \"t\";\\n    }\\n    return \"\";\\n}\\nstring And(string &s) {\\n    for(int i=0;i<s.size();i++){\\n        if(s[i]==\\'!\\'||s[i]==\\'&\\'||s[i]==\\'|\\'){\\n            int j=i;\\n            static stack<char>stk;\\n            stk.push(s[j+1]);\\n            i=j+2;\\n            while(!stk.empty()){\\n                if(s[i]==\\'(\\'){\\n                    stk.push(s[i]);\\n                    i++;\\n                    continue;\\n                }\\n                if(s[i]==\\')\\') {\\n                    stk.pop();\\n                    i++;\\n                    continue;\\n                }\\n                i++;\\n            }\\n            if(s[j]==\\'&\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str= And(str);\\n                if(j!=0){\\n                 s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'!\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=Not(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'|\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=OR(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }i=-1;continue;//to make the loop again run from start \\n        }\\n        if(s[i]==\\'f\\')\\n            return \"f\";\\n    }\\n    return \"t\";\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring And(string &s);\\nstring OR(string &s);\\nstring Not(string &s);\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'!\\'||s[i]==\\'&\\'||s[i]==\\'|\\'){\\n                int j=i;\\n                static stack<char>stk;\\n                stk.push(s[j+1]);\\n                i=j+2;\\n                while(!stk.empty()){\\n                    if(s[i]==\\'(\\'){\\n                        stk.push(s[i]);\\n                        i++;\\n                        continue;\\n                    }\\n                    if(s[i]==\\')\\') {\\n                        stk.pop();\\n                        i++;\\n                        continue;\\n                    }\\n                    i++;\\n                }\\n                if(s[j]==\\'&\\') {\\n                    string str = (s.substr(j + 2, i - j - 3));\\n                    str= And(str);\\n                    if(j!=0){\\n                        s.replace(j,i-j,str);\\n                    }else {\\n                        s.replace(j, i, str);\\n                    }\\n                }\\n                if(s[j]==\\'!\\') {\\n                    string str = (s.substr(j + 2, i - j - 3));\\n                    str=Not(str);\\n                    if(j!=0){\\n                        s.replace(j,i-j,str);\\n                    }else {\\n                        s.replace(j, i, str);\\n                    }\\n                }\\n                if(s[j]==\\'|\\') {\\n                    string str = (s.substr(j + 2, i - j - 3));\\n                    str=OR(str);\\n                    if(j!=0){\\n                        s.replace(j,i-j,str);\\n                    }else {\\n                        s.replace(j, i, str);\\n                    }\\n                }i=-1;continue;//to make the loop again run from start \\n            }\\n        }\\n\\n            if(s[0]==\\'t\\')\\n                return true;\\n            if(s[0]==\\'f\\')\\n                return false;\\n\\n        return \"\";\\n    }\\n};\\n\\nstring OR(string &s) {\\n    for(int i=0;i<s.size();i++){\\n        if(s[i]==\\'!\\'||s[i]==\\'&\\'||s[i]==\\'|\\'){\\n            int j=i;\\n            static stack<char>stk;\\n            stk.push(s[j+1]);\\n            i=j+2;\\n            while(!stk.empty()){\\n                if(s[i]==\\'(\\'){\\n                    stk.push(s[i]);\\n                    i++;\\n                    continue;\\n                }\\n                if(s[i]==\\')\\') {\\n                    stk.pop();\\n                    i++;\\n                    continue;\\n                }\\n                i++;\\n            }\\n            if(s[j]==\\'&\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str= And(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'!\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=Not(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'|\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=OR(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }i=-1;continue;//to make the loop again run from start \\n        }\\n        if(s[i]==\\'t\\')\\n            return \"t\";\\n    }\\n    return \"f\";\\n}\\nstring Not(string &s) {\\n    for(int i=0;i<s.size();i++){\\n        if(s[i]==\\'!\\'||s[i]==\\'&\\'||s[i]==\\'|\\'){\\n            int j=i;\\n            static stack<char>stk;\\n            stk.push(s[j+1]);\\n            i=j+2;\\n            while(!stk.empty()){\\n                if(s[i]==\\'(\\'){\\n                    stk.push(s[i]);\\n                    i++;\\n                    continue;\\n                }\\n                if(s[i]==\\')\\') {\\n                    stk.pop();\\n                    i++;\\n                    continue;\\n                }\\n                i++;\\n            }\\n            if(s[j]==\\'&\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str= And(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'!\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=Not(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'|\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=OR(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }i=-1;continue;//to make the loop again run from start \\n        }\\n        if(s[i]==\\'t\\')\\n            return \"f\";\\n        if(s[i]==\\'f\\')\\n            return \"t\";\\n    }\\n    return \"\";\\n}\\nstring And(string &s) {\\n    for(int i=0;i<s.size();i++){\\n        if(s[i]==\\'!\\'||s[i]==\\'&\\'||s[i]==\\'|\\'){\\n            int j=i;\\n            static stack<char>stk;\\n            stk.push(s[j+1]);\\n            i=j+2;\\n            while(!stk.empty()){\\n                if(s[i]==\\'(\\'){\\n                    stk.push(s[i]);\\n                    i++;\\n                    continue;\\n                }\\n                if(s[i]==\\')\\') {\\n                    stk.pop();\\n                    i++;\\n                    continue;\\n                }\\n                i++;\\n            }\\n            if(s[j]==\\'&\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str= And(str);\\n                if(j!=0){\\n                 s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'!\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=Not(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'|\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=OR(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }i=-1;continue;//to make the loop again run from start \\n        }\\n        if(s[i]==\\'f\\')\\n            return \"f\";\\n    }\\n    return \"t\";\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433025,
                "title": "c-96-recursion-not-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        if (expression == \"t\") return true;\\n        if (expression == \"f\") return false;\\n        \\n        auto oprt = expression[0];\\n        \\n        if (oprt == \\'!\\') {\\n            expression.pop_back();\\n            auto expr = expression.substr(2);\\n            return !parseBoolExpr(expr);\\n        }\\n        \\n        expression.pop_back();\\n        auto subexpr = expression.substr(2);\\n        int stk = 0;\\n        string expr;\\n        vector<string> exprs;\\n        for (auto cr : subexpr) {\\n            if (cr == \\'(\\') stk++;\\n            if (cr == \\')\\') stk--;\\n            if (cr == \\',\\') {\\n                if (stk == 0) {\\n                    exprs.push_back(expr);\\n                    expr = \"\";\\n                    continue;\\n                }\\n            }\\n            expr.push_back(cr);\\n        }\\n        \\n        exprs.push_back(expr);\\n        \\n        bool flag;\\n        if (oprt == \\'&\\') {\\n            flag = true;\\n            for (auto e : exprs) {\\n                flag = flag && parseBoolExpr(e);\\n            }\\n\\n        }\\n        \\n        if (oprt == \\'|\\') {\\n            flag = false;\\n            for (auto e : exprs) {\\n                flag = flag || parseBoolExpr(e);\\n            }\\n        }\\n        \\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        if (expression == \"t\") return true;\\n        if (expression == \"f\") return false;\\n        \\n        auto oprt = expression[0];\\n        \\n        if (oprt == \\'!\\') {\\n            expression.pop_back();\\n            auto expr = expression.substr(2);\\n            return !parseBoolExpr(expr);\\n        }\\n        \\n        expression.pop_back();\\n        auto subexpr = expression.substr(2);\\n        int stk = 0;\\n        string expr;\\n        vector<string> exprs;\\n        for (auto cr : subexpr) {\\n            if (cr == \\'(\\') stk++;\\n            if (cr == \\')\\') stk--;\\n            if (cr == \\',\\') {\\n                if (stk == 0) {\\n                    exprs.push_back(expr);\\n                    expr = \"\";\\n                    continue;\\n                }\\n            }\\n            expr.push_back(cr);\\n        }\\n        \\n        exprs.push_back(expr);\\n        \\n        bool flag;\\n        if (oprt == \\'&\\') {\\n            flag = true;\\n            for (auto e : exprs) {\\n                flag = flag && parseBoolExpr(e);\\n            }\\n\\n        }\\n        \\n        if (oprt == \\'|\\') {\\n            flag = false;\\n            for (auto e : exprs) {\\n                flag = flag || parseBoolExpr(e);\\n            }\\n        }\\n        \\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407632,
                "title": "cpp-solution-using-two-stacks",
                "content": "The first step is to reverse the string, so that whenever we encounter an operator, its operands are already in the stack, if we go from left to right in string.\\n\\nWhile iterating over the string, the following cases may arise:\\n1.  We encounter \\'t\\', \\'f\\', or \\')\\'. In this case, simply push to stack and continue.\\n2.  We encounter \\'(\\'. In this case, remove characters from stack until we have \\')\\' at the top of stack. This signifies that we have popped exactly one set of operands from stack.\\n3.  We encounter an operator. In this case, apply the operation on all the operands popped from stack in step 2, and store the answer back on stack.\\n\\nTo keep track of the operands we removed from our stack, we will use another temporary stack. This temporary stack would store only one set of operands at a time.\\n\\n**CODE:**\\n```\\nbool parseBoolExpr(string expression) {\\n        reverse(expression.begin(),expression.end());\\n        \\n        stack<char> s, t;\\n        for(auto c : expression) {\\n            if(c == \\')\\' || c == \\'t\\' || c == \\'f\\')\\n                s.push(c);\\n            else if(c == \\'(\\') {\\n                while(s.top() != \\')\\') {\\n                    t.push(s.top());\\n                    s.pop();\\n                }\\n                s.pop();\\n            }\\n            else if(c == \\'!\\') {\\n                char ans;\\n                while(!t.empty()) {\\n                    if(t.top() == \\'t\\')\\n                        ans = \\'f\\';\\n                    else ans = \\'t\\';\\n                    t.pop();\\n                }\\n                s.push(ans);\\n            }\\n            else if(c == \\'&\\') {\\n                char ans = \\'t\\';\\n                while(!t.empty()) {\\n                    if(t.top() == \\'f\\')\\n                        ans = \\'f\\';\\n                    t.pop();\\n                }\\n                s.push(ans);\\n            }\\n            else if(c == \\'|\\') {\\n                char ans = \\'f\\';\\n                while(!t.empty()) {\\n                    if(t.top() == \\'t\\')\\n                        ans = \\'t\\';\\n                    t.pop();\\n                }\\n                s.push(ans);\\n            }\\n        }\\n        \\n        return s.top() == \\'t\\' ? true : false;\\n    }\\n```",
                "solutionTags": [
                    "String",
                    "Stack"
                ],
                "code": "```\\nbool parseBoolExpr(string expression) {\\n        reverse(expression.begin(),expression.end());\\n        \\n        stack<char> s, t;\\n        for(auto c : expression) {\\n            if(c == \\')\\' || c == \\'t\\' || c == \\'f\\')\\n                s.push(c);\\n            else if(c == \\'(\\') {\\n                while(s.top() != \\')\\') {\\n                    t.push(s.top());\\n                    s.pop();\\n                }\\n                s.pop();\\n            }\\n            else if(c == \\'!\\') {\\n                char ans;\\n                while(!t.empty()) {\\n                    if(t.top() == \\'t\\')\\n                        ans = \\'f\\';\\n                    else ans = \\'t\\';\\n                    t.pop();\\n                }\\n                s.push(ans);\\n            }\\n            else if(c == \\'&\\') {\\n                char ans = \\'t\\';\\n                while(!t.empty()) {\\n                    if(t.top() == \\'f\\')\\n                        ans = \\'f\\';\\n                    t.pop();\\n                }\\n                s.push(ans);\\n            }\\n            else if(c == \\'|\\') {\\n                char ans = \\'f\\';\\n                while(!t.empty()) {\\n                    if(t.top() == \\'t\\')\\n                        ans = \\'t\\';\\n                    t.pop();\\n                }\\n                s.push(ans);\\n            }\\n        }\\n        \\n        return s.top() == \\'t\\' ? true : false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1388766,
                "title": "java-single-stack-easy-to-understand",
                "content": "```\\n\\nclass Solution {\\n\\tpublic boolean parseBoolExpr(String expression) {\\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0;i<expression.length();i++){\\n            char ch = expression.charAt(i);\\n            if(ch == \\')\\' || ch == \\'}\\'){\\n                boolean orAns = false;\\n                boolean andAns = true;\\n                boolean NotAns = false;\\n                while(stack.peek() != \\'(\\'){\\n                    char rm = stack.pop();\\n                    if(rm == \\'f\\'){\\n                        andAns = false;\\n                    }\\n                    if(rm == \\'t\\'){\\n                        orAns = true;\\n                    }\\n                    NotAns = rm == \\'t\\' ? false:true;\\n                }\\n                stack.pop();\\n                char rm = stack.pop();\\n                if( rm == \\'&\\'){\\n                    stack.push(andAns ? \\'t\\':\\'f\\');\\n                }\\n                else if( rm == \\'|\\'){\\n                    stack.push(orAns ? \\'t\\':\\'f\\');\\n                }\\n                else if(rm == \\'!\\'){\\n                    stack.push(NotAns ? \\'t\\':\\'f\\');\\n                }\\n            }else{\\n                if(ch == \\'{\\'){\\n                    stack.push(\\'(\\');\\n                }\\n                else{\\n                     stack.push(ch);\\n                }\\n            }\\n            \\n        }\\n        \\n        return stack.pop() == \\'t\\'? true: false;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic boolean parseBoolExpr(String expression) {\\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0;i<expression.length();i++){\\n            char ch = expression.charAt(i);\\n            if(ch == \\')\\' || ch == \\'}",
                "codeTag": "Java"
            },
            {
                "id": 1358099,
                "title": "c-clean-modularized-code",
                "content": "Process string right to left using **stack**.\\n\\n```\\nbool parseBoolExpr(string s) {\\n\\tint N=s.size();\\n\\tstack<char> stk;\\n\\tfor(int j=N-1; j>=0; j--) {\\n\\t\\tif (s[j] == \\',\\') continue;\\n\\t\\telse if (s[j] == \\')\\') stk.push(s[j]);\\n\\t\\telse if (s[j] == \\'(\\') {\\n\\t\\t\\tchar op = s[j-1];\\n\\t\\t\\tvector<bool> v;\\n\\t\\t\\twhile(stk.top() != \\')\\') {\\n\\t\\t\\t\\tv.push_back(toBool(stk.top()));  stk.pop();\\n\\t\\t\\t}\\n\\t\\t\\tstk.pop();\\n\\t\\t\\tstk.push(evaluate(op, v));\\n\\t\\t\\tj--;\\n\\t\\t} else stk.push(s[j]);\\n\\t}\\n\\treturn toBool(stk.top());\\n} \\n```\\n\\nHelpers: \\n```\\nchar evaluate(char op, vector<bool> &operands) {\\n\\tint result = op == \\'&\\' ? true : false;\\n\\tfor(bool v: operands) {\\n\\t\\tif (op == \\'!\\') return !v ? \\'t\\' : \\'f\\';\\n\\t\\telse if (op == \\'|\\') result |= v;\\n\\t\\telse result &= v;\\n\\t}\\n\\treturn result ? \\'t\\' : \\'f\\';\\n}\\n```\\n```\\nbool toBool(char c) {\\n\\treturn c == \\'t\\';\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool parseBoolExpr(string s) {\\n\\tint N=s.size();\\n\\tstack<char> stk;\\n\\tfor(int j=N-1; j>=0; j--) {\\n\\t\\tif (s[j] == \\',\\') continue;\\n\\t\\telse if (s[j] == \\')\\') stk.push(s[j]);\\n\\t\\telse if (s[j] == \\'(\\') {\\n\\t\\t\\tchar op = s[j-1];\\n\\t\\t\\tvector<bool> v;\\n\\t\\t\\twhile(stk.top() != \\')\\') {\\n\\t\\t\\t\\tv.push_back(toBool(stk.top()));  stk.pop();\\n\\t\\t\\t}\\n\\t\\t\\tstk.pop();\\n\\t\\t\\tstk.push(evaluate(op, v));\\n\\t\\t\\tj--;\\n\\t\\t} else stk.push(s[j]);\\n\\t}\\n\\treturn toBool(stk.top());\\n} \\n```\n```\\nchar evaluate(char op, vector<bool> &operands) {\\n\\tint result = op == \\'&\\' ? true : false;\\n\\tfor(bool v: operands) {\\n\\t\\tif (op == \\'!\\') return !v ? \\'t\\' : \\'f\\';\\n\\t\\telse if (op == \\'|\\') result |= v;\\n\\t\\telse result &= v;\\n\\t}\\n\\treturn result ? \\'t\\' : \\'f\\';\\n}\\n```\n```\\nbool toBool(char c) {\\n\\treturn c == \\'t\\';\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1351672,
                "title": "simple-and-clean-solution-using-recursion-pyhton",
                "content": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression):\\n        l=len(expression)\\n        for i in range(l):\\n            if expression[i]==\"(\": st=i\\n            if expression[i]==\")\":\\n                en=i\\n                break\\n        op=expression[st-1]\\n        #print(op)\\n        #print(expression[st:en+1])\\n        if op==\"&\": v=self.And(expression[st:en+1])\\n        if op==\"|\": v=self.Nor(expression[st:en+1])\\n        if op==\"!\": v=self.Not(expression[st:en+1])\\n        expression=expression[:st-1]+v+expression[en+1:]\\n        if expression==\"f\": return False\\n        if expression==\"t\": return True\\n        else: return self.parseBoolExpr(expression)\\n    \\n    def Not(self,exp):\\n        if \"t\" in exp: return \"f\"\\n        return \"t\"\\n    def Nor(self,exp):\\n        if \"t\" in exp: return \"t\"\\n        return \"f\"\\n    def And(self,exp):\\n        if \"f\" in exp: return \"f\"\\n        return \"t\"\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression):\\n        l=len(expression)\\n        for i in range(l):\\n            if expression[i]==\"(\": st=i\\n            if expression[i]==\")\":\\n                en=i\\n                break\\n        op=expression[st-1]\\n        #print(op)\\n        #print(expression[st:en+1])\\n        if op==\"&\": v=self.And(expression[st:en+1])\\n        if op==\"|\": v=self.Nor(expression[st:en+1])\\n        if op==\"!\": v=self.Not(expression[st:en+1])\\n        expression=expression[:st-1]+v+expression[en+1:]\\n        if expression==\"f\": return False\\n        if expression==\"t\": return True\\n        else: return self.parseBoolExpr(expression)\\n    \\n    def Not(self,exp):\\n        if \"t\" in exp: return \"f\"\\n        return \"t\"\\n    def Nor(self,exp):\\n        if \"t\" in exp: return \"t\"\\n        return \"f\"\\n    def And(self,exp):\\n        if \"f\" in exp: return \"f\"\\n        return \"t\"\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135308,
                "title": "c-solution-only-one-stack-solution-4ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n       stack<char> stk;\\n        \\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\',\\') continue;\\n            \\n            else if(s[i]==\\'f\\' || s[i]==\\'t\\' || s[i]==\\')\\' || s[i]==\\'(\\') stk.push(s[i]);\\n            \\n            else if(s[i]==\\'!\\')\\n            {\\n                bool exp=true;\\n                while(1)\\n                {\\n                   char x = stk.top(); stk.pop();\\n                    if(x==\\'(\\') continue;\\n                    else if(x==\\'f\\') exp=true;\\n                    else if(x==\\'t\\') exp=false;\\n                    else if(x==\\')\\')\\n                    {\\n                       if(exp) stk.push(\\'t\\');\\n                        else stk.push(\\'f\\');\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            else if(s[i]==\\'|\\')\\n            {\\n                bool exp=false;\\n                while(1)\\n                {\\n                    char x = stk.top(); stk.pop();\\n                    if(x==\\'(\\') continue;\\n                    else if(x==\\'f\\') exp=exp|false;\\n                    else if(x==\\'t\\') exp=exp|true;\\n                    else if(x==\\')\\')\\n                    {\\n                       if(exp) stk.push(\\'t\\');\\n                        else stk.push(\\'f\\');\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            else if(s[i]==\\'&\\')\\n            {\\n                bool exp=true;\\n                while(1)\\n                {\\n                    char x = stk.top(); stk.pop();\\n                    if(x==\\'(\\') continue;\\n                    else if(x==\\'f\\') exp=exp & false;\\n                    else if(x==\\'t\\') exp=exp & true;\\n                    else if(x==\\')\\')\\n                    {\\n                       if(exp) stk.push(\\'t\\');\\n                        else stk.push(\\'f\\');\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(stk.top()==\\'t\\') return true;\\n        else return false;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n       stack<char> stk;\\n        \\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\',\\') continue;\\n            \\n            else if(s[i]==\\'f\\' || s[i]==\\'t\\' || s[i]==\\')\\' || s[i]==\\'(\\') stk.push(s[i]);\\n            \\n            else if(s[i]==\\'!\\')\\n            {\\n                bool exp=true;\\n                while(1)\\n                {\\n                   char x = stk.top(); stk.pop();\\n                    if(x==\\'(\\') continue;\\n                    else if(x==\\'f\\') exp=true;\\n                    else if(x==\\'t\\') exp=false;\\n                    else if(x==\\')\\')\\n                    {\\n                       if(exp) stk.push(\\'t\\');\\n                        else stk.push(\\'f\\');\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            else if(s[i]==\\'|\\')\\n            {\\n                bool exp=false;\\n                while(1)\\n                {\\n                    char x = stk.top(); stk.pop();\\n                    if(x==\\'(\\') continue;\\n                    else if(x==\\'f\\') exp=exp|false;\\n                    else if(x==\\'t\\') exp=exp|true;\\n                    else if(x==\\')\\')\\n                    {\\n                       if(exp) stk.push(\\'t\\');\\n                        else stk.push(\\'f\\');\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            else if(s[i]==\\'&\\')\\n            {\\n                bool exp=true;\\n                while(1)\\n                {\\n                    char x = stk.top(); stk.pop();\\n                    if(x==\\'(\\') continue;\\n                    else if(x==\\'f\\') exp=exp & false;\\n                    else if(x==\\'t\\') exp=exp & true;\\n                    else if(x==\\')\\')\\n                    {\\n                       if(exp) stk.push(\\'t\\');\\n                        else stk.push(\\'f\\');\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(stk.top()==\\'t\\') return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1128897,
                "title": "python-easy-and-straightforward-solution-using-stack",
                "content": "**Intuition - Parsing problems**\\n\\nThis is one of the typical parsing questions in Leetcode. \\n- Parsing is quite challenging if you are not familiar with it; but once you know, it\\'s very fun to solve.\\n- Approaches: This type of problem could be solved using recursive descent or stack. I prefer stack since it is pretty straightforward and easy for detailed runtime and space complexity analysis.\\n- ***Note***: It\\'s very useful to check beforehand whether iterating the list backward is the good option. For example, in the problem [Parsing atoms from a chemical formula](https://leetcode.com/problems/number-of-atoms/), going backward is the best way to start.  \\n\\n**Algorithm**\\n\\n- Example 1:  Input: \"!(f)\"=> ***NOT false*** => Output: ***True***\\n- Example 2: Input: \"|(f,t)\" => ***OR*** of (***false, true***) => Output: ***True***\\n- Approach: Iterate through the expression and put all the characters into a stack , when encounter \")\", pop each element in the previous inner expression out of the stack for parsing, and then put the result back in stack. If the expression is valid (as confirmed in the **Constraints** session), then at the end of the loop, the stack remains only 1 value, which is \"t\" or \"f\". \\n+ Note that there are only 3 logical characters NOT, OR and AND => For clean code, as suggested in the problem hints: \"Write a function \"parse\" which calls helper functions \"parse_or\", \"parse_and\", \"parse_not\"\".\\n\\n**Example:**\\n\\nInput: **expression = \"|(&(t,f,t),!(t))\"**\\nIterate from 0 to len(expression)-1\\n1. When encounter the first \")\" :\\n`stack = [\"|\", \"(\", \"&\", \"(\", \"t\", \"f\", \"t\"]`\\n2. Go through parse function, pop out `\"&\", \"(\", \"t\", \"f\", \"t\" `=> result is \"f\", put back \"f\" in stack\\n`stack = [\"|\", \"(\", \"f\"]`\\n3. Continue on the expression, encounter the second \")\":\\n`stack = [\"|\", \"(\", \"f\", \"!\", \"(\", \"t\"] `\\n4. Go through parse function, pop out `\"!\", \"(\", \"t\" `=> result is \"f\", put back \"f\" in stack\\n`stack = [\"|\", \"(\", \"f\", \"f\"]`\\n5. Continue on the expression, encounter the third \")\":\\n`stack = [\"|\", \"(\", \"f\", \"f\"]`\\n6. Go through parse function, pop out` \"|\", \"(\", \"f\", \"f\"` => result is \"f\", put back \"f\" in stack\\n`stack = [\"f\"]`\\n7. Return False since stack[0] = \"f\"\\n\\n**Python:**\\n\\n```\\ndef parseBoolExpr(self, expression: str) -> bool: \\n        ###helper functions \"parse_or\", \"parse_and\", \"parse_not\"\".\\n        def parse_not(vals):\\n            if len(vals) == 1:\\n                return \"f\" if vals[0] == \"t\" else \"t\"\\n            else:\\n                print(\"More than 1 in !\", vals)\\n                \\n        def parse_and(vals):\\n            boolval = True if vals[0] == \"t\" else False\\n            for x in vals[1:]:\\n                boolval = boolval and (True if x == \"t\" else False)\\n            return \"f\" if boolval == False else \"t\"\\n        \\n        def parse_or(vals):\\n            boolval = True if vals[0] == \"t\" else False\\n            for x in vals[1:]:\\n                boolval = boolval or (True if x == \"t\" else False)\\n            return \"f\" if boolval == False else \"t\"\\n        \\n        ### parse function\\n        def parsing(stack):\\n            vals = [] # to store inner expression elements\\n            expr = \"\" # to store the logical expression\\n            result = \"\" # final result\\n            while stack:\\n                #pop out the elements and store in the list \"vals\" in the current inner expression until reach \"(\"\\n                curr = stack.pop()\\n                if curr == \"(\":\\n                    #get the logical expression \\n                    if stack: \\n                        expr = stack.pop()\\n                        break\\n                else:\\n                    vals.append(curr)\\n            # parsing using the helper functions\\n            if expr == \"\":\\n                print(\"Something\\'s wrong\", vals)\\n            else:\\n                if expr == \"!\":\\n                    result = parse_not(vals)       \\n                elif expr == \"&\":\\n                    result = parse_and(vals)   \\n                elif expr == \"|\":\\n                    result = parse_or(vals) \\n            # put the result back into stack\\n            stack.append(result)\\n                    \\n        stack = []    \\n        for i, x in enumerate(expression):\\n            # if encounter \")\", do parsing\\n            if x == \")\":\\n                parsing(stack)\\n            elif x == \",\":\\n                pass\\n            else:\\n                stack.append(x)\\n                \\n        #  If the expression is valid then at the end of the loop,  the stack remains only 1 value, which is \"t\" or \"f\"         \\n        return True if stack[0] == \"t\" else False\\n```\\n\\n**Complexity Analysis**\\n\\n- Time Complexity: O(N^2), where N is the length of the expression\\nO(n) to iterate through the expression\\nThe parsing of the ***k*** inner expression may cost O(k). But ***k*** doesn\\'t have any limitation, it could take a value up to **k < N/2**, therefore the complexity boils down to O(N^2)\\n- Space Complexity: O(N). There is no more intermediate information than what is in the expression.\\n\\n**More On Parsing Problems**\\n\\nMedium Problems:\\n- [227. Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/) (Similar to parsing problem, but at lower level, usually grouped in the **stack problem group**.)\\n- [150. Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/)\\n\\nHard Problems:\\n- [726. Number of Atoms](https://leetcode.com/problems/number-of-atoms/)\\n- [736. Parse Lisp Expression](https://leetcode.com/problems/parse-lisp-expression/)\\n",
                "solutionTags": [],
                "code": "```\\ndef parseBoolExpr(self, expression: str) -> bool: \\n        ###helper functions \"parse_or\", \"parse_and\", \"parse_not\"\".\\n        def parse_not(vals):\\n            if len(vals) == 1:\\n                return \"f\" if vals[0] == \"t\" else \"t\"\\n            else:\\n                print(\"More than 1 in !\", vals)\\n                \\n        def parse_and(vals):\\n            boolval = True if vals[0] == \"t\" else False\\n            for x in vals[1:]:\\n                boolval = boolval and (True if x == \"t\" else False)\\n            return \"f\" if boolval == False else \"t\"\\n        \\n        def parse_or(vals):\\n            boolval = True if vals[0] == \"t\" else False\\n            for x in vals[1:]:\\n                boolval = boolval or (True if x == \"t\" else False)\\n            return \"f\" if boolval == False else \"t\"\\n        \\n        ### parse function\\n        def parsing(stack):\\n            vals = [] # to store inner expression elements\\n            expr = \"\" # to store the logical expression\\n            result = \"\" # final result\\n            while stack:\\n                #pop out the elements and store in the list \"vals\" in the current inner expression until reach \"(\"\\n                curr = stack.pop()\\n                if curr == \"(\":\\n                    #get the logical expression \\n                    if stack: \\n                        expr = stack.pop()\\n                        break\\n                else:\\n                    vals.append(curr)\\n            # parsing using the helper functions\\n            if expr == \"\":\\n                print(\"Something\\'s wrong\", vals)\\n            else:\\n                if expr == \"!\":\\n                    result = parse_not(vals)       \\n                elif expr == \"&\":\\n                    result = parse_and(vals)   \\n                elif expr == \"|\":\\n                    result = parse_or(vals) \\n            # put the result back into stack\\n            stack.append(result)\\n                    \\n        stack = []    \\n        for i, x in enumerate(expression):\\n            # if encounter \")\", do parsing\\n            if x == \")\":\\n                parsing(stack)\\n            elif x == \",\":\\n                pass\\n            else:\\n                stack.append(x)\\n                \\n        #  If the expression is valid then at the end of the loop,  the stack remains only 1 value, which is \"t\" or \"f\"         \\n        return True if stack[0] == \"t\" else False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1107628,
                "title": "c-simple-two-stack-solution",
                "content": "class Solution {\\npublic:\\n    bool parseBoolExpr(string exp) {\\n        stack<char> op;\\n        stack<char> st;\\n        \\n        for(int i=0;i<exp.length();i++)\\n        {\\n            if(exp[i]==\\'(\\' || exp[i]==\\'f\\' || exp[i]==\\'t\\')\\n                st.push(exp[i]);\\n            else if(exp[i]==\\'&\\' || exp[i]==\\'|\\' || exp[i]==\\'!\\')\\n                op.push(exp[i]);\\n            else if(exp[i]==\\')\\')\\n            {\\n                char oper;\\n                bool result;\\n                if(!op.empty())\\n                {\\n                    oper=op.top();\\n                    op.pop();\\n                }\\n                if(oper==\\'&\\')\\n                    result=true;\\n                else if(oper==\\'|\\')\\n                    result=false;\\n                while(!st.empty() && st.top()!=\\'(\\')\\n                {\\n                    char top=st.top();\\n                    st.pop();\\n\\t\\t\\t\\t\\tif(oper==\\'&\\')\\n\\t\\t\\t\\t\\t\\tresult&=(top==\\'t\\');\\n\\t\\t\\t\\t\\telse if(oper==\\'|\\')\\n\\t\\t\\t\\t\\t\\tresult|=(top==\\'t\\');\\n\\t\\t\\t\\t\\telse if(oper==\\'!\\')\\n\\t\\t\\t\\t\\t\\tresult=!(top==\\'t\\');\\n                }\\n                if(!st.empty() && st.top()==\\'(\\')\\n                    st.pop();\\n                st.push(result?\\'t\\':\\'f\\');\\n            }\\n        }\\n        \\n        if(!st.empty())\\n            return st.top()==\\'t\\'?true:false;\\n        return false;\\n    }\\n};\\n\\nThis solution is a simple solution with two stacks.\\nhowever, not sure why this solution shows runtime as 8ms which is 64% faster?\\nCan anyone explain me why this solution has higher runtime and how to improve it?",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool parseBoolExpr(string exp) {\\n        stack<char> op;\\n        stack<char> st;\\n        \\n        for(int i=0;i<exp.length();i++)\\n        {\\n            if(exp[i]==\\'(\\' || exp[i]==\\'f\\' || exp[i]==\\'t\\')\\n                st.push(exp[i]);\\n            else if(exp[i]==\\'&\\' || exp[i]==\\'|\\' || exp[i]==\\'!\\')\\n                op.push(exp[i]);\\n            else if(exp[i]==\\')\\')\\n            {\\n                char oper;\\n                bool result;\\n                if(!op.empty())\\n                {\\n                    oper=op.top();\\n                    op.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1002861,
                "title": "easy-to-understand-and-visualize-2-stack-approach",
                "content": "This is my first attempt at posting a discussion thread. I found it easy to work with 2 stacks one for the operators and another one for the expressions. I used a helper function called eval which works with a operator and a list of expression values.\\nThe approach is pretty simple I parse the string from left to right and i I find a operator I add it to the operator stack and for \\'(\\', \\' t\\' and \\'f\\' I add them to the exprs stack. Once I arrive at a \\')\\' Iknow that the previous operator has to be applied to the list of expressions till the previous \\'(\\'. so the eval function comes in handy. Then I push this result back to the expression stack and continue to the end. Finally the result will be at the top of the expression stack.\\n```\\npublic boolean parseBoolExpr(String s) {\\n        Stack<Character> ops = new Stack<>();\\n        Stack<Character> expr = new Stack<>();\\n        \\n        for(int i=0; i<s.length(); ++i) {\\n            if(s.charAt(i)==\\'!\\' || s.charAt(i)==\\'&\\' || s.charAt(i)==\\'|\\' ) {\\n                ops.push(s.charAt(i));\\n            } else {\\n                if(s.charAt(i)==\\',\\') {\\n                    continue;\\n                } else if(s.charAt(i) == \\')\\') {\\n                    List<Character> exprs = new ArrayList<>();\\n                    while(!expr.isEmpty() && expr.peek()!=\\'(\\') {\\n                        exprs.add(expr.pop());\\n                    }\\n                    expr.pop();\\n                    boolean res = eval(ops.pop(), exprs);\\n                    expr.push(res?\\'t\\':\\'f\\');\\n                } else {\\n                    expr.push(s.charAt(i));\\n                }\\n            }\\n        }\\n        return expr.peek()==\\'t\\';\\n    }\\n    public boolean eval(Character op, List<Character> expr) {\\n        if(op == \\'!\\') {\\n            return expr.get(0) == \\'t\\'? false:true;\\n        } else if(op == \\'|\\') {\\n            for(char c :expr) {\\n                if(c == \\'t\\') {\\n                    return true;\\n                } \\n            }\\n            return false;\\n        } else  {\\n            for(char c :expr) {\\n                if(c == \\'f\\') {\\n                    return false;\\n                } \\n            }\\n            return true;\\n        }\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic boolean parseBoolExpr(String s) {\\n        Stack<Character> ops = new Stack<>();\\n        Stack<Character> expr = new Stack<>();\\n        \\n        for(int i=0; i<s.length(); ++i) {\\n            if(s.charAt(i)==\\'!\\' || s.charAt(i)==\\'&\\' || s.charAt(i)==\\'|\\' ) {\\n                ops.push(s.charAt(i));\\n            } else {\\n                if(s.charAt(i)==\\',\\') {\\n                    continue;\\n                } else if(s.charAt(i) == \\')\\') {\\n                    List<Character> exprs = new ArrayList<>();\\n                    while(!expr.isEmpty() && expr.peek()!=\\'(\\') {\\n                        exprs.add(expr.pop());\\n                    }\\n                    expr.pop();\\n                    boolean res = eval(ops.pop(), exprs);\\n                    expr.push(res?\\'t\\':\\'f\\');\\n                } else {\\n                    expr.push(s.charAt(i));\\n                }\\n            }\\n        }\\n        return expr.peek()==\\'t\\';\\n    }\\n    public boolean eval(Character op, List<Character> expr) {\\n        if(op == \\'!\\') {\\n            return expr.get(0) == \\'t\\'? false:true;\\n        } else if(op == \\'|\\') {\\n            for(char c :expr) {\\n                if(c == \\'t\\') {\\n                    return true;\\n                } \\n            }\\n            return false;\\n        } else  {\\n            for(char c :expr) {\\n                if(c == \\'f\\') {\\n                    return false;\\n                } \\n            }\\n            return true;\\n        }\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 930038,
                "title": "python-simple-intuitive-stack-o-n-time-o-n-space",
                "content": "```\\nclass Solution(object):\\n    def andFunction(self, array):\\n        return all(array)\\n\\n    def orFunction(self, array):\\n        return any(array)\\n\\n    def notFunction(self, array):\\n        return not(array[0])\\n\\n    def parseBoolExpr(self, expression):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: bool\\n        \"\"\"\\n        stack = []\\n        functionMapper = {\\n            \\'&\\': self.andFunction,\\n            \\'|\\': self.orFunction,\\n            \\'!\\': self.notFunction\\n        }\\n\\n        for token in expression:\\n            if token == \\')\\':\\n                temp = []\\n                while stack[len(stack)-1] != \\'(\\':\\n                    temp.append(stack.pop())\\n                stack.pop()\\n                op = stack.pop()\\n\\n                func = functionMapper[op]\\n                stack.append(func(temp))\\n\\n            else:\\n                if token == \\'t\\':\\n                    stack.append(True)\\n                elif token == \\'f\\':\\n                    stack.append(False)\\n\\n                elif token == \\',\\':\\n                    continue\\n                else:\\n                    stack.append(token)\\n        return stack[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution(object):\\n    def andFunction(self, array):\\n        return all(array)\\n\\n    def orFunction(self, array):\\n        return any(array)\\n\\n    def notFunction(self, array):\\n        return not(array[0])\\n\\n    def parseBoolExpr(self, expression):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: bool\\n        \"\"\"\\n        stack = []\\n        functionMapper = {\\n            \\'&\\': self.andFunction,\\n            \\'|\\': self.orFunction,\\n            \\'!\\': self.notFunction\\n        }\\n\\n        for token in expression:\\n            if token == \\')\\':\\n                temp = []\\n                while stack[len(stack)-1] != \\'(\\':\\n                    temp.append(stack.pop())\\n                stack.pop()\\n                op = stack.pop()\\n\\n                func = functionMapper[op]\\n                stack.append(func(temp))\\n\\n            else:\\n                if token == \\'t\\':\\n                    stack.append(True)\\n                elif token == \\'f\\':\\n                    stack.append(False)\\n\\n                elif token == \\',\\':\\n                    continue\\n                else:\\n                    stack.append(token)\\n        return stack[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882898,
                "title": "javascript-recursion",
                "content": "Not too proud of this one.\\n```js\\nvar parseBoolExpr = function(x) {\\n    if (x === \\'t\\') return true;\\n    if (x === \\'f\\') return false;\\n    \\n    const op = x.charAt(0), content = x.substring(2, x.length - 1);\\n    if (op === \\'!\\') return !parseBoolExpr(content);\\n    \\n    const A = [];\\n    let level = 0, si = 0;\\n    for (let i = 0; i < content.length; ++i) {\\n        if (content[i] === \\'(\\') ++level;\\n        else if (content[i] === \\')\\') --level;\\n        if (level === 0 && (content[i] === \\'t\\' || content[i] === \\'f\\' || content[i] === \\')\\')) {\\n            A.push(content.substring(si, i + 1));\\n            si = i + 2;\\n        }\\n    }\\n    \\n    let b;\\n    if (op === \\'&\\')\\n        for (let a of A)\\n            b = b !== undefined ? b && parseBoolExpr(a) : parseBoolExpr(a);\\n    else if (op === \\'|\\')\\n        for (let a of A)\\n            b = b || parseBoolExpr(a);\\n    return b;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar parseBoolExpr = function(x) {\\n    if (x === \\'t\\') return true;\\n    if (x === \\'f\\') return false;\\n    \\n    const op = x.charAt(0), content = x.substring(2, x.length - 1);\\n    if (op === \\'!\\') return !parseBoolExpr(content);\\n    \\n    const A = [];\\n    let level = 0, si = 0;\\n    for (let i = 0; i < content.length; ++i) {\\n        if (content[i] === \\'(\\') ++level;\\n        else if (content[i] === \\')\\') --level;\\n        if (level === 0 && (content[i] === \\'t\\' || content[i] === \\'f\\' || content[i] === \\')\\')) {\\n            A.push(content.substring(si, i + 1));\\n            si = i + 2;\\n        }\\n    }\\n    \\n    let b;\\n    if (op === \\'&\\')\\n        for (let a of A)\\n            b = b !== undefined ? b && parseBoolExpr(a) : parseBoolExpr(a);\\n    else if (op === \\'|\\')\\n        for (let a of A)\\n            b = b || parseBoolExpr(a);\\n    return b;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 875448,
                "title": "recursive-stack",
                "content": "```\\nclass Solution:\\n    def parseBoolExpr(self, E: str) -> bool:\\n        if E==\"f\": return False\\n        if E==\"t\": return True\\n        if E[0]==\"!\": return not self.parseBoolExpr(E[2:-1])\\n        \\n        X = []\\n        sub = \"\"\\n        openb = 0\\n        for c in E[2:-1]:\\n            if c == \"(\": openb += 1\\n            if c == \")\": openb -= 1\\n            if c == \",\" and openb == 0: \\n                X.append(sub)\\n                sub=\"\"\\n            else: sub += c\\n        X.append(sub)\\n    \\n        X=[self.parseBoolExpr(x) for x in X]\\n        \\n        if E[0]==\\'&\\': return all(X)\\n        if E[0]==\"|\": return any(X)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, E: str) -> bool:\\n        if E==\"f\": return False\\n        if E==\"t\": return True\\n        if E[0]==\"!\": return not self.parseBoolExpr(E[2:-1])\\n        \\n        X = []\\n        sub = \"\"\\n        openb = 0\\n        for c in E[2:-1]:\\n            if c == \"(\": openb += 1\\n            if c == \")\": openb -= 1\\n            if c == \",\" and openb == 0: \\n                X.append(sub)\\n                sub=\"\"\\n            else: sub += c\\n        X.append(sub)\\n    \\n        X=[self.parseBoolExpr(x) for x in X]\\n        \\n        if E[0]==\\'&\\': return all(X)\\n        if E[0]==\"|\": return any(X)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812371,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n        stack<char> st;\\n        int operation=1;\\n       for(int i=s.length()-1;i>=0;i--){\\n           if(s[i]==\\'|\\'){\\n               bool result=false;\\n               while(st.size()){\\n                   if(st.top()==\\'(\\'){\\n                       st.pop();\\n                   }else if(st.top()==\\'t\\'){\\n                       result|=1;\\n                       st.pop();\\n                   }else if(st.top()==\\'f\\'){\\n                       result|=0;\\n                       st.pop();\\n                   }else if(st.top()==\\')\\'){\\n                       st.pop();\\n                       st.push(result==true?\\'t\\':\\'f\\');\\n                       break;\\n                   }\\n               }\\n           }else if(s[i]==\\'!\\'){\\n               bool result=false;\\n               while(st.size()){\\n                   if(st.top()==\\'(\\'){\\n                       st.pop();\\n                   }else if(st.top()==\\'t\\'){\\n                       result|=1;\\n                       st.pop();\\n                   }else if(st.top()==\\'f\\'){\\n                       result|=0;\\n                       st.pop();\\n                   }else if(st.top()==\\')\\'){\\n                       st.pop();\\n                       st.push(!result==true?\\'t\\':\\'f\\');\\n                       break;\\n                   }\\n               }\\n               \\n           }else if(s[i]==\\'&\\'){\\n               bool result=true;\\n               while(st.size()){\\n                   if(st.top()==\\'(\\'){\\n                       st.pop();\\n                   }else if(st.top()==\\'t\\'){\\n                       result&=1;\\n                       st.pop();\\n                   }else if(st.top()==\\'f\\'){\\n                       result&=0;\\n                       st.pop();\\n                   }else if(st.top()==\\')\\'){\\n                       st.pop();\\n                       st.push(result==true?\\'t\\':\\'f\\');\\n                       break;\\n                   }\\n               }\\n               \\n           }else if(s[i]==\\',\\'){\\n               continue;\\n           }else{\\n               st.push(s[i]);\\n           }\\n       }\\n        \\n        if(st.size()){\\n            if(st.top()==\\'t\\'){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n        stack<char> st;\\n        int operation=1;\\n       for(int i=s.length()-1;i>=0;i--){\\n           if(s[i]==\\'|\\'){\\n               bool result=false;\\n               while(st.size()){\\n                   if(st.top()==\\'(\\'){\\n                       st.pop();\\n                   }else if(st.top()==\\'t\\'){\\n                       result|=1;\\n                       st.pop();\\n                   }else if(st.top()==\\'f\\'){\\n                       result|=0;\\n                       st.pop();\\n                   }else if(st.top()==\\')\\'){\\n                       st.pop();\\n                       st.push(result==true?\\'t\\':\\'f\\');\\n                       break;\\n                   }\\n               }\\n           }else if(s[i]==\\'!\\'){\\n               bool result=false;\\n               while(st.size()){\\n                   if(st.top()==\\'(\\'){\\n                       st.pop();\\n                   }else if(st.top()==\\'t\\'){\\n                       result|=1;\\n                       st.pop();\\n                   }else if(st.top()==\\'f\\'){\\n                       result|=0;\\n                       st.pop();\\n                   }else if(st.top()==\\')\\'){\\n                       st.pop();\\n                       st.push(!result==true?\\'t\\':\\'f\\');\\n                       break;\\n                   }\\n               }\\n               \\n           }else if(s[i]==\\'&\\'){\\n               bool result=true;\\n               while(st.size()){\\n                   if(st.top()==\\'(\\'){\\n                       st.pop();\\n                   }else if(st.top()==\\'t\\'){\\n                       result&=1;\\n                       st.pop();\\n                   }else if(st.top()==\\'f\\'){\\n                       result&=0;\\n                       st.pop();\\n                   }else if(st.top()==\\')\\'){\\n                       st.pop();\\n                       st.push(result==true?\\'t\\':\\'f\\');\\n                       break;\\n                   }\\n               }\\n               \\n           }else if(s[i]==\\',\\'){\\n               continue;\\n           }else{\\n               st.push(s[i]);\\n           }\\n       }\\n        \\n        if(st.size()){\\n            if(st.top()==\\'t\\'){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798124,
                "title": "beginner-friendly-not-really-hard-beats-95",
                "content": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack=[]\\n        \\n        for sym in expression:\\n            if sym==\\',\\':\\n                continue\\n            elif sym==\\')\\':\\n                temp=set()\\n                while stack[-1]!= \\'(\\':\\n                    temp.add(stack.pop())\\n                stack.pop()\\n                oper=stack.pop()\\n                if oper==\\'!\\':\\n                    if \\'t\\' in temp:\\n                        stack.append(\\'f\\')\\n                    else:\\n                        stack.append(\\'t\\')\\n                elif oper==\"|\":\\n                    if \\'t\\' in temp:\\n                        stack.append(\\'t\\')\\n                    else:\\n                        stack.append(\\'f\\')\\n                else:\\n                    if \\'f\\' in temp:\\n                        stack.append(\\'f\\')\\n                    else:\\n                        stack.append(\\'t\\')\\n            else:\\n                stack.append(sym)\\n        \\n            \\n        return True if stack[-1]==\\'t\\' else False              \\n                \\n                        \\n                    \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack=[]\\n        \\n        for sym in expression:\\n            if sym==\\',\\':\\n                continue\\n            elif sym==\\')\\':\\n                temp=set()\\n                while stack[-1]!= \\'(\\':\\n                    temp.add(stack.pop())\\n                stack.pop()\\n                oper=stack.pop()\\n                if oper==\\'!\\':\\n                    if \\'t\\' in temp:\\n                        stack.append(\\'f\\')\\n                    else:\\n                        stack.append(\\'t\\')\\n                elif oper==\"|\":\\n                    if \\'t\\' in temp:\\n                        stack.append(\\'t\\')\\n                    else:\\n                        stack.append(\\'f\\')\\n                else:\\n                    if \\'f\\' in temp:\\n                        stack.append(\\'f\\')\\n                    else:\\n                        stack.append(\\'t\\')\\n            else:\\n                stack.append(sym)\\n        \\n            \\n        return True if stack[-1]==\\'t\\' else False              \\n                \\n                        \\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 767212,
                "title": "c-solution-beats-87",
                "content": "Maintaining two stacks, one for the `operators(&, |, !)` and the other for values\\nLogic:\\n1. When you find the operator, push it into the stack `operation`\\n2. When you find `,` continue;\\n3. When you find `)` that is the closing parenthisis of operation, perform the operation AND after performing the operation, if the operation stack is empty( meaning all operations are done) return the value, else push the value in the `val` stack for further use.\\n4. When you find anything else, push it into the stack `val`; \\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> operation;\\n        stack<char> val;\\n        char e;\\n        bool v;\\n        for(char c: expression) {\\n            if(c == \\'|\\' || c ==\\'&\\' || c == \\'!\\') {\\n                operation.push(c);\\n            } else if(c == \\',\\') {\\n\\t\\t\\t\\tcontinue; \\n\\t\\t\\t} else if(c == \\')\\') {\\n                // pop from the stack\\n                char op = operation.top(); operation.pop();\\n                if(op == \\'&\\') {\\n                    v = true;\\n                    e = val.top(); val.pop();\\n                    while(e != \\'(\\') {\\n                        bool a = e==\\'t\\'?true:false;\\n                        v = v&a;\\n                        e = val.top(); val.pop();\\n                    }\\n                }\\n                if(op == \\'|\\') {\\n                    v = false;\\n                    e = val.top(); val.pop();\\n                    while(e != \\'(\\') {\\n                        bool a = e==\\'t\\'?true:false;\\n                        v = v|a;\\n                        e = val.top(); val.pop();\\n                    }\\n                } \\n                if(op == \\'!\\') {\\n                    e = val.top(); val.pop();\\n                    while(e != \\'(\\') {\\n                        bool a = e==\\'t\\'?true:false;\\n                        v = !a;\\n                        e = val.top(); val.pop();\\n                    }\\n                }\\n                if(operation.empty()) {\\n                    return v;\\n                } else {\\n                    e = (v==true?\\'t\\':\\'f\\');\\n                    val.push(e);\\n                }\\n            } else {\\n                val.push(c);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> operation;\\n        stack<char> val;\\n        char e;\\n        bool v;\\n        for(char c: expression) {\\n            if(c == \\'|\\' || c ==\\'&\\' || c == \\'!\\') {\\n                operation.push(c);\\n            } else if(c == \\',\\') {\\n\\t\\t\\t\\tcontinue; \\n\\t\\t\\t} else if(c == \\')\\') {\\n                // pop from the stack\\n                char op = operation.top(); operation.pop();\\n                if(op == \\'&\\') {\\n                    v = true;\\n                    e = val.top(); val.pop();\\n                    while(e != \\'(\\') {\\n                        bool a = e==\\'t\\'?true:false;\\n                        v = v&a;\\n                        e = val.top(); val.pop();\\n                    }\\n                }\\n                if(op == \\'|\\') {\\n                    v = false;\\n                    e = val.top(); val.pop();\\n                    while(e != \\'(\\') {\\n                        bool a = e==\\'t\\'?true:false;\\n                        v = v|a;\\n                        e = val.top(); val.pop();\\n                    }\\n                } \\n                if(op == \\'!\\') {\\n                    e = val.top(); val.pop();\\n                    while(e != \\'(\\') {\\n                        bool a = e==\\'t\\'?true:false;\\n                        v = !a;\\n                        e = val.top(); val.pop();\\n                    }\\n                }\\n                if(operation.empty()) {\\n                    return v;\\n                } else {\\n                    e = (v==true?\\'t\\':\\'f\\');\\n                    val.push(e);\\n                }\\n            } else {\\n                val.push(c);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 647468,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> logic, var;\\n        for(auto& ch : expression){\\n            if(ch == \\'!\\' || ch == \\'|\\' || ch == \\'&\\'){\\n                logic.push(ch);\\n            }else if(ch == \\'(\\' || ch == \\'f\\' || ch == \\'t\\'){\\n                var.push(ch);\\n            }else if(ch == \\')\\'){\\n                char operation = logic.top(); logic.pop();\\n                char res = \\'t\\';\\n                if(operation == \\'!\\'){\\n                    if(!var.empty() && var.top() != \\'(\\'){\\n                        char top = var.top(); var.pop();\\n                        if(top == \\'t\\') res = \\'f\\';\\n                        else           res = \\'t\\';\\n                    }\\n                }else if(operation == \\'&\\'){\\n                    while(!var.empty() && var.top() != \\'(\\'){\\n                        char top = var.top(); var.pop();\\n                        if(top == \\'f\\') res = \\'f\\'; \\n                    }                    \\n                }else if(operation == \\'|\\'){\\n                    res = \\'f\\';\\n                    while(!var.empty() && var.top() != \\'(\\'){\\n                        char top = var.top(); var.pop();\\n                        if(top == \\'t\\') res = \\'t\\'; \\n                    }                        \\n                }\\n                var.pop(); var.push(res);\\n            }\\n        }\\n        return var.top() == \\'t\\' ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> logic, var;\\n        for(auto& ch : expression){\\n            if(ch == \\'!\\' || ch == \\'|\\' || ch == \\'&\\'){\\n                logic.push(ch);\\n            }else if(ch == \\'(\\' || ch == \\'f\\' || ch == \\'t\\'){\\n                var.push(ch);\\n            }else if(ch == \\')\\'){\\n                char operation = logic.top(); logic.pop();\\n                char res = \\'t\\';\\n                if(operation == \\'!\\'){\\n                    if(!var.empty() && var.top() != \\'(\\'){\\n                        char top = var.top(); var.pop();\\n                        if(top == \\'t\\') res = \\'f\\';\\n                        else           res = \\'t\\';\\n                    }\\n                }else if(operation == \\'&\\'){\\n                    while(!var.empty() && var.top() != \\'(\\'){\\n                        char top = var.top(); var.pop();\\n                        if(top == \\'f\\') res = \\'f\\'; \\n                    }                    \\n                }else if(operation == \\'|\\'){\\n                    res = \\'f\\';\\n                    while(!var.empty() && var.top() != \\'(\\'){\\n                        char top = var.top(); var.pop();\\n                        if(top == \\'t\\') res = \\'t\\'; \\n                    }                        \\n                }\\n                var.pop(); var.push(res);\\n            }\\n        }\\n        return var.top() == \\'t\\' ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581908,
                "title": "go-beats-100-0ms-ll-1-parser",
                "content": "```go\\n/*\\ngrammar definition:\\n\\nS-> !(S) | |(L) | &(L) | E\\nL-> S | S,L\\nE-> t | f\\n*/\\nfunc parseBoolExpr(expression string) bool {\\n\\treader := strings.NewReader(expression)\\n\\treturn parseExpr(reader)\\n}\\n\\nfunc parseExpr(reader *strings.Reader) bool {\\n\\tlookahead, _ := reader.ReadByte()\\n\\n\\tvar result bool\\n\\tif lookahead == \\'!\\' {\\n\\t\\treader.ReadByte()\\n\\t\\tresult = !parseExpr(reader)\\n\\t\\treader.ReadByte() // eliminate trailing \\')\\'\\n\\t} else if lookahead == \\'|\\' {\\n\\t\\treader.ReadByte()\\n\\t\\tresult = parseOrExpList(reader)\\n\\t} else if lookahead == \\'&\\' {\\n\\t\\treader.ReadByte()\\n\\t\\tresult = parseAndExpList(reader)\\n\\t} else if lookahead == \\'t\\' {\\n\\t\\treturn true\\n\\t} else {\\n\\t\\treturn false\\n\\t}\\n\\treturn result\\n}\\n\\nfunc parseAndExpList(reader *strings.Reader) bool {\\n\\tresult := parseExpr(reader)\\n\\tif reader.Len() > 0 {\\n\\t\\tlookahead, _ := reader.ReadByte()\\n\\t\\tif lookahead == \\',\\' {\\n\\t\\t\\tif !parseAndExpList(reader) {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// or otherwise, lookahead is \\')\\' and it was just consumed\\n\\t}\\n\\treturn result\\n}\\n\\nfunc parseOrExpList(reader *strings.Reader) bool {\\n\\tresult := parseExpr(reader)\\n\\tif reader.Len() > 0 {\\n\\t\\tlookahead, _ := reader.ReadByte()\\n\\t\\tif lookahead == \\',\\' {\\n\\t\\t\\tif parseOrExpList(reader) {\\n\\t\\t\\t\\tresult = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\\n\\nbonus(script to generate random expression for testing purpose):\\n\\n```python\\nimport random\\n\\nfrom typing import Tuple\\n\\ndef generateRandomExpr(depth) -> str:\\n    sub, closed = generateRandomExprHelper(depth - 1)\\n    if not closed:\\n        choice = random.randint(1, 2)\\n        if choice == 1:\\n            return f\\'|({sub})\\'\\n        elif choice == 2:\\n            return f\\'&({sub})\\'\\n    return sub\\n\\ndef generateRandomExprHelper(depth) -> Tuple[str, bool]:\\n    result = \\'\\'\\n    if depth == 0:\\n        return (random.choice([\\'t\\', \\'f\\']), True)\\n\\n    size = random.randint(1, 6)\\n    while size > 0:\\n        randDepth = random.randint(0, depth - 1)\\n        sub, closed = generateRandomExprHelper(randDepth)\\n        if closed and random.randint(0, 1) == 1:\\n            sub = f\\'!({sub})\\'\\n\\n        result += sub\\n        result += \\',\\'\\n        size -= 1\\n\\n    result = result[:-1]\\n    choice = random.randint(1, 3)\\n    if choice == 1:\\n        return (f\\'|({result})\\', True)\\n    elif choice == 2:\\n        return (f\\'&({result})\\', True)\\n    return (result, False)\\n\\nif __name__ == \"__main__\":\\n    print(generateRandomExpr(1))\\n```",
                "solutionTags": [],
                "code": "```go\\n/*\\ngrammar definition:\\n\\nS-> !(S) | |(L) | &(L) | E\\nL-> S | S,L\\nE-> t | f\\n*/\\nfunc parseBoolExpr(expression string) bool {\\n\\treader := strings.NewReader(expression)\\n\\treturn parseExpr(reader)\\n}\\n\\nfunc parseExpr(reader *strings.Reader) bool {\\n\\tlookahead, _ := reader.ReadByte()\\n\\n\\tvar result bool\\n\\tif lookahead == \\'!\\' {\\n\\t\\treader.ReadByte()\\n\\t\\tresult = !parseExpr(reader)\\n\\t\\treader.ReadByte() // eliminate trailing \\')\\'\\n\\t} else if lookahead == \\'|\\' {\\n\\t\\treader.ReadByte()\\n\\t\\tresult = parseOrExpList(reader)\\n\\t} else if lookahead == \\'&\\' {\\n\\t\\treader.ReadByte()\\n\\t\\tresult = parseAndExpList(reader)\\n\\t} else if lookahead == \\'t\\' {\\n\\t\\treturn true\\n\\t} else {\\n\\t\\treturn false\\n\\t}\\n\\treturn result\\n}\\n\\nfunc parseAndExpList(reader *strings.Reader) bool {\\n\\tresult := parseExpr(reader)\\n\\tif reader.Len() > 0 {\\n\\t\\tlookahead, _ := reader.ReadByte()\\n\\t\\tif lookahead == \\',\\' {\\n\\t\\t\\tif !parseAndExpList(reader) {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// or otherwise, lookahead is \\')\\' and it was just consumed\\n\\t}\\n\\treturn result\\n}\\n\\nfunc parseOrExpList(reader *strings.Reader) bool {\\n\\tresult := parseExpr(reader)\\n\\tif reader.Len() > 0 {\\n\\t\\tlookahead, _ := reader.ReadByte()\\n\\t\\tif lookahead == \\',\\' {\\n\\t\\t\\tif parseOrExpList(reader) {\\n\\t\\t\\t\\tresult = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\n```python\\nimport random\\n\\nfrom typing import Tuple\\n\\ndef generateRandomExpr(depth) -> str:\\n    sub, closed = generateRandomExprHelper(depth - 1)\\n    if not closed:\\n        choice = random.randint(1, 2)\\n        if choice == 1:\\n            return f\\'|({sub})\\'\\n        elif choice == 2:\\n            return f\\'&({sub})\\'\\n    return sub\\n\\ndef generateRandomExprHelper(depth) -> Tuple[str, bool]:\\n    result = \\'\\'\\n    if depth == 0:\\n        return (random.choice([\\'t\\', \\'f\\']), True)\\n\\n    size = random.randint(1, 6)\\n    while size > 0:\\n        randDepth = random.randint(0, depth - 1)\\n        sub, closed = generateRandomExprHelper(randDepth)\\n        if closed and random.randint(0, 1) == 1:\\n            sub = f\\'!({sub})\\'\\n\\n        result += sub\\n        result += \\',\\'\\n        size -= 1\\n\\n    result = result[:-1]\\n    choice = random.randint(1, 3)\\n    if choice == 1:\\n        return (f\\'|({result})\\', True)\\n    elif choice == 2:\\n        return (f\\'&({result})\\', True)\\n    return (result, False)\\n\\nif __name__ == \"__main__\":\\n    print(generateRandomExpr(1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 560631,
                "title": "c-o-n-using-stacks",
                "content": "Approach:\\n**result is a boolean variable\\n1. form a **newexp** by removing those \\'*annoying*\\' commas form **exp**\\n2. create two stacks : One for operands {\\'**(**\\',\\'**t**\\',\\'**f**\\'}\\n                                  Second one for operators {\\'**!**\\',\\'**&**\\',\\'**|**\\'}\\n3. Now start traversing the newexp( : c):\\n* if( c == \\'(\\' OR \\'t\\' OR \\'f\\'), then push c -> operands\\n* if(c == \\'!\\' OR \\'&\\' OR \\'|\\'), then push c -> operators\\n* if(c == \\')\\'), then action begins :\\n* result =  operands.top\\n* while ( operands.top != \\'(\\')\\n     keep evaluating, result = result OPR operands.top\\n\\t and keep popping the operands\\n* finally when operands.top == \\'(\\', pop it out and push back the result\\n* continue this until you have evaluated newexp completely\\n* finally operands will be left with only one element, and that is our final result\\uD83D\\uDE09\\n\\n**TALK IS CHEAP, SHOW ME THE CODE**\\n\\n```\\nbool operate(bool f,bool s,char optr){\\n        return (optr==\\'&\\')?f&&s:f||s;}\\n    \\n    bool parseBoolExpr(string exp) {\\n      string newexp = \"\";  \\n       \\n        for(char c : exp){\\n           if(c != \\',\\')   newexp += c;}\\n        \\n     bool result = true;\\n     \\n     stack<char> operands,operators;\\n        \\n     char optr;\\n     \\n    int i=0; \\n    while(i < newexp.length()){\\n        \\n        if(newexp[i]==\\'!\\' || newexp[i]==\\'|\\' || newexp[i]==\\'&\\'){\\n           \\n            operators.push(newexp[i]);\\n            i++;\\n            \\n        }\\n        else if(newexp[i] == \\')\\'){\\n            \\n         optr = operators.top();operators.pop();\\n         result = operands.top()==\\'t\\'?true:false;\\n         operands.pop();\\n         \\n        if(optr != \\'!\\'){\\n             \\n           while(operands.top() != \\'(\\'){\\n             \\n             bool temp = operands.top()==\\'t\\'?true:false;\\n             operands.pop();\\n             result = operate(result,temp,optr);\\n           \\n           }\\n            \\n         }\\n         else\\n             result = !result;\\n\\n         operands.pop();\\n         operands.push(result?\\'t\\':\\'f\\');   \\n        i++;\\n        }\\n        else{    \\n            \\n            operands.push(newexp[i]);\\n            i++;\\n\\n        }\\n    }\\n        result = operands.top()==\\'t\\'?true:false;\\n        operands.pop();\\n        return result;\\n }\\n ```",
                "solutionTags": [],
                "code": "```\\nbool operate(bool f,bool s,char optr){\\n        return (optr==\\'&\\')?f&&s:f||s;}\\n    \\n    bool parseBoolExpr(string exp) {\\n      string newexp = \"\";  \\n       \\n        for(char c : exp){\\n           if(c != \\',\\')   newexp += c;}\\n        \\n     bool result = true;\\n     \\n     stack<char> operands,operators;\\n        \\n     char optr;\\n     \\n    int i=0; \\n    while(i < newexp.length()){\\n        \\n        if(newexp[i]==\\'!\\' || newexp[i]==\\'|\\' || newexp[i]==\\'&\\'){\\n           \\n            operators.push(newexp[i]);\\n            i++;\\n            \\n        }\\n        else if(newexp[i] == \\')\\'){\\n            \\n         optr = operators.top();operators.pop();\\n         result = operands.top()==\\'t\\'?true:false;\\n         operands.pop();\\n         \\n        if(optr != \\'!\\'){\\n             \\n           while(operands.top() != \\'(\\'){\\n             \\n             bool temp = operands.top()==\\'t\\'?true:false;\\n             operands.pop();\\n             result = operate(result,temp,optr);\\n           \\n           }\\n            \\n         }\\n         else\\n             result = !result;\\n\\n         operands.pop();\\n         operands.push(result?\\'t\\':\\'f\\');   \\n        i++;\\n        }\\n        else{    \\n            \\n            operands.push(newexp[i]);\\n            i++;\\n\\n        }\\n    }\\n        result = operands.top()==\\'t\\'?true:false;\\n        operands.pop();\\n        return result;\\n }\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 539849,
                "title": "python-stack-solution-one-template-to-solve-1106-1096-224",
                "content": "This problem is similar as 224 and 1096. The three solutions in fact are very similar.\\n\\nmy 1106 solution.\\n```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        def helper(pre, cur):\\n            if pre == None:\\n                pre = True if stk[-1] == \\'&\\' else False\\n            if stk[-1] == \\'&\\':\\n                pre &= cur\\n            elif stk[-1] == \\'!\\':\\n                pre = not cur\\n            else:\\n                pre |= cur\\n            return pre \\n            \\n        stk, op, pre = [], \\'\\', None\\n        for c in expression:\\n            if c in \\'&|!\\':\\n                op = c\\n            elif c == \\'(\\':\\n                stk.append(pre)\\n                stk.append(op)\\n                pre = None\\n            elif c in \\'tf\\':\\n                cur = True if c == \\'t\\' else False\\n                pre = helper(pre, cur)\\n            elif c == \\')\\':\\n                stk.pop()\\n                ppre = stk.pop()\\n                if stk:\\n                    pre = helper(ppre, pre)\\n        return pre\\n```\\n\\n224 solution\\nreference: https://leetcode.com/problems/basic-calculator/discuss/62362/JAVA-Easy-Version-To-Understand!!!!!\\n\\n```\\n\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        res = 0\\n        sign = 1\\n        stk = []\\n        i, n = 0, len(s)\\n        while i < n:\\n            if s[i].isdigit():\\n                cur = int(s[i])\\n                while i+1 < n and s[i+1].isdigit():\\n                    cur = cur*10 + int(s[i+1])\\n                    i += 1\\n                res += cur*sign\\n            elif s[i] == \\'+\\':\\n                sign = 1\\n            elif s[i] == \\'-\\':\\n                sign = -1\\n            elif s[i] == \\'(\\':\\n                stk.append(res)\\n                stk.append(sign)\\n                sign = 1\\n                res = 0\\n            elif s[i] == \\')\\':\\n                res = res*stk.pop() + stk.pop()\\n            i += 1\\n        return res\\n```\\n\\n1096 solution. \\nreference: https://leetcode.com/problems/brace-expansion-ii/discuss/322002/Python-concise-stack-solution\\n```\\nclass Solution:\\n    def braceExpansionII(self, expression: str) -> List[str]:\\n        stk, pre, cur = [], [], [\\'\\']\\n        for v in expression:\\n            if v == \\'{\\':\\n                stk.append(pre)\\n                stk.append(cur)\\n                pre, cur = [], [\\'\\']\\n            elif v.isalpha():\\n                cur = [c+v for c in cur]\\n            elif v == \\'}\\':\\n                p_cur= stk.pop()\\n                p_pre = stk.pop()\\n                cur = [p+c for c in pre+cur for p in p_cur]\\n                pre = p_pre\\n            else:\\n                pre += cur\\n                cur = [\\'\\']\\n        return sorted(set(pre+cur))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        def helper(pre, cur):\\n            if pre == None:\\n                pre = True if stk[-1] == \\'&\\' else False\\n            if stk[-1] == \\'&\\':\\n                pre &= cur\\n            elif stk[-1] == \\'!\\':\\n                pre = not cur\\n            else:\\n                pre |= cur\\n            return pre \\n            \\n        stk, op, pre = [], \\'\\', None\\n        for c in expression:\\n            if c in \\'&|!\\':\\n                op = c\\n            elif c == \\'(\\':\\n                stk.append(pre)\\n                stk.append(op)\\n                pre = None\\n            elif c in \\'tf\\':\\n                cur = True if c == \\'t\\' else False\\n                pre = helper(pre, cur)\\n            elif c == \\')\\':\\n                stk.pop()\\n                ppre = stk.pop()\\n                if stk:\\n                    pre = helper(ppre, pre)\\n        return pre\\n```\n```\\n\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        res = 0\\n        sign = 1\\n        stk = []\\n        i, n = 0, len(s)\\n        while i < n:\\n            if s[i].isdigit():\\n                cur = int(s[i])\\n                while i+1 < n and s[i+1].isdigit():\\n                    cur = cur*10 + int(s[i+1])\\n                    i += 1\\n                res += cur*sign\\n            elif s[i] == \\'+\\':\\n                sign = 1\\n            elif s[i] == \\'-\\':\\n                sign = -1\\n            elif s[i] == \\'(\\':\\n                stk.append(res)\\n                stk.append(sign)\\n                sign = 1\\n                res = 0\\n            elif s[i] == \\')\\':\\n                res = res*stk.pop() + stk.pop()\\n            i += 1\\n        return res\\n```\n```\\nclass Solution:\\n    def braceExpansionII(self, expression: str) -> List[str]:\\n        stk, pre, cur = [], [], [\\'\\']\\n        for v in expression:\\n            if v == \\'{\\':\\n                stk.append(pre)\\n                stk.append(cur)\\n                pre, cur = [], [\\'\\']\\n            elif v.isalpha():\\n                cur = [c+v for c in cur]\\n            elif v == \\'}\\':\\n                p_cur= stk.pop()\\n                p_pre = stk.pop()\\n                cur = [p+c for c in pre+cur for p in p_cur]\\n                pre = p_pre\\n            else:\\n                pre += cur\\n                cur = [\\'\\']\\n        return sorted(set(pre+cur))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513761,
                "title": "scala-10-lines-pattern-based-solution-beats-100",
                "content": "```\\n  def parseBoolExpr(expression: String): Boolean = ((true, Seq.empty[Char], -1) /: expression){\\n    case ((_, st, -1), op@(\\'!\\' | \\'&\\' | \\'|\\')) => (true, op +: st, -1) // add a new operator to the stack\\n    case ((_, st, -1), c@(\\'t\\' | \\'f\\')) => (c == \\'t\\', st, -1) // true of false\\n    case ((false, st@(\\'&\\' +: _), -1), \\',\\') => (false, st, 0) // we are inside of & and we got false for the previous argument, so we just going to skip the rest, so set the nest level to 0\\n    case ((true, st@(\\'|\\' +: _), -1), \\',\\') => (true, st, 0) // we are inside of | and we got true for the previous argument\\n    case (s@(_, _, -1), \\'(\\') => s // we can ignore (, when we are not in the skipping mode (the nest level is -1)\\n    case ((cv, \\'!\\' +: st, -1), \\')\\') => (!cv, st, -1)  // we accomplished !, so we are going to return reversed result\\n    case ((cv, _ +: st, 0 | -1), \\')\\') => (cv, st, -1) // pop the stack, when we encounter )\\n    case ((cv, st, cn), \\'(\\') => (cv, st, cn + 1) // we are skipping the rest of arguments inside & or |, so just increase the nest level\\n    case ((cv, st, cn), \\')\\') => (cv, st, cn - 1) // we are skipping the rest of arguments inside & or |, so just decrease the nest level\\n    case (s, _) => s // ignore all other cases\\n  }._1\\n```",
                "solutionTags": [],
                "code": "```\\n  def parseBoolExpr(expression: String): Boolean = ((true, Seq.empty[Char], -1) /: expression){\\n    case ((_, st, -1), op@(\\'!\\' | \\'&\\' | \\'|\\')) => (true, op +: st, -1) // add a new operator to the stack\\n    case ((_, st, -1), c@(\\'t\\' | \\'f\\')) => (c == \\'t\\', st, -1) // true of false\\n    case ((false, st@(\\'&\\' +: _), -1), \\',\\') => (false, st, 0) // we are inside of & and we got false for the previous argument, so we just going to skip the rest, so set the nest level to 0\\n    case ((true, st@(\\'|\\' +: _), -1), \\',\\') => (true, st, 0) // we are inside of | and we got true for the previous argument\\n    case (s@(_, _, -1), \\'(\\') => s // we can ignore (, when we are not in the skipping mode (the nest level is -1)\\n    case ((cv, \\'!\\' +: st, -1), \\')\\') => (!cv, st, -1)  // we accomplished !, so we are going to return reversed result\\n    case ((cv, _ +: st, 0 | -1), \\')\\') => (cv, st, -1) // pop the stack, when we encounter )\\n    case ((cv, st, cn), \\'(\\') => (cv, st, cn + 1) // we are skipping the rest of arguments inside & or |, so just increase the nest level\\n    case ((cv, st, cn), \\')\\') => (cv, st, cn - 1) // we are skipping the rest of arguments inside & or |, so just decrease the nest level\\n    case (s, _) => s // ignore all other cases\\n  }._1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 496457,
                "title": "python-3-solution-using-classes-and-2-stacks-beats-100-memory-o-n",
                "content": "The basic idea is to add an expression to a stack and when a `)` is found pop the expression, evaluate it and append it again. Whatever is remaining in the stack is the final solution.\\n\\n```python\\nclass Expr:\\n\\n\\tdef __init__(self, val):\\n\\t\\tself.val = val\\n\\nclass AndExpr(Expr):\\n\\n\\tdef eval(self):\\n\\t\\treturn all(self.val)\\n\\nclass OrExpr(Expr):\\n\\t\\n\\tdef eval(self):\\n\\t\\treturn any(self.val)\\n\\nclass NotExpr(Expr):\\n\\n\\tdef eval(self):\\n\\t\\treturn not self.val[0]\\n\\nmapper = {\\n    \\'!\\': NotExpr,\\n    \\'&\\': AndExpr,\\n    \\'|\\': OrExpr,\\n}\\n\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        if len(expression) == 1:\\n            return expression == \\'t\\'\\n\\n        parsed = [[]]\\n        stack = []\\n        \\n        for i, letter in enumerate(expression):\\n\\n            if letter in mapper:\\n                stack.append(mapper[letter])\\n                parsed.append([])\\n            elif letter in (\\'t\\', \\'f\\'):\\n                parsed[-1].append(letter == \\'t\\')\\n            elif letter == \\')\\':\\n                expr = stack.pop()\\n                values = parsed.pop()\\n                instance = expr(values)\\n                parsed[-1].append(instance.eval())\\n\\n        return parsed[-1][-1]\\n````",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Expr:\\n\\n\\tdef __init__(self, val):\\n\\t\\tself.val = val\\n\\nclass AndExpr(Expr):\\n\\n\\tdef eval(self):\\n\\t\\treturn all(self.val)\\n\\nclass OrExpr(Expr):\\n\\t\\n\\tdef eval(self):\\n\\t\\treturn any(self.val)\\n\\nclass NotExpr(Expr):\\n\\n\\tdef eval(self):\\n\\t\\treturn not self.val[0]\\n\\nmapper = {\\n    \\'!\\': NotExpr,\\n    \\'&\\': AndExpr,\\n    \\'|\\': OrExpr,\\n}\\n\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        if len(expression) == 1:\\n            return expression == \\'t\\'\\n\\n        parsed = [[]]\\n        stack = []\\n        \\n        for i, letter in enumerate(expression):\\n\\n            if letter in mapper:\\n                stack.append(mapper[letter])\\n                parsed.append([])\\n            elif letter in (\\'t\\', \\'f\\'):\\n                parsed[-1].append(letter == \\'t\\')\\n            elif letter == \\')\\':\\n                expr = stack.pop()\\n                values = parsed.pop()\\n                instance = expr(values)\\n                parsed[-1].append(instance.eval())\\n\\n        return parsed[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466489,
                "title": "dijkstra-s-two-stack-algorithm",
                "content": "I have no idea why[ **Dijkstra\\'s Two-Stack Algorithm**](http://www.wisenheimerbrainstorm.com/archive/algorithms/dijkstra-s-two-stack-algorithm) doesn\\'t appear more often on this forum.\\n\\nWe split the tokens into 2 categories: we treat `t`, `f`, `(` and `)` as **operands** and `!`, `&` and `|` as **operators**. We use a stack for each category, so that when we see an operator we push it onto the operators stack and when we see an operand we push it onto the operators stack, **EXCEPT** when we see a closing paranthesys. A `)` means **take all the operators untill you find it\\'s matching `(`**, **apply the top operand to them** and **put the resulting value back onto the operands stack**. The code features the details I left out.\\n\\nAssuming a correct expression is passed, we will always end up with 2 stacks consisting of **no operators** and **a single operand**, the final result.\\n\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> operators = new Stack<>();\\n        Stack<Character> operands = new Stack<>();\\n        \\n        for (char c: expression.toCharArray()) {\\n            if (c == \\'t\\' || c == \\'f\\' || c == \\'(\\') {\\n                operands.push(c);\\n            } else if (c == \\'!\\' || c == \\'&\\' || c == \\'|\\') {\\n                operators.push(c);\\n            } else if (c == \\')\\') {\\n                char operator = operators.pop();\\n                boolean result = operands.pop() == \\'t\\' ? true : false;\\n                if (operator == \\'!\\') {\\n                    result = !result;\\n                }\\n                \\n                while (operands.peek() != \\'(\\') {\\n                    boolean operand = operands.pop() == \\'t\\' ? true : false;\\n                    if (operator == \\'&\\') {\\n                        result = result && operand;\\n                    } else {\\n                        result = result || operand;\\n                    }\\n                }\\n                operands.pop();\\n                \\n                operands.push(result == true ? \\'t\\' : \\'f\\');\\n            }\\n        }\\n        \\n        return operands.peek() == \\'t\\' ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> operators = new Stack<>();\\n        Stack<Character> operands = new Stack<>();\\n        \\n        for (char c: expression.toCharArray()) {\\n            if (c == \\'t\\' || c == \\'f\\' || c == \\'(\\') {\\n                operands.push(c);\\n            } else if (c == \\'!\\' || c == \\'&\\' || c == \\'|\\') {\\n                operators.push(c);\\n            } else if (c == \\')\\') {\\n                char operator = operators.pop();\\n                boolean result = operands.pop() == \\'t\\' ? true : false;\\n                if (operator == \\'!\\') {\\n                    result = !result;\\n                }\\n                \\n                while (operands.peek() != \\'(\\') {\\n                    boolean operand = operands.pop() == \\'t\\' ? true : false;\\n                    if (operator == \\'&\\') {\\n                        result = result && operand;\\n                    } else {\\n                        result = result || operand;\\n                    }\\n                }\\n                operands.pop();\\n                \\n                operands.push(result == true ? \\'t\\' : \\'f\\');\\n            }\\n        }\\n        \\n        return operands.peek() == \\'t\\' ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 461236,
                "title": "c-solution",
                "content": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\n\\npublic class Node {\\n    public Node Parent { get; set; }\\n    public List<Node> Nodes { get; } = new List<Node>();\\n    public char Val { get; set; }\\n\\n    public bool GetResult() {\\n        if (Val == \\'|\\') return Or(Nodes.Select(x => x.GetResult()));\\n        if (Val == \\'&\\') return And(Nodes.Select(x => x.GetResult()));\\n        if (Val == \\'!\\') return Not(Nodes.First().GetResult());\\n        return Val == \\'t\\';\\n    }\\n\\n    private static bool Not(bool x) => !x;\\n\\n    private static bool Or(IEnumerable<bool> xs)\\n        => xs.Aggregate(false, (x, y) => x || y);\\n\\n    private static bool And(IEnumerable<bool> xs)\\n        => xs.Aggregate(true, (x, y) => x && y);\\n}\\n\\npublic class Solution {\\n    public bool ParseBoolExpr(string expression) {\\n        Node curr = null;\\n\\n        foreach (var c in expression.ToCharArray()) {\\n            if (\"|&!tf\".Contains(c)) {\\n                var node = new Node { Val = c, Parent = curr };\\n                curr?.Nodes.Add(node);\\n                curr = node;\\n            }\\n            else if (\",)\".Contains(c)) {\\n                curr = curr?.Parent;\\n            }\\n        }\\n\\n        return curr?.GetResult() ?? throw new Exception();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\n\\npublic class Node {\\n    public Node Parent { get; set; }\\n    public List<Node> Nodes { get; } = new List<Node>();\\n    public char Val { get; set; }\\n\\n    public bool GetResult() {\\n        if (Val == \\'|\\') return Or(Nodes.Select(x => x.GetResult()));\\n        if (Val == \\'&\\') return And(Nodes.Select(x => x.GetResult()));\\n        if (Val == \\'!\\') return Not(Nodes.First().GetResult());\\n        return Val == \\'t\\';\\n    }\\n\\n    private static bool Not(bool x) => !x;\\n\\n    private static bool Or(IEnumerable<bool> xs)\\n        => xs.Aggregate(false, (x, y) => x || y);\\n\\n    private static bool And(IEnumerable<bool> xs)\\n        => xs.Aggregate(true, (x, y) => x && y);\\n}\\n\\npublic class Solution {\\n    public bool ParseBoolExpr(string expression) {\\n        Node curr = null;\\n\\n        foreach (var c in expression.ToCharArray()) {\\n            if (\"|&!tf\".Contains(c)) {\\n                var node = new Node { Val = c, Parent = curr };\\n                curr?.Nodes.Add(node);\\n                curr = node;\\n            }\\n            else if (\",)\".Contains(c)) {\\n                curr = curr?.Parent;\\n            }\\n        }\\n\\n        return curr?.GetResult() ?? throw new Exception();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428163,
                "title": "short-python-solution-with-commentary-for-every-line",
                "content": "\\n```\\nclass Solution(object):\\n```\\nFrom the starting code provided by leetcode.\\n```\\n    def parseBoolExpr(self, expr):\\n```\\nI shortened the argument \"expression\" to just \"expr\".  I originally used it more often.\\n```\\n        func,ops,args = {\"&\": all, \"|\":any, \"!\":lambda x:not x[0]},[all],[[]]\\n```\\nI\\'m using aggregate assignment for 3 varaibles.\\n```ops``` holds a stack of operators waiting to evaluate their arguments.  Note that \"&( x )\" gives you back x.  Having a default here let\\'s me handle expressions with no operators.  In theory those are legal (```\"t\", evaluating to True;```), but I was surprised to learn they didn\\'t test for it. My code handles that case.\\n```args``` holds True and False values which are either directly specified, or the result of an operator.\\n```func``` is a list of allowed functions.  Python\\'s any() returns True if any of it\\'s arguments are True, which matches the behavior of the \"|\" operator in this problem.  The same for all() and \"&\".  I implemented \"!\" with a lambda that assumes there\\'s just one argument.\\n```\\n        for ch in expr:\\n```\\nMy first attempt was too complicated, with skipping around and short-circuit evaluation.  I need to avoid \"pre-mature optimizartion\" and start simple.  So here I will evaluate one character at a time.\\n```\\n            if ch in func:\\n```\\nWhen used on a dictionary, Python\\'s ```in``` operator acts on the dictionary keys.  If the current letter is any of the functions (\"!&}\"), then this ```if``` statetment will evaluate to True.\\n```\\n                ops.append(func[ch])\\n```\\nI append the function, not the character.  Functions and built-ins are objects that can be stored in a list.  Later, I\\'m going to call this function directly, which make look a little weird.\\n```\\n                args.append([])\\n```\\nI picked operators that work on a list of arguments.  The list gets fed to the current operator, so a new operator needs a new list to hold it\\'s arguments.\\n```\\n            elif ch in \"tf\":\\n```\\nI suspect this is faster than two separate ```if``` statements.  I catch \"t\" or \"f\" with one line.\\n```\\n                args[-1].append( ch == \"t\" )\\n```\\nI\\'m translating ch into True/False.  \"t\"==\"t\" gives me True, and \"f\"==\"t\" gives me False.  Every argument gets appended to the list.\\n```\\n            elif ch == \")\":\\n```\\nI actually ignore ( and , since they don\\'t change anything.  But \")\" is very important.\\n```\\n                args[-2].append(ops.pop()(args.pop()))\\n```\\nTo quote the matrix, this may feel a little weird.  I should explain each part in turn:\\n```args.pop()``` takes the current list of arguments, which I\\'ve been appending to using ```args[1].append()```.  I need to turn the entire list into one True or False value, so I pop() the list since it\\'s not needed anymore.\\n```ops.pop()``` takes the current operator off the stack - but it also calls the operator.\\n\\nIf you pretend ```ops.pop()``` is op, and allow ```args.pop()``` is arg, you will see this expression:\\n``` op ( arg ) ```\\nI\\'m actually calling the operator (any, all, or lambda) on the list of arguments.  That will result in a True False value... bu where do I put that value?\\n```args[-2].append(...)``` is where I place the result of the nested operator.  Once it returns True or False, that\\'s just another True/False value for the outer operator to process.  Note that ```args[-2]``` gets evaluated first, refering to the prior operator.  And then ```args.pop()``` removes args[-1] from the stack of arguments.\\n```\\n        return args[0][0]\\n```\\nI have a top-level dummy operator of \"all\", which should have just one boolean to evaluate.  The first operator in the list, in effect, is called by this dummy top-level operator.  Since ```all( x )``` is the same as x, I shouldn\\'t change the result of the boolean calclation.\\n\\nThe first argument is args[0], and there should be just one thing in the list, so args[0][0].\\n\\nIf explaining it line-by-line still left you confused, please quote the line and ask me questions about it.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n```\n```\\n    def parseBoolExpr(self, expr):\\n```\n```\\n        func,ops,args = {\"&\": all, \"|\":any, \"!\":lambda x:not x[0]},[all],[[]]\\n```\n```ops```\n```\"t\", evaluating to True;```\n```args```\n```func```\n```\\n        for ch in expr:\\n```\n```\\n            if ch in func:\\n```\n```in```\n```if```\n```\\n                ops.append(func[ch])\\n```\n```\\n                args.append([])\\n```\n```\\n            elif ch in \"tf\":\\n```\n```if```\n```\\n                args[-1].append( ch == \"t\" )\\n```\n```\\n            elif ch == \")\":\\n```\n```\\n                args[-2].append(ops.pop()(args.pop()))\\n```\n```args.pop()```\n```args[1].append()```\n```ops.pop()```\n```ops.pop()```\n```args.pop()```\n``` op ( arg ) ```\n```args[-2].append(...)```\n```args[-2]```\n```args.pop()```\n```\\n        return args[0][0]\\n```\n```all( x )```",
                "codeTag": "Java"
            },
            {
                "id": 420775,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String str) {\\n     \\n        Stack<Character> s = new Stack<>();   \\n        HashSet<Character> hash = new HashSet<>();\\n        \\n        int i=0;\\n        \\n        while(i<str.length()){\\n            if(str.charAt(i)==\\')\\'){\\n                hash = new HashSet<>(); \\n                while(s.peek()!=\\'(\\'){\\n                    hash.add(s.pop());\\n                }\\n                s.pop();\\n                char op = s.pop();\\n                if(op == \\'&\\')\\n                    s.push( hash.contains(\\'f\\') ? \\'f\\' : \\'t\\' );\\n                else if(op == \\'|\\')\\n                    s.push( hash.contains(\\'t\\') ? \\'t\\' : \\'f\\' );\\n                else if(op == \\'!\\')\\n                    s.push( hash.contains(\\'f\\') ? \\'t\\' : \\'f\\');       \\n            }\\n            else if(str.charAt(i) != \\',\\'){\\n                s.push(str.charAt(i));\\n            }\\n            i++;\\n        }\\n        return s.pop() == \\'t\\' ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String str) {\\n     \\n        Stack<Character> s = new Stack<>();   \\n        HashSet<Character> hash = new HashSet<>();\\n        \\n        int i=0;\\n        \\n        while(i<str.length()){\\n            if(str.charAt(i)==\\')\\'){\\n                hash = new HashSet<>(); \\n                while(s.peek()!=\\'(\\'){\\n                    hash.add(s.pop());\\n                }\\n                s.pop();\\n                char op = s.pop();\\n                if(op == \\'&\\')\\n                    s.push( hash.contains(\\'f\\') ? \\'f\\' : \\'t\\' );\\n                else if(op == \\'|\\')\\n                    s.push( hash.contains(\\'t\\') ? \\'t\\' : \\'f\\' );\\n                else if(op == \\'!\\')\\n                    s.push( hash.contains(\\'f\\') ? \\'t\\' : \\'f\\');       \\n            }\\n            else if(str.charAt(i) != \\',\\'){\\n                s.push(str.charAt(i));\\n            }\\n            i++;\\n        }\\n        return s.pop() == \\'t\\' ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391064,
                "title": "c-elegant-recursive-solution",
                "content": "\\n    string endChars = \")}\";\\n    string ops = \"|!&\";\\n    \\n    \\n    bool solve(string&s, int &idx){\\n        char op = s[idx];\\n        bool res = op == \\'|\\' ? false : true;\\n        idx++;\\n        \\n        while(endChars.find(s[idx]) == -1){\\n            if(ops.find(s[idx]) != -1){\\n                bool c = solve(s, idx);\\n                \\n                if (op == \\'&\\') res &= c;\\n\\t\\t\\t\\tif (op == \\'|\\') res |= c;\\n\\t\\t\\t\\tif (op == \\'!\\') res = !c;\\n                \\n            }else if(s[idx] == \\'(\\' || s[idx] == \\'{\\' || s[idx] == \\',\\'){\\n                idx++;\\n                continue;\\n            }else{\\n                bool c = s[idx] == \\'t\\' ? true : false;\\n                if (op == \\'&\\') res &= c;\\n\\t\\t\\t\\tif (op == \\'|\\') res |= c;\\n\\t\\t\\t\\tif (op == \\'!\\') res = !c;\\n            }    \\n            idx++;\\n        }\\n        return res;\\n    }\\n    \\n    \\n    bool parseBoolExpr(string expression) {\\n        int i =0;\\n        expression = \"!(\" + expression + \")\";\\n        return !solve(expression, i);\\n       \\n    }\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "\\n    string endChars = \")}\";\\n    string ops = \"|!&\";\\n    \\n    \\n    bool solve(string&s, int &idx){\\n        char op = s[idx];\\n        bool res = op == \\'|\\' ? false : true;\\n        idx++;\\n        \\n        while(endChars.find(s[idx]) == -1){\\n            if(ops.find(s[idx]) != -1){\\n                bool c = solve(s, idx);\\n                \\n                if (op == \\'&\\') res &= c;\\n\\t\\t\\t\\tif (op == \\'|\\') res |= c;\\n\\t\\t\\t\\tif (op == \\'!\\') res = !c;\\n                \\n            }else if(s[idx] == \\'(\\' || s[idx] == \\'{\\' || s[idx] == \\',\\'){\\n                idx++;\\n                continue;\\n            }else{\\n                bool c = s[idx] == \\'t\\' ? true : false;\\n                if (op == \\'&\\') res &= c;\\n\\t\\t\\t\\tif (op == \\'|\\') res |= c;\\n\\t\\t\\t\\tif (op == \\'!\\') res = !c;\\n            }    \\n            idx++;\\n        }\\n        return res;\\n    }\\n    \\n    \\n    bool parseBoolExpr(string expression) {\\n        int i =0;\\n        expression = \"!(\" + expression + \")\";\\n        return !solve(expression, i);\\n       \\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 378304,
                "title": "python-clear-solution-with-regex-99-65-100",
                "content": "```\\nimport re\\n\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        pattern = \\'(\\\\&|\\\\||\\\\!)\\\\(((t|f)(,(t|f))*)\\\\)\\'\\n        while True:\\n            m = re.search(pattern, expression)\\n            if m is None:\\n                break\\n            if m.group(1) == \\'&\\':\\n                rep = \\'f\\' if \\'f\\' in m.group(2) else \\'t\\'\\n            elif m.group(1) == \\'|\\':\\n                rep = \\'t\\' if \\'t\\' in m.group(2) else \\'f\\'\\n            else:\\n                rep = \\'t\\' if m.group(2) == \\'f\\' else \\'f\\'\\n            expression = expression.replace(m.group(0), rep)\\n        return True if expression == \\'t\\' else False\\n```",
                "solutionTags": [],
                "code": "```\\nimport re\\n\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        pattern = \\'(\\\\&|\\\\||\\\\!)\\\\(((t|f)(,(t|f))*)\\\\)\\'\\n        while True:\\n            m = re.search(pattern, expression)\\n            if m is None:\\n                break\\n            if m.group(1) == \\'&\\':\\n                rep = \\'f\\' if \\'f\\' in m.group(2) else \\'t\\'\\n            elif m.group(1) == \\'|\\':\\n                rep = \\'t\\' if \\'t\\' in m.group(2) else \\'f\\'\\n            else:\\n                rep = \\'t\\' if m.group(2) == \\'f\\' else \\'f\\'\\n            expression = expression.replace(m.group(0), rep)\\n        return True if expression == \\'t\\' else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 367580,
                "title": "ll-1-recursive-parser-in-python",
                "content": "The parser decides what to do by looking at the next character. The current index gets passed into and out of the functions to avoid string slicing. The value of `i` after parsing indicates how much of the string has been consumed so far. I\\'ve tried to provide helpful error messages in the event that an invalid expression is entered.\\n\\n```python\\nclass Solution:\\n\\n    def parseBoolExpr(self, expression):\\n        result, i = self.parse_expression(expression)\\n        if i == len(expression):\\n            return result\\n        else:\\n            raise ValueError(\\'not all of the expression was parsed\\')\\n\\n    def parse_expression(self, expr, i=0):\\n        if expr[i] == \\'t\\':\\n            return (True, i+1)\\n        elif expr[i] == \\'f\\':\\n            return (False, i+1)\\n        elif expr[i] == \\'!\\':\\n            subexprs, i = self.parse_sequence(expr, i+1)\\n            if len(subexprs) != 1:\\n                raise ValueError(f\"expected exactly one sub-expression in negation but got {len(subexprs)}\")\\n            return (not subexprs[0], i)\\n        elif expr[i] == \\'&\\':\\n            conjuncts, i = self.parse_sequence(expr, i+1)\\n            return all(conjuncts), i\\n        elif expr[i] == \\'|\\':\\n            disjuncts, i = self.parse_sequence(expr, i+1)\\n            return any(disjuncts), i\\n        else:\\n            raise ValueError(\\'invalid expression\\')\\n    \\n    def parse_sequence(self, expr, i=0):\\n        if expr[i] != \\'(\\':\\n            raise ValueError(f\"expected \\'(\\' at index {i} but got {expr[i]!r}\")\\n\\n        first, i = self.parse_expression(expr, i+1)\\n        results = [first]\\n\\n        while expr[i] == \\',\\':\\n            result, i = self.parse_expression(expr, i+1)\\n            results.append(result)\\n        \\n        if expr[i] != \\')\\':\\n            raise ValueError(f\"expected \\')\\' at index {i} but got {expr[i]!r}\")\\n\\n        return results, i+1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n\\n    def parseBoolExpr(self, expression):\\n        result, i = self.parse_expression(expression)\\n        if i == len(expression):\\n            return result\\n        else:\\n            raise ValueError(\\'not all of the expression was parsed\\')\\n\\n    def parse_expression(self, expr, i=0):\\n        if expr[i] == \\'t\\':\\n            return (True, i+1)\\n        elif expr[i] == \\'f\\':\\n            return (False, i+1)\\n        elif expr[i] == \\'!\\':\\n            subexprs, i = self.parse_sequence(expr, i+1)\\n            if len(subexprs) != 1:\\n                raise ValueError(f\"expected exactly one sub-expression in negation but got {len(subexprs)}\")\\n            return (not subexprs[0], i)\\n        elif expr[i] == \\'&\\':\\n            conjuncts, i = self.parse_sequence(expr, i+1)\\n            return all(conjuncts), i\\n        elif expr[i] == \\'|\\':\\n            disjuncts, i = self.parse_sequence(expr, i+1)\\n            return any(disjuncts), i\\n        else:\\n            raise ValueError(\\'invalid expression\\')\\n    \\n    def parse_sequence(self, expr, i=0):\\n        if expr[i] != \\'(\\':\\n            raise ValueError(f\"expected \\'(\\' at index {i} but got {expr[i]!r}\")\\n\\n        first, i = self.parse_expression(expr, i+1)\\n        results = [first]\\n\\n        while expr[i] == \\',\\':\\n            result, i = self.parse_expression(expr, i+1)\\n            results.append(result)\\n        \\n        if expr[i] != \\')\\':\\n            raise ValueError(f\"expected \\')\\' at index {i} but got {expr[i]!r}\")\\n\\n        return results, i+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342757,
                "title": "short-parsing-on-stack-c",
                "content": "```C++\\nclass Solution {\\npublic:\\n    char compute(char op, vector<bool> const& v) {\\n        //assert(v.size() != 0);\\n        if (op == \\'!\\') return !v.front() ? \\'t\\' : \\'f\\';\\n        bool res = op == \\'&\\';\\n        for (bool o : v) {\\n            if (op == \\'&\\' && o == false) {\\n                res = false;\\n                break;\\n            } else if (op == \\'|\\' && o == true) {\\n                res = true;\\n                break;\\n            }\\n        }\\n        return res ? \\'t\\' : \\'f\\';\\n    }\\n    \\n    bool isop(char c) {\\n        return c == \\'&\\' || c == \\'|\\' || c == \\'!\\';\\n    }\\n    \\n    bool parseBoolExpr(string expression) {\\n        stack<char> st; // can have t,f,operation\\n        for (char c : expression) {\\n            if (isop(c) || c == \\'t\\' || c == \\'f\\')\\n                st.push(c);\\n            if (c == \\')\\') {\\n                vector<bool> operands;\\n                while (!isop(st.top())) {\\n                    operands.push_back(st.top() == \\'f\\' ? false : true);\\n                    st.pop();\\n                }\\n                char op = st.top();\\n                st.pop();\\n                st.push(compute(op, operands));\\n                \\n            }\\n            // ( and , are skipped\\n        }\\n        return st.top() == \\'t\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    char compute(char op, vector<bool> const& v) {\\n        //assert(v.size() != 0);\\n        if (op == \\'!\\') return !v.front() ? \\'t\\' : \\'f\\';\\n        bool res = op == \\'&\\';\\n        for (bool o : v) {\\n            if (op == \\'&\\' && o == false) {\\n                res = false;\\n                break;\\n            } else if (op == \\'|\\' && o == true) {\\n                res = true;\\n                break;\\n            }\\n        }\\n        return res ? \\'t\\' : \\'f\\';\\n    }\\n    \\n    bool isop(char c) {\\n        return c == \\'&\\' || c == \\'|\\' || c == \\'!\\';\\n    }\\n    \\n    bool parseBoolExpr(string expression) {\\n        stack<char> st; // can have t,f,operation\\n        for (char c : expression) {\\n            if (isop(c) || c == \\'t\\' || c == \\'f\\')\\n                st.push(c);\\n            if (c == \\')\\') {\\n                vector<bool> operands;\\n                while (!isop(st.top())) {\\n                    operands.push_back(st.top() == \\'f\\' ? false : true);\\n                    st.pop();\\n                }\\n                char op = st.top();\\n                st.pop();\\n                st.push(compute(op, operands));\\n                \\n            }\\n            // ( and , are skipped\\n        }\\n        return st.top() == \\'t\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328397,
                "title": "java-o-n-recursive-way-without-substring-15-line",
                "content": "the thought behind it is same as the discuss i write here https://leetcode.com/discuss/topic/328064\\n```\\nint i = 0;\\npublic boolean parseBoolExpr(String expression) {\\n\\treturn help(expression.toCharArray());\\n}\\nboolean help(char[] cs) {\\n\\tif (cs[i] == \\'t\\' || cs[i] == \\'f\\') {\\n\\t\\treturn cs[i++] == \\'t\\';\\n\\t}\\n\\tchar tag = cs[i++];\\n\\tSet<Boolean> bs = new HashSet<>();\\n\\tassert(cs[i++] == \\'(\\');\\n\\twhile (cs[i] != \\')\\') {\\n\\t\\tbs.add(help(cs));\\n\\t\\tif (cs[i] == \\',\\') i++;\\n\\t}\\n\\tassert(cs[i++] == \\')\\');\\n\\tif (tag == \\'!\\') return bs.contains(false);\\n\\treturn tag == \\'|\\' ? bs.contains(true) : !bs.contains(false);\\n}\\n```\\n\\niterative way\\n```\\npublic boolean parseBoolExpr(String exp) {\\n        Deque<Character> st = new ArrayDeque<>(exp.length());\\n        char[] cs = exp.toCharArray();\\n        for (int i = 0; i < cs.length; i++) {\\n            if (cs[i] == \\')\\') {\\n                Set<Character> bs = new HashSet<>();\\n                while (st.peek() != \\'(\\') {\\n                    bs.add(st.pop());\\n                }\\n                st.pop();\\n                char tag = st.pop();\\n                if (tag == \\'!\\') st.push(bs.contains(\\'f\\') ? \\'t\\' : \\'f\\');\\n                else {\\n                    boolean res = tag == \\'|\\' ? bs.contains(\\'t\\') : !bs.contains(\\'f\\');\\n                    st.push(res ? \\'t\\' : \\'f\\');\\n                }\\n            } else if (cs[i] != \\',\\') {\\n                st.push(cs[i]);\\n            }\\n        }\\n        return st.peek() == \\'t\\';\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint i = 0;\\npublic boolean parseBoolExpr(String expression) {\\n\\treturn help(expression.toCharArray());\\n}\\nboolean help(char[] cs) {\\n\\tif (cs[i] == \\'t\\' || cs[i] == \\'f\\') {\\n\\t\\treturn cs[i++] == \\'t\\';\\n\\t}\\n\\tchar tag = cs[i++];\\n\\tSet<Boolean> bs = new HashSet<>();\\n\\tassert(cs[i++] == \\'(\\');\\n\\twhile (cs[i] != \\')\\') {\\n\\t\\tbs.add(help(cs));\\n\\t\\tif (cs[i] == \\',\\') i++;\\n\\t}\\n\\tassert(cs[i++] == \\')\\');\\n\\tif (tag == \\'!\\') return bs.contains(false);\\n\\treturn tag == \\'|\\' ? bs.contains(true) : !bs.contains(false);\\n}\\n```\n```\\npublic boolean parseBoolExpr(String exp) {\\n        Deque<Character> st = new ArrayDeque<>(exp.length());\\n        char[] cs = exp.toCharArray();\\n        for (int i = 0; i < cs.length; i++) {\\n            if (cs[i] == \\')\\') {\\n                Set<Character> bs = new HashSet<>();\\n                while (st.peek() != \\'(\\') {\\n                    bs.add(st.pop());\\n                }\\n                st.pop();\\n                char tag = st.pop();\\n                if (tag == \\'!\\') st.push(bs.contains(\\'f\\') ? \\'t\\' : \\'f\\');\\n                else {\\n                    boolean res = tag == \\'|\\' ? bs.contains(\\'t\\') : !bs.contains(\\'f\\');\\n                    st.push(res ? \\'t\\' : \\'f\\');\\n                }\\n            } else if (cs[i] != \\',\\') {\\n                st.push(cs[i]);\\n            }\\n        }\\n        return st.peek() == \\'t\\';\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 328392,
                "title": "rust-0ms-faster-than-100",
                "content": "```rust\\n/// We can solve this problem by implementing our own stack and treat (&, |, !) as a function calls\\n/// and (t, f) as params to these functions.\\n///\\n/// For example here is a simple Expression representing `not` function\\n/// input: \"!(f)\"\\n/// the parser will create an empty stack at first for this function\\n/// ```t\\n/// +---------+\\n/// |         |\\n/// +---------+\\n/// ```\\n/// after that the parser will match every `char` in the expression and try to push that `Expr`\\n/// in the stack\\n///\\n/// We have two type of `Expr` represented by the `Expr` enum.\\n/// so the parser will at first hit the `!` char, it will push `Expr::Func(not)` to the stack\\n///\\n/// ```t\\n/// +-----------------+\\n/// | Expr::Func(not) |\\n/// +-----------------+\\n/// ```\\n/// next it would match the `(` char, we ignore that, then matching the `f` char, it will map\\n/// that to `Expr::Const(false)` and push it to the stack\\n/// ```t\\n/// +--------------------+\\n/// |   Expr::Func(not)  |\\n/// +--------------------+\\n/// | Expr::Const(false) |\\n/// +--------------------+\\n/// ```\\n/// > Note that since our stack is implemented using `Vec` it pushes in the reverse order, but\\n/// the stack is pushes into the top.\\n///\\n/// next we he hit the `)` char, that\\'s where we execute the expr.\\n///\\n/// we will start from the back (last element) in our `Vec` to act as a `Stack`, we start to\\n/// collect a new `Vec` of `bool`s called `params` from the stack and pop that value too from the\\n/// stack and once we hit a `Expr::Func` we stop.\\n/// `params = [false]`\\n/// ```t\\n/// +-----------------+\\n/// | Expr::Func(not) |\\n/// +-----------------+\\n/// ```\\n/// next we get that function from the stack, and call it with the collected `params`\\n/// ```t\\n/// +---------+\\n/// |         |\\n/// +---------+\\n/// ```\\n/// `result = Expr::Const(func(params))`\\n///\\n/// and we push the result pack in the stack\\n/// ```t\\n/// +-------------------+\\n/// | Expr::Const(true) |\\n/// +-------------------+\\n/// ```\\n/// and we go to next `char` and so on..\\n///\\n/// at the end of the loop we know that we will be left with one `Expr::Const` on the top of our\\n/// stack so we fetch it and return the result :)\\n///\\npub fn parse_bool_expr(expression: String) -> bool {\\n    let mut stack: Vec<Expr> = Vec::new();\\n    for c in expression.chars() {\\n        match c {\\n            \\'!\\' => stack.push(Expr::Func(not)),\\n            \\'|\\' => stack.push(Expr::Func(or)),\\n            \\'&\\' => stack.push(Expr::Func(and)),\\n            \\'t\\' => stack.push(Expr::Const(true)),\\n            \\'f\\' => stack.push(Expr::Const(false)),\\n            \\')\\' => {\\n                let mut params: Vec<bool> = vec![];\\n                while let Some(Expr::Const(v)) = stack.last() {\\n                    params.push(*v);\\n                    stack.pop(); // then remove it\\n                }\\n                // get the last func for these params\\n                if let Expr::Func(func) = stack.pop().unwrap() {\\n                    let result = func(params);\\n                    // store the value back to the stack.\\n                    stack.push(Expr::Const(result));\\n                }\\n            }\\n            _ => {\\n                // I would ignore that\\n            }\\n        }\\n    }\\n    if let Expr::Const(v) = *stack.last().unwrap() {\\n        v\\n    } else {\\n        unreachable!(\"Oh Bad\")\\n    }\\n}\\n\\nfn not(tf: Vec<bool>) -> bool {\\n    !tf[0]\\n}\\n\\nfn or(tf: Vec<bool>) -> bool {\\n    tf.iter().any(|v| *v)\\n}\\n\\nfn and(tf: Vec<bool>) -> bool {\\n    tf.iter().all(|v| *v)\\n}\\n\\nenum Expr {\\n    Const(bool),\\n    Func(fn(tf: Vec<bool>) -> bool),\\n}\\n```\\n\\nif you have any improvements, i would be more than happy to mention it here \\uD83E\\uDD70\\n",
                "solutionTags": [],
                "code": "```rust\\n/// We can solve this problem by implementing our own stack and treat (&, |, !) as a function calls\\n/// and (t, f) as params to these functions.\\n///\\n/// For example here is a simple Expression representing `not` function\\n/// input: \"!(f)\"\\n/// the parser will create an empty stack at first for this function\\n/// ```\n```\\n/// after that the parser will match every `char` in the expression and try to push that `Expr`\\n/// in the stack\\n///\\n/// We have two type of `Expr` represented by the `Expr` enum.\\n/// so the parser will at first hit the `!` char, it will push `Expr::Func(not)` to the stack\\n///\\n/// ```\n```\\n/// next it would match the `(` char, we ignore that, then matching the `f` char, it will map\\n/// that to `Expr::Const(false)` and push it to the stack\\n/// ```\n```\\n/// > Note that since our stack is implemented using `Vec` it pushes in the reverse order, but\\n/// the stack is pushes into the top.\\n///\\n/// next we he hit the `)` char, that\\'s where we execute the expr.\\n///\\n/// we will start from the back (last element) in our `Vec` to act as a `Stack`, we start to\\n/// collect a new `Vec` of `bool`s called `params` from the stack and pop that value too from the\\n/// stack and once we hit a `Expr::Func` we stop.\\n/// `params = [false]`\\n/// ```\n```\\n/// next we get that function from the stack, and call it with the collected `params`\\n/// ```\n```\\n/// `result = Expr::Const(func(params))`\\n///\\n/// and we push the result pack in the stack\\n/// ```\n```\\n/// and we go to next `char` and so on..\\n///\\n/// at the end of the loop we know that we will be left with one `Expr::Const` on the top of our\\n/// stack so we fetch it and return the result :)\\n///\\npub fn parse_bool_expr(expression: String) -> bool {\\n    let mut stack: Vec<Expr> = Vec::new();\\n    for c in expression.chars() {\\n        match c {\\n            \\'!\\' => stack.push(Expr::Func(not)),\\n            \\'|\\' => stack.push(Expr::Func(or)),\\n            \\'&\\' => stack.push(Expr::Func(and)),\\n            \\'t\\' => stack.push(Expr::Const(true)),\\n            \\'f\\' => stack.push(Expr::Const(false)),\\n            \\')\\' => {\\n                let mut params: Vec<bool> = vec![];\\n                while let Some(Expr::Const(v)) = stack.last() {\\n                    params.push(*v);\\n                    stack.pop(); // then remove it\\n                }\\n                // get the last func for these params\\n                if let Expr::Func(func) = stack.pop().unwrap() {\\n                    let result = func(params);\\n                    // store the value back to the stack.\\n                    stack.push(Expr::Const(result));\\n                }\\n            }\\n            _ => {\\n                // I would ignore that\\n            }\\n        }\\n    }\\n    if let Expr::Const(v) = *stack.last().unwrap() {\\n        v\\n    } else {\\n        unreachable!(\"Oh Bad\")\\n    }\\n}\\n\\nfn not(tf: Vec<bool>) -> bool {\\n    !tf[0]\\n}\\n\\nfn or(tf: Vec<bool>) -> bool {\\n    tf.iter().any(|v| *v)\\n}\\n\\nfn and(tf: Vec<bool>) -> bool {\\n    tf.iter().all(|v| *v)\\n}\\n\\nenum Expr {\\n    Const(bool),\\n    Func(fn(tf: Vec<bool>) -> bool),\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 327752,
                "title": "simple-python-solution-using-stack",
                "content": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        \"\"\"\\n        :type expression: str\\n        :rtype: bool\\n        \"\"\"\\n        stack, i = [], 0\\n        \\n        while i < len(expression):\\n            c = expression[i]\\n            if c == \\')\\':\\n                operands = []\\n                while stack[-1] in (True, False):\\n                    operands.append(stack.pop())\\n                operator = stack.pop()    \\n                stack.append(operator(operands))\\n            elif c == \\'!\\':\\n                stack.append(lambda x: not x[0])\\n            elif c == \\'&\\':\\n                stack.append(all)\\n            elif c == \\'|\\':\\n                stack.append(any)\\n            elif c == \\'t\\':   \\n                stack.append(True)\\n            elif c == \\'f\\':   \\n                stack.append(False)\\n            \\n            i += 1\\n        \\n        return stack[-1]\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        \"\"\"\\n        :type expression: str\\n        :rtype: bool\\n        \"\"\"\\n        stack, i = [], 0\\n        \\n        while i < len(expression):\\n            c = expression[i]\\n            if c == \\')\\':\\n                operands = []\\n                while stack[-1] in (True, False):\\n                    operands.append(stack.pop())\\n                operator = stack.pop()    \\n                stack.append(operator(operands))\\n            elif c == \\'!\\':\\n                stack.append(lambda x: not x[0])\\n            elif c == \\'&\\':\\n                stack.append(all)\\n            elif c == \\'|\\':\\n                stack.append(any)\\n            elif c == \\'t\\':   \\n                stack.append(True)\\n            elif c == \\'f\\':   \\n                stack.append(False)\\n            \\n            i += 1\\n        \\n        return stack[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323843,
                "title": "simple-100-java-recursive-parser-with-explanation",
                "content": "This is a problem of type \"Recursive Parser\", just like other problems are of, say, type \"Sliding Window\" or type \"DFS\". The Recursive Parser pattern is a useful pattern to have in your mental toolbox.\\n\\nThe general structure to solving these problems is:\\n\\n* `parse()`: This function will handle \"blocks\", or logical groups of computation. In this problem, our \"blocks\" will look like `operator(boolean, boolean, ...)`. For example, a block would be `&(t, t, f)`. Another block is `!(t)`. Blocks may contain blocks, such as `|(f, &(t, t))`. Our `parse()` function will recursively call itself to transform that inner block into a single boolean value and then perform the `|`. `Parse()` will parse an expression by keeping a running list of its constituents (in this case, booleans). Once it encounters `)` it will call `eval()` with its operator and constituents. \\n* `eval()`: This function takes an operator and a list of elements, and performs the operation on those elements. Returns a single value.\\n* `i`: This global variable is current index in the string the parser is at. This will monotonically increase, making our time O(n). It must be a global because, when `parse()` calls itself, after that child call is done, the original `parse()` call needs to know where to pick up parsing, so it may continue parsing its own expression. We can\\'t have `parse()` return the amount `i` was incremented by, because we instead need `parse()` return the result of a computation (which, in this case, is a boolean). \\n* `s`: It\\'s the string we\\'re parsing. Doesn\\'t have to be a global. I like it because it\\'s one less argument to pass around.\\n\\nOther Recursive Parser pattern problems to try:\\n* https://leetcode.com/problems/brace-expansion-ii/\\n* https://leetcode.com/problems/basic-calculator-iii/\\n\\n```\\nclass Solution {\\n    int i;\\n    String s;\\n    \\n    public boolean parseBoolExpr(String expression) {\\n        i = 0;\\n        s = expression;\\n        \\n        return parse();\\n    }\\n    \\n    private boolean parse() {\\n        char op = s.charAt(i++);\\n        List<Boolean> bools = new ArrayList();\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i++);\\n            \\n            if (c == \\'t\\' || c == \\'f\\')\\n                bools.add(c == \\'t\\');\\n            else if (c == \\'|\\' || c == \\'&\\' || c == \\'!\\') {\\n                i--;\\n                bools.add(parse());\\n            }\\n            else if (c == \\')\\')\\n                break;\\n        }\\n        return eval(bools, op);\\n    }\\n    \\n    private boolean eval(List<Boolean> bools, char op) {\\n        if (op == \\'!\\')\\n            return !bools.get(0);\\n        \\n        boolean result = (op == \\'|\\') ? false : true;\\n        for (boolean bool : bools)\\n            result = (op == \\'|\\') ? (result || bool) : (result && bool);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int i;\\n    String s;\\n    \\n    public boolean parseBoolExpr(String expression) {\\n        i = 0;\\n        s = expression;\\n        \\n        return parse();\\n    }\\n    \\n    private boolean parse() {\\n        char op = s.charAt(i++);\\n        List<Boolean> bools = new ArrayList();\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i++);\\n            \\n            if (c == \\'t\\' || c == \\'f\\')\\n                bools.add(c == \\'t\\');\\n            else if (c == \\'|\\' || c == \\'&\\' || c == \\'!\\') {\\n                i--;\\n                bools.add(parse());\\n            }\\n            else if (c == \\')\\')\\n                break;\\n        }\\n        return eval(bools, op);\\n    }\\n    \\n    private boolean eval(List<Boolean> bools, char op) {\\n        if (op == \\'!\\')\\n            return !bools.get(0);\\n        \\n        boolean result = (op == \\'|\\') ? false : true;\\n        for (boolean bool : bools)\\n            result = (op == \\'|\\') ? (result || bool) : (result && bool);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323742,
                "title": "c-recursion-solution-4ms-beats-100-memory",
                "content": "Run this code.\\nWatch the Stdout\\nto know how recursion works in this solution.\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        vector<string> tmp;\\n        if(expression[0]==\\'|\\'){\\n            tmp=partition(expression);\\n            return orJudge(tmp);\\n        }else if(expression[0]==\\'&\\'){\\n            tmp=partition(expression);\\n            return andJudge(tmp);\\n        }else{\\n            tmp=partition(expression);\\n            return !notJudge(tmp);\\n        }\\n    }\\n    vector<string> partition(string expression){\\n        int size=expression.size();\\n        int mark=0,pos=2;\\n        int i,j;\\n        vector<string> ret;\\n        cout << \"Expression: \" << expression << endl;\\n        for(i=2;i<size;++i){\\n            if(expression[i]==\\',\\' && mark==0){\\n                string tmp=expression.substr(pos,i-pos);\\n                ret.push_back(tmp);\\n                cout << tmp << endl;\\n                pos=i+1;\\n            }else if(expression[i]==\\')\\' && mark==0){\\n                string tmp=expression.substr(pos,i-pos);\\n                ret.push_back(tmp);\\n                cout << tmp << endl;\\n                pos=i+1;\\n            }\\n            if(expression[i]==\\'(\\'){\\n                ++mark;\\n            }else if(expression[i]==\\')\\'){\\n                --mark;\\n            }\\n        }\\n        cout << \"Expression partition Finished.\" << endl;\\n        return ret;\\n    }\\n    bool andJudge(vector<string> A){\\n        int i;\\n        int size=A.size();\\n        vector<string> recursion;\\n        for(i=0;i<size;++i){\\n            if(A[i].size()==1){\\n                if(A[i][0]==\\'f\\')\\n                    return false;\\n            }else{\\n                if(A[i][0]==\\'|\\'){\\n                    recursion=partition(A[i]);\\n                    if(!orJudge(recursion)){\\n                        return false;\\n                    }\\n                }else if(A[i][0]==\\'&\\'){\\n                    recursion=partition(A[i]);\\n                    if(!andJudge(recursion)){\\n                        return false;\\n                    }\\n                }else{\\n                    recursion=partition(A[i]);\\n                    if(notJudge(recursion)){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool orJudge(vector<string> A){\\n        int i;\\n        int size=A.size();\\n        vector<string> recursion;\\n        for(i=0;i<size;++i){\\n            if(A[i].size()==1){\\n                if(A[i][0]==\\'t\\')\\n                    return true;\\n            }else{\\n                if(A[i][0]==\\'|\\'){\\n                    recursion=partition(A[i]);\\n                    if(orJudge(recursion)){\\n                        return true;\\n                    }\\n                }else if(A[i][0]==\\'&\\'){\\n                    recursion=partition(A[i]);\\n                    if(andJudge(recursion)){\\n                        return true;\\n                    }\\n                }else{\\n                    recursion=partition(A[i]);\\n                    if(!notJudge(recursion)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool notJudge(vector<string> A){\\n        int i;\\n        int size=A.size();\\n        vector<string> recursion;\\n        for(i=0;i<size;++i){\\n            if(A[i].size()==1){\\n                if(A[i][0]==\\'t\\')\\n                    return true;\\n                else\\n                    return false;\\n            }else{\\n                if(A[i][0]==\\'|\\'){\\n                    recursion=partition(A[i]);\\n                    return orJudge(recursion);\\n                }else if(A[i][0]==\\'&\\'){\\n                    recursion=partition(A[i]);\\n                    return andJudge(recursion);\\n                }else{\\n                    recursion=partition(A[i]);\\n                    return !notJudge(recursion);\\n                }\\n            }\\n        }\\n        return false; //return guard\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        vector<string> tmp;\\n        if(expression[0]==\\'|\\'){\\n            tmp=partition(expression);\\n            return orJudge(tmp);\\n        }else if(expression[0]==\\'&\\'){\\n            tmp=partition(expression);\\n            return andJudge(tmp);\\n        }else{\\n            tmp=partition(expression);\\n            return !notJudge(tmp);\\n        }\\n    }\\n    vector<string> partition(string expression){\\n        int size=expression.size();\\n        int mark=0,pos=2;\\n        int i,j;\\n        vector<string> ret;\\n        cout << \"Expression: \" << expression << endl;\\n        for(i=2;i<size;++i){\\n            if(expression[i]==\\',\\' && mark==0){\\n                string tmp=expression.substr(pos,i-pos);\\n                ret.push_back(tmp);\\n                cout << tmp << endl;\\n                pos=i+1;\\n            }else if(expression[i]==\\')\\' && mark==0){\\n                string tmp=expression.substr(pos,i-pos);\\n                ret.push_back(tmp);\\n                cout << tmp << endl;\\n                pos=i+1;\\n            }\\n            if(expression[i]==\\'(\\'){\\n                ++mark;\\n            }else if(expression[i]==\\')\\'){\\n                --mark;\\n            }\\n        }\\n        cout << \"Expression partition Finished.\" << endl;\\n        return ret;\\n    }\\n    bool andJudge(vector<string> A){\\n        int i;\\n        int size=A.size();\\n        vector<string> recursion;\\n        for(i=0;i<size;++i){\\n            if(A[i].size()==1){\\n                if(A[i][0]==\\'f\\')\\n                    return false;\\n            }else{\\n                if(A[i][0]==\\'|\\'){\\n                    recursion=partition(A[i]);\\n                    if(!orJudge(recursion)){\\n                        return false;\\n                    }\\n                }else if(A[i][0]==\\'&\\'){\\n                    recursion=partition(A[i]);\\n                    if(!andJudge(recursion)){\\n                        return false;\\n                    }\\n                }else{\\n                    recursion=partition(A[i]);\\n                    if(notJudge(recursion)){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool orJudge(vector<string> A){\\n        int i;\\n        int size=A.size();\\n        vector<string> recursion;\\n        for(i=0;i<size;++i){\\n            if(A[i].size()==1){\\n                if(A[i][0]==\\'t\\')\\n                    return true;\\n            }else{\\n                if(A[i][0]==\\'|\\'){\\n                    recursion=partition(A[i]);\\n                    if(orJudge(recursion)){\\n                        return true;\\n                    }\\n                }else if(A[i][0]==\\'&\\'){\\n                    recursion=partition(A[i]);\\n                    if(andJudge(recursion)){\\n                        return true;\\n                    }\\n                }else{\\n                    recursion=partition(A[i]);\\n                    if(!notJudge(recursion)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool notJudge(vector<string> A){\\n        int i;\\n        int size=A.size();\\n        vector<string> recursion;\\n        for(i=0;i<size;++i){\\n            if(A[i].size()==1){\\n                if(A[i][0]==\\'t\\')\\n                    return true;\\n                else\\n                    return false;\\n            }else{\\n                if(A[i][0]==\\'|\\'){\\n                    recursion=partition(A[i]);\\n                    return orJudge(recursion);\\n                }else if(A[i][0]==\\'&\\'){\\n                    recursion=partition(A[i]);\\n                    return andJudge(recursion);\\n                }else{\\n                    recursion=partition(A[i]);\\n                    return !notJudge(recursion);\\n                }\\n            }\\n        }\\n        return false; //return guard\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 323710,
                "title": "python-stack-solution",
                "content": "```\\nclass Solution(object):\\n    def parseBoolExpr(self, expression):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        def getAns(stack, operation):\\n            res = stack.pop()\\n            if operation == \\'!\\':\\n                return not res\\n            \\n            while len(stack)>0 and stack[len(stack)-1]!=\\'(\\':\\n                temp = stack.pop()\\n                if operation == \\'|\\':\\n                    res = (res or temp)\\n                else:\\n                    res = (res and temp)\\n            return res\\n                    \\n        \\n        stack = []\\n        operations = []\\n        for i in range(len(expression)):\\n            c = expression[i]\\n            if c==\\'(\\':\\n                stack.append(c)\\n            elif c==\\'!\\' or c==\\'&\\' or c==\\'|\\':\\n                operations.append(c)\\n            elif c==\\'t\\':\\n                stack.append(True)\\n            elif c==\\'f\\':\\n                stack.append(False)\\n            elif c==\\')\\':\\n                temp = getAns(stack, operations[len(operations)-1])\\n                stack.pop()\\n                stack.append(temp)\\n                operations.pop()\\n        \\n        \\n        return stack[0]\\n                \\n                \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def parseBoolExpr(self, expression):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        def getAns(stack, operation):\\n            res = stack.pop()\\n            if operation == \\'!\\':\\n                return not res\\n            \\n            while len(stack)>0 and stack[len(stack)-1]!=\\'(\\':\\n                temp = stack.pop()\\n                if operation == \\'|\\':\\n                    res = (res or temp)\\n                else:\\n                    res = (res and temp)\\n            return res\\n                    \\n        \\n        stack = []\\n        operations = []\\n        for i in range(len(expression)):\\n            c = expression[i]\\n            if c==\\'(\\':\\n                stack.append(c)\\n            elif c==\\'!\\' or c==\\'&\\' or c==\\'|\\':\\n                operations.append(c)\\n            elif c==\\'t\\':\\n                stack.append(True)\\n            elif c==\\'f\\':\\n                stack.append(False)\\n            elif c==\\')\\':\\n                temp = getAns(stack, operations[len(operations)-1])\\n                stack.pop()\\n                stack.append(temp)\\n                operations.pop()\\n        \\n        \\n        return stack[0]\\n                \\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 323562,
                "title": "rust-clean-solution-using-recursion",
                "content": "```rust\\nuse std::str::Chars;\\n\\nimpl Solution {\\n    pub fn parse_next(iter: &mut Chars) -> bool {\\n        match iter.next() {\\n            Some(\\'t\\') => true,\\n            Some(\\'f\\') => false,\\n            Some(\\'&\\') => Solution::parse_and(iter),\\n            Some(\\'|\\') => Solution::parse_or(iter),\\n            Some(\\'!\\') => Solution::parse_not(iter),\\n            _ => unreachable!()\\n        }\\n    }\\n\\n    pub fn parse_not(iter: &mut Chars) -> bool {\\n        let mut result = true;\\n        loop {\\n            match iter.next() {\\n                Some(\\')\\') => return !result,\\n                Some(\\'(\\') => result = Solution::parse_next(iter),\\n                _ => unreachable!()\\n            }\\n        }\\n    }\\n\\n    pub fn parse_and(iter: &mut Chars) -> bool {\\n        let mut result = true;\\n        loop {\\n            match iter.next() {\\n                Some(\\')\\') => return result,\\n                Some(\\'(\\') => result = Solution::parse_next(iter),\\n                Some(\\',\\') => result = Solution::parse_next(iter) && result,\\n                _ => unreachable!()\\n            }\\n        }\\n    }\\n    \\n    pub fn parse_or(iter: &mut Chars) -> bool {\\n        let mut result = false;\\n        loop {\\n            match iter.next() {\\n                Some(\\')\\') => return result,\\n                Some(\\'(\\') => result = Solution::parse_next(iter),\\n                Some(\\',\\') => result = Solution::parse_next(iter) || result,\\n                _ => unreachable!()\\n            }\\n        }\\n    }\\n\\n    pub fn parse_bool_expr(expression: String) -> bool {\\n        let mut iter = expression.chars();\\n        Solution::parse_next(&mut iter)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::str::Chars;\\n\\nimpl Solution {\\n    pub fn parse_next(iter: &mut Chars) -> bool {\\n        match iter.next() {\\n            Some(\\'t\\') => true,\\n            Some(\\'f\\') => false,\\n            Some(\\'&\\') => Solution::parse_and(iter),\\n            Some(\\'|\\') => Solution::parse_or(iter),\\n            Some(\\'!\\') => Solution::parse_not(iter),\\n            _ => unreachable!()\\n        }\\n    }\\n\\n    pub fn parse_not(iter: &mut Chars) -> bool {\\n        let mut result = true;\\n        loop {\\n            match iter.next() {\\n                Some(\\')\\') => return !result,\\n                Some(\\'(\\') => result = Solution::parse_next(iter),\\n                _ => unreachable!()\\n            }\\n        }\\n    }\\n\\n    pub fn parse_and(iter: &mut Chars) -> bool {\\n        let mut result = true;\\n        loop {\\n            match iter.next() {\\n                Some(\\')\\') => return result,\\n                Some(\\'(\\') => result = Solution::parse_next(iter),\\n                Some(\\',\\') => result = Solution::parse_next(iter) && result,\\n                _ => unreachable!()\\n            }\\n        }\\n    }\\n    \\n    pub fn parse_or(iter: &mut Chars) -> bool {\\n        let mut result = false;\\n        loop {\\n            match iter.next() {\\n                Some(\\')\\') => return result,\\n                Some(\\'(\\') => result = Solution::parse_next(iter),\\n                Some(\\',\\') => result = Solution::parse_next(iter) || result,\\n                _ => unreachable!()\\n            }\\n        }\\n    }\\n\\n    pub fn parse_bool_expr(expression: String) -> bool {\\n        let mut iter = expression.chars();\\n        Solution::parse_next(&mut iter)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323465,
                "title": "c-easy-to-understand-solution-using-stack-with-explanation",
                "content": "You my use the cout to help understanding how it works.\\nGiven the 4th exemple: \\n|(&(t,f,t),!(t))\\nThe result stack: |(&tft\\nEvaluation stack: &tft\\n\\nAfter the first evaluation\\nThe result stack: |(f\\n\\nAnd then\\nThe result stack: |(f!(t\\nEvaluation stack: !t\\n\\nAfter the second evaluation\\nThe result stack: |(ff\\n\\nAne then\\nThe result stack: |(ff\\nEvaluation stack: |ff\\n\\nAfter the third evaluation\\nThe result stack: f --> final answer\\n\\n* Analysis: (Feel free to correct me if I am wrong, not quite sure about the analysis of this problem)\\n    * Time complexity: O(N) since each element will be push into the stack and pop once.\\n    * Space complexity: O(N) \\n```\\n#include <bits/stdc++.h>\\nclass Solution \\n{\\npublic:\\n    bool parseBoolExpr(string exp) \\n    {\\n        int n = exp.size();\\n        vector<char> ev;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(exp[i] != \\',\\')\\n            {\\n                ev.push_back(exp[i]);\\n            }\\n        }\\n        \\n        n = ev.size();\\n        deque<char> res;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(ev[i] != \\')\\')\\n            {\\n                res.push_back(ev[i]);\\n            }\\n            else\\n            {\\n                deque<char> eval_stk; // stack stored for evaluation   \\n                while(res.size() && res.back() != \\'&\\' && res.back() != \\'|\\' && res.back() != \\'!\\') // push back the operands\\n                {\\n                    cout << \"res_back \" << res.back() << \\'\\\\n\\';\\n                    if(res.back() == \\'t\\' || res.back() == \\'f\\')\\n                    {\\n                        eval_stk.push_back(res.back());\\n                    }\\n                    res.pop_back();\\n                }\\n                \\n                char op = res.back(); // get operator\\n                res.pop_back(); // pop that operator out\\n                bool on = (eval_stk.back() == \\'t\\') ? 1 : 0; // first answer\\n                cout <<\"on \" << on << \" op \" << op << \"res.size() \" << res.size() << \\'\\\\n\\';\\n                \\n                if(op == \\'|\\') // or operator\\n                {\\n                    while(eval_stk.size())\\n                    {\\n                        if((eval_stk.back() == \\'t\\'))\\n                        {\\n                            on |= 1; // early stopping if encounter OR 1\\n                            break;\\n                        }\\n                        else\\n                        {\\n                            on |= 0;\\n                        }\\n                        eval_stk.pop_back();\\n                    }\\n                }\\n                else if(op == \\'&\\') // and operator\\n                {\\n                    while(eval_stk.size())\\n                    {\\n                        if((eval_stk.back() == \\'t\\'))\\n                        {\\n                            on &= 1;\\n                        }\\n                        else\\n                        {\\n                            on &= 0; // early stopping if encounter AND 0\\n                            break;\\n                        }\\n                        eval_stk.pop_back();\\n                    }\\n                }\\n                else if(op == \\'!\\')\\n                {\\n                    on ^= 1; // toggle the boolean result\\n                }\\n                res.push_back((on == 1) ? \\'t\\' : \\'f\\');\\n            }\\n        }\\n        \\n        return (res.back() == \\'t\\') ? 1 : 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <bits/stdc++.h>\\nclass Solution \\n{\\npublic:\\n    bool parseBoolExpr(string exp) \\n    {\\n        int n = exp.size();\\n        vector<char> ev;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(exp[i] != \\',\\')\\n            {\\n                ev.push_back(exp[i]);\\n            }\\n        }\\n        \\n        n = ev.size();\\n        deque<char> res;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(ev[i] != \\')\\')\\n            {\\n                res.push_back(ev[i]);\\n            }\\n            else\\n            {\\n                deque<char> eval_stk; // stack stored for evaluation   \\n                while(res.size() && res.back() != \\'&\\' && res.back() != \\'|\\' && res.back() != \\'!\\') // push back the operands\\n                {\\n                    cout << \"res_back \" << res.back() << \\'\\\\n\\';\\n                    if(res.back() == \\'t\\' || res.back() == \\'f\\')\\n                    {\\n                        eval_stk.push_back(res.back());\\n                    }\\n                    res.pop_back();\\n                }\\n                \\n                char op = res.back(); // get operator\\n                res.pop_back(); // pop that operator out\\n                bool on = (eval_stk.back() == \\'t\\') ? 1 : 0; // first answer\\n                cout <<\"on \" << on << \" op \" << op << \"res.size() \" << res.size() << \\'\\\\n\\';\\n                \\n                if(op == \\'|\\') // or operator\\n                {\\n                    while(eval_stk.size())\\n                    {\\n                        if((eval_stk.back() == \\'t\\'))\\n                        {\\n                            on |= 1; // early stopping if encounter OR 1\\n                            break;\\n                        }\\n                        else\\n                        {\\n                            on |= 0;\\n                        }\\n                        eval_stk.pop_back();\\n                    }\\n                }\\n                else if(op == \\'&\\') // and operator\\n                {\\n                    while(eval_stk.size())\\n                    {\\n                        if((eval_stk.back() == \\'t\\'))\\n                        {\\n                            on &= 1;\\n                        }\\n                        else\\n                        {\\n                            on &= 0; // early stopping if encounter AND 0\\n                            break;\\n                        }\\n                        eval_stk.pop_back();\\n                    }\\n                }\\n                else if(op == \\'!\\')\\n                {\\n                    on ^= 1; // toggle the boolean result\\n                }\\n                res.push_back((on == 1) ? \\'t\\' : \\'f\\');\\n            }\\n        }\\n        \\n        return (res.back() == \\'t\\') ? 1 : 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 323417,
                "title": "easily-implemented-python-solution",
                "content": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        def split_expression(exp):\\n            level, sub_exp, sub_exps = 0, \\'\\', []\\n            for char in exp:\\n                if char == \\',\\' and level == 0:\\n                    sub_exps.append(sub_exp)\\n                    sub_exp = \\'\\'\\n                else:\\n                    sub_exp += char\\n                    if char == \\'(\\':\\n                        level += 1\\n                    if char == \\')\\':\\n                        level -= 1\\n            sub_exps.append(sub_exp)\\n            return sub_exps\\n                \\n        \\n        if expression == \\'t\\':\\n            return True\\n        elif expression == \\'f\\':\\n            return False\\n        elif expression[0] == \\'!\\':\\n            return not self.parseBoolExpr(expression[2:-1])\\n        elif expression[0] == \\'&\\':\\n            sub_exps = split_expression(expression[2:-1])\\n            for sub_exp in sub_exps:\\n                if not self.parseBoolExpr(sub_exp):\\n                    return False\\n            return True\\n        elif expression[0] == \\'|\\':\\n            sub_exps = split_expression(expression[2:-1])\\n            for sub_exp in sub_exps:\\n                if self.parseBoolExpr(sub_exp):\\n                    return True\\n            return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        def split_expression(exp):\\n            level, sub_exp, sub_exps = 0, \\'\\', []\\n            for char in exp:\\n                if char == \\',\\' and level == 0:\\n                    sub_exps.append(sub_exp)\\n                    sub_exp = \\'\\'\\n                else:\\n                    sub_exp += char\\n                    if char == \\'(\\':\\n                        level += 1\\n                    if char == \\')\\':\\n                        level -= 1\\n            sub_exps.append(sub_exp)\\n            return sub_exps\\n                \\n        \\n        if expression == \\'t\\':\\n            return True\\n        elif expression == \\'f\\':\\n            return False\\n        elif expression[0] == \\'!\\':\\n            return not self.parseBoolExpr(expression[2:-1])\\n        elif expression[0] == \\'&\\':\\n            sub_exps = split_expression(expression[2:-1])\\n            for sub_exp in sub_exps:\\n                if not self.parseBoolExpr(sub_exp):\\n                    return False\\n            return True\\n        elif expression[0] == \\'|\\':\\n            sub_exps = split_expression(expression[2:-1])\\n            for sub_exp in sub_exps:\\n                if self.parseBoolExpr(sub_exp):\\n                    return True\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323400,
                "title": "concise-and-clear-java-solution-using-recursion",
                "content": "```\\n    public boolean parseBoolExpr(String expression) {\\n        return eval(expression);\\n    }\\n    \\n    private boolean eval(String expression) {\\n        if (expression.length() == 1) {\\n            return expression.equals(\"t\") ? true : false;\\n        }\\n        \\n       \\n        char mark = expression.charAt(0);\\n        List<String> list = parse(expression);        \\n         boolean res = eval(list.get(0)); \\n        \\n        if (mark == \\'!\\') {\\n            return !res;\\n        }\\n        for (int i = 1; i < list.size(); i++) {\\n            String exp = list.get(i);\\n            if (mark == \\'&\\') {\\n                res &= eval(exp);\\n            } else if (mark == \\'|\\') {\\n                res |= eval(exp);\\n            } \\n        }\\n        return res;\\n    }\\n    \\n    private List<String> parse(String expression) {\\n        List<String> res = new ArrayList<>();\\n        int start = 2, end = 2;\\n        int open = 0, close = 0;\\n        while (end < expression.length() - 1) {\\n            char c = expression.charAt(end);\\n            switch(c) {\\n                case \\'(\\':\\n                    open++;\\n                    break;\\n                case \\')\\' :\\n                    close++;\\n                    break;\\n                case \\',\\' :\\n                    if (open == close) {\\n                        res.add(expression.substring(start, end));\\n                        start = end + 1;\\n                    }\\n                    break;\\n            }\\n            end++;\\n        }\\n        res.add(expression.substring(start, end));\\n        return res;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\n    public boolean parseBoolExpr(String expression) {\\n        return eval(expression);\\n    }\\n    \\n    private boolean eval(String expression) {\\n        if (expression.length() == 1) {\\n            return expression.equals(\"t\") ? true : false;\\n        }\\n        \\n       \\n        char mark = expression.charAt(0);\\n        List<String> list = parse(expression);        \\n         boolean res = eval(list.get(0)); \\n        \\n        if (mark == \\'!\\') {\\n            return !res;\\n        }\\n        for (int i = 1; i < list.size(); i++) {\\n            String exp = list.get(i);\\n            if (mark == \\'&\\') {\\n                res &= eval(exp);\\n            } else if (mark == \\'|\\') {\\n                res |= eval(exp);\\n            } \\n        }\\n        return res;\\n    }\\n    \\n    private List<String> parse(String expression) {\\n        List<String> res = new ArrayList<>();\\n        int start = 2, end = 2;\\n        int open = 0, close = 0;\\n        while (end < expression.length() - 1) {\\n            char c = expression.charAt(end);\\n            switch(c) {\\n                case \\'(\\':\\n                    open++;\\n                    break;\\n                case \\')\\' :\\n                    close++;\\n                    break;\\n                case \\',\\' :\\n                    if (open == close) {\\n                        res.add(expression.substring(start, end));\\n                        start = end + 1;\\n                    }\\n                    break;\\n            }\\n            end++;\\n        }\\n        res.add(expression.substring(start, end));\\n        return res;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 323346,
                "title": "python3-clear-recursive-solution",
                "content": "\\n- similar to brace expansion II (see my previous post for this problem: [Brace Expansion II - LeetCode](https://leetcode.com/problems/brace-expansion-ii/discuss/317623/Python3-Clear-and-Short-Recursive-Solution))\\n- the point is to try removing a level of parentheses (or the top level boolean operator) in each recursive call\\n- base case: when there is no parentheses (i.e., no boolean operator) in the expression\\n- use a boolean list to store all booleans in the same level\\n- note that the boolean operator must appear at `0` index of a valid expression (if there is a boolean operator)\\n\\n```py\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        if len(expression) == 1:\\n            return expression == \\'t\\'\\n        op = expression[0]\\n        boolean_list = []\\n        level = 0\\n        start = 2\\n        for i in range(2, len(expression) - 1):\\n            ch = expression[i]\\n            if ch == \\'(\\':\\n                level += 1\\n            elif ch == \\')\\':\\n                level -= 1\\n            elif ch == \\',\\' and level == 0:\\n                boolean_list.append(self.parseBoolExpr(expression[start:i]))\\n                start = i+1\\n            elif ch not in \\'&|!\\' and level == 0:\\n                boolean_list.append(True if ch == \\'t\\' else False)\\n        boolean_list.append(self.parseBoolExpr(expression[start:-1]))\\n        if op == \\'!\\':\\n            return not boolean_list[0]\\n        elif op == \\'&\\':\\n            return all(boolean_list)\\n        else:\\n            return any(boolean_list)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        if len(expression) == 1:\\n            return expression == \\'t\\'\\n        op = expression[0]\\n        boolean_list = []\\n        level = 0\\n        start = 2\\n        for i in range(2, len(expression) - 1):\\n            ch = expression[i]\\n            if ch == \\'(\\':\\n                level += 1\\n            elif ch == \\')\\':\\n                level -= 1\\n            elif ch == \\',\\' and level == 0:\\n                boolean_list.append(self.parseBoolExpr(expression[start:i]))\\n                start = i+1\\n            elif ch not in \\'&|!\\' and level == 0:\\n                boolean_list.append(True if ch == \\'t\\' else False)\\n        boolean_list.append(self.parseBoolExpr(expression[start:-1]))\\n        if op == \\'!\\':\\n            return not boolean_list[0]\\n        elif op == \\'&\\':\\n            return all(boolean_list)\\n        else:\\n            return any(boolean_list)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323299,
                "title": "java-on-recursion-similar-to-basic-calculator-iii",
                "content": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String s) {\\n        Queue<Character> q = new LinkedList<>();\\n        for (char c : s.toCharArray()) {\\n            q.offer(c);\\n        }\\n        return cal(q).get(0);\\n    }\\n    public List<Boolean> cal(Queue<Character> q) {\\n        List<Boolean> temp = new ArrayList<>();\\n        char operator = \\'&\\';\\n        while (!q.isEmpty()) {\\n            char c = q.poll();\\n            if (c == \\'|\\' || c == \\'&\\' || c == \\'!\\') operator = c;\\n            if (c == \\'t\\') temp.add(true);\\n            if (c == \\'f\\') temp.add(false);\\n            if (c == \\')\\') return temp;\\n            if (c == \\'(\\') temp.add(helper(cal(q), operator));\\n        }\\n        return temp;\\n    }\\n    public boolean helper(List<Boolean> res, char operator) {\\n        boolean cur = res.get(0);\\n        if (operator == \\'!\\') return !cur;\\n        for (int i = 1; i < res.size(); i++) {\\n            cur = operator == \\'&\\' ? cur && res.get(i) : cur || res.get(i);\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String s) {\\n        Queue<Character> q = new LinkedList<>();\\n        for (char c : s.toCharArray()) {\\n            q.offer(c);\\n        }\\n        return cal(q).get(0);\\n    }\\n    public List<Boolean> cal(Queue<Character> q) {\\n        List<Boolean> temp = new ArrayList<>();\\n        char operator = \\'&\\';\\n        while (!q.isEmpty()) {\\n            char c = q.poll();\\n            if (c == \\'|\\' || c == \\'&\\' || c == \\'!\\') operator = c;\\n            if (c == \\'t\\') temp.add(true);\\n            if (c == \\'f\\') temp.add(false);\\n            if (c == \\')\\') return temp;\\n            if (c == \\'(\\') temp.add(helper(cal(q), operator));\\n        }\\n        return temp;\\n    }\\n    public boolean helper(List<Boolean> res, char operator) {\\n        boolean cur = res.get(0);\\n        if (operator == \\'!\\') return !cur;\\n        for (int i = 1; i < res.size(); i++) {\\n            cur = operator == \\'&\\' ? cur && res.get(i) : cur || res.get(i);\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099869,
                "title": "python",
                "content": "# Code\\n```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        e = []\\n\\n        def apply(e, operator):\\n            if operator == \\'|\\':\\n                if len(e) == 1:\\n                    return e[-1]\\n                else:\\n                    res = e[0]|e[1]\\n                    for i in range(2, len(e)):\\n                        res |= e[i]\\n                return res\\n            elif operator == \\'&\\': \\n                if len(e) == 1:\\n                    return e[-1]\\n                else:\\n                    res = e[0]&e[1]\\n                    for i in range(2, len(e)):\\n                        res &= e[i]\\n                return res\\n            \\n            else:\\n                return False if e[-1] == True else True \\n\\n       \\n        for i in range(len(expression)):\\n            if expression[i] in (\\'!\\', \"|\", \"&\", \\'(\\'):\\n                stack.append(expression[i])\\n            \\n            else:\\n                if expression[i] == \\')\\':\\n                    while stack[-1] != \\'(\\':\\n                        e.append(stack.pop())\\n\\n                    stack.pop()\\n                    print(e, stack[-1])\\n                    stack.append(apply(e, stack.pop()))\\n                    e = []\\n\\n                if (expression[i] == \\'f\\' or expression[i] == \\'t\\'):\\n                    stack.append(False if expression[i] == \\'f\\' else True)\\n\\n        return stack[-1]\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        e = []\\n\\n        def apply(e, operator):\\n            if operator == \\'|\\':\\n                if len(e) == 1:\\n                    return e[-1]\\n                else:\\n                    res = e[0]|e[1]\\n                    for i in range(2, len(e)):\\n                        res |= e[i]\\n                return res\\n            elif operator == \\'&\\': \\n                if len(e) == 1:\\n                    return e[-1]\\n                else:\\n                    res = e[0]&e[1]\\n                    for i in range(2, len(e)):\\n                        res &= e[i]\\n                return res\\n            \\n            else:\\n                return False if e[-1] == True else True \\n\\n       \\n        for i in range(len(expression)):\\n            if expression[i] in (\\'!\\', \"|\", \"&\", \\'(\\'):\\n                stack.append(expression[i])\\n            \\n            else:\\n                if expression[i] == \\')\\':\\n                    while stack[-1] != \\'(\\':\\n                        e.append(stack.pop())\\n\\n                    stack.pop()\\n                    print(e, stack[-1])\\n                    stack.append(apply(e, stack.pop()))\\n                    e = []\\n\\n                if (expression[i] == \\'f\\' or expression[i] == \\'t\\'):\\n                    stack.append(False if expression[i] == \\'f\\' else True)\\n\\n        return stack[-1]\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098971,
                "title": "c-easy-1-stack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n        stack<char>st;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\')\\'){\\n                int x=0,y=0;\\n                while(st.top()!=\\'(\\'){\\n                    if(st.top()==\\'f\\')y++;\\n                    else if(st.top()==\\'t\\')x++;\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(st.top()==\\'&\\'){\\n                    st.pop();\\n                    if(y>0)st.push(\\'f\\');\\n                    else st.push(\\'t\\');\\n                    \\n                }else if(st.top()==\\'|\\'){st.pop();\\n                    if(x>0)st.push(\\'t\\');\\n                    else st.push(\\'f\\');\\n                    \\n                }else{st.pop();\\n                    if(x>0)st.push(\\'f\\');\\n                    else st.push(\\'t\\');\\n                    \\n                }\\n                \\n            }else{\\n                if(s[i]!=\\',\\');\\n            st.push(s[i]);}\\n        }\\n        if(st.top()==\\'t\\')return 1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n        stack<char>st;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\')\\'){\\n                int x=0,y=0;\\n                while(st.top()!=\\'(\\'){\\n                    if(st.top()==\\'f\\')y++;\\n                    else if(st.top()==\\'t\\')x++;\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(st.top()==\\'&\\'){\\n                    st.pop();\\n                    if(y>0)st.push(\\'f\\');\\n                    else st.push(\\'t\\');\\n                    \\n                }else if(st.top()==\\'|\\'){st.pop();\\n                    if(x>0)st.push(\\'t\\');\\n                    else st.push(\\'f\\');\\n                    \\n                }else{st.pop();\\n                    if(x>0)st.push(\\'f\\');\\n                    else st.push(\\'t\\');\\n                    \\n                }\\n                \\n            }else{\\n                if(s[i]!=\\',\\');\\n            st.push(s[i]);}\\n        }\\n        if(st.top()==\\'t\\')return 1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097175,
                "title": "easy-to-understand-stack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool subExpr(char logical_op,int t,int f){\\n        if(logical_op == \\'&\\'){\\n            if(f) return false;\\n            else return true;\\n        }\\n        if(logical_op == \\'|\\'){\\n            if(t) return true;\\n            return false;\\n        }\\n        else{\\n            if(t) return false;\\n            return true;\\n        }\\n    }\\n\\n    bool parseBoolExpr(string expression) {\\n        stack<char>s;\\n\\n        int n = expression.length();\\n\\n        for(int i = 0;i<n;i++){\\n            if(expression[i] == \\',\\') continue;\\n\\n            if(expression[i] == \\')\\'){\\n                int f = 0;int t = 0;\\n                while(s.top() == \\'f\\' || s.top() == \\'t\\' || s.top() == \\'(\\'){\\n                    if(s.top() == \\'f\\') f++;\\n                    if(s.top() == \\'t\\') t++;\\n                    s.pop();\\n                }\\n                bool k = subExpr(s.top(),t,f);\\n                s.pop();\\n\\n                if(k) s.push(\\'t\\');\\n                else s.push(\\'f\\');\\n            }else{\\n                s.push(expression[i]);\\n            }\\n        }\\n\\n        if(s.top() == \\'f\\') return false;\\n        else return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool subExpr(char logical_op,int t,int f){\\n        if(logical_op == \\'&\\'){\\n            if(f) return false;\\n            else return true;\\n        }\\n        if(logical_op == \\'|\\'){\\n            if(t) return true;\\n            return false;\\n        }\\n        else{\\n            if(t) return false;\\n            return true;\\n        }\\n    }\\n\\n    bool parseBoolExpr(string expression) {\\n        stack<char>s;\\n\\n        int n = expression.length();\\n\\n        for(int i = 0;i<n;i++){\\n            if(expression[i] == \\',\\') continue;\\n\\n            if(expression[i] == \\')\\'){\\n                int f = 0;int t = 0;\\n                while(s.top() == \\'f\\' || s.top() == \\'t\\' || s.top() == \\'(\\'){\\n                    if(s.top() == \\'f\\') f++;\\n                    if(s.top() == \\'t\\') t++;\\n                    s.pop();\\n                }\\n                bool k = subExpr(s.top(),t,f);\\n                s.pop();\\n\\n                if(k) s.push(\\'t\\');\\n                else s.push(\\'f\\');\\n            }else{\\n                s.push(expression[i]);\\n            }\\n        }\\n\\n        if(s.top() == \\'f\\') return false;\\n        else return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096853,
                "title": "c-readable-recursive-string-parsing-92-time-and-memory",
                "content": "# Intuition\\nAlthough this problem requires careful implementation and a thorough test case to start with, this problem can be broken down into 3 cases of AND, OR and NOT.\\n\\n# Approach\\nRecursively parse inner expressions and apply the parent operator to them.\\nStop parsing an inner expression as soon as the stopper bool value is found. E.g.: once we found false, it doesn\\'t make sense to eval \\'&\\' anymore, it\\'s always going to result in false.\\n\\n# Complexity\\n- Time complexity:\\nO(n) - one pass of the input string.\\n\\n- Space complexity:\\nO(n) for recursion callstack.\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool ParseBoolExpr(string expression) {\\n        if (expression.Length == 1)\\n            return expression == \"t\";\\n        \\n        char oper = expression[0];\\n        int end = 0;\\n        return Eval(expression, oper, 2, ref end);\\n    }\\n\\n    private bool Eval(string expr, char oper, int start, ref int end)\\n    {\\n        if (oper == \\'&\\')\\n        {\\n            return EvalAndOr(expr, start, isAnd: true, ref end);\\n        }\\n        else if (oper == \\'|\\')\\n        {\\n            return EvalAndOr(expr, start, isAnd: false, ref end);\\n        }\\n        else if (oper == \\'!\\')\\n        {\\n            char newOp = expr[start];\\n            if (IsOperator(newOp))\\n            {\\n                return !Eval(expr, newOp, start + 2, ref end);\\n            }\\n            \\n            end = start + 1;\\n            return newOp == \\'f\\';\\n        }\\n\\n        throw new Exception(\"Impossible\");\\n    }\\n\\n    // if isAnd == false, then this is for \\'|\\' operator.\\n    // for \\'&\\', any false operator will stop eval immediately, returning false.\\n    // for \\'|\\' it\\'s any true.\\n    private bool EvalAndOr(string expr, int start, bool isAnd, ref int end)\\n    {\\n        // for better readability.\\n        char stopper = isAnd ? \\'f\\' : \\'t\\';\\n        char insignificant = isAnd ? \\'t\\' : \\'f\\';\\n        bool stopperBool = isAnd ? false : true;\\n        for (var i = start; i < expr.Length; i++)\\n        {\\n            if (expr[i] == stopper)\\n            {\\n                end = LookAheadFor(expr, i + 1, \\')\\', \\'(\\') + 1;\\n                return stopperBool;\\n            }\\n            else if (expr[i] == insignificant || expr[i] == \\',\\')\\n                continue;\\n            \\n            char newOp = expr[i];\\n            if (IsOperator(newOp))\\n            {\\n                bool innerVal = Eval(expr, newOp, i + 2, ref end);\\n                if (innerVal == stopperBool)\\n                    return stopperBool;\\n                \\n                i = end;\\n            }\\n        }\\n\\n        return isAnd;\\n    }\\n\\n    private int LookAheadFor(string expr, int start, char target, char counterPart)\\n    {\\n        // opened already.\\n        int count = 1;\\n        for (int i = start; i < expr.Length; i++)\\n        {\\n            if (expr[i] == target)\\n            {\\n                if (--count == 0)\\n                    return i;\\n            } else if (expr[i] == counterPart)\\n                count++;\\n        }\\n\\n        return int.MinValue;\\n    }\\n\\n    private bool IsOperator(char c)\\n    {\\n        return c == \\'&\\' || c == \\'|\\' || c == \\'!\\';\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool ParseBoolExpr(string expression) {\\n        if (expression.Length == 1)\\n            return expression == \"t\";\\n        \\n        char oper = expression[0];\\n        int end = 0;\\n        return Eval(expression, oper, 2, ref end);\\n    }\\n\\n    private bool Eval(string expr, char oper, int start, ref int end)\\n    {\\n        if (oper == \\'&\\')\\n        {\\n            return EvalAndOr(expr, start, isAnd: true, ref end);\\n        }\\n        else if (oper == \\'|\\')\\n        {\\n            return EvalAndOr(expr, start, isAnd: false, ref end);\\n        }\\n        else if (oper == \\'!\\')\\n        {\\n            char newOp = expr[start];\\n            if (IsOperator(newOp))\\n            {\\n                return !Eval(expr, newOp, start + 2, ref end);\\n            }\\n            \\n            end = start + 1;\\n            return newOp == \\'f\\';\\n        }\\n\\n        throw new Exception(\"Impossible\");\\n    }\\n\\n    // if isAnd == false, then this is for \\'|\\' operator.\\n    // for \\'&\\', any false operator will stop eval immediately, returning false.\\n    // for \\'|\\' it\\'s any true.\\n    private bool EvalAndOr(string expr, int start, bool isAnd, ref int end)\\n    {\\n        // for better readability.\\n        char stopper = isAnd ? \\'f\\' : \\'t\\';\\n        char insignificant = isAnd ? \\'t\\' : \\'f\\';\\n        bool stopperBool = isAnd ? false : true;\\n        for (var i = start; i < expr.Length; i++)\\n        {\\n            if (expr[i] == stopper)\\n            {\\n                end = LookAheadFor(expr, i + 1, \\')\\', \\'(\\') + 1;\\n                return stopperBool;\\n            }\\n            else if (expr[i] == insignificant || expr[i] == \\',\\')\\n                continue;\\n            \\n            char newOp = expr[i];\\n            if (IsOperator(newOp))\\n            {\\n                bool innerVal = Eval(expr, newOp, i + 2, ref end);\\n                if (innerVal == stopperBool)\\n                    return stopperBool;\\n                \\n                i = end;\\n            }\\n        }\\n\\n        return isAnd;\\n    }\\n\\n    private int LookAheadFor(string expr, int start, char target, char counterPart)\\n    {\\n        // opened already.\\n        int count = 1;\\n        for (int i = start; i < expr.Length; i++)\\n        {\\n            if (expr[i] == target)\\n            {\\n                if (--count == 0)\\n                    return i;\\n            } else if (expr[i] == counterPart)\\n                count++;\\n        }\\n\\n        return int.MinValue;\\n    }\\n\\n    private bool IsOperator(char c)\\n    {\\n        return c == \\'&\\' || c == \\'|\\' || c == \\'!\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086969,
                "title": "simple-stack-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> stack =new Stack<>();\\n\\n        for(int i=0;i<expression.length();i++){\\n             char ch = expression.charAt(i);\\n             if(ch==\\',\\')continue;\\n\\n             if(ch!=\\')\\'){\\n                 stack.push(ch);\\n                 continue;\\n             }\\n             int t =0;\\n             int f=0;\\n             while(stack.peek()!=\\'(\\'){\\n                 char a = stack.pop();\\n                 if(a==\\'t\\')t++;\\n                 if(a==\\'f\\')f++;\\n             }\\n             stack.pop();\\n             if(stack.peek() ==\\'&\\'){\\n                 stack.pop();\\n                if(f>0){\\n                stack.push(\\'f\\');\\n                }               \\n                else{\\n                    stack.push(\\'t\\');\\n                } \\n             }\\n             else if(stack.peek()==\\'|\\'){\\n                 stack.pop();\\n                 if(t>0){\\n                   stack.push(\\'t\\');\\n                 }\\n                 else{\\n                     stack.push(\\'f\\');\\n                 }\\n                \\n             }\\n             else{\\n                stack.pop();\\n                if(t==1){\\n                    stack.push(\\'f\\');\\n                }\\n                else{\\n                    stack.push(\\'t\\');\\n                }\\n             }\\n        }  \\n         return stack.peek()==\\'t\\';  \\n    }\\n   \\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> stack =new Stack<>();\\n\\n        for(int i=0;i<expression.length();i++){\\n             char ch = expression.charAt(i);\\n             if(ch==\\',\\')continue;\\n\\n             if(ch!=\\')\\'){\\n                 stack.push(ch);\\n                 continue;\\n             }\\n             int t =0;\\n             int f=0;\\n             while(stack.peek()!=\\'(\\'){\\n                 char a = stack.pop();\\n                 if(a==\\'t\\')t++;\\n                 if(a==\\'f\\')f++;\\n             }\\n             stack.pop();\\n             if(stack.peek() ==\\'&\\'){\\n                 stack.pop();\\n                if(f>0){\\n                stack.push(\\'f\\');\\n                }               \\n                else{\\n                    stack.push(\\'t\\');\\n                } \\n             }\\n             else if(stack.peek()==\\'|\\'){\\n                 stack.pop();\\n                 if(t>0){\\n                   stack.push(\\'t\\');\\n                 }\\n                 else{\\n                     stack.push(\\'f\\');\\n                 }\\n                \\n             }\\n             else{\\n                stack.pop();\\n                if(t==1){\\n                    stack.push(\\'f\\');\\n                }\\n                else{\\n                    stack.push(\\'t\\');\\n                }\\n             }\\n        }  \\n         return stack.peek()==\\'t\\';  \\n    }\\n   \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060602,
                "title": "c-o-n-clean-code-one-operator-one-function",
                "content": "# Intuition\\nOne operator, one function\\n\\n# Approach\\nRecursion\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)(without stack usage)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        int i = 0;\\n        return solve(expression, i);\\n    }\\n\\n    bool solve(string& expression, int& index) {\\n        switch (expression[index]) {\\n        case \\'!\\':\\n            return solveNotExpr(expression, index);\\n        case \\'&\\':\\n            return solveAndExpr(expression, index);\\n        case \\'|\\':\\n            return solveOrExpr(expression, index);\\n        }\\n        return solveLetter(expression, index);\\n    }\\n\\n    bool solveAndExpr(string& expression, int& index) {\\n        index += 2;\\n        bool res = true;\\n        while (expression[index] != \\')\\') {\\n            if (expression[index] == \\',\\') {\\n                index++;\\n            } else {\\n                bool r = solve(expression, index);\\n                res &= r;\\n            }\\n        }\\n        index++;\\n        return res;\\n    }\\n\\n    bool solveOrExpr(string& expression, int& index) {\\n        index += 2;\\n        bool res = false;\\n        while (expression[index] != \\')\\') {\\n            if (expression[index] == \\',\\') {\\n                index++;\\n            } else {\\n                bool r = solve(expression, index);\\n                res |= r;\\n            }\\n        }\\n        index++;\\n        return res;\\n    }\\n\\n    bool solveNotExpr(string& expression, int& index) {\\n        index += 2;\\n        bool r = solve(expression, index);\\n        index++;\\n        return !r;\\n    }\\n\\n    bool solveLetter(string& expression, int& index) {\\n        char c = expression[index];\\n        index++;\\n        if (c == \\'t\\')\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        int i = 0;\\n        return solve(expression, i);\\n    }\\n\\n    bool solve(string& expression, int& index) {\\n        switch (expression[index]) {\\n        case \\'!\\':\\n            return solveNotExpr(expression, index);\\n        case \\'&\\':\\n            return solveAndExpr(expression, index);\\n        case \\'|\\':\\n            return solveOrExpr(expression, index);\\n        }\\n        return solveLetter(expression, index);\\n    }\\n\\n    bool solveAndExpr(string& expression, int& index) {\\n        index += 2;\\n        bool res = true;\\n        while (expression[index] != \\')\\') {\\n            if (expression[index] == \\',\\') {\\n                index++;\\n            } else {\\n                bool r = solve(expression, index);\\n                res &= r;\\n            }\\n        }\\n        index++;\\n        return res;\\n    }\\n\\n    bool solveOrExpr(string& expression, int& index) {\\n        index += 2;\\n        bool res = false;\\n        while (expression[index] != \\')\\') {\\n            if (expression[index] == \\',\\') {\\n                index++;\\n            } else {\\n                bool r = solve(expression, index);\\n                res |= r;\\n            }\\n        }\\n        index++;\\n        return res;\\n    }\\n\\n    bool solveNotExpr(string& expression, int& index) {\\n        index += 2;\\n        bool r = solve(expression, index);\\n        index++;\\n        return !r;\\n    }\\n\\n    bool solveLetter(string& expression, int& index) {\\n        char c = expression[index];\\n        index++;\\n        if (c == \\'t\\')\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043509,
                "title": "typescript-best-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction parseBoolExpr(expression: string): boolean {\\n\\nlet stack = [];\\n\\nfor(let i=0; i<expression.length;i++)\\n{\\n\\n   if(expression[i]!=\")\" && expression[i]!=\",\" )\\n   {\\n      stack.push(expression[i]);\\n   }\\n   else if(expression[i]==\")\")\\n   {\\n     evaluate(stack)\\n   }\\n\\n}\\n\\nif(stack[0] == \\'t\\')\\n{\\nreturn true;\\n}\\n\\nreturn false;\\n\\n};\\n\\nfunction evaluate(stack:string[])\\n{\\n\\n     let operands = [];\\n     let top = stack.pop()\\n     \\n     if(top == \\'t\\' || top == \"f\")\\n     {\\n         operands.push(top);\\n     }\\n\\n     while(top != \"(\")\\n     {\\n        top = stack.pop()\\n     \\n        if(top == \\'t\\' || top == \"f\")\\n        {\\n         operands.push(top);\\n        }\\n\\n     }\\n\\n     let operator = stack.pop();\\n         //Evaluate\\n\\n     let true_count = 0;\\n     let false_count=0;\\n\\n     for(let i=0; i < operands.length; i++)\\n     {\\n         if(operands[i]==\"t\")\\n         {\\n             true_count++;\\n         }\\n         else\\n         {\\n            false_count++;\\n         }\\n     }\\n\\n     if(operator== \"|\")\\n     {\\n         if(true_count > 0)\\n         {\\n             stack.push(\\'t\\');\\n         }\\n         else\\n         {\\n             stack.push(\\'f\\');\\n         }\\n     }\\n     else if(operator== \"&\")\\n     {\\n         if(false_count > 0)\\n         {\\n             stack.push(\\'f\\');\\n         }\\n         else\\n         {\\n             stack.push(\\'t\\');\\n         }\\n     }\\n     else if(operator== \"!\")\\n     {\\n         if(true_count == 0)\\n         {\\n             stack.push(\\'t\\');\\n         }\\n         else\\n         {\\n              stack.push(\\'f\\');\\n         }\\n     }\\n\\n}\\n\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction parseBoolExpr(expression: string): boolean {\\n\\nlet stack = [];\\n\\nfor(let i=0; i<expression.length;i++)\\n{\\n\\n   if(expression[i]!=\")\" && expression[i]!=\",\" )\\n   {\\n      stack.push(expression[i]);\\n   }\\n   else if(expression[i]==\")\")\\n   {\\n     evaluate(stack)\\n   }\\n\\n}\\n\\nif(stack[0] == \\'t\\')\\n{\\nreturn true;\\n}\\n\\nreturn false;\\n\\n};\\n\\nfunction evaluate(stack:string[])\\n{\\n\\n     let operands = [];\\n     let top = stack.pop()\\n     \\n     if(top == \\'t\\' || top == \"f\")\\n     {\\n         operands.push(top);\\n     }\\n\\n     while(top != \"(\")\\n     {\\n        top = stack.pop()\\n     \\n        if(top == \\'t\\' || top == \"f\")\\n        {\\n         operands.push(top);\\n        }\\n\\n     }\\n\\n     let operator = stack.pop();\\n         //Evaluate\\n\\n     let true_count = 0;\\n     let false_count=0;\\n\\n     for(let i=0; i < operands.length; i++)\\n     {\\n         if(operands[i]==\"t\")\\n         {\\n             true_count++;\\n         }\\n         else\\n         {\\n            false_count++;\\n         }\\n     }\\n\\n     if(operator== \"|\")\\n     {\\n         if(true_count > 0)\\n         {\\n             stack.push(\\'t\\');\\n         }\\n         else\\n         {\\n             stack.push(\\'f\\');\\n         }\\n     }\\n     else if(operator== \"&\")\\n     {\\n         if(false_count > 0)\\n         {\\n             stack.push(\\'f\\');\\n         }\\n         else\\n         {\\n             stack.push(\\'t\\');\\n         }\\n     }\\n     else if(operator== \"!\")\\n     {\\n         if(true_count == 0)\\n         {\\n             stack.push(\\'t\\');\\n         }\\n         else\\n         {\\n              stack.push(\\'f\\');\\n         }\\n     }\\n\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039851,
                "title": "easy-to-understand-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> st;\\n\\n        for (int i = 0; i < expression.size(); i++) {\\n            int countt = 0;\\n            int countf = 0;\\n            if (expression[i] == \\',\\') \\n                continue;\\n\\n            if (expression[i] == \\')\\') {\\n                while (st.top() == \\'t\\' || st.top() == \\'f\\') {\\n                    if (st.top() == \\'t\\') {\\n                        countt++;\\n                    }\\n                    else {\\n                        countf++;\\n                    }\\n                    st.pop();\\n                }\\n                st.pop();\\n                if (st.top() == \\'|\\') {\\n                    st.pop();\\n                    if (countt)\\n                        st.push(\\'t\\');\\n                    else\\n                        st.push(\\'f\\');\\n                }\\n                else if (st.top() == \\'!\\') {\\n                    st.pop();\\n                    if (countt)\\n                        st.push(\\'f\\');\\n                    else\\n                        st.push(\\'t\\');\\n                }\\n                else {\\n                    st.pop();\\n                    if (countf)\\n                        st.push(\\'f\\');\\n                    else\\n                        st.push(\\'t\\');\\n                }\\n            }\\n            else\\n                st.push(expression[i]);\\n        }\\n\\n        return st.top() == \\'t\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> st;\\n\\n        for (int i = 0; i < expression.size(); i++) {\\n            int countt = 0;\\n            int countf = 0;\\n            if (expression[i] == \\',\\') \\n                continue;\\n\\n            if (expression[i] == \\')\\') {\\n                while (st.top() == \\'t\\' || st.top() == \\'f\\') {\\n                    if (st.top() == \\'t\\') {\\n                        countt++;\\n                    }\\n                    else {\\n                        countf++;\\n                    }\\n                    st.pop();\\n                }\\n                st.pop();\\n                if (st.top() == \\'|\\') {\\n                    st.pop();\\n                    if (countt)\\n                        st.push(\\'t\\');\\n                    else\\n                        st.push(\\'f\\');\\n                }\\n                else if (st.top() == \\'!\\') {\\n                    st.pop();\\n                    if (countt)\\n                        st.push(\\'f\\');\\n                    else\\n                        st.push(\\'t\\');\\n                }\\n                else {\\n                    st.pop();\\n                    if (countf)\\n                        st.push(\\'f\\');\\n                    else\\n                        st.push(\\'t\\');\\n                }\\n            }\\n            else\\n                st.push(expression[i]);\\n        }\\n\\n        return st.top() == \\'t\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030978,
                "title": "c-solution-easy-to-understand-using-stack",
                "content": "# Intuition\\nit is just like the problem valid paranthesis which is easy version of this ques.\\nYou can just think about solving each () baracket than you wil be come to know that this can be done by using stack.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to solve each baracket and again push the result to the stack as it may also be part of another previous bracket.\\n\\nexample\\n&(!(f)|(ftf));\\ninitially i will push all the char to stack till i encounter \\')\\'.\\nwhen i get ) then i will pop all the char from stack till first open baracket( and count f and t, now i will check the sign\\n\\n                char sn=s.top(); // sign \\n                s.pop();  //poping the sign\\n                if(sn==\\'|\\'){\\n                    if(t)s.push(\\'t\\');  // if ther is any true then push true in stack similarly for all;\\n                    else s.push(\\'f\\');\\n                }\\n                else if(sn==\\'&\\'){\\n                    if(f==0)s.push(\\'t\\');\\n                    else s.push(\\'f\\');\\n                }\\n                else if(sn==\\'!\\'){\\n                    if(f)s.push(\\'t\\');\\n                    else s.push(\\'f\\');\\n                }\\n\\n# Complexity\\n- Time complexity:\\n- O(n);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n) as one stack is required.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string a) {\\n        stack<char> s;\\n        int n=a.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]!=\\')\\')s.push(a[i]);\\n            else {\\n                int t=0,f=0;\\n                while(s.empty() || s.top()!=\\'(\\'){\\n                    char cur=s.top();s.pop();\\n                    if(cur==\\'t\\')t++;\\n                    else if(cur==\\'f\\') f++;\\n                }\\n                s.pop();\\n                char sn=s.top();\\n                s.pop();\\n                if(sn==\\'|\\'){\\n                    if(t)s.push(\\'t\\');\\n                    else s.push(\\'f\\');\\n                }\\n                else if(sn==\\'&\\'){\\n                    if(f==0)s.push(\\'t\\');\\n                    else s.push(\\'f\\');\\n                }\\n                else if(sn==\\'!\\'){\\n                    if(f)s.push(\\'t\\');\\n                    else s.push(\\'f\\');\\n                }\\n            }\\n        }\\n        return s.top()==\\'t\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string a) {\\n        stack<char> s;\\n        int n=a.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]!=\\')\\')s.push(a[i]);\\n            else {\\n                int t=0,f=0;\\n                while(s.empty() || s.top()!=\\'(\\'){\\n                    char cur=s.top();s.pop();\\n                    if(cur==\\'t\\')t++;\\n                    else if(cur==\\'f\\') f++;\\n                }\\n                s.pop();\\n                char sn=s.top();\\n                s.pop();\\n                if(sn==\\'|\\'){\\n                    if(t)s.push(\\'t\\');\\n                    else s.push(\\'f\\');\\n                }\\n                else if(sn==\\'&\\'){\\n                    if(f==0)s.push(\\'t\\');\\n                    else s.push(\\'f\\');\\n                }\\n                else if(sn==\\'!\\'){\\n                    if(f)s.push(\\'t\\');\\n                    else s.push(\\'f\\');\\n                }\\n            }\\n        }\\n        return s.top()==\\'t\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023175,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> st;\\n        int t,f;\\n        for(auto i:expression){\\n            if(i==\\')\\'){\\n                t=0;\\n                f=0;\\n                while(st.top()!=\\'(\\' ){ \\n                    if(st.top()==\\'t\\') t++;\\n                    if(st.top()==\\'f\\') f++;\\n                    st.pop();\\n                    }\\n                st.pop();\\n                if(st.top()==\\'&\\'){\\n                    st.pop();\\n                    if(f==0) st.push(\\'t\\');\\n                    else st.push(\\'f\\');\\n                }\\n                else if(st.top()==\\'|\\'){\\n                    st.pop();\\n                    if(t==0) st.push(\\'f\\');\\n                    else st.push(\\'t\\');\\n                }\\n                else if(st.top()==\\'!\\'){\\n                    st.pop();\\n                    if(f==1) st.push(\\'t\\');\\n                    else st.push(\\'f\\');\\n                }\\n\\n            }\\n            else{\\n                if(i!=\\',\\') st.push(i);\\n            }\\n        }\\n        return st.top() == \\'t\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> st;\\n        int t,f;\\n        for(auto i:expression){\\n            if(i==\\')\\'){\\n                t=0;\\n                f=0;\\n                while(st.top()!=\\'(\\' ){ \\n                    if(st.top()==\\'t\\') t++;\\n                    if(st.top()==\\'f\\') f++;\\n                    st.pop();\\n                    }\\n                st.pop();\\n                if(st.top()==\\'&\\'){\\n                    st.pop();\\n                    if(f==0) st.push(\\'t\\');\\n                    else st.push(\\'f\\');\\n                }\\n                else if(st.top()==\\'|\\'){\\n                    st.pop();\\n                    if(t==0) st.push(\\'f\\');\\n                    else st.push(\\'t\\');\\n                }\\n                else if(st.top()==\\'!\\'){\\n                    st.pop();\\n                    if(f==1) st.push(\\'t\\');\\n                    else st.push(\\'f\\');\\n                }\\n\\n            }\\n            else{\\n                if(i!=\\',\\') st.push(i);\\n            }\\n        }\\n        return st.top() == \\'t\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021600,
                "title": "c-solution-o-n-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(n) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool ParseBoolExpr(string expression) {\\n        Stack<char> stack = new();\\n        int j=expression.Length-1;\\n\\n        while(j >= 0){\\n            while(j >= 0 && (expression[j] == \\')\\' || expression[j] == \\',\\')){\\n                if(expression[j] == \\')\\'){\\n                    stack.Push(expression[j]);\\n                }\\n\\n                j--;\\n            }\\n\\n            while(j >= 0 && expression[j] != \\'(\\'){\\n                if(expression[j] != \\',\\'){\\n                    stack.Push(expression[j]);\\n                }\\n\\n                j--;\\n            }\\n\\n            if(expression[j] == \\'(\\'){\\n                j--;\\n            }\\n\\n            var op = expression[j--];\\n\\n            // Console.WriteLine($\"Before: stack.Count={stack.Count}, op={op}\");\\n\\n            if(op == \\'|\\' || op == \\'&\\'){\\n                bool tFound = false, fFound=false;\\n\\n                while(stack.Peek() != \\')\\'){\\n                    // Console.WriteLine($\"stack.Peek() = {stack.Peek()}, stack.Count={stack.Count}\");\\n                    tFound = tFound || stack.Peek() == \\'t\\';\\n                    fFound = stack.Pop() == \\'f\\' || fFound;\\n                }\\n\\n                stack.Pop();\\n                if(op == \\'|\\'){\\n                    stack.Push(tFound ? \\'t\\' : \\'f\\');\\n                }\\n                else if(op == \\'&\\'){\\n                    stack.Push(fFound ? \\'f\\' : \\'t\\');\\n                }\\n            }\\n            else{\\n                var top = stack.Pop();\\n                stack.Pop();\\n                stack.Push(top == \\'t\\' ? \\'f\\' : \\'t\\');\\n            }\\n\\n            // Console.WriteLine($\"stack.Count = {stack.Count}\");\\n        }\\n        \\n        return stack.Pop() == \\'t\\' ? true : false;\\n    }\\n}\\n\\n/*\\n\\n\\n\"|(f,f,f,t)\"\\n\"!(&(f,t))\"\\n\"!(&(!(t),&(f),|(f)))\"\\n\\n*/\\n```",
                "solutionTags": [
                    "C#",
                    "String",
                    "Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public bool ParseBoolExpr(string expression) {\\n        Stack<char> stack = new();\\n        int j=expression.Length-1;\\n\\n        while(j >= 0){\\n            while(j >= 0 && (expression[j] == \\')\\' || expression[j] == \\',\\')){\\n                if(expression[j] == \\')\\'){\\n                    stack.Push(expression[j]);\\n                }\\n\\n                j--;\\n            }\\n\\n            while(j >= 0 && expression[j] != \\'(\\'){\\n                if(expression[j] != \\',\\'){\\n                    stack.Push(expression[j]);\\n                }\\n\\n                j--;\\n            }\\n\\n            if(expression[j] == \\'(\\'){\\n                j--;\\n            }\\n\\n            var op = expression[j--];\\n\\n            // Console.WriteLine($\"Before: stack.Count={stack.Count}, op={op}\");\\n\\n            if(op == \\'|\\' || op == \\'&\\'){\\n                bool tFound = false, fFound=false;\\n\\n                while(stack.Peek() != \\')\\'){\\n                    // Console.WriteLine($\"stack.Peek() = {stack.Peek()}, stack.Count={stack.Count}\");\\n                    tFound = tFound || stack.Peek() == \\'t\\';\\n                    fFound = stack.Pop() == \\'f\\' || fFound;\\n                }\\n\\n                stack.Pop();\\n                if(op == \\'|\\'){\\n                    stack.Push(tFound ? \\'t\\' : \\'f\\');\\n                }\\n                else if(op == \\'&\\'){\\n                    stack.Push(fFound ? \\'f\\' : \\'t\\');\\n                }\\n            }\\n            else{\\n                var top = stack.Pop();\\n                stack.Pop();\\n                stack.Push(top == \\'t\\' ? \\'f\\' : \\'t\\');\\n            }\\n\\n            // Console.WriteLine($\"stack.Count = {stack.Count}\");\\n        }\\n        \\n        return stack.Pop() == \\'t\\' ? true : false;\\n    }\\n}\\n\\n/*\\n\\n\\n\"|(f,f,f,t)\"\\n\"!(&(f,t))\"\\n\"!(&(!(t),&(f),|(f)))\"\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016282,
                "title": "stack-implementation-easy-to-follow",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool ParseBoolExpr(string expression) { \\n        Stack<char> stkSymbol = new Stack<char>();\\n        Stack<char> stkChar = new Stack<char>();\\n        char AND = \\'&\\', OR = \\'|\\', NOT = \\'!\\', CLOSE = \\')\\', TRUE = \\'t\\', FALSE = \\'f\\', OPEN = \\'(\\';\\n\\n        HashSet<char> hsSymbol = new HashSet<char>(){\\'&\\', \\'|\\', \\'!\\'};\\n        HashSet<char> hsChar = new HashSet<char>(){\\'(\\', \\'t\\', \\'f\\'};\\n\\n        foreach(char c in expression){\\n            if(hsSymbol.Contains(c)){\\n                stkSymbol.Push(c);\\n                continue;\\n            }\\n\\n            if(hsChar.Contains(c)){\\n                stkChar.Push(c);\\n                continue;\\n            }\\n\\n            if(c == CLOSE){\\n                char symbolToBeApplied = stkSymbol.Pop();\\n                char fetchedElement = stkChar.Pop();\\n                bool computedResult = fetchedElement == TRUE? true : false;\\n\\n                if(symbolToBeApplied == NOT)\\n                    computedResult = !computedResult;\\n\\n                while(stkChar.Peek() != OPEN){\\n                    fetchedElement = stkChar.Pop();\\n                    bool tempComputedResult = fetchedElement == TRUE? true : false;\\n\\n                    if(symbolToBeApplied == AND)\\n                        computedResult &= tempComputedResult;\\n                    else if(symbolToBeApplied == OR)\\n                        computedResult |= tempComputedResult;\\n                }\\n\\n                stkChar.Pop();\\n                char charComputedResult = computedResult ? TRUE : FALSE;\\n                stkChar.Push(charComputedResult);\\n            }\\n        }\\n\\n        return stkChar.Peek() == TRUE? true : false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "String",
                    "Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public bool ParseBoolExpr(string expression) { \\n        Stack<char> stkSymbol = new Stack<char>();\\n        Stack<char> stkChar = new Stack<char>();\\n        char AND = \\'&\\', OR = \\'|\\', NOT = \\'!\\', CLOSE = \\')\\', TRUE = \\'t\\', FALSE = \\'f\\', OPEN = \\'(\\';\\n\\n        HashSet<char> hsSymbol = new HashSet<char>(){\\'&\\', \\'|\\', \\'!\\'};\\n        HashSet<char> hsChar = new HashSet<char>(){\\'(\\', \\'t\\', \\'f\\'};\\n\\n        foreach(char c in expression){\\n            if(hsSymbol.Contains(c)){\\n                stkSymbol.Push(c);\\n                continue;\\n            }\\n\\n            if(hsChar.Contains(c)){\\n                stkChar.Push(c);\\n                continue;\\n            }\\n\\n            if(c == CLOSE){\\n                char symbolToBeApplied = stkSymbol.Pop();\\n                char fetchedElement = stkChar.Pop();\\n                bool computedResult = fetchedElement == TRUE? true : false;\\n\\n                if(symbolToBeApplied == NOT)\\n                    computedResult = !computedResult;\\n\\n                while(stkChar.Peek() != OPEN){\\n                    fetchedElement = stkChar.Pop();\\n                    bool tempComputedResult = fetchedElement == TRUE? true : false;\\n\\n                    if(symbolToBeApplied == AND)\\n                        computedResult &= tempComputedResult;\\n                    else if(symbolToBeApplied == OR)\\n                        computedResult |= tempComputedResult;\\n                }\\n\\n                stkChar.Pop();\\n                char charComputedResult = computedResult ? TRUE : FALSE;\\n                stkChar.Push(charComputedResult);\\n            }\\n        }\\n\\n        return stkChar.Peek() == TRUE? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007978,
                "title": "java-solution-with-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Stack<Character> stk = new Stack();\\n    public boolean parseBoolExpr(String expression) {\\n        for (int i = 0; i < expression.length(); i++) {\\n            char c = expression.charAt(i);\\n            if (c == \\',\\') continue;\\n            if (c == \\')\\') {\\n                List<Boolean> operandList = new ArrayList();\\n                while (true) {\\n                    char popped = (char) stk.pop();\\n                    if (popped == \\'t\\') operandList.add(true);\\n                    else if (popped == \\'f\\') operandList.add(false);\\n                    else if (popped == \\'(\\') break;\\n                }\\n                char operator = stk.pop();\\n                stk.push(evaluate(operator, operandList));\\n            } else {\\n                stk.push(c);\\n            }\\n        }\\n        char remaining = stk.pop();\\n        if (remaining == \\'t\\') return true;\\n        return false;\\n    }\\n\\n    private char evaluate(char operator, List<Boolean> operandList) {\\n        if (operator == \\'!\\') {\\n            if (operandList.get(0)) return \\'f\\';\\n            return \\'t\\';\\n        }\\n\\n        boolean ret = false;\\n        if (operandList.get(0)) ret = true;\\n        for (int i = 1; i < operandList.size(); i++) {\\n            if (operator == \\'&\\') {\\n                ret = ret && operandList.get(i);\\n            } else if (operator == \\'|\\') {\\n                ret = ret || operandList.get(i);\\n            }\\n        } \\n        if (ret) return \\'t\\';\\n        return \\'f\\';\\n    }\\n}\\n\\n/*\\nuse a stack\\nwhenever you see a close bracket we will pop the stack up to the last open bracket\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    Stack<Character> stk = new Stack();\\n    public boolean parseBoolExpr(String expression) {\\n        for (int i = 0; i < expression.length(); i++) {\\n            char c = expression.charAt(i);\\n            if (c == \\',\\') continue;\\n            if (c == \\')\\') {\\n                List<Boolean> operandList = new ArrayList();\\n                while (true) {\\n                    char popped = (char) stk.pop();\\n                    if (popped == \\'t\\') operandList.add(true);\\n                    else if (popped == \\'f\\') operandList.add(false);\\n                    else if (popped == \\'(\\') break;\\n                }\\n                char operator = stk.pop();\\n                stk.push(evaluate(operator, operandList));\\n            } else {\\n                stk.push(c);\\n            }\\n        }\\n        char remaining = stk.pop();\\n        if (remaining == \\'t\\') return true;\\n        return false;\\n    }\\n\\n    private char evaluate(char operator, List<Boolean> operandList) {\\n        if (operator == \\'!\\') {\\n            if (operandList.get(0)) return \\'f\\';\\n            return \\'t\\';\\n        }\\n\\n        boolean ret = false;\\n        if (operandList.get(0)) ret = true;\\n        for (int i = 1; i < operandList.size(); i++) {\\n            if (operator == \\'&\\') {\\n                ret = ret && operandList.get(i);\\n            } else if (operator == \\'|\\') {\\n                ret = ret || operandList.get(i);\\n            }\\n        } \\n        if (ret) return \\'t\\';\\n        return \\'f\\';\\n    }\\n}\\n\\n/*\\nuse a stack\\nwhenever you see a close bracket we will pop the stack up to the last open bracket\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966074,
                "title": "using-stack-easy-intuitive-approach",
                "content": "# Intuition\\nJust treat it like valid parenthesis question.\\n\\n# Approach\\nBy this I mean evaluate for each parenthesis as soon as it completes and then pop all those values from stack and insert your evaluated value in it. For eg: |(&(t,f,t),!(t)) -> Here we will keep on inserting values till we get a closed parentheis i.e. \\')\\' then we will evaluate value of function by popping elements from stack till st.top() != \\'(\\' finally get the operation on which we have to evaluate that is &,|,!. I creted seperate function for evaluation.\\n\\n# Complexity\\n- Time complexity: O(3*n)\\n\\n\\n- Space complexity: O(2*n), Stack space & temporary vector space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool give(char ch){\\n        if(ch==\\'f\\') return false;\\n        return true;\\n    }\\n    //Evaluates value of expression.\\n    bool get(vector<char> v, char ch){\\n        if(ch==\\'&\\'){\\n            for(int i = 0;i<v.size();++i){\\n                if(!give(v[i])) return false;\\n            }\\n            return true;\\n        }\\n        else if(ch==\\'|\\'){\\n            for(int i = 0;i<v.size();++i){\\n                if(give(v[i])) return true;\\n            }\\n            return false;\\n        }\\n        return !give(v[0]);\\n    }\\n    \\n    bool remove(stack<char> &st){\\n        vector<char> v;\\n        while(st.top()!=\\'(\\'){\\n            v.push_back(st.top());\\n            st.pop();\\n        }\\n        st.pop();\\n        char ch = st.top();\\n        st.pop();\\n        return get(v,ch);\\n    }\\n\\n    bool check(string s, int n){\\n        stack<char> st;\\n        int i = 0;\\n        //char ch;\\n        while(i<n){\\n            // if(s[i]==\\'&\\' || s[i]==\\'|\\' || s[i]==\\'!\\') ch = s[i];\\n            if(s[i] == \\')\\'){\\n                if(remove(st)) st.push(\\'t\\');\\n                else st.push(\\'f\\');\\n            }\\n            else if(s[i]==\\',\\');\\n            else st.push(s[i]);\\n            i++;\\n        }\\n        return give(st.top());\\n    }\\n\\n    bool parseBoolExpr(string exp) {\\n        return check(exp,exp.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool give(char ch){\\n        if(ch==\\'f\\') return false;\\n        return true;\\n    }\\n    //Evaluates value of expression.\\n    bool get(vector<char> v, char ch){\\n        if(ch==\\'&\\'){\\n            for(int i = 0;i<v.size();++i){\\n                if(!give(v[i])) return false;\\n            }\\n            return true;\\n        }\\n        else if(ch==\\'|\\'){\\n            for(int i = 0;i<v.size();++i){\\n                if(give(v[i])) return true;\\n            }\\n            return false;\\n        }\\n        return !give(v[0]);\\n    }\\n    \\n    bool remove(stack<char> &st){\\n        vector<char> v;\\n        while(st.top()!=\\'(\\'){\\n            v.push_back(st.top());\\n            st.pop();\\n        }\\n        st.pop();\\n        char ch = st.top();\\n        st.pop();\\n        return get(v,ch);\\n    }\\n\\n    bool check(string s, int n){\\n        stack<char> st;\\n        int i = 0;\\n        //char ch;\\n        while(i<n){\\n            // if(s[i]==\\'&\\' || s[i]==\\'|\\' || s[i]==\\'!\\') ch = s[i];\\n            if(s[i] == \\')\\'){\\n                if(remove(st)) st.push(\\'t\\');\\n                else st.push(\\'f\\');\\n            }\\n            else if(s[i]==\\',\\');\\n            else st.push(s[i]);\\n            i++;\\n        }\\n        return give(st.top());\\n    }\\n\\n    bool parseBoolExpr(string exp) {\\n        return check(exp,exp.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958036,
                "title": "java-intuitive-easy-iterative-solution",
                "content": "# Intuition: Use Stack\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean parseBoolExpr(String expression) {\\n        Stack<Character> others = new Stack<>();\\n        Stack<Character> operators = new Stack<>();\\n        char expressionArr[] = expression.toCharArray();\\n\\n        for(char character : expressionArr){\\n            if(character == \\',\\'){\\n                continue;\\n            } else if(character == \\'(\\' || character == \\'t\\' || character == \\'f\\'){\\n                others.push(character);\\n            } else if(character == \\'!\\' || character == \\'&\\' || character == \\'|\\'){\\n                operators.push(character);\\n            } else {\\n                if(operators.peek() == \\'!\\'){\\n                    operators.pop();\\n                    others.push(evaluateNegation(others));\\n                } else if(operators.peek() == \\'&\\'){\\n                    operators.pop();\\n                    others.push(evaluateAND(others));\\n                } else {\\n                    operators.pop();\\n                    others.push(evaluateOR(others));\\n                }\\n            }\\n        }\\n        \\n        return others.pop() == \\'t\\';\\n    }\\n\\n    private static char evaluateNegation(Stack<Character> stack){\\n        char finalAns = stack.pop() == \\'t\\' ? \\'f\\' : \\'t\\';\\n        stack.pop();\\n        return finalAns;\\n    }\\n\\n    private static char evaluateOR(Stack<Character> stack){\\n        char finalAns = \\'f\\';\\n        while(stack.peek() != \\'(\\'){\\n            char poppedChar = stack.pop();\\n            if(poppedChar == \\'t\\'){\\n                finalAns = \\'t\\';\\n            }\\n        }\\n        stack.pop();\\n        return finalAns;\\n    }\\n\\n    private static char evaluateAND(Stack<Character> stack){\\n        char finalAns = \\'t\\';\\n        while(stack.peek() != \\'(\\'){\\n            char poppedChar = stack.pop();\\n            if(poppedChar == \\'f\\'){\\n                finalAns = \\'f\\';\\n            }\\n        }\\n        stack.pop();\\n        return finalAns;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean parseBoolExpr(String expression) {\\n        Stack<Character> others = new Stack<>();\\n        Stack<Character> operators = new Stack<>();\\n        char expressionArr[] = expression.toCharArray();\\n\\n        for(char character : expressionArr){\\n            if(character == \\',\\'){\\n                continue;\\n            } else if(character == \\'(\\' || character == \\'t\\' || character == \\'f\\'){\\n                others.push(character);\\n            } else if(character == \\'!\\' || character == \\'&\\' || character == \\'|\\'){\\n                operators.push(character);\\n            } else {\\n                if(operators.peek() == \\'!\\'){\\n                    operators.pop();\\n                    others.push(evaluateNegation(others));\\n                } else if(operators.peek() == \\'&\\'){\\n                    operators.pop();\\n                    others.push(evaluateAND(others));\\n                } else {\\n                    operators.pop();\\n                    others.push(evaluateOR(others));\\n                }\\n            }\\n        }\\n        \\n        return others.pop() == \\'t\\';\\n    }\\n\\n    private static char evaluateNegation(Stack<Character> stack){\\n        char finalAns = stack.pop() == \\'t\\' ? \\'f\\' : \\'t\\';\\n        stack.pop();\\n        return finalAns;\\n    }\\n\\n    private static char evaluateOR(Stack<Character> stack){\\n        char finalAns = \\'f\\';\\n        while(stack.peek() != \\'(\\'){\\n            char poppedChar = stack.pop();\\n            if(poppedChar == \\'t\\'){\\n                finalAns = \\'t\\';\\n            }\\n        }\\n        stack.pop();\\n        return finalAns;\\n    }\\n\\n    private static char evaluateAND(Stack<Character> stack){\\n        char finalAns = \\'t\\';\\n        while(stack.peek() != \\'(\\'){\\n            char poppedChar = stack.pop();\\n            if(poppedChar == \\'f\\'){\\n                finalAns = \\'f\\';\\n            }\\n        }\\n        stack.pop();\\n        return finalAns;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955710,
                "title": "stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe key of this problem is operators like `!,&,|` must on the left of `(`\\nHere\\'s a breakdown of the function\\'s logic:\\n\\nInitialize an empty stack.\\n\\nIterate over each character in the expression.\\n\\nIf the stack is empty or the current character is not a closing parenthesis ()), push the character onto the stack.\\n\\nIf the current character is a closing parenthesis:\\n    Initialize an empty temp list to hold the contents between the opening and closing parentheses.\\n    Pop characters off the stack until an opening parenthesis (() is encountered. Store these characters in the temp list and pop the opening parenthesis.\\n    Pop the next character off the stack. This will be the operator (!, &, or |).\\n    Depending on the operator, evaluate the contents of the temp list and push the result onto the stack:\\n\\n        If the operator is !, it\\'s a NOT operation, so if the first (and only) character in temp is f, push t onto the stack, otherwise push f.\\n\\n        If the operator is &, it\\'s an AND operation, so if f is not in temp, push t onto the stack, otherwise push f.\\n\\n        If the operator is |, it\\'s an OR operation, so if t is in temp, push t onto the stack, otherwise push f.\\n\\nAfter processing the entire expression, the stack should have one item which is the result of evaluating the Boolean expression.\\nReturn True if the result is t, otherwise return False.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        for i in expression:\\n            if not stack or i != \")\":\\n                stack.append(i)\\n            else:\\n                temp = []\\n                while stack[-1] != \"(\":\\n                    temp.append(stack.pop())\\n                stack.pop()\\n                op = stack.pop()\\n                if op == \"!\":\\n                    stack.append(\"t\" if temp[0] == \"f\" else \"f\")\\n                elif op == \"&\":\\n                    stack.append(\"t\" if \"f\" not in temp else \"f\")\\n                elif op == \"|\":\\n                    stack.append(\"t\" if \"t\" in temp else \"f\")\\n        return stack[0] == \"t\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        for i in expression:\\n            if not stack or i != \")\":\\n                stack.append(i)\\n            else:\\n                temp = []\\n                while stack[-1] != \"(\":\\n                    temp.append(stack.pop())\\n                stack.pop()\\n                op = stack.pop()\\n                if op == \"!\":\\n                    stack.append(\"t\" if temp[0] == \"f\" else \"f\")\\n                elif op == \"&\":\\n                    stack.append(\"t\" if \"f\" not in temp else \"f\")\\n                elif op == \"|\":\\n                    stack.append(\"t\" if \"t\" in temp else \"f\")\\n        return stack[0] == \"t\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954404,
                "title": "fast-easy-to-understand-recursive-solution-beats-100-speed",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} expression\\n * @return {boolean}\\n */\\nvar parseBoolExpr = function(expression) {\\n        const helper = function (index) {\\n            let sign = expression[index];\\n            if (sign === \\'t\\' || sign === \\'f\\') return [index, sign === \\'t\\']\\n            index += 2;\\n            let booleans = []\\n            while(true){\\n                let [processedIndex, bool] = helper(index);\\n                booleans.push(bool)\\n                index = processedIndex;\\n                if(expression[index+1] === \\')\\') break;\\n                index += 2;\\n            }\\n            index++;\\n            switch (sign) {\\n                case \\'!\\':\\n                    return [index, !booleans[0]]\\n                case \\'&\\':\\n                    return [index, booleans.every(e=> e)]\\n                case \\'|\\':\\n                    return [index, booleans.some(e=> e)]\\n            }\\n        }\\n        return helper(0)[1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} expression\\n * @return {boolean}\\n */\\nvar parseBoolExpr = function(expression) {\\n        const helper = function (index) {\\n            let sign = expression[index];\\n            if (sign === \\'t\\' || sign === \\'f\\') return [index, sign === \\'t\\']\\n            index += 2;\\n            let booleans = []\\n            while(true){\\n                let [processedIndex, bool] = helper(index);\\n                booleans.push(bool)\\n                index = processedIndex;\\n                if(expression[index+1] === \\')\\') break;\\n                index += 2;\\n            }\\n            index++;\\n            switch (sign) {\\n                case \\'!\\':\\n                    return [index, !booleans[0]]\\n                case \\'&\\':\\n                    return [index, booleans.every(e=> e)]\\n                case \\'|\\':\\n                    return [index, booleans.some(e=> e)]\\n            }\\n        }\\n        return helper(0)[1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3895534,
                "title": "short-and-simple-using-stack",
                "content": "```\\nclass Solution {\\npublic: \\n    char expVal(int t, int f, char op){\\n        if(op==\\'&\\') return f?\\'f\\':\\'t\\';\\n        if(op==\\'|\\') return t?\\'t\\':\\'f\\';\\n        return t?\\'f\\':\\'t\\';\\n    }\\n    \\n    bool parseBoolExpr(string exp) {\\n        set<char> isOp={\\'&\\', \\'|\\', \\'!\\'};\\n        stack<char> op, e;\\n\\n        for(int i=0; i<exp.size(); i++){\\n            if(exp[i]==\\',\\') continue;\\n            \\n            if(exp[i]==\\')\\'){\\n                int ct=0, cf=0;\\n                while(e.top()!=\\'(\\'){\\n                    ct+=e.top()==\\'t\\';\\n                    cf+=e.top()==\\'f\\';\\n                    e.pop();\\n                }\\n                e.pop();\\n                e.push(expVal(ct, cf, op.top()));\\n                op.pop();\\n            }\\n            else if(isOp.count(exp[i])) op.push(exp[i]);\\n            else e.push(exp[i]);\\n        }\\n        return e.top()==\\'t\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    char expVal(int t, int f, char op){\\n        if(op==\\'&\\') return f?\\'f\\':\\'t\\';\\n        if(op==\\'|\\') return t?\\'t\\':\\'f\\';\\n        return t?\\'f\\':\\'t\\';\\n    }\\n    \\n    bool parseBoolExpr(string exp) {\\n        set<char> isOp={\\'&\\', \\'|\\', \\'!\\'};\\n        stack<char> op, e;\\n\\n        for(int i=0; i<exp.size(); i++){\\n            if(exp[i]==\\',\\') continue;\\n            \\n            if(exp[i]==\\')\\'){\\n                int ct=0, cf=0;\\n                while(e.top()!=\\'(\\'){\\n                    ct+=e.top()==\\'t\\';\\n                    cf+=e.top()==\\'f\\';\\n                    e.pop();\\n                }\\n                e.pop();\\n                e.push(expVal(ct, cf, op.top()));\\n                op.pop();\\n            }\\n            else if(isOp.count(exp[i])) op.push(exp[i]);\\n            else e.push(exp[i]);\\n        }\\n        return e.top()==\\'t\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886472,
                "title": "best-and-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string e) {\\n        auto it = e.begin();\\n        return parse(it);\\n    }\\n\\n    bool parse(string::iterator& it) {\\n        switch (*(it++)) {\\n            case \\'t\\': return true;\\n            case \\'f\\': return false;\\n            case \\'|\\': return parse(it, false, [](bool init, bool val){ return init || val; });\\n            case \\'&\\': return parse(it, true,  [](bool init, bool val){ return init && val; });\\n            case \\'!\\': return parse(it, false, [](bool init, bool val){ return !val; });\\n        }\\n        return false;\\n    }\\n\\n    bool parse(string::iterator& it, bool init, function<bool(bool, bool)> op) {\\n        it++; \\n        while (true) {\\n            auto b = parse(it);\\n            init = op(init, b);\\n            if (*it == \\')\\') break;\\n            it++; \\n        }\\n        it++; \\n        return init;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string e) {\\n        auto it = e.begin();\\n        return parse(it);\\n    }\\n\\n    bool parse(string::iterator& it) {\\n        switch (*(it++)) {\\n            case \\'t\\': return true;\\n            case \\'f\\': return false;\\n            case \\'|\\': return parse(it, false, [](bool init, bool val){ return init || val; });\\n            case \\'&\\': return parse(it, true,  [](bool init, bool val){ return init && val; });\\n            case \\'!\\': return parse(it, false, [](bool init, bool val){ return !val; });\\n        }\\n        return false;\\n    }\\n\\n    bool parse(string::iterator& it, bool init, function<bool(bool, bool)> op) {\\n        it++; \\n        while (true) {\\n            auto b = parse(it);\\n            init = op(init, b);\\n            if (*it == \\')\\') break;\\n            it++; \\n        }\\n        it++; \\n        return init;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873554,
                "title": "javascript-o-n",
                "content": "# Intuition\\nTo evaluates expression best thing to do is to thing about stack\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Push every character into stack expect `,`.\\n- If we encounter `)` pop it from the stack and store in set.\\n- Then one more char from stack so that it remove `(`\\n- Now pop one more character because it will operation which we have to perform\\n- Using this operation find `t` or `f` and store it in stack.\\n- When return from check stack last elemet whether it\\'s `t` or `f`\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} expression\\n * @return {boolean}\\n */\\nvar parseBoolExpr = function(expression) {\\n    let stack = []; \\n    for(let i = 0; i < expression.length; i++) {\\n        const char = expression[i];\\n        if (char === \\')\\') {\\n            let _seen = new Set();\\n            while(stack.at(-1) !== \\'(\\'){\\n                _seen.add(stack.pop());\\n            }\\n            stack.pop();\\n            const operator = stack.pop();\\n            if(operator === \\'&\\') {\\n                stack.push(_seen.has(\\'f\\') ? \\'f\\' : \\'t\\');\\n            } else if (operator === \\'|\\') {\\n                stack.push(_seen.has(\\'t\\') ? \\'t\\' : \\'f\\');\\n            } else {\\n                 stack.push(_seen.has(\\'t\\') ? \\'f\\' : \\'t\\');\\n            }\\n        } else if (char !== \\',\\') {\\n            stack.push(char)\\n        }\\n    }\\n    return stack.pop() == \\'t\\';\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} expression\\n * @return {boolean}\\n */\\nvar parseBoolExpr = function(expression) {\\n    let stack = []; \\n    for(let i = 0; i < expression.length; i++) {\\n        const char = expression[i];\\n        if (char === \\')\\') {\\n            let _seen = new Set();\\n            while(stack.at(-1) !== \\'(\\'){\\n                _seen.add(stack.pop());\\n            }\\n            stack.pop();\\n            const operator = stack.pop();\\n            if(operator === \\'&\\') {\\n                stack.push(_seen.has(\\'f\\') ? \\'f\\' : \\'t\\');\\n            } else if (operator === \\'|\\') {\\n                stack.push(_seen.has(\\'t\\') ? \\'t\\' : \\'f\\');\\n            } else {\\n                 stack.push(_seen.has(\\'t\\') ? \\'f\\' : \\'t\\');\\n            }\\n        } else if (char !== \\',\\') {\\n            stack.push(char)\\n        }\\n    }\\n    return stack.pop() == \\'t\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3854174,
                "title": "java-just-normal-stack-operation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> st = new Stack<Character>();\\n\\n        for(int i = expression.length()-1;i>=0;i--){\\n            //only one element, just push the opposite into the stack\\n            if(expression.charAt(i)==\\'!\\'){\\n                st.pop();//(\\n                char temp = st.pop();\\n                st.pop();//)\\n                if(temp==\\'t\\') st.push(\\'f\\');\\n                else st.push(\\'t\\');\\n            }\\n\\n            //initialise a \"false\", if there is one \"true\", the result is true\\n            else if(expression.charAt(i)==\\'|\\'){\\n                st.pop();//(\\n                char temp = \\'f\\';\\n                while(st.peek()!=\\')\\'){\\n                    if(st.pop()==\\'t\\'){\\n                        temp = \\'t\\';\\n                        \\n                    }\\n\\n                }\\n                st.pop();//)\\n                st.push(temp);\\n\\n            }\\n\\n            //initialise a \"true\", if there is one \"false\", the result is false\\n            else if(expression.charAt(i)==\\'&\\'){\\n                st.pop();//(\\n                char temp = \\'t\\';\\n                while(st.peek()!=\\')\\'){\\n                    if(st.pop()==\\'f\\'){\\n                        temp = \\'f\\';\\n                        \\n                    }\\n\\n                }\\n                st.pop();//)\\n                st.push(temp);\\n            }\\n            else\\n                st.push(expression.charAt(i));\\n        }\\n\\n        return st.peek()==\\'t\\'; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> st = new Stack<Character>();\\n\\n        for(int i = expression.length()-1;i>=0;i--){\\n            //only one element, just push the opposite into the stack\\n            if(expression.charAt(i)==\\'!\\'){\\n                st.pop();//(\\n                char temp = st.pop();\\n                st.pop();//)\\n                if(temp==\\'t\\') st.push(\\'f\\');\\n                else st.push(\\'t\\');\\n            }\\n\\n            //initialise a \"false\", if there is one \"true\", the result is true\\n            else if(expression.charAt(i)==\\'|\\'){\\n                st.pop();//(\\n                char temp = \\'f\\';\\n                while(st.peek()!=\\')\\'){\\n                    if(st.pop()==\\'t\\'){\\n                        temp = \\'t\\';\\n                        \\n                    }\\n\\n                }\\n                st.pop();//)\\n                st.push(temp);\\n\\n            }\\n\\n            //initialise a \"true\", if there is one \"false\", the result is false\\n            else if(expression.charAt(i)==\\'&\\'){\\n                st.pop();//(\\n                char temp = \\'t\\';\\n                while(st.peek()!=\\')\\'){\\n                    if(st.pop()==\\'f\\'){\\n                        temp = \\'f\\';\\n                        \\n                    }\\n\\n                }\\n                st.pop();//)\\n                st.push(temp);\\n            }\\n            else\\n                st.push(expression.charAt(i));\\n        }\\n\\n        return st.peek()==\\'t\\'; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854019,
                "title": "python-easy-to-undestand-solution-using-two-stacks-prefix-expression",
                "content": "# Code\\n```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        operands = []\\n        operators = []\\n        b = {\"f\": False, \"t\": True, \"(\": \"(\"}\\n        for i in range(len(expression)):\\n            if expression[i] in \"(ft\":\\n                operands.append(b[expression[i]])\\n            elif expression[i] in \"!&|\":\\n                operators.append(expression[i])\\n            elif expression[i] == \")\":\\n                c = []\\n                while operands and operands[-1] != \"(\":\\n                    c.append(operands.pop())\\n                operands.pop()\\n                val = None\\n                if operators[-1] == \"&\":\\n                    val = True\\n                    for x in c:\\n                        val = val and x\\n                elif operators[-1] == \"|\":\\n                    val = False\\n                    for x in c:\\n                        val = val or x\\n                else:\\n                    val = not c[0]\\n                operands.append(val)\\n                operators.pop()\\n        return operands[-1]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        operands = []\\n        operators = []\\n        b = {\"f\": False, \"t\": True, \"(\": \"(\"}\\n        for i in range(len(expression)):\\n            if expression[i] in \"(ft\":\\n                operands.append(b[expression[i]])\\n            elif expression[i] in \"!&|\":\\n                operators.append(expression[i])\\n            elif expression[i] == \")\":\\n                c = []\\n                while operands and operands[-1] != \"(\":\\n                    c.append(operands.pop())\\n                operands.pop()\\n                val = None\\n                if operators[-1] == \"&\":\\n                    val = True\\n                    for x in c:\\n                        val = val and x\\n                elif operators[-1] == \"|\":\\n                    val = False\\n                    for x in c:\\n                        val = val or x\\n                else:\\n                    val = not c[0]\\n                operands.append(val)\\n                operators.pop()\\n        return operands[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844299,
                "title": "intuitive-recursion-approach-1ms",
                "content": "# Intuition\\nThere are 2 main options for the first character of the expression given or any subexpression:\\n\\n1. Either \\'t\\' or \\'f\\'.\\n2. An operator \\'!\\',\\'&\\' or \\'|\\' followed by \\'(\\' followed by an expression or list of expressions and closed with \\')\\'\\n\\nThis means that if we can break either of these options into a subexpression or a series of subexpressions, we can use `parseBoolExpr` on those subexpressions to find thier boolean values, and ultimately use boolean algebra to combine them.\\n\\nAdditionally, we note that for any series of expressions ANDed together, if any value is found to be false, the entire expression is false, and for any series of expressions ORed together if any value is found to be false, the entire expression is false. We shall call this boolean for the OR or the AND the overriding operator.\\n\\n# Approach\\n\\n1. So, in making `parseBoolExpr` a recursive method, we first check if the expression starts with \\'t\\' or \\'f\\', and if so, we return the corresponding value (any subexpression that starts with \\'t\\' or \\'f\\' only contains 1 character).\\n2. Then we check for \\'!\\'. If the expression starts with \\'!\\', we can strip the first and last parenthesis and return the opposite of `parseBoolExpr` on the resulting substring.\\n3. Lastly for `parseBoolExpr`, we know that the first character is either \\'&\\' or \\'|\\', and using the intuition that any false in \\'&\\' makes the whole statment false and any true in \\'|\\' makes the whole statement true, we save this corresponding boolean depending on if the character is an \\'&\\' or \\'|\\'. As previously discussed, we shall refer to this as the overriding operator. To handle the expressions inside the parenthesis that we strip, we call `parseList`.\\n4. In `parseList` we will iterate through each character in the expression looking for commas. We know we have gotten to the end index of a first statement once we see a comma and there are no open parenthesis (which we track with parenParity).\\n5. We check if the overriding operator is the outcome of that subexpression, and return that operator if true. Otherwise, we continue looping through and save our index+1 to strip away the comma when finding the next statement.\\n6. Once `idx`=`expression.length` we know that we have one sub-expression left to check as the last one ends without a comma. We check this accordingly, and if it does not equal to the overring operator then we know that all of the expressions were not the overriding operator, and therefore the whole statement evaulates to `!operator`.\\n\\nWe have now covered all cases, so in the end parseBoolExpr will successfully subdivide all expressions to evaulate them recursively.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        if(expression.charAt(0) == \\'t\\'){\\n            return true;\\n        }\\n        if(expression.charAt(0) == \\'f\\'){\\n            return false;\\n        }\\n        if(expression.charAt(0)==\\'!\\'){\\n            return !parseBoolExpr(expression.substring(2,expression.length()-1));\\n        }\\n        return parseList(expression.substring(2,expression.length()-1),expression.charAt(0)==\\'|\\');\\n        \\n    }\\n\\n    private boolean parseList(String expression, boolean operator){\\n        int parenParity = 0;\\n        int prevIdx = 0;\\n        int idx = 0;\\n        while(idx<expression.length()){\\n            if(expression.charAt(idx)==\\'(\\'){\\n                parenParity++;\\n            }\\n            else if(expression.charAt(idx)==\\')\\'){\\n                parenParity--;\\n            }\\n            else if(expression.charAt(idx)==\\',\\' && parenParity==0){\\n                if(parseBoolExpr(expression.substring(prevIdx,idx))==operator){\\n                    return operator;\\n                }\\n                prevIdx=idx+1;\\n            }\\n            idx++;\\n        }\\n        if(parseBoolExpr(expression.substring(prevIdx,idx))==operator){\\n            return operator;\\n        }\\n        return !operator;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        if(expression.charAt(0) == \\'t\\'){\\n            return true;\\n        }\\n        if(expression.charAt(0) == \\'f\\'){\\n            return false;\\n        }\\n        if(expression.charAt(0)==\\'!\\'){\\n            return !parseBoolExpr(expression.substring(2,expression.length()-1));\\n        }\\n        return parseList(expression.substring(2,expression.length()-1),expression.charAt(0)==\\'|\\');\\n        \\n    }\\n\\n    private boolean parseList(String expression, boolean operator){\\n        int parenParity = 0;\\n        int prevIdx = 0;\\n        int idx = 0;\\n        while(idx<expression.length()){\\n            if(expression.charAt(idx)==\\'(\\'){\\n                parenParity++;\\n            }\\n            else if(expression.charAt(idx)==\\')\\'){\\n                parenParity--;\\n            }\\n            else if(expression.charAt(idx)==\\',\\' && parenParity==0){\\n                if(parseBoolExpr(expression.substring(prevIdx,idx))==operator){\\n                    return operator;\\n                }\\n                prevIdx=idx+1;\\n            }\\n            idx++;\\n        }\\n        if(parseBoolExpr(expression.substring(prevIdx,idx))==operator){\\n            return operator;\\n        }\\n        return !operator;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841761,
                "title": "recusive-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} expression\\n * @return {boolean}\\n */\\nfunction parseBoolExpr(expr) {\\n    if (expr === \\'f\\') return false;\\n    if (expr === \\'t\\') return true;\\n\\n    expr = lexing(expr);\\n    if (expr[0] == \\'&\\') {\\n        for (let i = 1; i < expr.length; i++) {\\n            expr[i] = parseBoolExpr(expr[i]);\\n            if (!expr[i]) return false;\\n        }\\n        return true;\\n    } else if (expr[0] === \\'|\\') {\\n        for (let i = 1; i < expr.length; i++) {\\n            expr[i] = parseBoolExpr(expr[i]);\\n            if (expr[i]) return true;\\n        }\\n        return false;\\n    } else { // if (expr[0] === \\'!\\')\\n        return !(parseBoolExpr(expr[1]))\\n    }\\n}\\n\\nfunction lexing(expr) {\\n\\n    const res = [];\\n    if (expr[0] === \\'&\\' || expr[0] === \\'|\\' || expr[0] === \\'!\\') res.push(expr[0]);\\n\\n    let lastPos = 1;\\n    let leftBracket = -1;\\n    for (let i = 1; i < expr.length; i++) {\\n        if (expr[i] === \\'(\\') {\\n            leftBracket++;\\n            if (leftBracket > 0) {\\n                lastPos = i-1;\\n\\n                while(++i < expr.length && leftBracket > 0) {\\n                    if (expr[i] === \\'(\\') leftBracket++;\\n                    if (expr[i] === \\')\\') leftBracket--;\\n                }\\n                res.push(expr.slice(lastPos, i));\\n                lastPos = i;\\n            } \\n        } else if (expr[i] === \\',\\') {\\n            res.push(expr.slice(lastPos+1, i));\\n            lastPos = i;\\n        } else if (expr[i] === \\')\\') {\\n            res.push(expr.slice(lastPos+1, i));\\n            lastPos = i;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} expression\\n * @return {boolean}\\n */\\nfunction parseBoolExpr(expr) {\\n    if (expr === \\'f\\') return false;\\n    if (expr === \\'t\\') return true;\\n\\n    expr = lexing(expr);\\n    if (expr[0] == \\'&\\') {\\n        for (let i = 1; i < expr.length; i++) {\\n            expr[i] = parseBoolExpr(expr[i]);\\n            if (!expr[i]) return false;\\n        }\\n        return true;\\n    } else if (expr[0] === \\'|\\') {\\n        for (let i = 1; i < expr.length; i++) {\\n            expr[i] = parseBoolExpr(expr[i]);\\n            if (expr[i]) return true;\\n        }\\n        return false;\\n    } else { // if (expr[0] === \\'!\\')\\n        return !(parseBoolExpr(expr[1]))\\n    }\\n}\\n\\nfunction lexing(expr) {\\n\\n    const res = [];\\n    if (expr[0] === \\'&\\' || expr[0] === \\'|\\' || expr[0] === \\'!\\') res.push(expr[0]);\\n\\n    let lastPos = 1;\\n    let leftBracket = -1;\\n    for (let i = 1; i < expr.length; i++) {\\n        if (expr[i] === \\'(\\') {\\n            leftBracket++;\\n            if (leftBracket > 0) {\\n                lastPos = i-1;\\n\\n                while(++i < expr.length && leftBracket > 0) {\\n                    if (expr[i] === \\'(\\') leftBracket++;\\n                    if (expr[i] === \\')\\') leftBracket--;\\n                }\\n                res.push(expr.slice(lastPos, i));\\n                lastPos = i;\\n            } \\n        } else if (expr[i] === \\',\\') {\\n            res.push(expr.slice(lastPos+1, i));\\n            lastPos = i;\\n        } else if (expr[i] === \\')\\') {\\n            res.push(expr.slice(lastPos+1, i));\\n            lastPos = i;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3832197,
                "title": "parsing-a-boolean-expression",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nParenthesis problems come, think in terms of stack.\\nwe need to evaluate for an operator,before that we need to resolve the various subproblems that were there.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe most basic subproblem would be operator(t,f,t) etc.\\nhow can  I solve it.\\nRemember for an operator say op we need to have it\\'s values in a vector.\\nsay we start and then found an operator op, then what we do is that we keep on moving if found a closing bracket, can only found if all it\\'s subproblems inside have been evaluated.\\nwe want the answers for the subproblems ( )inside the parenthesis, so we take them out of the stack and then apply the appropriate operation on them.\\nfinally since again we solved a subproblem we then store it\\'s result in the stack only.\\nfinally the st top element would be having the result.\\nsince two variables T,F are there so instead of storing all their occurences we can store a frequency hash for them to further optimize our space.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// https://www.youtube.com/watch?v=lYw86z7Astg&ab_channel=leetuition\\n\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> st;\\n        // hash[0]=truecnt,hash[1]=falseccnt; , used instead of storing everything.\\n        for(auto ch:expression)\\n        {\\n            if(ch==\\',\\') continue;\\n            if(ch!=\\')\\') \\n            {\\n             st.push(ch);\\n             continue;\\n            }\\n            int hash[2]={0}; \\n            while(st.top()!=\\'(\\')\\n            {\\n                st.top()==\\'t\\'?hash[0]++:hash[1]++;\\n                st.pop();\\n            }\\n            st.pop();\\n            if(st.empty())continue;\\n            //evaluate for the operator.\\n            char op=st.top();st.pop();\\n            char topush;\\n            switch(op)\\n            {\\n                case \\'&\\':\\n                topush=hash[1]!=0?\\'f\\':\\'t\\';break;\\n                case \\'|\\':\\n                topush=hash[0]!=0?\\'t\\':\\'f\\';break;\\n                case \\'!\\':\\n                topush=hash[0]!=0?\\'f\\':\\'t\\';\\n                break;\\n            }\\n            st.push(topush);\\n        }\\n        \\n        return st.top()==\\'t\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n// https://www.youtube.com/watch?v=lYw86z7Astg&ab_channel=leetuition\\n\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> st;\\n        // hash[0]=truecnt,hash[1]=falseccnt; , used instead of storing everything.\\n        for(auto ch:expression)\\n        {\\n            if(ch==\\',\\') continue;\\n            if(ch!=\\')\\') \\n            {\\n             st.push(ch);\\n             continue;\\n            }\\n            int hash[2]={0}; \\n            while(st.top()!=\\'(\\')\\n            {\\n                st.top()==\\'t\\'?hash[0]++:hash[1]++;\\n                st.pop();\\n            }\\n            st.pop();\\n            if(st.empty())continue;\\n            //evaluate for the operator.\\n            char op=st.top();st.pop();\\n            char topush;\\n            switch(op)\\n            {\\n                case \\'&\\':\\n                topush=hash[1]!=0?\\'f\\':\\'t\\';break;\\n                case \\'|\\':\\n                topush=hash[0]!=0?\\'t\\':\\'f\\';break;\\n                case \\'!\\':\\n                topush=hash[0]!=0?\\'f\\':\\'t\\';\\n                break;\\n            }\\n            st.push(topush);\\n        }\\n        \\n        return st.top()==\\'t\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812030,
                "title": "simple-python-o-n-stack-solution",
                "content": "`!, &, |` are functions, so every time we encounter them, we want to create a new \"function stack frame\". Once we see a `)`, we have all the parameters to the function, so we can evaluate it and pop the stack frame.\\n```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        def eval_expr(expr):\\n            op = expr[0]\\n            if op == \\'!\\':\\n                return not expr[1]\\n            elif op == \\'&\\':\\n                return all(expr[1:])\\n            elif op == \\'|\\':\\n                return any(expr[1:])\\n\\n        stack = [[]]\\n        i = 0\\n        while i < len(expression):\\n            if expression[i] in \\'tf\\':\\n                stack[-1].append(True if expression[i] == \\'t\\' else False)\\n                i += 1\\n            elif expression[i] in \\'!&|\\':\\n                stack.append([expression[i]])\\n                i += 2\\n            elif expression[i] == \\')\\':\\n                t = stack.pop()\\n                stack[-1].append(eval_expr(t))\\n                i += 1\\n            else:\\n                i += 1\\n        return stack[-1][0]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        def eval_expr(expr):\\n            op = expr[0]\\n            if op == \\'!\\':\\n                return not expr[1]\\n            elif op == \\'&\\':\\n                return all(expr[1:])\\n            elif op == \\'|\\':\\n                return any(expr[1:])\\n\\n        stack = [[]]\\n        i = 0\\n        while i < len(expression):\\n            if expression[i] in \\'tf\\':\\n                stack[-1].append(True if expression[i] == \\'t\\' else False)\\n                i += 1\\n            elif expression[i] in \\'!&|\\':\\n                stack.append([expression[i]])\\n                i += 2\\n            elif expression[i] == \\')\\':\\n                t = stack.pop()\\n                stack[-1].append(eval_expr(t))\\n                i += 1\\n            else:\\n                i += 1\\n        return stack[-1][0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797098,
                "title": "beats-100-of-the-c-solutions-simple-approach-using-stack",
                "content": "# Intuition\\nMost of the questions which includes a expression in it can be solved by stack.\\n\\n# Approach\\nwe maintain 2 stacks.one for storing operators and other for storing expressions.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)+O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n        stack<char>op,exp;\\n        int idx=0;\\n        int n=s.size();\\n        while(idx<n){\\n            if(s[idx]==\\',\\'){\\n                idx++;\\n                continue;\\n            }\\n            if(s[idx]==\\'&\\' || s[idx]==\\'|\\' || s[idx]==\\'!\\'){\\n                op.push(s[idx]);\\n            }\\n            else if(s[idx]==\\')\\'){\\n                int ctf=0,ctt=0;\\n                while(exp.top()!=\\'(\\'){\\n                    if(exp.top()==\\'f\\') ctf++;\\n                    else ctt++;\\n                    exp.pop();\\n                }\\n                exp.pop();\\n                char oper=op.top();\\n                op.pop();\\n                if(oper==\\'&\\'){\\n                    if(ctf==0) exp.push(\\'t\\');\\n                    else exp.push(\\'f\\');\\n                }\\n                else if(oper==\\'|\\'){\\n                    if(ctt==0) exp.push(\\'f\\');\\n                    else exp.push(\\'t\\');\\n                }\\n                else{\\n                    if(ctt==0) exp.push(\\'t\\');\\n                    else exp.push(\\'f\\');\\n                }\\n            }\\n            else{\\n                exp.push(s[idx]);\\n            }\\n            idx++;\\n        }\\n        \\n        if(exp.top()==\\'f\\') return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n        stack<char>op,exp;\\n        int idx=0;\\n        int n=s.size();\\n        while(idx<n){\\n            if(s[idx]==\\',\\'){\\n                idx++;\\n                continue;\\n            }\\n            if(s[idx]==\\'&\\' || s[idx]==\\'|\\' || s[idx]==\\'!\\'){\\n                op.push(s[idx]);\\n            }\\n            else if(s[idx]==\\')\\'){\\n                int ctf=0,ctt=0;\\n                while(exp.top()!=\\'(\\'){\\n                    if(exp.top()==\\'f\\') ctf++;\\n                    else ctt++;\\n                    exp.pop();\\n                }\\n                exp.pop();\\n                char oper=op.top();\\n                op.pop();\\n                if(oper==\\'&\\'){\\n                    if(ctf==0) exp.push(\\'t\\');\\n                    else exp.push(\\'f\\');\\n                }\\n                else if(oper==\\'|\\'){\\n                    if(ctt==0) exp.push(\\'f\\');\\n                    else exp.push(\\'t\\');\\n                }\\n                else{\\n                    if(ctt==0) exp.push(\\'t\\');\\n                    else exp.push(\\'f\\');\\n                }\\n            }\\n            else{\\n                exp.push(s[idx]);\\n            }\\n            idx++;\\n        }\\n        \\n        if(exp.top()==\\'f\\') return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759517,
                "title": "parsing-boolean-expression-recursion-easy-to-understand",
                "content": "# Problem Statement:\\nYou are given a string representing a boolean expression, where \\'t\\' represents true, \\'f\\' represents false, \\'&\\' represents the logical AND operator, \\'|\\' represents the logical OR operator, and \\'!\\' represents the logical NOT operator. You need to parse and evaluate the given boolean expression.\\n\\n# Intuition:\\nTo solve this problem, we can use a recursive parsing approach. We define different parsing functions for each logical operator (\\'&\\', \\'|\\', \\'!\\') and recursively evaluate the subexpressions.\\n\\n# Approach:\\n1. Define a parsing function `parseOr` for the logical OR operator (\\'|\\'):\\n   - The function takes the following parameters:\\n     - `expression`: The boolean expression string.\\n     - `index`: The current index in the expression string.\\n   - Move past the opening \\'|(\\' in the expression.\\n   - Initialize a boolean variable `response` to store the result.\\n   - Parse the first expression by calling the `parse` function recursively.\\n   - While the current character is not \\')\\', move to the next character and parse the subsequent expressions. Perform the logical OR operation with the previous result.\\n   - Move past the closing \\')\\'.\\n   - Return the final response.\\n   \\n2. Define a parsing function `parseAnd` for the logical AND operator (\\'&\\'):\\n   - The function takes similar parameters as `parseOr`.\\n   - Move past the opening \\'&(\\' in the expression.\\n   - Initialize a boolean variable `response` to store the result.\\n   - Parse the first expression by calling the `parse` function recursively.\\n   - While the current character is not \\')\\', move to the next character and parse the subsequent expressions. Perform the logical AND operation with the previous result.\\n   - Move past the closing \\')\\'.\\n   - Return the final response.\\n   \\n3. Define a parsing function `parseNot` for the logical NOT operator (\\'!\\'):\\n   - The function takes similar parameters as `parseOr`.\\n   - Move past the opening \\'!(\\' in the expression.\\n   - Parse the expression after the \\'!\\' by calling the `parse` function recursively.\\n   - Move past the closing \\')\\'.\\n   - Perform logical negation on the parsed expression and return the result.\\n   \\n4. Define a general parsing function `parse` to handle the base cases and parse the main expression:\\n   - The function takes similar parameters as the other parsing functions.\\n   - Check the current character in the expression:\\n     - If it is \\'f\\', move to the next character and return false.\\n     - If it is \\'&\\', call `parseAnd` to parse the AND operation.\\n     - If it is \\'|\\', call `parseOr` to parse the OR operation.\\n     - If it is \\'!\\', call `parseNot` to parse the NOT operation.\\n     - Otherwise, move to the next character and return true.\\n     \\n5. In the `parseBoolExpr` function:\\n   - Initialize an index variable to 0 to track the current position in the expression.\\n   - Call the `parse` function to start parsing from index 0.\\n   - Return the final result.\\n\\n# Complexity Analysis:\\n- Let n be the length of the input expression.\\n- The time complexity of the solution is O(n) since we process each character once.\\n- The space complexity is O(1) since we don\\'t use any extra space that scales with the input size.\\n\\n# Code:\\n```cpp\\n\\nclass Solution {\\npublic:\\n    bool parseOr(string& expression, int& index) {\\n        index += 2; // Move past the opening \\'|(\\'\\n        bool response = false;\\n        response |= parse(expression, index); // Parse the first expression\\n        while (expression[index] != \\')\\') {\\n            index++;\\n            response |= parse(expression, index); // Parse the subsequent expressions and perform OR operation\\n        }\\n        index++; // Move past the closing \\')\\'\\n        return response;\\n    }\\n    \\n    bool parseAnd(string& expression, int& index) {\\n        index += 2; // Move past the opening \\'&(\\'\\n        bool response = true;\\n        response &= parse(expression, index); // Parse the first expression\\n        while (expression[index] != \\')\\') {\\n            index++;\\n            response &= parse(expression, index); // Parse the subsequent expressions and perform AND operation\\n        }\\n        index++; // Move past the closing \\')\\'\\n        return response;\\n    }\\n    \\n    bool parseNot(string& expression, int& index) {\\n        index += 2; // Move past the opening \\'!(\\'\\n        bool response = parse(expression, index); // Parse the expression after the \\'!\\'\\n        index++; // Move past the closing \\')\\'\\n        return !response; // Perform logical negation\\n    }\\n    \\n    bool parse(string& expression, int& index) {\\n        if (expression[index] == \\'f\\') {\\n            index++;\\n            return false; // Return false for \\'f\\'\\n        } else if (expression[index] == \\'&\\') {\\n            return parseAnd(expression, index); // Parse AND operation\\n        } else if (expression[index] == \\'|\\') {\\n            return parseOr(expression, index); // Parse OR operation\\n        } else if (expression[index] == \\'!\\') {\\n            return parseNot(expression, index); // Parse NOT operation\\n        }\\n        index++;\\n        return true; // Return true for \\'t\\'\\n    }\\n    \\n    bool parseBoolExpr(string expression) {\\n        int index = 0;\\n        bool ans = parse(expression, index); // Start parsing from index 0\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion"
                ],
                "code": "```cpp\\n\\nclass Solution {\\npublic:\\n    bool parseOr(string& expression, int& index) {\\n        index += 2; // Move past the opening \\'|(\\'\\n        bool response = false;\\n        response |= parse(expression, index); // Parse the first expression\\n        while (expression[index] != \\')\\') {\\n            index++;\\n            response |= parse(expression, index); // Parse the subsequent expressions and perform OR operation\\n        }\\n        index++; // Move past the closing \\')\\'\\n        return response;\\n    }\\n    \\n    bool parseAnd(string& expression, int& index) {\\n        index += 2; // Move past the opening \\'&(\\'\\n        bool response = true;\\n        response &= parse(expression, index); // Parse the first expression\\n        while (expression[index] != \\')\\') {\\n            index++;\\n            response &= parse(expression, index); // Parse the subsequent expressions and perform AND operation\\n        }\\n        index++; // Move past the closing \\')\\'\\n        return response;\\n    }\\n    \\n    bool parseNot(string& expression, int& index) {\\n        index += 2; // Move past the opening \\'!(\\'\\n        bool response = parse(expression, index); // Parse the expression after the \\'!\\'\\n        index++; // Move past the closing \\')\\'\\n        return !response; // Perform logical negation\\n    }\\n    \\n    bool parse(string& expression, int& index) {\\n        if (expression[index] == \\'f\\') {\\n            index++;\\n            return false; // Return false for \\'f\\'\\n        } else if (expression[index] == \\'&\\') {\\n            return parseAnd(expression, index); // Parse AND operation\\n        } else if (expression[index] == \\'|\\') {\\n            return parseOr(expression, index); // Parse OR operation\\n        } else if (expression[index] == \\'!\\') {\\n            return parseNot(expression, index); // Parse NOT operation\\n        }\\n        index++;\\n        return true; // Return true for \\'t\\'\\n    }\\n    \\n    bool parseBoolExpr(string expression) {\\n        int index = 0;\\n        bool ans = parse(expression, index); // Start parsing from index 0\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753841,
                "title": "stack-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n- o(n)\\n\\n- Space complexity:\\n- o(n){both stack total = o(n)}\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isValid(char curr){\\n        if(curr ==\\'t\\' || curr == \\'f\\' || curr == \\'(\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    bool parseBoolExpr(string expression) {\\n        stack<char>st;  // stores ( \\'(\\',\\'t\\',\\'f\\' )\\n        stack<char>exp; // stores (\\'all operators\\')\\n        for(int i = 0;i<expression.size();i++){\\n            char current = expression[i];\\n            if(current == \\'&\\' || current == \\'|\\' || current == \\'!\\'){\\n                exp.push(current);\\n            }\\n            if(isValid(current)){\\n                st.push(current);\\n            }\\n            else{\\n                if(current == \\')\\'){\\n                    bool result = st.top() == \\'t\\'?true:false;\\n                    while(st.top()!= \\'(\\'){\\n                        // cout<<result<<endl;\\n                        st.pop();\\n                        if(exp.top() == \\'&\\'){\\n                            bool opr = st.top() == \\'t\\'?true:st.top() == \\'f\\'?false:result;\\n                            result = result&&opr;\\n                        }\\n                        else if(exp.top() == \\'|\\'){\\n                            bool opr = st.top() == \\'t\\'?true:st.top() == \\'f\\'?false:result;\\n                            // the above statement takes care of the case &(f) since it will evaluate to (f && f) or result&&result \\n                            result = result||opr;\\n                        }\\n                        else if(exp.top() == \\'!\\'){\\n                            result = !result;\\n                        }\\n                        cout<<result<<endl;\\n                    }\\n                    st.pop();\\n                    result == true?st.push(\\'t\\'):st.push(\\'f\\');\\n                    exp.pop();\\n                }\\n            }\\n        }\\n        return st.top() == \\'t\\'?true:false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isValid(char curr){\\n        if(curr ==\\'t\\' || curr == \\'f\\' || curr == \\'(\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    bool parseBoolExpr(string expression) {\\n        stack<char>st;  // stores ( \\'(\\',\\'t\\',\\'f\\' )\\n        stack<char>exp; // stores (\\'all operators\\')\\n        for(int i = 0;i<expression.size();i++){\\n            char current = expression[i];\\n            if(current == \\'&\\' || current == \\'|\\' || current == \\'!\\'){\\n                exp.push(current);\\n            }\\n            if(isValid(current)){\\n                st.push(current);\\n            }\\n            else{\\n                if(current == \\')\\'){\\n                    bool result = st.top() == \\'t\\'?true:false;\\n                    while(st.top()!= \\'(\\'){\\n                        // cout<<result<<endl;\\n                        st.pop();\\n                        if(exp.top() == \\'&\\'){\\n                            bool opr = st.top() == \\'t\\'?true:st.top() == \\'f\\'?false:result;\\n                            result = result&&opr;\\n                        }\\n                        else if(exp.top() == \\'|\\'){\\n                            bool opr = st.top() == \\'t\\'?true:st.top() == \\'f\\'?false:result;\\n                            // the above statement takes care of the case &(f) since it will evaluate to (f && f) or result&&result \\n                            result = result||opr;\\n                        }\\n                        else if(exp.top() == \\'!\\'){\\n                            result = !result;\\n                        }\\n                        cout<<result<<endl;\\n                    }\\n                    st.pop();\\n                    result == true?st.push(\\'t\\'):st.push(\\'f\\');\\n                    exp.pop();\\n                }\\n            }\\n        }\\n        return st.top() == \\'t\\'?true:false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3751841,
                "title": "unique-solution-stack-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string exp) {\\n        if(exp.size() == 1) return exp[0] == \\'f\\' ? false : true;\\n        stack<char> s;\\n        vector<char> v;\\n        bool flag=false;\\n\\n        for(int i=0;i<exp.size();i++){\\n            if(exp[i] == \\')\\'){\\n                flag = false;\\n                while(!(s.top() == \\'(\\')){\\n                    v.push_back(s.top());\\n                    cout<<s.top()<<\" \";\\n                    s.pop();\\n                }\\n                s.pop();\\n                char ch = s.top(); s.pop();\\n\\n                if(v[0] == \\'t\\') flag = true;\\n                if(ch == \\'!\\'){\\n                    flag = !flag;\\n                    char fl = flag==false ? \\'f\\' : \\'t\\';\\n                    s.push(fl);\\n                    cout<<flag<<\" \";\\n                }else if(ch == \\'&\\'){\\n                    for(int i=1;i<v.size();i++){\\n                        bool f=false;\\n                        if(v[i] == \\'t\\') f = true;\\n                        flag &= f;\\n                    }\\n                    char fl = flag==false ? \\'f\\' : \\'t\\';\\n                    s.push(fl);\\n                    cout<<flag<<\" \";\\n                }else if(ch == \\'|\\'){\\n                    for(int i=1;i<v.size();i++){\\n                        bool f=false;\\n                        if(v[i] == \\'t\\') f = true;\\n                        flag |= f;\\n                    }\\n                    char fl = flag==false ? \\'f\\' : \\'t\\';\\n                    s.push(fl);\\n                    cout<<flag<<\" \";\\n                }\\n                v.clear();\\n            }\\n            else if(exp[i] != \\',\\'){\\n                s.push(exp[i]);\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string exp) {\\n        if(exp.size() == 1) return exp[0] == \\'f\\' ? false : true;\\n        stack<char> s;\\n        vector<char> v;\\n        bool flag=false;\\n\\n        for(int i=0;i<exp.size();i++){\\n            if(exp[i] == \\')\\'){\\n                flag = false;\\n                while(!(s.top() == \\'(\\')){\\n                    v.push_back(s.top());\\n                    cout<<s.top()<<\" \";\\n                    s.pop();\\n                }\\n                s.pop();\\n                char ch = s.top(); s.pop();\\n\\n                if(v[0] == \\'t\\') flag = true;\\n                if(ch == \\'!\\'){\\n                    flag = !flag;\\n                    char fl = flag==false ? \\'f\\' : \\'t\\';\\n                    s.push(fl);\\n                    cout<<flag<<\" \";\\n                }else if(ch == \\'&\\'){\\n                    for(int i=1;i<v.size();i++){\\n                        bool f=false;\\n                        if(v[i] == \\'t\\') f = true;\\n                        flag &= f;\\n                    }\\n                    char fl = flag==false ? \\'f\\' : \\'t\\';\\n                    s.push(fl);\\n                    cout<<flag<<\" \";\\n                }else if(ch == \\'|\\'){\\n                    for(int i=1;i<v.size();i++){\\n                        bool f=false;\\n                        if(v[i] == \\'t\\') f = true;\\n                        flag |= f;\\n                    }\\n                    char fl = flag==false ? \\'f\\' : \\'t\\';\\n                    s.push(fl);\\n                    cout<<flag<<\" \";\\n                }\\n                v.clear();\\n            }\\n            else if(exp[i] != \\',\\'){\\n                s.push(exp[i]);\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3747468,
                "title": "python-simple-solution-to-split-the-input-into-boolean-expressions-and-evaluate-them-recursively",
                "content": "# Approach\\nEvaluating boolean expressions is straight forward if we can split the string into boolean expressions.\\nString.split is not helpful and can result in bugs if we have nested expressions. We have to split the string at the point where open bracket count is 0. Keep a counter and increment it for every \"(\" and decrement it for every \")\" seen so far. If we see a \",\" and the bracket count is 0, split the string\\nUse the parent method to recursive evaluate the sub_expressions.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfrom functools import reduce\\nimport operator as op\\n\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        \\n        def child_expressions(parent_expression):\\n            l = len(parent_expression)\\n            child_expression = parent_expression[2: l-1]\\n\\n            br_count = 0\\n            result = []\\n            cur_expression = \"\"\\n            for ch in child_expression:\\n                if ch == \\'(\\':\\n                    br_count += 1\\n                elif ch == \\')\\':\\n                    br_count -= 1\\n                elif ch == \\',\\':\\n                    if br_count == 0:\\n                        result.append(cur_expression)\\n                        cur_expression = \"\"\\n                        continue\\n                cur_expression += ch\\n            if cur_expression:\\n                result.append(cur_expression)\\n            return result\\n\\n\\n        if expression == \\'t\\':\\n            return True\\n        elif expression == \\'f\\':\\n            return False\\n        elif expression.startswith(\"!\"):\\n            l = len(expression)\\n            return not self.parseBoolExpr(expression[2:l-1])\\n        elif expression.startswith(\"&\"):\\n            return reduce(op.iand, map(self.parseBoolExpr, child_expressions(expression)))\\n        elif expression.startswith(\"|\"):\\n            return reduce(op.ior,  map(self.parseBoolExpr, child_expressions(expression)))\\n        else:\\n            return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import reduce\\nimport operator as op\\n\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        \\n        def child_expressions(parent_expression):\\n            l = len(parent_expression)\\n            child_expression = parent_expression[2: l-1]\\n\\n            br_count = 0\\n            result = []\\n            cur_expression = \"\"\\n            for ch in child_expression:\\n                if ch == \\'(\\':\\n                    br_count += 1\\n                elif ch == \\')\\':\\n                    br_count -= 1\\n                elif ch == \\',\\':\\n                    if br_count == 0:\\n                        result.append(cur_expression)\\n                        cur_expression = \"\"\\n                        continue\\n                cur_expression += ch\\n            if cur_expression:\\n                result.append(cur_expression)\\n            return result\\n\\n\\n        if expression == \\'t\\':\\n            return True\\n        elif expression == \\'f\\':\\n            return False\\n        elif expression.startswith(\"!\"):\\n            l = len(expression)\\n            return not self.parseBoolExpr(expression[2:l-1])\\n        elif expression.startswith(\"&\"):\\n            return reduce(op.iand, map(self.parseBoolExpr, child_expressions(expression)))\\n        elif expression.startswith(\"|\"):\\n            return reduce(op.ior,  map(self.parseBoolExpr, child_expressions(expression)))\\n        else:\\n            return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744192,
                "title": "100-faster-stack-easy-to-understand-expression-evaluation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> s1;\\n        stack<char> s2;\\n        for(char c : expression){\\n            if(c == \\',\\') continue;\\n            if(c == \\'!\\' || c == \\'&\\' || c== \\'|\\'){\\n                s2.push(c);\\n            }\\n            else if(c != \\')\\'){\\n                s1.push(c);\\n            }\\n            else{\\n                while(s2.empty() == false){\\n                   char c1 = s1.top();\\n                   s1.pop();\\n                   char c2 = s1.top();\\n                   s1.pop();\\n                   if(c2 == \\'(\\'){\\n                       if(s2.top() == \\'!\\'){\\n                           s2.pop();\\n                           if(c1 == \\'f\\') s1.push(\\'t\\');\\n                           else s1.push(\\'f\\');\\n                       }\\n                       else{\\n                           s2.pop();\\n                           s1.push(c1);\\n                       } \\n                       break;\\n                   }\\n                   else{\\n                       if(s2.top() == \\'&\\'){\\n                           bool b1 = c1 == \\'t\\' ? true : false;\\n                           bool b2 = c2 == \\'t\\' ? true : false;\\n                           bool b3 = b1&b2;\\n                           if(b3 == false) s1.push(\\'f\\');\\n                           else s1.push(\\'t\\');\\n                       }\\n                       if(s2.top() == \\'|\\'){\\n                           bool b1 = c1 == \\'t\\' ? true : false;\\n                           bool b2 = c2 == \\'t\\' ? true : false;\\n                           bool b3 = b1|b2;\\n                           if(b3 == false) s1.push(\\'f\\');\\n                           else s1.push(\\'t\\');\\n                       }\\n                   }\\n                }\\n            }\\n        }\\n        if(s1.top() == \\'t\\') return true;\\n        else return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> s1;\\n        stack<char> s2;\\n        for(char c : expression){\\n            if(c == \\',\\') continue;\\n            if(c == \\'!\\' || c == \\'&\\' || c== \\'|\\'){\\n                s2.push(c);\\n            }\\n            else if(c != \\')\\'){\\n                s1.push(c);\\n            }\\n            else{\\n                while(s2.empty() == false){\\n                   char c1 = s1.top();\\n                   s1.pop();\\n                   char c2 = s1.top();\\n                   s1.pop();\\n                   if(c2 == \\'(\\'){\\n                       if(s2.top() == \\'!\\'){\\n                           s2.pop();\\n                           if(c1 == \\'f\\') s1.push(\\'t\\');\\n                           else s1.push(\\'f\\');\\n                       }\\n                       else{\\n                           s2.pop();\\n                           s1.push(c1);\\n                       } \\n                       break;\\n                   }\\n                   else{\\n                       if(s2.top() == \\'&\\'){\\n                           bool b1 = c1 == \\'t\\' ? true : false;\\n                           bool b2 = c2 == \\'t\\' ? true : false;\\n                           bool b3 = b1&b2;\\n                           if(b3 == false) s1.push(\\'f\\');\\n                           else s1.push(\\'t\\');\\n                       }\\n                       if(s2.top() == \\'|\\'){\\n                           bool b1 = c1 == \\'t\\' ? true : false;\\n                           bool b2 = c2 == \\'t\\' ? true : false;\\n                           bool b3 = b1|b2;\\n                           if(b3 == false) s1.push(\\'f\\');\\n                           else s1.push(\\'t\\');\\n                       }\\n                   }\\n                }\\n            }\\n        }\\n        if(s1.top() == \\'t\\') return true;\\n        else return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736770,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public void split(String x, ArrayList<String> arr){\\n        \\n        if(x.length() == 0){\\n            return;\\n        }\\n        if(x.startsWith(\"&\") || x.startsWith(\"|\") || x.startsWith(\"!\")){\\n            int open = 1;\\n            int charIndex = 2;\\n            while(open!=0){\\n                if(x.charAt(charIndex) == \\')\\'){\\n                    open--;\\n                }\\n                if(x.charAt(charIndex) == \\'(\\'){\\n                    open++;\\n                }   \\n\\n                charIndex++;\\n\\n            }\\n            arr.add(x.substring(0, charIndex));\\n            if(x.length() > charIndex + 1){\\n                split(x.substring(charIndex + 1), arr);\\n            }\\n        }\\n        else{\\n            arr.add(x.substring(0,1));\\n            if(x.length() > 2){\\n                split(x.substring(2), arr);\\n            }\\n            \\n        }\\n\\n    }\\n    public boolean parseBoolExpr(String expression) {\\n        \\n        if(expression.length() == 1){\\n            if(expression.charAt(0) == \\'f\\'){\\n                return false;\\n            }\\n            return true;\\n        }\\n\\n        if(expression.startsWith(\"&\")){\\n            expression = expression.substring(2,expression.length() - 1);\\n            ArrayList<String> arr = new ArrayList<>();\\n            split(expression, arr);\\n            for(String s : arr){\\n                boolean x = parseBoolExpr(s);\\n                if(!x){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        else if(expression.startsWith(\"|\")){\\n            expression = expression.substring(2,expression.length() - 1);\\n            ArrayList<String> arr = new ArrayList<>();\\n            split(expression, arr);\\n            // System.out.println(arr);\\n            for(String s : arr){\\n                boolean x = parseBoolExpr(s);\\n                if(x){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else{\\n            expression = expression.substring(2,expression.length() - 1);\\n            \\n            boolean x = parseBoolExpr(expression);\\n            return !x;\\n\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public void split(String x, ArrayList<String> arr){\\n        \\n        if(x.length() == 0){\\n            return;\\n        }\\n        if(x.startsWith(\"&\") || x.startsWith(\"|\") || x.startsWith(\"!\")){\\n            int open = 1;\\n            int charIndex = 2;\\n            while(open!=0){\\n                if(x.charAt(charIndex) == \\')\\'){\\n                    open--;\\n                }\\n                if(x.charAt(charIndex) == \\'(\\'){\\n                    open++;\\n                }   \\n\\n                charIndex++;\\n\\n            }\\n            arr.add(x.substring(0, charIndex));\\n            if(x.length() > charIndex + 1){\\n                split(x.substring(charIndex + 1), arr);\\n            }\\n        }\\n        else{\\n            arr.add(x.substring(0,1));\\n            if(x.length() > 2){\\n                split(x.substring(2), arr);\\n            }\\n            \\n        }\\n\\n    }\\n    public boolean parseBoolExpr(String expression) {\\n        \\n        if(expression.length() == 1){\\n            if(expression.charAt(0) == \\'f\\'){\\n                return false;\\n            }\\n            return true;\\n        }\\n\\n        if(expression.startsWith(\"&\")){\\n            expression = expression.substring(2,expression.length() - 1);\\n            ArrayList<String> arr = new ArrayList<>();\\n            split(expression, arr);\\n            for(String s : arr){\\n                boolean x = parseBoolExpr(s);\\n                if(!x){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        else if(expression.startsWith(\"|\")){\\n            expression = expression.substring(2,expression.length() - 1);\\n            ArrayList<String> arr = new ArrayList<>();\\n            split(expression, arr);\\n            // System.out.println(arr);\\n            for(String s : arr){\\n                boolean x = parseBoolExpr(s);\\n                if(x){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else{\\n            expression = expression.substring(2,expression.length() - 1);\\n            \\n            boolean x = parseBoolExpr(expression);\\n            return !x;\\n\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735399,
                "title": "easy-c-solution-using-stack-with-approach-explained",
                "content": "# Intuition\\nAs we need to evaluate each expressions inside the brackets and eventually come out. So we will use stack.\\n\\n# Approach\\nWe will take a stack and keep pushing the values inside it till we get an closing bracket i.e \\')\\'. The  moment we got this then we will pop out all of the characters and store it in a vector for evaluating. We will pop out till we encounter an opening bracket i.e \\'(\\'.\\n\\nNow that we have got our vector to work then we will check if st.top() is \\'&\\' or \\'|\\' or \\'!\\'. According to that we will do our operation.\\n\\nWhen it is \\'&\\' then we know if any of them is false then we return false else return true. Thats what we have done in evaland function.\\n\\nWhen it is \\'|\\' then we know if any of them is true then we return true else return false. Thats what we have done in evalor function.\\n\\nWhen it is \\'!\\' then we know if inside it is false we return true and vice versa. Thats what we have done in evalnot function.\\n\\nAfter evaluating everything we keep pushing the evaluated values inside stack to continue the operation.\\n\\nAt last when every operation is done then what remains in stack is the ans Hence returning the st.top().\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void evaland(stack<char> &st, vector<char> &f){\\n        int cnt=0;\\n        for(auto it: f){\\n            if(it==\\'f\\'){\\n                st.pop();\\n                st.push(\\'f\\');\\n                cnt=1;\\n                break;\\n            }\\n        }\\n        if(cnt==0){\\n            st.pop();\\n            st.push(\\'t\\');\\n        }\\n    }\\n\\n    void evalor(stack<char> &st, vector<char> &f){\\n        int cnt=0;\\n        for(auto it: f){\\n            if(it==\\'t\\'){\\n                st.pop();\\n                st.push(\\'t\\');\\n                cnt=1;\\n                break;\\n            }\\n        }\\n        if(cnt==0){\\n            st.pop();\\n            st.push(\\'f\\');\\n        }\\n    }\\n\\n    void evalnot(stack<char> &st, vector<char> &f){\\n        if(f[0]==\\'t\\') st.push(\\'f\\');\\n        if(f[0]==\\'f\\') st.push(\\'t\\');\\n    }\\n\\n    bool parseBoolExpr(string s) {\\n        int n=s.size();\\n        stack<char> st;\\n        for(int i=0; i<n; i++){\\n            st.push(s[i]);\\n            if(st.top()==\\')\\'){\\n                vector<char> f;\\n                st.pop();\\n                while(st.top()!=\\'(\\'){\\n                    if(st.top()==\\'t\\' || st.top()==\\'f\\'){\\n                        f.push_back(st.top());\\n                    }\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(st.top()==\\'&\\'){\\n                    evaland(st, f);  \\n                }\\n\\n                if(st.top()==\\'|\\'){\\n                    evalor(st, f);\\n                }\\n\\n                if(st.top()==\\'!\\'){\\n                    evalnot(st, f);\\n                }\\n            }\\n        }\\n        if(st.top()==\\'t\\') return true;\\n        return false;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void evaland(stack<char> &st, vector<char> &f){\\n        int cnt=0;\\n        for(auto it: f){\\n            if(it==\\'f\\'){\\n                st.pop();\\n                st.push(\\'f\\');\\n                cnt=1;\\n                break;\\n            }\\n        }\\n        if(cnt==0){\\n            st.pop();\\n            st.push(\\'t\\');\\n        }\\n    }\\n\\n    void evalor(stack<char> &st, vector<char> &f){\\n        int cnt=0;\\n        for(auto it: f){\\n            if(it==\\'t\\'){\\n                st.pop();\\n                st.push(\\'t\\');\\n                cnt=1;\\n                break;\\n            }\\n        }\\n        if(cnt==0){\\n            st.pop();\\n            st.push(\\'f\\');\\n        }\\n    }\\n\\n    void evalnot(stack<char> &st, vector<char> &f){\\n        if(f[0]==\\'t\\') st.push(\\'f\\');\\n        if(f[0]==\\'f\\') st.push(\\'t\\');\\n    }\\n\\n    bool parseBoolExpr(string s) {\\n        int n=s.size();\\n        stack<char> st;\\n        for(int i=0; i<n; i++){\\n            st.push(s[i]);\\n            if(st.top()==\\')\\'){\\n                vector<char> f;\\n                st.pop();\\n                while(st.top()!=\\'(\\'){\\n                    if(st.top()==\\'t\\' || st.top()==\\'f\\'){\\n                        f.push_back(st.top());\\n                    }\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(st.top()==\\'&\\'){\\n                    evaland(st, f);  \\n                }\\n\\n                if(st.top()==\\'|\\'){\\n                    evalor(st, f);\\n                }\\n\\n                if(st.top()==\\'!\\'){\\n                    evalnot(st, f);\\n                }\\n            }\\n        }\\n        if(st.top()==\\'t\\') return true;\\n        return false;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727972,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n\\n       stack<char>st1;\\n       stack<char>st2;\\n       bool ans=true;\\n\\n       for(int i=0;i<expression.length();i++){\\n\\n         if(expression[i]!=\\')\\'){\\n             st1.push(expression[i]);\\n         }else{\\n\\n             while(st1.top()!=\\'(\\'){\\n                 char ch=st1.top();\\n                  st1.pop();\\n\\n                 if(ch==\\'t\\'){\\n                     st2.push(true);\\n                 }else if(ch==\\'f\\'){\\n                     st2.push(false);\\n                 }\\n                \\n             }\\n\\n             if(!st1.empty()){\\n                 st1.pop();\\n\\n                 if(!st1.empty()){\\n                    char op = st1.top();\\n                    st1.pop();\\n                    bool check=true;\\n                    if(!st2.empty()){\\n                     check=st2.top();\\n                    st2.pop();\\n                    }\\n\\n                    while(!st2.empty()){\\n                        bool val = st2.top();\\n                        st2.pop();\\n                       \\n                        if(op==\\'!\\'){\\n                            check = !val; \\n                        } \\n                        else if(op==\\'&\\'){\\n                           check =check & val;\\n                        }else{\\n                            check = check | val;\\n                        }\\n                         \\n                    }\\n                    if(op==\\'!\\'){\\n                        check =!check;\\n                    }\\n                    st1.push(check==true?\\'t\\':\\'f\\');\\n                 }\\n             }\\n\\n         }\\n\\n\\n       }\\n      \\n      if(!st1.empty()){\\n          ans =st1.top()==\\'t\\'?true:false;\\n      }\\n\\n      return ans;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n\\n       stack<char>st1;\\n       stack<char>st2;\\n       bool ans=true;\\n\\n       for(int i=0;i<expression.length();i++){\\n\\n         if(expression[i]!=\\')\\'){\\n             st1.push(expression[i]);\\n         }else{\\n\\n             while(st1.top()!=\\'(\\'){\\n                 char ch=st1.top();\\n                  st1.pop();\\n\\n                 if(ch==\\'t\\'){\\n                     st2.push(true);\\n                 }else if(ch==\\'f\\'){\\n                     st2.push(false);\\n                 }\\n                \\n             }\\n\\n             if(!st1.empty()){\\n                 st1.pop();\\n\\n                 if(!st1.empty()){\\n                    char op = st1.top();\\n                    st1.pop();\\n                    bool check=true;\\n                    if(!st2.empty()){\\n                     check=st2.top();\\n                    st2.pop();\\n                    }\\n\\n                    while(!st2.empty()){\\n                        bool val = st2.top();\\n                        st2.pop();\\n                       \\n                        if(op==\\'!\\'){\\n                            check = !val; \\n                        } \\n                        else if(op==\\'&\\'){\\n                           check =check & val;\\n                        }else{\\n                            check = check | val;\\n                        }\\n                         \\n                    }\\n                    if(op==\\'!\\'){\\n                        check =!check;\\n                    }\\n                    st1.push(check==true?\\'t\\':\\'f\\');\\n                 }\\n             }\\n\\n         }\\n\\n\\n       }\\n      \\n      if(!st1.empty()){\\n          ans =st1.top()==\\'t\\'?true:false;\\n      }\\n\\n      return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690053,
                "title": "simple-cpp-solution-using-two-stacks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    char calculate(char expr,char c1,char c2){\\n        int t1 = c1==\\'t\\' ? 1 : 0;\\n        int t2 = c2==\\'t\\' ? 1 : 0;\\n        int ans;\\n        if(expr==\\'|\\'){\\n            ans = (t1|t2);\\n        }\\n        else if(expr==\\'&\\'){\\n            ans = (t1&t2);\\n        }\\n        return ans==1 ? \\'t\\' : \\'f\\';\\n    }\\npublic:\\n    bool parseBoolExpr(string ex) {\\n        stack<char> st1,st2;\\n        for(int i=0; i<ex.length(); i++){\\n            if(ex[i]==\\'|\\' || ex[i]==\\'&\\' || ex[i]==\\'!\\'){\\n                st1.push(ex[i]);\\n            }\\n            else if(ex[i]!=\\')\\' && ex[i]!=\\',\\'){\\n                st2.push(ex[i]);\\n            }\\n            else if(ex[i]==\\')\\'){\\n                char ch = st1.top();\\n                st1.pop();\\n                char ch2 = st2.top();\\n                st2.pop();\\n                while(st2.size() && st2.top()!=\\'(\\'){\\n                    int ch3 = st2.top();\\n                    ch2 = calculate(ch,ch2,ch3);\\n                    st2.pop();\\n                }\\n                if(st2.size()){\\n                    st2.pop();\\n                }\\n                if(ch==\\'!\\'){\\n                    ch2 = ch2==\\'t\\' ? \\'f\\' : \\'t\\';\\n                }\\n                st2.push(ch2);\\n            }\\n        }\\n        if(st2.top()==\\'t\\'){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    char calculate(char expr,char c1,char c2){\\n        int t1 = c1==\\'t\\' ? 1 : 0;\\n        int t2 = c2==\\'t\\' ? 1 : 0;\\n        int ans;\\n        if(expr==\\'|\\'){\\n            ans = (t1|t2);\\n        }\\n        else if(expr==\\'&\\'){\\n            ans = (t1&t2);\\n        }\\n        return ans==1 ? \\'t\\' : \\'f\\';\\n    }\\npublic:\\n    bool parseBoolExpr(string ex) {\\n        stack<char> st1,st2;\\n        for(int i=0; i<ex.length(); i++){\\n            if(ex[i]==\\'|\\' || ex[i]==\\'&\\' || ex[i]==\\'!\\'){\\n                st1.push(ex[i]);\\n            }\\n            else if(ex[i]!=\\')\\' && ex[i]!=\\',\\'){\\n                st2.push(ex[i]);\\n            }\\n            else if(ex[i]==\\')\\'){\\n                char ch = st1.top();\\n                st1.pop();\\n                char ch2 = st2.top();\\n                st2.pop();\\n                while(st2.size() && st2.top()!=\\'(\\'){\\n                    int ch3 = st2.top();\\n                    ch2 = calculate(ch,ch2,ch3);\\n                    st2.pop();\\n                }\\n                if(st2.size()){\\n                    st2.pop();\\n                }\\n                if(ch==\\'!\\'){\\n                    ch2 = ch2==\\'t\\' ? \\'f\\' : \\'t\\';\\n                }\\n                st2.push(ch2);\\n            }\\n        }\\n        if(st2.top()==\\'t\\'){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683477,
                "title": "simple-straight-forward",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string exp) {\\n        stack<char> st , op;\\n\\n        for(int i=0;i<exp.length();i++) {\\n            if(exp[i] == \\',\\') continue;\\n            if(exp[i] == \\'&\\' || exp[i] == \\'|\\' || exp[i] == \\'!\\') {\\n                op.push(exp[i]);\\n            }\\n            else if(exp[i] == \\'(\\') {\\n                st.push(exp[i]);\\n            }\\n            else if(exp[i] == \\'t\\') {\\n                st.push(\\'1\\');\\n            }\\n            else if(exp[i] == \\'f\\') {\\n                st.push(\\'0\\');\\n            }\\n            else {    // closing bracket\\n                char curr_op = op.top();\\n                op.pop();\\n                int num = -1;\\n                while(!st.empty() && st.top() != \\'(\\') {\\n                    if(curr_op == \\'!\\') num = !(st.top()-\\'0\\');     // \\'!\\' is single input operator\\n                    else if(num == -1) num = st.top()-\\'0\\';\\n                    else {\\n                        if(curr_op == \\'&\\') num &= (st.top()-\\'0\\');\\n                        if(curr_op == \\'|\\') num |= (st.top()-\\'0\\');\\n                    }\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(num != -1) st.push(num+\\'0\\');\\n            }\\n        }\\n        \\n        if(st.top()==\\'1\\') return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string exp) {\\n        stack<char> st , op;\\n\\n        for(int i=0;i<exp.length();i++) {\\n            if(exp[i] == \\',\\') continue;\\n            if(exp[i] == \\'&\\' || exp[i] == \\'|\\' || exp[i] == \\'!\\') {\\n                op.push(exp[i]);\\n            }\\n            else if(exp[i] == \\'(\\') {\\n                st.push(exp[i]);\\n            }\\n            else if(exp[i] == \\'t\\') {\\n                st.push(\\'1\\');\\n            }\\n            else if(exp[i] == \\'f\\') {\\n                st.push(\\'0\\');\\n            }\\n            else {    // closing bracket\\n                char curr_op = op.top();\\n                op.pop();\\n                int num = -1;\\n                while(!st.empty() && st.top() != \\'(\\') {\\n                    if(curr_op == \\'!\\') num = !(st.top()-\\'0\\');     // \\'!\\' is single input operator\\n                    else if(num == -1) num = st.top()-\\'0\\';\\n                    else {\\n                        if(curr_op == \\'&\\') num &= (st.top()-\\'0\\');\\n                        if(curr_op == \\'|\\') num |= (st.top()-\\'0\\');\\n                    }\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(num != -1) st.push(num+\\'0\\');\\n            }\\n        }\\n        \\n        if(st.top()==\\'1\\') return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680037,
                "title": "full-smooth-solution-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f_not(const string& s,int& i){\\n        i+=2;\\n        auto ret = f(s,i);\\n        i++;\\n        return !ret;\\n    }\\n    \\n    bool f_and(const string& s,int& i){\\n        i+=2;\\n        bool ret = true;\\n        ret &= f(s,i);\\n        while(s[i]!=\\')\\'){\\n            i++;\\n            ret &= f(s,i);\\n        }\\n        i++;\\n        return ret;\\n    }\\n    \\n    bool f_or(const string& s,int& i){\\n        i+=2;\\n        bool ret = false;\\n        ret |= f(s,i);\\n        while(s[i]!=\\')\\'){\\n            i++;\\n            ret |= f(s,i);\\n        }\\n        i++;\\n        return ret;\\n    }\\n    \\n    bool f(const string& s, int& i){\\n        if(s[i] == \\'t\\'){\\n            i++;\\n            return true;\\n        } else if(s[i] == \\'f\\'){\\n            i++;\\n            return false;\\n        } else if(s[i] == \\'!\\'){\\n            return f_not(s,i);\\n        } else if(s[i] == \\'&\\'){\\n            return f_and(s,i);\\n        } return f_or(s,i);\\n    }\\n    bool parseBoolExpr(string expression) {\\n        int i = 0;\\n        return f(expression,i);\\n    }\\n};\\n```\\nUpvote if it helps\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f_not(const string& s,int& i){\\n        i+=2;\\n        auto ret = f(s,i);\\n        i++;\\n        return !ret;\\n    }\\n    \\n    bool f_and(const string& s,int& i){\\n        i+=2;\\n        bool ret = true;\\n        ret &= f(s,i);\\n        while(s[i]!=\\')\\'){\\n            i++;\\n            ret &= f(s,i);\\n        }\\n        i++;\\n        return ret;\\n    }\\n    \\n    bool f_or(const string& s,int& i){\\n        i+=2;\\n        bool ret = false;\\n        ret |= f(s,i);\\n        while(s[i]!=\\')\\'){\\n            i++;\\n            ret |= f(s,i);\\n        }\\n        i++;\\n        return ret;\\n    }\\n    \\n    bool f(const string& s, int& i){\\n        if(s[i] == \\'t\\'){\\n            i++;\\n            return true;\\n        } else if(s[i] == \\'f\\'){\\n            i++;\\n            return false;\\n        } else if(s[i] == \\'!\\'){\\n            return f_not(s,i);\\n        } else if(s[i] == \\'&\\'){\\n            return f_and(s,i);\\n        } return f_or(s,i);\\n    }\\n    bool parseBoolExpr(string expression) {\\n        int i = 0;\\n        return f(expression,i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675851,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def parseBoolExpr(expression: String): Boolean = {\\n      val stack = scala.collection.mutable.Stack[Char]()\\n      for (c <- expression) \\n        if (c == \\')\\') {\\n          val seen = scala.collection.mutable.Set[Char]()\\n          while (stack.top != \\'(\\') seen += stack.pop()\\n          stack.pop()\\n          val operator = stack.pop()\\n          if (operator == \\'!\\') stack.push(if (seen.head == \\'t\\') \\'f\\' else \\'t\\')\\n          else if (operator == \\'&\\') stack.push(if (seen.contains(\\'f\\')) \\'f\\' else \\'t\\')\\n          else if (operator == \\'|\\') stack.push(if (seen.contains(\\'t\\')) \\'t\\' else \\'f\\')\\n        } else if (c != \\',\\') stack.push(c)\\n      stack.top == \\'t\\'\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def parseBoolExpr(expression: String): Boolean = {\\n      val stack = scala.collection.mutable.Stack[Char]()\\n      for (c <- expression) \\n        if (c == \\')\\') {\\n          val seen = scala.collection.mutable.Set[Char]()\\n          while (stack.top != \\'(\\') seen += stack.pop()\\n          stack.pop()\\n          val operator = stack.pop()\\n          if (operator == \\'!\\') stack.push(if (seen.head == \\'t\\') \\'f\\' else \\'t\\')\\n          else if (operator == \\'&\\') stack.push(if (seen.contains(\\'f\\')) \\'f\\' else \\'t\\')\\n          else if (operator == \\'|\\') stack.push(if (seen.contains(\\'t\\')) \\'t\\' else \\'f\\')\\n        } else if (c != \\',\\') stack.push(c)\\n      stack.top == \\'t\\'\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3672517,
                "title": "java-easy-to-understand-time-complexity-o-n-space-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar apporach to solve this problem is that using evalutate expression in stack.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple follow logical gates property and count no. of true and false:\\n\\nLike in \\n1. Logical OR gate: if one true is present then resut is always true\\n2. Logical AND gate if one false is present then result is always false\\n1. Logical NOT gate: It is apply only one variable and the invented  value of input like input : true -> false / false -> true\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nDepends upon the size of stack --> O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nDepends upon the size of stack --> O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> st = new Stack<>();\\n        boolean ans = true;\\n        int count_True = 0 , count_False = 0;\\n        for(int i=0;i<expression.length();i++){\\n            if(expression.charAt(i)==\\')\\'){\\n                count_True = 0;\\n                count_False = 0;\\n                while(!st.empty()){\\n                    char ch = st.pop();\\n                    if(ch==\\'!\\'||ch==\\'|\\'||ch==\\'&\\'){\\n                        switch(ch){\\n                            case \\'&\\':\\n                                ans = count_False > 0 && count_True>=0 ? false : true;\\n                                break;\\n                            case \\'|\\':\\n                               ans = count_False >= 0 && count_True>0 ? true : false;\\n                               break;\\n                            default:\\n                               ans = count_False > 0 ? true : false;\\n                               break;\\n                        }\\n                        ch = ans ? \\'t\\' : \\'f\\';\\n                        st.push(ch);\\n                        break;\\n                    }\\n                    else{\\n                        if(ch==\\'t\\'){\\n                            ++count_True;\\n                        }\\n                        else{\\n                            if(ch==\\'f\\') ++count_False;\\n                        }\\n                    }\\n                }\\n            }\\n            else{\\n                st.push(expression.charAt(i));\\n            }\\n        }\\n        return st.peek()==\\'t\\' ? true:false;\\n    }\\n}\\n```\\n# **Please up vote for me!!!!**",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> st = new Stack<>();\\n        boolean ans = true;\\n        int count_True = 0 , count_False = 0;\\n        for(int i=0;i<expression.length();i++){\\n            if(expression.charAt(i)==\\')\\'){\\n                count_True = 0;\\n                count_False = 0;\\n                while(!st.empty()){\\n                    char ch = st.pop();\\n                    if(ch==\\'!\\'||ch==\\'|\\'||ch==\\'&\\'){\\n                        switch(ch){\\n                            case \\'&\\':\\n                                ans = count_False > 0 && count_True>=0 ? false : true;\\n                                break;\\n                            case \\'|\\':\\n                               ans = count_False >= 0 && count_True>0 ? true : false;\\n                               break;\\n                            default:\\n                               ans = count_False > 0 ? true : false;\\n                               break;\\n                        }\\n                        ch = ans ? \\'t\\' : \\'f\\';\\n                        st.push(ch);\\n                        break;\\n                    }\\n                    else{\\n                        if(ch==\\'t\\'){\\n                            ++count_True;\\n                        }\\n                        else{\\n                            if(ch==\\'f\\') ++count_False;\\n                        }\\n                    }\\n                }\\n            }\\n            else{\\n                st.push(expression.charAt(i));\\n            }\\n        }\\n        return st.peek()==\\'t\\' ? true:false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660685,
                "title": "easy-java-solution-using-stack",
                "content": "Refer this video for the explanation : \\n\\n\\nhttps://youtu.be/lYw86z7Astg\\n\\n\\nPS: This video is not created by me. I understood the concept of this problem from this video and wrote this code by myself. Maybe it could help you as well.\\n```\\nclass Solution {\\n\\n    public char find(boolean hasTrue, boolean hasFalse, char op){\\n        if(op == \\'!\\') return hasTrue? \\'f\\' : \\'t\\';\\n        else if(op == \\'|\\') return hasTrue? \\'t\\' : \\'f\\';\\n        else if(op == \\'&\\') return hasFalse? \\'f\\' : \\'t\\';\\n        return \\'a\\';\\n    }\\n\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> st = new Stack<>();\\n        char[] exp = expression.toCharArray();\\n        for(char ch : exp){\\n            if(ch == \\',\\') continue;\\n            if(ch != \\')\\') st.push(ch);\\n            else{\\n                boolean hasTrue = false;\\n                boolean hasFalse = false;\\n                while(!st.isEmpty() && st.peek() != \\'(\\'){\\n                    char top = st.pop();\\n                    if(top == \\'t\\') hasTrue = true;\\n                    else if(top == \\'f\\') hasFalse = true;\\n                }\\n                st.pop(); // Removing the opening bracket\\n                char op = st.pop(); // Operator\\n                st.push(find(hasTrue,hasFalse,op));\\n            }\\n        }\\n        return st.peek() == \\'t\\';\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n\\n    public char find(boolean hasTrue, boolean hasFalse, char op){\\n        if(op == \\'!\\') return hasTrue? \\'f\\' : \\'t\\';\\n        else if(op == \\'|\\') return hasTrue? \\'t\\' : \\'f\\';\\n        else if(op == \\'&\\') return hasFalse? \\'f\\' : \\'t\\';\\n        return \\'a\\';\\n    }\\n\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> st = new Stack<>();\\n        char[] exp = expression.toCharArray();\\n        for(char ch : exp){\\n            if(ch == \\',\\') continue;\\n            if(ch != \\')\\') st.push(ch);\\n            else{\\n                boolean hasTrue = false;\\n                boolean hasFalse = false;\\n                while(!st.isEmpty() && st.peek() != \\'(\\'){\\n                    char top = st.pop();\\n                    if(top == \\'t\\') hasTrue = true;\\n                    else if(top == \\'f\\') hasFalse = true;\\n                }\\n                st.pop(); // Removing the opening bracket\\n                char op = st.pop(); // Operator\\n                st.push(find(hasTrue,hasFalse,op));\\n            }\\n        }\\n        return st.peek() == \\'t\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649608,
                "title": "c-shunting-yard-inspired-solution-beats-95-in-time",
                "content": "# Intuition\\nI inspired from the shunting yard algorithm, used to create an RPN from a correctly parsed expression\\n\\n# Approach\\nThis algorithm is inspired by the Shunting Yard Algorithm that is used to calculate the RPN of any right-parenthesized expression.  \\n\\nI use two stacks:  \\n- one that will store the operators *&*, *|*, *!*\\n- another one that will store the other tokens *f*, *t*, *(*\\nit will never contain *\\')\\'* though because of the algorithm\\'s logic (see further)\\n\\nI parse the expression character by character and fill the stacks based on the following logic:\\n- whenever i meet an operator, i push it on the operators stack\\n- whenever I meet any other token except from *\\')\\'*, I push it on the tokens stack\\n- when I meet a closing parenthesis \\')\\', it means that it is closing an operator expression that could have been &(...), |(...) or !(...). It is actually very easy to know, because based on how we pushed our operators on our op stack, it is just the last operator we pushed.\\nSo we just take the operator on top of our op stack, and we apply it to every element on top of our other stack, until we meet a left parenthesis \\'(\\'. It is the signal that we unwinded every elements that were inside our parenthesized expression. We then discard the left parenthesis and push the result of this on top of our expression stack. And we keep going\\n# Complexity\\n$$n$$ is the length of our expression\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(std::string s)\\n    {\\n        std::stack<char> ops, tokens;\\n\\n        for (int i = 0; s[i]; i++)\\n        {\\n            if (s[i] == \\'f\\' || s[i] == \\'t\\' || s[i] == \\'(\\')\\n                tokens.push(s[i]);\\n            else if (s[i] == \\'!\\' || s[i] == \\'&\\' || s[i] == \\'|\\')\\n                ops.push(s[i]);\\n            else if (s[i] == \\')\\')\\n            {\\n                bool res = (tokens.top() == \\'t\\');\\n                tokens.pop();\\n                char op = ops.top();\\n                ops.pop();\\n                if (op == \\'&\\')\\n                {\\n                    while (tokens.top() != \\'(\\')\\n                    {\\n                        res = res && (tokens.top() == \\'t\\');\\n                        tokens.pop();\\n                    }\\n                }\\n                else if (op == \\'|\\')\\n                {\\n                    while (tokens.top() != \\'(\\')\\n                    {\\n                        res = res || (tokens.top() == \\'t\\');\\n                        tokens.pop();\\n                    }\\n                }\\n                else if (op == \\'!\\')\\n                    res = !res;\\n                tokens.pop();\\n                tokens.push(res ? \\'t\\' : \\'f\\');\\n            }\\n        }\\n        return tokens.top() == \\'t\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(std::string s)\\n    {\\n        std::stack<char> ops, tokens;\\n\\n        for (int i = 0; s[i]; i++)\\n        {\\n            if (s[i] == \\'f\\' || s[i] == \\'t\\' || s[i] == \\'(\\')\\n                tokens.push(s[i]);\\n            else if (s[i] == \\'!\\' || s[i] == \\'&\\' || s[i] == \\'|\\')\\n                ops.push(s[i]);\\n            else if (s[i] == \\')\\')\\n            {\\n                bool res = (tokens.top() == \\'t\\');\\n                tokens.pop();\\n                char op = ops.top();\\n                ops.pop();\\n                if (op == \\'&\\')\\n                {\\n                    while (tokens.top() != \\'(\\')\\n                    {\\n                        res = res && (tokens.top() == \\'t\\');\\n                        tokens.pop();\\n                    }\\n                }\\n                else if (op == \\'|\\')\\n                {\\n                    while (tokens.top() != \\'(\\')\\n                    {\\n                        res = res || (tokens.top() == \\'t\\');\\n                        tokens.pop();\\n                    }\\n                }\\n                else if (op == \\'!\\')\\n                    res = !res;\\n                tokens.pop();\\n                tokens.push(res ? \\'t\\' : \\'f\\');\\n            }\\n        }\\n        return tokens.top() == \\'t\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638925,
                "title": "kotlin-using-stack-beats-100",
                "content": "# Intuition\\nSimple stack problem\\n# Approach\\nJust add all the \\'&\\' \\'|\\' \\'!\\' \\'t\\' \\'f\\' \\'(\\' to stack and perform operation when you encounter a \\')\\'. The operation you perform should replace the expression till last operation with the corresponding result. \\n# Complexity\\n- Time complexity:\\nO(N^2) - Think of a case like !(!(!(!(!(!(!(f)))))))\\n- Space complexity:\\nO(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun parseBoolExpr(expression: String): Boolean {\\n        val stack = mutableListOf<Char>()\\n        expression.forEachIndexed{ index, value ->\\n            if(value == \\'&\\' || value == \\'|\\' || value == \\'!\\' || value == \\'(\\' || value == \\'t\\' || value == \\'f\\'){\\n                stack.add(value)\\n            }\\n            if(value == \\')\\'){\\n                popStack(stack)\\n            }\\n        }\\n        return stack[0] == \\'t\\'\\n    }\\n\\n    fun popStack(stack: MutableList<Char>){\\n        var op = \\' \\'\\n        val expArray = mutableListOf<Char>()\\n        for (it in (stack.lastIndex downTo 0)){\\n            val e = stack.removeAt(it)\\n            if(e == \\'t\\' || e == \\'f\\') expArray.add(e)\\n            if(e == \\'&\\' || e == \\'|\\' || e == \\'!\\' ){\\n                op = e\\n                break\\n            }\\n        }\\n        stack.add(when(op){\\n            \\'&\\' -> andChars(expArray)\\n            \\'|\\' -> orChars(expArray)\\n            else -> negateChars(expArray)\\n        })\\n    }\\n\\n    fun andChars(exps: MutableList<Char>): Char {\\n        return if(exps.contains(\\'f\\'))  \\'f\\' else \\'t\\'\\n    }\\n    fun orChars(exps: MutableList<Char>): Char {\\n        return if(exps.contains(\\'t\\')) \\'t\\' else \\'f\\'\\n    }\\n    fun negateChars(exps: MutableList<Char>): Char {\\n        if(exps[0] == \\'t\\') return \\'f\\' else return \\'t\\'\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun parseBoolExpr(expression: String): Boolean {\\n        val stack = mutableListOf<Char>()\\n        expression.forEachIndexed{ index, value ->\\n            if(value == \\'&\\' || value == \\'|\\' || value == \\'!\\' || value == \\'(\\' || value == \\'t\\' || value == \\'f\\'){\\n                stack.add(value)\\n            }\\n            if(value == \\')\\'){\\n                popStack(stack)\\n            }\\n        }\\n        return stack[0] == \\'t\\'\\n    }\\n\\n    fun popStack(stack: MutableList<Char>){\\n        var op = \\' \\'\\n        val expArray = mutableListOf<Char>()\\n        for (it in (stack.lastIndex downTo 0)){\\n            val e = stack.removeAt(it)\\n            if(e == \\'t\\' || e == \\'f\\') expArray.add(e)\\n            if(e == \\'&\\' || e == \\'|\\' || e == \\'!\\' ){\\n                op = e\\n                break\\n            }\\n        }\\n        stack.add(when(op){\\n            \\'&\\' -> andChars(expArray)\\n            \\'|\\' -> orChars(expArray)\\n            else -> negateChars(expArray)\\n        })\\n    }\\n\\n    fun andChars(exps: MutableList<Char>): Char {\\n        return if(exps.contains(\\'f\\'))  \\'f\\' else \\'t\\'\\n    }\\n    fun orChars(exps: MutableList<Char>): Char {\\n        return if(exps.contains(\\'t\\')) \\'t\\' else \\'f\\'\\n    }\\n    fun negateChars(exps: MutableList<Char>): Char {\\n        if(exps[0] == \\'t\\') return \\'f\\' else return \\'t\\'\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633148,
                "title": "c-recursion-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsee the code and you can easily understand it...\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseor(string expression){\\n        vector<bool>v;\\n        \\n        int idx=0;\\n        while(idx<expression.length()){\\n            string temp=\"\";\\n            int cnt=0;\\n            while(idx<expression.length()){\\n                 if(  expression[idx]==\\',\\' && cnt==0)break;\\n                 if(expression[idx]==\\'(\\')cnt++;\\n                if(expression[idx]==\\')\\')cnt--;\\n                temp+=expression[idx];\\n                idx++;\\n            }\\n            cout<<temp<<endl;\\n            v.push_back(parseBoolExpr(temp));\\n            idx++;\\n        }\\n\\n        bool ans=false;\\n        for(auto x:v)ans=ans||x;\\n        return ans;\\n    }\\n    bool parseand(string expression){\\n        vector<bool>v;\\n        \\n        int idx=0;\\n        while(idx<expression.length()){\\n            string temp=\"\";\\n            int cnt=0;\\n            while(idx<expression.length()){\\n                if(  (expression[idx]==\\',\\' && cnt==0))break;\\n                if(expression[idx]==\\'(\\')cnt++;\\n                if(expression[idx]==\\')\\')cnt--;\\n                temp+=expression[idx];\\n                idx++;\\n            }\\n            cout<<temp<<endl;\\n            v.push_back(parseBoolExpr(temp));\\n            idx++;\\n        }\\n\\n        bool ans=true;\\n        for(auto x:v)ans=ans&&x;\\n        return ans;\\n    }\\n\\n    bool parseBoolExpr(string expression) {\\n        if(expression.length()==1){\\n            return expression[0]==\\'t\\'?true:false;\\n        }\\n        if(expression[0]==\\'|\\'){\\n           return parseor(expression.substr(2,expression.length()-3));\\n        }\\n        if(expression[0]==\\'&\\'){\\n           return parseand(expression.substr(2,expression.length()-3));\\n        }\\n        if(expression[0]==\\'!\\'){\\n           return !parseBoolExpr(expression.substr(2,expression.length()-3));\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseor(string expression){\\n        vector<bool>v;\\n        \\n        int idx=0;\\n        while(idx<expression.length()){\\n            string temp=\"\";\\n            int cnt=0;\\n            while(idx<expression.length()){\\n                 if(  expression[idx]==\\',\\' && cnt==0)break;\\n                 if(expression[idx]==\\'(\\')cnt++;\\n                if(expression[idx]==\\')\\')cnt--;\\n                temp+=expression[idx];\\n                idx++;\\n            }\\n            cout<<temp<<endl;\\n            v.push_back(parseBoolExpr(temp));\\n            idx++;\\n        }\\n\\n        bool ans=false;\\n        for(auto x:v)ans=ans||x;\\n        return ans;\\n    }\\n    bool parseand(string expression){\\n        vector<bool>v;\\n        \\n        int idx=0;\\n        while(idx<expression.length()){\\n            string temp=\"\";\\n            int cnt=0;\\n            while(idx<expression.length()){\\n                if(  (expression[idx]==\\',\\' && cnt==0))break;\\n                if(expression[idx]==\\'(\\')cnt++;\\n                if(expression[idx]==\\')\\')cnt--;\\n                temp+=expression[idx];\\n                idx++;\\n            }\\n            cout<<temp<<endl;\\n            v.push_back(parseBoolExpr(temp));\\n            idx++;\\n        }\\n\\n        bool ans=true;\\n        for(auto x:v)ans=ans&&x;\\n        return ans;\\n    }\\n\\n    bool parseBoolExpr(string expression) {\\n        if(expression.length()==1){\\n            return expression[0]==\\'t\\'?true:false;\\n        }\\n        if(expression[0]==\\'|\\'){\\n           return parseor(expression.substr(2,expression.length()-3));\\n        }\\n        if(expression[0]==\\'&\\'){\\n           return parseand(expression.substr(2,expression.length()-3));\\n        }\\n        if(expression[0]==\\'!\\'){\\n           return !parseBoolExpr(expression.substr(2,expression.length()-3));\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3614994,
                "title": "parsing-a-boolean-expression",
                "content": "\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character>st = new Stack<>();\\n        for(char ch :expression.toCharArray()){\\n            if(ch!=\\')\\')\\n            st.push(ch);\\n            else{\\n                boolean T =false ,F = false;\\n                while(st.peek()!=\\'(\\'){\\n                  char check = st.pop();\\n                  if(check==\\'f\\')\\n                    F = true;\\n                  else if(check==\\'t\\')\\n                  T = true;  \\n                }\\n                st.pop();\\n                char optr  = st.pop();\\n                if(optr==\\'&\\'){\\n                    if(F)\\n                    st.push(\\'f\\');\\n                    else\\n                    st.push(\\'t\\');\\n                }\\n                else if(optr ==\\'!\\'){\\n                   if(F)\\n                   st.push(\\'t\\');\\n                   else\\n                    st.push(\\'f\\');\\n                }\\n                else{\\n                    if(T)\\n                     st.push(\\'t\\');\\n                     else\\n                   st.push(\\'f\\');\\n                }\\n            }\\n        }\\n        return st.pop()==\\'t\\'?true:false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character>st = new Stack<>();\\n        for(char ch :expression.toCharArray()){\\n            if(ch!=\\')\\')\\n            st.push(ch);\\n            else{\\n                boolean T =false ,F = false;\\n                while(st.peek()!=\\'(\\'){\\n                  char check = st.pop();\\n                  if(check==\\'f\\')\\n                    F = true;\\n                  else if(check==\\'t\\')\\n                  T = true;  \\n                }\\n                st.pop();\\n                char optr  = st.pop();\\n                if(optr==\\'&\\'){\\n                    if(F)\\n                    st.push(\\'f\\');\\n                    else\\n                    st.push(\\'t\\');\\n                }\\n                else if(optr ==\\'!\\'){\\n                   if(F)\\n                   st.push(\\'t\\');\\n                   else\\n                    st.push(\\'f\\');\\n                }\\n                else{\\n                    if(T)\\n                     st.push(\\'t\\');\\n                     else\\n                   st.push(\\'f\\');\\n                }\\n            }\\n        }\\n        return st.pop()==\\'t\\'?true:false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588797,
                "title": "using-stack-only-no-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string e) {\\n        if(e.size()==1)return (e[0]==\\'t\\');\\n        stack<char>st;\\n        for(int i = 0;i<e.size();i++){\\n            if(e[i]==\\')\\'){\\n                string t;\\n                while(!st.empty() and st.top()!=\\'(\\'){\\n                    t.push_back(st.top());\\n                    st.pop();\\n                }\\n                if(!st.empty())st.pop();\\n                if(t.size()==0)continue;\\n                char op;\\n                if(!st.empty()){\\n                    op = st.top();\\n                    st.pop();\\n                }\\n                \\n                if(op==\\'!\\'){\\n                    if(t[0]==\\'0\\')st.push(\\'1\\');\\n                    else st.push(\\'0\\');\\n                }\\n                else{\\n                    while(t.size()>1){\\n                    if(op==\\'|\\'){\\n                        int x = (t[t.size()-1] - \\'0\\') | (t[t.size()-2] -\\'0\\');\\n                        t.pop_back();\\n                        t.pop_back();\\n                        t.push_back(x + \\'0\\');\\n                    }\\n                    else if(op==\\'&\\'){\\n                        int x = (int(t[t.size()-1]) - \\'0\\') & (int(t[t.size()-2]) -\\'0\\');\\n                        t.pop_back();\\n                        t.pop_back();\\n                        t.push_back(x+\\'0\\');\\n                    }\\n                  }\\n                  st.push(t[0]);\\n                }\\n                cout<<st.top();\\n            }\\n            else {\\n                if(e[i]==\\'t\\')st.push(\\'1\\');\\n                else if(e[i]==\\'f\\')st.push(\\'0\\');\\n                else if(e[i]==\\',\\')continue;\\n                else st.push(e[i]);\\n            }\\n            cout<<st.size()<<\" \";\\n        }\\n        if(st.top()==\\'0\\')return 0;\\n        else return 1;\\n        return st.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string e) {\\n        if(e.size()==1)return (e[0]==\\'t\\');\\n        stack<char>st;\\n        for(int i = 0;i<e.size();i++){\\n            if(e[i]==\\')\\'){\\n                string t;\\n                while(!st.empty() and st.top()!=\\'(\\'){\\n                    t.push_back(st.top());\\n                    st.pop();\\n                }\\n                if(!st.empty())st.pop();\\n                if(t.size()==0)continue;\\n                char op;\\n                if(!st.empty()){\\n                    op = st.top();\\n                    st.pop();\\n                }\\n                \\n                if(op==\\'!\\'){\\n                    if(t[0]==\\'0\\')st.push(\\'1\\');\\n                    else st.push(\\'0\\');\\n                }\\n                else{\\n                    while(t.size()>1){\\n                    if(op==\\'|\\'){\\n                        int x = (t[t.size()-1] - \\'0\\') | (t[t.size()-2] -\\'0\\');\\n                        t.pop_back();\\n                        t.pop_back();\\n                        t.push_back(x + \\'0\\');\\n                    }\\n                    else if(op==\\'&\\'){\\n                        int x = (int(t[t.size()-1]) - \\'0\\') & (int(t[t.size()-2]) -\\'0\\');\\n                        t.pop_back();\\n                        t.pop_back();\\n                        t.push_back(x+\\'0\\');\\n                    }\\n                  }\\n                  st.push(t[0]);\\n                }\\n                cout<<st.top();\\n            }\\n            else {\\n                if(e[i]==\\'t\\')st.push(\\'1\\');\\n                else if(e[i]==\\'f\\')st.push(\\'0\\');\\n                else if(e[i]==\\',\\')continue;\\n                else st.push(e[i]);\\n            }\\n            cout<<st.size()<<\" \";\\n        }\\n        if(st.top()==\\'0\\')return 0;\\n        else return 1;\\n        return st.top();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3583376,
                "title": "intuitive-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe typical pattern can be described as such:\\n\\none \"sign\" ```(|, &, !)```, followed by a \"```()```\", inside of which there may be \"```f```\", \"```t```\", or another ```expression```.\\n\\nWith this realization, we define a function ```boolean dp(s)``` which takes a string and generates the boolean value it represents. \\n\\n\\n\\n# Approach\\nThe first character of the string is guaranteed to be ```|``` ```&``` or ```!```. So we say char ```sign = s.charAt(0);```\\n\\nAfter the first character we traverse the string. If we see a \"```t```\" or an \"```f```\" we parse it and add to our list. Whenever we see another \"```sign```\", we know there is a nested string that needs to be decoded. \\nWe define an integer ```stack = 1 ```, which is used to indicate the layer of the parenthesis. We then move our pointer forward: any left parenthesis ```(``` will add 1 to the ```stack```; any right parenthesis ```)``` will reduce the stack by 1. When the stack is zero, it means we have reached the end of the nested string. We then subtract this string and do the recursion. \\n \\n# Note: \\n\\nThis recursion does not have an explicit \"base case\" as the actual base would the an expression that does not have any nested string. For example: ```|(t,f,t,f)```\\n\\nIf you find my solution useful, please upvote :)\\n\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        return dp(expression);\\n    }\\n\\n    boolean dp(String s){\\n\\n      char sign = s.charAt(0);\\n      List<Boolean> list = new ArrayList();\\n\\n      for(int i = 1; i<s.length(); i++){\\n          \\n          char c = s.charAt(i);\\n          if(c==\\'t\\' || c==\\'f\\') {\\n            if(c==\\'t\\') list.add(true);\\n            else if (c==\\'f\\') list.add(false);\\n          } else if(c==\\'&\\' || c==\\'|\\' ||c==\\'!\\' ){\\n            \\n            int j = i+2;\\n            int stack = 1;\\n            //!(&(f,t, !(f,t)))\\n\\n            while(stack!=0){\\n              if(s.charAt(j)==\\'(\\') stack++;\\n              else if(s.charAt(j)==\\')\\') stack--;\\n              j++;\\n            }\\n\\n            boolean sub = dp(s.substring(i, j));\\n            list.add(sub);\\n            i=j-1;\\n          }\\n          \\n      }\\n      \\n     return eval(sign, list);\\n\\n    }\\n\\n    boolean eval(char sign, List<Boolean> list){\\n\\n        boolean res = false;\\n\\n        if(sign == \\'|\\'){\\n          boolean first = false;\\n\\n          for(boolean flag: list){\\n            res|=flag;\\n          }\\n          \\n        }\\n\\n        if(sign == \\'&\\'){\\n          res = true;\\n          boolean first = true;\\n          for(boolean flag: list){\\n            res &=flag;\\n          }\\n        }\\n\\n        if(sign == \\'!\\'){\\n          return !list.get(0);\\n        }\\n\\n        return res;\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```(|, &, !)```\n```()```\n```f```\n```t```\n```expression```\n```boolean dp(s)```\n```|```\n```&```\n```!```\n```sign = s.charAt(0);```\n```t```\n```f```\n```sign```\n```stack = 1 ```\n```(```\n```stack```\n```)```\n```|(t,f,t,f)```\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        return dp(expression);\\n    }\\n\\n    boolean dp(String s){\\n\\n      char sign = s.charAt(0);\\n      List<Boolean> list = new ArrayList();\\n\\n      for(int i = 1; i<s.length(); i++){\\n          \\n          char c = s.charAt(i);\\n          if(c==\\'t\\' || c==\\'f\\') {\\n            if(c==\\'t\\') list.add(true);\\n            else if (c==\\'f\\') list.add(false);\\n          } else if(c==\\'&\\' || c==\\'|\\' ||c==\\'!\\' ){\\n            \\n            int j = i+2;\\n            int stack = 1;\\n            //!(&(f,t, !(f,t)))\\n\\n            while(stack!=0){\\n              if(s.charAt(j)==\\'(\\') stack++;\\n              else if(s.charAt(j)==\\')\\') stack--;\\n              j++;\\n            }\\n\\n            boolean sub = dp(s.substring(i, j));\\n            list.add(sub);\\n            i=j-1;\\n          }\\n          \\n      }\\n      \\n     return eval(sign, list);\\n\\n    }\\n\\n    boolean eval(char sign, List<Boolean> list){\\n\\n        boolean res = false;\\n\\n        if(sign == \\'|\\'){\\n          boolean first = false;\\n\\n          for(boolean flag: list){\\n            res|=flag;\\n          }\\n          \\n        }\\n\\n        if(sign == \\'&\\'){\\n          res = true;\\n          boolean first = true;\\n          for(boolean flag: list){\\n            res &=flag;\\n          }\\n        }\\n\\n        if(sign == \\'!\\'){\\n          return !list.get(0);\\n        }\\n\\n        return res;\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568231,
                "content": [
                    {
                        "username": "bluedreamer94",
                        "content": "In the problem description, it says: \\n\"&(expr1,expr2,...)\", evaluating to the logical AND of 2 or more inner expressions\"\\nand there is a corresponding statement for the OR operator.\\n\\nHowever, when I submitted my solution, I failed on this test case:\\n\"!(&(!(t),&(f),|(f)))\"\\n\\nAs you can see, there are ANDs and ORs with only 1 argument. I was able to complete my solution simply by having my code return the input value for the AND or OR of a single argument, ie AND(t) = t, OR(f) = f, etc\\n\\nIt would be good for LeetCoders if the problem statement could be corrected. Other than\\nthat I think this is a great problem btw."
                    },
                    {
                        "username": "AnujJadhav",
                        "content": "It says invalid expression for this testcase, I think they have updated the testcases."
                    },
                    {
                        "username": "ranjithreddy-31",
                        "content": "This should be labeled as Medium"
                    },
                    {
                        "username": "Msey",
                        "content": "Classic approach is to use a polish notation featuring stack"
                    }
                ]
            },
            {
                "id": 1983448,
                "content": [
                    {
                        "username": "bluedreamer94",
                        "content": "In the problem description, it says: \\n\"&(expr1,expr2,...)\", evaluating to the logical AND of 2 or more inner expressions\"\\nand there is a corresponding statement for the OR operator.\\n\\nHowever, when I submitted my solution, I failed on this test case:\\n\"!(&(!(t),&(f),|(f)))\"\\n\\nAs you can see, there are ANDs and ORs with only 1 argument. I was able to complete my solution simply by having my code return the input value for the AND or OR of a single argument, ie AND(t) = t, OR(f) = f, etc\\n\\nIt would be good for LeetCoders if the problem statement could be corrected. Other than\\nthat I think this is a great problem btw."
                    },
                    {
                        "username": "AnujJadhav",
                        "content": "It says invalid expression for this testcase, I think they have updated the testcases."
                    },
                    {
                        "username": "ranjithreddy-31",
                        "content": "This should be labeled as Medium"
                    },
                    {
                        "username": "Msey",
                        "content": "Classic approach is to use a polish notation featuring stack"
                    }
                ]
            },
            {
                "id": 1829521,
                "content": [
                    {
                        "username": "bluedreamer94",
                        "content": "In the problem description, it says: \\n\"&(expr1,expr2,...)\", evaluating to the logical AND of 2 or more inner expressions\"\\nand there is a corresponding statement for the OR operator.\\n\\nHowever, when I submitted my solution, I failed on this test case:\\n\"!(&(!(t),&(f),|(f)))\"\\n\\nAs you can see, there are ANDs and ORs with only 1 argument. I was able to complete my solution simply by having my code return the input value for the AND or OR of a single argument, ie AND(t) = t, OR(f) = f, etc\\n\\nIt would be good for LeetCoders if the problem statement could be corrected. Other than\\nthat I think this is a great problem btw."
                    },
                    {
                        "username": "AnujJadhav",
                        "content": "It says invalid expression for this testcase, I think they have updated the testcases."
                    },
                    {
                        "username": "ranjithreddy-31",
                        "content": "This should be labeled as Medium"
                    },
                    {
                        "username": "Msey",
                        "content": "Classic approach is to use a polish notation featuring stack"
                    }
                ]
            }
        ]
    }
]