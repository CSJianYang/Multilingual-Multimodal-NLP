[
    {
        "title": "Koko Eating Bananas",
        "question_content": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\nReturn the minimum integer k such that she can eat all the bananas within h hours.\n&nbsp;\nExample 1:\n\nInput: piles = [3,6,7,11], h = 8\nOutput: 4\n\nExample 2:\n\nInput: piles = [30,11,23,4,20], h = 5\nOutput: 30\n\nExample 3:\n\nInput: piles = [30,11,23,4,20], h = 6\nOutput: 23\n\n&nbsp;\nConstraints:\n\n\t1 <= piles.length <= 104\n\tpiles.length <= h <= 109\n\t1 <= piles[i] <= 109",
        "solutions": [
            {
                "id": 769702,
                "title": "python-clear-explanation-powerful-ultimate-binary-search-template-solved-many-problems",
                "content": "First thing first, here is the code:\\n\\n```python\\ndef minEatingSpeed(piles: List[int], H: int) -> int:\\n    def feasible(speed) -> bool:\\n        # return sum(math.ceil(pile / speed) for pile in piles) <= H  # slower        \\n        return sum((pile - 1) / speed + 1 for pile in piles) <= H  # faster\\n\\n    left, right = 1, max(piles)\\n    while left < right:\\n        mid = left  + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\nI have built a powerful generalized binary search template and used it to solve many problems easily. Below is the detailed and clear introduction to this template. I believe it will be worth your time :)\\n\\n****\\n\\n# Intro\\n\\nBinary Search is quite easy to understand conceptually. Basically, it splits the search space into two halves and only keep the half that probably has the search target and throw away the other half that would not possibly have the answer. In this manner, we reduce the search space to half the size at every step, until we find the target. Binary Search helps us reduce the search time from linear O(n) to logarithmic O(log n). But when it comes to implementation, it\\'s rather difficult to write a bug-free code in just a few minutes. Some of the most common problems include:\\n\\n- When to exit the loop? Should we use `left < right` or `left <= right` as the while loop condition?\\n- How to initialize the boundary variable `left` and `right`?\\n- How to update the boundary? How to choose the appropriate combination from `left = mid `, `left = mid + 1` and  `right = mid`, `right = mid - 1`?\\n\\nA rather common misunderstanding of binary search is that people often think this technique could only be used in simple scenario like \"Given a sorted array, find a specific value in it\". As a matter of fact, it can be applied to much more complicated situations.\\n\\nAfter a lot of practice in LeetCode, I\\'ve made a powerful binary search template and solved many Hard problems by just slightly twisting this template. I\\'ll share the template with you guys in this post. I don\\'t want to just show off the code and leave. Most importantly, I want to share the logical thinking: how to apply this general template to all sorts of problems. Hopefully, after reading this post, people wouldn\\'t be pissed off any more when LeetCoding, \"Holy sh*t! This problem could be solved with binary search! Why didn\\'t I think of that before!\"\\n\\n\\n\\n****\\n\\n\\n\\n# Most Generalized Binary Search\\n\\nSuppose we have a search space. It could be an array, a range, etc. Usually it\\'s sorted in ascend order. For most tasks, we can transform the requirement into the following generalized form:\\n\\n**Minimize k ,    s.t.  condition(k) is True**\\n\\nThe following code is the most generalized binary search template:\\n\\n```python\\ndef binary_search(array) -> int:\\n    def condition(value) -> bool:\\n        pass\\n\\n    left, right = 0, len(array)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\nWhat\\'s really nice of this template is that, for most of the binary search problems, we only need to modify three parts after copy-pasting this template, and never need to worry about corner cases and bugs in code any more:\\n\\n- Correctly initialize the boundary variables `left` and `right`. Only one rule: set up the boundary to **include all possible elements**;\\n- Decide return value. Is it `return left` or `return left - 1`? Remember this: **after exiting the while loop, `left` is the minimal k\\u200B satisfying the `condition ` function**;\\n- Design the `condition` function. This is the most difficult and most beautiful part. Needs lots of practice.\\n\\nBelow I\\'ll show you guys how to apply this powerful template to many LeetCode problems.\\n\\n\\n\\n****\\n\\n\\n\\n# Basic Application\\n\\n## [278. First Bad Version [Easy]](https://leetcode.com/problems/first-bad-version/)\\n\\nYou are a product manager and currently leading a team to develop a new product. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have `n` versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API `bool isBadVersion(version)` which will return whether `version` is bad.\\n\\n**Example:**\\n\\n```scala\\nGiven n = 5, and version = 4 is the first bad version.\\n\\ncall isBadVersion(3) -> false\\ncall isBadVersion(5) -> true\\ncall isBadVersion(4) -> true\\n\\nThen 4 is the first bad version. \\n```\\n\\nFirst, we initialize `left = 1` and `right = n` to include all possible values. Then we notice that we don\\'t even need to design the `condition` function. It\\'s already given by the `isBadVersion` API. Finding the first bad version is equivalent to finding the minimal k satisfying `isBadVersion(k) is True`. Our template can fit in very nicely:\\n\\n```python\\nclass Solution:\\n    def firstBadVersion(self, n) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n****\\n\\n\\n\\n## [69. Sqrt(x) [Easy]](https://leetcode.com/problems/sqrtx/)\\n\\nImplement `int sqrt(int x)`. Compute and return the square root of *x*, where *x* is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.\\n\\n**Example:**\\n\\n```scala\\nInput: 4\\nOutput: 2\\n```\\n\\n```scala\\nInput: 8\\nOutput: 2\\n```\\n\\nQuite an easy problem. We need to search for maximal k satisfying `k^2 <= x`, so we can easily come up with the solution:\\n\\n```python\\ndef mySqrt(x: int) -> int:\\n    left, right = 0, x\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if mid * mid <= x:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return left - 1\\n```\\n\\nThere\\'s one thing I\\'d like to point out. Remember I say that **we usually look for the minimal k value satisfying certain condition**? But in this problem we are searching for maximal k value instead. Feeling confused? Don\\'t be. Actually, the maximal k satisfying `condition(k) is False` is just equal to the minimal k satisfying `condition(k) is True` minus one. This is why I mentioned earlier that we need to decide which value to return, `left` or `left - 1`.\\n\\n\\n\\n****\\n\\n\\n\\n## [35. Search Insert Position [Easy]](https://leetcode.com/problems/search-insert-position/)\\n\\nGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.\\n\\n**Example:**\\n\\n```scala\\nInput: [1,3,5,6], 5\\nOutput: 2\\n```\\n\\n```scala\\nInput: [1,3,5,6], 2\\nOutput: 1\\n```\\n\\nVery classic application of binary search. We are looking for the minimal k value satisfying `nums[k] >= target`, and we can just copy-paste our template. Notice that our solution is correct regardless of whether the input array `nums` has duplicates. Also notice that the input  `target` might be larger than all elements in `nums` and therefore needs to placed at the end of the array. That\\'s why we should initialize `right = len(nums)` instead of `right = len(nums) - 1`.\\n\\n```python\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if nums[mid] >= target:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n# Advanced Application\\n\\nThe above problems are quite easy to solve, because they already give us the array to be searched. We\\'d know that we should use binary search to solve them at first glance.  However, more often are the situations where the search space and search target are not so readily available. Sometimes we won\\'t even realize that the problem should be solved with binary search -- we might just turn to dynamic programming or DFS and get stuck for a very long time.\\n\\nAs for the question \"When can we use binary search?\", my answer is that, **If we can discover some kind of monotonicity, for example, if `condition(k) is True` then `condition(k + 1) is True`, then we can consider binary search**.\\n\\n## [1011. Capacity To Ship Packages Within D Days [Medium]](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n\\ndays. The `i`-th package on the conveyor belt has a weight of `weights[i]`. Each day, we load the ship with packages on the conveyor belt (in the order given by `weights`). We may not load more weight than the maximum weight capacity of the ship. \\n\\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within `D` days.\\n\\n**Example :**\\n\\n```scala\\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5\\nOutput: 15\\nExplanation: \\nA ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\\n1st day: 1, 2, 3, 4, 5\\n2nd day: 6, 7\\n3rd day: 8\\n4th day: 9\\n5th day: 10\\n\\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. \\n```\\n\\nBinary search probably would not come to our mind when we first meet this problem. We might automatically treat `weights` as search space and then realize we\\'ve entered a dead end after wasting lots of time. In fact, we are looking for the minimal one among all feasible capacities. We dig out the monotonicity of this problem: if we can successfully ship all packages within `D` days with capacity `m`, then we can definitely ship them all with any capacity larger than `m`. Now we can design a `condition` function, let\\'s call it `feasible`, given an input `capacity`, it returns whether it\\'s possible to ship all packages within `D` days. This can run in a greedy way: if there\\'s still room for the current package, we put this package onto the conveyor belt, otherwise we wait for the next day to place this package. If the total days needed exceeds `D`, we return `False`, otherwise we return `True`.\\n\\nNext, we need to initialize our boundary correctly. Obviously `capacity` should be at least `max(weights)`, otherwise the conveyor belt couldn\\'t ship the heaviest package. On the other hand, `capacity` need not be more than`sum(weights)`, because then we can ship all packages in just one day.\\n\\nNow we\\'ve got all we need to apply our binary search template:\\n\\n```python\\ndef shipWithinDays(weights: List[int], D: int) -> int:\\n    def feasible(capacity) -> bool:\\n        days = 1\\n        total = 0\\n        for weight in weights:\\n            total += weight\\n            if total > capacity:  # too heavy, wait for the next day\\n                total = weight\\n                days += 1\\n                if days > D:  # cannot ship within D days\\n                    return False\\n        return True\\n\\n    left, right = max(weights), sum(weights)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [410. Split Array Largest Sum [Hard]](https://leetcode.com/problems/split-array-largest-sum/)\\n\\nGiven an array which consists of non-negative integers and an integer *m*, you can split the array into *m* non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these *m* subarrays.\\n\\n**Example:**\\n\\n```scala\\nInput:\\nnums = [7,2,5,10,8]\\nm = 2\\n\\nOutput:\\n18\\n\\nExplanation:\\nThere are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n```\\n\\nIf you take a close look, you would probably see how similar this problem is with LC 1011 above. Similarly, we can design a `feasible` function: given an input `threshold`, then decide if we can split the array into several subarrays such that every subarray-sum is less than or equal to `threshold`. In this way, we discover the monotonicity of the problem: if `feasible(m)` is `True`, then all inputs larger than `m` can satisfy `feasible` function. You can see that the solution code is exactly the same as LC 1011.\\n\\n```python\\ndef splitArray(nums: List[int], m: int) -> int:        \\n    def feasible(threshold) -> bool:\\n        count = 1\\n        total = 0\\n        for num in nums:\\n            total += num\\n            if total > threshold:\\n                total = num\\n                count += 1\\n                if count > m:\\n                    return False\\n        return True\\n\\n    left, right = max(nums), sum(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid     \\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\nBut we probably would have doubts: It\\'s true that `left` returned by our solution is the minimal value satisfying `feasible`, but how can we know that we can split the original array to **actually get this subarray-sum**? For example, let\\'s say `nums = [7,2,5,10,8]` and `m = 2`. We have 4 different ways to split the array to get 4 different largest subarray-sum correspondingly: `25:[[7], [2,5,10,8]]`, `23:[[7,2], [5,10,8]]`, `18:[[7,2,5], [10,8]]`, `24:[[7,2,5,10], [8]]`. Only 4 values. But our search space `[max(nums), sum(nums)] = [10, 32]` has much more that just 4 values. That is, no matter how we split the input array, we cannot get most of the values in our search space.\\n\\nLet\\'s say `k` is the minimal value satisfying `feasible` function. We can prove the correctness of our solution with proof by contradiction. Assume that no subarray\\'s sum is equal to `k`, that is, every subarray sum is less than `k`. The variable `total` inside `feasible` function keeps track of the total weights of current load. If our assumption is correct, then `total` would always be less than `k`. As a result, `feasible(k - 1)` must be `True`, because `total` would at most be equal to `k - 1` and would never trigger the if-clause `if total > threshold`, therefore `feasible(k - 1)` must have the same output as `feasible(k)`, which is `True`. But we already know that `k`  is the minimal value satisfying `feasible` function, so `feasible(k - 1)` has to be `False`, which is a contradiction. So our assumption is incorrect. Now we\\'ve proved that our algorithm is correct.\\n\\n\\n\\n****\\n\\n\\n\\n## [875. Koko Eating Bananas [Medium]](https://leetcode.com/problems/koko-eating-bananas/)\\n\\nKoko loves to eat bananas. There are `N` piles of bananas, the `i`-th pile has `piles[i]` bananas. The guards have gone and will come back in `H` hours. Koko can decide her bananas-per-hour eating speed of `K`. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than `K` bananas, she eats all of them instead, and won\\'t eat any more bananas during this hour. \\n\\nKoko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back. **Return the minimum integer `K` such that she can eat all the bananas within `H` hours**.\\n\\n**Example :**\\n\\n```scala\\nInput: piles = [3,6,7,11], H = 8\\nOutput: 4\\n```\\n\\n```scala\\nInput: piles = [30,11,23,4,20], H = 5\\nOutput: 30\\n```\\n\\n```scala\\nInput: piles = [30,11,23,4,20], H = 6\\nOutput: 23\\n```\\n\\nVery similar to LC 1011 and LC 410 mentioned above. Let\\'s design a `feasible` function, given an input `speed`, determine whether Koko can finish all bananas within `H` hours with hourly eating speed `speed`. Obviously, the lower bound of the search space is 1, and upper bound is `max(piles)`, because Koko can only choose one pile of bananas to eat every hour.\\n\\n```python\\ndef minEatingSpeed(piles: List[int], H: int) -> int:\\n    def feasible(speed) -> bool:\\n        # return sum(math.ceil(pile / speed) for pile in piles) <= H  # slower        \\n        return sum((pile - 1) / speed + 1 for pile in piles) <= H  # faster\\n\\n    left, right = 1, max(piles)\\n    while left < right:\\n        mid = left  + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [1482. Minimum Number of Days to Make m Bouquets [Medium]](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\\n\\nGiven an integer array `bloomDay`, an integer `m` and an integer `k`. We need to make `m` bouquets. To make a bouquet, you need to use `k` **adjacent flowers** from the garden. The garden consists of `n` flowers, the `ith` flower will bloom in the `bloomDay[i]` and then can be used in **exactly one** bouquet. Return *the minimum number of days* you need to wait to be able to make `m` bouquets from the garden. If it is impossible to make `m` bouquets return **-1**.\\n\\n**Examples:**\\n\\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 1\\nOutput: 3\\nExplanation: Let\\'s see what happened in the first three days. x means flower bloomed and _ means flower didn\\'t bloom in the garden.\\nWe need 3 bouquets each should contain 1 flower.\\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.\\n```\\n\\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 2\\nOutput: -1\\nExplanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\\n```\\n\\nNow that we\\'ve solved three advanced problems above, this one should be pretty easy to do. The monotonicity of this problem is very clear: if we can make `m` bouquets after waiting for `d` days, then we can definitely finish that as well if we wait more than `d` days.\\n\\n```python\\ndef minDays(bloomDay: List[int], m: int, k: int) -> int:\\n    def feasible(days) -> bool:\\n        bonquets, flowers = 0, 0\\n        for bloom in bloomDay:\\n            if bloom > days:\\n                flowers = 0\\n            else:\\n                bonquets += (flowers + 1) // k\\n                flowers = (flowers + 1) % k\\n        return bonquets >= m\\n\\n    if len(bloomDay) < m * k:\\n        return -1\\n    left, right = 1, max(bloomDay)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [668. Kth Smallest Number in Multiplication Table [Hard]](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\\n\\nNearly every one have used the [Multiplication Table](https://en.wikipedia.org/wiki/Multiplication_table). But could you find out the `k-th` smallest number quickly from the multiplication table? Given the height `m` and the length `n` of a `m * n` Multiplication Table, and a positive integer `k`, you need to return the `k-th` smallest number in this table.\\n\\n**Example :**\\n\\n```scala\\nInput: m = 3, n = 3, k = 5\\nOutput: 3\\nExplanation: \\nThe Multiplication Table:\\n1\\t2\\t3\\n2\\t4\\t6\\n3\\t6\\t9\\n\\nThe 5-th smallest number is 3 (1, 2, 2, 3, 3).\\n```\\n\\nFor Kth-Smallest problems like this, what comes to our mind first is Heap. Usually we can  maintain a Min-Heap and just pop the top of the Heap for k times. However, that doesn\\'t work out in this problem. We don\\'t have every single number in the entire Multiplication Table, instead, we only have the height and the length of the table. If we are to apply Heap method, we need to explicitly calculate these `m * n` values and save them to a heap. The time complexity and space complexity of this process are both O(mn), which is quite inefficient. This is when binary search comes in. Remember we say that designing `condition` function is the most difficult part? In order to find the k-th smallest value in the table, we can design an `enough` function, given an input `num`, determine whether there\\'re at least k values less than or equal to `num`. **The minimal `num` satisfying `enough` function is the answer we\\'re looking for**. Recall that the key to binary search is discovering monotonicity. In this problem, if `num` satisfies `enough`, then of course any value larger than `num` can satisfy. This monotonicity is the fundament of our binary search algorithm.\\n\\nLet\\'s consider search space. Obviously the lower bound should be 1, and the upper bound should be the largest value in the Multiplication Table, which is `m * n`, then we have search space `[1, m * n]`. The overwhelming advantage of binary search solution to heap solution is that it doesn\\'t need to explicitly calculate all numbers in that table, all it needs is just picking up one value out of the search space and apply `enough` function to this value, to determine should we keep the left half or the right half of the search space. In this way, binary search solution only requires constant space complexity, much better than heap solution.\\n\\nNext let\\'s consider how to implement `enough` function. It can be observed that every row in the Multiplication Table is just multiples of its index. For example, all numbers in 3rd row `[3,6,9,12,15...]` are multiples of 3. Therefore, we can just go row by row to count the total number of entries less than or equal to input `num`. Following is the complete solution.\\n\\n```python\\ndef findKthNumber(m: int, n: int, k: int) -> int:\\n    def enough(num) -> bool:\\n        count = 0\\n        for val in range(1, m + 1):  # count row by row\\n            add = min(num // val, n)\\n            if add == 0:  # early exit\\n                break\\n            count += add\\n        return count >= k                \\n\\n    left, right = 1, n * m\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left \\n```\\n\\nIn LC 410 above, we have doubt \"Is the result from binary search actually a subarray sum?\". Here we have a similar doubt: \"Is the result from binary search actually in the Multiplication Table?\". The answer is yes, and we also can apply proof by contradiction. Denote `num` as the minimal input that satisfies `enough` function. Let\\'s assume that `num` is not in the table, which means that `num` is not divisible by any `val` in `[1, m]`, that is, `num % val > 0`. Therefore, changing the input from `num` to `num - 1` doesn\\'t have any effect on the expression `add = min(num // val, n)`. So `enough(num)` would also return `True`,  just like `enough(num)`. But we already know `num` is the minimal input satisfying `enough` function, so `enough(num - 1)` has to be `False`. Contradiction! The opposite of our original assumption is true: `num` is actually in the table.\\n\\n\\n\\n****\\n\\n\\n\\n## [719. Find K-th Smallest Pair Distance [Hard]](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)\\n\\nGiven an integer array, return the k-th smallest **distance** among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.\\n\\n**Example :**\\n\\n```scala\\nInput:\\nnums = [1,3,1]\\nk = 1\\nOutput: 0 \\nExplanation:\\nFollowing are all the pairs. The 1st smallest distance pair is (1,1), and its distance is 0.\\n(1,3) -> 2\\n(1,1) -> 0\\n(3,1) -> 2\\n```\\n\\nVery similar to LC 668 above, both are about finding Kth-Smallest. Just like LC 668, We can design an `enough` function, given an input `distance`, determine whether there\\'re at least k pairs whose distances are less than or equal to `distance`. We can sort the input array and use two pointers (fast pointer and slow pointer, pointed at a pair) to scan it. Both pointers go from leftmost end. If the current pair pointed at has a distance less than or equal to `distance`, all pairs between these pointers are valid (since the array is already sorted), we move forward the fast pointer. Otherwise, we move forward the slow pointer. By the time both pointers reach the rightmost end, we finish our scan and see if total counts exceed k. Here is the implementation:\\n\\n```python\\ndef enough(distance) -> bool:  # two pointers\\n    count, i, j = 0, 0, 0\\n    while i < n or j < n:\\n        while j < n and nums[j] - nums[i] <= distance:  # move fast pointer\\n            j += 1\\n        count += j - i - 1  # count pairs\\n        i += 1  # move slow pointer\\n    return count >= k\\n```\\n\\nObviously, our search space should be `[0, max(nums) - min(nums)]`. Now we are ready to copy-paste our template:\\n\\n```python\\ndef smallestDistancePair(nums: List[int], k: int) -> int:\\n    nums.sort()\\n    n = len(nums)\\n    left, right = 0, nums[-1] - nums[0]\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [1201. Ugly Number III [Medium]](https://leetcode.com/problems/ugly-number-iii/)\\n\\nWrite a program to find the `n`-th ugly number. Ugly numbers are **positive integers** which are divisible by `a` **or** `b` **or** `c`.\\n\\n**Example :**\\n\\n```scala\\nInput: n = 3, a = 2, b = 3, c = 5\\nOutput: 4\\nExplanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.\\n```\\n\\n```scala\\nInput: n = 4, a = 2, b = 3, c = 4\\nOutput: 6\\nExplanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.\\n```\\n\\nNothing special. Still finding the Kth-Smallest. We need to design an `enough` function, given an input `num`, determine whether there are at least n ugly numbers less than or equal to `num`. Since `a` might be a multiple of `b` or `c`, or the other way round, we need the help of greatest common divisor to avoid counting duplicate numbers.\\n\\n```python\\ndef nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\\n    def enough(num) -> bool:\\n        total = mid//a + mid//b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n        return total >= n\\n\\n    ab = a * b // math.gcd(a, b)\\n    ac = a * c // math.gcd(a, c)\\n    bc = b * c // math.gcd(b, c)\\n    abc = a * bc // math.gcd(a, bc)\\n    left, right = 1, 10 ** 10\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [1283. Find the Smallest Divisor Given a Threshold [Medium]](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/)\\n\\nGiven an array of integers `nums` and an integer `threshold`, we will choose a positive integer divisor and divide all the array by it and sum the result of the division. Find the **smallest** divisor such that the result mentioned above is less than or equal to `threshold`.\\n\\nEach result of division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5). It is guaranteed that there will be an answer.\\n\\n**Example :**\\n\\n```scala\\nInput: nums = [1,2,5,9], threshold = 6\\nOutput: 5\\nExplanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. \\nIf the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). \\n```\\n\\nAfter so many problems introduced above, this one should be a piece of cake. We don\\'t even need to bother to design a `condition` function, because the problem has already told us explicitly what condition we need to satisfy.\\n\\n```python\\ndef smallestDivisor(nums: List[int], threshold: int) -> int:\\n    def condition(divisor) -> bool:\\n        return sum((num - 1) // divisor + 1 for num in nums) <= threshold\\n\\n    left, right = 1, max(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n# End\\n\\nWow, thank you so much for making it to the end, really appreciate that. As you can see from the python codes above, they all look very similar to each other. That\\'s because I copy-pasted my template all the time. No exception. This is the strong proof of my template\\'s powerfulness. I believe everyone can acquire this binary search template to solve many problems. All we need is just more practice to build up our ability to discover the monotonicity of the problem and to design a beautiful `condition` function.\\n\\nHope this helps.\\n\\n**Reference**\\n\\n- [[C++ / Fast / Very clear explanation / Clean Code] Solution with Greedy Algorithm and Binary Search](https://leetcode.com/problems/split-array-largest-sum/discuss/89819/C%2B%2B-Fast-Very-clear-explanation-Clean-Code-Solution-with-Greedy-Algorithm-and-Binary-Search)\\n- [Approach the problem using the \"trial and error\" algorithm](https://leetcode.com/problems/find-k-th-smallest-pair-distance/discuss/109082/Approach-the-problem-using-the-\"trial-and-error\"-algorithm)\\n- [Binary Search 101 The-Ultimate-Binary-Search-Handbook - LeetCode](https://leetcode.com/problems/binary-search/discuss/423162/Binary-Search-101-The-Ultimate-Binary-Search-Handbook)\\n- [ugly-number-iii Binary Search with picture & Binary Search Template - LeetCode](https://leetcode.com/problems/ugly-number-iii/discuss/387539/cpp-Binary-Search-with-picture-and-Binary-Search-Template)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\ndef minEatingSpeed(piles: List[int], H: int) -> int:\\n    def feasible(speed) -> bool:\\n        # return sum(math.ceil(pile / speed) for pile in piles) <= H  # slower        \\n        return sum((pile - 1) / speed + 1 for pile in piles) <= H  # faster\\n\\n    left, right = 1, max(piles)\\n    while left < right:\\n        mid = left  + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```python\\ndef binary_search(array) -> int:\\n    def condition(value) -> bool:\\n        pass\\n\\n    left, right = 0, len(array)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nGiven n = 5, and version = 4 is the first bad version.\\n\\ncall isBadVersion(3) -> false\\ncall isBadVersion(5) -> true\\ncall isBadVersion(4) -> true\\n\\nThen 4 is the first bad version. \\n```\n```python\\nclass Solution:\\n    def firstBadVersion(self, n) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```scala\\nInput: 4\\nOutput: 2\\n```\n```scala\\nInput: 8\\nOutput: 2\\n```\n```python\\ndef mySqrt(x: int) -> int:\\n    left, right = 0, x\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if mid * mid <= x:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return left - 1\\n```\n```scala\\nInput: [1,3,5,6], 5\\nOutput: 2\\n```\n```scala\\nInput: [1,3,5,6], 2\\nOutput: 1\\n```\n```python\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if nums[mid] >= target:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```scala\\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5\\nOutput: 15\\nExplanation: \\nA ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\\n1st day: 1, 2, 3, 4, 5\\n2nd day: 6, 7\\n3rd day: 8\\n4th day: 9\\n5th day: 10\\n\\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. \\n```\n```python\\ndef shipWithinDays(weights: List[int], D: int) -> int:\\n    def feasible(capacity) -> bool:\\n        days = 1\\n        total = 0\\n        for weight in weights:\\n            total += weight\\n            if total > capacity:  # too heavy, wait for the next day\\n                total = weight\\n                days += 1\\n                if days > D:  # cannot ship within D days\\n                    return False\\n        return True\\n\\n    left, right = max(weights), sum(weights)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput:\\nnums = [7,2,5,10,8]\\nm = 2\\n\\nOutput:\\n18\\n\\nExplanation:\\nThere are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n```\n```python\\ndef splitArray(nums: List[int], m: int) -> int:        \\n    def feasible(threshold) -> bool:\\n        count = 1\\n        total = 0\\n        for num in nums:\\n            total += num\\n            if total > threshold:\\n                total = num\\n                count += 1\\n                if count > m:\\n                    return False\\n        return True\\n\\n    left, right = max(nums), sum(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid     \\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: piles = [3,6,7,11], H = 8\\nOutput: 4\\n```\n```scala\\nInput: piles = [30,11,23,4,20], H = 5\\nOutput: 30\\n```\n```scala\\nInput: piles = [30,11,23,4,20], H = 6\\nOutput: 23\\n```\n```python\\ndef minEatingSpeed(piles: List[int], H: int) -> int:\\n    def feasible(speed) -> bool:\\n        # return sum(math.ceil(pile / speed) for pile in piles) <= H  # slower        \\n        return sum((pile - 1) / speed + 1 for pile in piles) <= H  # faster\\n\\n    left, right = 1, max(piles)\\n    while left < right:\\n        mid = left  + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 1\\nOutput: 3\\nExplanation: Let\\'s see what happened in the first three days. x means flower bloomed and _ means flower didn\\'t bloom in the garden.\\nWe need 3 bouquets each should contain 1 flower.\\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.\\n```\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 2\\nOutput: -1\\nExplanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\\n```\n```python\\ndef minDays(bloomDay: List[int], m: int, k: int) -> int:\\n    def feasible(days) -> bool:\\n        bonquets, flowers = 0, 0\\n        for bloom in bloomDay:\\n            if bloom > days:\\n                flowers = 0\\n            else:\\n                bonquets += (flowers + 1) // k\\n                flowers = (flowers + 1) % k\\n        return bonquets >= m\\n\\n    if len(bloomDay) < m * k:\\n        return -1\\n    left, right = 1, max(bloomDay)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: m = 3, n = 3, k = 5\\nOutput: 3\\nExplanation: \\nThe Multiplication Table:\\n1\\t2\\t3\\n2\\t4\\t6\\n3\\t6\\t9\\n\\nThe 5-th smallest number is 3 (1, 2, 2, 3, 3).\\n```\n```python\\ndef findKthNumber(m: int, n: int, k: int) -> int:\\n    def enough(num) -> bool:\\n        count = 0\\n        for val in range(1, m + 1):  # count row by row\\n            add = min(num // val, n)\\n            if add == 0:  # early exit\\n                break\\n            count += add\\n        return count >= k                \\n\\n    left, right = 1, n * m\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left \\n```\n```scala\\nInput:\\nnums = [1,3,1]\\nk = 1\\nOutput: 0 \\nExplanation:\\nFollowing are all the pairs. The 1st smallest distance pair is (1,1), and its distance is 0.\\n(1,3) -> 2\\n(1,1) -> 0\\n(3,1) -> 2\\n```\n```python\\ndef enough(distance) -> bool:  # two pointers\\n    count, i, j = 0, 0, 0\\n    while i < n or j < n:\\n        while j < n and nums[j] - nums[i] <= distance:  # move fast pointer\\n            j += 1\\n        count += j - i - 1  # count pairs\\n        i += 1  # move slow pointer\\n    return count >= k\\n```\n```python\\ndef smallestDistancePair(nums: List[int], k: int) -> int:\\n    nums.sort()\\n    n = len(nums)\\n    left, right = 0, nums[-1] - nums[0]\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: n = 3, a = 2, b = 3, c = 5\\nOutput: 4\\nExplanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.\\n```\n```scala\\nInput: n = 4, a = 2, b = 3, c = 4\\nOutput: 6\\nExplanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.\\n```\n```python\\ndef nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\\n    def enough(num) -> bool:\\n        total = mid//a + mid//b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n        return total >= n\\n\\n    ab = a * b // math.gcd(a, b)\\n    ac = a * c // math.gcd(a, c)\\n    bc = b * c // math.gcd(b, c)\\n    abc = a * bc // math.gcd(a, bc)\\n    left, right = 1, 10 ** 10\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: nums = [1,2,5,9], threshold = 6\\nOutput: 5\\nExplanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. \\nIf the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). \\n```\n```python\\ndef smallestDivisor(nums: List[int], threshold: int) -> int:\\n    def condition(divisor) -> bool:\\n        return sum((num - 1) // divisor + 1 for num in nums) <= threshold\\n\\n    left, right = 1, max(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152506,
                "title": "binary-search-java-python-with-explanations",
                "content": "Each hour, Koko chooses some pile of bananas, and eats `K` bananas from that pile. \\n\\nThere is a limited value range of `K`: `[lo, hi]`. \\nThere is a `K\\'` value, such that `K`(for any `K >= K\\'`) can enable her to eat all the bananas within `H` hours: `[K\\', hi]`.\\nWe are asked to find `K\\'`.\\n\\nGiven a linear searching space `[lo, hi]`, `[mi, hi]` (lo <= mi) satisfy a property, we can use Binary Searc to get `mi`.\\n\\nInitially, we know that K belongs to [1, the largest element in `piles[]`]. And we follow the pattern of lower-bound Binary Search except that `if (K == target)` is replaced with `if (canEatAll(piles, K, H))`.\\n****\\n**Java**\\n```\\n    public int minEatingSpeed(int[] piles, int H) {\\n        int lo = 1, hi = getMaxPile(piles);\\n        \\n        // Binary search to find the smallest valid K.\\n        while (lo <= hi) {\\n            int K = lo + ((hi - lo) >> 1);\\n            if (canEatAll(piles, K, H)) {\\n                hi = K - 1;\\n            } else {\\n                lo = K + 1;\\n            }\\n        }\\n        \\n        return lo;\\n    }\\n    \\n    private boolean canEatAll(int[] piles, int K, int H) {\\n        int countHour = 0; // Hours take to eat all bananas at speed K.\\n        \\n        for (int pile : piles) {\\n            countHour += pile / K;\\n            if (pile % K != 0)\\n                countHour++;\\n        }\\n        return countHour <= H;\\n    }\\n    \\n    private int getMaxPile(int[] piles) {\\n        int maxPile = Integer.MIN_VALUE;\\n        for (int pile : piles) {\\n            maxPile = Math.max(pile, maxPile);\\n        }\\n        return maxPile;\\n    }\\n```\\n**Python**\\n```\\n    def minEatingSpeed(self, piles, H):\\n        lo, hi = 1, max(piles)\\n        \\n        while lo <= hi:\\n            K = lo + ((hi - lo) >> 1)\\n            if self.countTimeEatAllAtSpeed(\\n                    K, piles) <= H:  # count time to eat all bananas at speed K\\n                hi = K - 1\\n            else:\\n                lo = K + 1\\n        return lo\\n    \\n    def countTimeEatAllAtSpeed(self, K, piles):\\n        countHours = 0  # hours take to eat all bananas\\n        \\n        for pile in piles:\\n            countHours += pile / K\\n            if pile % K != 0:\\n                countHours += 1\\n        return countHours\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n    public int minEatingSpeed(int[] piles, int H) {\\n        int lo = 1, hi = getMaxPile(piles);\\n        \\n        // Binary search to find the smallest valid K.\\n        while (lo <= hi) {\\n            int K = lo + ((hi - lo) >> 1);\\n            if (canEatAll(piles, K, H)) {\\n                hi = K - 1;\\n            } else {\\n                lo = K + 1;\\n            }\\n        }\\n        \\n        return lo;\\n    }\\n    \\n    private boolean canEatAll(int[] piles, int K, int H) {\\n        int countHour = 0; // Hours take to eat all bananas at speed K.\\n        \\n        for (int pile : piles) {\\n            countHour += pile / K;\\n            if (pile % K != 0)\\n                countHour++;\\n        }\\n        return countHour <= H;\\n    }\\n    \\n    private int getMaxPile(int[] piles) {\\n        int maxPile = Integer.MIN_VALUE;\\n        for (int pile : piles) {\\n            maxPile = Math.max(pile, maxPile);\\n        }\\n        return maxPile;\\n    }\\n```\n```\\n    def minEatingSpeed(self, piles, H):\\n        lo, hi = 1, max(piles)\\n        \\n        while lo <= hi:\\n            K = lo + ((hi - lo) >> 1)\\n            if self.countTimeEatAllAtSpeed(\\n                    K, piles) <= H:  # count time to eat all bananas at speed K\\n                hi = K - 1\\n            else:\\n                lo = K + 1\\n        return lo\\n    \\n    def countTimeEatAllAtSpeed(self, K, piles):\\n        countHours = 0  # hours take to eat all bananas\\n        \\n        for pile in piles:\\n            countHours += pile / K\\n            if pile % K != 0:\\n                countHours += 1\\n        return countHours\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 152324,
                "title": "java-c-python-binary-search",
                "content": "# Explanation\\nBinary search between `[1, 10^9]` or `[1, max(piles)]` to find the result.\\nTime complexity: `O(NlogM)`\\n\\n`(p + m - 1) / m` equal to `ceil(p / m)` (just personal behavior)\\n\\nHere you find another similar problem.\\n[774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/113633/C++JavaPython-Binary-Search)\\n<br>\\n\\n# Complexity\\nTime `O(Nlog(MaxP))`\\nSpace `O(1)`\\n<br>\\n\\n**C++:**\\n```cpp\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        int l = 1, r = 1000000000;\\n        while (l < r) {\\n            int m = (l + r) / 2, total = 0;\\n            for (int p : piles)\\n                total += (p + m - 1) / m;\\n            if (total > H)\\n                l = m + 1;\\n            else\\n                r = m;\\n        }\\n        return l;\\n    }\\n```\\n**Java:**\\n```java\\n    public int minEatingSpeed(int[] piles, int H) {\\n        int l = 1, r = 1000000000;\\n        while (l < r) {\\n            int m = (l + r) / 2, total = 0;\\n            for (int p : piles)\\n                total += (p + m - 1) / m;\\n            if (total > H)\\n                l = m + 1;\\n            else\\n                r = m;\\n        }\\n        return l;\\n    }\\n```\\n**Python:**\\n```py\\n    def minEatingSpeed(self, piles, H):\\n        l, r = 1, max(piles)\\n        while l < r:\\n            m = (l + r) / 2\\n            if sum((p + m - 1) / m for p in piles) > H:\\n                l = m + 1\\n            else:\\n                r = m\\n        return l\\n```\\n<br>\\n\\n# More Good Binary Search Problems\\nHere are some similar binary search problems.\\nAlso find more explanations.\\nGood luck and have fun.\\n\\n- 1539. [Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/discuss/779999/JavaC++Python-O(logN))\\n- 1482. [Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/686316/javacpython-binary-search/578488)\\n- 1283. [Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/discuss/446376/javacpython-bianry-search/401806)\\n- 1231. [Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/408503/Python-Binary-Search)\\n- 1011. [Capacity To Ship Packages In N Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/256729/javacpython-binary-search/351188?page=3)\\n- 875. [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/152324/C++JavaPython-Binary-Search)\\n- 774. [Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/113633/Easy-and-Concise-Solution-using-Binary-Search-C++JavaPython)\\n- 410. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n<br>",
                "solutionTags": [],
                "code": "```cpp\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        int l = 1, r = 1000000000;\\n        while (l < r) {\\n            int m = (l + r) / 2, total = 0;\\n            for (int p : piles)\\n                total += (p + m - 1) / m;\\n            if (total > H)\\n                l = m + 1;\\n            else\\n                r = m;\\n        }\\n        return l;\\n    }\\n```\n```java\\n    public int minEatingSpeed(int[] piles, int H) {\\n        int l = 1, r = 1000000000;\\n        while (l < r) {\\n            int m = (l + r) / 2, total = 0;\\n            for (int p : piles)\\n                total += (p + m - 1) / m;\\n            if (total > H)\\n                l = m + 1;\\n            else\\n                r = m;\\n        }\\n        return l;\\n    }\\n```\n```py\\n    def minEatingSpeed(self, piles, H):\\n        l, r = 1, max(piles)\\n        while l < r:\\n            m = (l + r) / 2\\n            if sum((p + m - 1) / m for p in piles) > H:\\n                l = m + 1\\n            else:\\n                r = m\\n        return l\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1703687,
                "title": "java-c-a-very-very-well-detailed-explanation",
                "content": "```\\nLet\\'s understand the solution, as we are going to be using Binary Search we have given an Array [3,6,7,11] \\nAnd we have to eat every single pile of bananas in less than or equals to hours = 8.\\nIf we not able to do that Gurad will kill KOKO [just a joke] \\n```\\nAs we know that the potential rate that we\\'re eating bananas at **k** is going to be between **1**  that\\'s the minimum it could possibly be. The max it could possibly be is going to be whatever the max in our input array is and that is **11**.\\nSo, then we\\'re going to initialize a range like this **k = [1,2,3,4,5,6,7,8,9,10,11]** the entire range we have. Going all the way from **1** to the max value **11**.\\n![image](https://assets.leetcode.com/users/images/012f952e-b395-419a-b8fc-cfafd16cb907_1642649929.7762113.png)\\n\\nSo, in other words we\\'re going to have a **left pointer** at the **minimum** and a **right pointer** at the **maximum** . Then we compute the middle by taking the **average of left & right / 2 i.e. 1 + 11 / 2 = 6**. So, our **middle** will be here at **6** in other words that **k** we\\'re trying is going to be here at this rate that we\\'re going to eat bananas at rate of **6** .\\n\\n`Now let\\'s check can we eat all the piles of bananas at rate of 6. Let\\'s check it,`\\n![image](https://assets.leetcode.com/users/images/e89c158c-d94e-470d-b614-5cce7c826784_1642650601.5053208.png)\\n\\nIf you see that we just eat all piles of bananas in **6 hour** is that a good value. Well it is less than or equals to **8 hours**, but still we have to find the **minimum possible** of **k** value. This might be the solution but less try is there any more **smaller** **k** value then **6**. \\nSo, we **decrement** our **right pointer to mid - 1** becuase there might be the best possible solution available.\\n\\nSo, once again we compute the middle by taking the **average of left & right / 2 i.e. 1 + 5 / 2 = 3** our **k** is here at **3** value \\n\\n`Now let\\'s check can we eat all the piles of bananas at rate of 3. Let\\'s check it,`\\n![image](https://assets.leetcode.com/users/images/6d2a2019-34c4-49f7-b5ad-f4468862d490_1642651233.9354265.png)\\n\\nIf you see that we just eat all piles of bananas in **10 hour** but if you see we went over **8 hours** we took too long to eat all the bananas. So, eating at **rate of 3** didn\\'t work.\\nLet\\'s start searching to right of our range we **increment** our **left pointer to mid + 1** *but remember when we shift our right pointer from the last position to mid -1 we just consider that this range will not work. And that\\'s how Binary search work!*\\n\\nSo, once again we compute the middle by taking the **average of left & right / 2 i.e. 4 + 5 / 2 = 4** our **k** is here at **4** value \\n\\n`Now let\\'s check can we eat all the piles of bananas at rate of 4. Let\\'s check it,`\\n![image](https://assets.leetcode.com/users/images/ee337cb4-121f-4239-93f0-825e66119386_1642653637.250936.png)\\n\\n\\nIf you see that we just eat all piles of bananas in **8 hour**. So, we able to eat all bananas in less than or equals to **8 hours** if we had a rate of **4**. Let\\'s compare this with our current result. So, far we find a value of **6** we update this **6** and we can say there is a more smaller rate we can use i.e. **4**.\\n```\\nBut if we try to calculate more further on then we see our right pointer moves more left to the left pointer. Then we can now stop our Binar Search.\\n```\\n**I hope you got the point. Let\\'s code it up**\\n\\n*code each line explained :* `Similar for C++ & Java`\\n\\n* Step 1 :\\n```\\nint minEatingSpeed(int[] piles, int h) {\\n        int left = 1;\\n        int right = 1000000000;\\n        \\n        while(left <= right){ // performing binary search\\n            int mid = left + (right - left) / 2; // doing in that way, to handle overflow instead of left + right / 2\\n            // if koko can eat, mid bananas per hour in less then or equals to h time\\n            if(canEatInTime(piles, mid, h)) right = mid - 1; // means decrement our right pointer to optimise better solution \\n            else left = mid + 1; // if not true, increment left pointer\\n        }\\n        return left; // bcz left pointer hold our optimize k, at the end of BS\\n    }\\n```\\n* Step 2 : \\n```\\nboolean canEatInTime(int piles[], int k, int h){\\n        \\n        int hours = 0; // track count of hours\\n        for(int pile : piles){\\n            // performing claculation, take an example \\n            // k = 4\\n            // pile = 10\\n\\n            // pile / k => 10 / 4 = 2\\n            // pile % k => 2, so we need to have one more hour to eat remaining bananas left over as remainder \\n            // hours = 3;\\n            int div = pile / k;\\n            hours += div;\\n            if(pile % k != 0) hours++; // if remainder value is not 0, we need to have an extra hour\\n        }\\n        return hours <= h;\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int left = 1;\\n        int right = 1000000000;\\n        \\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(canEatInTime(piles, mid, h)) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n    public boolean canEatInTime(int piles[], int k, int h){\\n        int hours = 0;\\n        for(int pile : piles){\\n            int div = pile / k;\\n            hours += div;\\n            if(pile % k != 0) hours++;\\n        }\\n        return hours <= h;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left = 1;\\n        int right = 1000000000;\\n        \\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(canEatInTime(piles, mid, h)) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n    bool canEatInTime(vector<int>& piles, int k, int h){\\n        int hours = 0;\\n        for(int pile : piles){\\n            int div = pile / k;\\n            hours += div;\\n            if(pile % k != 0) hours++;\\n        }\\n        return hours <= h;\\n    }\\n};\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N * log(M)) where N is no of piles & M is range of K (left to right)\\n\\n* **Space Complexity :-** BigO(1) as not using any extra space",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nLet\\'s understand the solution, as we are going to be using Binary Search we have given an Array [3,6,7,11] \\nAnd we have to eat every single pile of bananas in less than or equals to hours = 8.\\nIf we not able to do that Gurad will kill KOKO [just a joke] \\n```\n```\\nBut if we try to calculate more further on then we see our right pointer moves more left to the left pointer. Then we can now stop our Binar Search.\\n```\n```\\nint minEatingSpeed(int[] piles, int h) {\\n        int left = 1;\\n        int right = 1000000000;\\n        \\n        while(left <= right){ // performing binary search\\n            int mid = left + (right - left) / 2; // doing in that way, to handle overflow instead of left + right / 2\\n            // if koko can eat, mid bananas per hour in less then or equals to h time\\n            if(canEatInTime(piles, mid, h)) right = mid - 1; // means decrement our right pointer to optimise better solution \\n            else left = mid + 1; // if not true, increment left pointer\\n        }\\n        return left; // bcz left pointer hold our optimize k, at the end of BS\\n    }\\n```\n```\\nboolean canEatInTime(int piles[], int k, int h){\\n        \\n        int hours = 0; // track count of hours\\n        for(int pile : piles){\\n            // performing claculation, take an example \\n            // k = 4\\n            // pile = 10\\n\\n            // pile / k => 10 / 4 = 2\\n            // pile % k => 2, so we need to have one more hour to eat remaining bananas left over as remainder \\n            // hours = 3;\\n            int div = pile / k;\\n            hours += div;\\n            if(pile % k != 0) hours++; // if remainder value is not 0, we need to have an extra hour\\n        }\\n        return hours <= h;\\n```\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int left = 1;\\n        int right = 1000000000;\\n        \\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(canEatInTime(piles, mid, h)) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n    public boolean canEatInTime(int piles[], int k, int h){\\n        int hours = 0;\\n        for(int pile : piles){\\n            int div = pile / k;\\n            hours += div;\\n            if(pile % k != 0) hours++;\\n        }\\n        return hours <= h;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left = 1;\\n        int right = 1000000000;\\n        \\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(canEatInTime(piles, mid, h)) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n    bool canEatInTime(vector<int>& piles, int k, int h){\\n        int hours = 0;\\n        for(int pile : piles){\\n            int div = pile / k;\\n            hours += div;\\n            if(pile % k != 0) hours++;\\n        }\\n        return hours <= h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270468,
                "title": "complete-intuition-to-use-binary-search-explained-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/5b1d53cc-0f5a-42e6-8abb-4cb5f0a8eae7_1678247572.0249767.png)\\n\\n![image](https://assets.leetcode.com/users/images/04364f67-e0b4-467c-b2ca-f595c0a0100c_1678238178.6954896.png)\\n\\n```\\nclass Solution {\\npublic:\\n    long long getHoursToEatAll(vector<int>&piles, int bananasPerHour)\\n    {\\n        long long totalHours = 0;\\n        for (int i = 0; i < piles.size(); i++)\\n        {\\n            int hoursToEatPile = ceil(piles[i] / (double)bananasPerHour);\\n            totalHours += hoursToEatPile;\\n        }\\n        return totalHours;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int targetHours)\\n    {\\n        int low = 1, high = *(max_element(piles.begin(), piles.end()));\\n        int ans = -1;\\n        //================================================================\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            long long hoursToEatAll = getHoursToEatAll(piles, mid);\\n            \\n            if (hoursToEatAll <= targetHours)\\n            {\\n                ans = mid; //record the answer (this is the best we could record till curr step)\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        //=================================================================\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getHoursToEatAll(vector<int>&piles, int bananasPerHour)\\n    {\\n        long long totalHours = 0;\\n        for (int i = 0; i < piles.size(); i++)\\n        {\\n            int hoursToEatPile = ceil(piles[i] / (double)bananasPerHour);\\n            totalHours += hoursToEatPile;\\n        }\\n        return totalHours;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int targetHours)\\n    {\\n        int low = 1, high = *(max_element(piles.begin(), piles.end()));\\n        int ans = -1;\\n        //================================================================\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            long long hoursToEatAll = getHoursToEatAll(piles, mid);\\n            \\n            if (hoursToEatAll <= targetHours)\\n            {\\n                ans = mid; //record the answer (this is the best we could record till curr step)\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        //=================================================================\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703550,
                "title": "c-java-python-6-lines-binary-search-image-explained-beginner-friendly",
                "content": "\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n\\n* Given `k`, koko need `ceil(1.0 * piles[i] / k)` to eat up all bananas in `piles[i]`\\n\\t* so given `k`, koko need `hours = sum(math.ceil(1.0 * pile / k) for pile in piles)` to eat up all the bananas from all piles.\\n\\t* `ceil(1.5) = 2`\\n* We can use **Binary Search** to find the minimum `k`\\n\\t* if `hours > h`, that indicates `k` is too small, then `low = k + 1`\\n\\t* if `hours < h`, that indicates `k` is too large, then `high = k - 1`\\n\\t* if `hours == h`, we can try a smaller `k`, then also `high = k - 1`\\n\\t* intuitively, we can initialize ` low = 1, high = 1000000000` or  `low = 1, high = max(piles)`\\n* Note that we are searching `k` via **Binary Search**, we need not sort any array or list, the condition of **Binary Search** is \\n\\t* The search space is limited\\n\\t* Every time after checking for the current `mid`, we know exactly where to search next (greater than `mid` or lower than `mid`)\\n\\n\\n![image](https://assets.leetcode.com/users/images/c88526a1-3ea4-4b45-9bfd-9e13f6f36aa4_1642648234.4864397.png)\\n\\n```\\nTime  Complexity: O(30 * N)  # log2(10 ** 9) = 29.9\\nSpace Complexity: O(1)\\n```\\n\\n**Python**\\n```\\nclass Solution(object):\\n    def minEatingSpeed(self, piles, h):\\n        low, high = 1, 10 ** 9\\n        while low <= high:\\n            k = (low + high) // 2\\n            if sum(math.ceil(1.0 * pile / k) for pile in piles) > h: low = k + 1\\n            else: high = k - 1\\n        return low\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        int low = 1, high = 1000000000, k = 0;\\n        while (low <= high) {\\n            k = (low + high) / 2;\\n            int h = 0;\\n            for (int i = 0; i < piles.size(); i ++) \\n                h += ceil(1.0 * piles[i] / k);\\n            if (h > H)\\n                low = k + 1;\\n            else\\n                high = k - 1;\\n        }\\n        return low;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        int low = 1, high = 1000000000, k = 0;\\n        while (low <= high) {\\n            k = (low + high) / 2;\\n            int h = 0;\\n            for (int i = 0; i < piles.length; i ++) \\n                h += Math.ceil(1.0 * piles[i] / k);\\n            if (h > H)\\n                low = k + 1;\\n            else\\n                high = k - 1;\\n        }\\n        return low;\\n    }\\n}\\n```\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nTime  Complexity: O(30 * N)  # log2(10 ** 9) = 29.9\\nSpace Complexity: O(1)\\n```\n```\\nclass Solution(object):\\n    def minEatingSpeed(self, piles, h):\\n        low, high = 1, 10 ** 9\\n        while low <= high:\\n            k = (low + high) // 2\\n            if sum(math.ceil(1.0 * pile / k) for pile in piles) > h: low = k + 1\\n            else: high = k - 1\\n        return low\\n```\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        int low = 1, high = 1000000000, k = 0;\\n        while (low <= high) {\\n            k = (low + high) / 2;\\n            int h = 0;\\n            for (int i = 0; i < piles.size(); i ++) \\n                h += ceil(1.0 * piles[i] / k);\\n            if (h > H)\\n                low = k + 1;\\n            else\\n                high = k - 1;\\n        }\\n        return low;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        int low = 1, high = 1000000000, k = 0;\\n        while (low <= high) {\\n            k = (low + high) / 2;\\n            int h = 0;\\n            for (int i = 0; i < piles.length; i ++) \\n                h += Math.ceil(1.0 * piles[i] / k);\\n            if (h > H)\\n                low = k + 1;\\n            else\\n                high = k - 1;\\n        }\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270528,
                "title": "java-binary-search-on-answers-with-similar-follow-up-problems",
                "content": "**We need to find the speed of eating bananas per hour i.e k such that he will eat all bananas within hours (h). So if we observe we can know that we can use Binary Search in this. Now you will say how?? We know that we need to find the minimum bananas he can eat within an hour (k) such that koko will eat all bananas within the hours (h). So if suppose we have fixed that koko can eat t bananas within an hour and if the speed of eating is t bananas/ hour then will I be able to eat all bananas within the hour (h)?? If yes, we are not sure that it may or may not be the minimum bananas he will eat in an hour so we will do high=t because obviously we know that if in t bananas/hour if he can achieve the target then why will he go to right because it will not give him the minimum bananas to eat in an hour and for that reason we move to left. We kept on going left till we are able to achieve the target. If we are not able to achieve the target that means we can\\'t eat all bananas with that speed so we move to right. We keep on doing this till we get the speed (bananas to eat within an hour) as minimum as possible. At last we return the answer.\\nIn blackbox we just tried to find if he can eat all banana with that speed (bananas to eat within an hour) within the stipulated time (h). If yes, we return true or else we return false.**\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low=1;\\n        int high=Integer.MIN_VALUE;\\n        for(int i=0;i<piles.length;i++){\\n            high=Math.max(high,piles[i]);\\n        }\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            if(blackbox(mid,piles,h)){\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n    public boolean blackbox(int maxpiles,int[] piles,int h){\\n        int hours=0;\\n        for(int i:piles){\\n            int time=i/maxpiles;\\n            hours+=time;\\n            if(i%maxpiles!=0) hours++;\\n        }\\n        if(hours<=h)\\n            return true;\\n        return false;\\n    }\\n}\\n```\\n**Similar follow up problems related to Binary Search on Answers :- https://leetcode.com/problems/minimum-time-to-complete-trips/discuss/3266855/All-Binary-Search-Problems**\\n\\n![image](https://assets.leetcode.com/users/images/c7ed53ec-f37f-4429-b7b2-79fb768a16c3_1678237613.4171617.jpeg)",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low=1;\\n        int high=Integer.MIN_VALUE;\\n        for(int i=0;i<piles.length;i++){\\n            high=Math.max(high,piles[i]);\\n        }\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            if(blackbox(mid,piles,h)){\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n    public boolean blackbox(int maxpiles,int[] piles,int h){\\n        int hours=0;\\n        for(int i:piles){\\n            int time=i/maxpiles;\\n            hours+=time;\\n            if(i%maxpiles!=0) hours++;\\n        }\\n        if(hours<=h)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270477,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find the minimum integer `k` such that Koko can eat all the bananas within `h`\\nhours. This means that we need to find the smallest value of `k` such that she can eat all\\nthe bananas within `h` hours.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize left and right pointers as `left = 1` and `right = maximum number of bananas in any pile`.\\n2. While the left pointer is less than the right pointer, repeat the following:\\na. Calculate the middle pointer using `mid = (left + right) / 2`.\\nb. Check if Koko can eat all the bananas at the current speed (middle pointer) within `h` hours using the `canEatAll` method.\\nc. If Koko can eat all the bananas at the current speed, update the right pointer to the middle pointer using `right = mid`.\\nd. If Koko cannot eat all the bananas at the current speed, update the left pointer to `mid + 1`.\\n3. Once the left pointer is equal to the right pointer, return the left pointer as the minimum speed at which Koko can eat all the bananas within h hours.\\nThe `canEatAll` method calculates the total time required to eat all the piles using the given speed. If the total time is greater than h, the method returns `false`, otherwise, it\\nreturns `true`.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe binary search algorithm has a time complexity of O(logn), where n is the maximum number of bananas in a pile. The canEatAll function has a time complexity of O(n), where n is the number of piles. Therefore, the overall time complexity of the solution is O(nlogn).\\n\\n- Space complexity:\\nThe space complexity of the solution is O(1), as we only use a constant amount of extra space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n```Java []\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int left = 1;\\n        int right = Arrays.stream(piles).max().getAsInt();\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (canEatAll(piles, mid, h)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private boolean canEatAll(int[] piles, int speed, int h) {\\n        int time = 0;\\n        for (int pile : piles) {\\n            time += (pile - 1) / speed + 1; // calculate the time required to eat this pile\\n            if (time > h) {\\n                return false; // if the total time is greater than h, return false\\n            }\\n        }\\n        return true; // if all piles can be eaten within h hours, return true\\n    }\\n}\\n\\n```\\n``` Python []\\nclass Solution(object):\\n    def minEatingSpeed(self, piles, h):\\n        left = 1\\n        right = max(piles)\\n        \\n        while left < right:\\n            mid = (left + right) / 2\\n            if self.canEatAll(piles, mid, h):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        return left\\n    \\n    def canEatAll(self, piles, speed, h):\\n        time = 0\\n        for pile in piles:\\n            time += (pile - 1) / speed + 1\\n            if time > h:\\n                return False\\n        return True\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left = 1;\\n        int right = *max_element(piles.begin(), piles.end());\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (canEatAll(piles, mid, h)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    bool canEatAll(vector<int>& piles, int speed, int h) {\\n        int time = 0;\\n        for (int pile : piles) {\\n            time += (pile - 1) / speed + 1;\\n            if (time > h) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```Java []\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int left = 1;\\n        int right = Arrays.stream(piles).max().getAsInt();\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (canEatAll(piles, mid, h)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private boolean canEatAll(int[] piles, int speed, int h) {\\n        int time = 0;\\n        for (int pile : piles) {\\n            time += (pile - 1) / speed + 1; // calculate the time required to eat this pile\\n            if (time > h) {\\n                return false; // if the total time is greater than h, return false\\n            }\\n        }\\n        return true; // if all piles can be eaten within h hours, return true\\n    }\\n}\\n\\n```\n``` Python []\\nclass Solution(object):\\n    def minEatingSpeed(self, piles, h):\\n        left = 1\\n        right = max(piles)\\n        \\n        while left < right:\\n            mid = (left + right) / 2\\n            if self.canEatAll(piles, mid, h):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        return left\\n    \\n    def canEatAll(self, piles, speed, h):\\n        time = 0\\n        for pile in piles:\\n            time += (pile - 1) / speed + 1\\n            if time > h:\\n                return False\\n        return True\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left = 1;\\n        int right = *max_element(piles.begin(), piles.end());\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (canEatAll(piles, mid, h)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    bool canEatAll(vector<int>& piles, int speed, int h) {\\n        int time = 0;\\n        for (int pile : piles) {\\n            time += (pile - 1) / speed + 1;\\n            if (time > h) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703427,
                "title": "javascript-binary-search-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nBy the condition, Koko does not pass to another pile when she eats all bananas earlier. So it makes no sense to eat faster than the maximum number of bananas in a pile. From that, you can see that we know the max and min speed: `min=1 banana/h` and `max = max(piles)`. Thus, this is a good candidate for the Binary Search. We search the speed in the range `1...(max number in piles array)`.\\n\\nHow do we estimate a chosen speed? We create a helper function that calculates the time needed to eat all bananas at a given speed. Formula is just sum `ceil(number_of_bananas_in_pile/speed)` for every pile. We have to round to the top value since Koko does not pass to another pile even she finishes earlier.\\n\\nTime: **O(NlogM)** - BS plus scan in the helper. `N` - number of piles, `M` - max number of bananas in a pile.\\nSpace: **O(1)** - nothing stored\\n\\nRuntime: 88 ms, faster than **84.26%** of JavaScript online submissions for Koko Eating Bananas.\\nMemory Usage: 42.5 MB, less than **58.88%** of JavaScript online submissions for Koko Eating Bananas.\\n\\n```\\nconst minEatingSpeed = (piles, h) => {\\n    let min = 1,\\n        max = Math.max(...piles),\\n        best = max\\n\\n    const time = speed => piles.reduce((sum, pile) => sum + Math.ceil(pile/speed), 0)\\n\\n    while (min <= max) {\\n        const mid = Math.floor((min + max) / 2)\\n\\t\\t\\n        if (time(mid) <= h) {\\n            best = mid\\n            max = mid - 1\\n        } else\\n            min = mid + 1\\n    }\\n\\n    return best\\n}\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nconst minEatingSpeed = (piles, h) => {\\n    let min = 1,\\n        max = Math.max(...piles),\\n        best = max\\n\\n    const time = speed => piles.reduce((sum, pile) => sum + Math.ceil(pile/speed), 0)\\n\\n    while (min <= max) {\\n        const mid = Math.floor((min + max) / 2)\\n\\t\\t\\n        if (time(mid) <= h) {\\n            best = mid\\n            max = mid - 1\\n        } else\\n            min = mid + 1\\n    }\\n\\n    return best\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1705145,
                "title": "python-binarysearch-optimizations-explained",
                "content": "k -> Speed of eating bananas per hour\\nT -> Total time to eat all the piles under given conditions\\nH -> Given time limit\\nA -> Average speed of eating bananas per hour, ```A = ceil(sum(piles)/h)```\\n\\n## **Method 1: Brute Force** *[Gives TLE]*\\nIntuitively we can take these steps:\\n1. Simply consider the initial speed k to be 1.\\n2. Calculate the total time T required to finish all the  piles.\\n3. If T is greater than the given time limit H, we increment k and repeat steps 1, 2, 3\\n4. If T is <= H then we return k as our answer.\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        k = 1\\n        while True:\\n            total_time = 0\\n            for i in piles:\\n                total_time += ceil(i / k)\\n            if total_time > h:\\n                k += 1\\n            else:\\n                return k\\n```\\n## **Method 2: Brute Force + Optimizations** *[Gives TLE]*\\nWe can optimize 2 things about our Brute Force Solution code\\n1. Rather than finishing the loop even if T exceeds H and then incrementing k. We can directly exit the inner loop as soon as T > H. This optimization is rather easy to get to.\\n2. This optimization is related to our initial assumption. We consider the initial speed to be 1. Well, **one can mathematically prove that k must always be greater than or equal to the average speed of eating**. We can see as a result of case 1 and case 2, `k>=A`\\n\\n![image](https://assets.leetcode.com/users/images/fbe86fce-8516-4067-8bea-2c32c13c18b7_1642692725.833398.png)\\n\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        k = ceil(sum(piles)/h)\\n        while True:\\n            total_time = 0\\n            for i in piles:\\n                total_time += ceil(i/k)\\n                if total_time > h:\\n                    break # as time exceeds H\\n            if total_time <= h:\\n                return k # answer found as time is in the given limits.\\n            k += 1\\n```\\n#### Intution for next solution:\\n1. **One thing is obvious in this problem. We do not know the required speed and we cannot know this without any sort of hit and try. In method 1 we do this hit and trial linearly. In method 2 we optimize our approach by removing some values we know that are not going to work and exiting the loop early if time exceeds H.** \\n2. We know the lower bound of k >= A. We also know the upper bound of k that is k <= (max element in Piles).\\nThus, **A<=k<=(max element in Piles)**\\n3. In essence we are looking for a value that might satisfy **T<=H** in the range mentioned above. We were looking for an answer by **searching linearly**, which is of course is slow. *A much better searching algorithm within a given range would be* **Binary Search.**\\n4. If k = x works fine then x+1, x+2, x+3, basically x plus anything +ve would also work fine. But since we need minimum value we must return x. \\n5. If the current value satisfies the condition then the answer must exist to the left of it including itself. If the current value does not satisfy the condition then the answer must exist to the right of it exclusive of itself.\\n\\nWith this idea, we code the next solution with Binary search and Optimizations in mind.\\n\\n## **Method 3: Binary Search + Previous Optimizations** *[Works Perfectly with Runtime beating 82%]*\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        left = ceil(sum(piles) / h) # lower bound of Binary Search \\n        right = max(piles) # upper bound of Binary Search \\n        while left < right:\\n            mid = (left + right) // 2 # we check for k=mid\\n            total_time = 0\\n            for i in piles:\\n                total_time += ceil(i / mid)\\n                if total_time > h:\\n                    break\\n            if total_time <= h:\\n                right = mid # answer must lie to the left half (inclusive of current value ie mid)\\n            else:\\n                left = mid + 1 # answer must lie to the right half (exclusive of current value ie mid)\\n        return right\\n```\\n### Give an \\u2B06\\uFE0Fupvote if you found this article helpful ;D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```A = ceil(sum(piles)/h)```\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        k = 1\\n        while True:\\n            total_time = 0\\n            for i in piles:\\n                total_time += ceil(i / k)\\n            if total_time > h:\\n                k += 1\\n            else:\\n                return k\\n```\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        k = ceil(sum(piles)/h)\\n        while True:\\n            total_time = 0\\n            for i in piles:\\n                total_time += ceil(i/k)\\n                if total_time > h:\\n                    break # as time exceeds H\\n            if total_time <= h:\\n                return k # answer found as time is in the given limits.\\n            k += 1\\n```\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        left = ceil(sum(piles) / h) # lower bound of Binary Search \\n        right = max(piles) # upper bound of Binary Search \\n        while left < right:\\n            mid = (left + right) // 2 # we check for k=mid\\n            total_time = 0\\n            for i in piles:\\n                total_time += ceil(i / mid)\\n                if total_time > h:\\n                    break\\n            if total_time <= h:\\n                right = mid # answer must lie to the left half (inclusive of current value ie mid)\\n            else:\\n                left = mid + 1 # answer must lie to the right half (exclusive of current value ie mid)\\n        return right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704140,
                "title": "python-short-binary-search-explained",
                "content": "The idea is given value `mid`, answer a question: can Koko eat all bananas within `H` hours. We need `sum(ceil(i/mid) for i in piles)` hours to eat all bananas. Then we just do binary search and find the first place, where time is `<= H`. We always keep invariant: `time(beg) > H` and `time(end) <= H`, we can do it, because function `time` is not-increasing.\\n\\n#### Complexity\\nTime Complexity: `O(N log W)`, where `N` is the number of piles, and `W` is the maximum size of a pile, space is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def minEatingSpeed(self, piles, H):\\n        beg, end = 0, max(piles)\\n        while beg + 1 < end:\\n            mid = (beg + end)//2\\n            if sum(ceil(i/mid) for i in piles) > H:\\n                beg = mid\\n            else:\\n                end = mid\\n                \\n        return end\\n``` \\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def minEatingSpeed(self, piles, H):\\n        beg, end = 0, max(piles)\\n        while beg + 1 < end:\\n            mid = (beg + end)//2\\n            if sum(ceil(i/mid) for i in piles) > H:\\n                beg = mid\\n            else:\\n                end = mid\\n                \\n        return end\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667143,
                "title": "why-the-hell-does-koko-want-to-eat-so-many-bananas",
                "content": "```\\nWhy the hell does Koko want to eat so many bananas? \\n```",
                "solutionTags": [],
                "code": "```\\nWhy the hell does Koko want to eat so many bananas? \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3273872,
                "title": "koko-finds-hints-then-tries-binary-search-java-c",
                "content": "# Intuition\\nWhen minimum or maximum is specified in the problem, people tend to think it as a dynamic programming problem. But in all cases it won\\'t be a dynamic programming problem. Sometimes it can be binary search!\\n\\n**How do you know this is a binary search problem?**\\nBecause the problem wants you to find some target value and satisfy some property. **But the input array is not sorted and binary search only works for sorted arrays.** Yes! That\\'s true. But for this problem, are we using any of the array elements as our **left** or **right** variables? No, we are not. Infact we won\\'t be using all of them. We will be determining the speed k. **In this case, k can be monotonically increasing or decreasing.** When this type of problem statement is given, try using binary search. Also, if you have solved yesterday\\'s problem [2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/) you will directly find out that this is a binary search problem. Because the statements are similar.\\nMy solution for **2187. Minimum Time to Complete Trips** [\\u2705 Simple BruteForce to Crazy Binary Search || Code like a pro \\uD83D\\uDE80](https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267566/simple-bruteforce-to-crazy-binary-search-code-like-a-pro/)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nNow you probably know you have to use binary search into this.\\nThe main thing in binary search is determining what values should **left** and **right** be!\\nIn this problem, what do we need to find? We need to find the speed. What can be the maximum speed? The maximum pile from the piles array right?\\n\\nBut what should be the minimum speed?\\n\\nIf you think about these questions. You probably have the answer to left and right. Your **left variable will be 1** and your **right variable will be maximum pile value** from the piles array.\\n\\nNow, perform binary search..\\n```\\nwhile(left < right){\\n    mid = (left+right)/2;\\n    mid is our new speed..\\n}\\n```\\n\\nWe now calculate the total hours for each pile to complete if speed is mid.\\nFor a pile p and the speed s, the time requires to complete pile p is $$\\\\frac{P}{S}$$.\\n\\nYou probably have a hint till now. Try writing yourself...\\n\\n\\nIf you still wasn\\'t able to, see my solution.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\log m)$$\\nWhere N is the length of piles array. The initial search space is from 1 to m, it takes $$\\\\log m$$ comparisons to reduce the search space to 1.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\nNo variable length object like array, stack, list, map etc. was created.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` Java []\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int left = 1;\\n        int right = 1;\\n        for(int pile : piles){\\n            right = Math.max(right, pile);\\n        }\\n        \\n        while(left<right) {\\n            int mid = left + (right-left)/2;\\n            int hours = 0;\\n            for(int pile: piles){\\n                hours += Math.ceil(pile*1.0/mid);\\n            }\\n            if(hours<=h){\\n                right = mid;\\n            }\\n            else {\\n                left = mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left = 1;\\n        int right = 1;\\n        for(int pile : piles){\\n            right = max(right, pile);\\n        }\\n        \\n        while(left<right) {\\n            int mid = left + (right-left)/2;\\n            int hours = 0;\\n            for(int pile: piles){\\n                hours += ceil(pile*1.0/mid);\\n            }\\n            if(hours<=h){\\n                right = mid;\\n            }\\n            else {\\n                left = mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```\\n![No Upvotes, Have a Good Day.png](https://assets.leetcode.com/users/images/dd8798bf-62ab-4a7d-89b6-fcbf40124321_1678309726.6535485.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nwhile(left < right){\\n    mid = (left+right)/2;\\n    mid is our new speed..\\n}\\n```\n``` Java []\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int left = 1;\\n        int right = 1;\\n        for(int pile : piles){\\n            right = Math.max(right, pile);\\n        }\\n        \\n        while(left<right) {\\n            int mid = left + (right-left)/2;\\n            int hours = 0;\\n            for(int pile: piles){\\n                hours += Math.ceil(pile*1.0/mid);\\n            }\\n            if(hours<=h){\\n                right = mid;\\n            }\\n            else {\\n                left = mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left = 1;\\n        int right = 1;\\n        for(int pile : piles){\\n            right = max(right, pile);\\n        }\\n        \\n        while(left<right) {\\n            int mid = left + (right-left)/2;\\n            int hours = 0;\\n            for(int pile: piles){\\n                hours += ceil(pile*1.0/mid);\\n            }\\n            if(hours<=h){\\n                right = mid;\\n            }\\n            else {\\n                left = mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 569149,
                "title": "easy-to-understand-binary-search-with-optimization-c",
                "content": "We know that the minimum number of bananas Koko should eat cannot be lower than `sum of all elements \\\\ number of hourse` and also it cannot be greater than `the maximum number of bananas present in any single pile`. Our answer will definitely fall in this range.\\n\\nBased upon this logic, we perform binary search within the given range.\\n\\n````\\nclass Solution {\\n    // Helper function which returns the number of hours required to consume the piles for given K\\n    int hoursRequired(const vector<int> &piles, int k)\\n    {\\n        int h = 0;\\n        if(k == 0) return INT_MAX;\\n        for(int i : piles)\\n        {\\n            if(i % k != 0)\\n            {\\n                h++;\\n            }\\n            h += (i / k);\\n        }\\n        return h;\\n    }\\n    \\npublic:\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        long long sum = 0;\\n        int mx = 0;\\n        for(int i = 0; i < piles.size(); i++)\\n        {\\n            sum += piles[i];\\n            mx = max(mx, piles[i]);\\n        }\\n        int l = sum / H, r = mx, ans;\\n        while(l < r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            int ans = hoursRequired(piles, mid);\\n\\t\\t\\t// If hours required is greater than our limit, ignore mid\\n            if(ans > H)\\n            {\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                r = mid;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "````\\nclass Solution {\\n    // Helper function which returns the number of hours required to consume the piles for given K\\n    int hoursRequired(const vector<int> &piles, int k)\\n    {\\n        int h = 0;\\n        if(k == 0) return INT_MAX;\\n        for(int i : piles)\\n        {\\n            if(i % k != 0)\\n            {\\n                h++;\\n            }\\n            h += (i / k);\\n        }\\n        return h;\\n    }\\n    \\npublic:\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        long long sum = 0;\\n        int mx = 0;\\n        for(int i = 0; i < piles.size(); i++)\\n        {\\n            sum += piles[i];\\n            mx = max(mx, piles[i]);\\n        }\\n        int l = sum / H, r = mx, ans;\\n        while(l < r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            int ans = hoursRequired(piles, mid);\\n\\t\\t\\t// If hours required is greater than our limit, ignore mid\\n            if(ans > H)\\n            {\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                r = mid;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703573,
                "title": "c-binary-search-easy-to-understand",
                "content": "1. the answer lies in the range [1, **max-element**]\\n2. now we can use **binary search to find  the k**.\\n3. here we are calculating mid for low and high and then checking the time for it to eat bananas **check comment for better understanding**\\n![image](https://assets.leetcode.com/users/images/387ea381-ae8d-4296-928e-e8cac02bd022_1642655698.9761198.jpeg)\\n\\n```\\nint minEatingSpeed(vector<int>& piles, int h) {\\n        int low = 1;\\n        int high = INT_MIN;\\n        \\n        // number lies between min and max-element\\n        for(auto x : piles){\\n            high = max(x,high);\\n        }\\n        \\n        int val = 0;\\n        while(low<high){\\n            int mid = (low+high)/2; val = 0;\\n            // calculate val for each mid assumed\\n\\t\\t\\t// this loops tell the time taken to eat all bananas by the current mid\\n            for (auto x : piles) val += (x+mid-1)/mid; \\n            // if the time is less than the value given to us we reduce the high as we need \\n\\t\\t\\t// to increase time by decreasing high we increase time\\n            if (val <= h) high = mid; \\n            \\n            else low = mid+1; \\n        }\\n        return low;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nint minEatingSpeed(vector<int>& piles, int h) {\\n        int low = 1;\\n        int high = INT_MIN;\\n        \\n        // number lies between min and max-element\\n        for(auto x : piles){\\n            high = max(x,high);\\n        }\\n        \\n        int val = 0;\\n        while(low<high){\\n            int mid = (low+high)/2; val = 0;\\n            // calculate val for each mid assumed\\n\\t\\t\\t// this loops tell the time taken to eat all bananas by the current mid\\n            for (auto x : piles) val += (x+mid-1)/mid; \\n            // if the time is less than the value given to us we reduce the high as we need \\n\\t\\t\\t// to increase time by decreasing high we increase time\\n            if (val <= h) high = mid; \\n            \\n            else low = mid+1; \\n        }\\n        return low;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3271007,
                "title": "binary-search-intuition-explained-with-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLooking at the problem, it can be deduced that the minimum speed at which Koko can eat bananas is 1 and the maximum speed is the maximum number of bananas available in the pile. \\nNow, we have a range of values in which our answer lies. To solve this kind of problem, we can use Binary search.\\nWe can search in the range 1 to maximum speed and update the range according to whether the mid value is enough to eat all bananas or not.\\n\\n![image.png](https://assets.leetcode.com/users/images/db19fea9-12c0-432e-af8a-3b1a3217d3f5_1678253443.526576.png)\\n\\n# Example\\n piles=[4,6,9,7,11] and h= 13\\n=> k can be: 1,2,3,4,5,6,7,8,9,10,11\\n\\nfor binary search the range will be minspeed=1 and maxspeed=11\\n\\n1. mid = (1+11)/2 =5\\nnow for 5 bananas/hour speed.\\nthe total number of hours it\\'d take to finish all bananas:\\n```\\n4, 6, 9, 7, 11 \\n1  2  2  2   3  = 10 \\n\\nas 10<13 that means our answer lies in between range minspeed to mid i.e 1 to 5.\\nHence, maxspeed=5\\n```\\n\\n2. mid= (1+5)/2=3\\n``` \\n4, 6, 9, 7, 11\\n2  2  3  3   4  = 14 \\n\\nas 14>13 hence range would be mid+1 to maxpeed. i.e minspeed=4\\n```\\n\\n3. mid=(4+5)/2=4.\\n```\\n4, 6, 9, 7, 11\\n1  2  3  2   3  = 11\\nas 11<13, range would become minspeed to mid i.e maxpeed=4.\\nAs minspeed=maxspeed now.\\nHence 4 is the minimum speed \\n```\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity: O(nlog(m)), where n=number of piles, m= range of k\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool eatAll(vector<int>&piles, int h,int speed){\\n        int curr=0;\\n        for(double num:piles){\\n            double hours=num/speed;\\n            curr+=ceil(hours);\\n        }\\n        return curr<=h;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n=piles.size();\\n        int maxspeed=*max_element(piles.begin(),piles.end()), minspeed=1; // setting range for binary search\\n        \\n        while(maxspeed>minspeed){\\n            int mid=(maxspeed+minspeed)/2;\\n            if(eatAll(piles,h,mid)) maxspeed=mid; // if mid is enough to all bananas than minspeed to mid will have the minimum value.\\n            else minspeed=mid+1; // if mid is not enough than minimum value will lie between mid+1 to maxspeed\\n        }\\n        return minspeed;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n4, 6, 9, 7, 11 \\n1  2  2  2   3  = 10 \\n\\nas 10<13 that means our answer lies in between range minspeed to mid i.e 1 to 5.\\nHence, maxspeed=5\\n```\n``` \\n4, 6, 9, 7, 11\\n2  2  3  3   4  = 14 \\n\\nas 14>13 hence range would be mid+1 to maxpeed. i.e minspeed=4\\n```\n```\\n4, 6, 9, 7, 11\\n1  2  3  2   3  = 11\\nas 11<13, range would become minspeed to mid i.e maxpeed=4.\\nAs minspeed=maxspeed now.\\nHence 4 is the minimum speed \\n```\n```\\nclass Solution {\\npublic:\\n    bool eatAll(vector<int>&piles, int h,int speed){\\n        int curr=0;\\n        for(double num:piles){\\n            double hours=num/speed;\\n            curr+=ceil(hours);\\n        }\\n        return curr<=h;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n=piles.size();\\n        int maxspeed=*max_element(piles.begin(),piles.end()), minspeed=1; // setting range for binary search\\n        \\n        while(maxspeed>minspeed){\\n            int mid=(maxspeed+minspeed)/2;\\n            if(eatAll(piles,h,mid)) maxspeed=mid; // if mid is enough to all bananas than minspeed to mid will have the minimum value.\\n            else minspeed=mid+1; // if mid is not enough than minimum value will lie between mid+1 to maxspeed\\n        }\\n        return minspeed;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330795,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low = 1,high=0;\\n        for(int i=0;i<piles.length;i++)\\n            high = Math.max(piles[i],high);\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            if(possible(piles,mid,h))\\n                high = mid-1;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n    boolean possible(int[] piles,int speed,int hours)\\n    {\\n        int res = 0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            res += (piles[i]/speed);\\n            if(piles[i]%speed != 0)\\n                res++;\\n        }\\n        return res <= hours;\\n    }\\n}\\n```\\nPlease ipvote if u feel my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low = 1,high=0;\\n        for(int i=0;i<piles.length;i++)\\n            high = Math.max(piles[i],high);\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            if(possible(piles,mid,h))\\n                high = mid-1;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n    boolean possible(int[] piles,int speed,int hours)\\n    {\\n        int res = 0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            res += (piles[i]/speed);\\n            if(piles[i]%speed != 0)\\n                res++;\\n        }\\n        return res <= hours;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329232,
                "title": "clean-easy-with-explanation-binary-search-javascript-solution",
                "content": "```\\nvar minEatingSpeed = function(piles, h) {\\n    /*The range of bananas that Koko can eat is k = 1 to Max(piles)*/\\n    let startk = 1;\\n    let endk = Math.max(...piles);\\n    \\n    while(startk <= endk){\\n        let midk = Math.floor(startk + (endk - startk)/2);\\n        /*midk are the count of bananas that koko decide to eat. \\n        So how many hours she will take to finish the piles?*/\\n        let hrs = 0;\\n        for(let pile of piles){\\n            /*pile is the num of bananas in piles*/\\n            hrs += Math.ceil(pile/midk);\\n        }\\n        if(hrs > h){\\n            /*Now if hrs > h she will not be to finish the pile so we have \\n            to increase the bananas by moving start.*/\\n            startk = midk + 1;\\n        }else{\\n            /*If hrs <= h she will be eating too fast so we can reduce the bananas \\n            so she eats slowly. So decrement end.*/\\n            endk = midk - 1;\\n        }\\n    }\\n    return startk;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar minEatingSpeed = function(piles, h) {\\n    /*The range of bananas that Koko can eat is k = 1 to Max(piles)*/\\n    let startk = 1;\\n    let endk = Math.max(...piles);\\n    \\n    while(startk <= endk){\\n        let midk = Math.floor(startk + (endk - startk)/2);\\n        /*midk are the count of bananas that koko decide to eat. \\n        So how many hours she will take to finish the piles?*/\\n        let hrs = 0;\\n        for(let pile of piles){\\n            /*pile is the num of bananas in piles*/\\n            hrs += Math.ceil(pile/midk);\\n        }\\n        if(hrs > h){\\n            /*Now if hrs > h she will not be to finish the pile so we have \\n            to increase the bananas by moving start.*/\\n            startk = midk + 1;\\n        }else{\\n            /*If hrs <= h she will be eating too fast so we can reduce the bananas \\n            so she eats slowly. So decrement end.*/\\n            endk = midk - 1;\\n        }\\n    }\\n    return startk;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 152308,
                "title": "java-concise-binary-search-10-lines-with-explanation",
                "content": "The search range is from 0 to the largest pile.\\nWe count total hours it needs to eat all bananas with speed=```mid```, and use ```cnt``` to decide whether to move ```lo``` or ```hi```.\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        Arrays.sort(piles);\\n        int lo=0, hi=piles[piles.length-1];\\n        while (lo<hi){\\n            int mid= (lo+hi)/2, cnt=0;\\n            for (int p: piles) \\n                cnt+=Math.ceil((double)p/mid);\\n            if (cnt>H) lo=mid+1;\\n            else hi=mid;\\n        }\\n        return lo;\\n    }\\n}\\n```\\nHappy Coding.",
                "solutionTags": [],
                "code": "```mid```\n```cnt```\n```lo```\n```hi```\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        Arrays.sort(piles);\\n        int lo=0, hi=piles[piles.length-1];\\n        while (lo<hi){\\n            int mid= (lo+hi)/2, cnt=0;\\n            for (int p: piles) \\n                cnt+=Math.ceil((double)p/mid);\\n            if (cnt>H) lo=mid+1;\\n            else hi=mid;\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270773,
                "title": "leetcode-the-hard-way-binary-search",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [YouTube Channel](https://www.youtube.com/@leetcodethehardway) if you are interested.\\n\\n---\\n\\nFor detailed explanation, please go to [here](https://leetcodethehardway.com/solutions/0800-0899/koko-eating-bananas-medium).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int ok(vector<int>& piles, int m, int h) {\\n        int hours = 0;\\n        for (auto p : piles) {\\n            hours += (p + m - 1) / m;\\n        }\\n        return hours > h;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l = 1, r = 1e9;\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (ok(piles, m, h)) l = m + 1;\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n```\\n\\n```py\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        l, r = 1, max(piles)\\n        while l < r:\\n            m = (l + r) // 2\\n            if sum((p + m - 1) // m for p in piles) > h:\\n                l = m + 1\\n            else:\\n                r = m\\n        return l\\n    \\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int ok(vector<int>& piles, int m, int h) {\\n        int hours = 0;\\n        for (auto p : piles) {\\n            hours += (p + m - 1) / m;\\n        }\\n        return hours > h;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l = 1, r = 1e9;\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (ok(piles, m, h)) l = m + 1;\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        l, r = 1, max(piles)\\n        while l < r:\\n            m = (l + r) // 2\\n            if sum((p + m - 1) // m for p in piles) > h:\\n                l = m + 1\\n            else:\\n                r = m\\n        return l\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083830,
                "title": "c-solution-with-explanation",
                "content": "**Explanation** \\nex - [ 3, 6, 7, 11]  if speed is 4, that means 4 banana per hr, then \\n\\n1st hr    [ 0, 6, 7, 11]\\n2nd hr   [ 0, 2, 7, 11]\\n3rd hr    [ 0, 0, 7, 11]\\n4th hr    [ 0, 0, 3, 11]\\n5th hr    [ 0, 0, 0, 11]\\n6th hr    [ 0, 0, 0, 7]\\n7th hr    [ 0, 0, 0, 3]\\n8th hr    [ 0, 0, 0, 0]\\n\\nand if speed is 5, then \\n\\n1st hr    [ 0, 6, 7, 11]\\n2nd hr   [ 0, 1, 7, 11]\\n3rd hr    [ 0, 0, 7, 11]\\n4th hr    [ 0, 0, 2, 11]\\n5th hr    [ 0, 0, 0, 11]\\n6th hr    [ 0, 0, 0, 6]\\n7th hr    [ 0, 0, 0, 1]\\n8th hr    [ 0, 0, 0, 0]\\n\\nthat means both 4,and 5 speed can be able to help koko to eat all banana within in 8 hr. \\nbut since it mention that Koko likes to eat slowly, so we need to find minimum speed to finish eating all the bananas. In that case, correct answer is 4.\\n\\n\\n**Solution**\\nA possible answer (i.e k) can be from 1 to 10^9  as in constraint maximum value of piles[i] is 10^9.\\nNow brute force approach will be from 1 to 10^9 trying every possibility as the number of banana-per-hour eating speed of k and answer will be the first k value that satisfies the condition!\\n\\nthe time complexity for the brute force approach will be 10^4 * 10^9\\n\\n\\nOptimal Solution!\\nBinary search the answer \\nIf the mid-value (i.e k) number of banana eaten per hour(or speed). \\nWith that k value, calculate the total time taken to eat all the bananas.\\n \\nHere the relation between NumberOfhours and k(speed) is\\nTo increase NumberOfHours, decrease speed.\\nTo decrease NumberOfHours, increase speed.\\n\\nif(NumberOfHours>H)\\n that is within the given limit(H) speed is less to eat all the banana , so need to decrease NumberOfHours, and to do so, need to increase speed.\\nTherefore range for k will be reduced towards the right (i.e left=k+1).\\n\\nelse if(NumberOfHours<=H) \\nthen this speed can be the possible answer so store that speed and what if while reducing speed further might possible all the banana can be eaten within H hours too!\\n Therefore reducing the range of speed towards the left (i.e right=k-1).\\nTime complexity  10^4 *(log 10^9).\\n\\n```\\nclass Solution {\\npublic:\\n    int Calculate(vector<int>& nums,int k){\\n        int NumberOfHours=0;\\n        for(int i = 0; i < nums.size(); i++){\\n            NumberOfHours += (nums[i] % k == 0) ? nums[i] / k : (nums[i] /k)+1;\\n        }\\n        return NumberOfHours;\\n    }\\n    \\n    \\n    \\n    \\n    int minEatingSpeed(vector<int>& nums, int H) {\\n        int left = 1;\\n        int right = 1000000000;\\n        while(left < right){\\n           int k=(left + right)/2;    \\n            \\n           int NumberOfHours = Calculate(nums,k);\\n            \\n            if(NumberOfHours > H) {\\n                left = k+1;\\n            }\\n            else {\\n                right = k;\\n            }\\n        }\\n        return left;\\n        \\n    }\\n};\\n```\\n\\nvarient!\\nhttps://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/\\nMy post - https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/discuss/1083631/c-solution-with-explanation\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int Calculate(vector<int>& nums,int k){\\n        int NumberOfHours=0;\\n        for(int i = 0; i < nums.size(); i++){\\n            NumberOfHours += (nums[i] % k == 0) ? nums[i] / k : (nums[i] /k)+1;\\n        }\\n        return NumberOfHours;\\n    }\\n    \\n    \\n    \\n    \\n    int minEatingSpeed(vector<int>& nums, int H) {\\n        int left = 1;\\n        int right = 1000000000;\\n        while(left < right){\\n           int k=(left + right)/2;    \\n            \\n           int NumberOfHours = Calculate(nums,k);\\n            \\n            if(NumberOfHours > H) {\\n                left = k+1;\\n            }\\n            else {\\n                right = k;\\n            }\\n        }\\n        return left;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750804,
                "title": "best-c-solution-list-of-11-similar-very-imp-binary-search-questions",
                "content": "# List of similar binary search questions \\n- [Find the Smallest Divisor Given a Threshold - Leetcode](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/solutions/3746201/best-c-solution-pure-binary-search-approach-beats-98-84/)\\n- [Minimize the Maximum Difference of Pairs - Leetcode](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3884064/simple-binary-search-solution-list-of-11-similar-very-imp-problems/)\\n- [House Robber IV - Leetcode](https://leetcode.com/problems/house-robber-iv/solutions/3756280/best-c-solution-list-of-similar-very-imp-binary-problems/)\\n- [Minimum Speed to Arrive on Time - Leetcode](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/solutions/3817728/best-c-solution-list-of-10-similar-very-imp-problems-asked-in-faang-interviews/)\\n- [Minimum Time to Repair Cars - Leetcode](https://leetcode.com/problems/minimum-time-to-repair-cars/solutions/3753730/best-c-solution-list-of-8-similar-very-imp-binary-search-questions/)\\n- [Minimum Number of Days to Make m Bouquets - Leetcode](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/solutions/3751751/best-c-solution-list-of-similar-very-imp-binary-search-questions/)\\n- [Capacity To Ship Packages Within D Days - Leetcode](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/solutions/3751752/best-c-solution-list-of-similar-very-imp-binary-search-questions/)\\n- [Minimized Maximum of Products Distributed to Any Store - Leetcode](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/solutions/3750918/best-c-solution-list-of-similar-very-imp-binary-search-questions/) \\n- [Book Allocation - Coding Ninjas](https://www.codingninjas.com/studio/problems/ayush-and-ninja-test_1097574?source=youtube&campaign=love_babbar_codestudio2&leftPanelTab=0)\\n- [Aggressive cows - Coding Ninjas](https://www.codingninjas.com/studio/problems/aggressive-cows_1082559?source=youtube&campaign=love_babbar_codestudio2&leftPanelTab=1)\\n- [Painter\\'s partition - Coding Ninjas](https://www.codingninjas.com/studio/problems/painter\\'s-partition-problem_1089557?source=youtube&campaign=love_babbar_codestudio2&leftPanelTab=0)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        sort(piles.begin(), piles.end());\\n        int n = piles.size(), start = 1, end = piles[n-1], ans = 1; // You can also initiate start and end as per the constraints\\n        if(n==h)    return end;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            long long hourCount = 0;\\n            for(int i=0; i<n; i++)\\n                hourCount += (piles[i]-1)/mid + 1;\\n            if(hourCount<=h)\\n                ans = mid, end = mid-1;\\n            else\\n                start = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        sort(piles.begin(), piles.end());\\n        int n = piles.size(), start = 1, end = piles[n-1], ans = 1; // You can also initiate start and end as per the constraints\\n        if(n==h)    return end;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            long long hourCount = 0;\\n            for(int i=0; i<n; i++)\\n                hourCount += (piles[i]-1)/mid + 1;\\n            if(hourCount<=h)\\n                ans = mid, end = mid-1;\\n            else\\n                start = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272648,
                "title": "solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left = 1;\\n        int right = *max_element(piles.begin(), piles.end());\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (canEatAll(piles, mid, h)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\nprivate:\\n    bool canEatAll(vector<int>& piles, int speed, int h) {\\n        int time = 0;\\n        for (int pile : piles) {\\n            time += (pile - 1) / speed + 1;\\n            if (time > h) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left = 1;\\n        int right = *max_element(piles.begin(), piles.end());\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (canEatAll(piles, mid, h)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\nprivate:\\n    bool canEatAll(vector<int>& piles, int speed, int h) {\\n        int time = 0;\\n        for (int pile : piles) {\\n            time += (pile - 1) / speed + 1;\\n            if (time > h) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492154,
                "title": "to-those-who-failed-the-last-test-case-of-805306368-805306368-805306368-1000000000",
                "content": "Your hour variable overflow since it took Koko too much time to eat. Simply change it to long.\\n```\\npublic boolean check(int[] piles, int k, int h) {\\n        long hour = 0;\\n        for (int pile : piles) {\\n            hour += pile / k;\\n            if (pile % k != 0)\\n                hour++;\\n        }\\n        return hour <= h;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean check(int[] piles, int k, int h) {\\n        long hour = 0;\\n        for (int pile : piles) {\\n            hour += pile / k;\\n            if (pile % k != 0)\\n                hour++;\\n        }\\n        return hour <= h;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1112358,
                "title": "very-simple-python-solution-beats-90-online-subs-with-detailed-explanation",
                "content": "Success\\n     Details \\n    Runtime: 408 ms, faster than 90.99% of Python3 online submissions for Koko Eating Bananas.\\n    Memory Usage: 15.4 MB, less than 98.70% of Python3 online submissions for Koko Eating Bananas\\n\\n\\n     def canfinish(K):\\n            hours_needed = 0\\n            for p in piles:\\n                  hours_needed+= ceil(p/K) #doing the cummulative sum\\n              return hours_needed <= h   \\n        \\n        # here we are taking k b/w the range of 1, max(piles)\\n\\n            \\n        l = 1\\n        r = max(piles)\\n            \\n        while l<r:\\n            mid = (l+r)//2\\n                \\n            if canfinish(mid):# we are checking if we can finish with mid speed\\n                r = mid       #if yes then we will see if there is anything min than this \\n                              # and the reason we are not making the r = mid -1 coz \\n                              # then if our mid would be the required k then we might miss it.\\n            \\n            else:\\n                l = mid+1\\n                    \\n        return r\\n        \\n**IF YOU FIND IT HELP PLEASE UPVOTE**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Success\\n     Details \\n    Runtime: 408 ms, faster than 90.99% of Python3 online submissions for Koko Eating Bananas.\\n    Memory Usage: 15.4 MB, less than 98.70% of Python3 online submissions for Koko Eating Bananas\\n\\n\\n     def canfinish(K):\\n            hours_needed = 0\\n            for p in piles:\\n                  hours_needed+= ceil(p/K) #doing the cummulative sum\\n              return hours_needed <= h   \\n        \\n        # here we are taking k b/w the range of 1, max(piles)\\n\\n            \\n        l = 1\\n        r = max(piles)\\n            \\n        while l<r:\\n            mid = (l+r)//2\\n                \\n            if canfinish(mid):# we are checking if we can finish with mid speed\\n                r = mid       #if yes then we will see if there is anything min than this \\n                              # and the reason we are not making the r = mid -1 coz \\n                              # then if our mid would be the required k then we might miss it.\\n            \\n            else:\\n                l = mid+1\\n                    \\n        return r\\n        \\n**IF YOU FIND IT HELP PLEASE UPVOTE**",
                "codeTag": "Python3"
            },
            {
                "id": 692856,
                "title": "python-solution-binary-search",
                "content": "If the length of the piles is equal to the H, each time koko need to finish a pile in order to eat all of them within the limited time. So k=max(piles)\\n\\nIf the length of the piles is bigger than the H, koko can not finish eat all of them.\\n\\nIf the length of the piles is smaller than the H, we could find a k smaller than the max(piles)\\n\\n\\n\\nClass Solution:\\n\\n\\n\\t\\tdef minEatingSpeed(self, piles: List[int], H: int) -> int:\\n\\t\\t#If the length of the piles is equal to the H, return max(piles)\\n\\t\\t\\tif H == len(piles):\\n\\t\\t\\t\\treturn max(piles)\\n\\t\\t\\n\\t\\t#Binary search\\n\\t\\t#Koko could each at least 1 banana and at most max(piles) bananas each time\\n\\t\\t\\tlo, hi = 1, max(piles)\\n\\n\\t\\t\\twhile lo < hi:\\n\\t\\t#Get the mid number of bananas to eat\\n\\t\\t\\t\\tmid = (lo+hi) // 2\\n\\t\\t\\n\\t\\t#Calculate how many hours that koko need to finish eating all of the piles given the eating speed mid \\n\\t\\t\\t\\th = 0\\n\\t\\t\\t\\tfor p in piles:\\n\\t\\t\\t\\t\\tif p < mid:\\n\\t\\t\\t\\t\\t\\th += 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\th += math.ceil(p/mid)\\n\\t\\t#If the time that koko need is less than or equal to H, we need to search for the left part\\n\\t\\t\\t\\tif h <= H:\\n\\t\\t\\t\\t\\thi = mid\\n\\t\\t#If the time that koko need is bigger than H, we need to search for the right part\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tlo = mid + 1\\n\\t\\t\\treturn lo",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "If the length of the piles is equal to the H, each time koko need to finish a pile in order to eat all of them within the limited time. So k=max(piles)\\n\\nIf the length of the piles is bigger than the H, koko can not finish eat all of them.\\n\\nIf the length of the piles is smaller than the H, we could find a k smaller than the max(piles)\\n\\n\\n\\nClass Solution:\\n\\n\\n\\t\\tdef minEatingSpeed(self, piles: List[int], H: int) -> int:\\n\\t\\t#If the length of the piles is equal to the H, return max(piles)\\n\\t\\t\\tif H == len(piles):\\n\\t\\t\\t\\treturn max(piles)\\n\\t\\t\\n\\t\\t#Binary search\\n\\t\\t#Koko could each at least 1 banana and at most max(piles) bananas each time\\n\\t\\t\\tlo, hi = 1, max(piles)\\n\\n\\t\\t\\twhile lo < hi:\\n\\t\\t#Get the mid number of bananas to eat\\n\\t\\t\\t\\tmid = (lo+hi) // 2\\n\\t\\t\\n\\t\\t#Calculate how many hours that koko need to finish eating all of the piles given the eating speed mid \\n\\t\\t\\t\\th = 0\\n\\t\\t\\t\\tfor p in piles:\\n\\t\\t\\t\\t\\tif p < mid:\\n\\t\\t\\t\\t\\t\\th += 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\th += math.ceil(p/mid)\\n\\t\\t#If the time that koko need is less than or equal to H, we need to search for the left part\\n\\t\\t\\t\\tif h <= H:\\n\\t\\t\\t\\t\\thi = mid\\n\\t\\t#If the time that koko need is bigger than H, we need to search for the right part\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tlo = mid + 1\\n\\t\\t\\treturn lo",
                "codeTag": "Python3"
            },
            {
                "id": 408055,
                "title": "simple-javascript-solution",
                "content": "```\\nfunction minEatingSpeed(piles, H) {\\n  function canEatAll(speed) {\\n    let time = 0;\\n    for (let p of piles) {\\n      time += Math.ceil(p / speed);\\n    }\\n    return time <= H;\\n  }\\n\\n  let l = 0;\\n  let r = Math.max(...piles);  // when the max speed = biggest pile, it only needs 1h to eat each pile\\n  while (l < r) {\\n    const m = Math.floor((l + r) / 2);\\n    if (!canEatAll(m)) l = m + 1;\\n    else r = m;\\n  }\\n  return l;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nfunction minEatingSpeed(piles, H) {\\n  function canEatAll(speed) {\\n    let time = 0;\\n    for (let p of piles) {\\n      time += Math.ceil(p / speed);\\n    }\\n    return time <= H;\\n  }\\n\\n  let l = 0;\\n  let r = Math.max(...piles);  // when the max speed = biggest pile, it only needs 1h to eat each pile\\n  while (l < r) {\\n    const m = Math.floor((l + r) / 2);\\n    if (!canEatAll(m)) l = m + 1;\\n    else r = m;\\n  }\\n  return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3270761,
                "title": "white-board-solution-ultimate-binary-search-video-solution",
                "content": "# Video Solution\\nhttps://www.youtube.com/watch?v=FVdgesYtCco&feature=youtu.be\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/80201054-fa14-44dd-867b-90b553079de5_1678247029.4675646.png)\\n![image.png](https://assets.leetcode.com/users/images/6b5b3466-f4a1-43aa-8164-5898a518d07b_1678247047.7302418.png)\\n![image.png](https://assets.leetcode.com/users/images/5526a725-3c1d-4714-8332-fd4d97b9ac50_1678247054.649504.png)\\n![image.png](https://assets.leetcode.com/users/images/a592cdab-51ca-48fb-9f02-efe1244d5cc2_1678247060.3896809.png)\\n![image.png](https://assets.leetcode.com/users/images/04696fd6-442e-46b7-871b-0db78de7ff9a_1678247070.2887137.png)\\n![image.png](https://assets.leetcode.com/users/images/7fdd88de-eecf-4635-8a84-c4b8228470e3_1678247078.526738.png)\\n![image.png](https://assets.leetcode.com/users/images/f55446c8-bb0b-413f-9498-1fe8f91d19f3_1678247089.6819258.png)\\n![image.png](https://assets.leetcode.com/users/images/15e0a66c-4c24-470b-9e01-4735ae4ae4e7_1678247099.0462978.png)\\n![image.png](https://assets.leetcode.com/users/images/2695e91a-d9fc-467f-9718-cf051eeebde7_1678247106.8703642.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool is_possible(int k, vector<int>& piles, int h){\\n        int hours_req = 0;\\n        for(int bananas : piles){\\n            hours_req += ceil((bananas*1.0)/k);\\n        }\\n\\n        return (hours_req <= h);\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l=1, r=1e9;\\n        while(l < r){\\n            int mid = (l + r)/2;\\n            if(is_possible(mid, piles, h)){\\n                r = mid;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool is_possible(int k, vector<int>& piles, int h){\\n        int hours_req = 0;\\n        for(int bananas : piles){\\n            hours_req += ceil((bananas*1.0)/k);\\n        }\\n\\n        return (hours_req <= h);\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l=1, r=1e9;\\n        while(l < r){\\n            int mid = (l + r)/2;\\n            if(is_possible(mid, piles, h)){\\n                r = mid;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270374,
                "title": "c-easier-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    int hoursRequired(const vector<int> &piles, int k)\\n    {\\n        int h = 0;\\n        if(k == 0) return INT_MAX;\\n        for(int i : piles)\\n        {\\n            if(i % k != 0)\\n            {\\n                h++;\\n            }\\n            h += (i / k);\\n        }\\n        return h;\\n    }\\n    \\npublic:\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        long long sum = 0;\\n        int mx = 0;\\n        for(int i = 0; i < piles.size(); i++)\\n        {\\n            sum += piles[i];\\n            mx = max(mx, piles[i]);\\n        }\\n        int l = sum / H, r = mx, ans;\\n        while(l < r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            int ans = hoursRequired(piles, mid);\\n\\t\\t\\t\\n            if(ans > H)\\n            {\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                r = mid;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int hoursRequired(const vector<int> &piles, int k)\\n    {\\n        int h = 0;\\n        if(k == 0) return INT_MAX;\\n        for(int i : piles)\\n        {\\n            if(i % k != 0)\\n            {\\n                h++;\\n            }\\n            h += (i / k);\\n        }\\n        return h;\\n    }\\n    \\npublic:\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        long long sum = 0;\\n        int mx = 0;\\n        for(int i = 0; i < piles.size(); i++)\\n        {\\n            sum += piles[i];\\n            mx = max(mx, piles[i]);\\n        }\\n        int l = sum / H, r = mx, ans;\\n        while(l < r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            int ans = hoursRequired(piles, mid);\\n\\t\\t\\t\\n            if(ans > H)\\n            {\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                r = mid;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192016,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n=piles.size();\\n        ll i,j,an;\\n        i=1;j=1000000000;\\n        an=j;\\n        while(i<=j){\\n            ll m=(i+j)/2;\\n            ll t=0;\\n            for(int k=0;k<n;k++){\\n              t += piles[k]/m;\\n              if(piles[k]%m)t++;\\n            }\\n            if(t>h)i=m+1;\\n            else {\\n                an=m;\\n                j=m-1;\\n            }\\n        }\\n       return an;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/0ba960b1-62cd-406f-b31d-609dee45e07c_1677408190.5276134.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n=piles.size();\\n        ll i,j,an;\\n        i=1;j=1000000000;\\n        an=j;\\n        while(i<=j){\\n            ll m=(i+j)/2;\\n            ll t=0;\\n            for(int k=0;k<n;k++){\\n              t += piles[k]/m;\\n              if(piles[k]%m)t++;\\n            }\\n            if(t>h)i=m+1;\\n            else {\\n                an=m;\\n                j=m-1;\\n            }\\n        }\\n       return an;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181422,
                "title": "binary-search-o-n-log-max-piles-solution",
                "content": "**Please upvote if you  find this solution useful and do comment if you have any doubts or suggestions**\\n**At max, our k can be max(piles)** as it will take one hour even if the value is less than that.\\nSo we will do **binary search** from 1 to max(piles) untill we get a value of k which is minimum than others.\\nwe will start from l=1 and r=max(piles) and then will findout mid and we will iterate through piles to check how much time it takes, if it is more we will move our right pointer towards mid-1, else we will move our left pointer towards mid+1, and we will use val variable to find out minimum of them.\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        k=max(piles)\\n        l=1\\n        r=k\\n        val=float(\"inf\")\\n        while(l<=r):\\n            mid=(l+r)//2\\n            c=0\\n            for i in piles:\\n                c+=ceil(i/mid)\\n            if c>h:\\n                l=mid+1\\n            elif c<=h:\\n                val=min(mid,val)\\n                r=mid-1\\n        return val\\n```\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        k=max(piles)\\n        l=1\\n        r=k\\n        val=float(\"inf\")\\n        while(l<=r):\\n            mid=(l+r)//2\\n            c=0\\n            for i in piles:\\n                c+=ceil(i/mid)\\n            if c>h:\\n                l=mid+1\\n            elif c<=h:\\n                val=min(mid,val)\\n                r=mid-1\\n        return val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703504,
                "title": "c-simple-intuitive-solution-binary-search-o-nlogn",
                "content": "We need to find the minimum number of bananas koko needs to eat per hour so that it can finish all the bananas before ```h``` hours.\\n\\n**APPROACH :**\\n* Intuitively, the answer should lie between ```1``` and ```*max_element()``` in the array ```piles```.\\n* If ```h == *max_element()```, koko must eat a minimum of ```*max_element()``` bananas to finish all of them in ```h``` hours.\\n* Otherwise, we can do binary search between the numbers ```1``` and ```*max_element()``` to find the min. no. of bananas to eat so that koko can finish all the bananas in ```h``` hours.\\n\\n**ALGORITHM :**\\n* Initialize ```l=1``` and ```r=max_element(piles.begin(), piles.end())```.\\n* While l < r, do the following :\\n              1. Find ```mid = l + (r-l)/2```.\\n              2. See if taking mid as limit, koko can finish all the bananas in h hours (Initialize ```count=0```. For every element ```x``` in the array, add ```x/mid``` (No. of hours it will take to finish ```x``` bananas if it eats ```mid``` bananas per hour) to count. If ```x%mid > 0``` (Consider the left out bananas after doing ```x/mid```, if it\\'s greater than ```0```, then we need ```1``` more hour) -> increment count by ```1```).\\n              3. See if count <= h. \\n              4. If yes, then coco can easily finish the bananas in ```h``` hours so we\\'ll do ```r=mid``` and check if there\\'s a smaller value for which this can happen.\\n              5. If not, then do ```l=mid+1``` and check for an appropiate value.\\n* Return the minimum num ```mid```.\\n\\n**Time Complexity :** O(nlogn) - For each mid value we traverse the array once - O(n) - ```n = piles.size()```\\n\\n**Space Complexity :** O(1)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l=1, r=*max_element(piles.begin(), piles.end()), n=piles.size();\\n        \\n        if(n == h) return r;\\n        while(l < r){\\n            int mid = l+(r-l)/2;\\n            if(notEnough(piles, mid, h)) l = mid+1;\\n            else r= mid;\\n        }\\n        return l;\\n    }\\n    \\n    bool notEnough(vector<int> piles, int limit, int h){\\n        int count=0;\\n        for(auto p : piles){\\n            count += p/limit;\\n            if(p%limit) count++;\\n        }\\n        return count > h;\\n    }\\n};\\n```\\n\\nIf you like my solution & explanation, do upvote my post :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```h```\n```1```\n```*max_element()```\n```piles```\n```h == *max_element()```\n```*max_element()```\n```h```\n```1```\n```*max_element()```\n```h```\n```l=1```\n```r=max_element(piles.begin(), piles.end())```\n```mid = l + (r-l)/2```\n```count=0```\n```x```\n```x/mid```\n```x```\n```mid```\n```x%mid > 0```\n```x/mid```\n```0```\n```1```\n```1```\n```h```\n```r=mid```\n```l=mid+1```\n```mid```\n```n = piles.size()```\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l=1, r=*max_element(piles.begin(), piles.end()), n=piles.size();\\n        \\n        if(n == h) return r;\\n        while(l < r){\\n            int mid = l+(r-l)/2;\\n            if(notEnough(piles, mid, h)) l = mid+1;\\n            else r= mid;\\n        }\\n        return l;\\n    }\\n    \\n    bool notEnough(vector<int> piles, int limit, int h){\\n        int count=0;\\n        for(auto p : piles){\\n            count += p/limit;\\n            if(p%limit) count++;\\n        }\\n        return count > h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665715,
                "title": "c-binary-search-o-n-log-n-binary-search-on-answer",
                "content": "**!!!Please please like or Upvote if you find useful : <3**\\n\\n**Point to Notice :**\\n\\n1. We cant change the pile of bananas.\\n2. The maixmum time to eat those pile who has maxium number of banana. ie(maximum=maxi and minimum =1)\\n3. So number of banana that must be eaten  per hour lie between 1 and maxi.\\n\\n**Thinking about binary searc**h \\n\\n1. Minimum  number of banana eaten per hour is  1.\\n2.  Maximum number of banana eaten per hour is maximum value in the whole array.\\n3. Since we know that answer must lie between maximum and minimum value.\\n4. Here we use binary search b/w max and min and every time you find middle element and go for it.\\n**Helper function:**\\n1. Helper function help to conclude weather we are able to  eat all pile of banana in h hours ,\\n\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    bool is_possible(vector<int>arr,int h,int mid)\\n    {     \\n        int count=0;//intialise no of hour\\n        int n=arr.size();\\n        for(int i=0;i<n;i++)\\n        {\\n         count+=ceil((arr[i]*1.0)/mid);//checking time taken to eat every pile of banana\\n        }\\n        if(count<=h)\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        \\n        int n=piles.size();\\n        int start=1;//minimum possible  banana\\n        int end=*max_element(piles.begin(),piles.end());//maximum possible banana eaten\\n        if(h==n)//corner case for easy computaion\\n        {\\n            return end;        \\n        }\\n        \\n        int ans=-1;//intialise final answer\\n        while(start<=end)\\n        {\\n            int mid=(start+end)/2;// finding middle element\\n            cout<<mid<<endl;\\n            if(is_possible(piles,h,mid))//checking is it possible to eat all banana if monkey eat mid banana per hour..\\n            {\\n               ans=mid;//updating\\n                end=mid-1;    //moving left to find more optimal answer      \\n            }\\n            else\\n            {   \\n               start=mid+1;//moving right to remove impossible cases.\\n            }\\n        }\\n        return ans ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    bool is_possible(vector<int>arr,int h,int mid)\\n    {     \\n        int count=0;//intialise no of hour\\n        int n=arr.size();\\n        for(int i=0;i<n;i++)\\n        {\\n         count+=ceil((arr[i]*1.0)/mid);//checking time taken to eat every pile of banana\\n        }\\n        if(count<=h)\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        \\n        int n=piles.size();\\n        int start=1;//minimum possible  banana\\n        int end=*max_element(piles.begin(),piles.end());//maximum possible banana eaten\\n        if(h==n)//corner case for easy computaion\\n        {\\n            return end;        \\n        }\\n        \\n        int ans=-1;//intialise final answer\\n        while(start<=end)\\n        {\\n            int mid=(start+end)/2;// finding middle element\\n            cout<<mid<<endl;\\n            if(is_possible(piles,h,mid))//checking is it possible to eat all banana if monkey eat mid banana per hour..\\n            {\\n               ans=mid;//updating\\n                end=mid-1;    //moving left to find more optimal answer      \\n            }\\n            else\\n            {   \\n               start=mid+1;//moving right to remove impossible cases.\\n            }\\n        }\\n        return ans ;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3271117,
                "title": "j",
                "content": "# Intuition\\nHere the intuition of the problem is search in the non given space .Don\\'t think we do binary search over the given Array but do binary search over the lowest value i.e. 1 and highest value in the  array.\\n\\n# Approach\\nBRUTE FORCE\\n\\n# Complexity\\n- Time complexity:\\nO(n^2 logn)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low=1;\\n        int high=-1;\\n        int k=0;\\n        //Getting the  highest value in the array\\n        for(int i:piles){\\n            high=Integer.max(high,i);\\n        }\\n        //Search  over the values from 1 to high \\n        while( low < high){\\n            int m=(low+high)/2;\\n             k=0;\\n            for(int val:piles){\\n                //total timing when each piles were eaten in m per hour\\n                k+=Math.ceil((double)val/m);\\n             }\\n             //check whether the total timing is less than h if it is then   keep high = m\\n             //if m is answer than m+1 definetly the answer but m-1 may or may not be the answer\\n             //so always keep high as m\\n             if(k <= h) high=m;\\n             // if  it takes time greater than h then move l to m+1\\n             else low=m+1;\\n        }\\n        return high;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low=1;\\n        int high=-1;\\n        int k=0;\\n        //Getting the  highest value in the array\\n        for(int i:piles){\\n            high=Integer.max(high,i);\\n        }\\n        //Search  over the values from 1 to high \\n        while( low < high){\\n            int m=(low+high)/2;\\n             k=0;\\n            for(int val:piles){\\n                //total timing when each piles were eaten in m per hour\\n                k+=Math.ceil((double)val/m);\\n             }\\n             //check whether the total timing is less than h if it is then   keep high = m\\n             //if m is answer than m+1 definetly the answer but m-1 may or may not be the answer\\n             //so always keep high as m\\n             if(k <= h) high=m;\\n             // if  it takes time greater than h then move l to m+1\\n             else low=m+1;\\n        }\\n        return high;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270861,
                "title": "binary-search-py",
                "content": "# Approach\\n<h4>Binary Search\\n\\n# Code\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        l,r=1,max(piles)\\n        while l<r:\\n            mid,t=(l+r)//2,0\\n            for i in piles: t+=(i+mid-1)//mid\\n            print(t,mid,end=\" \")\\n            if t<=h:r=mid\\n            else:l=mid+1\\n        return l \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        l,r=1,max(piles)\\n        while l<r:\\n            mid,t=(l+r)//2,0\\n            for i in piles: t+=(i+mid-1)//mid\\n            print(t,mid,end=\" \")\\n            if t<=h:r=mid\\n            else:l=mid+1\\n        return l \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601825,
                "title": "java-basic-binary-search-98-fatser",
                "content": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max = 0;\\n        for(int i = 0; i< piles.length; i++){\\n            max = Math.max(max , piles[i]);\\n        }\\n        \\n        if(h == piles.length){\\n            return max;\\n        }\\n        int low = 0;\\n        int high = max;\\n        int speed = Integer.MAX_VALUE;\\n        while(low<=high){\\n            int mid = low + (high - low)/2;\\n            if(ifpossible(mid , piles , h)){\\n                speed = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return speed;\\n    }\\n        public static boolean ifpossible(int mid , int crates[] , int h){\\n            int time = 0;\\n            for(int i = 0; i< crates.length ; i++){\\n                time += (int) Math.ceil(crates[i] * 1.0/mid);\\n            }\\n            return time<=h;\\n        }\\n        \\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max = 0;\\n        for(int i = 0; i< piles.length; i++){\\n            max = Math.max(max , piles[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1704143,
                "title": "c-simple-and-clean-binary-search-solution-explained",
                "content": "**Idea:**\\nWe will use typical binary search.\\nInitializing `lo` with zero, and `hi` with the biggest pile, because that\\'s the biggest amount koko can eat in one hour.\\nNow, we want to check:\\nIf koko can eat `mid` bananas an hour and finish on time, maybe she can eat less, so we set `hi = mid` and continue searching.\\nIf koko cannot eat `mid` bananas an hour, we need to try a larger number, so we set `lo = mid + 1` and continue searching.\\n\\n**Time Complexity:** O(mlog(n)) - m is number of piles and n is size of largest pile.\\n**Space Complexity:** O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    bool can_eat_k(vector<int>& piles, int k, int h) {\\n        if (h <= piles.size()) return false;\\n\\n        for (auto p : piles)\\n            h -= (p / k + (p % k != 0));\\n\\n        return h >= 0;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int lo = 1, hi = *max_element(piles.begin(), piles.end()), mid;\\n        \\n        while (lo < hi) {\\n            mid = lo + (hi - lo) / 2;\\n            if (can_eat_k(piles, mid, h)) hi = mid;\\n            else lo = mid + 1;\\n        }\\n        \\n        return lo;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool can_eat_k(vector<int>& piles, int k, int h) {\\n        if (h <= piles.size()) return false;\\n\\n        for (auto p : piles)\\n            h -= (p / k + (p % k != 0));\\n\\n        return h >= 0;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int lo = 1, hi = *max_element(piles.begin(), piles.end()), mid;\\n        \\n        while (lo < hi) {\\n            mid = lo + (hi - lo) / 2;\\n            if (can_eat_k(piles, mid, h)) hi = mid;\\n            else lo = mid + 1;\\n        }\\n        \\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 390523,
                "title": "simple-python-binary-search",
                "content": "Please see my solutions for these similar problems.\\n\\nFor these problems, it\\'s relatively easy to solve the subproblem:\\ngiven a specific guess, determine whether it\\'s possible to xxx?\\nFurthermore, the range of guess is limited, and the boolean answer of the above subproblem has the pattern\\nF...FT...T or T...TF...F.\\nThus, we can use binary search to find the minimal/maximal value such that the boolean answer is True.\\n[378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/1004232/Python-solution-with-thinking-process)\\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/discuss/1714072/Simple-Python-Binary-Search-(similar-problem-listed))\\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/discuss/326747/Python-solutions-with-thinking-process)\\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/390359/Simple-Python-Binary-Search)\\n[1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/409956/Simple-Python-Binary-Search-(similar-problem-listed))\\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/390523/Simple-Python-Binary-Search)\\n[774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/390526/Simple-Python-Binary-Search)\\n[1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/discuss/390530/Simple-Python-Binary-Search)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/1714075/Simple-Python-Binary-Search-(similar-problem-listed))\\n[1891. Cutting Ribbons](https://leetcode.com/problems/cutting-ribbons/discuss/2361972/Python-Binary-search-solution-(similar-problems-listed))\\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/discuss/1698346/Python-Binary-search-solution-(similar-problems-listed))\\n\\n```\\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\\n        def cannot_eat(piles, H, K):\\n            hours = 0\\n            for x in piles:\\n                if x % K == 0:\\n                    hours += x // K\\n                else:\\n                    hours += x // K + 1\\n            return hours > H\\n        \\n        low, high = 1, max(piles)\\n        while low < high:\\n            mid = low + (high - low) // 2\\n            if cannot_eat(piles, H, mid):\\n                low = mid + 1\\n            else:\\n                high = mid\\n        return low\\n```",
                "solutionTags": [],
                "code": "```\\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\\n        def cannot_eat(piles, H, K):\\n            hours = 0\\n            for x in piles:\\n                if x % K == 0:\\n                    hours += x // K\\n                else:\\n                    hours += x // K + 1\\n            return hours > H\\n        \\n        low, high = 1, max(piles)\\n        while low < high:\\n            mid = low + (high - low) // 2\\n            if cannot_eat(piles, H, mid):\\n                low = mid + 1\\n            else:\\n                high = mid\\n        return low\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 152472,
                "title": "python-binary-search-with-bisect",
                "content": "**Explanation:**\\n\\n 1. `CanEat()` acts like a list of `True` or `False` (**Can Koko eat all bananas within H hours?)** with different speed K as its index.\\n\\n 2. We want to find the first (minimum) K that satisfies `CanEat()`:\\n\\n```\\n                           \\u25BC\\n[... False, False, False, True, True, True ...]\\n```\\n\\n3. Binary Search from `1` to `10**9`\\n\\n**Python:**\\n\\n```python\\nfrom bisect import bisect_left\\n\\ndef minEatingSpeed(piles, H):\\n\\n    class CanEat: __getitem__ = (lambda _, i: \\n        sum(ceil(p/i) for p in piles) <= H\\n    )\\n\\n    #      bisect_left(list,     item, lo, hi)\\n    return bisect_left(CanEat(), True, 1, 10**9)\\n```\\n\\n---\\n\\n",
                "solutionTags": [],
                "code": "```\\n                           \\u25BC\\n[... False, False, False, True, True, True ...]\\n```\n```python\\nfrom bisect import bisect_left\\n\\ndef minEatingSpeed(piles, H):\\n\\n    class CanEat: __getitem__ = (lambda _, i: \\n        sum(ceil(p/i) for p in piles) <= H\\n    )\\n\\n    #      bisect_left(list,     item, lo, hi)\\n    return bisect_left(CanEat(), True, 1, 10**9)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927733,
                "title": "c-binary-search-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(N logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n//allocate the piles of banana\\n    long long allocate(vector<int>&v, int banana){\\n        long long sum=0;\\n        for(int it: v){\\n            sum = sum + (it/banana)+((it % banana) !=0);\\n        }\\n        return sum;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        // 3 6 7 11  => h=8\\n        int ans=0;\\n        int s = 1, e = *max_element(piles.begin(),piles.end());\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            long long alloted = allocate(piles, mid);\\n            if(alloted <= h){\\n                ans = mid;\\n                e = mid-1;\\n            } \\n            else s = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n//allocate the piles of banana\\n    long long allocate(vector<int>&v, int banana){\\n        long long sum=0;\\n        for(int it: v){\\n            sum = sum + (it/banana)+((it % banana) !=0);\\n        }\\n        return sum;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        // 3 6 7 11  => h=8\\n        int ans=0;\\n        int s = 1, e = *max_element(piles.begin(),piles.end());\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            long long alloted = allocate(piles, mid);\\n            if(alloted <= h){\\n                ans = mid;\\n                e = mid-1;\\n            } \\n            else s = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881077,
                "title": "easy-and-simple-image-solution-bs",
                "content": "\\n# Approach\\n- Binary Search\\n- Koko wants to eat all bananas within $h$ hours. We are supposed to find the minimum value of $k$.\\n- eg.- $piles = [30,11,23,4,20], h = 6$\\n- $l = 0$ and $r = 1e9+5$\\n- so, we find out the value of k using binary search in $log(1e9)$ complexity.\\n- for this we get $h = 23$\\n- Koko will eat bananas in this way to eat all bananas in 6 hours:\\n![koko.png](https://assets.leetcode.com/users/images/e77ae364-f64b-4f74-b5a9-b441b40872fd_1691487636.3198938.png)\\n\\nFirst hour: 23\\n\\nSecond hour: 7\\n\\nThird hour: 11\\n\\nFourth hour: 23\\n\\nFifth hour: 4\\n\\nSixth hour: 20\\n\\n- if koko eat 23 banana each hours the he will able to eat all in 6 hours.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(nlog(h))$  \\n- n =  length of piles    \\n- Space complexity: $O(1)$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPerfect(vector<int>& piles, int mid, int hours){\\n        int count = 0;\\n        for(auto p : piles)\\n            if(p % mid > 0) count += ((p/mid) + 1);\\n            else count += (p/mid);\\n        return count <= hours;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int hours) {\\n        int l = 1, h = 1e9+5, ans  = 0;\\n        while(l < h){\\n            int mid = (l+h)/2;\\n            if(isPerfect(piles, mid, hours)) ans = mid, h = mid;\\n            else l = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfect(vector<int>& piles, int mid, int hours){\\n        int count = 0;\\n        for(auto p : piles)\\n            if(p % mid > 0) count += ((p/mid) + 1);\\n            else count += (p/mid);\\n        return count <= hours;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int hours) {\\n        int l = 1, h = 1e9+5, ans  = 0;\\n        while(l < h){\\n            int mid = (l+h)/2;\\n            if(isPerfect(piles, mid, hours)) ans = mid, h = mid;\\n            else l = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643281,
                "title": "revved-up-gobbling-crush-the-piles-at-lightning-speed",
                "content": "# Intuition\\nPrepare for a gobbling adventure! Our first move is to find the lowest theoretical speed. By calculating `ceil(sum(piles) / h)`, we determine our starting point. For example, with `piles = [4, 11, 20, 23, 30]` and `h = 5`, we should start with speed 18.\\n\\nBut hold on! I\\'ve discovered a secret technique to optimize our banana-eating. Incrementing by a mere 1 won\\'t cut it! We should try the next speed that gives us an improvement. For `piles = [4, 11, 20, 23, 30]` and `curr_speed = 18`, this is how many hours it would take to finish each pile:\\n\\n`piles = [4, 11, 20, 23, 30]`\\n`curr_turns = [1, 1, 2, 3, 3]`\\n\\nTo improve the performance at `piles[2]` from 2 to 1, we need `curr_speed = 20`. \\nTo improve `piles[3]` from 3 to 2, we need `curr_speed = 12`. \\nTo improve `piles[4]` from 3 to 2, we need `curr_speed = 15`. \\nFor the solution to be correct, we need to choose the smallest next speed.\\n\\n# Approach\\nWe can get a major speedup by only keeping track of the piles that need more than 1 hour to finish. We don\\'t need to keep track of the easy piles! Since finding the next speed takes linear time and we have to do it a linear number of times, by maintaining a smaller list we speed up the program from `O(n^2)` to `O(m^2)`, where m is the number of piles that cannot be processed in one hour.\\n\\n# Complexity\\n- Time complexity: `O(n) + O(m^2)`. One pass to find theoretical minimum. The m is the number of piles that are bigger than the lowest theoretical speed (`m <= n`).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(m)` to store list of big piles.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nAt the time of writing, this solution finishes in top 99%.\\n\\n# Code\\n```\\nfrom math import ceil\\n\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        # Start at lowest theoretical speed. \\n        # Increment by a minimal amount that would yield improvement.\\n        # O(n) + O(m^2)\\n        # m is the list of big piles\\n        curr_speed = ceil(sum(piles) / h)\\n        # Only need to consider piles that take multiple turns to finish.\\n        big_piles = [pile for pile in piles if pile > curr_speed]\\n        curr_turns = [ceil(pile / curr_speed) for pile in big_piles]\\n        curr_num_hours = (len(piles) - len(big_piles)) + sum(curr_turns)\\n        while curr_num_hours > h:\\n            # Find minimally higher speed needed to improve any pile\\'s performance\\n            next_speed = float(\"inf\")\\n            for i in range(len(big_piles)):\\n                if curr_turns[i] > 1:\\n                    next_speed = min(next_speed, ceil(big_piles[i] / (curr_turns[i] - 1)))\\n            curr_speed = next_speed\\n            # Would be even faster if we reduce size of curr_turns and update curr_num_hours accordingly\\n            curr_turns = [ceil(pile / curr_speed) for pile in big_piles]\\n            curr_num_hours = (len(piles) - len(big_piles)) + sum(curr_turns)\\n        return curr_speed\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import ceil\\n\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        # Start at lowest theoretical speed. \\n        # Increment by a minimal amount that would yield improvement.\\n        # O(n) + O(m^2)\\n        # m is the list of big piles\\n        curr_speed = ceil(sum(piles) / h)\\n        # Only need to consider piles that take multiple turns to finish.\\n        big_piles = [pile for pile in piles if pile > curr_speed]\\n        curr_turns = [ceil(pile / curr_speed) for pile in big_piles]\\n        curr_num_hours = (len(piles) - len(big_piles)) + sum(curr_turns)\\n        while curr_num_hours > h:\\n            # Find minimally higher speed needed to improve any pile\\'s performance\\n            next_speed = float(\"inf\")\\n            for i in range(len(big_piles)):\\n                if curr_turns[i] > 1:\\n                    next_speed = min(next_speed, ceil(big_piles[i] / (curr_turns[i] - 1)))\\n            curr_speed = next_speed\\n            # Would be even faster if we reduce size of curr_turns and update curr_num_hours accordingly\\n            curr_turns = [ceil(pile / curr_speed) for pile in big_piles]\\n            curr_num_hours = (len(piles) - len(big_piles)) + sum(curr_turns)\\n        return curr_speed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272877,
                "title": "javascript-solution-beats-99-56-binary-search-approach",
                "content": "```javascript\\n/**\\n * @param {number[]} piles\\n * @param {number} speed\\n * @param {number} h\\n * @return {boolean}\\n */\\nconst canEatAll = (piles, speed, h) => {\\n    let totalTime = 0;\\n    for (const bananas of piles) {\\n        totalTime += Math.ceil(bananas / speed);\\n        if (totalTime > h) {\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n\\n/**\\n * @param {number[]} piles\\n * @param {number} h\\n * @return {number}\\n */\\nvar minEatingSpeed = function (piles, h) {\\n    let left = 1, right = Math.max(...piles);\\n    while (left <= right) {\\n        const mid = Math.floor(left + (right - left) / 2);\\n        if (canEatAll(piles, mid, h)) {\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    return left;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} piles\\n * @param {number} speed\\n * @param {number} h\\n * @return {boolean}\\n */\\nconst canEatAll = (piles, speed, h) => {\\n    let totalTime = 0;\\n    for (const bananas of piles) {\\n        totalTime += Math.ceil(bananas / speed);\\n        if (totalTime > h) {\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n\\n/**\\n * @param {number[]} piles\\n * @param {number} h\\n * @return {number}\\n */\\nvar minEatingSpeed = function (piles, h) {\\n    let left = 1, right = Math.max(...piles);\\n    while (left <= right) {\\n        const mid = Math.floor(left + (right - left) / 2);\\n        if (canEatAll(piles, mid, h)) {\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    return left;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3271281,
                "title": "pytgon3-98-fast-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Binary search.**\\n![Capture.PNG](https://assets.leetcode.com/users/images/024e5e94-3f78-4279-97b5-294b38bf9cd5_1678256525.242.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Well this is not array binary search but more like dangling speed search.\\n- we have lowspeed and **maxspeed**, where **lowspeed** is obviously **1** and **maxspeed** is **maximum(piles)**.\\n- now start dangling between low and max speed.\\n- find **mid speed**, **if** at that speed **we can eat** all banana within givren hr = h then we can **assume** that **loweing speed** might **help** to **find minimum**, so now our maxspeed is midspeed.\\n- now if midspeed is **not covering all bananas** then incresing lowspeed will help, so **lowspeed is now midspeed + 1** (midspeed is not helping so increse it by 1).\\n- do this we converge on **lowspeed ==  midspeed**, and return found lowspeed.\\n- **isPossible()**: helps to **identify** if we use current speedn then **can** we **eat all bananas** within **given time**.\\n\\n# Complexity\\n- Time complexity: O(N * logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom math import ceil as c, floor as f\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        def isPossible(rate_of_banana_eating):\\n            total_hr = 0\\n            for i in piles:\\n                total_hr += c(i / rate_of_banana_eating)\\n            return total_hr <= h\\n        \\n        def find_speed():\\n            maximumSpeed = max(piles)\\n            lowestSpeed = 1\\n            while lowestSpeed < maximumSpeed:\\n                midSpeed = f((lowestSpeed+maximumSpeed)/2)\\n                if isPossible(midSpeed):\\n                    maximumSpeed = midSpeed\\n                else:\\n                    lowestSpeed = midSpeed + 1\\n            return lowestSpeed\\n        return find_speed()\\n\\n```\\n# Note: why only divide by 2\\n - because /2 is efficient than any other /3 or /4.\\n - and somethimes it may be case when we divide by 4 then lowspeed and maxspeed keep changing same values between old and new onces.\\n - so our code will run till infinity.\\n# Please like and comment below. :-)\\n\\uD83C\\uDD5F\\uD83C\\uDD57\\uD83C\\uDD54\\uD83C\\uDD66 \\uD83C\\uDD57\\uD83C\\uDD50\\uD83C\\uDD61\\uD83C\\uDD53 \\uD83C\\uDD5E\\uD83C\\uDD5D\\uD83C\\uDD54",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nfrom math import ceil as c, floor as f\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        def isPossible(rate_of_banana_eating):\\n            total_hr = 0\\n            for i in piles:\\n                total_hr += c(i / rate_of_banana_eating)\\n            return total_hr <= h\\n        \\n        def find_speed():\\n            maximumSpeed = max(piles)\\n            lowestSpeed = 1\\n            while lowestSpeed < maximumSpeed:\\n                midSpeed = f((lowestSpeed+maximumSpeed)/2)\\n                if isPossible(midSpeed):\\n                    maximumSpeed = midSpeed\\n                else:\\n                    lowestSpeed = midSpeed + 1\\n            return lowestSpeed\\n        return find_speed()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271069,
                "title": "easy-approach",
                "content": "Happy Holi guys...\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        l=1\\n        r=max(piles)\\n        while l<r:\\n            mid=(l+r)//2\\n            c=0\\n            for j in piles:\\n                c+=((j-1)//mid)+1\\n            if c>h:\\n                l=mid+1\\n            else:\\n                r=mid\\n        return l\\n```\\n# **Please Upvote this post**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        l=1\\n        r=max(piles)\\n        while l<r:\\n            mid=(l+r)//2\\n            c=0\\n            for j in piles:\\n                c+=((j-1)//mid)+1\\n            if c>h:\\n                l=mid+1\\n            else:\\n                r=mid\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270710,
                "title": "python3-97-98-faster-beats-only-one-line-clean-solution-simple-explain",
                "content": "![image.png](https://assets.leetcode.com/users/images/d2ec0401-b191-4b24-98b1-1d178baaba64_1678266432.1355073.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a speed time list, then Binary search the precise number such that meet the requirements of the problem.\\n# Complexity\\n- Time complexity:O(logN)\\nBinary search with \\nstart , end = 1, max(piles) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\nNeed create time list\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        return bisect_left(range(1,max(piles)), True , key=lambda t:sum(ceil(pile/t) for pile in piles)<=h )+1\\n        # Tips: time list start at 1 because can\\'t divide by zero\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        return bisect_left(range(1,max(piles)), True , key=lambda t:sum(ceil(pile/t) for pile in piles)<=h )+1\\n        # Tips: time list start at 1 because can\\'t divide by zero\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270643,
                "title": "c-binary-search",
                "content": "Minimum Speed with which we could just Finish the Piles within H hours.\\n# Complexity\\n- Time complexity:\\nO(NLOGH)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool could_eat(vector<int>&piles,int h,int speed)\\n    {\\n        for(int i=0;i<piles.size();i++)\\n        {\\n            if(piles[i]%speed==0)\\n            {\\n                h-=(piles[i]/speed);//(piles[i]/speed) units of time to finish pile\\n            }\\n            else\\n            {\\n                h-=(piles[i]/speed)+1;(piles[i]/speed) units of time + 1 for remainder to finish pile\\n            }\\n            if(h<0)\\n            {\\n                return false;//time out....Guards return before could finish completing the current pile\\n            }\\n        }\\n        return true;//Guards didn\\'t return wihtin time to catch\\n    }\\n    int minEatingSpeed(vector<int>&piles,int h) \\n    {\\n        int left=1,right=INT_MIN;\\n        for(auto j:piles)//with this maximum limit we could always complete piles within time\\n        {\\n            right=max(right,j);\\n        }\\n        while(left<=right)//Normal Binary Search to find Minimum Element for which could_eat_piles within time\\n        {\\n            int mid=(left+right)/2;\\n            if(could_eat(piles,h,mid))\\n            {\\n                right=mid-1;\\n            }\\n            else\\n            {\\n                left=mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool could_eat(vector<int>&piles,int h,int speed)\\n    {\\n        for(int i=0;i<piles.size();i++)\\n        {\\n            if(piles[i]%speed==0)\\n            {\\n                h-=(piles[i]/speed);//(piles[i]/speed) units of time to finish pile\\n            }\\n            else\\n            {\\n                h-=(piles[i]/speed)+1;(piles[i]/speed) units of time + 1 for remainder to finish pile\\n            }\\n            if(h<0)\\n            {\\n                return false;//time out....Guards return before could finish completing the current pile\\n            }\\n        }\\n        return true;//Guards didn\\'t return wihtin time to catch\\n    }\\n    int minEatingSpeed(vector<int>&piles,int h) \\n    {\\n        int left=1,right=INT_MIN;\\n        for(auto j:piles)//with this maximum limit we could always complete piles within time\\n        {\\n            right=max(right,j);\\n        }\\n        while(left<=right)//Normal Binary Search to find Minimum Element for which could_eat_piles within time\\n        {\\n            int mid=(left+right)/2;\\n            if(could_eat(piles,h,mid))\\n            {\\n                right=mid-1;\\n            }\\n            else\\n            {\\n                left=mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270492,
                "title": "java-100-faster-step-by-step-explained-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/ac776f4f-2cae-480b-85a4-c39a454dade5_1678239037.368098.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n    // Calculate the minimum and maximum possible values of k\\n    int left = 1, right = (int) 1e9;\\n    \\n    // Binary search to find the minimum value of k\\n    while (left < right) {\\n        int mid = (left + right) / 2;\\n        \\n        // Check if it\\'s possible to eat all bananas with mid as k\\n        if (canEatAllBananas(piles, h, mid)) {\\n            // If it\\'s possible, then we can try to reduce k further\\n            right = mid;\\n        } else {\\n            // If it\\'s not possible, then we need to increase k\\n            left = mid + 1;\\n        }\\n    }\\n    \\n    // The value of left will be the minimum value of k that allows Koko to eat all bananas in h hours\\n    return left;\\n}\\n\\nprivate boolean canEatAllBananas(int[] piles, int h, int k) {\\n    // Initialize hours to 0\\n    int hours = 0;\\n    \\n    // Iterate over each pile of bananas\\n    for (int bananas : piles) {\\n        // Calculate the number of hours required to eat this pile\\n        int pileHours = bananas / k;\\n        if (bananas % k != 0) {\\n            pileHours++; // If there are some bananas left over, we need one more hour\\n        }\\n        \\n        // Add the hours required to eat this pile to the total hours\\n        hours += pileHours;\\n        \\n        // If the total hours exceed h, then we can\\'t eat all bananas in h hours\\n        if (hours > h) {\\n            return false;\\n        }\\n    }\\n    \\n    // If we reach this point, it means we can eat all bananas in h hours\\n    return true;\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n    // Calculate the minimum and maximum possible values of k\\n    int left = 1, right = (int) 1e9;\\n    \\n    // Binary search to find the minimum value of k\\n    while (left < right) {\\n        int mid = (left + right) / 2;\\n        \\n        // Check if it\\'s possible to eat all bananas with mid as k\\n        if (canEatAllBananas(piles, h, mid)) {\\n            // If it\\'s possible, then we can try to reduce k further\\n            right = mid;\\n        } else {\\n            // If it\\'s not possible, then we need to increase k\\n            left = mid + 1;\\n        }\\n    }\\n    \\n    // The value of left will be the minimum value of k that allows Koko to eat all bananas in h hours\\n    return left;\\n}\\n\\nprivate boolean canEatAllBananas(int[] piles, int h, int k) {\\n    // Initialize hours to 0\\n    int hours = 0;\\n    \\n    // Iterate over each pile of bananas\\n    for (int bananas : piles) {\\n        // Calculate the number of hours required to eat this pile\\n        int pileHours = bananas / k;\\n        if (bananas % k != 0) {\\n            pileHours++; // If there are some bananas left over, we need one more hour\\n        }\\n        \\n        // Add the hours required to eat this pile to the total hours\\n        hours += pileHours;\\n        \\n        // If the total hours exceed h, then we can\\'t eat all bananas in h hours\\n        if (hours > h) {\\n            return false;\\n        }\\n    }\\n    \\n    // If we reach this point, it means we can eat all bananas in h hours\\n    return true;\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208566,
                "title": "python3-golang-rust-binary-search",
                "content": "**Python3**:\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        left, right = 1, max(piles)\\n        \\n        while left < right:\\n            mid = (left + right) // 2\\n            hours = 0\\n            \\n            for pile in piles:\\n                hours += ceil(pile / mid)\\n                \\n            if hours <= h:\\n                right = mid\\n            else:\\n                left = mid + 1\\n            \\n        return right\\n```\\n**Golang**:\\n```\\nfunc minEatingSpeed(piles []int, h int) int {\\n    left, right := 1, max(piles)\\n    \\n    for left < right {\\n        mid := (left + right) / 2\\n        hours := 0\\n        \\n        for _, pile := range(piles) {\\n            hours += int(math.Ceil(float64(pile) / float64(mid)))\\n        }\\n        \\n        if hours <= h {\\n            right = mid\\n        } else {\\n            left = mid + 1\\n        }\\n    }\\n    return right\\n}\\n\\nfunc max(arr []int) int {\\n    max := arr[0]\\n    \\n    for _, val := range(arr) {\\n        if max < val {\\n            max = val\\n        }\\n    }\\n    return max\\n}\\n```\\n\\n**Rust**:\\n```\\nimpl Solution {\\n    pub fn min_eating_speed(piles: Vec<i32>, h: i32) -> i32 {\\n        let mut left: i32 = 1;\\n        let mut right: i32 = *piles.iter().max().unwrap();\\n        \\n        while left < right {\\n            let mid: i32 = (left + right) / 2;\\n            let mut hours: i32 = 0;\\n            \\n            for pile in &piles {\\n                hours += (*pile as f64 / mid as f64).ceil() as i32\\n            }\\n            \\n            if hours <= h {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        return right\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Rust"
                ],
                "code": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        left, right = 1, max(piles)\\n        \\n        while left < right:\\n            mid = (left + right) // 2\\n            hours = 0\\n            \\n            for pile in piles:\\n                hours += ceil(pile / mid)\\n                \\n            if hours <= h:\\n                right = mid\\n            else:\\n                left = mid + 1\\n            \\n        return right\\n```\n```\\nfunc minEatingSpeed(piles []int, h int) int {\\n    left, right := 1, max(piles)\\n    \\n    for left < right {\\n        mid := (left + right) / 2\\n        hours := 0\\n        \\n        for _, pile := range(piles) {\\n            hours += int(math.Ceil(float64(pile) / float64(mid)))\\n        }\\n        \\n        if hours <= h {\\n            right = mid\\n        } else {\\n            left = mid + 1\\n        }\\n    }\\n    return right\\n}\\n\\nfunc max(arr []int) int {\\n    max := arr[0]\\n    \\n    for _, val := range(arr) {\\n        if max < val {\\n            max = val\\n        }\\n    }\\n    return max\\n}\\n```\n```\\nimpl Solution {\\n    pub fn min_eating_speed(piles: Vec<i32>, h: i32) -> i32 {\\n        let mut left: i32 = 1;\\n        let mut right: i32 = *piles.iter().max().unwrap();\\n        \\n        while left < right {\\n            let mid: i32 = (left + right) / 2;\\n            let mut hours: i32 = 0;\\n            \\n            for pile in &piles {\\n                hours += (*pile as f64 / mid as f64).ceil() as i32\\n            }\\n            \\n            if hours <= h {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        return right\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783416,
                "title": "c-faster-than-all-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int minEatingSpeed(vector<int>& piles, int H) {\\n        int l = 1, r = 1000000000;\\n        while (l < r) {\\n            int m = (l + r) / 2, total = 0;\\n            for (int p : piles)\\n                total += (p + m - 1) / m;\\n            if (total > H)\\n                l = m + 1;\\n            else\\n                r = m;\\n        }\\n        return l;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int minEatingSpeed(vector<int>& piles, int H) {\\n        int l = 1, r = 1000000000;\\n        while (l < r) {\\n            int m = (l + r) / 2, total = 0;\\n            for (int p : piles)\\n                total += (p + m - 1) / m;\\n            if (total > H)\\n                l = m + 1;\\n            else\\n                r = m;\\n        }\\n        return l;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705032,
                "title": "java-binary-search-solution-easily-explained-even-for-beginners",
                "content": "Let\\'s see how it works.\\nSo the basic idea of a binary search algorithm is to partition a search space into half after each iteration. Same is supposed to be done here. The catch is, we are searching a space we will create ourselves.\\n\\nWe have to return the minimum rate of eating bananas so that, we are finished in ```h``` hours.\\nHow should we go about it? Well binary search suggests us to deal with a sorted array but what sorted array to be exact ? ```piles``` one ? No, we will deal with an increasing sequence of numbers with length equal to ```piles[max] - piles[min]```. What good would this do? Well this will help us search between slowest and fastest rate we could go. \\n\\t    We will start our lower boundary with ```low = 1``` with 1 being the minimum speed of eating bananas anad ```high = piles[max]```. Then we\\'ll follow the traditional binary search, calculate the mid and then comes the crucial part. We must calculate ```total time taken``` by each ```mid``` integer and we will check if that time taken is within the range of given ```h```. If the time is <= h then we will go towards the slower rate to find an even smaller number that can satisfy the time limit of h hours. Ultimately the \\'low\\' and \\'high\\' boundries will converge and we will return the value that would be the minimum rate at which we could eat bananas. Following is the implementation.\\n\\t\\t\\n\\tclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low = 1;\\n        int high = 1;\\n        for(int i=0;i<piles.length;i++){\\n            high = Math.max(high,piles[i]);\\n        }\\n        while(low<high){\\n            int m = (low+high)/2;\\n            int k=0;\\n            for(var i : piles){\\n                k+=Math.ceil((double)i/m);\\n            }\\n            if(k<=h) high = m;\\n            else low = m+1;\\n        }\\n        return high;\\n    }\\n}\\n\\n****Do upvote if you like the explanation.****",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```h```\n```piles```\n```piles[max] - piles[min]```\n```low = 1```\n```high = piles[max]```\n```total time taken```\n```mid```\n```h```",
                "codeTag": "Unknown"
            },
            {
                "id": 1703574,
                "title": "python3-heap-queue",
                "content": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        h_left = h - len(piles)\\n        total = sum(piles)\\n        hq = []\\n        \\n        for bananas in piles:\\n            hour = 1 + h_left * bananas // total\\n            bananas_per_hour = math.ceil(bananas / hour)\\n            heapq.heappush(hq,(-bananas_per_hour, bananas, hour))\\n            h -= hour\\n        \\n        while h > 0:\\n            _, bananas, hour = heapq.heappop(hq)\\n            hour += 1\\n            h -= 1\\n            bananas_per_hour = math.ceil(bananas / hour)\\n            heapq.heappush(hq,(-bananas_per_hour, bananas, hour))\\n        \\n        return -hq[0][0]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        h_left = h - len(piles)\\n        total = sum(piles)\\n        hq = []\\n        \\n        for bananas in piles:\\n            hour = 1 + h_left * bananas // total\\n            bananas_per_hour = math.ceil(bananas / hour)\\n            heapq.heappush(hq,(-bananas_per_hour, bananas, hour))\\n            h -= hour\\n        \\n        while h > 0:\\n            _, bananas, hour = heapq.heappop(hq)\\n            hour += 1\\n            h -= 1\\n            bananas_per_hour = math.ceil(bananas / hour)\\n            heapq.heappush(hq,(-bananas_per_hour, bananas, hour))\\n        \\n        return -hq[0][0]",
                "codeTag": "Java"
            },
            {
                "id": 1534739,
                "title": "c-binary-search-faster-than-95",
                "content": "```\\n    bool check(int k, int h, vector<int> &piles){\\n      int count = 0;\\n      for(auto it : piles){\\n        count += it / k;\\n        if(it % k != 0) count++;\\n      }\\n      if(count <= h) return true;\\n      return false;\\n    }\\n  \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      int beg = 1, end = INT_MIN, ans;\\n      for(auto it : piles) if(it > end) end = it;\\n      \\n\\t  while(beg <= end){\\n        int mid = beg + (end - beg)/2;\\n        if(check(mid, h, piles)) {\\n          ans = mid;\\n          end = mid - 1;\\n        }\\n        else beg = mid + 1;\\n      }\\n      return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool check(int k, int h, vector<int> &piles){\\n      int count = 0;\\n      for(auto it : piles){\\n        count += it / k;\\n        if(it % k != 0) count++;\\n      }\\n      if(count <= h) return true;\\n      return false;\\n    }\\n  \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      int beg = 1, end = INT_MIN, ans;\\n      for(auto it : piles) if(it > end) end = it;\\n      \\n\\t  while(beg <= end){\\n        int mid = beg + (end - beg)/2;\\n        if(check(mid, h, piles)) {\\n          ans = mid;\\n          end = mid - 1;\\n        }\\n        else beg = mid + 1;\\n      }\\n      return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 887786,
                "title": "java-binary-search-w-detailed-explanation",
                "content": "```\\n/* \\n1. Implement findMax(int[] piles) method to find the max amount of banana in a pile and assign it to - int R as the rightmost value;\\n    1.1 Define your search space as : [1,2,3,4,5 ... R], since R is the maximum amount of bananas Koko can eat during 1 hour period\\n\\n2. After you have your search space we will perform Binary Search to find the minimum satisfactory K.\\n    2.1 Implement boolean canEatUnderH(int[] piles, int H, int K) method to find out whether K <= H to eat all bananas.\\n    2.2 For [3,6,7,11] search space is   [1,2,3,4,5,6,7,8,9,10,11]\\n\\t\\t2.2.1 F = false, T = true:       [F,F,F,T,T,T,T,T,T,T,T,T] with this intuition we need to return the leftmost T value using Binary Search which is the answer\\n*/\\n\\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        int L = 1, R = findMax(piles);\\n        \\n        while(L < R) {\\n            int M = L + (R-L)/2;\\n            if(canEatUnderH(piles,H,M))\\n                R = M;\\n            else\\n                L = M+1;\\n        }\\n        \\n        return R;       \\n    }\\n    private int findMax(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        for(int num : nums)\\n            max = Math.max(max, num);\\n\\n        return max;            \\n    }\\n    \\n    public boolean canEatUnderH(int[] piles, int H, int K) {\\n        int time = 0;\\n        for (int p: piles)\\n            time += (p-1) / K + 1;\\n        return time <= H;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n/* \\n1. Implement findMax(int[] piles) method to find the max amount of banana in a pile and assign it to - int R as the rightmost value;\\n    1.1 Define your search space as : [1,2,3,4,5 ... R], since R is the maximum amount of bananas Koko can eat during 1 hour period\\n\\n2. After you have your search space we will perform Binary Search to find the minimum satisfactory K.\\n    2.1 Implement boolean canEatUnderH(int[] piles, int H, int K) method to find out whether K <= H to eat all bananas.\\n    2.2 For [3,6,7,11] search space is   [1,2,3,4,5,6,7,8,9,10,11]\\n\\t\\t2.2.1 F = false, T = true:       [F,F,F,T,T,T,T,T,T,T,T,T] with this intuition we need to return the leftmost T value using Binary Search which is the answer\\n*/\\n\\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        int L = 1, R = findMax(piles);\\n        \\n        while(L < R) {\\n            int M = L + (R-L)/2;\\n            if(canEatUnderH(piles,H,M))\\n                R = M;\\n            else\\n                L = M+1;\\n        }\\n        \\n        return R;       \\n    }\\n    private int findMax(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        for(int num : nums)\\n            max = Math.max(max, num);\\n\\n        return max;            \\n    }\\n    \\n    public boolean canEatUnderH(int[] piles, int H, int K) {\\n        int time = 0;\\n        for (int p: piles)\\n            time += (p-1) / K + 1;\\n        return time <= H;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377681,
                "title": "c-accepted-dull-brute-force-solution",
                "content": "The only solution I could come up with in a reasonable interview time is a brute force approach:\\n* choose starting eating speed better than 1, so we don\\'t get a TLE (how Koko can eat so many bananas per hour???);\\n* repeatedly increment the eating speed until Koko can eat all bananas within `H` hours range;\\n\\nIt is a bit ugly compared to the binary search solution, but it is accepted and *98.21%* faster than other solutions (which was strange for me). But I guess Koko would have needed to visit a doctor after such eating approach.\\n\\n```\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        // Determine the starting eating speed of Koko\\n        // There are no lower eating speed than the average speed,\\n        // because if it was a case, we will not be able to finish all piles within H hours.\\n        double sum = 0.;\\n        for (auto pile : piles) {\\n            sum += pile;\\n        }\\n        int speed = ceil(sum / H);\\n        \\n        // Continuously increment the speed by 1 until\\n        // Koko can eat all bananas within H hours range\\n        while (true) {\\n            int hours = 0;\\n            for (auto pile : piles) {\\n                hours += ceil(double(pile) / speed);\\n                if (hours > H) {\\n                    break;\\n                }\\n            }\\n            \\n            if (hours <= H) {\\n                break;\\n            }\\n            ++speed;\\n        }\\n        return speed;\\n    }\\n```\\n\\nP.S.: RIP Koko... :\\'(",
                "solutionTags": [],
                "code": "```\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        // Determine the starting eating speed of Koko\\n        // There are no lower eating speed than the average speed,\\n        // because if it was a case, we will not be able to finish all piles within H hours.\\n        double sum = 0.;\\n        for (auto pile : piles) {\\n            sum += pile;\\n        }\\n        int speed = ceil(sum / H);\\n        \\n        // Continuously increment the speed by 1 until\\n        // Koko can eat all bananas within H hours range\\n        while (true) {\\n            int hours = 0;\\n            for (auto pile : piles) {\\n                hours += ceil(double(pile) / speed);\\n                if (hours > H) {\\n                    break;\\n                }\\n            }\\n            \\n            if (hours <= H) {\\n                break;\\n            }\\n            ++speed;\\n        }\\n        return speed;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 155546,
                "title": "python-binary-search-100",
                "content": "```\\nhi, lo = math.ceil(sum(piles) / (H - len(piles) + 1)), math.floor(sum(piles) / H)\\nwhile hi - lo > 1:\\n\\t\\tmd = (hi + lo) // 2\\n\\t\\th = sum(math.ceil(pile / md) for pile in piles)\\n\\t\\tif h > H:\\n\\t\\t\\t\\tlo = md\\n\\t\\telse:\\n\\t\\t\\t\\thi = md\\nreturn hi\\n```\\nFirst I use too wide lower and upper bound, which causes much time.\\nHowever, image the best case is that all elements are the same, and the lower bound is actually math.floor(sum(piles) / H)\\nAlso, the worst case is like [1,1,1,...,big_num], then the upper bound should be math.ceil(sum(piles) / (H - len(piles) + 1)).",
                "solutionTags": [],
                "code": "```\\nhi, lo = math.ceil(sum(piles) / (H - len(piles) + 1)), math.floor(sum(piles) / H)\\nwhile hi - lo > 1:\\n\\t\\tmd = (hi + lo) // 2\\n\\t\\th = sum(math.ceil(pile / md) for pile in piles)\\n\\t\\tif h > H:\\n\\t\\t\\t\\tlo = md\\n\\t\\telse:\\n\\t\\t\\t\\thi = md\\nreturn hi\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052057,
                "title": "java-solution-very-easy-to-understand",
                "content": "# Intuition\\nThe problem asks us to find the minimum eating speed that allows us to eat all the bananas within the given time limit. We can approach this problem using binary search.\\n\\n\\n# Approach\\nFind the maximum pile size in the given piles array. We can initialize a variable max to the minimum possible integer value and iterate over all the piles to update the max value if we find a larger pile.\\n\\nInitialize two variables start and end, where start is the minimum possible eating speed (1) and end is the maximum pile size.\\n\\nUse binary search to find the minimum eating speed. While start is less than end, perform the following steps:\\n\\n1. Calculate the middle eating speed mid using start + (end - start) / 2\\n\\n2. Use the koko function to calculate the total number of hours required to eat all the piles with the current eating speed mid. The koko function takes in the eating speed mid and the piles array as parameters. Inside the function, iterate over all the piles and calculate the number of hours required by dividing each pile size by the eating speed and rounding up using Math.ceil(). Add each calculated hours value to a variable sum.\\n\\n3. If the value of sum is greater than the given time h, it means that the eating speed is too low and we need to increase it. Update start to mid + 1.\\n\\n4. If the value of sum is less than or equal to h, it means that the eating speed is sufficient. In this case, update end to mid.\\n\\nAfter the binary search loop terminates, return the value of start as the minimum eating speed that allows us to eat all the piles within h hours.\\n# Complexity\\n- Time complexity:$$O(nlog(max-value-in-piles))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max = Integer.MIN_VALUE;\\n        for (int pile : piles) {\\n            max = Math.max(max, pile);\\n        }\\n        int start = 1;\\n        int end =  max;\\n    \\n        while(start<end){\\n            int mid = start + (end-start) / 2;\\n            if(koko(mid,piles)>h){\\n                start = mid + 1;\\n          }\\n            else{\\n                end=mid;\\n            }\\n        }\\n        return start;\\n    }\\n\\n\\n    public int koko(long num, int[] arr){\\n    int sum = 0;\\n    for(int i = 0; i < arr.length; i++){\\n        sum += Math.ceil((double)arr[i]/num);\\n    }\\n    return sum;\\n}\\n\\n}\\n\\n\\n\\n```\\n\\nPS: Rip KOKO & Harambe, You will be missed.\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max = Integer.MIN_VALUE;\\n        for (int pile : piles) {\\n            max = Math.max(max, pile);\\n        }\\n        int start = 1;\\n        int end =  max;\\n    \\n        while(start<end){\\n            int mid = start + (end-start) / 2;\\n            if(koko(mid,piles)>h){\\n                start = mid + 1;\\n          }\\n            else{\\n                end=mid;\\n            }\\n        }\\n        return start;\\n    }\\n\\n\\n    public int koko(long num, int[] arr){\\n    int sum = 0;\\n    for(int i = 0; i < arr.length; i++){\\n        sum += Math.ceil((double)arr[i]/num);\\n    }\\n    return sum;\\n}\\n\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835079,
                "title": "binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfinding the range in which answer can exist. the maximum answer will be the maximum element present in the piles vector. it will be true when h = piles.size().\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing binary search to find the minimum possible answer in the range.creating another function to check wheather it is possible to eat all the bananas within the h hours.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nplease upvote\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool possible(vector<int> piles, int mid, int h){\\n        long long hours = 0;\\n        for(int i = 0; i < piles.size() ; i++){\\n            hours += piles[i]/mid;\\n            piles[i] %= mid;\\n            if(piles[i] > 0) hours++;\\n            if(hours > h) return false;\\n        }\\n        return true;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int min = 1;\\n        int max = *max_element(piles.begin(),piles.end());\\n        int ans = 0;\\n        while(min <= max){\\n            int mid = (min + max)/2;\\n            if(possible(piles,mid,h)){\\n                ans = mid;\\n                max = mid - 1;\\n            }\\n            else{\\n                min = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possible(vector<int> piles, int mid, int h){\\n        long long hours = 0;\\n        for(int i = 0; i < piles.size() ; i++){\\n            hours += piles[i]/mid;\\n            piles[i] %= mid;\\n            if(piles[i] > 0) hours++;\\n            if(hours > h) return false;\\n        }\\n        return true;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int min = 1;\\n        int max = *max_element(piles.begin(),piles.end());\\n        int ans = 0;\\n        while(min <= max){\\n            int mid = (min + max)/2;\\n            if(possible(piles,mid,h)){\\n                ans = mid;\\n                max = mid - 1;\\n            }\\n            else{\\n                min = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685871,
                "title": "w-explanation-easy-binary-search-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse binary search to find the minimum eating speed that allows finishing within a given time constraint.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe given code defines a class with two functions. The \"eating\" function calculates the total number of hours required to eat piles of food at a given eating speed, taking into account the ceiling function for rounding up. The \"minEatingSpeed\" function uses binary search to find the minimum eating speed that allows all the piles to be consumed within a given time constraint. It initializes left and right pointers based on the time constraint and the maximum pile size. It iteratively updates the pointers until they converge, checking if the current eating speed allows completion within the time constraint. The function returns the minimum eating speed found.\\n\\nOne Testcase:\\n```\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\n823855818\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N log M), where N is the size of the piles vector and M is the maximum element in the piles vector. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\nPlease turn on english subtitles if necessary:\\n[https://www.youtube.com/watch?v=KtZOZ4E1zww](https://www.youtube.com/watch?v=KtZOZ4E1zww)\\n\\n![Cpp\\u89E3Leetcode 875 Koko\\u5403\\u9999\\u8549\\u7528\\u4E8C\\u5143\\u641C\\u5C0B .jpg](https://assets.leetcode.com/users/images/4c3d2eb9-0941-42b5-9827-09bcdf9aa6a3_1680431481.2523654.jpeg)\\n\\nUse trick to compute the ceiling function which is used in the code several times\\n```\\n(p+(k-1))/k; // (int)ceil((double)p/k)\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eating(vector<int>& piles, int k){\\n        int sum=0;\\n        for(int p: piles)\\n            sum+=(p+(k-1))/k; // Calculate the number of hours needed to eat each pile, rounding up using the ceiling function\\n        return sum;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        long long left=h-1; // Initialize the left pointer as h-1\\n\\n        //the following is in fact left=ceil(average(piles))\\n        left=accumulate(piles.begin(), piles.end(), left)/h; // Calculate the average eating speed required, rounding up using the ceiling function\\n\\n        int right=*max_element(piles.begin(),piles.end()); // Initialize the right pointer as the maximum element in the piles vector\\n        \\n        while(left<right) // Perform binary search until left and right pointers meet\\n        {\\n            int&& mid=(left+right)/2; // Calculate the middle pointer\\n            \\n            if (eating(piles, mid)<=h) // If eating at the middle speed allows us to finish within h hours\\n                right=mid; // Update the right pointer to mid\\n            else\\n                left=mid+1; // Update the left pointer to mid+1\\n        }\\n        \\n        return right; // Return the minimum eating speed\\n    }\\n};\\n\\n```\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\n823855818\\n```\n```\\n(p+(k-1))/k; // (int)ceil((double)p/k)\\n```\n```\\nclass Solution {\\npublic:\\n    int eating(vector<int>& piles, int k){\\n        int sum=0;\\n        for(int p: piles)\\n            sum+=(p+(k-1))/k; // Calculate the number of hours needed to eat each pile, rounding up using the ceiling function\\n        return sum;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        long long left=h-1; // Initialize the left pointer as h-1\\n\\n        //the following is in fact left=ceil(average(piles))\\n        left=accumulate(piles.begin(), piles.end(), left)/h; // Calculate the average eating speed required, rounding up using the ceiling function\\n\\n        int right=*max_element(piles.begin(),piles.end()); // Initialize the right pointer as the maximum element in the piles vector\\n        \\n        while(left<right) // Perform binary search until left and right pointers meet\\n        {\\n            int&& mid=(left+right)/2; // Calculate the middle pointer\\n            \\n            if (eating(piles, mid)<=h) // If eating at the middle speed allows us to finish within h hours\\n                right=mid; // Update the right pointer to mid\\n            else\\n                left=mid+1; // Update the left pointer to mid+1\\n        }\\n        \\n        return right; // Return the minimum eating speed\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272560,
                "title": "fastest-dart-solution-binary-search-wow-o-n-logn",
                "content": "# Complexity\\n- Time complexity: $$O(n*logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int minEatingSpeed(List<int> piles, int h) {\\n      int minK = 1;\\n      int maxK = piles.reduce(max);\\n\\n      while(minK <= maxK) {\\n          int middle = (minK + maxK) ~/ 2;\\n\\n          //count hours\\n          int hours = 0;\\n          for (int pile in piles ) {\\n              hours += pile ~/ middle;\\n              hours += pile % middle == 0 ? 0 : 1;\\n          }\\n          \\n          if (hours <= h) {\\n              maxK = middle - 1;\\n          }\\n          else {\\n              minK = middle + 1;\\n          }\\n      }\\n\\n      return minK;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int minEatingSpeed(List<int> piles, int h) {\\n      int minK = 1;\\n      int maxK = piles.reduce(max);\\n\\n      while(minK <= maxK) {\\n          int middle = (minK + maxK) ~/ 2;\\n\\n          //count hours\\n          int hours = 0;\\n          for (int pile in piles ) {\\n              hours += pile ~/ middle;\\n              hours += pile % middle == 0 ? 0 : 1;\\n          }\\n          \\n          if (hours <= h) {\\n              maxK = middle - 1;\\n          }\\n          else {\\n              minK = middle + 1;\\n          }\\n      }\\n\\n      return minK;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272122,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int l = 1;\\n        int r = piles[0];\\n        for(int i = 0;i<piles.length;i++){\\n            r=Math.max(r,piles[i]);\\n        }\\n        \\n        int m;        \\n        int ans = -1;\\n        while(l<=r){\\n            m = (l+r)/2; \\n            if(check(piles, h,m)){\\n                r = m-1;\\n                ans = m;\\n            }else{\\n                l = m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public boolean check(int[] piles, int h, int k){\\n        if(k ==0)return false;\\n        int i = 0;\\n        while(h>=0 && i<piles.length){\\n\\n            h -=Math.ceil((double)piles[i]/k);\\n            i++;\\n        }\\n        return (h>=0 && i == piles.length);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int l = 1;\\n        int r = piles[0];\\n        for(int i = 0;i<piles.length;i++){\\n            r=Math.max(r,piles[i]);\\n        }\\n        \\n        int m;        \\n        int ans = -1;\\n        while(l<=r){\\n            m = (l+r)/2; \\n            if(check(piles, h,m)){\\n                r = m-1;\\n                ans = m;\\n            }else{\\n                l = m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public boolean check(int[] piles, int h, int k){\\n        if(k ==0)return false;\\n        int i = 0;\\n        while(h>=0 && i<piles.length){\\n\\n            h -=Math.ceil((double)piles[i]/k);\\n            i++;\\n        }\\n        return (h>=0 && i == piles.length);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271457,
                "title": "detailed-step-by-step-explanation-java-python-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this problem is that we need to find the minimum possible value of K (the eating speed) that will allow us to eat all the bananas in the given piles within H hours. One possible approach to finding the minimum value of K is to use binary search, because the search space (the range of possible values of K) is continuous and can be divided in half at each step, making binary search a good candidate for finding the minimum value efficiently.\\n\\nTo use binary search, we need to define a valid function that will check whether a particular value of K is valid, i.e., whether we can eat all the bananas in the given piles within H hours using that value of K. The valid function needs to iterate over all the piles and calculate the total number of hours required to eat all the bananas using the given value of K. If the total number of hours is less than or equal to H, then the value of K is valid, otherwise it is not valid.\\n\\nOnce we have a valid function, we can use binary search to find the minimum valid value of K. We start with the range of possible values of K (from 1 to the maximum number of bananas in the piles), and at each step we check the middle value of the range using the valid function. If the middle value is valid, then we narrow the range to the lower half of the current range, otherwise we narrow the range to the upper half of the current range. We repeat this process until we have narrowed the range to a single valid value, which is the minimum value of K that satisfies the given constraints.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in this solution is binary search. The search is performed on the range of possible values for K, which is between 1 and the maximum number of bananas in any pile. The binary search is performed by repeatedly dividing the search range in half until the correct value of K is found. The blackbox method is used to check if a given K value is valid (i.e., Koko can eat all the bananas in H hours). If the given K value is too small, Koko cannot eat all the bananas in H hours and the search range is adjusted accordingly to the right. Conversely, if the given K value is too large, Koko can eat all the bananas in H hours and the search range is adjusted to the left.\\n\\nThe blackbox method calculates the number of hours it will take Koko to eat all the bananas in the piles using the given K value. This is done by iterating over each pile and dividing the number of bananas in the pile by K. The quotient gives the number of hours required to eat all the bananas in the pile. If there are any bananas left over (i.e., the pile size is not a multiple of K), one additional hour is required. The sum of the hours required for each pile gives the total number of hours required to eat all the bananas. If this total is less than or equal to H, the given K value is valid and the method returns true. Otherwise, the method returns false.\\n\\nThe maxBananas method simply iterates over all the piles to find the maximum number of bananas in any pile. This value is used as the upper bound for the binary search range.\\n\\nFinally, the minEatingSpeed method uses the binary search to find the minimum value of K such that Koko can eat all the bananas in the given piles within H hours. The method returns the minimum value of K.\\n# Explanation\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low=1;\\n        int high=maxBananas(piles);\\n```\\nThe minEatingSpeed method takes in an array `piles` representing the number of bananas in each pile and an integer `h` representing the maximum number of hours Koko has to eat all the bananas. The method returns the minimum positive integer `K` such that Koko can eat all the bananas in the given piles within h hours.\\n\\nThe method initializes `low` to 1, which represents the minimum possible value of `K`. It initializes `high` to the maximum number of bananas in any pile, which represents the maximum possible value of `K`.\\n```\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            if(blackbox(mid,piles,h)){\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n```\\nThe method then enters a while loop which runs until `low` becomes greater than or equal to `high`. Inside the while loop, it calculates the midpoint `mid` of the current range of `K` values using the formula `(low + high) / 2`.\\n\\nIt then checks if the mid value is a valid value of K by calling the `blackbox` method. If the `mid` value is valid, it updates the value of `high` to `mid`. Otherwise, it updates the value of `low` to `mid + 1`.\\n\\nAfter the while loop exits, it returns the value of `low`, which is the minimum possible value of `K`.\\n```\\n    public boolean blackbox(int maxBananas,int[] piles,int h){\\n        int hours=0;\\n        for(int i:piles){\\n            int time=i/maxBananas;\\n            hours += time;\\n            if(i % maxBananas!=0) hours++;\\n        }\\n        if(hours <= h)\\n            return true;\\n        return false;\\n    }\\n```\\nThe `blackbox` method takes in a value `maxBananas`, which represents the value of `K` to be tested, the array `piles` representing the number of bananas in each pile, and the maximum number of hours `h` that Koko has to eat all the bananas.\\n\\nThe method calculates the number of hours it will take Koko to eat all the bananas using the given `maxBananas` value. This is done by iterating over each pile and dividing the number of bananas in the pile by `maxBananas`. The quotient gives the number of hours required to eat all the bananas in the pile. If there are any bananas left over (i.e., the pile size is not a multiple of maxBananas), one additional hour is required. The sum of the hours required for each pile gives the total number of hours required to eat all the bananas.\\n\\nIf this total is less than or equal to `h`, the method returns `true`, indicating that the given `maxBananas` value is a valid value of `K`. Otherwise, the method returns `false`.\\n```\\n    public int maxBananas (int[] piles){\\n        int maxBananas = 0;\\n        for(int i=0;i<piles.length;i++){\\n            maxBananas=Math.max(maxBananas,piles[i]);\\n        }\\n        return maxBananas;\\n    }\\n}\\n```\\nThe `maxBananas` method takes in an array `piles` representing the number of bananas in each pile. It iterates over all the `piles` to find the maximum bananas in the pile.\\n\\n# Complexity\\n- Time complexity:      $$O(N log M)$$,\\n where N is the number of piles and M is the maximum number of bananas in a pile. This is because the method uses binary search to search for the minimum possible value of K, and each iteration of the binary search takes O(N) time to check whether a particular value of K is valid using the blackbox method, which itself takes O(N) time to iterate over all the piles.\\nThe time complexity of the `maxBananas` method is O(N), where N is the number of piles, because the method needs to iterate over all the piles to find the maximum number of bananas.\\nThe time complexity of the `blackbox` method is O(N), where N is the number of piles, because the method needs to iterate over all the piles to calculate the number of hours required to eat all the bananas using the given value of `K`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**$$O(1)$$**, \\nbecause the method only uses a constant amount of space to store the variables `low`, `high`, and `mid`.\\nThe space complexity of the `blackbox` method is O(1), because the method only uses a constant amount of space to store the variables `hours`, `time`, and `i`.\\nThe space complexity of the maxBananas method is O(1), because the method only uses a constant amount of space to store the variable maxBananas.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low=1;\\n        int high=maxBananas(piles);\\n        \\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            if(blackbox(mid,piles,h)){\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n    public boolean blackbox(int maxpiles,int[] piles,int h){\\n        int hours=0;\\n        for(int i:piles){\\n            int time=i/maxpiles;\\n            hours+=time;\\n            if(i%maxpiles!=0) hours++;\\n        }\\n        if(hours<=h)\\n            return true;\\n        return false;\\n    }\\n    public int maxBananas (int[] piles){\\n        int maxBananas = 0;\\n        for(int i=0;i<piles.length;i++){\\n            maxBananas=Math.max(maxBananas,piles[i]);\\n        }\\n        return maxBananas;\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/be28e379-60ba-4216-9e2d-7d5e015313da_1678259451.250167.png)\\n\\n# Pyhton3\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        low,high,ans = 1,max(piles),0\\n        while low <= high:\\n            mid = low + (high - low) // 2\\n            hours = 0\\n            for p in piles:\\n                hours += ceil(p / mid)\\n            if hours <= h:\\n                ans = mid\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n        return ans\\n```\\n![image.png](https://assets.leetcode.com/users/images/0de9c636-e54c-4f3c-80da-8ba798d2ecbc_1678258936.6838865.png)\\n---\\n\\n# Connect\\nLinkedIn : www.linkedin.com/in/akashjana\\n\\n---\\n#### Please consider upvoting if you find this helpful. Thank You :)\\n![image.png](https://assets.leetcode.com/users/images/f36a288e-bdb7-4264-b2d5-8d7275e29330_1678259367.2213438.png)\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low=1;\\n        int high=maxBananas(piles);\\n```\n```\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            if(blackbox(mid,piles,h)){\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n```\n```\\n    public boolean blackbox(int maxBananas,int[] piles,int h){\\n        int hours=0;\\n        for(int i:piles){\\n            int time=i/maxBananas;\\n            hours += time;\\n            if(i % maxBananas!=0) hours++;\\n        }\\n        if(hours <= h)\\n            return true;\\n        return false;\\n    }\\n```\n```\\n    public int maxBananas (int[] piles){\\n        int maxBananas = 0;\\n        for(int i=0;i<piles.length;i++){\\n            maxBananas=Math.max(maxBananas,piles[i]);\\n        }\\n        return maxBananas;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low=1;\\n        int high=maxBananas(piles);\\n        \\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            if(blackbox(mid,piles,h)){\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n    public boolean blackbox(int maxpiles,int[] piles,int h){\\n        int hours=0;\\n        for(int i:piles){\\n            int time=i/maxpiles;\\n            hours+=time;\\n            if(i%maxpiles!=0) hours++;\\n        }\\n        if(hours<=h)\\n            return true;\\n        return false;\\n    }\\n    public int maxBananas (int[] piles){\\n        int maxBananas = 0;\\n        for(int i=0;i<piles.length;i++){\\n            maxBananas=Math.max(maxBananas,piles[i]);\\n        }\\n        return maxBananas;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        low,high,ans = 1,max(piles),0\\n        while low <= high:\\n            mid = low + (high - low) // 2\\n            hours = 0\\n            for p in piles:\\n                hours += ceil(p / mid)\\n            if hours <= h:\\n                ans = mid\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270892,
                "title": "well-explained-code-in-java",
                "content": "\\n\\n# Approach\\nThe solution uses a binary search algorithm to find the minimum possible value of k. The minEatingSpeed function takes in an integer array piles representing the number of bananas in each pile, and an integer h representing the maximum number of hours Koko can work per day.\\n\\nFirst, we find the maximum value in the piles array using a loop. This value will be the upper bound for our binary search.\\n\\nNext, we perform the binary search. We initialize lo to 0 and hi to max, and then repeatedly calculate the middle point sp between lo and hi. We call the isPossible function to check if it is possible for Koko to eat all the bananas at a rate of sp bananas per hour within h hours. If it is possible, we update speed to sp and move the upper bound hi to sp-1 to try to find a smaller value of k. If it is not possible, we move the lower bound lo to sp+1 to try to find a larger value of k.\\n\\nFinally, we return the value of speed, which will be the minimum value of k for which it is possible for Koko to eat all the bananas within h hours.\\n\\nThe isPossible function takes in the same arguments as minEatingSpeed and returns a boolean value indicating whether it is possible for Koko to eat all the bananas within h hours at a rate of sp bananas per hour. The implementation of isPossible is the same as the second implementation we discussed earlier.\\n\\n# Complexity\\n- Time complexity:\\nO(n log m), where n is the length of the piles array and m is the maximum value in the piles array. This is because we perform a binary search for the minimum possible value of k, and each iteration of the binary search takes O(n) time to call the isPossible function, which has a time complexity of O(n) due to the for loop. The binary search takes O(log m) iterations to converge to a single value, so the total time complexity is O(n log m).\\n\\n- Space complexity:\\nO(1), The minEatingSpeed function uses a constant amount of extra space, regardless of the size of the input.\\n\\n# Note\\n\\n```\\n// 1st method\\npublic boolean isPossible(int[]piles,int sp,int h){\\n    int time = 0;\\n    for(int i=0;i<piles.length;i++){\\n        time += (int)Math.ceil(piles[i]*1.0/sp);\\n    }\\n    return time<=h;\\n}\\n```\\n```\\n//2nd method\\npublic boolean isPossible(int[]piles,int sp,int h){\\n    int time = 0;\\n    for(int i=0;i<piles.length;i++){\\n        time += (int)Math.ceil(piles[i]*1.0/sp);\\n        if(time > h) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```\\n\\nThe difference between the two methods is in the way they calculate the total time it takes for the monkey to finish eating all the bananas. The first method simply calculates the total time required to finish all the piles, and returns true if this time is less than or equal to the maximum allowed time h. The second method, on the other hand, calculates the time required to finish each pile individually, and checks at each step if the total time exceeds the maximum allowed time h. If it does, it immediately returns false, indicating that the monkey cannot finish eating all the bananas within the given time constraints.\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max = Integer.MIN_VALUE;\\n        for(int val : piles){\\n            max = Math.max(val,max);\\n        }\\n        if(h==piles.length){\\n            return max;\\n        }\\n        int lo = 0;\\n        int hi = max;\\n        int speed = Integer.MAX_VALUE;\\n        while(lo<=hi){\\n            int sp = lo + (hi-lo)/2;\\n            if(isPossible(piles,sp,h)){\\n                speed = sp;\\n                hi = sp-1;\\n            }else{\\n                lo = sp+1;\\n            }\\n        }\\n        return speed;\\n    }\\n    public boolean isPossible(int[]piles,int sp,int h){\\n        int time = 0;\\n        for(int i=0;i<piles.length;i++){\\n            time += (int)Math.ceil(piles[i]*1.0/sp);\\n            if(time > h) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/e0201d37-8f7b-4ffe-9b79-be1f9399d2ea_1678249742.4366345.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n// 1st method\\npublic boolean isPossible(int[]piles,int sp,int h){\\n    int time = 0;\\n    for(int i=0;i<piles.length;i++){\\n        time += (int)Math.ceil(piles[i]*1.0/sp);\\n    }\\n    return time<=h;\\n}\\n```\n```\\n//2nd method\\npublic boolean isPossible(int[]piles,int sp,int h){\\n    int time = 0;\\n    for(int i=0;i<piles.length;i++){\\n        time += (int)Math.ceil(piles[i]*1.0/sp);\\n        if(time > h) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max = Integer.MIN_VALUE;\\n        for(int val : piles){\\n            max = Math.max(val,max);\\n        }\\n        if(h==piles.length){\\n            return max;\\n        }\\n        int lo = 0;\\n        int hi = max;\\n        int speed = Integer.MAX_VALUE;\\n        while(lo<=hi){\\n            int sp = lo + (hi-lo)/2;\\n            if(isPossible(piles,sp,h)){\\n                speed = sp;\\n                hi = sp-1;\\n            }else{\\n                lo = sp+1;\\n            }\\n        }\\n        return speed;\\n    }\\n    public boolean isPossible(int[]piles,int sp,int h){\\n        int time = 0;\\n        for(int i=0;i<piles.length;i++){\\n            time += (int)Math.ceil(piles[i]*1.0/sp);\\n            if(time > h) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105173,
                "title": "easy-c-solution-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>&piles,int speed){\\n        int time=0;        \\n        for(int i=0;i<piles.size();i++){\\n            time+=piles[i]/speed;\\n            if(piles[i]%speed>0)\\n                time++;\\n        }\\n        return time;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l=1;\\n        int r=*max_element(piles.begin(),piles.end());\\n        while(r>=l){\\n            int mid=l+(r-l)/2;            \\n            if(check(piles,mid)>h)\\n                l=mid+1;\\n            else\\n                r=mid-1;\\n        }   \\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>&piles,int speed){\\n        int time=0;        \\n        for(int i=0;i<piles.size();i++){\\n            time+=piles[i]/speed;\\n            if(piles[i]%speed>0)\\n                time++;\\n        }\\n        return time;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l=1;\\n        int r=*max_element(piles.begin(),piles.end());\\n        while(r>=l){\\n            int mid=l+(r-l)/2;            \\n            if(check(piles,mid)>h)\\n                l=mid+1;\\n            else\\n                r=mid-1;\\n        }   \\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900110,
                "title": "c-easy-to-understand-tc-o-m-log-max-piles-sc-o-1",
                "content": "#### *Upvote if it helps\\u2B06\\uFE0F*\\n```\\n\\tint minEatingSpeed(vector<int>& piles, int h) {\\n        int m=piles.size(), l=1,r=0;\\n        for(auto bananas: piles) r=max(r,bananas);\\n        \\n        int mid=0, ans=0;\\n        while(l<=r){\\n            mid=(l+r)/2;\\n            int count=0;\\n            for(auto bananas: piles){\\n                count+=bananas/mid;\\n                if(bananas%mid) count++;\\n            }\\n            if(count<=h) ans=mid,r=mid-1;\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\tint minEatingSpeed(vector<int>& piles, int h) {\\n        int m=piles.size(), l=1,r=0;\\n        for(auto bananas: piles) r=max(r,bananas);\\n        \\n        int mid=0, ans=0;\\n        while(l<=r){\\n            mid=(l+r)/2;\\n            int count=0;\\n            for(auto bananas: piles){\\n                count+=bananas/mid;\\n                if(bananas%mid) count++;\\n            }\\n            if(count<=h) ans=mid,r=mid-1;\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1704403,
                "title": "hit-and-trail-approach-of-solving",
                "content": "class Solution {\\npublic:\\n    \\n \\n    \\n    vector<int>v;int limit;\\n\\t\\n\\t\\n\\t   //IS IT POSSIBLE TO EAT ALL BANANA WITH THIS SPEED\\n    bool solve(int speed)\\n    {\\n        int ans=0;\\n        for(int x:v)\\n        {\\n            //ceil of time\\n            ans+=(x/speed+(x%speed!=0));\\n        }\\n        \\n        if(ans<=limit)\\n            return true;\\n        else return false;\\n    \\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) \\n    {\\n        v=piles;\\n        limit=h;\\n        int l=1,r=INT_MIN;\\n        \\n        for(int x:piles)\\n        {\\n            r=max(r,x);\\n        }\\n        \\n        int res=-1;\\n        while(l<=r)\\n        {\\n            int m=l+(r-l)/2;\\n            \\n            if(solve(m))\\n            {\\n             //YES IT IS POSSIBLE TO FINISH ALL THE BANANA WITH M SPEED   \\n                res=m;\\n                          \\n                //STILL GO ANY TRY IF IT IS POSSIBLE TO FINISH WITH ANY SMALLER SPEED\\n                r=m-1;\\n            }\\n            else\\n            {\\n                l=m+1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n \\n    \\n    vector<int>v;int limit;\\n\\t\\n\\t\\n\\t   //IS IT POSSIBLE TO EAT ALL BANANA WITH THIS SPEED\\n    bool solve(int speed)\\n    {\\n        int ans=0;\\n        for(int x:v)\\n        {\\n            //ceil of time\\n            ans+=(x/speed+(x%speed!=0));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1075275,
                "title": "java-n-log-n-solution",
                "content": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        int maxSpeed = 0;\\n        int minSpeed = 1;\\n        for (int pile:piles)maxSpeed=Math.max(maxSpeed,pile);\\n        \\n        return binary(piles, H, minSpeed, maxSpeed);\\n    }\\n    \\n    public int binary(int[]piles, int H, int minSpeed, int maxSpeed){\\n        if (minSpeed==maxSpeed){\\n            if (canEatAll(piles, H, minSpeed))return minSpeed;\\n            else return minSpeed+1;\\n        };\\n        int middle = minSpeed + (maxSpeed - minSpeed)/2;\\n        if (canEatAll(piles, H, middle))return binary(piles, H, minSpeed, middle);\\n        else return binary(piles, H, middle+1, maxSpeed);\\n    }\\n    \\n    public boolean canEatAll(int[]piles, int H, int speed){\\n        for (int pile:piles)\\n            H-= pile/speed + (pile%speed==0?0:1);\\n        return H>=0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        int maxSpeed = 0;\\n        int minSpeed = 1;\\n        for (int pile:piles)maxSpeed=Math.max(maxSpeed,pile);\\n        \\n        return binary(piles, H, minSpeed, maxSpeed);\\n    }\\n    \\n    public int binary(int[]piles, int H, int minSpeed, int maxSpeed){\\n        if (minSpeed==maxSpeed){\\n            if (canEatAll(piles, H, minSpeed))return minSpeed;\\n            else return minSpeed+1;\\n        };\\n        int middle = minSpeed + (maxSpeed - minSpeed)/2;\\n        if (canEatAll(piles, H, middle))return binary(piles, H, minSpeed, middle);\\n        else return binary(piles, H, middle+1, maxSpeed);\\n    }\\n    \\n    public boolean canEatAll(int[]piles, int H, int speed){\\n        for (int pile:piles)\\n            H-= pile/speed + (pile%speed==0?0:1);\\n        return H>=0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963720,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n    bool isPossible(vector<int> &piles, int hours, int speed)\\n    {\\n      int count = 0;\\n      int n = piles.size();\\n      \\n      for(int i = 0; i < n; i++)\\n      {\\n//      If speed of eating banana in our hour is greter than or equal to  pile height, we just incremenet by the count by 1. because we know she can eat the complete pile in an hour\\n        if(piles[i] <= speed)\\n          count += 1;\\n        \\n//      Now we have a pile height of 11 and eating banana in every hour is 4, then we will take 4*2 hours to eat 8 bananas and (11 - 8) -> 3 bananas we can eat in one hour. so we can do piles[i]/speed + 1.\\n        \\n        else\\n        {\\n          count += (piles[i]/speed) + 1;\\n        }\\n      }\\n      \\n      return (count <= hours) ? true : false;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int H) \\n    {\\n      int low = 1;\\n//       we have taken this high because we want to get the minimum hour so we need to find the ceiling value\\n      int high = *max_element(piles.begin(), piles.end());\\n      \\n      while(low < high)\\n      {\\n        int mid = low + (high - low)/2;\\n        \\n        if(isPossible(piles, H, mid))\\n        {\\n          high = mid;\\n        } else {\\n          low = mid + 1;\\n        }\\n      }\\n      \\n      return low;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    bool isPossible(vector<int> &piles, int hours, int speed)\\n    {\\n      int count = 0;\\n      int n = piles.size();\\n      \\n      for(int i = 0; i < n; i++)\\n      {\\n//      If speed of eating banana in our hour is greter than or equal to  pile height, we just incremenet by the count by 1. because we know she can eat the complete pile in an hour\\n        if(piles[i] <= speed)\\n          count += 1;\\n        \\n//      Now we have a pile height of 11 and eating banana in every hour is 4, then we will take 4*2 hours to eat 8 bananas and (11 - 8) -> 3 bananas we can eat in one hour. so we can do piles[i]/speed + 1.\\n        \\n        else\\n        {\\n          count += (piles[i]/speed) + 1;\\n        }\\n      }\\n      \\n      return (count <= hours) ? true : false;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int H) \\n    {\\n      int low = 1;\\n//       we have taken this high because we want to get the minimum hour so we need to find the ceiling value\\n      int high = *max_element(piles.begin(), piles.end());\\n      \\n      while(low < high)\\n      {\\n        int mid = low + (high - low)/2;\\n        \\n        if(isPossible(piles, H, mid))\\n        {\\n          high = mid;\\n        } else {\\n          low = mid + 1;\\n        }\\n      }\\n      \\n      return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152338,
                "title": "binary-search-with-optimized-runtime",
                "content": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        Arrays.sort(piles);\\n        long total = 0;\\n        for(int pile : piles) total += pile;\\n        int min = (int)Math.ceil(total/(double)H);\\n        int max = piles[piles.length - 1];\\n        while (min < max){\\n            if (canFinish(piles, min, H)) return min;\\n            if (canFinish(piles, (min + max) / 2, H)) max = (min + max)/2;\\n            else min = (min + max) / 2 + 1;\\n        }\\n        return (int)min;\\n    }\\n    \\n    \\n    private boolean canFinish(int[] piles, int speed, int target){\\n        long counter = 0;\\n        for (int pile : piles){\\n            counter += Math.ceil(pile / (double)speed);\\n        }\\n        return (int)counter <= target;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        Arrays.sort(piles);\\n        long total = 0;\\n        for(int pile : piles) total += pile;\\n        int min = (int)Math.ceil(total/(double)H);\\n        int max = piles[piles.length - 1];\\n        while (min < max){\\n            if (canFinish(piles, min, H)) return min;\\n            if (canFinish(piles, (min + max) / 2, H)) max = (min + max)/2;\\n            else min = (min + max) / 2 + 1;\\n        }\\n        return (int)min;\\n    }\\n    \\n    \\n    private boolean canFinish(int[] piles, int speed, int target){\\n        long counter = 0;\\n        for (int pile : piles){\\n            counter += Math.ceil(pile / (double)speed);\\n        }\\n        return (int)counter <= target;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882285,
                "title": "optimal-solution-using-binary-search",
                "content": "\\n\\n# Approach\\n- The maxEl function finds the maximum number of bananas in any pile. This value is used as the upper bound for the binary search.\\n\\n- The totalHours function calculates the total hours needed to finish eating all piles at a given eating speed \"hrs\". It uses the formula (piles[i] + hrs - 1) / hrs to perform ceiling division for each pile.\\n\\n- The minEatingSpeed function employs binary search to find the minimum eating speed \"k\". The search range is between 1 (minimum possible speed) and the maximum number of bananas in a pile. The loop narrows down the range by checking if the total hours needed at the current eating speed \"mid\" are within the allowed time \"h\".\\n\\n- The binary search continues until the low and high bounds cross each other. The result is the minimum eating speed \"k\" that allows Koko to finish eating all bananas within the given time \"h\".\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxEl(vector<int>& piles) {\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < piles.size(); i++){\\n            maxi = max(maxi, piles[i]);\\n        }\\n        return maxi;\\n    }\\n\\n    long long totalHours(vector<int>& piles, int hrs) {\\n        long long total = 0;\\n        for(int i = 0; i < piles.size(); i++) {\\n            total += (piles[i] + hrs - 1) / hrs; \\n        }\\n        return total;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low = 1, high = maxEl(piles);\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            long long total = totalHours(piles, mid);\\n            if(total <= h) high = mid - 1;\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n};\\n```\\n```JAVA []\\nclass Solution {\\n    public int maxEl(int[] piles) {\\n        int maxi = Integer.MIN_VALUE;\\n        for (int i = 0; i < piles.length; i++) {\\n            maxi = Math.max(maxi, piles[i]);\\n        }\\n        return maxi;\\n    }\\n\\n    public long totalHours(int[] piles, int hrs) {\\n        long total = 0;\\n        for (int i = 0; i < piles.length; i++) {\\n            total += (piles[i] + hrs - 1) / hrs; // Ceiling division\\n        }\\n        return total;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low = 1, high = maxEl(piles);\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            long total = totalHours(piles, mid);\\n            if (total <= h) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxEl(vector<int>& piles) {\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < piles.size(); i++){\\n            maxi = max(maxi, piles[i]);\\n        }\\n        return maxi;\\n    }\\n\\n    long long totalHours(vector<int>& piles, int hrs) {\\n        long long total = 0;\\n        for(int i = 0; i < piles.size(); i++) {\\n            total += (piles[i] + hrs - 1) / hrs; \\n        }\\n        return total;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low = 1, high = maxEl(piles);\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            long long total = totalHours(piles, mid);\\n            if(total <= h) high = mid - 1;\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n};\\n```\n```JAVA []\\nclass Solution {\\n    public int maxEl(int[] piles) {\\n        int maxi = Integer.MIN_VALUE;\\n        for (int i = 0; i < piles.length; i++) {\\n            maxi = Math.max(maxi, piles[i]);\\n        }\\n        return maxi;\\n    }\\n\\n    public long totalHours(int[] piles, int hrs) {\\n        long total = 0;\\n        for (int i = 0; i < piles.length; i++) {\\n            total += (piles[i] + hrs - 1) / hrs; // Ceiling division\\n        }\\n        return total;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low = 1, high = maxEl(piles);\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            long total = totalHours(piles, mid);\\n            if (total <= h) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606500,
                "title": "optimized-bounds-binary-search-python3-solution",
                "content": "# Optimized Bounds + Binary Search\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nIn addition to the binary search solution, I also added an optimization at the beginning to find the bounds of where k could be. This should be better than the posted solutions, since it\\'s able to find the bounds in O(nlog(n)), which is equivalent to the modified BS and can severely cut down on the starting space that\\'s checked, more than doubling the % beat from 35% to 80%\\n\\n# Code\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        k = 1\\n        hours_taken = sum(piles)\\n        while hours_taken > h:\\n            k *= 2\\n            hours_taken = sum([math.ceil(p / k) for p in piles])\\n        if k == 1:\\n            return k\\n\\n        l = k/2\\n        while l < k:\\n            mid = (l + k) // 2\\n            val = sum([math.ceil(p / mid) for p in piles])\\n\\n            if val <= h:\\n                k = mid\\n            else:\\n                l = mid + 1\\n        return int(k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        k = 1\\n        hours_taken = sum(piles)\\n        while hours_taken > h:\\n            k *= 2\\n            hours_taken = sum([math.ceil(p / k) for p in piles])\\n        if k == 1:\\n            return k\\n\\n        l = k/2\\n        while l < k:\\n            mid = (l + k) // 2\\n            val = sum([math.ceil(p / mid) for p in piles])\\n\\n            if val <= h:\\n                k = mid\\n            else:\\n                l = mid + 1\\n        return int(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551930,
                "title": "c-delight-easy-and-understandable-solution-for-koko-s-banana-munching",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to find the minimum eating speed (Koko\\'s eating speed) required for Koko to eat all the bananas within a given time limit. To solve this, we can use binary search to find the minimum eating speed. We know that Koko can only eat one pile at a time, so the eating speed should be such that Koko can finish eating all the piles within the given time limit.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Define a helper function \\'tym\\' that takes the piles vector and a mid value as parameters. This function calculates the total time required for Koko to eat all the piles with the given eating speed mid.\\n2. Inside the \\'tym\\' function, initialize a variable sum to keep track of the total time.\\n3. Iterate through each pile in the piles vector.\\n- Divide the current pile by mid to get the number of times Koko needs to eat that pile.\\n- If there is any remainder (pile % mid != 0), increment the count by 1 because Koko needs to eat an extra time to finish the remaining bananas.\\n- Add the count to the sum variable.\\n4. Return the sum.\\n5. In the minEatingSpeed function:\\n - Initialize variables l and r to 1 and the maximum element in the piles vector, respectively.\\n - Initialize ans to 0, which will store the minimum eating speed.\\n - Use a while loop with the condition l <= r to perform binary search.\\n - Calculate the middle value mid using the formula l + (r - l) / 2.\\n- Call the tym function with the piles vector and mid to get the total time required.\\n- If the total time is less than or equal to the given time limit H:\\n-Update ans to the current mid value.\\n-Update r to mid - 1 to search for a smaller eating speed.\\n- Else:\\n-Update l to mid + 1 to search for a larger eating speed.\\n- Repeat the loop until l becomes greater than r.\\n6. Return ans, which will be the minimum eating speed required for Koko.\\n\\n\\n# Complexity\\n- Time complexity:O(n * log(max_piles))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution { \\n    long long int tym(vector<int>&piles,int mid)\\n    {\\n        long long sum = 0; \\n        for(int i=0;i<piles.size();i++)\\n        {\\n            sum+=(piles[i]/mid)+((piles[i]%mid)!=0);\\n        }\\n        return sum;\\n    }   \\n    public:\\n    int minEatingSpeed(vector<int>& piles, int H) \\n    {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        int l = 1;\\n        int r;\\n        r = *max_element(piles.begin(), piles.end());\\n        int ans = 0;\\n        while(l <= r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            long long int time = tym(piles,mid);\\n\\t\\t\\t\\n                if (time <= H)\\n                {\\n                    ans = mid;\\n                    r = mid - 1;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution { \\n    long long int tym(vector<int>&piles,int mid)\\n    {\\n        long long sum = 0; \\n        for(int i=0;i<piles.size();i++)\\n        {\\n            sum+=(piles[i]/mid)+((piles[i]%mid)!=0);\\n        }\\n        return sum;\\n    }   \\n    public:\\n    int minEatingSpeed(vector<int>& piles, int H) \\n    {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        int l = 1;\\n        int r;\\n        r = *max_element(piles.begin(), piles.end());\\n        int ans = 0;\\n        while(l <= r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            long long int time = tym(piles,mid);\\n\\t\\t\\t\\n                if (time <= H)\\n                {\\n                    ans = mid;\\n                    r = mid - 1;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3273559,
                "title": "happy-holi-easy-c-solution",
                "content": "\\n# Code\\nAttempted this question after a fun and tiring day, happy to solve within 15mins....Happy Holi\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int s=1,e=1e9;\\n        int n=piles.size();\\n        while(s<=e){\\n            long long hours=0;\\n            int mid=(s+e)/2;\\n            for(int i=0;i<n;i++){\\n                if(piles[i]%mid==0){\\n                    hours+=(piles[i]/mid);\\n                }\\n                else{\\n                    int x=piles[i]/mid;\\n                    x++;\\n                    hours+=x;\\n                }\\n            }\\n            if(hours<=h){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int s=1,e=1e9;\\n        int n=piles.size();\\n        while(s<=e){\\n            long long hours=0;\\n            int mid=(s+e)/2;\\n            for(int i=0;i<n;i++){\\n                if(piles[i]%mid==0){\\n                    hours+=(piles[i]/mid);\\n                }\\n                else{\\n                    int x=piles[i]/mid;\\n                    x++;\\n                    hours+=x;\\n                }\\n            }\\n            if(hours<=h){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273376,
                "title": "c-fully-explained-binary-search",
                "content": "```\\n// #google, #amazon, #Airbnb, #FaceBook\\n\\n/*\\nIntution : Binary Search\\n1. By understading the question we know there will always possible ans so we do not have to worry about the case when he is not able to eat all the banana\\'s\\n2. If we take the maximum piles from piles array and set the speed as maximum in the piles array then for every index Koko need only 1 hr to finish the bananas at that index, we also know koko give atleast 1 hr at every index to eat banana(bananas can be 1 -> 10^9)\\n3. So for Binary search our lowSpeed = 1, and highSpeed = max(piles_array)\\n4. Then we approach this question via binary search and at every iteration of Binary search we have to check weather koko can eat banana at that speed: there are two case:\\n    Case 1:  if koko can eat all banana within h hr at that speed then this can be out possible answer so we have to store it and check for lower speed if there could possible with lower speed as well ( high = mid - 1)\\n    case2 : If koko can\\'t eat all banana within h hr then we have to check for higher speed ( low = mid+1)\\n5. isPossible funtion is simple just check if koko can finish the banana within the h hr at specific speed it returns true of false which will evaluated at main function\\nIf you rreally finds my solution usefull then please do upvote\\n */\\n/* ====>>> Solution for Leetcode <<<=====  */\\nclass Solution\\n{\\npublic:\\n    bool isPossible(vector<int> &piles, int speed, int h)\\n    {\\n        long long count = 0;\\n        for (int i = 0; i < piles.size(); i++)\\n        {\\n            count += ceil(piles[i] / (double)speed);\\n        }\\n        return count <= h;\\n    }\\n\\n    int minEatingSpeed(vector<int> &piles, int h)\\n    {\\n        int low = 1, high = INT_MIN;\\n        for (int i = 0; i < piles.size(); i++)\\n            high = max(high, piles[i]);\\n        int ans = INT_MAX;\\n        while (low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if (isPossible(piles, mid, h))\\n            {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n// #google, #amazon, #Airbnb, #FaceBook\\n\\n/*\\nIntution : Binary Search\\n1. By understading the question we know there will always possible ans so we do not have to worry about the case when he is not able to eat all the banana\\'s\\n2. If we take the maximum piles from piles array and set the speed as maximum in the piles array then for every index Koko need only 1 hr to finish the bananas at that index, we also know koko give atleast 1 hr at every index to eat banana(bananas can be 1 -> 10^9)\\n3. So for Binary search our lowSpeed = 1, and highSpeed = max(piles_array)\\n4. Then we approach this question via binary search and at every iteration of Binary search we have to check weather koko can eat banana at that speed: there are two case:\\n    Case 1:  if koko can eat all banana within h hr at that speed then this can be out possible answer so we have to store it and check for lower speed if there could possible with lower speed as well ( high = mid - 1)\\n    case2 : If koko can\\'t eat all banana within h hr then we have to check for higher speed ( low = mid+1)\\n5. isPossible funtion is simple just check if koko can finish the banana within the h hr at specific speed it returns true of false which will evaluated at main function\\nIf you rreally finds my solution usefull then please do upvote\\n */\\n/* ====>>> Solution for Leetcode <<<=====  */\\nclass Solution\\n{\\npublic:\\n    bool isPossible(vector<int> &piles, int speed, int h)\\n    {\\n        long long count = 0;\\n        for (int i = 0; i < piles.size(); i++)\\n        {\\n            count += ceil(piles[i] / (double)speed);\\n        }\\n        return count <= h;\\n    }\\n\\n    int minEatingSpeed(vector<int> &piles, int h)\\n    {\\n        int low = 1, high = INT_MIN;\\n        for (int i = 0; i < piles.size(); i++)\\n            high = max(high, piles[i]);\\n        int ans = INT_MAX;\\n        while (low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if (isPossible(piles, mid, h))\\n            {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272708,
                "title": "explained-clearly-with-intuition-and-approach-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe question wants us to find the minimum rate `h` _(bananas/hour)_ for which Koko consumes all the bananas before the guard arrives.\\n\\n_PS: The guards are useless LOL!_\\n\\n---\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBy analyzing the searching space and constraints, we can say that `Binary Search` will be an efficient approach for this. Because for Linear search, it\\'ll definitely throw TLE.\\n\\n- Step 1: For Binary Search, we requires a range. Guess what, this is the initial mindstorming part. Minimum rate in which Koko can consume bananas is 1 and maximum is the maximum_element of the piles array.\\n- Now lets begin the BS, finding mid, checking the hours for the mid rate. If it results in more than `h` hours then Koko will be busted by the guards. So what? Then we will have to reduce our serching space by shifting our focus to the right array. Otherwise we will be using the left array.\\n\\n---\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n---\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        sort(piles.begin(), piles.end());\\n        int left = 1, right = piles[piles.size()-1];\\n\\n        while(left<=right){\\n            int mid = left + (right-left)/2;\\n            long long int hours = 0;\\n\\n            for(auto x:piles){\\n                hours+= x/mid;\\n                if(x%mid!=0) hours++;\\n            }\\n\\n            if(hours<=h) right = mid-1;\\n            else left = mid+1;\\n        }\\n\\n        return left;\\n    }\\n};\\n```\\n---\\n_If you have any doubts, feel free to ask in the comment section.\\nAnd if you have find optimizations in my solution, do let me know._\\n\\n[Lets connect on LinkedIn](https://www.linkedin.com/in/priyanshu-choudhary-techgeek/)\\n\\nPLEASE MAKE SURE TO UPVOTE THE SOLUTION AS IT GIVES ME MOTIVATION TO DO MORE.\\n\\n---\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/65eeb207-f2a9-4d1b-9d13-2c8573d657ed_1677603105.5077243.png\" alt=\"\">\\n</p>",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        sort(piles.begin(), piles.end());\\n        int left = 1, right = piles[piles.size()-1];\\n\\n        while(left<=right){\\n            int mid = left + (right-left)/2;\\n            long long int hours = 0;\\n\\n            for(auto x:piles){\\n                hours+= x/mid;\\n                if(x%mid!=0) hours++;\\n            }\\n\\n            if(hours<=h) right = mid-1;\\n            else left = mid+1;\\n        }\\n\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272664,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long timetaken(vector<int>& piles, int k)\\n    {\\n        long long ans=0;\\n        for (int i=0; i<piles.size(); i++){\\n            ans+= (piles[i]/k)+(piles[i]%k!=0);\\n        }\\n        return ans;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h)\\n     {\\n        int low=1; int high= *max_element(piles.begin(),piles.end());\\n        while (low <= high)\\n        {\\n            int mid= low+ (high-low)/2;\\n            if (timetaken(piles,mid)<=h)\\n            {\\n                high= mid-1;\\n            }\\n            else low= mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long timetaken(vector<int>& piles, int k)\\n    {\\n        long long ans=0;\\n        for (int i=0; i<piles.size(); i++){\\n            ans+= (piles[i]/k)+(piles[i]%k!=0);\\n        }\\n        return ans;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h)\\n     {\\n        int low=1; int high= *max_element(piles.begin(),piles.end());\\n        while (low <= high)\\n        {\\n            int mid= low+ (high-low)/2;\\n            if (timetaken(piles,mid)<=h)\\n            {\\n                high= mid-1;\\n            }\\n            else low= mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272567,
                "title": "easy-binary-search-approach-with-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst sort the *piles* array then find the left index which will be the minimum number of banana to be eaten i.e(1), then find the right index which will be the maximum number of banana to be eaten which will be the last element of the array.\\nNow we have the range of our answer, use binary search to find our answer quickly. For this use a sum variable and a mid variable , where mid = (right-left)/2+left and sum contains piles[i]/mid and if there is a remainder then add 1. Then use the condition if else which is provided in the code.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $$O(nlogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        Arrays.sort(piles);\\n        int left = 1;\\n        int right = piles[piles.length-1];\\n        while(left <= right){\\n            long sum = 0;\\n            int mid = (right-left)/2+left;\\n            for(int i = 0 ; i < piles.length ;i++){\\n                sum += piles[i]/mid;\\n                if(piles[i]%mid> 0){\\n                    sum++;\\n                }\\n            }\\n            if(sum > h){\\n                left = mid+1;\\n            }\\n            else{\\n                right = mid-1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```\\n\\nHaving doubts in understanding the approach then feel free to ask in the comment section.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg\" alt=\"\">\\n</p>\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        Arrays.sort(piles);\\n        int left = 1;\\n        int right = piles[piles.length-1];\\n        while(left <= right){\\n            long sum = 0;\\n            int mid = (right-left)/2+left;\\n            for(int i = 0 ; i < piles.length ;i++){\\n                sum += piles[i]/mid;\\n                if(piles[i]%mid> 0){\\n                    sum++;\\n                }\\n            }\\n            if(sum > h){\\n                left = mid+1;\\n            }\\n            else{\\n                right = mid-1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272216,
                "title": "binary-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(n))$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int minEatingSpeed(vector<int>& piles, int h) {\\n         int n=piles.size();\\n        sort(piles.begin(),piles.end());\\n        int low=1,high=piles[n-1],ans=INT_MAX;\\n        long long hours;\\n        while(low<=high){\\n            hours=0;\\n            int mid=(low+high)/2;\\n            for(int i=0;i<n;i++){\\n                if(piles[i]%mid==0)\\n                hours+=piles[i]/mid;\\n                else\\n                hours+=(piles[i]/mid)+1;\\n            }\\n            if(hours<=(long long)h){\\n            ans=mid;\\n            high=mid-1;\\n            }\\n            else{\\n            low=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int minEatingSpeed(vector<int>& piles, int h) {\\n         int n=piles.size();\\n        sort(piles.begin(),piles.end());\\n        int low=1,high=piles[n-1],ans=INT_MAX;\\n        long long hours;\\n        while(low<=high){\\n            hours=0;\\n            int mid=(low+high)/2;\\n            for(int i=0;i<n;i++){\\n                if(piles[i]%mid==0)\\n                hours+=piles[i]/mid;\\n                else\\n                hours+=(piles[i]/mid)+1;\\n            }\\n            if(hours<=(long long)h){\\n            ans=mid;\\n            high=mid-1;\\n            }\\n            else{\\n            low=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271509,
                "title": "java-brute-force-approach",
                "content": "```\\n// Approach 1: Brute Force - TLE\\n\\n// Time complexity: O(m * n), where n is length of piles, m is max(piles)\\n// Space complexity: O(1)\\n\\npublic int minEatingSpeed(int[] piles, int h) {\\n\\tint speed = 1;\\n\\t\\n\\twhile (true) {\\n\\t\\tlong hours = 0;\\n\\t\\t\\n\\t\\tfor (int pile : piles) {\\n\\t\\t\\thours += pile / speed;\\n\\t\\t\\t\\n\\t\\t\\tif (pile % speed != 0)\\n\\t\\t\\t\\thours++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (hours <= h)\\n\\t\\t\\tbreak;\\n\\t\\t\\n\\t\\tspeed++;\\n\\t}\\n\\t\\n\\treturn speed;\\n}\\n```\\n\\n**Note:** This solution gives TLE. It\\'s provided just for understanding purpose.\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Approach 1: Brute Force - TLE\\n\\n// Time complexity: O(m * n), where n is length of piles, m is max(piles)\\n// Space complexity: O(1)\\n\\npublic int minEatingSpeed(int[] piles, int h) {\\n\\tint speed = 1;\\n\\t\\n\\twhile (true) {\\n\\t\\tlong hours = 0;\\n\\t\\t\\n\\t\\tfor (int pile : piles) {\\n\\t\\t\\thours += pile / speed;\\n\\t\\t\\t\\n\\t\\t\\tif (pile % speed != 0)\\n\\t\\t\\t\\thours++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (hours <= h)\\n\\t\\t\\tbreak;\\n\\t\\t\\n\\t\\tspeed++;\\n\\t}\\n\\t\\n\\treturn speed;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3271225,
                "title": "python3-clean-beats-75-88-99-75-improvement-thanks-for-reading-upvt",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou guess `numOfBanana` per hour.\\nEach `piles[i]` requires `piles[i] / numOfBanana` = `hours needed` to finish, then `sum total hours`.\\n\\nIf `sum total hours` > `h` -> you need to eat MORE \\uD83C\\uDF4C\\uD83C\\uDF4C\\uD83C\\uDF4C\\uD83C\\uDF4C\\uD83C\\uDF4C.\\nIf `sum total hours` < `h` -> you need to eat LESS \\uD83C\\uDF4C.\\n\\n---\\n\\n# Approach - [\"intuition 75.88%\" to \"improvement 99.75%\"]\\n<!-- Describe your approach to solving the problem. -->\\n--> **INTUITION** 1. `l` = 1, `r` = `max(piles)` intuitively, at most you will eat this many so you can finish every pile in 1 hour.\\n\\n2. Get `sum total hours` needed to finish all the `piles[]` -> using $$math.ceil()$$ because you have to +1 for additional hour to finish the remainder banana. --> (eg. 7(pile[ i ]) / 3(per hr) = 2(hr) .. 1(left), you need 2+1 = 3 hours to finish the pile)\\n3. If `sum total hours` > `h` -> you need to eat MORE \\uD83C\\uDF4C\\uD83C\\uDF4C\\uD83C\\uDF4C\\uD83C\\uDF4C\\uD83C\\uDF4C.\\nIf `sum total hours` < `h` -> you need to eat LESS \\uD83C\\uDF4C.\\n\\n--> \\uD83E\\uDDFC**IMPROVEMENT**\\uD83E\\uDDFC 4. Make the range `l` to `r` smaller so we can do fewer $$Binary Search\\'es$$.\\n\\n5. `l = sum(piles) / h` --> LOWER-BOUND: min. avg banana eaten per hr if no pile constraint\\n6. `r = max(piles) / (h // len(piles))`. --> HIGHER-BOUND: h // len(piles) --> **number of rounds** if distribute number of hrs to eat each pile evenly. (eg. [2,3,8], len = 3, h = 7 \\u27A1\\uFE0F 7//3 = 2, we evenly eat each pile at least 2 times) --> max(piles) / **number of rounds** = . (eg. [2,3,8], max = 8 \\u27A1\\uFE0F 8/2 = 4, # of banana per round per each pile)\\n\\n# Complexity\\n- \\u2705\\u231B Time complexity: $$O(N * log(N))$$\\u231B --> $$Binary Search$$ technique divides range from `l` to `r` by **2** every run.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- \\u2705\\uD83D\\uDCBE Space complexity: $$O(1)$$ \\uD83D\\uDCBE --> Storing `l` and `r`.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# \\uD83E\\uDDFCCode\\uD83E\\uDDFC[99.75% - After Improvement]\\n![image.png](https://assets.leetcode.com/users/images/15442652-b6ba-47cd-ae7e-61a45ad059c6_1678254378.609097.png)\\n\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        # \\uD83E\\uDDFCIMPROVEMENT\\uD83E\\uDDFC #\\n        l = math.ceil(sum(piles) / h) # LOWER: total banana / h, avg banana per banana if no pile constraint\\n        r = math.ceil(max(piles) / (h // len(piles))) # HIGHER: banan per \"round\" per pile if eat every pile same number of times.\\n\\n        while l < r:\\n            numOfBanana = (l + r) // 2\\n            if sum(math.ceil(p / numOfBanana) for p in piles) > h:\\n                l = numOfBanana + 1\\n            else:\\n                r = numOfBanana\\n\\n        return l\\n```\\n# [75.88% - Before Improvement]\\n![image.png](https://assets.leetcode.com/users/images/edb3820a-6bcd-4739-8acd-d4b821a8552c_1678250644.5445335.png)\\n\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        # \\uD83E\\uDDE0INTUITION\\uD83E\\uDDE0 # \\n        l = 1\\n        r = max(piles)\\n\\n        while l < r:\\n            numOfBanana = (l+r) // 2\\n            if sum(math.ceil(p / numOfBanana) for p in piles) > h:\\n                l = numOfBanana + 1\\n            else:\\n                r = numOfBanana\\n\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        # \\uD83E\\uDDFCIMPROVEMENT\\uD83E\\uDDFC #\\n        l = math.ceil(sum(piles) / h) # LOWER: total banana / h, avg banana per banana if no pile constraint\\n        r = math.ceil(max(piles) / (h // len(piles))) # HIGHER: banan per \"round\" per pile if eat every pile same number of times.\\n\\n        while l < r:\\n            numOfBanana = (l + r) // 2\\n            if sum(math.ceil(p / numOfBanana) for p in piles) > h:\\n                l = numOfBanana + 1\\n            else:\\n                r = numOfBanana\\n\\n        return l\\n```\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        # \\uD83E\\uDDE0INTUITION\\uD83E\\uDDE0 # \\n        l = 1\\n        r = max(piles)\\n\\n        while l < r:\\n            numOfBanana = (l+r) // 2\\n            if sum(math.ceil(p / numOfBanana) for p in piles) > h:\\n                l = numOfBanana + 1\\n            else:\\n                r = numOfBanana\\n\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271066,
                "title": "go-come-mister-tally-man-tally-me-banana-harry-belafonte-o-n-log-k-time-o-1-space",
                "content": "\\n> \"Man these bananas are good! - *Brian Regan*\\n\\nKoko be munchin\\' them bananas. A regular potassium assassin.\\n\\nWe need to find the **optimal** value for $k$ given a specific number of hours $h$ that those pesky guards will be gone.\\n\\n\\n---\\n\\n\\nLooking at the constraints of our problem - we can see that *$h$ is greater-than or equal to the number of piles*. This gives us a hint that time $k$ will be at-most the largest number of bananas from some pile, as a larger value for $k$ would mean Koko would be eating them bananas way too fast... like a duck or something, and Koko is not a duck. No sirree, bob... wait - no bob either -- Koko not be bobbin\\' like  a bird.\\n\\nWe need to let Koko relax. We need to let Koko spread them bananas out over the hour, like Elvis spread bananas on his sandwiches.\\n\\nWe know that $h$ can be as large as $10^9$, so it could easily be the case that Koko will transform into a sloth and only eat 1 banana per hour to finish all the bananas... and also somehow live to be over 100 thousand years old, but that\\'s not important. Anyway, the summation across all the piles of bananas could be exactly the number of hours we were given. If we were given more hours than bananas, then Koko would be bored not doing anything for those extra hours. So let the minimum be Koko eats 1 banana per hour.\\n\\n---\\n\\nThe inequality around time $k$ should be greater-than or equal to 1 and less-than or equal to the largest number of bananas in some pile. We can determine the max value in $O(n)$ time.\\n\\n$$\\n1 \\\\le k \\\\le max(piles)\\n$$\\n\\nWe have a left and right side... right? That means we can have the walls close in on time $k$ using a binary search to determine the optimal value that will satisfy Koko\\'s banana bonanza, without making Koko be a duck or sloth. \\n\\n---\\n\\n```go\\n// Time complexity: O(n log k) - where n is the number of piles and k is the largest pile\\n// Space complexity: O(1)\\nfunc minEatingSpeed(piles []int, h int) int {\\n\\t// O(n) - determine largest pile of bananas - as Koko may need to eat a pile per hour if h is the same as the number of piles\\n\\tindexOfLargestK := 0\\n    largestK := piles[0]\\n\\tfor i := 1; i < len(piles); i++ {\\n\\t\\tif piles[i] > largestK {\\n\\t\\t\\tindexOfLargestK = i\\n            largestK = piles[i]\\n\\t\\t}\\n\\t}\\n\\n\\t// O(1) - if h is the same as the number of piles, then just return the largest pile as we cannot\\n\\t// \\t\\t  optimize k any better\\n\\tif h == len(piles) {\\n\\t\\treturn largestK\\n\\t}\\n\\n    // O(1) - move largest pile to the front so Koko eats up most of the hours at the beginning. This could be a \"low-hanging fruit\" optimization depending on the size of the piles and h, and what was already in piles[0]\\n    piles[0], piles[indexOfLargestK] = piles[indexOfLargestK], piles[0]\\n\\n\\t// O(log k) - we need to optimize/minimize for k. we will use a binary search to do so.\\n\\tleft, right := 1, largestK\\n\\tfor left < right {\\n\\t\\t// k speed\\n\\t\\tmid := (left + right) / 2\\n\\n\\t\\t// O(n) - determine how many hours are left after Koko eats the bananas at k=mid speed\\n\\t\\thoursLeft := h\\n\\t\\tfor i := 0; hoursLeft >= 0 && i < len(piles); i++ {\\n\\t\\t\\thoursLeft -= (piles[i] + mid - 1) / mid\\n\\t\\t}\\n\\n\\t\\tif hoursLeft < 0 { // Koko did not finish the bananas in time, so we have failed to optimize\\n\\t\\t\\tleft = mid + 1\\n\\t\\t} else { // Koko may have ate the bananas too fast, but may have done just \"right\"\\n\\t\\t\\tright = mid\\n\\t\\t}\\n\\t}\\n\\treturn right\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```go\\n// Time complexity: O(n log k) - where n is the number of piles and k is the largest pile\\n// Space complexity: O(1)\\nfunc minEatingSpeed(piles []int, h int) int {\\n\\t// O(n) - determine largest pile of bananas - as Koko may need to eat a pile per hour if h is the same as the number of piles\\n\\tindexOfLargestK := 0\\n    largestK := piles[0]\\n\\tfor i := 1; i < len(piles); i++ {\\n\\t\\tif piles[i] > largestK {\\n\\t\\t\\tindexOfLargestK = i\\n            largestK = piles[i]\\n\\t\\t}\\n\\t}\\n\\n\\t// O(1) - if h is the same as the number of piles, then just return the largest pile as we cannot\\n\\t// \\t\\t  optimize k any better\\n\\tif h == len(piles) {\\n\\t\\treturn largestK\\n\\t}\\n\\n    // O(1) - move largest pile to the front so Koko eats up most of the hours at the beginning. This could be a \"low-hanging fruit\" optimization depending on the size of the piles and h, and what was already in piles[0]\\n    piles[0], piles[indexOfLargestK] = piles[indexOfLargestK], piles[0]\\n\\n\\t// O(log k) - we need to optimize/minimize for k. we will use a binary search to do so.\\n\\tleft, right := 1, largestK\\n\\tfor left < right {\\n\\t\\t// k speed\\n\\t\\tmid := (left + right) / 2\\n\\n\\t\\t// O(n) - determine how many hours are left after Koko eats the bananas at k=mid speed\\n\\t\\thoursLeft := h\\n\\t\\tfor i := 0; hoursLeft >= 0 && i < len(piles); i++ {\\n\\t\\t\\thoursLeft -= (piles[i] + mid - 1) / mid\\n\\t\\t}\\n\\n\\t\\tif hoursLeft < 0 { // Koko did not finish the bananas in time, so we have failed to optimize\\n\\t\\t\\tleft = mid + 1\\n\\t\\t} else { // Koko may have ate the bananas too fast, but may have done just \"right\"\\n\\t\\t\\tright = mid\\n\\t\\t}\\n\\t}\\n\\treturn right\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3270451,
                "title": "c-easy-beats-100-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen thinking of brute force only one thing comes to mind that lets take a set of number and try if that is the minimum in which all bananas can be eaten.So why not optimise it by using binary Search.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLets first think about the minimum and maximum value that could possibly be the answer. Minimum can be 1 obviously but now think about max value; it cannot be more than maximum value of the array $$piles$$ so you can either find the maximum element or other way is to directly see the constraint and see maximum possible value i.e $$10^9$$.\\nNow we know what could be our $$low$$ and $$high$$. We can apply binary search and find minimum possible $$k$$.\\nTo check if the $$mid$$ is correct or not we use function check in which we find the hours taken by Koko if her $$speed$$ was $$mid$$.Which could be found by taking sum of $$ceil(piles[i]/speed)$$.\\n\\n# Complexity\\n- Time complexity: $$O(Nlog(K))$$\\nwhere N is size of array $$piles$$ and K is the maximum element or $$10^9$$ depending on your choice.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&piles,int h,long long speed)\\n    {\\n        long long countHours=0;\\n        for(auto i:piles)\\n        {\\n            countHours+=(i+speed-1)/speed;//equivalent to ceil(i/speed)\\n        }\\n        if(countHours<=h)return true;\\n        else return false;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=1,high=1e9;\\n        int ans=-1;\\n        while(low<=high)\\n        {\\n            long long mid=(low+high>>1);//equivalent to (mid+high)/2\\n            if(check(piles,h,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Thank You for Reading\\nAsk your query in comment if any\\nif (you understood my explaination)\\nupvote the solution\\nelse \\ndownvote the solution $$:)$$",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&piles,int h,long long speed)\\n    {\\n        long long countHours=0;\\n        for(auto i:piles)\\n        {\\n            countHours+=(i+speed-1)/speed;//equivalent to ceil(i/speed)\\n        }\\n        if(countHours<=h)return true;\\n        else return false;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=1,high=1e9;\\n        int ans=-1;\\n        while(low<=high)\\n        {\\n            long long mid=(low+high>>1);//equivalent to (mid+high)/2\\n            if(check(piles,h,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270429,
                "title": "java-binary-search-simple-and-easy",
                "content": "# Code\\n```\\nclass Solution {\\n  public int minEatingSpeed(int[] piles, int h) {\\n    var r = 0;\\n    var sum = 0;\\n\\n    for (var pile : piles) {\\n      r = Math.max(r, pile);\\n      sum += pile;\\n    }\\n    var l = sum / h;\\n\\n    while (l < r) {\\n      var m = l + (r-l) / 2;\\n      var hours = 0;\\n\\n      for (var i=0; i < piles.length && hours <= h; i++)\\n        hours += Math.ceil(piles[i] / (double) m);\\n\\n      if (hours > h) l = m+1;\\n      else r = m;\\n    }\\n    return l;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n  public int minEatingSpeed(int[] piles, int h) {\\n    var r = 0;\\n    var sum = 0;\\n\\n    for (var pile : piles) {\\n      r = Math.max(r, pile);\\n      sum += pile;\\n    }\\n    var l = sum / h;\\n\\n    while (l < r) {\\n      var m = l + (r-l) / 2;\\n      var hours = 0;\\n\\n      for (var i=0; i < piles.length && hours <= h; i++)\\n        hours += Math.ceil(piles[i] / (double) m);\\n\\n      if (hours > h) l = m+1;\\n      else r = m;\\n    }\\n    return l;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270361,
                "title": "daily-leetcoding-challenge-march-day-8",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3082799,
                "title": "super-easy-java-sol-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Binary Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N log x) (x is the max bananas from all piles)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n    int max=Integer.MIN_VALUE;\\n    for(int val:piles){\\n        max = Math.max(val,max);\\n    }\\n    if(h==piles.length){\\n        return max;\\n    }\\n    int low=0,high = max,speed = Integer.MAX_VALUE;\\n    while(low<=high){\\n        int sp = low+(high-low)/2;\\n        if(isPossible(piles,sp,h)==true){\\n            speed = sp;\\n            high = sp-1;\\n        }else{\\n            low = sp+1;\\n        }\\n    }\\n      return speed;\\n    \\n    }public boolean isPossible(int[] piles,int sp,int h){\\n        int time=0;\\n        for(int i=0;i<piles.length;i++){\\n          time+=(int)Math.ceil((piles[i]*1.0)/sp);\\n        }\\n        return time<=h;\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n    int max=Integer.MIN_VALUE;\\n    for(int val:piles){\\n        max = Math.max(val,max);\\n    }\\n    if(h==piles.length){\\n        return max;\\n    }\\n    int low=0,high = max,speed = Integer.MAX_VALUE;\\n    while(low<=high){\\n        int sp = low+(high-low)/2;\\n        if(isPossible(piles,sp,h)==true){\\n            speed = sp;\\n            high = sp-1;\\n        }else{\\n            low = sp+1;\\n        }\\n    }\\n      return speed;\\n    \\n    }public boolean isPossible(int[] piles,int sp,int h){\\n        int time=0;\\n        for(int i=0;i<piles.length;i++){\\n          time+=(int)Math.ceil((piles[i]*1.0)/sp);\\n        }\\n        return time<=h;\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080319,
                "title": "beats-98-easy-c-solution-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(vector<int>& p,int h,int n,int mid){\\n        int x=0;\\n        for(int i=0;i<n;i++){\\n            if(p[i]%mid==0){\\n                x+=(p[i]/mid);\\n            }\\n            else{\\n                x+=(p[i]/mid)+1;\\n            }\\n            if(x>h) return false;\\n        }\\n        return true;\\n    }\\n    int minEatingSpeed(vector<int>& p, int h) {\\n        sort(p.begin(),p.end());\\n        int low=1;\\n        int n=p.size();\\n        int high=p[n-1];\\n        int res=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            // int mid=(low+high)/2;\\n            if(f(p,h,n,mid)==true){\\n                res=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        // if(res==INT_MAX) return p[n-1];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(vector<int>& p,int h,int n,int mid){\\n        int x=0;\\n        for(int i=0;i<n;i++){\\n            if(p[i]%mid==0){\\n                x+=(p[i]/mid);\\n            }\\n            else{\\n                x+=(p[i]/mid)+1;\\n            }\\n            if(x>h) return false;\\n        }\\n        return true;\\n    }\\n    int minEatingSpeed(vector<int>& p, int h) {\\n        sort(p.begin(),p.end());\\n        int low=1;\\n        int n=p.size();\\n        int high=p[n-1];\\n        int res=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            // int mid=(low+high)/2;\\n            if(f(p,h,n,mid)==true){\\n                res=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        // if(res==INT_MAX) return p[n-1];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992575,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool count(vector<int>& piles, int h, int m)\\n    {\\n        int c=0;\\n        for(int i:piles)\\n        {\\n            c+=i/m;\\n            if(i%m==0)\\n            c++;\\n        }\\n        return c<=h;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l=1;\\n        int r=0;\\n        for(int i:piles)\\n        r=max(r, i);\\n        while(l<r)\\n        {\\n            int m=(l+r)/2;\\n            int c=0;\\n            for(int i:piles)\\n            {\\n                c+=i/m;\\n                if(i%m)\\n                c++;\\n            }\\n            if(c<=h)\\n            r=m;\\n            else\\n            l=m+1;\\n        }\\n        return l;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool count(vector<int>& piles, int h, int m)\\n    {\\n        int c=0;\\n        for(int i:piles)\\n        {\\n            c+=i/m;\\n            if(i%m==0)\\n            c++;\\n        }\\n        return c<=h;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l=1;\\n        int r=0;\\n        for(int i:piles)\\n        r=max(r, i);\\n        while(l<r)\\n        {\\n            int m=(l+r)/2;\\n            int c=0;\\n            for(int i:piles)\\n            {\\n                c+=i/m;\\n                if(i%m)\\n                c++;\\n            }\\n            if(c<=h)\\n            r=m;\\n            else\\n            l=m+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737692,
                "title": "why-do-you-fail-java-big-input",
                "content": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        \\n        int maxk = 0;\\n        for(int i : piles)\\n            maxk = Math.max(maxk, i);\\n        \\n        int res = maxk, l = 1, r = maxk;\\n        \\n        while(l <= r){\\n            \\n            int mid = l + (r - l) / 2;\\n            int hour = 0;\\n            for(int i : piles){\\n                //Careful here, when we want to get float number of integer devision and round it up\\n                //We need to cast it to float / double first\\n                //But for this problem , Float won\\'t work becasue it can have maximum 6-7 digits \\n\\t\\t\\t\\t//but the input is maximum 10^9 , so we need to use double here which can have maximum 15 digits\\n                \\n                hour += Math.ceil((double)i / mid );\\n            }\\n            \\n            if(hour <= h){\\n                r = mid - 1;\\n                res = Math.min(res, mid);\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        \\n        int maxk = 0;\\n        for(int i : piles)\\n            maxk = Math.max(maxk, i);\\n        \\n        int res = maxk, l = 1, r = maxk;\\n        \\n        while(l <= r){\\n            \\n            int mid = l + (r - l) / 2;\\n            int hour = 0;\\n            for(int i : piles){\\n                //Careful here, when we want to get float number of integer devision and round it up\\n                //We need to cast it to float / double first\\n                //But for this problem , Float won\\'t work becasue it can have maximum 6-7 digits \\n\\t\\t\\t\\t//but the input is maximum 10^9 , so we need to use double here which can have maximum 15 digits\\n                \\n                hour += Math.ceil((double)i / mid );\\n            }\\n            \\n            if(hour <= h){\\n                r = mid - 1;\\n                res = Math.min(res, mid);\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738653,
                "title": "why-binary-search-intiution-explained-java",
                "content": "Notice one thing , h (hours of returning of guard) will always be >= length of array.\\n### Why is it so?\\nBecause if h is less than length of array (i.e number of piles) than all banana of every piles can\\'t be eaten. Hence h must be >= arr.length.\\n\\nNow if the h == arr.length , then minimum banana eating speed must be max element of array.\\nWhy is it so?\\nLet\\'s understand it with an example --------\\npiles[] = [2,4,8,12,6]  h = 5\\n\\nhere the minimum banana eating speed must be 12 because only with that speed all piles can be finised within h hours\\n\\n\\nNow case comes when h is greater than piles.length\\n\\nNotice , minimum banana eating speed is 1 banana per hour and maximum banana eating speed is Max Element of pile\\'s banana per hour\\n\\nSo we can observe that banana eating speed lies in range of 1 to Max Element of piles\\n#### HENCE WE CAN APPLY BINARY SERACH ON banana eating speed\\n\\nnow we have start =1 and end = MAX ELELEMNT \\nwe\\'ll calculate mid and that will be our potential banana eating speed\\n\\nCASE 1:\\nif with mid as our banana eating speed , all piles can be finised within h hours , then store this mid ans our answer and reduce end to mid -1 , as we will check with further low mid values (because we have to find minimum speed possible)\\n\\n\\n\\nCASE 2:\\nif with mid as our banana eating speed , all piles can\\'t be finised within h hours , then increase start to mid+1, as we have to increase our banana eating speed in order to finish the piles\\n\\n\\n\\n```\\n/*\\nNotice one thing , h (hours of returning of guard) will always be >= length of array.\\nWhy is it so?\\nBecause if h is less than length of array (i.e number of piles) than all banana of every piles can\\'t be eaten. Hence h must be >= arr.length.\\n\\nNow if the h == arr.length , then minimum banana eating speed must be max element of array.\\nWhy is it so?\\nLet\\'s understand it with an example --------\\npiles[] = [2,4,8,12,6]  h = 5\\n\\nhere the minimum banana eating speed must be 12 because only with that speed all piles can be finised within h hours\\n\\n\\nNow case comes when h is greater than piles.length\\n\\nNotice , minimum banana eating speed is 1 banana per hour and maximum banana eating speed is Max Element of pile\\'s banana per hour\\n\\nSo we can observe that banana eating speed lies in range of 1 to Max Element of piles\\nHENCE WE CAN APPLY BINARY SERACH ON banana eating speed\\n\\nnow we have start =1 and end = MAX ELELEMNT \\nwe\\'ll calculate mid and that will be our potential banana eating speed\\n\\nCASE 1:\\nif with mid as our banana eating speed , all piles can be finised within h hours , then store this mid ans our answer and reduce end to mid -1 , as we will check with further low mid values (because we have to find minimum speed possible)\\n\\n\\n\\nCASE 2:\\nif with mid as our banana eating speed , all piles can\\'t be finised within h hours , then increase start to mid+1, as we have to increase our banana eating speed in order to finish the piles\\n\\n\\n\\n\\n\\n*/\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        \\n        int max =0;\\n        for(int banana : piles)\\n        {\\n            max = Math.max(max,banana);\\n        }\\n        if(h == piles.length)\\n            return max;\\n        \\n        int bananaEatingSpeed = BinarySearch(piles, 1 , max, h);\\n        return bananaEatingSpeed;\\n    }\\n    public int BinarySearch(int[] arr, int s, int e, int maxHours)     \\n    {\\n        int speed = Integer.MAX_VALUE;\\n        \\n        \\n        while(s<=e)\\n        {\\n          \\n            int m = s + (e-s)/2;  \\n            long timeTaken =0; \\n            \\n            /*\\n            Calculating the total time taken in finishing the piles with banana eating speed as \\'m\\'\\n            */\\n            for(int i : arr)\\n            {   \\n                if(m !=0)\\n                {\\n                timeTaken = timeTaken + (int)Math.ceil(i*1.0/m);  // we have to take ceil because of this statement-- If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour. \\n                }    \\n            }\\n            \\n            \\n            if(timeTaken > maxHours)\\n            {\\n                s = m+1;\\n            }\\n            else //if(timeTaken <= maxHours)\\n            {   if(m > 0)\\n                {speed = Math.min(speed, m);}       // Storing the minimum banana eating speed\\n                e = m-1;\\n            }\\n        }\\n        return speed;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        \\n        int max =0;\\n        for(int banana : piles)\\n        {\\n            max = Math.max(max,banana);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1705664,
                "title": "c-with-integer-ceil-trick",
                "content": "Many of the answers posted use the ```ceil``` library function to round up.  However, depending on the floating point representation and the inputs, you could end up with the wrong answer.  I instead use an integer rounding trick I learned from programming in CUDA.  Basically, if you want to calculate ```ceil(x/y)```, where ```x``` and ```y``` are integers, and you want an integer result, you can simply write ```(x + y - 1)/y```.  The intuition is that ```/``` is integer division: you divide `x` by `y` and follow that operation by an integer ```floor``` operation.  Thus, 3 / 2 =  (int)floor(1.5) = 1, but we want a result of 2.  With the alternate equation, (3 + 2 - 1) / 2 = (int) floor(4/2) = 2, which is what we want.  If you do a quick check with other values, you\\'ll see that the identity holds.\\n\\n\\n```\\ninline int hours_to_eat(vector<int>& piles, int eating_rate){\\n        int hours = 0;\\n        for(int p: piles){\\n\\t\\t    // Integer ceiling operation\\n            hours += (p + eating_rate - 1) / eating_rate;\\n        }\\n        return hours;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int lo = 1;\\n        int hi = 1000000000;\\n        int min_eating_speed = INT_MAX;\\n        while(lo <= hi){\\n            int k = hi - (hi - lo) / 2;\\n            int hours = hours_to_eat(piles, k);\\n            if(hours <= h){\\n                min_eating_speed = std::min<int>(k, min_eating_speed);\\n                hi = k - 1;\\n            }\\n            else{\\n                lo = k + 1;\\n            }\\n        }\\n        return min_eating_speed;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```ceil```\n```ceil(x/y)```\n```x```\n```y```\n```(x + y - 1)/y```\n```/```\n```floor```\n```\\ninline int hours_to_eat(vector<int>& piles, int eating_rate){\\n        int hours = 0;\\n        for(int p: piles){\\n\\t\\t    // Integer ceiling operation\\n            hours += (p + eating_rate - 1) / eating_rate;\\n        }\\n        return hours;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int lo = 1;\\n        int hi = 1000000000;\\n        int min_eating_speed = INT_MAX;\\n        while(lo <= hi){\\n            int k = hi - (hi - lo) / 2;\\n            int hours = hours_to_eat(piles, k);\\n            if(hours <= h){\\n                min_eating_speed = std::min<int>(k, min_eating_speed);\\n                hi = k - 1;\\n            }\\n            else{\\n                lo = k + 1;\\n            }\\n        }\\n        return min_eating_speed;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1704648,
                "title": "binary-search-solution",
                "content": "We are supposed to find the minimum speed which can satisfy our problem.\\nSo, brute force approach is to linear check every speed starting from 1 and incrementing, where we return answer whenever we get the speed that satisfies our condition.\\nBut Time-complexity of such a linear method can go anywhere in the range of the input i.e. 10^9, so it is not feasible.\\n\\n**Binary Search Approach :**\\nInstead of linearly searching for values, we can convert it to a binary search approach.\\n\\nWe perform our search on the full range of possible numbers,\\nso let\\'s assume our lower bound is at 1 and our upper bound at 10^18 (Maximum value of Long long type).\\n\\nSince we\\'re performing binary search on a constant range, so it comes down to almost constant time, as log(10^18) is around 63.\\nBut, we also traverse our array everytime so time complexity is constant X (N) === N (Linear)\\n\\n**Binary Search**\\nIf with our current value of mid, it is possible to complete the task under \"h\" hours, then we consider that for any value>mid, it is also possible, as we are focused on minimum, we simply neglect the upper range, and shift our high pointer to mid value, and try to search an yet smaller value, if possible.\\nIf our current value of mid, can\\'t fulfill the condition then we search for a higher value by shifting low pointer to mid+1.\\n\\nWhen our low pointer equals our high, we finally reach our target and we can return either of high or low as our answer.\\n\\n**The possible() method**\\nThe possible method simply traverses the array and calculates the hours for the given mid value, if it falls under our maximum alloted time, it returns true , else false.\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    bool possible(ll m, vector<int> p, ll h){\\n        ll c=0;\\n        for(auto i:p){\\n            c+= ceil(i/(double)m);\\n        }\\n        if(c<=h)return true;\\n        return false;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        //binary search\\n        ll lo=1;\\n        ll hi=1e18;\\n        while(lo<hi){\\n            ll m= lo+(hi-lo)/2;\\n            if(possible(m,piles,h)){\\n                hi=m;\\n            }\\n            else{\\n                lo=m+1;\\n            }\\n        }\\n        return lo;//or hi\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    bool possible(ll m, vector<int> p, ll h){\\n        ll c=0;\\n        for(auto i:p){\\n            c+= ceil(i/(double)m);\\n        }\\n        if(c<=h)return true;\\n        return false;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        //binary search\\n        ll lo=1;\\n        ll hi=1e18;\\n        while(lo<hi){\\n            ll m= lo+(hi-lo)/2;\\n            if(possible(m,piles,h)){\\n                hi=m;\\n            }\\n            else{\\n                lo=m+1;\\n            }\\n        }\\n        return lo;//or hi\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548610,
                "title": "c-easy-code-binary-search",
                "content": "class Solution {\\npublic:\\n    \\n    bool isvalid(vector<int> a,int h,int mid){\\n        int n=a.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]%mid!=0){\\n                sum++;\\n            }\\n            sum+=a[i]/mid;\\n        }\\n        if(sum<=h){\\n            return true;\\n        }\\n        return false;\\n    } \\n        \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=1;\\n        int high=1e9;\\n        int ans=-1;\\n        while(low<=high){\\n            int mid=low+((high-low))/2;\\n            if(isvalid(piles,h,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    bool isvalid(vector<int> a,int h,int mid){\\n        int n=a.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]%mid!=0){\\n                sum++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1484486,
                "title": "binary-search-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef minEatingSpeed(self, piles: List[int], h: int) -> int:\\n\\n\\n\\t\\t\\tdef feasible(speed):\\n\\n\\t\\t\\t\\treturn sum((pile-1) //speed+1 for pile in piles) <= h  # faster\\n\\n\\n\\t\\t\\t\\t#hour=1\\n\\t\\t\\t\\t#s=0\\n\\t\\t\\t\\t#for pile in piles:\\n\\t\\t\\t\\t\\t#s+=pile\\n\\t\\t\\t\\t\\t#if s>speed:\\n\\t\\t\\t\\t\\t\\t#s=pile\\n\\t\\t\\t\\t\\t\\t#if hour>h:\\n\\t\\t\\t\\t\\t\\t\\t#return False\\n\\t\\t\\t\\t#return True\\n\\n\\n\\t\\t\\tleft, right = 1, max(piles)\\n\\n\\t\\t\\twhile left < right:\\n\\t\\t\\t\\tmid = left  + (right - left) // 2\\n\\t\\t\\t\\tif feasible(mid):\\n\\t\\t\\t\\t\\tright = mid\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tleft = mid + 1\\n\\t\\t\\treturn left",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef minEatingSpeed(self, piles: List[int], h: int) -> int:\\n\\n\\n\\t\\t\\tdef feasible(speed):\\n\\n\\t\\t\\t\\treturn sum((pile-1) //speed+1 for pile in piles) <= h  # faster\\n\\n\\n\\t\\t\\t\\t#hour=1\\n\\t\\t\\t\\t#s=0\\n\\t\\t\\t\\t#for pile in piles:\\n\\t\\t\\t\\t\\t#s+=pile\\n\\t\\t\\t\\t\\t#if s>speed:\\n\\t\\t\\t\\t\\t\\t#s=pile\\n\\t\\t\\t\\t\\t\\t#if hour>h:\\n\\t\\t\\t\\t\\t\\t\\t#return False\\n\\t\\t\\t\\t#return True\\n\\n\\n\\t\\t\\tleft, right = 1, max(piles)\\n\\n\\t\\t\\twhile left < right:\\n\\t\\t\\t\\tmid = left  + (right - left) // 2\\n\\t\\t\\t\\tif feasible(mid):\\n\\t\\t\\t\\t\\tright = mid\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tleft = mid + 1\\n\\t\\t\\treturn left",
                "codeTag": "Java"
            },
            {
                "id": 1475435,
                "title": "simple-c-solution-using-binary-search-concept",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>a, int k, int mid)\\n    {\\n        int n=a.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]%mid!=0)\\n                sum++;\\n            sum+=a[i]/mid;\\n        }\\n        if(sum<=k)\\n                return true;\\n        return false;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n=piles.size();\\n        int low=1;\\n        int high=1e9;\\n        int ans=-1;\\n        while(low<=high)\\n        {\\n            int mid=low+((high-low)>>1);\\n            if(isValid(piles,h,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\tPlease consider upvoting.",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>a, int k, int mid)\\n    {\\n        int n=a.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]%mid!=0)\\n                sum++;\\n            sum+=a[i]/mid;\\n        }\\n        if(sum<=k)\\n                return true;\\n        return false;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n=piles.size();\\n        int low=1;\\n        int high=1e9;\\n        int ans=-1;\\n        while(low<=high)\\n        {\\n            int mid=low+((high-low)>>1);\\n            if(isValid(piles,h,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450414,
                "title": "binary-search-on-answer-time-94-c",
                "content": "```\\nint minEatingSpeed(vector<int>& piles, int h) {\\n        \\n        auto check=[&](int x){                                         //check wether the choosen answer is valid or not\\n            int count=0;\\n            for(auto &i:piles)\\n                count+=i%x==0?i/x:i/x+1;\\n            return count<=h;\\n        };\\n    \\n        int l=1,r=*max_element(piles.begin(),piles.end());   //answer must be lies in between l ans r\\n        while(l<r) {\\n            int mid= l+(r-l)/2;\\n            if(check(mid))\\n                r=mid;\\n            else l=mid+1;\\n        }\\n        return l;\\n    }",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nint minEatingSpeed(vector<int>& piles, int h) {\\n        \\n        auto check=[&](int x){                                         //check wether the choosen answer is valid or not\\n            int count=0;\\n            for(auto &i:piles)\\n                count+=i%x==0?i/x:i/x+1;\\n            return count<=h;\\n        };\\n    \\n        int l=1,r=*max_element(piles.begin(),piles.end());   //answer must be lies in between l ans r\\n        while(l<r) {\\n            int mid= l+(r-l)/2;\\n            if(check(mid))\\n                r=mid;\\n            else l=mid+1;\\n        }\\n        return l;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1297064,
                "title": "java-explanation-for-dumbs-like-me",
                "content": "[3,6,7,11] \\n    done in 4 hours at k = 11\\n    at k = 10, done in 5h\\n    at k = 9, done in 5h\\n    at k = 8, done in 5h\\n    at k = 7, done in 5h\\n    at k = 6, done in 6h\\n    at k = 5, done in 8h\\n    at k = 4, done in 8h\\n    at k = 3, done in 10h (1+2+3+4)\\n    at k = 2, done in 15h (2+3+4+6)\\n    at k = 1, done in 15h (3+6+7+11)\\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10,11] -->Possible Values Of K! (speed cannot be less than 1)\\n    [F, F, F,T,T, T,T, T, T, T,  T]\\n    first true is the minimum speed required for koko to eat the bananas\\n\\t\\n```\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max = 0;  \\n        for(int n : piles){\\n            max = Math.max(max, n);\\n        }\\n        // assumed right to be max, because at this speed the maximum time taken will be atleast the length of the array.\\n        int left = 1 ; int right = max;\\n        while(left < right){\\n            int mid = left + (right-left)/2 ;\\n            if(property(mid,piles,h)){\\n                right = mid;  // this may be the answer or a better ans is on the left side\\n            }else{\\n                left = mid +1; // is not the answer so go to right. \\n            }\\n        }\\n        //left == right so return anything.\\n        return left;\\n    }\\n    public boolean property(int speed, int[] piles, int maxTime){\\n        int timeTaken = 0;\\n        for (int n : piles){\\n            timeTaken += (int)Math.ceil(((double)n/speed));\\n        }\\n        return timeTaken <= maxTime ;\\n    }\\n}\\n\\n```\\n\\n```\\ntime O(N * log(MaxValueOfPiles))   // look at the possible values of k if confuesd.\\nSpace O(1)\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max = 0;  \\n        for(int n : piles){\\n            max = Math.max(max, n);\\n        }\\n        // assumed right to be max, because at this speed the maximum time taken will be atleast the length of the array.\\n        int left = 1 ; int right = max;\\n        while(left < right){\\n            int mid = left + (right-left)/2 ;\\n            if(property(mid,piles,h)){\\n                right = mid;  // this may be the answer or a better ans is on the left side\\n            }else{\\n                left = mid +1; // is not the answer so go to right. \\n            }\\n        }\\n        //left == right so return anything.\\n        return left;\\n    }\\n    public boolean property(int speed, int[] piles, int maxTime){\\n        int timeTaken = 0;\\n        for (int n : piles){\\n            timeTaken += (int)Math.ceil(((double)n/speed));\\n        }\\n        return timeTaken <= maxTime ;\\n    }\\n}\\n\\n```\n```\\ntime O(N * log(MaxValueOfPiles))   // look at the possible values of k if confuesd.\\nSpace O(1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261133,
                "title": "c-simple-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool possible(int mid, vector<int>& piles, int h)\\n    {\\n        int ans = 0;\\n        for(auto p : piles)\\n            ans += ceil(p*1.0/mid);\\n        \\n        return ans <= h;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        \\n        if(piles.size()==1)\\n            return ceil(piles[0]*1.0/h);\\n        \\n        int low = 0, high = *max_element(piles.begin(), piles.end());\\n        int ans = INT_MAX;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            \\n            if(possible(mid, piles, h))\\n            {\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possible(int mid, vector<int>& piles, int h)\\n    {\\n        int ans = 0;\\n        for(auto p : piles)\\n            ans += ceil(p*1.0/mid);\\n        \\n        return ans <= h;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        \\n        if(piles.size()==1)\\n            return ceil(piles[0]*1.0/h);\\n        \\n        int low = 0, high = *max_element(piles.begin(), piles.end());\\n        int ans = INT_MAX;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            \\n            if(possible(mid, piles, h))\\n            {\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966298,
                "title": "python3",
                "content": "```\\ndef minEatingSpeed(self, piles: List[int], H: int) -> int:\\n        def geth(p,s):\\n            return sum(math.ceil(x/s) for x in p)    \\n        i,j=0,max(piles)\\n        while i<j:\\n            mid=i+(j-i)//2\\n            if geth(piles,mid)<=H:\\n                j=mid\\n            else:\\n                i=mid+1\\n        return i\\n```",
                "solutionTags": [],
                "code": "```\\ndef minEatingSpeed(self, piles: List[int], H: int) -> int:\\n        def geth(p,s):\\n            return sum(math.ceil(x/s) for x in p)    \\n        i,j=0,max(piles)\\n        while i<j:\\n            mid=i+(j-i)//2\\n            if geth(piles,mid)<=H:\\n                j=mid\\n            else:\\n                i=mid+1\\n        return i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 683042,
                "title": "java-binary-search",
                "content": "class Solution {\\n\\n    public int minEatingSpeed(int[] piles, int H) {\\n     \\n        int left = 1, right = Arrays.stream(piles).max().getAsInt();\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (canEatBananas(piles, mid, H)) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n    \\n    private boolean canEatBananas(int[] piles, int k, int H) {\\n        \\n        int hours = 0;\\n        for (int pile : piles) {\\n            hours += pile / k;\\n            if (pile % k != 0) {\\n                ++hours;\\n            }\\n        }\\n        return hours <= H; \\n    }\\n}\\n\\n// Time complexity - O(Nlog(M)); where M - Max difference between int values in the list & N number of elements in the list",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int minEatingSpeed(int[] piles, int H) {\\n     \\n        int left = 1, right = Arrays.stream(piles).max().getAsInt();\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (canEatBananas(piles, mid, H)) {\\n                right = mid - 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 413063,
                "title": "binary-search-to-find-hours-required",
                "content": "```csharp\\npublic class Solution \\n{\\n    public int MinEatingSpeed(int[] piles, int H)\\n    {        \\n        int low = 1, high = piles.Max();\\n        int mid;\\n\\n        while (low < high)\\n        {\\n            mid = low + (high - low) / 2;\\n            int hours = 0;\\n            \\n            foreach (int pile in piles)\\n            {\\n                hours += 1 + (pile- 1) / mid;\\n            }\\n\\n            if (hours <= H)\\n            {\\n                high = mid;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution \\n{\\n    public int MinEatingSpeed(int[] piles, int H)\\n    {        \\n        int low = 1, high = piles.Max();\\n        int mid;\\n\\n        while (low < high)\\n        {\\n            mid = low + (high - low) / 2;\\n            int hours = 0;\\n            \\n            foreach (int pile in piles)\\n            {\\n                hours += 1 + (pile- 1) / mid;\\n            }\\n\\n            if (hours <= H)\\n            {\\n                high = mid;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152355,
                "title": "python-simple-optimization",
                "content": "```python\\nclass Solution(object):\\n    def minEatingSpeed(self, piles, H):\\n        res, pilest = float(\\'inf\\'), 0\\n        for i in piles: pilest+=i \\n        K = int(pilest/H)  # Optimization : K can not be lesser than this\\n        if K == 0: K = 1\\n        while res > H:\\n            res = 0\\n            for i in piles:\\n                res += math.ceil((i*1.0)/K)\\n            K+=1\\n        return K-1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def minEatingSpeed(self, piles, H):\\n        res, pilest = float(\\'inf\\'), 0\\n        for i in piles: pilest+=i \\n        K = int(pilest/H)  # Optimization : K can not be lesser than this\\n        if K == 0: K = 1\\n        while res > H:\\n            res = 0\\n            for i in piles:\\n                res += math.ceil((i*1.0)/K)\\n            K+=1\\n        return K-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040879,
                "title": "koko-eating-bananas-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n=piles.size();\\n        int l=1;\\n        double sum;\\n        int ans;\\n        int r=INT_MIN;\\n        for(int i=0;i<n;i++)\\n            r=max(r,piles[i]);\\n        while(l<=r)\\n        {\\n            sum=0;\\n            int mid=l+(r-l)/2;\\n            for(int i=0;i<n;i++)\\n                sum+=ceil((double)piles[i]/mid);\\n\\n            if(sum<=h)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n=piles.size();\\n        int l=1;\\n        double sum;\\n        int ans;\\n        int r=INT_MIN;\\n        for(int i=0;i<n;i++)\\n            r=max(r,piles[i]);\\n        while(l<=r)\\n        {\\n            sum=0;\\n            int mid=l+(r-l)/2;\\n            for(int i=0;i<n;i++)\\n                sum+=ceil((double)piles[i]/mid);\\n\\n            if(sum<=h)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022247,
                "title": "binary-search-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* It took me a while to realize on what should I do the searching. \\n* After analyzing the problem and writing it down on a white paper, I found out that my search space is in the range from [1 : maximum number of bananas in all piles]\\n* so I thought about applying binary search. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* I have found some base cases:\\n    1. if the given number of hours was equal to the number of piles:\\n        * Then we must eat each pile in only one hour, so we have to eat with a speed equals to the maximum number of bananas in a pile per hour. \\n    2. if the number of piles was equal to 1\\n        * Then we must finish that pile before the gaurds come back, so the allowed time is ceil( the number of bananas in this pile / the given duration).\\n        * and do not forget to apply casting to long double, because int / int will give you int not float nor double. \\n* Then the basic logic will be simple binary search logic.\\n* we have three pointers\\n    1. bgn = 1 initially.\\n    2. end = the maximum number of bananas in the list.\\n    3. mid = (bgn + end) / 2 -> and the integer division will apply the floor logic by default. \\n* Then we should loop while the end pointer is larger than the bgn pointer:\\n    - if mid is a valid k -> we will discuss its logic later.\\n        - then assign the minimum number of hours = mid\\n        - then lets check if we can eat all bananas in less hours, so ,move the end pointer to the mid position.\\n        - Update the mid position using the same equation \\n        - mid = (bgn + end) / 2\\n    - else we need to just look for a larger number of bananas per hour, so we will move the bgn pointer to the mid position + **1**\\n    - Then update the mid position using the same logic\\n    - mid = (bgn + end) /2\\n* Then as a final check if mid < max_element and mid >= 0\\n* do another check, and if mid < minimum number of banans per hour, update it.\\n* and finally return that minimum number.      \\n\\n## Valid Function (piles, k, h)\\n* This is a function which check wethere we can eat all the bananas in the given k hours or the gaurds will catch us. \\n* so we just define a sum variable and initialize it with 0\\n* and iterate over all piles.\\n* and divide the number of bananas in this pile by the given k\\n* and do not forget to cast it to double, to avoid wrong calculations.\\n* then finaly if the sum of hours was greater than the hours after which the gaurds will come back  then we just return false, otherwise this is a valid number of hours.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n* O(n log m) as:\\n    - valid function takes O(n) as we iterate over the all piles.\\n    - O(lg m) because we apply binary search on the space of the m [1 : m]\\n    - n is the number of piles, m is the maximum number of bananas.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n* O(n) as I do not use any extra space. \\n# Code\\n```\\nclass Solution {\\npublic:\\n   #define DPSolver ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\\n#define DPSolver ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\\nusing ll = long long;\\nusing ld = long double;\\n\\nbool valid(const vector<int> &piles, const int k, const int h)\\n{\\n    int sum = 0;\\n    for (auto pile : piles)\\n        sum += ceil(pile / (ld)k);\\n    return sum <= h;\\n}\\n\\nint minEatingSpeed(vector<int> &piles, int h)\\n{\\n    DPSolver; \\n    // int sz = piles.size();\\n    // if (sz == h)\\n    //     return *max_element(piles.begin(), piles.end());\\n    // else if (sz == 1)\\n    //     return ceil((ld)piles[0] / h);\\n    // int mx_element = *max_element(piles.begin(), piles.end());\\n    int mx_element = INT_MAX; \\n    int bgn = 1;\\n    ll end = mx_element;\\n    ll md = (bgn + end) / 2;\\n    int mn = INT_MAX; \\n    while (end > bgn)\\n        if (valid(piles, md, h))\\n        {\\n            if(md < mn)\\n                mn = md; \\n            end = md;\\n            md = (bgn + end) / 2;\\n        }\\n        else\\n        {\\n            bgn = md + 1;\\n            md = (bgn + end) / 2;\\n        }\\n\\n    if (md >= 0 && md <= mx_element)\\n        if (valid(piles, md, h))\\n            if(md < mn)\\n                mn = md; \\n\\n    return mn;\\n}\\n\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   #define DPSolver ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\\n#define DPSolver ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\\nusing ll = long long;\\nusing ld = long double;\\n\\nbool valid(const vector<int> &piles, const int k, const int h)\\n{\\n    int sum = 0;\\n    for (auto pile : piles)\\n        sum += ceil(pile / (ld)k);\\n    return sum <= h;\\n}\\n\\nint minEatingSpeed(vector<int> &piles, int h)\\n{\\n    DPSolver; \\n    // int sz = piles.size();\\n    // if (sz == h)\\n    //     return *max_element(piles.begin(), piles.end());\\n    // else if (sz == 1)\\n    //     return ceil((ld)piles[0] / h);\\n    // int mx_element = *max_element(piles.begin(), piles.end());\\n    int mx_element = INT_MAX; \\n    int bgn = 1;\\n    ll end = mx_element;\\n    ll md = (bgn + end) / 2;\\n    int mn = INT_MAX; \\n    while (end > bgn)\\n        if (valid(piles, md, h))\\n        {\\n            if(md < mn)\\n                mn = md; \\n            end = md;\\n            md = (bgn + end) / 2;\\n        }\\n        else\\n        {\\n            bgn = md + 1;\\n            md = (bgn + end) / 2;\\n        }\\n\\n    if (md >= 0 && md <= mx_element)\\n        if (valid(piles, md, h))\\n            if(md < mn)\\n                mn = md; \\n\\n    return mn;\\n}\\n\\n\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3953546,
                "title": "easy-to-understand-clear-code-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(Nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // Helper function which returns the number of hours required to consume the piles for given K\\n    int hoursRequired(const vector<int> &piles, int k)\\n    {\\n        int h = 0;\\n        if(k == 0) return INT_MAX;\\n        for(int i : piles)\\n        {\\n            if(i % k != 0)\\n            {\\n                h++;\\n            }\\n            h += (i / k);\\n        }\\n        return h;\\n    }\\n    \\npublic:\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        long long sum = 0;\\n        int mx = 0;\\n        for(int i = 0; i < piles.size(); i++)\\n        {\\n            sum += piles[i];\\n            mx = max(mx, piles[i]);\\n        }\\n        int l = sum / H, r = mx, ans;\\n        while(l < r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            int ans = hoursRequired(piles, mid);\\n\\t\\t\\t// If hours required is greater than our limit, ignore mid\\n            if(ans > H)\\n            {\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                r = mid;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    // Helper function which returns the number of hours required to consume the piles for given K\\n    int hoursRequired(const vector<int> &piles, int k)\\n    {\\n        int h = 0;\\n        if(k == 0) return INT_MAX;\\n        for(int i : piles)\\n        {\\n            if(i % k != 0)\\n            {\\n                h++;\\n            }\\n            h += (i / k);\\n        }\\n        return h;\\n    }\\n    \\npublic:\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        long long sum = 0;\\n        int mx = 0;\\n        for(int i = 0; i < piles.size(); i++)\\n        {\\n            sum += piles[i];\\n            mx = max(mx, piles[i]);\\n        }\\n        int l = sum / H, r = mx, ans;\\n        while(l < r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            int ans = hoursRequired(piles, mid);\\n\\t\\t\\t// If hours required is greater than our limit, ignore mid\\n            if(ans > H)\\n            {\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                r = mid;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931313,
                "title": "simple-c-solution",
                "content": "# Linearly Traversing\\nApplying a Linear traversal on all the possible solutions\\n```\\nclass Solution {\\npublic:\\n    int maxOfArray(vector<int> &piles){\\n        int maxElement=INT_MIN;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]>maxElement){\\n                maxElement=piles[i];\\n            }\\n        }\\n        return maxElement;\\n    }\\n    long long timeTaken(vector<int> &piles,int k){\\n        long long totalTimeRequired=0;\\n        for(int i=0;i<piles.size();i++){\\n            totalTimeRequired+=ceil((double)piles[i]/(double)k);\\n        }\\n        return totalTimeRequired;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int maxPerHour=maxOfArray(piles);\\n        for(int i=1;i<=maxPerHour;i++){\\n            long long timeRequired=timeTaken(piles,i);\\n            if(timeRequired<=h){\\n                return i;\\n            }\\n        }\\n        return maxPerHour;\\n    }\\n};\\n```\\n# Binary Search\\nFor this approach to reduce the time taken to linearly iterate over all possible answers we can apply binary serach on the possible answers.\\n```\\nclass Solution {\\npublic:\\n    int maxOfArray(vector<int> &piles){\\n        int maxElement=INT_MIN;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]>maxElement){\\n                maxElement=piles[i];\\n            }\\n        }\\n        return maxElement;\\n    }\\n    long long timeTaken(vector<int> &piles,int k){\\n        long long totalTimeRequired=0;\\n        for(int i=0;i<piles.size();i++){\\n            totalTimeRequired+=ceil((double)piles[i]/(double)k);\\n        }\\n        return totalTimeRequired;\\n    }\\n    int minEatingSpeed(vector<int> &piles,int h){\\n        int low=1,high=maxOfArray(piles);\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(timeTaken(piles,mid)<=h){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOfArray(vector<int> &piles){\\n        int maxElement=INT_MIN;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]>maxElement){\\n                maxElement=piles[i];\\n            }\\n        }\\n        return maxElement;\\n    }\\n    long long timeTaken(vector<int> &piles,int k){\\n        long long totalTimeRequired=0;\\n        for(int i=0;i<piles.size();i++){\\n            totalTimeRequired+=ceil((double)piles[i]/(double)k);\\n        }\\n        return totalTimeRequired;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int maxPerHour=maxOfArray(piles);\\n        for(int i=1;i<=maxPerHour;i++){\\n            long long timeRequired=timeTaken(piles,i);\\n            if(timeRequired<=h){\\n                return i;\\n            }\\n        }\\n        return maxPerHour;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxOfArray(vector<int> &piles){\\n        int maxElement=INT_MIN;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]>maxElement){\\n                maxElement=piles[i];\\n            }\\n        }\\n        return maxElement;\\n    }\\n    long long timeTaken(vector<int> &piles,int k){\\n        long long totalTimeRequired=0;\\n        for(int i=0;i<piles.size();i++){\\n            totalTimeRequired+=ceil((double)piles[i]/(double)k);\\n        }\\n        return totalTimeRequired;\\n    }\\n    int minEatingSpeed(vector<int> &piles,int h){\\n        int low=1,high=maxOfArray(piles);\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(timeTaken(piles,mid)<=h){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921543,
                "title": "using-binary-search-easy-c-solution-self-explanatory-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long count_banana(vector<int> &v,int num)\\n{\\n    long long sum=0;\\n    for(int i=0;i<v.size();i++)\\n    {\\n        sum+=ceil(v[i]/(double)num);\\n    }\\n    return sum;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n       int low=1;\\n       int high=*max_element(piles.begin(),piles.end());\\n       while(low<=high)\\n       {\\n           int mid=(low+high)/2;\\n           if(count_banana(piles,mid)<=h)\\n           {\\n               high=mid-1;\\n           }\\n           else{\\n               low=mid+1;\\n           }\\n       } \\n       return low;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long count_banana(vector<int> &v,int num)\\n{\\n    long long sum=0;\\n    for(int i=0;i<v.size();i++)\\n    {\\n        sum+=ceil(v[i]/(double)num);\\n    }\\n    return sum;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n       int low=1;\\n       int high=*max_element(piles.begin(),piles.end());\\n       while(low<=high)\\n       {\\n           int mid=(low+high)/2;\\n           if(count_banana(piles,mid)<=h)\\n           {\\n               high=mid-1;\\n           }\\n           else{\\n               low=mid+1;\\n           }\\n       } \\n       return low;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909246,
                "title": "clear-c-solution-with-comments-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N log M), where N is the count of the piles, M is the maximum eating speed which is maximum pile height\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // the main idea is to search among all possible speed of eating\\n    int minEatingSpeed(vector<int>& piles, int h) \\n    {\\n        int left = 1; // minimum speed is 1 banana per hour\\n        int right = getMax(piles); // maximum speed is the amount of bananas in the biggest pile\\n        \\n        // using binary search to find the minimum speed of all possible Koko\\'s eating speed values\\n        while (left <= right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            long hoursRequired = calculateHours(piles, mid);\\n\\n            // if Koko eats faster than required or as required, than we should look among lower speed values\\n            // there might be a value of speed that satisfies the conditions better (the minimal speed)\\n            if (hoursRequired <= h)\\n            {\\n                right = mid - 1;\\n            }\\n            // if Koko eats slower than required, than we should look among higher speed values\\n            else\\n            {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return left;\\n    }\\n\\n    // calculating required hours amount for eating speed from parameter\\n    long calculateHours(vector<int>& piles, int speed)\\n    {\\n        long spentHours = 0;\\n        for (int i = 0; i < piles.size(); i++)\\n        {\\n            spentHours += piles[i] / speed;\\n            if (piles[i] % speed != 0)\\n            {\\n                spentHours++;\\n            }\\n        }\\n        return spentHours;\\n    }\\n\\n    int getMax(vector<int> piles)\\n    {\\n        int maxPile = 0;\\n        for(int i = 0; i < piles.size(); i++)\\n        {\\n            maxPile = max(piles[i], maxPile);\\n        }\\n\\n        return maxPile;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // the main idea is to search among all possible speed of eating\\n    int minEatingSpeed(vector<int>& piles, int h) \\n    {\\n        int left = 1; // minimum speed is 1 banana per hour\\n        int right = getMax(piles); // maximum speed is the amount of bananas in the biggest pile\\n        \\n        // using binary search to find the minimum speed of all possible Koko\\'s eating speed values\\n        while (left <= right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            long hoursRequired = calculateHours(piles, mid);\\n\\n            // if Koko eats faster than required or as required, than we should look among lower speed values\\n            // there might be a value of speed that satisfies the conditions better (the minimal speed)\\n            if (hoursRequired <= h)\\n            {\\n                right = mid - 1;\\n            }\\n            // if Koko eats slower than required, than we should look among higher speed values\\n            else\\n            {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return left;\\n    }\\n\\n    // calculating required hours amount for eating speed from parameter\\n    long calculateHours(vector<int>& piles, int speed)\\n    {\\n        long spentHours = 0;\\n        for (int i = 0; i < piles.size(); i++)\\n        {\\n            spentHours += piles[i] / speed;\\n            if (piles[i] % speed != 0)\\n            {\\n                spentHours++;\\n            }\\n        }\\n        return spentHours;\\n    }\\n\\n    int getMax(vector<int> piles)\\n    {\\n        int maxPile = 0;\\n        for(int i = 0; i < piles.size(); i++)\\n        {\\n            maxPile = max(piles[i], maxPile);\\n        }\\n\\n        return maxPile;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887223,
                "title": "simple-and-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findmaxi(vector<int>& piles){\\n        int maxi = INT_MIN;\\n        for(int i = 0;i<piles.size();i++){\\n            maxi = max(maxi,piles[i]);\\n        }\\n        return maxi;\\n    }\\n\\n    double calaculateTotalHours(vector<int>& piles,int hourly){\\n        double totalh = 0;\\n        for(int i = 0;i<piles.size();i++){\\n            totalh += ceil((double)piles[i]/(double)hourly);\\n        }\\n        return totalh;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low = 0, high = findmaxi(piles);\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n            double totalH = calaculateTotalHours(piles,mid);\\n            if(totalH <= h){\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findmaxi(vector<int>& piles){\\n        int maxi = INT_MIN;\\n        for(int i = 0;i<piles.size();i++){\\n            maxi = max(maxi,piles[i]);\\n        }\\n        return maxi;\\n    }\\n\\n    double calaculateTotalHours(vector<int>& piles,int hourly){\\n        double totalh = 0;\\n        for(int i = 0;i<piles.size();i++){\\n            totalh += ceil((double)piles[i]/(double)hourly);\\n        }\\n        return totalh;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low = 0, high = findmaxi(piles);\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n            double totalH = calaculateTotalHours(piles,mid);\\n            if(totalH <= h){\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834236,
                "title": "simple-easy-binary-search",
                "content": "\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    n = max of array\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` c++ [0]\\nclass Solution {\\npublic:\\n    long long getHoursToEatAll(vector<int>&piles, int bananasPerHour)\\n    {\\n        long long totalHours = 0;\\n        for (int i = 0; i < piles.size(); i++)\\n        {\\n            int hoursToEatPile = ceil(piles[i] / (double)bananasPerHour);\\n            totalHours += hoursToEatPile;\\n        }\\n        return totalHours;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int targetHours)\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int low = 1, high = *(max_element(piles.begin(), piles.end()));\\n        int ans = -1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            long long hoursToEatAll = getHoursToEatAll(piles, mid);\\n            \\n            if (hoursToEatAll <= targetHours)\\n            {\\n                ans = mid; //record the answer (this is the best we could record till curr step)\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n``` Python [0]\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        if len(piles) == h:\\n            return max(piles)\\n        \\n        left, right = 1, max(piles)\\n\\n        ans = -1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if sum([ceil(i/mid) for i in piles]) > h:\\n                left = mid + 1\\n            else:\\n                ans = mid\\n                right = mid - 1\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "``` c++ [0]\\nclass Solution {\\npublic:\\n    long long getHoursToEatAll(vector<int>&piles, int bananasPerHour)\\n    {\\n        long long totalHours = 0;\\n        for (int i = 0; i < piles.size(); i++)\\n        {\\n            int hoursToEatPile = ceil(piles[i] / (double)bananasPerHour);\\n            totalHours += hoursToEatPile;\\n        }\\n        return totalHours;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int targetHours)\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int low = 1, high = *(max_element(piles.begin(), piles.end()));\\n        int ans = -1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            long long hoursToEatAll = getHoursToEatAll(piles, mid);\\n            \\n            if (hoursToEatAll <= targetHours)\\n            {\\n                ans = mid; //record the answer (this is the best we could record till curr step)\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n``` Python [0]\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        if len(piles) == h:\\n            return max(piles)\\n        \\n        left, right = 1, max(piles)\\n\\n        ans = -1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if sum([ceil(i/mid) for i in piles]) > h:\\n                left = mid + 1\\n            else:\\n                ans = mid\\n                right = mid - 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746885,
                "title": "python-binary-search",
                "content": "# Code\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        right, left = max(piles), 1\\n        while left < right:\\n            middle = (left + right) // 2\\n            count = 0\\n            for each in piles:\\n                count += ceil(each / middle)\\n            if count > h:\\n                left = middle + 1\\n            else:\\n                right = middle\\n        return left\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        right, left = max(piles), 1\\n        while left < right:\\n            middle = (left + right) // 2\\n            count = 0\\n            for each in piles:\\n                count += ceil(each / middle)\\n            if count > h:\\n                left = middle + 1\\n            else:\\n                right = middle\\n        return left\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691381,
                "title": "easy-python-solution-using-binary-search-beginners-friendly",
                "content": "# Code\\n```\\nimport math\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        a = 1\\n        b=max(piles)\\n        while a<b:\\n            mid=(a+b)//2\\n            c=0\\n            for j in piles:\\n                c+=math.ceil(j/mid)\\n            if c>h:\\n                a=mid+1\\n            else:\\n                b=mid\\n        return a\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        a = 1\\n        b=max(piles)\\n        while a<b:\\n            mid=(a+b)//2\\n            c=0\\n            for j in piles:\\n                c+=math.ceil(j/mid)\\n            if c>h:\\n                a=mid+1\\n            else:\\n                b=mid\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683961,
                "title": "python3-c-brute-force-optimal-full-explanation",
                "content": "### Koko Eating Bananas\\n\\nReturn *the minimum integer* `k` *such that she can eat all the bananas within* `h` *hours*.\\n\\n**Example 1:**\\n\\nInput: piles = [3,6,7,11], h = 8\\nOutput: 4\\n\\n**Example 2:**\\n\\nInput: piles = [30,11,23,4,20], h = 5\\nOutput: 30\\n\\n**Example 3:**\\n\\nInput: piles = [30,11,23,4,20], h = 6\\nOutput: 23\\n\\n- Approach\\n    - Brute-force\\n        - Minimum time will be taken when koko eats `max(piles)` bananas each hour and total hours taken will be `len(piles)` hours and maximum time will be taken when koko eats 1 banana per hour\\n        - Thus for every number in range `1` to `max(piles)`, we calculate hours taken and if it is < h, then return it\\n        - Time Complexity: $O(n * max(piles))$\\n        - Space Complexity: $O(1)$\\n    - Optimal\\n        - Binary Search between 1 and max(piles)\\n        - Time Complexity: $O(n * log(max(piles)))$\\n        - Space Complexity: $O(1)$\\n\\n```python\\n# Python3\\n# Brute-force Solution\\nfrom math import ceil\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        for i in range(1, max(piles) + 1):\\n            hrs = 0\\n            for j in range(len(piles)):\\n                hrs += ceil(piles[j] / i)\\n            if hrs <= h:\\n                return i\\n        return -1\\n```\\n\\n```python\\n# Python3\\n# Optimal Solution\\nfrom math import ceil\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        l = 1\\n        r = max(piles)\\n        \\n        while l <= r:\\n            mid = (l + r) // 2\\n            s = 0\\n            for i in piles:\\n                s += ceil(i / mid)\\n            if s <= h:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return l\\n```\\n\\n```cpp\\n// C++\\n// Optimal Solution\\n#include <bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int find_max(vector<int>& piles) {\\n        int maxi = piles[0];\\n        for (int i = 1; i < piles.size(); i++) {\\n            maxi = max(maxi, piles[i]);\\n        }\\n        return maxi;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l = 1, r = find_max(piles);\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            long long hrs = 0;\\n            for (int i = 0; i < piles.size(); i++) {\\n                hrs += ceil(double(piles[i]) / double(mid));\\n            }\\n            if (hrs <= h) {\\n                r = mid - 1;\\n            }\\n            else {\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```python\\n# Python3\\n# Brute-force Solution\\nfrom math import ceil\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        for i in range(1, max(piles) + 1):\\n            hrs = 0\\n            for j in range(len(piles)):\\n                hrs += ceil(piles[j] / i)\\n            if hrs <= h:\\n                return i\\n        return -1\\n```\n```python\\n# Python3\\n# Optimal Solution\\nfrom math import ceil\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        l = 1\\n        r = max(piles)\\n        \\n        while l <= r:\\n            mid = (l + r) // 2\\n            s = 0\\n            for i in piles:\\n                s += ceil(i / mid)\\n            if s <= h:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return l\\n```\n```cpp\\n// C++\\n// Optimal Solution\\n#include <bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int find_max(vector<int>& piles) {\\n        int maxi = piles[0];\\n        for (int i = 1; i < piles.size(); i++) {\\n            maxi = max(maxi, piles[i]);\\n        }\\n        return maxi;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l = 1, r = find_max(piles);\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            long long hrs = 0;\\n            for (int i = 0; i < piles.size(); i++) {\\n                hrs += ceil(double(piles[i]) / double(mid));\\n            }\\n            if (hrs <= h) {\\n                r = mid - 1;\\n            }\\n            else {\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3643392,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code aims to find the minimum eating speed required to eat all the piles of bananas within a given number of hours. Each pile has a certain number of bananas, and the eating speed represents the number of bananas that can be eaten per hour.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a binary search approach to find the minimum eating speed. It starts by initializing the variables low and high. low is set to 1, representing the minimum possible eating speed, while high is set to the maximum value among all the piles, representing the maximum possible eating speed.\\n\\nThe binary search is performed within the range of low to high. In each iteration, it calculates the mid-point k using the formula low + (high - low) / 2, which ensures that the mid-point is always rounded down. The mid-point represents the current eating speed to be tested.\\n\\nFor each eating speed k, the code calculates the number of hours required to eat all the piles by iterating through each pile and accumulating the hours using the formula hours += ceil((double)piles[i] / k). The ceil function is used to ensure that even if the division results in a fractional value, it is rounded up to the next integer.\\n\\nIf the calculated hours (hours) are less than or equal to the given number of hours (h), it means that the eating speed is sufficient to eat all the piles within the given time constraint. In this case, the code updates the result variable with the minimum of the current result and k to keep track of the minimum eating speed found so far. Then, it updates high to k - 1 to search for even smaller eating speeds in the next iteration.\\n\\nIf the calculated hours are greater than h, it means that the eating speed is too slow to eat all the piles within the given time constraint. In this case, the code updates low to k + 1 to search for larger eating speeds in the next iteration.\\n\\nThe binary search continues until low becomes greater than high, indicating that the search space has been exhausted.\\n\\nFinally, the minimum eating speed (result) is returned as the result.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code performs a binary search on the range of possible eating speeds, which has a logarithmic time complexity of O(log(high - low)). Within each iteration, it calculates the number of hours required, which involves iterating through each pile once. Thus, the overall time complexity is O(n log m), where n is the number of piles and m is the maximum value among all the piles.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1), as the code only uses a constant amount of extra space for the variables n, low, high, result, hours, and k. The space usage does not depend on the input size.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n= piles.size();\\n        int low=1;\\n        int high=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            high=max(high,piles[i]);\\n        }\\n        int result= high;\\n        while(low<=high){\\n            long int hours=0;\\n            int k= low+ (high-low)/2;\\n            for(int i=0;i<n;i++)\\n            {\\n                hours+=ceil((double)piles[i]/k);\\n            }\\n            if(hours<=h)\\n            {\\n                result=min(result,k);\\n                high=k-1;\\n            }\\n            else\\n            low=k+1;\\n\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n= piles.size();\\n        int low=1;\\n        int high=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            high=max(high,piles[i]);\\n        }\\n        int result= high;\\n        while(low<=high){\\n            long int hours=0;\\n            int k= low+ (high-low)/2;\\n            for(int i=0;i<n;i++)\\n            {\\n                hours+=ceil((double)piles[i]/k);\\n            }\\n            if(hours<=h)\\n            {\\n                result=min(result,k);\\n                high=k-1;\\n            }\\n            else\\n            low=k+1;\\n\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621532,
                "title": "c-easy-to-understand-binary-search-clean-code",
                "content": "# Intuition\\nApply Binary search on the possible values of K which lies from 1 to maximum element of the array to search the minimum value of K.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(h))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n=piles.size();\\n        int l=1;\\n        double sum;\\n        int ans;\\n        int r=INT_MIN;\\n        for(int i=0;i<n;i++)\\n            r=max(r,piles[i]);\\n        while(l<=r)\\n        {\\n            sum=0;\\n            int mid=l+(r-l)/2;\\n            for(int i=0;i<n;i++)\\n                sum+=ceil((double)piles[i]/mid);\\n\\n            if(sum<=h)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n=piles.size();\\n        int l=1;\\n        double sum;\\n        int ans;\\n        int r=INT_MIN;\\n        for(int i=0;i<n;i++)\\n            r=max(r,piles[i]);\\n        while(l<=r)\\n        {\\n            sum=0;\\n            int mid=l+(r-l)/2;\\n            for(int i=0;i<n;i++)\\n                sum+=ceil((double)piles[i]/mid);\\n\\n            if(sum<=h)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607103,
                "title": "binary-search-python-readable-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        def check(x):\\n            return sum(ceil(ele/x) for ele in piles) <= h\\n\\n        l = 1\\n        r = max(piles)\\n        while l < r:\\n            mid = (l+r) >> 1\\n            if not check(mid):\\n                l=mid+1\\n            else:\\n                r=mid\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        def check(x):\\n            return sum(ceil(ele/x) for ele in piles) <= h\\n\\n        l = 1\\n        r = max(piles)\\n        while l < r:\\n            mid = (l+r) >> 1\\n            if not check(mid):\\n                l=mid+1\\n            else:\\n                r=mid\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503832,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        \\n        int leftPtr = 1;\\n        int rightPtr = 0;\\n        int answer = 0;\\n\\n        for(const int& pile : piles)\\n        {\\n            rightPtr = std::max(rightPtr, pile);\\n        }\\n        while(leftPtr <= rightPtr)\\n        {\\n            double mid = leftPtr + (rightPtr - leftPtr) / 2;\\n            long long hoursToEatBananas = 0;\\n            for(const int& pile : piles)\\n            {\\n                hoursToEatBananas += static_cast<int>(std::ceil(pile / mid));\\n            }\\n            if(hoursToEatBananas <= h)\\n            {\\n                rightPtr = mid - 1;\\n                answer = mid;\\n            }\\n            else\\n            {\\n                leftPtr = mid + 1;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        Sum = sum(piles)\\n        l = ceil(Sum/h)\\n        r = ceil(Sum/(h-len(piles)+1))\\n        while l<r:\\n            m = (l+r)//2\\n            t = 0\\n            for pile in piles:\\n                t+=ceil(pile/m)\\n            if t>h:\\n                l=m+1\\n            else:\\n                r=m\\n        return l\\n```\\n\\n```Java []\\nclass Solution {\\n\\tpublic boolean findHour(int[] piles, int h, int k) {\\n\\t\\tint v = k - 1;\\n\\t\\tfor (int p : piles) {\\n\\t\\t\\th -= (int)((p + v) / (double)k);\\n\\t\\t\\tif (h < 0) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\tpublic int minEatingSpeed(int[] piles, int h) {\\n\\t\\tint n = piles.length;\\n\\t\\tlong sum = 0;\\n\\t\\tfor (int p : piles) {\\n\\t\\t\\tsum += p;\\n\\t\\t}\\n\\t\\tint left = (int)(sum / h);\\n\\t\\tint right = (int)(sum / (h - n + 1));\\n\\t\\tint middle = 0;\\n\\n\\t\\twhile (left <= right) {\\n\\t\\t\\tmiddle = left + right >>> 1;\\n\\t\\t\\tif (findHour(piles, h, middle)) {\\n\\t\\t\\t\\tright = middle - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tleft = middle + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn left;\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        \\n        int leftPtr = 1;\\n        int rightPtr = 0;\\n        int answer = 0;\\n\\n        for(const int& pile : piles)\\n        {\\n            rightPtr = std::max(rightPtr, pile);\\n        }\\n        while(leftPtr <= rightPtr)\\n        {\\n            double mid = leftPtr + (rightPtr - leftPtr) / 2;\\n            long long hoursToEatBananas = 0;\\n            for(const int& pile : piles)\\n            {\\n                hoursToEatBananas += static_cast<int>(std::ceil(pile / mid));\\n            }\\n            if(hoursToEatBananas <= h)\\n            {\\n                rightPtr = mid - 1;\\n                answer = mid;\\n            }\\n            else\\n            {\\n                leftPtr = mid + 1;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        Sum = sum(piles)\\n        l = ceil(Sum/h)\\n        r = ceil(Sum/(h-len(piles)+1))\\n        while l<r:\\n            m = (l+r)//2\\n            t = 0\\n            for pile in piles:\\n                t+=ceil(pile/m)\\n            if t>h:\\n                l=m+1\\n            else:\\n                r=m\\n        return l\\n```\n```Java []\\nclass Solution {\\n\\tpublic boolean findHour(int[] piles, int h, int k) {\\n\\t\\tint v = k - 1;\\n\\t\\tfor (int p : piles) {\\n\\t\\t\\th -= (int)((p + v) / (double)k);\\n\\t\\t\\tif (h < 0) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\tpublic int minEatingSpeed(int[] piles, int h) {\\n\\t\\tint n = piles.length;\\n\\t\\tlong sum = 0;\\n\\t\\tfor (int p : piles) {\\n\\t\\t\\tsum += p;\\n\\t\\t}\\n\\t\\tint left = (int)(sum / h);\\n\\t\\tint right = (int)(sum / (h - n + 1));\\n\\t\\tint middle = 0;\\n\\n\\t\\twhile (left <= right) {\\n\\t\\t\\tmiddle = left + right >>> 1;\\n\\t\\t\\tif (findHour(piles, h, middle)) {\\n\\t\\t\\t\\tright = middle - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tleft = middle + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn left;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283789,
                "title": "java-clean-code-solution-using-binary-search",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(Nlog(N))\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] arr, int h) {\\n       \\n        int end=-1;\\n        int fin=0;\\n        for(int i=0;i<arr.length;i++){\\n            end=end>arr[i]?end:arr[i];\\n        }\\n        int start=0;\\n        int ans=start+(end-start)/2;\\n        while(start<=end){\\n            ans=start+(end-start)/2;\\n            if(!check(arr,h,ans)){\\n                start=ans+1;\\n            }\\n            else{\\n                fin=ans;\\n                end=ans-1;\\n            }\\n        }\\n        return fin;\\n    }\\n    static boolean check(int []arr,int h,int ans){\\n        double sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=Math.ceil((double)arr[i]/(double)ans);\\n        \\n        if(sum>h){\\n            return false;\\n        }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] arr, int h) {\\n       \\n        int end=-1;\\n        int fin=0;\\n        for(int i=0;i<arr.length;i++){\\n            end=end>arr[i]?end:arr[i];\\n        }\\n        int start=0;\\n        int ans=start+(end-start)/2;\\n        while(start<=end){\\n            ans=start+(end-start)/2;\\n            if(!check(arr,h,ans)){\\n                start=ans+1;\\n            }\\n            else{\\n                fin=ans;\\n                end=ans-1;\\n            }\\n        }\\n        return fin;\\n    }\\n    static boolean check(int []arr,int h,int ans){\\n        double sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=Math.ceil((double)arr[i]/(double)ans);\\n        \\n        if(sum>h){\\n            return false;\\n        }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279721,
                "title": "optimized-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int st=1;\\n        int end=1000000000;\\n        int mid;\\n\\n        while(st<=end){\\n            mid=st+(end-st)/2;\\n            if(kokoEatsAll(piles,h,mid)) end=mid-1;\\n            else st=mid+1;\\n        }\\n        return st;\\n    }\\n    public boolean kokoEatsAll(int[] piles, int h, int k){\\n        int sum=0;\\n   \\n        for(int pile:piles){\\n            sum+=pile/k;\\n\\n            if(pile%k!=0) sum++;\\n            if(sum>h) return false;\\n\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int st=1;\\n        int end=1000000000;\\n        int mid;\\n\\n        while(st<=end){\\n            mid=st+(end-st)/2;\\n            if(kokoEatsAll(piles,h,mid)) end=mid-1;\\n            else st=mid+1;\\n        }\\n        return st;\\n    }\\n    public boolean kokoEatsAll(int[] piles, int h, int k){\\n        int sum=0;\\n   \\n        for(int pile:piles){\\n            sum+=pile/k;\\n\\n            if(pile%k!=0) sum++;\\n            if(sum>h) return false;\\n\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273879,
                "title": "easy-c-solution-beat-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int s=1,e=1000000000,mid=0,tot;\\n        while(s<e){\\n            mid=s+(e-s)/2;\\n            tot=0;\\n            for(auto p:piles)\\n                tot+=(p+mid-1)/mid;\\n     \\n            if(tot>h)\\n            s=mid+1;\\n            else \\n            e=mid;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int s=1,e=1000000000,mid=0,tot;\\n        while(s<e){\\n            mid=s+(e-s)/2;\\n            tot=0;\\n            for(auto p:piles)\\n                tot+=(p+mid-1)/mid;\\n     \\n            if(tot>h)\\n            s=mid+1;\\n            else \\n            e=mid;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273690,
                "title": "python3-very-easy-solution-uwu",
                "content": "\\n```\\nclass Solution(object):\\n    def minEatingSpeed(self, piles, h):\\n        lo, hi = 1, max(piles)\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if sum((p-1) // mid + 1 for p in piles) > h:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        \\n        return lo\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def minEatingSpeed(self, piles, h):\\n        lo, hi = 1, max(piles)\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if sum((p-1) // mid + 1 for p in piles) > h:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        \\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273300,
                "title": "c-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBinary search on minimum and maximum possible banana to be eaten\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(max_element(array)))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int start=1;\\n        int end=*max_element(piles.begin(),piles.end());\\n        int ans=INT_MAX;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            int flag=0;\\n            long long hrs=0;\\n            for(int i=0;i<piles.size();i++){\\n                hrs+=ceil(piles[i]*1.0/mid*1.0);\\n                if(hrs>h){\\n                    start=mid+1;\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(!flag){\\n                end=mid-1;\\n                ans=min(mid,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int start=1;\\n        int end=*max_element(piles.begin(),piles.end());\\n        int ans=INT_MAX;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            int flag=0;\\n            long long hrs=0;\\n            for(int i=0;i<piles.size();i++){\\n                hrs+=ceil(piles[i]*1.0/mid*1.0);\\n                if(hrs>h){\\n                    start=mid+1;\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(!flag){\\n                end=mid-1;\\n                ans=min(mid,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273198,
                "title": "c-binary-search-beginner-friendly-faster-than-98-85-with-special-trick",
                "content": "# Approach\\nThe major optimization is the maximum value of high will not be more than maximum value in the piles array. This improves the speed by a larger extent.\\n\\nTrick:\\n`high=*max_element(piles.begin(),piles.end());`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int chk(vector<int>& piles, int mid) {\\n        int tot=0;\\n        for(auto x:piles) {\\n            tot+=ceil(1.0*x/mid);\\n        }    \\n        return tot;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int low=1,high=*max_element(piles.begin(),piles.end());\\n        while(low<high) {\\n            int mid=low+(high-low)/2;              \\n            if(chk(piles,mid)>h)\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int chk(vector<int>& piles, int mid) {\\n        int tot=0;\\n        for(auto x:piles) {\\n            tot+=ceil(1.0*x/mid);\\n        }    \\n        return tot;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int low=1,high=*max_element(piles.begin(),piles.end());\\n        while(low<high) {\\n            int mid=low+(high-low)/2;              \\n            if(chk(piles,mid)>h)\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273136,
                "title": "kotlin-binary-search-easy-concise-solution-explanation",
                "content": "# Intuition\\n   The naive approach is trying to iterate over eating speed starting from 1 till we got the number of hours when guards are back. The calculation of the number of hours we need to spend with some eating speed `k` is a sum of hours for every pile `val hoursToEat = piles.map { (it - 1) / k + 1 }.sum()` which has $$O(N)$$ time complexity, where N is number of piles. Hence, overall complexity will be `quadratic`. The trick with calculation of next up integer (`(it - 1) / mid + 1`) is well described [here](https://stackoverflow.com/questions/19689128/how-to-round-up-to-the-next-integer/19689196#19689196)\\n   So, how can we reduce time complexity?\\n   The initial thinking process was to reduce the number of times to calculate `hoursToEat`. We can approach it with binary search, hence complexity will be logarithmic. The main idea is to get some maximum top value (`right`) of eating speed `k` and try to calculate the number of hours to eat with this speed. If it\\'s bigger than `h`(amount of hours when guards are back) it means we need to increase eating speed to decrease the number of hours. If it\\'s not bigger than `h`, hence we need to decrease the number of hours by decreasing eating speed to achieve the `minimum` possible value of eating speed.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- specify `left` and `right` variables for binary search which would stand for eating speed which we are about to find\\n- use binary search and calculate the number of hours for the `mid` value which is needed for eating all bananas\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(NLogM)$$ where `N` is the size of piles and `M` is the largest value in piles;\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\n    fun minEatingSpeed(piles: IntArray, h: Int): Int {\\n        var left = 1\\n        var right = piles.max()!!\\n        while (left < right) {\\n            val mid = left + (right - left) / 2\\n            val hoursToEat = piles.map { (it - 1) / mid + 1 }.sum()\\n            if (hoursToEat > h) left = mid + 1 else right = mid\\n        }\\n        return left      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    fun minEatingSpeed(piles: IntArray, h: Int): Int {\\n        var left = 1\\n        var right = piles.max()!!\\n        while (left < right) {\\n            val mid = left + (right - left) / 2\\n            val hoursToEat = piles.map { (it - 1) / mid + 1 }.sum()\\n            if (hoursToEat > h) left = mid + 1 else right = mid\\n        }\\n        return left      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272888,
                "title": "rust-c-short-sweet",
                "content": "```Rust []\\nimpl Solution {\\n    pub fn min_eating_speed(piles: Vec<i32>, h: i32) -> i32 {\\n        let (mut i, mut j) : (i32, i32) = (1,  *piles.iter().max().unwrap());\\n        // small optimization : just take max from Vec if Vec.len() == h \\n        if piles.len() == h as usize {return j};\\n        while(i < j){\\n            let mid = i + ((j - i) / 2);\\n            if piles.iter().fold(0, |temp_h, &el| temp_h + (((el as f64) / mid as f64).ceil() as i32)) > h {\\n                i = mid + 1;  \\n            } else { j = mid; }\\n        }\\n        i\\n    }\\n}\\n```\\n\\n```C++ []\\nclass Solution {\\nprivate:\\n    int sz;\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        sz = piles.size(); \\n        int j = *max_element(piles.begin(), piles.end());\\n        // small optimization : just take max from vector if vector.size() == h \\n        if(sz == h) return j;\\n        int i = 1;\\n        while(i < j){\\n            int temp_h = 0;\\n            int mid = i + ((j - i) / 2);\\n            for(int k = 0; k < sz; ++k)\\n                temp_h += ceil((double)piles[k] / mid);\\n            \\n            if (temp_h > h) i = mid + 1;\\n            else j = mid;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Rust",
                    "Binary Search"
                ],
                "code": "```Rust []\\nimpl Solution {\\n    pub fn min_eating_speed(piles: Vec<i32>, h: i32) -> i32 {\\n        let (mut i, mut j) : (i32, i32) = (1,  *piles.iter().max().unwrap());\\n        // small optimization : just take max from Vec if Vec.len() == h \\n        if piles.len() == h as usize {return j};\\n        while(i < j){\\n            let mid = i + ((j - i) / 2);\\n            if piles.iter().fold(0, |temp_h, &el| temp_h + (((el as f64) / mid as f64).ceil() as i32)) > h {\\n                i = mid + 1;  \\n            } else { j = mid; }\\n        }\\n        i\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\nprivate:\\n    int sz;\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        sz = piles.size(); \\n        int j = *max_element(piles.begin(), piles.end());\\n        // small optimization : just take max from vector if vector.size() == h \\n        if(sz == h) return j;\\n        int i = 1;\\n        while(i < j){\\n            int temp_h = 0;\\n            int mid = i + ((j - i) / 2);\\n            for(int k = 0; k < sz; ++k)\\n                temp_h += ceil((double)piles[k] / mid);\\n            \\n            if (temp_h > h) i = mid + 1;\\n            else j = mid;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272872,
                "title": "binary-search-same-as-minimum-time-to-complete-trips-problem",
                "content": "**Intuition**\\nLooking at the problem, it can be deduced that the minimum speed at which Koko can eat bananas is 1 and the maximum speed is the maximum number of bananas available in the pile.\\nNow, we have a range of values in which our answer lies. To solve this kind of problem, we can use Binary search.\\nWe can search in the range 1 to maximum speed and update the range according to whether the mid value is enough to eat all bananas or not.\\n![image](https://assets.leetcode.com/users/images/553c7a66-7db7-4805-948f-14f202a8a2ed_1678288717.158244.png)\\n\\n**Example**\\npiles=[4,6,9,7,11] and h= 13\\n=> k can be: 1,2,3,4,5,6,7,8,9,10,11\\n\\nfor binary search the range will be minspeed=1 and maxspeed=11\\n\\n1.\\tmid = (1+11)/2 =5\\n\\t\\t\\tnow for 5 bananas/hour speed. the total number of hours it\\'d take to finish all bananas:\\n```\\n4, 6, 9, 7, 11 \\n1  2  2  2   3  = 10 \\n\\nas 10<13 that means our answer lies in between range minspeed to mid i.e 1 to 5.\\nHence, maxspeed=5\\n```\\n2.mid= (1+5)/2=3\\n\\n\\t4, 6, 9, 7, 11\\n\\t2  2  3  3   4  = 14 \\n\\n\\tas 14>13 hence range would be mid+1 to maxpeed. i.e minspeed=4\\n\\n3.mid=(4+5)/2=4.\\n\\n\\t4, 6, 9, 7, 11\\n\\t1  2  3  2   3  = 11\\n\\tas 11<13, range would become minspeed to mid i.e maxpeed=4.\\n\\tAs minspeed=maxspeed now.\\n\\tHence 4 is the minimum speed \\n\\n```\\nPLEASE upvote if you like my solution . it motivates me lot \\n```\\n![image](https://assets.leetcode.com/users/images/1863510a-6f9c-4c49-9081-bbc71a642a14_1678289092.5429008.png)\\n\\n**Code:**\\n```\\n// Same as \"Minimum time to complete Trips\" Problem\\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int start = 1;\\n        int end = INT_MAX;\\n        int ans = 0;\\n        \\n        while(start <= end) {\\n            int mid = start + (end-start)/2;\\n            int currSpeed = mid;                            // speed to eat\\n            \\n            int hours = 0;\\n            for(int i=0; i < piles.size(); i++) {\\n                \\n                // If currSpeed is divisible by number then Number of hours are easy to find,\\n                // else, One more hour is required to eat that pile.\\n                if(piles[i] % currSpeed == 0)   hours += piles[i]/currSpeed;\\n                else                            hours += (piles[i]/currSpeed) + 1;\\n            }\\n            \\n            // If this speed to eat is enough to eat all, then find minimum speed again.\\n            if(hours <= h) {\\n                end = mid-1;\\n                ans = mid;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\n        Time complexity: O(nlog(m)), where n=number of piles, m= range of k\\n        Space complexity: O(1)\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n4, 6, 9, 7, 11 \\n1  2  2  2   3  = 10 \\n\\nas 10<13 that means our answer lies in between range minspeed to mid i.e 1 to 5.\\nHence, maxspeed=5\\n```\n```\\nPLEASE upvote if you like my solution . it motivates me lot \\n```\n```\\n// Same as \"Minimum time to complete Trips\" Problem\\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int start = 1;\\n        int end = INT_MAX;\\n        int ans = 0;\\n        \\n        while(start <= end) {\\n            int mid = start + (end-start)/2;\\n            int currSpeed = mid;                            // speed to eat\\n            \\n            int hours = 0;\\n            for(int i=0; i < piles.size(); i++) {\\n                \\n                // If currSpeed is divisible by number then Number of hours are easy to find,\\n                // else, One more hour is required to eat that pile.\\n                if(piles[i] % currSpeed == 0)   hours += piles[i]/currSpeed;\\n                else                            hours += (piles[i]/currSpeed) + 1;\\n            }\\n            \\n            // If this speed to eat is enough to eat all, then find minimum speed again.\\n            if(hours <= h) {\\n                end = mid-1;\\n                ans = mid;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\n        Time complexity: O(nlog(m)), where n=number of piles, m= range of k\\n        Space complexity: O(1)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272683,
                "title": "java-simple-binary-search-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low = 1,high=0;\\n        for(int x : piles) high = Math.max(high,x);\\n\\n        while(low <= high){\\n            int mid = low +(high - low)/2;\\n            int time = checkTime(piles,mid);\\n\\n            if(time <= h) high = mid - 1;\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n\\n    private int checkTime(int[] arr, int mid){\\n        int time_takes = 0;\\n        for(int x : arr)\\n            time_takes += Math.ceil(x/(double)mid);\\n        return time_takes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low = 1,high=0;\\n        for(int x : piles) high = Math.max(high,x);\\n\\n        while(low <= high){\\n            int mid = low +(high - low)/2;\\n            int time = checkTime(piles,mid);\\n\\n            if(time <= h) high = mid - 1;\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n\\n    private int checkTime(int[] arr, int mid){\\n        int time_takes = 0;\\n        for(int x : arr)\\n            time_takes += Math.ceil(x/(double)mid);\\n        return time_takes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272615,
                "title": "banana-speed-eating-binary-search-for-optimal-eating-speed-a-fully-explained-approach-to-solution",
                "content": "# Intuition\\nWe can use binary search\\n\\n# Approach\\no solve this problem, we can use binary search to find the minimum integer k that satisfies the conditions. We can set the lower bound of the search to 1 (since we can\\'t eat 0 bananas per hour), and the upper bound to the maximum number of bananas in a pile (since we can\\'t eat more bananas than there are in a pile). Then, we can repeatedly calculate the total hours it would take to eat all the bananas at a given speed k, and adjust the lower or upper bound of the search based on whether the total hours is less than or greater than h, respectively.\\nIn this code, we use the ceil() function to round up the result of the division when calculating the total hours, since Koko can\\'t eat a fraction of a banana. Finally, we return the left bound of the search, which will be the minimum integer k that satisfies the conditions.\\n\\n# Complexity\\n- Time complexity:\\nO(n log m)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left = 1;\\n        int right = *max_element(piles.begin(), piles.end());\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            int total_hours = 0;\\n            for (int pile : piles) {\\n                total_hours += ceil((double)pile / mid);\\n            }\\n            if (total_hours > h) {\\n                left = mid + 1;\\n            }\\n             else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left = 1;\\n        int right = *max_element(piles.begin(), piles.end());\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            int total_hours = 0;\\n            for (int pile : piles) {\\n                total_hours += ceil((double)pile / mid);\\n            }\\n            if (total_hours > h) {\\n                left = mid + 1;\\n            }\\n             else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272444,
                "title": "c-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int hour) {\\n        int l = 1,h=*max_element(piles.begin(),piles.end());\\n        while(l<h){\\n            double m = (l+h)/2;\\n            int t= 0;\\n            for(auto x:piles) t+=ceil(x/m);\\n            if(t<=hour) h=m;\\n            else l=m+1;\\n        }\\n        return l;\\n    }\\n};\\n```\\n![Web capture_25-2-2023_224944_leetcode.com.jpeg](https://assets.leetcode.com/users/images/5c380cd2-8fa5-4c01-901e-7ab12968e501_1678281019.429373.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int hour) {\\n        int l = 1,h=*max_element(piles.begin(),piles.end());\\n        while(l<h){\\n            double m = (l+h)/2;\\n            int t= 0;\\n            for(auto x:piles) t+=ceil(x/m);\\n            if(t<=hour) h=m;\\n            else l=m+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271972,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Binary Search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N * logN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        ll l = 1, r = 1e9;\\n        while(l <= r) {\\n            ll tot = 0, mid = (l + r) / 2;\\n            for(int i=0; i<piles.size(); i++) tot += ceil(1.0 * piles[i] / mid);\\n            if(tot > h) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        ll l = 1, r = 1e9;\\n        while(l <= r) {\\n            ll tot = 0, mid = (l + r) / 2;\\n            for(int i=0; i<piles.size(); i++) tot += ceil(1.0 * piles[i] / mid);\\n            if(tot > h) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271937,
                "title": "875-koko-eating-bananas-java-solution",
                "content": "# Intuition\\nthis approach follows simple binary search and we need to find the minimum capacity to eat bananas in a hour to finish all the bananas in given hours.\\n\\n# Approach\\nhere the main thing we need to find is the lower and upper bound of the array or piles so that to apply binary search\\n\\n$$ Lower$$ $$ Bound :- $$\\nlower bound will be = total no. of bananas in all piles / given hours\\n(this is the lowest capacity to eat bananas to finish in time)\\n\\n$$ Upper $$ $$Bound :-$$\\nupper bound will be the largest pile present as if we eat that much banana in every hour we will require least number of time.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the minEatingSpeed method is $$ O(N $$ $$log M) $$, where n is the length of the piles array and m is the maximum pile size. The for loop that calculates the sum of all the elements in the piles array takes O(n) time. The binary search loop takes O(log m) time because the search space is divided in half in each iteration.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Request \\uD83D\\uDE4F\\uD83E\\uDD7A\\n\\n$$ PLEASE UPVOTE $$  (it takes efforts and time to write solution \\uD83D\\uDC95\\u2764\\uFE0F ) \\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int hours(int []piles, int f)\\n    {\\n        int t=0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            if(piles[i]<f)\\n            {\\n                t+=1;\\n            }\\n            else\\n            {\\n                t+=piles[i]/f;\\n                if(piles[i]%f>0)\\n                    t+=1;\\n            }\\n        }\\n        return t;\\n    }\\n    public int minEatingSpeed(int[] piles, int h) {\\n        if(piles.length==1)\\n        {\\n            if(piles[0]<h)\\n                return 1;\\n            else\\n            {\\n                int t= piles[0]/h;\\n                if(piles[0]%h>0)\\n                    return t+1;\\n                return t;\\n            }\\n        }\\n        long s1=0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            s1+=piles[i];\\n        }\\n        int s=(int)(s1/h);\\n        Arrays.sort(piles);\\n        int e = piles[piles.length-1];\\n\\n        //APPLYING BINARY SEARCH\\n\\n        while(s<e)\\n        {\\n            int mid = s+(e-s)/2;\\n            if(hours(piles,mid)>h)\\n            {\\n                s=mid+1;\\n            }\\n            else\\n            {\\n                e=mid;\\n            }\\n        }\\n\\n        return s;   \\n    }\\n}\\n```\\n# More EXplanation\\nThis Java code implements a solution to a problem that involves finding the minimum eating speed required for a person to eat all the bananas from a pile of piles within a given number of hours. The algorithm uses binary search to find the minimum eating speed.\\n\\nThe main function is minEatingSpeed, which takes an array piles representing the number of bananas in each pile and an integer h representing the maximum number of hours allowed to eat all the bananas.\\n\\nThe first part of the function deals with the special case where there is only one pile. If the number of bananas in the pile is less than the allowed hours, then the minimum eating speed required is 1. Otherwise, the minimum eating speed is the integer division of the number of bananas by the allowed hours, plus one if there are any leftover bananas.\\n\\nThe next part of the function computes the average number of bananas that need to be eaten per hour by dividing the total number of bananas by the allowed hours. The initial lower bound s for the minimum eating speed is set to this average. The upper bound e is set to the maximum number of bananas in a pile.\\nThe while loop uses binary search to find the minimum eating speed. At each iteration, the middle point between s and e is computed as mid. The function hours is called with piles and mid as arguments to determine how many hours it would take to eat all the bananas at that eating speed. If the result is greater than the allowed hours, the minimum eating speed must be increased, so the lower bound s is updated to mid+1. Otherwise, the maximum eating speed can be decreased, so the upper bound e is updated to mid.\\n\\nWhen the loop terminates, the value of s is the minimum eating speed required to eat all the bananas within the allowed time, so it is returned by the function",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int hours(int []piles, int f)\\n    {\\n        int t=0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            if(piles[i]<f)\\n            {\\n                t+=1;\\n            }\\n            else\\n            {\\n                t+=piles[i]/f;\\n                if(piles[i]%f>0)\\n                    t+=1;\\n            }\\n        }\\n        return t;\\n    }\\n    public int minEatingSpeed(int[] piles, int h) {\\n        if(piles.length==1)\\n        {\\n            if(piles[0]<h)\\n                return 1;\\n            else\\n            {\\n                int t= piles[0]/h;\\n                if(piles[0]%h>0)\\n                    return t+1;\\n                return t;\\n            }\\n        }\\n        long s1=0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            s1+=piles[i];\\n        }\\n        int s=(int)(s1/h);\\n        Arrays.sort(piles);\\n        int e = piles[piles.length-1];\\n\\n        //APPLYING BINARY SEARCH\\n\\n        while(s<e)\\n        {\\n            int mid = s+(e-s)/2;\\n            if(hours(piles,mid)>h)\\n            {\\n                s=mid+1;\\n            }\\n            else\\n            {\\n                e=mid;\\n            }\\n        }\\n\\n        return s;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271884,
                "title": "day-36-binary-search-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMinimum rate would be 1 if total banana=h and maximum rate would be equal to 1e9 when there is one pile with 1e9 bananas and h=1 hour. We can do a binary search in this range and check which minimum value satisfies the condition.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Note: \\nWe want floor value of hours taken to eat bananas as 1.5 hours for pile means 2 hours as we cannot start with next pile so it takes that full hour as well. Either take ceil(pile*1.0/mid) or the way I did in code to get the ceil value.\\n   > ***Please upvote if this was helpful. Happy coding!***\\n** and Happy Holi.\\uD83D\\uDE1C**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left=1,right=1e9;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            long long time=0;\\n            for(auto i:piles)time+=(i+mid-1)/mid;\\n            if(time>h)left=mid+1;\\n            else right=mid-1;\\n        }\\n        return left;\\n    }\\n};\\n```\\n\\n---\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left=1,right=1e9;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            long long time=0;\\n            for(auto i:piles)time+=(i+mid-1)/mid;\\n            if(time>h)left=mid+1;\\n            else right=mid-1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271862,
                "title": "koko-eating-bananas-c-easy-approach-fast-simple",
                "content": "**PLEASE UPVOTE, IF YOU LIKE,.\\u2764\\uFE0F\\u2764\\uFE0F **\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(vector<int>& p,int h,int n,int mid){\\n        int x=0;\\n        for(int i=0;i<n;i++){\\n            if(p[i]%mid==0){\\n                x+=(p[i]/mid);\\n            }\\n            else{\\n                x+=(p[i]/mid)+1;\\n            }\\n            if(x>h) return false;\\n        }\\n        return true;\\n    }\\n    int minEatingSpeed(vector<int>& p, int h) {\\n        sort(p.begin(),p.end());\\n        int low=1;\\n        int n=p.size();\\n        int high=p[n-1];\\n        int res=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            // int mid=(low+high)/2;\\n            if(f(p,h,n,mid)==true){\\n                res=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        // if(res==INT_MAX) return p[n-1];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(vector<int>& p,int h,int n,int mid){\\n        int x=0;\\n        for(int i=0;i<n;i++){\\n            if(p[i]%mid==0){\\n                x+=(p[i]/mid);\\n            }\\n            else{\\n                x+=(p[i]/mid)+1;\\n            }\\n            if(x>h) return false;\\n        }\\n        return true;\\n    }\\n    int minEatingSpeed(vector<int>& p, int h) {\\n        sort(p.begin(),p.end());\\n        int low=1;\\n        int n=p.size();\\n        int high=p[n-1];\\n        int res=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            // int mid=(low+high)/2;\\n            if(f(p,h,n,mid)==true){\\n                res=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        // if(res==INT_MAX) return p[n-1];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271831,
                "title": "binary-search",
                "content": "# Intuition & Approach\\nhttps://youtu.be/0Vu-cGHm3Hk\\n\\n# C++\\n```cpp\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int lo = 1, hi = maxPiles(piles), k = -1;\\n        while (lo <= hi) {\\n            int mid = lo + ((hi - lo) >> 1);\\n\\n            if (numOfHours(mid, piles) <= h) {\\n                k = mid;\\n                hi = mid - 1;\\n            }\\n            else\\n                lo = mid + 1;\\n        }\\n\\n        return k;\\n    }\\n\\n    long long numOfHours(int k, vector<int>& piles) {\\n        long long totalHours = 0;\\n\\n        for (int pile : piles)\\n            totalHours += (pile + k - 1) / k;\\n        \\n        return totalHours;\\n    }\\n\\n    int maxPiles(vector<int>& piles) {\\n        return *max_element(piles.begin(), piles.end());\\n    }\\n};\\n```\\n# Java\\n```java\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int lo = 1, hi = maxPiles(piles), k = -1;\\n        while (lo <= hi) {\\n            int mid = lo + ((hi - lo) >> 1);\\n\\n            if (numOfHours(mid, piles) <= h) {\\n                k = mid;\\n                hi = mid - 1;\\n            }\\n            else\\n                lo = mid + 1;\\n        }\\n\\n        return k;\\n    }\\n\\n    public long numOfHours(int k, int[] piles) {\\n        long totalHours = 0;\\n\\n        for (int pile : piles)\\n            totalHours += (pile + k - 1) / k;\\n        \\n        return totalHours;\\n    }\\n\\n    public int maxPiles(int[] piles) {\\n        int max = piles[0];\\n        for(int i=1;i<piles.length;i++){\\n            if(piles[i] > max){\\n                max = piles[i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n# Python\\n```py\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        lo, hi, k = 1, max(piles), -1\\n        \\n        while lo <= hi:\\n            mid = lo + ((hi - lo) >> 1)\\n\\n            if self.numOfHours(mid, piles) <= h:\\n                k = mid\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n\\n        return k\\n\\n    def numOfHours(self, k: int, piles: List[int]) -> int:\\n        totalHours = 0\\n        for pile in piles:\\n            totalHours += math.ceil(pile / k)\\n\\n        return totalHours\\n```\\n# JS\\n```js\\n/**\\n * @param {number[]} piles\\n * @param {number} h\\n * @return {number}\\n */\\nvar minEatingSpeed = function(piles, h) {\\n    let lo = 1, hi = Math.max(...piles), k = -1;\\n    \\n    while (lo <= hi) {\\n        const mid = lo + ((hi - lo) >> 1);\\n        const numOfHours = piles.reduce((total, pile) => total + Math.ceil(pile / mid), 0);\\n        \\n        if (numOfHours <= h) {\\n            k = mid;\\n            hi = mid - 1;\\n        }\\n        else {\\n            lo = mid + 1;\\n        }\\n    }\\n    \\n    return k;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int lo = 1, hi = maxPiles(piles), k = -1;\\n        while (lo <= hi) {\\n            int mid = lo + ((hi - lo) >> 1);\\n\\n            if (numOfHours(mid, piles) <= h) {\\n                k = mid;\\n                hi = mid - 1;\\n            }\\n            else\\n                lo = mid + 1;\\n        }\\n\\n        return k;\\n    }\\n\\n    long long numOfHours(int k, vector<int>& piles) {\\n        long long totalHours = 0;\\n\\n        for (int pile : piles)\\n            totalHours += (pile + k - 1) / k;\\n        \\n        return totalHours;\\n    }\\n\\n    int maxPiles(vector<int>& piles) {\\n        return *max_element(piles.begin(), piles.end());\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int lo = 1, hi = maxPiles(piles), k = -1;\\n        while (lo <= hi) {\\n            int mid = lo + ((hi - lo) >> 1);\\n\\n            if (numOfHours(mid, piles) <= h) {\\n                k = mid;\\n                hi = mid - 1;\\n            }\\n            else\\n                lo = mid + 1;\\n        }\\n\\n        return k;\\n    }\\n\\n    public long numOfHours(int k, int[] piles) {\\n        long totalHours = 0;\\n\\n        for (int pile : piles)\\n            totalHours += (pile + k - 1) / k;\\n        \\n        return totalHours;\\n    }\\n\\n    public int maxPiles(int[] piles) {\\n        int max = piles[0];\\n        for(int i=1;i<piles.length;i++){\\n            if(piles[i] > max){\\n                max = piles[i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n```py\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        lo, hi, k = 1, max(piles), -1\\n        \\n        while lo <= hi:\\n            mid = lo + ((hi - lo) >> 1)\\n\\n            if self.numOfHours(mid, piles) <= h:\\n                k = mid\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n\\n        return k\\n\\n    def numOfHours(self, k: int, piles: List[int]) -> int:\\n        totalHours = 0\\n        for pile in piles:\\n            totalHours += math.ceil(pile / k)\\n\\n        return totalHours\\n```\n```js\\n/**\\n * @param {number[]} piles\\n * @param {number} h\\n * @return {number}\\n */\\nvar minEatingSpeed = function(piles, h) {\\n    let lo = 1, hi = Math.max(...piles), k = -1;\\n    \\n    while (lo <= hi) {\\n        const mid = lo + ((hi - lo) >> 1);\\n        const numOfHours = piles.reduce((total, pile) => total + Math.ceil(pile / mid), 0);\\n        \\n        if (numOfHours <= h) {\\n            k = mid;\\n            hi = mid - 1;\\n        }\\n        else {\\n            lo = mid + 1;\\n        }\\n    }\\n    \\n    return k;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271807,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=1;\\n        int high=*max_element(piles.begin(),piles.end());\\n        while(low<=high){\\n            long long int count =0;\\n            int mid=low+(high-low)/2;\\n            for(int i=0;i<piles.size();i++){\\n                if(piles[i]<mid) count++;\\n                else count+=((piles[i]/mid)+(piles[i]%mid!=0));\\n            }\\n            if(count>h) low=mid+1;\\n            else high=mid-1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=1;\\n        int high=*max_element(piles.begin(),piles.end());\\n        while(low<=high){\\n            long long int count =0;\\n            int mid=low+(high-low)/2;\\n            for(int i=0;i<piles.size();i++){\\n                if(piles[i]<mid) count++;\\n                else count+=((piles[i]/mid)+(piles[i]%mid!=0));\\n            }\\n            if(count>h) low=mid+1;\\n            else high=mid-1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271776,
                "title": "c-solution-binary-search-on-answer-explained-solution",
                "content": "# Intuition\\nWe need to minimize the answer so we can create a lower limit and an upper limit on speed and apply binary search on this interval and try to minimize the answer.\\n\\n# Approach\\nWe create a lower limit on speed as 1 and an upper limit on speed which will be the maximum bananas in a pile. Now we apply binary search on this interval and find out the middle element. If that middle element taken as speed satisfies the condition then we store it and search for a better answer in the left interval. If it doesn\\'t satisfy the condition then we check for an answer in the right interval.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN) where N is the length of piles array\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        sort(piles.begin(), piles.end());\\n        int low = 1;\\n        int high = piles[piles.size()-1];\\n        int ans = INT_MAX;\\n        int mid = low+(high-low)/2;\\n        while(low <= high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(check(mid, piles, h))\\n            {\\n                ans = mid;\\n                high = mid-1;\\n            }else\\n            {\\n                low = mid+1;\\n            }\\n        }      \\n        return ans;\\n    }\\n\\n    bool check(int speed, vector<int>& piles, int h)  //Function to check whether with this speed, all bananas can be eaten or not under h hours\\n    {\\n        int currenthours = 0;\\n        bool valid = true;\\n        for(int i = 0;i < piles.size(); i++)\\n        {\\n            if(piles[i]%speed == 0)\\n            {\\n                currenthours += ((piles[i]/speed));\\n            }else\\n            {\\n                currenthours += ((piles[i]/speed)+1);\\n            }\\n            if(currenthours > h)\\n            {\\n                valid = false;\\n                break;\\n            }\\n        }\\n        return valid;\\n    }\\n};\\n```\\n\\n**Do upvote if you understood it ! \\uD83D\\uDE00\\uD83D\\uDE00**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        sort(piles.begin(), piles.end());\\n        int low = 1;\\n        int high = piles[piles.size()-1];\\n        int ans = INT_MAX;\\n        int mid = low+(high-low)/2;\\n        while(low <= high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(check(mid, piles, h))\\n            {\\n                ans = mid;\\n                high = mid-1;\\n            }else\\n            {\\n                low = mid+1;\\n            }\\n        }      \\n        return ans;\\n    }\\n\\n    bool check(int speed, vector<int>& piles, int h)  //Function to check whether with this speed, all bananas can be eaten or not under h hours\\n    {\\n        int currenthours = 0;\\n        bool valid = true;\\n        for(int i = 0;i < piles.size(); i++)\\n        {\\n            if(piles[i]%speed == 0)\\n            {\\n                currenthours += ((piles[i]/speed));\\n            }else\\n            {\\n                currenthours += ((piles[i]/speed)+1);\\n            }\\n            if(currenthours > h)\\n            {\\n                valid = false;\\n                break;\\n            }\\n        }\\n        return valid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271710,
                "title": "c-easiest-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int i = 1, j = 0;\\n        for(int p:piles){\\n            j = max(j,p); //max possible value for k\\n        }\\n        while(i<j){\\n            int m = i+(j-i)/2;\\n            int x = 0;\\n            for(int p:piles){\\n                x += (p+m-1)/m; //calculate how much hours it\\'ll take if k = m\\n            }\\n            if(x>h) i = m+1; //set the min value of k to m+1\\n            else j = m; //set the max value of k to m\\n        }\\n        return i; // i is our required value of k\\n    }\\n};\\nDo Upvote if it helps\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int i = 1, j = 0;\\n        for(int p:piles){\\n            j = max(j,p); //max possible value for k\\n        }\\n        while(i<j){\\n            int m = i+(j-i)/2;\\n            int x = 0;\\n            for(int p:piles){\\n                x += (p+m-1)/m; //calculate how much hours it\\'ll take if k = m\\n            }\\n            if(x>h) i = m+1; //set the min value of k to m+1\\n            else j = m; //set the max value of k to m\\n        }\\n        return i; // i is our required value of k\\n    }\\n};\\nDo Upvote if it helps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271569,
                "title": "java-solution-binary-search-fully-explained-beats-80",
                "content": "# Inituition\\n- We can find the answer easily by \\n    - (sum of all values ) / h \\n- but koko doesnt use decimals and if there is a reminder she will wait for the remaining hour.\\n- This forces us to \\n    1. Use a for loop approach \\n    2. Or use Binary search\\n- Obviously the 2nd option is better. \\n\\n# Approach\\n## Check comments in code for better explaination\\n- Use Binary Search to guess the answer at first then pinpoint it correctly\\n- maxSpeed and minSpeed variables for the max and min values of the Binary search.\\n- Make a function canFinishEating to check if the given speed is enough to eat it all.\\n- Before binary search, if the maxSpeed and minSpeed are equal it means that all values in the piles array are equal, which makes the loop unable to run. \\n- So we can directly give the answer by using the formula.\\n\\n\\n# Code\\n\\n```\\nclass Solution {\\n    public static boolean canFinishEating(double speed, int totalTime, int[] bananas) {\\n        double timeTaken = 0;\\n        for (int i = 0; i < bananas.length; i++) {\\n            // we calculate the time taken\\n            double t = (double) bananas[i] / speed;\\n            // if the time taken is something like 1.5 then \\n            //koko will wait till 2 so we use math. ceil\\n            t = Math.ceil(t);\\n            timeTaken += t;\\n            //we check if the given speed is enough.\\n            if (timeTaken > totalTime)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    public static int minEatingSpeed(int[] bananas, int totalTime) {\\n        double maxSpeed = 0;\\n        double minSpeed = Integer.MAX_VALUE;\\n        for (int i = 0; i < bananas.length; i++) {\\n            if (maxSpeed < bananas[i])\\n                maxSpeed = bananas[i];\\n            if (minSpeed > bananas[i])\\n                minSpeed = bananas[i];\\n        }\\n        //minSpeed and maxSpeed are the smallest and the biggest values \\n        //in the array. This will serve us our range for binary search\\n        if (maxSpeed == minSpeed) {\\n            // we come into a problem where all the items are equal \\n            // where maxSpeed == minSpeed, so this will tackle that problem\\n            if (bananas.length <= totalTime && totalTime / bananas.length == 1)\\n                return (int) maxSpeed;\\n            return (int) (Math.ceil((maxSpeed * bananas.length) / totalTime));\\n        }\\n        minSpeed = minSpeed / totalTime;\\n        while (minSpeed < maxSpeed) {\\n            double mid = minSpeed + (maxSpeed - minSpeed) / 2;\\n            if (canFinishEating(mid, totalTime, bananas))\\n                maxSpeed = mid;\\n            else\\n                minSpeed = Math.ceil(mid);\\n        }\\n        return (int) minSpeed;\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/7fc848d9-4799-4780-8278-6dbdab2793a4_1678261862.5974212.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean canFinishEating(double speed, int totalTime, int[] bananas) {\\n        double timeTaken = 0;\\n        for (int i = 0; i < bananas.length; i++) {\\n            // we calculate the time taken\\n            double t = (double) bananas[i] / speed;\\n            // if the time taken is something like 1.5 then \\n            //koko will wait till 2 so we use math. ceil\\n            t = Math.ceil(t);\\n            timeTaken += t;\\n            //we check if the given speed is enough.\\n            if (timeTaken > totalTime)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    public static int minEatingSpeed(int[] bananas, int totalTime) {\\n        double maxSpeed = 0;\\n        double minSpeed = Integer.MAX_VALUE;\\n        for (int i = 0; i < bananas.length; i++) {\\n            if (maxSpeed < bananas[i])\\n                maxSpeed = bananas[i];\\n            if (minSpeed > bananas[i])\\n                minSpeed = bananas[i];\\n        }\\n        //minSpeed and maxSpeed are the smallest and the biggest values \\n        //in the array. This will serve us our range for binary search\\n        if (maxSpeed == minSpeed) {\\n            // we come into a problem where all the items are equal \\n            // where maxSpeed == minSpeed, so this will tackle that problem\\n            if (bananas.length <= totalTime && totalTime / bananas.length == 1)\\n                return (int) maxSpeed;\\n            return (int) (Math.ceil((maxSpeed * bananas.length) / totalTime));\\n        }\\n        minSpeed = minSpeed / totalTime;\\n        while (minSpeed < maxSpeed) {\\n            double mid = minSpeed + (maxSpeed - minSpeed) / 2;\\n            if (canFinishEating(mid, totalTime, bananas))\\n                maxSpeed = mid;\\n            else\\n                minSpeed = Math.ceil(mid);\\n        }\\n        return (int) minSpeed;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271513,
                "title": "java-binary-search-on-answers-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int min=1;\\n        int max=0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int ans=Integer.MAX_VALUE;\\n\\n        while(min<=max)\\n        {\\n            int mid=(min+max)/2;\\n            if(valid(mid,piles,h))\\n            {\\n                ans=Math.min(ans,mid);\\n                max=mid-1;\\n            }\\n            else\\n                min=mid+1;\\n        }\\n        return ans;\\n\\n    }\\n    public boolean valid(int temp,int[]piles,int h)\\n    {\\n        int count=0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            count+=piles[i]/temp;\\n            if(piles[i]%temp!=0)\\n               count++;\\n               if(count>h)\\n                 return false;\\n        }\\n        return count<=h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int min=1;\\n        int max=0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int ans=Integer.MAX_VALUE;\\n\\n        while(min<=max)\\n        {\\n            int mid=(min+max)/2;\\n            if(valid(mid,piles,h))\\n            {\\n                ans=Math.min(ans,mid);\\n                max=mid-1;\\n            }\\n            else\\n                min=mid+1;\\n        }\\n        return ans;\\n\\n    }\\n    public boolean valid(int temp,int[]piles,int h)\\n    {\\n        int count=0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            count+=piles[i]/temp;\\n            if(piles[i]%temp!=0)\\n               count++;\\n               if(count>h)\\n                 return false;\\n        }\\n        return count<=h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271362,
                "title": "easy-python-solution-beats-88-of-other-solutions",
                "content": "**Please upvote if you like it.**\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        a = 1\\n        b=max(piles)\\n        while a<b:\\n            mid=(a+b)//2\\n            c=0\\n            for j in piles:\\n                c+=((j-1)//mid)+1\\n            if c>h:\\n                a=mid+1\\n            else:\\n                b=mid\\n        return a",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "**Please upvote if you like it.**\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        a = 1\\n        b=max(piles)\\n        while a<b:\\n            mid=(a+b)//2\\n            c=0\\n            for j in piles:\\n                c+=((j-1)//mid)+1\\n            if c>h:\\n                a=mid+1\\n            else:\\n                b=mid\\n        return a",
                "codeTag": "Java"
            },
            {
                "id": 3271144,
                "title": "python-short-and-clean-binary-search",
                "content": "# Approach\\nNotice that `h >= len(piles)`, which means the eating rate, `k`, doesn\\'t need to be greater than `max(piles)` to finish under `h` hours.\\nLeveraging this, binary search for the optimal `k` in the range `[1, max(piles)]`\\n\\n# Complexity\\n- Time complexity: $$O(n * log(m))$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere,\\n`n is number of piles`,\\n`m is number of bananas in the largest pile`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def minEatingSpeed(self, piles: list[int], h: int) -> int:\\n        l, r = 1, max(piles)\\n        while l < r:\\n            k = (l + r) // 2\\n            hours = sum(ceil(n / k) for n in piles)\\n            l, r = (l, k) if hours <= h else (k + 1, r)\\n        return l\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def minEatingSpeed(self, piles: list[int], h: int) -> int:\\n        l, r = 1, max(piles)\\n        while l < r:\\n            k = (l + r) // 2\\n            hours = sum(ceil(n / k) for n in piles)\\n            l, r = (l, k) if hours <= h else (k + 1, r)\\n        return l\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271055,
                "title": "simple-solution-99-thought-process-to-get-an-intuition-for-problems-like-this",
                "content": "# Intuition\\nSuppose we had no boundation on time, or $$H$$ hours had such a large value(Infinity) for every test case that koko could eat every pile with as low of a value of $$k$$ as she wanted, what would be the answer? \\nWon\\'t it be just $$1$$ ? \\nBecause you have infinite time, why not take your time and eat at the slowest rate imaginable?\\n\\nAnd on the flip side, what is the minimum value $$H$$ could have for any test case? \\nIt is $$piles.length$$. Even if you assign a value of $$k$$ that would make koko eat any pile in one hour, she would still **only finish one pile in one hour**. Or in other words, you need at least $$piles.length$$ hours for this question to be valid(which is the case).\\n\\nBut what can we infer from that? Doesn\\'t that decide the maximum value of $$k$$ for us?\\nIf the value of $$H$$ were $$piles.length$$, koko would need to finish each pile in an hour. \\nThat will be possible if **she eats at a speed of the maximum size of any pile in the array**, which enables her to finish every pile in $$1$$ hour, to have no leftovers.\\n\\nIf we have a definite range for our answer, what approach do you suggest for optimising our search for $$k$$ ?\\nOr first, can\\'t you just iterate from $$1$$ to $$maxValueOfPiles$$ to check for the lowest value from which you\\'re able to eat all the piles within $$H$$ hours?\\nThat makes sense, and an improvement on our linear search would be ...\\n\\n\\n# Approach\\nWe set ```lo=1``` and ```hi=maximum value of any pile in the array``` for our binary search. In each iteration, ``mid`` will give us the  speed we\\'re trying to check for which we can finish the entire array within ```H``` hours. \\nApart from a standard binary search template, we have to find the condition based on which we decide to update either ```lo``` or ```hi``` pointers. That condition is as simple as:\\n**Given an eating speed of ```mid``` bananas per hour, can koko finish all the bananas in every pile in ```H``` hours?**\\n\\n# Complexity\\n- Time complexity:\\n$$O(N log(hi))$$\\nOur condition function will take $$O(N)$$ time and we will call it for $$log(hi)$$ times. \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        // Find the largest pile\\n        int maxValue = 0;\\n        for (int i : piles) {\\n            maxValue = Math.max(i, maxValue);\\n        }\\n\\n        // Binary search\\n        int lo = 1;\\n        int hi = maxValue;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            long hours = calculateHours(piles, mid);\\n//only bit different from a standard binary search\\n            if (hours > H) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return lo;\\n    }\\n    \\n    private long calculateHours(int[] piles, int speed) {\\n//we have used a function like this in problems like leetcode 1011\\n//and leetcode 2187\\n        long hours = 0;\\n        for (int pile : piles) {\\n            hours += ((pile - 1) / speed )+ 1;\\n    //(pile - 1) / speed + 1 because we need total time koko\\n    //will spend on a pile having(say) 10 bananas, if her eating \\n    //speed were 3. It would be 4.\\n        }\\n        return hours;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        int maxValue = 0;\\n        for(int i : piles) { // find largest number in piles\\n            maxValue = max(i, maxValue);\\n        }\\n        int l = 1;\\n        int h = maxValue;\\n        while(l <= h) {\\n            int mid = l + (h - l) / 2;\\n            if(calculateSum(piles, mid) > H) {\\n                l = mid + 1;\\n            } else {\\n                h = mid - 1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    long calculateSum(vector<int>& piles, int speed) {\\n        long sum = 0;\\n        for(int pile : piles) {\\n            sum += (pile + speed - 1) / speed;\\n        }\\n        return sum;\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\\n        max_val = max(piles)\\n        l = 1\\n        h = max_val\\n        \\n        while l <= h:\\n            mid = l + (h - l) // 2\\n            if self.calculate_sum(piles, mid) > H:\\n                l = mid + 1\\n            else:\\n                h = mid - 1\\n                \\n        return l\\n    \\n    def calculate_sum(self, piles: List[int], speed: int) -> int:\\n        total_time = 0\\n        for pile in piles:\\n            total_time += (pile + speed - 1) // speed\\n        return total_time\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Binary Search"
                ],
                "code": "```lo=1```\n```hi=maximum value of any pile in the array```\n```H```\n```lo```\n```hi```\n```mid```\n```H```\n```Java []\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        // Find the largest pile\\n        int maxValue = 0;\\n        for (int i : piles) {\\n            maxValue = Math.max(i, maxValue);\\n        }\\n\\n        // Binary search\\n        int lo = 1;\\n        int hi = maxValue;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            long hours = calculateHours(piles, mid);\\n//only bit different from a standard binary search\\n            if (hours > H) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return lo;\\n    }\\n    \\n    private long calculateHours(int[] piles, int speed) {\\n//we have used a function like this in problems like leetcode 1011\\n//and leetcode 2187\\n        long hours = 0;\\n        for (int pile : piles) {\\n            hours += ((pile - 1) / speed )+ 1;\\n    //(pile - 1) / speed + 1 because we need total time koko\\n    //will spend on a pile having(say) 10 bananas, if her eating \\n    //speed were 3. It would be 4.\\n        }\\n        return hours;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        int maxValue = 0;\\n        for(int i : piles) { // find largest number in piles\\n            maxValue = max(i, maxValue);\\n        }\\n        int l = 1;\\n        int h = maxValue;\\n        while(l <= h) {\\n            int mid = l + (h - l) / 2;\\n            if(calculateSum(piles, mid) > H) {\\n                l = mid + 1;\\n            } else {\\n                h = mid - 1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    long calculateSum(vector<int>& piles, int speed) {\\n        long sum = 0;\\n        for(int pile : piles) {\\n            sum += (pile + speed - 1) / speed;\\n        }\\n        return sum;\\n    }\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\\n        max_val = max(piles)\\n        l = 1\\n        h = max_val\\n        \\n        while l <= h:\\n            mid = l + (h - l) // 2\\n            if self.calculate_sum(piles, mid) > H:\\n                l = mid + 1\\n            else:\\n                h = mid - 1\\n                \\n        return l\\n    \\n    def calculate_sum(self, piles: List[int], speed: int) -> int:\\n        total_time = 0\\n        for pile in piles:\\n            total_time += (pile + speed - 1) // speed\\n        return total_time\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270959,
                "title": "java-solution-time-complexity-o-n-log-m-m-is-the-search-space-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n    Apply Binary Search logic\\n\\n# Complexity\\n- Time complexity:\\n    - O(n log m), m is the search space (1 to max(piles))\\n\\n- Space complexity:\\n    - O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low = 1, high = Integer.MIN_VALUE;\\n\\n        for (int p : piles) {\\n            high = Math.max(p, high);\\n        }\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (isBananaPossible(piles, mid, h)) {\\n                high = mid - 1;\\n            }\\n\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n\\n    private boolean isBananaPossible(int[] piles, int k, int h) {\\n        int total = 0;\\n        for (int p : piles) {\\n            total += Math.ceil((double) p / k);\\n        }\\n\\n        return total <= h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low = 1, high = Integer.MIN_VALUE;\\n\\n        for (int p : piles) {\\n            high = Math.max(p, high);\\n        }\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (isBananaPossible(piles, mid, h)) {\\n                high = mid - 1;\\n            }\\n\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n\\n    private boolean isBananaPossible(int[] piles, int k, int h) {\\n        int total = 0;\\n        for (int p : piles) {\\n            total += Math.ceil((double) p / k);\\n        }\\n\\n        return total <= h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270949,
                "title": "breathe-air-and-use-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> This is a simple binary search problem wherein we have to find the optimum time for Koko to finish all piles. Note that for a given speed k, Koko will need ceil(i/k) to finish a pile containing i bananas.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe take the lower limit as 1 and the higher limit as the maximum element in piles, as any higher number doesn\\'t make sense, since we are looking for minimum. We then apply simple binary search and in each iteration of the search, we traverse the array to find if the mid number is a suitable speed. If it is, we store it and look for a lower possible speed and if its not, we go higher.\\n\\n# Complexity\\n- Time complexity: O(n log2(n)).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) extra space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        long long ans,lo=1,hi=*max_element(piles.begin(),piles.end());\\n        while(lo<=hi){\\n            long long mid=(lo+hi)>>1,time=0;\\n            for(int &i:piles) time+=(i+mid-1)/mid;\\n            if(time<=h) ans=mid,hi=mid-1;\\n            else lo=mid+1;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        long long ans,lo=1,hi=*max_element(piles.begin(),piles.end());\\n        while(lo<=hi){\\n            long long mid=(lo+hi)>>1,time=0;\\n            for(int &i:piles) time+=(i+mid-1)/mid;\\n            if(time<=h) ans=mid,hi=mid-1;\\n            else lo=mid+1;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270894,
                "title": "java-simple-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        //binary search\\n        Arrays.sort(piles);\\n        int start = 1;\\n        //taking the largest value possible as end\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0;i < piles.length;i++){\\n            max = Math.max(max, piles[i]);\\n        }\\n        int end = max;\\n        while(start < end){\\n            int mid = start + (end - start) / 2;\\n            //check whether mid is a possible candidate or not\\n            if(isPossible(piles, mid, h)){\\n                end = mid;\\n            }else{\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n    public boolean isPossible(int[] piles, int value, int h){\\n        int hours = 0;\\n        int i = 0;\\n        for(int pile : piles){\\n            int div = pile / value;\\n            hours += div;\\n            if(pile % value != 0) hours++;\\n        }\\n        return hours <= h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        //binary search\\n        Arrays.sort(piles);\\n        int start = 1;\\n        //taking the largest value possible as end\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0;i < piles.length;i++){\\n            max = Math.max(max, piles[i]);\\n        }\\n        int end = max;\\n        while(start < end){\\n            int mid = start + (end - start) / 2;\\n            //check whether mid is a possible candidate or not\\n            if(isPossible(piles, mid, h)){\\n                end = mid;\\n            }else{\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n    public boolean isPossible(int[] piles, int value, int h){\\n        int hours = 0;\\n        int i = 0;\\n        for(int pile : piles){\\n            int div = pile / value;\\n            hours += div;\\n            if(pile % value != 0) hours++;\\n        }\\n        return hours <= h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270757,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool predicate(int mid,vector<int> a,int h,int n){\\n        int ct=0;\\n        for(int i=0;i<n;i++){\\n            ct+=(a[i]/mid);\\n            if(a[i]%mid !=0) ct++;\\n        if(ct>h) return false;\\n        }\\n    return true;\\n    }\\n\\n    int minEatingSpeed(vector<int>& a, int h) {\\n      int l =1,r=1e9;\\n      int n = a.size();\\n      while(l<r){\\n          int mid = l+(r-l)/2 ;\\n           if(predicate(mid,a,h,n)){\\n               r= mid;\\n           } \\n           else l = mid+1;\\n      }\\n      return l;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool predicate(int mid,vector<int> a,int h,int n){\\n        int ct=0;\\n        for(int i=0;i<n;i++){\\n            ct+=(a[i]/mid);\\n            if(a[i]%mid !=0) ct++;\\n        if(ct>h) return false;\\n        }\\n    return true;\\n    }\\n\\n    int minEatingSpeed(vector<int>& a, int h) {\\n      int l =1,r=1e9;\\n      int n = a.size();\\n      while(l<r){\\n          int mid = l+(r-l)/2 ;\\n           if(predicate(mid,a,h,n)){\\n               r= mid;\\n           } \\n           else l = mid+1;\\n      }\\n      return l;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270738,
                "title": "java-solution-binary-search",
                "content": "\\n# Complexity\\n- Time complexity:$$O(N)$$ +  $$O(N*logN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n Here $$N$$ is the max value of Piles.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int left = 1;\\n        int right = Integer.MIN_VALUE;\\n        for(int pile : piles){\\n            right = Math.max(right,pile);\\n        }\\n        while(left < right){\\n            int mid = left + (right - left)/2;\\n            int time = 0;\\n            for(int pile : piles){\\n                time += pile % mid == 0 ? pile/mid : (pile/mid)+1;\\n            }\\n            if(time > h){\\n                left = mid+1;\\n            }else{\\n                right = mid;\\n            }\\n        }\\n\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int left = 1;\\n        int right = Integer.MIN_VALUE;\\n        for(int pile : piles){\\n            right = Math.max(right,pile);\\n        }\\n        while(left < right){\\n            int mid = left + (right - left)/2;\\n            int time = 0;\\n            for(int pile : piles){\\n                time += pile % mid == 0 ? pile/mid : (pile/mid)+1;\\n            }\\n            if(time > h){\\n                left = mid+1;\\n            }else{\\n                right = mid;\\n            }\\n        }\\n\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270645,
                "title": "binary-search-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int max_element(vector<int>piles){\\n        int max=piles[0];\\n        for(int i=1;i<piles.size();i++){\\n            if(max<piles[i]){\\n                max=piles[i];\\n            }\\n        }\\n        return max;\\n    }\\n    int find(vector<int>piles, int hour){\\n        int sum=0;\\n        for(int i=0; i<piles.size(); i++){\\n            if(piles[i]%hour==0){\\n                sum+=piles[i]/hour;\\n            }\\n            else{\\n                sum+=(piles[i]/hour)+1;\\n            }\\n        }\\n        return sum;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int start = 1;\\n        int end = max_element(piles);\\n        while(start<end){\\n            int mid = start + (end-start)/2;\\n            int currsum = find(piles,mid);\\n            if(currsum<=h){\\n                end=mid;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int max_element(vector<int>piles){\\n        int max=piles[0];\\n        for(int i=1;i<piles.size();i++){\\n            if(max<piles[i]){\\n                max=piles[i];\\n            }\\n        }\\n        return max;\\n    }\\n    int find(vector<int>piles, int hour){\\n        int sum=0;\\n        for(int i=0; i<piles.size(); i++){\\n            if(piles[i]%hour==0){\\n                sum+=piles[i]/hour;\\n            }\\n            else{\\n                sum+=(piles[i]/hour)+1;\\n            }\\n        }\\n        return sum;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int start = 1;\\n        int end = max_element(piles);\\n        while(start<end){\\n            int mid = start + (end-start)/2;\\n            int currsum = find(piles,mid);\\n            if(currsum<=h){\\n                end=mid;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270602,
                "title": "java-solution-beats-96-binary-search-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$ \\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n       int left = 1, right = Arrays.stream(piles).max().getAsInt();\\n       while(left<right){\\n           int mid = left + (right - left)/2;\\n           if(CompletesEatingAll(piles,h,mid)) right = mid;\\n           else left = mid + 1;\\n       }  \\n       return left;\\n    }\\n    private boolean CompletesEatingAll(int[]piles,int h,int mid){\\n        int time = 0;\\n        for(int i=0;i<piles.length;i++) time += (piles[i]-1)/mid+1;\\n        if(time>h) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n       int left = 1, right = Arrays.stream(piles).max().getAsInt();\\n       while(left<right){\\n           int mid = left + (right - left)/2;\\n           if(CompletesEatingAll(piles,h,mid)) right = mid;\\n           else left = mid + 1;\\n       }  \\n       return left;\\n    }\\n    private boolean CompletesEatingAll(int[]piles,int h,int mid){\\n        int time = 0;\\n        for(int i=0;i<piles.length;i++) time += (piles[i]-1)/mid+1;\\n        if(time>h) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270580,
                "title": "c-binarysearch-o-n-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBinarySearch\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n * log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n\\n    private bool IsEnough(int[] piles, int k, int h)\\n    {\\n        int hours = 0;\\n\\n        foreach (var pile in piles)\\n        {\\n            hours += (pile + k - 1) / k;\\n        }\\n\\n        return hours <= h;\\n    }\\n\\n    public int MinEatingSpeed(int[] piles, int h) {\\n        int l = 1;\\n        int r = piles.Max();\\n\\n        while (l < r)\\n        {\\n            int m = l + (r - l) / 2;\\n\\n            if (IsEnough(piles, m, h))\\n            {\\n                r = m;\\n            }\\n            else\\n            {\\n                l = m + 1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n    private bool IsEnough(int[] piles, int k, int h)\\n    {\\n        int hours = 0;\\n\\n        foreach (var pile in piles)\\n        {\\n            hours += (pile + k - 1) / k;\\n        }\\n\\n        return hours <= h;\\n    }\\n\\n    public int MinEatingSpeed(int[] piles, int h) {\\n        int l = 1;\\n        int r = piles.Max();\\n\\n        while (l < r)\\n        {\\n            int m = l + (r - l) / 2;\\n\\n            if (IsEnough(piles, m, h))\\n            {\\n                r = m;\\n            }\\n            else\\n            {\\n                l = m + 1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270452,
                "title": "easy-c-solution-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int mid, vector<int> piles, int h) {\\n        int hours = 0;\\n        for(int i=0;i<piles.size();i++) {\\n            hours += (piles[i]/mid);\\n            piles[i] %=mid;\\n            if(piles[i] > 0) hours++;\\n            if(hours > h) return false;\\n        }\\n        return true;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int start = 1, end = 0, res = -1;\\n        for(int i=0;i<piles.size();i++) {\\n            end = max(end, piles[i]);\\n        }\\n        while(start <= end) {\\n            int mid = start + (end-start)/2;\\n            if(isValid(mid, piles, h)) {\\n                res = mid;\\n                end = mid - 1;\\n            } else start = mid + 1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int mid, vector<int> piles, int h) {\\n        int hours = 0;\\n        for(int i=0;i<piles.size();i++) {\\n            hours += (piles[i]/mid);\\n            piles[i] %=mid;\\n            if(piles[i] > 0) hours++;\\n            if(hours > h) return false;\\n        }\\n        return true;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int start = 1, end = 0, res = -1;\\n        for(int i=0;i<piles.size();i++) {\\n            end = max(end, piles[i]);\\n        }\\n        while(start <= end) {\\n            int mid = start + (end-start)/2;\\n            if(isValid(mid, piles, h)) {\\n                res = mid;\\n                end = mid - 1;\\n            } else start = mid + 1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1811257,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1825809,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1826048,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1825949,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1825795,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1979799,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1810142,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1825674,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1826041,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1576265,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1811257,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1825809,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1826048,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1825949,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1825795,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1979799,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1810142,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1825674,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1826041,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1576265,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1565643,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "iiiiiiiiiix",
                        "content": "\\u2764\\uFE0F **R.I.P. Koko** (everyone who doesn\\'t know about her should google _Koko the gorilla_).\\nWith her intelligence she could probably solve some LeetCode problems :)\\n\\nCheers to the task authors, you are my soulmates!\\nBest problem statement ever! It makes a heart melt"
                    },
                    {
                        "username": "juxtapo",
                        "content": "I don\\'t understand the question "
                    },
                    {
                        "username": "cennav",
                        "content": "Me neither, I don't feel so bad already"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Hahaha, welcome to a club, guys! "
                    },
                    {
                        "username": "markymarrk",
                        "content": "same here my man"
                    },
                    {
                        "username": "samirhembrom007",
                        "content": "This test case seems to be wrong : [805306368,805306368,805306368]\\nCan someone verify this"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code   count>0 then your code works fine "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "ydt_notfound",
                        "content": "[@RamanV312](/RamanV312) its not out of range but it gives wrong answer for this particular test case\\n"
                    },
                    {
                        "username": "vishalpal1999",
                        "content": "[@RamanV312](/RamanV312) or long in java"
                    },
                    {
                        "username": "RamanV312",
                        "content": "Use long long for count instead of int."
                    },
                    {
                        "username": "baby_groot",
                        "content": "Do you agree ?"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: try binary searching over the solution space. Given a fixed speed k, it is easy to check if Koko can eat all the bananas within h hours. If it works for k, we recurse by setting right = k. Otherwise, we recurse by setting left = k+1."
                    },
                    {
                        "username": "tmdgjs2592",
                        "content": "[@arjun202](/arjun202) It is not necessarily true that, when k*h >= sum, koko can eat all piles."
                    },
                    {
                        "username": "arjun202",
                        "content": "Hey I took your tip and tried to solve the question.. can u let me know where y code or logic is failing? Please\\n\\n\\nclass Solution {\\npublic:\\n//helper function to do binary search on k\\nvoid kokoEatsAllBananas(int lo, int hi,int sum, int h,int &ans){\\n         int k = ceil(lo + (hi-lo)/2);\\n         \\n         if(lo>hi) return;\\n         if(k*h >= sum){\\n            ans = k;\\n            kokoEatsAllBananas(lo,k-1,sum,h,ans);\\n         }\\n         else{\\n             kokoEatsAllBananas(k+1,hi,sum,h,ans);\\n         }\\n         return;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n     int size = piles.size();\\n     int sum = 0; for(auto i : piles) sum++;\\n     //k can only range from min[piles] to max[piles]\\n     sort(piles.begin(),piles.end());\\n     int lo = piles[0];\\n     int hi = piles[size-1];\\n     int ans = 0;\\n     kokoEatsAllBananas(lo,hi,sum,h,ans);\\n     return ans;\\n     \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "k is bananas per hour, h is number of hours\\nFor example 1: Given piles = [3,6,7,11], h = 8hrs, if k = 4 ban/hr\\nSince 3 is less than k, only (1hr) is added. The 0th pile took 1 hr;\\nSince 6 is greater than k, Koko can eat k from 6, leaving 6 - k = 2 bananas left and adding (1hr), since 2 is less than 4, add (1hr). The 1st pile took 2 hours.\\nSince 7 > k, 7 - k = 3, add (1hr), 3 < k, add (1hr). The 2nd pile took 2 hours.\\nSince 11 > k, 11 - k = 7, add (1hr), 7 - k = 3, add (1hr), 3 < k, add (1hr). The 3rd pile took 3 hours.\\n\\nFor a total of 1 + 2 + 2 + 3 = 8 hours == h\\nThere\\'s a faster way of doing the above that doesn\\'t involve subtraction.\\n\\nFor example 2: Given piles = [30,11,23,4,20], h = 5, if k = 30 ban/hr.\\nHours Spent = [1, 1, 1, 1, 1]\\n1 + 1 + 1 + 1 + 1 = 5 hours == h\\n\\nFor example 3: Given piles = [30,11,23,4,20], h = 6, if k = 23 ban/hr.\\nHours Spent = [2,1,1,1,1]\\nFor a total of 6 hours == h."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/tag/binary-search/discuss/691825/Binary-Search-for-Beginners-Problems-or-Patterns-or-Sample-solutions"
                    },
                    {
                        "username": "siddhs",
                        "content": "Thank you!.\\nDo you have some more links like this. It will help me in my interview preparation."
                    },
                    {
                        "username": "ashokesen02",
                        "content": "So for this problem I initially chose the range for Binary Search to be [1....10^9] with low=1 and high=10^9 but this gives wrong answer for only one case where  piles =[805306368,805306368,805306368] and h= 1000000000, where the expected output is 3 but my code gives 1. Upon substituting the value of high with max value of the array , it passes all test cases. Can anybody please tell me why this happened?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code count>0 then your code works fine"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Wishing you all a very Happy Holi filled with love and programming success."
                    }
                ]
            },
            {
                "id": 1826355,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "iiiiiiiiiix",
                        "content": "\\u2764\\uFE0F **R.I.P. Koko** (everyone who doesn\\'t know about her should google _Koko the gorilla_).\\nWith her intelligence she could probably solve some LeetCode problems :)\\n\\nCheers to the task authors, you are my soulmates!\\nBest problem statement ever! It makes a heart melt"
                    },
                    {
                        "username": "juxtapo",
                        "content": "I don\\'t understand the question "
                    },
                    {
                        "username": "cennav",
                        "content": "Me neither, I don't feel so bad already"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Hahaha, welcome to a club, guys! "
                    },
                    {
                        "username": "markymarrk",
                        "content": "same here my man"
                    },
                    {
                        "username": "samirhembrom007",
                        "content": "This test case seems to be wrong : [805306368,805306368,805306368]\\nCan someone verify this"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code   count>0 then your code works fine "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "ydt_notfound",
                        "content": "[@RamanV312](/RamanV312) its not out of range but it gives wrong answer for this particular test case\\n"
                    },
                    {
                        "username": "vishalpal1999",
                        "content": "[@RamanV312](/RamanV312) or long in java"
                    },
                    {
                        "username": "RamanV312",
                        "content": "Use long long for count instead of int."
                    },
                    {
                        "username": "baby_groot",
                        "content": "Do you agree ?"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: try binary searching over the solution space. Given a fixed speed k, it is easy to check if Koko can eat all the bananas within h hours. If it works for k, we recurse by setting right = k. Otherwise, we recurse by setting left = k+1."
                    },
                    {
                        "username": "tmdgjs2592",
                        "content": "[@arjun202](/arjun202) It is not necessarily true that, when k*h >= sum, koko can eat all piles."
                    },
                    {
                        "username": "arjun202",
                        "content": "Hey I took your tip and tried to solve the question.. can u let me know where y code or logic is failing? Please\\n\\n\\nclass Solution {\\npublic:\\n//helper function to do binary search on k\\nvoid kokoEatsAllBananas(int lo, int hi,int sum, int h,int &ans){\\n         int k = ceil(lo + (hi-lo)/2);\\n         \\n         if(lo>hi) return;\\n         if(k*h >= sum){\\n            ans = k;\\n            kokoEatsAllBananas(lo,k-1,sum,h,ans);\\n         }\\n         else{\\n             kokoEatsAllBananas(k+1,hi,sum,h,ans);\\n         }\\n         return;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n     int size = piles.size();\\n     int sum = 0; for(auto i : piles) sum++;\\n     //k can only range from min[piles] to max[piles]\\n     sort(piles.begin(),piles.end());\\n     int lo = piles[0];\\n     int hi = piles[size-1];\\n     int ans = 0;\\n     kokoEatsAllBananas(lo,hi,sum,h,ans);\\n     return ans;\\n     \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "k is bananas per hour, h is number of hours\\nFor example 1: Given piles = [3,6,7,11], h = 8hrs, if k = 4 ban/hr\\nSince 3 is less than k, only (1hr) is added. The 0th pile took 1 hr;\\nSince 6 is greater than k, Koko can eat k from 6, leaving 6 - k = 2 bananas left and adding (1hr), since 2 is less than 4, add (1hr). The 1st pile took 2 hours.\\nSince 7 > k, 7 - k = 3, add (1hr), 3 < k, add (1hr). The 2nd pile took 2 hours.\\nSince 11 > k, 11 - k = 7, add (1hr), 7 - k = 3, add (1hr), 3 < k, add (1hr). The 3rd pile took 3 hours.\\n\\nFor a total of 1 + 2 + 2 + 3 = 8 hours == h\\nThere\\'s a faster way of doing the above that doesn\\'t involve subtraction.\\n\\nFor example 2: Given piles = [30,11,23,4,20], h = 5, if k = 30 ban/hr.\\nHours Spent = [1, 1, 1, 1, 1]\\n1 + 1 + 1 + 1 + 1 = 5 hours == h\\n\\nFor example 3: Given piles = [30,11,23,4,20], h = 6, if k = 23 ban/hr.\\nHours Spent = [2,1,1,1,1]\\nFor a total of 6 hours == h."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/tag/binary-search/discuss/691825/Binary-Search-for-Beginners-Problems-or-Patterns-or-Sample-solutions"
                    },
                    {
                        "username": "siddhs",
                        "content": "Thank you!.\\nDo you have some more links like this. It will help me in my interview preparation."
                    },
                    {
                        "username": "ashokesen02",
                        "content": "So for this problem I initially chose the range for Binary Search to be [1....10^9] with low=1 and high=10^9 but this gives wrong answer for only one case where  piles =[805306368,805306368,805306368] and h= 1000000000, where the expected output is 3 but my code gives 1. Upon substituting the value of high with max value of the array , it passes all test cases. Can anybody please tell me why this happened?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code count>0 then your code works fine"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Wishing you all a very Happy Holi filled with love and programming success."
                    }
                ]
            },
            {
                "id": 1877225,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "iiiiiiiiiix",
                        "content": "\\u2764\\uFE0F **R.I.P. Koko** (everyone who doesn\\'t know about her should google _Koko the gorilla_).\\nWith her intelligence she could probably solve some LeetCode problems :)\\n\\nCheers to the task authors, you are my soulmates!\\nBest problem statement ever! It makes a heart melt"
                    },
                    {
                        "username": "juxtapo",
                        "content": "I don\\'t understand the question "
                    },
                    {
                        "username": "cennav",
                        "content": "Me neither, I don't feel so bad already"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Hahaha, welcome to a club, guys! "
                    },
                    {
                        "username": "markymarrk",
                        "content": "same here my man"
                    },
                    {
                        "username": "samirhembrom007",
                        "content": "This test case seems to be wrong : [805306368,805306368,805306368]\\nCan someone verify this"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code   count>0 then your code works fine "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "ydt_notfound",
                        "content": "[@RamanV312](/RamanV312) its not out of range but it gives wrong answer for this particular test case\\n"
                    },
                    {
                        "username": "vishalpal1999",
                        "content": "[@RamanV312](/RamanV312) or long in java"
                    },
                    {
                        "username": "RamanV312",
                        "content": "Use long long for count instead of int."
                    },
                    {
                        "username": "baby_groot",
                        "content": "Do you agree ?"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: try binary searching over the solution space. Given a fixed speed k, it is easy to check if Koko can eat all the bananas within h hours. If it works for k, we recurse by setting right = k. Otherwise, we recurse by setting left = k+1."
                    },
                    {
                        "username": "tmdgjs2592",
                        "content": "[@arjun202](/arjun202) It is not necessarily true that, when k*h >= sum, koko can eat all piles."
                    },
                    {
                        "username": "arjun202",
                        "content": "Hey I took your tip and tried to solve the question.. can u let me know where y code or logic is failing? Please\\n\\n\\nclass Solution {\\npublic:\\n//helper function to do binary search on k\\nvoid kokoEatsAllBananas(int lo, int hi,int sum, int h,int &ans){\\n         int k = ceil(lo + (hi-lo)/2);\\n         \\n         if(lo>hi) return;\\n         if(k*h >= sum){\\n            ans = k;\\n            kokoEatsAllBananas(lo,k-1,sum,h,ans);\\n         }\\n         else{\\n             kokoEatsAllBananas(k+1,hi,sum,h,ans);\\n         }\\n         return;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n     int size = piles.size();\\n     int sum = 0; for(auto i : piles) sum++;\\n     //k can only range from min[piles] to max[piles]\\n     sort(piles.begin(),piles.end());\\n     int lo = piles[0];\\n     int hi = piles[size-1];\\n     int ans = 0;\\n     kokoEatsAllBananas(lo,hi,sum,h,ans);\\n     return ans;\\n     \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "k is bananas per hour, h is number of hours\\nFor example 1: Given piles = [3,6,7,11], h = 8hrs, if k = 4 ban/hr\\nSince 3 is less than k, only (1hr) is added. The 0th pile took 1 hr;\\nSince 6 is greater than k, Koko can eat k from 6, leaving 6 - k = 2 bananas left and adding (1hr), since 2 is less than 4, add (1hr). The 1st pile took 2 hours.\\nSince 7 > k, 7 - k = 3, add (1hr), 3 < k, add (1hr). The 2nd pile took 2 hours.\\nSince 11 > k, 11 - k = 7, add (1hr), 7 - k = 3, add (1hr), 3 < k, add (1hr). The 3rd pile took 3 hours.\\n\\nFor a total of 1 + 2 + 2 + 3 = 8 hours == h\\nThere\\'s a faster way of doing the above that doesn\\'t involve subtraction.\\n\\nFor example 2: Given piles = [30,11,23,4,20], h = 5, if k = 30 ban/hr.\\nHours Spent = [1, 1, 1, 1, 1]\\n1 + 1 + 1 + 1 + 1 = 5 hours == h\\n\\nFor example 3: Given piles = [30,11,23,4,20], h = 6, if k = 23 ban/hr.\\nHours Spent = [2,1,1,1,1]\\nFor a total of 6 hours == h."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/tag/binary-search/discuss/691825/Binary-Search-for-Beginners-Problems-or-Patterns-or-Sample-solutions"
                    },
                    {
                        "username": "siddhs",
                        "content": "Thank you!.\\nDo you have some more links like this. It will help me in my interview preparation."
                    },
                    {
                        "username": "ashokesen02",
                        "content": "So for this problem I initially chose the range for Binary Search to be [1....10^9] with low=1 and high=10^9 but this gives wrong answer for only one case where  piles =[805306368,805306368,805306368] and h= 1000000000, where the expected output is 3 but my code gives 1. Upon substituting the value of high with max value of the array , it passes all test cases. Can anybody please tell me why this happened?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code count>0 then your code works fine"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Wishing you all a very Happy Holi filled with love and programming success."
                    }
                ]
            },
            {
                "id": 1757763,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "iiiiiiiiiix",
                        "content": "\\u2764\\uFE0F **R.I.P. Koko** (everyone who doesn\\'t know about her should google _Koko the gorilla_).\\nWith her intelligence she could probably solve some LeetCode problems :)\\n\\nCheers to the task authors, you are my soulmates!\\nBest problem statement ever! It makes a heart melt"
                    },
                    {
                        "username": "juxtapo",
                        "content": "I don\\'t understand the question "
                    },
                    {
                        "username": "cennav",
                        "content": "Me neither, I don't feel so bad already"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Hahaha, welcome to a club, guys! "
                    },
                    {
                        "username": "markymarrk",
                        "content": "same here my man"
                    },
                    {
                        "username": "samirhembrom007",
                        "content": "This test case seems to be wrong : [805306368,805306368,805306368]\\nCan someone verify this"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code   count>0 then your code works fine "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "ydt_notfound",
                        "content": "[@RamanV312](/RamanV312) its not out of range but it gives wrong answer for this particular test case\\n"
                    },
                    {
                        "username": "vishalpal1999",
                        "content": "[@RamanV312](/RamanV312) or long in java"
                    },
                    {
                        "username": "RamanV312",
                        "content": "Use long long for count instead of int."
                    },
                    {
                        "username": "baby_groot",
                        "content": "Do you agree ?"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: try binary searching over the solution space. Given a fixed speed k, it is easy to check if Koko can eat all the bananas within h hours. If it works for k, we recurse by setting right = k. Otherwise, we recurse by setting left = k+1."
                    },
                    {
                        "username": "tmdgjs2592",
                        "content": "[@arjun202](/arjun202) It is not necessarily true that, when k*h >= sum, koko can eat all piles."
                    },
                    {
                        "username": "arjun202",
                        "content": "Hey I took your tip and tried to solve the question.. can u let me know where y code or logic is failing? Please\\n\\n\\nclass Solution {\\npublic:\\n//helper function to do binary search on k\\nvoid kokoEatsAllBananas(int lo, int hi,int sum, int h,int &ans){\\n         int k = ceil(lo + (hi-lo)/2);\\n         \\n         if(lo>hi) return;\\n         if(k*h >= sum){\\n            ans = k;\\n            kokoEatsAllBananas(lo,k-1,sum,h,ans);\\n         }\\n         else{\\n             kokoEatsAllBananas(k+1,hi,sum,h,ans);\\n         }\\n         return;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n     int size = piles.size();\\n     int sum = 0; for(auto i : piles) sum++;\\n     //k can only range from min[piles] to max[piles]\\n     sort(piles.begin(),piles.end());\\n     int lo = piles[0];\\n     int hi = piles[size-1];\\n     int ans = 0;\\n     kokoEatsAllBananas(lo,hi,sum,h,ans);\\n     return ans;\\n     \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "k is bananas per hour, h is number of hours\\nFor example 1: Given piles = [3,6,7,11], h = 8hrs, if k = 4 ban/hr\\nSince 3 is less than k, only (1hr) is added. The 0th pile took 1 hr;\\nSince 6 is greater than k, Koko can eat k from 6, leaving 6 - k = 2 bananas left and adding (1hr), since 2 is less than 4, add (1hr). The 1st pile took 2 hours.\\nSince 7 > k, 7 - k = 3, add (1hr), 3 < k, add (1hr). The 2nd pile took 2 hours.\\nSince 11 > k, 11 - k = 7, add (1hr), 7 - k = 3, add (1hr), 3 < k, add (1hr). The 3rd pile took 3 hours.\\n\\nFor a total of 1 + 2 + 2 + 3 = 8 hours == h\\nThere\\'s a faster way of doing the above that doesn\\'t involve subtraction.\\n\\nFor example 2: Given piles = [30,11,23,4,20], h = 5, if k = 30 ban/hr.\\nHours Spent = [1, 1, 1, 1, 1]\\n1 + 1 + 1 + 1 + 1 = 5 hours == h\\n\\nFor example 3: Given piles = [30,11,23,4,20], h = 6, if k = 23 ban/hr.\\nHours Spent = [2,1,1,1,1]\\nFor a total of 6 hours == h."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/tag/binary-search/discuss/691825/Binary-Search-for-Beginners-Problems-or-Patterns-or-Sample-solutions"
                    },
                    {
                        "username": "siddhs",
                        "content": "Thank you!.\\nDo you have some more links like this. It will help me in my interview preparation."
                    },
                    {
                        "username": "ashokesen02",
                        "content": "So for this problem I initially chose the range for Binary Search to be [1....10^9] with low=1 and high=10^9 but this gives wrong answer for only one case where  piles =[805306368,805306368,805306368] and h= 1000000000, where the expected output is 3 but my code gives 1. Upon substituting the value of high with max value of the array , it passes all test cases. Can anybody please tell me why this happened?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code count>0 then your code works fine"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Wishing you all a very Happy Holi filled with love and programming success."
                    }
                ]
            },
            {
                "id": 1564970,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "iiiiiiiiiix",
                        "content": "\\u2764\\uFE0F **R.I.P. Koko** (everyone who doesn\\'t know about her should google _Koko the gorilla_).\\nWith her intelligence she could probably solve some LeetCode problems :)\\n\\nCheers to the task authors, you are my soulmates!\\nBest problem statement ever! It makes a heart melt"
                    },
                    {
                        "username": "juxtapo",
                        "content": "I don\\'t understand the question "
                    },
                    {
                        "username": "cennav",
                        "content": "Me neither, I don't feel so bad already"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Hahaha, welcome to a club, guys! "
                    },
                    {
                        "username": "markymarrk",
                        "content": "same here my man"
                    },
                    {
                        "username": "samirhembrom007",
                        "content": "This test case seems to be wrong : [805306368,805306368,805306368]\\nCan someone verify this"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code   count>0 then your code works fine "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "ydt_notfound",
                        "content": "[@RamanV312](/RamanV312) its not out of range but it gives wrong answer for this particular test case\\n"
                    },
                    {
                        "username": "vishalpal1999",
                        "content": "[@RamanV312](/RamanV312) or long in java"
                    },
                    {
                        "username": "RamanV312",
                        "content": "Use long long for count instead of int."
                    },
                    {
                        "username": "baby_groot",
                        "content": "Do you agree ?"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: try binary searching over the solution space. Given a fixed speed k, it is easy to check if Koko can eat all the bananas within h hours. If it works for k, we recurse by setting right = k. Otherwise, we recurse by setting left = k+1."
                    },
                    {
                        "username": "tmdgjs2592",
                        "content": "[@arjun202](/arjun202) It is not necessarily true that, when k*h >= sum, koko can eat all piles."
                    },
                    {
                        "username": "arjun202",
                        "content": "Hey I took your tip and tried to solve the question.. can u let me know where y code or logic is failing? Please\\n\\n\\nclass Solution {\\npublic:\\n//helper function to do binary search on k\\nvoid kokoEatsAllBananas(int lo, int hi,int sum, int h,int &ans){\\n         int k = ceil(lo + (hi-lo)/2);\\n         \\n         if(lo>hi) return;\\n         if(k*h >= sum){\\n            ans = k;\\n            kokoEatsAllBananas(lo,k-1,sum,h,ans);\\n         }\\n         else{\\n             kokoEatsAllBananas(k+1,hi,sum,h,ans);\\n         }\\n         return;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n     int size = piles.size();\\n     int sum = 0; for(auto i : piles) sum++;\\n     //k can only range from min[piles] to max[piles]\\n     sort(piles.begin(),piles.end());\\n     int lo = piles[0];\\n     int hi = piles[size-1];\\n     int ans = 0;\\n     kokoEatsAllBananas(lo,hi,sum,h,ans);\\n     return ans;\\n     \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "k is bananas per hour, h is number of hours\\nFor example 1: Given piles = [3,6,7,11], h = 8hrs, if k = 4 ban/hr\\nSince 3 is less than k, only (1hr) is added. The 0th pile took 1 hr;\\nSince 6 is greater than k, Koko can eat k from 6, leaving 6 - k = 2 bananas left and adding (1hr), since 2 is less than 4, add (1hr). The 1st pile took 2 hours.\\nSince 7 > k, 7 - k = 3, add (1hr), 3 < k, add (1hr). The 2nd pile took 2 hours.\\nSince 11 > k, 11 - k = 7, add (1hr), 7 - k = 3, add (1hr), 3 < k, add (1hr). The 3rd pile took 3 hours.\\n\\nFor a total of 1 + 2 + 2 + 3 = 8 hours == h\\nThere\\'s a faster way of doing the above that doesn\\'t involve subtraction.\\n\\nFor example 2: Given piles = [30,11,23,4,20], h = 5, if k = 30 ban/hr.\\nHours Spent = [1, 1, 1, 1, 1]\\n1 + 1 + 1 + 1 + 1 = 5 hours == h\\n\\nFor example 3: Given piles = [30,11,23,4,20], h = 6, if k = 23 ban/hr.\\nHours Spent = [2,1,1,1,1]\\nFor a total of 6 hours == h."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/tag/binary-search/discuss/691825/Binary-Search-for-Beginners-Problems-or-Patterns-or-Sample-solutions"
                    },
                    {
                        "username": "siddhs",
                        "content": "Thank you!.\\nDo you have some more links like this. It will help me in my interview preparation."
                    },
                    {
                        "username": "ashokesen02",
                        "content": "So for this problem I initially chose the range for Binary Search to be [1....10^9] with low=1 and high=10^9 but this gives wrong answer for only one case where  piles =[805306368,805306368,805306368] and h= 1000000000, where the expected output is 3 but my code gives 1. Upon substituting the value of high with max value of the array , it passes all test cases. Can anybody please tell me why this happened?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code count>0 then your code works fine"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Wishing you all a very Happy Holi filled with love and programming success."
                    }
                ]
            },
            {
                "id": 1688194,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "iiiiiiiiiix",
                        "content": "\\u2764\\uFE0F **R.I.P. Koko** (everyone who doesn\\'t know about her should google _Koko the gorilla_).\\nWith her intelligence she could probably solve some LeetCode problems :)\\n\\nCheers to the task authors, you are my soulmates!\\nBest problem statement ever! It makes a heart melt"
                    },
                    {
                        "username": "juxtapo",
                        "content": "I don\\'t understand the question "
                    },
                    {
                        "username": "cennav",
                        "content": "Me neither, I don't feel so bad already"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Hahaha, welcome to a club, guys! "
                    },
                    {
                        "username": "markymarrk",
                        "content": "same here my man"
                    },
                    {
                        "username": "samirhembrom007",
                        "content": "This test case seems to be wrong : [805306368,805306368,805306368]\\nCan someone verify this"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code   count>0 then your code works fine "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "ydt_notfound",
                        "content": "[@RamanV312](/RamanV312) its not out of range but it gives wrong answer for this particular test case\\n"
                    },
                    {
                        "username": "vishalpal1999",
                        "content": "[@RamanV312](/RamanV312) or long in java"
                    },
                    {
                        "username": "RamanV312",
                        "content": "Use long long for count instead of int."
                    },
                    {
                        "username": "baby_groot",
                        "content": "Do you agree ?"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: try binary searching over the solution space. Given a fixed speed k, it is easy to check if Koko can eat all the bananas within h hours. If it works for k, we recurse by setting right = k. Otherwise, we recurse by setting left = k+1."
                    },
                    {
                        "username": "tmdgjs2592",
                        "content": "[@arjun202](/arjun202) It is not necessarily true that, when k*h >= sum, koko can eat all piles."
                    },
                    {
                        "username": "arjun202",
                        "content": "Hey I took your tip and tried to solve the question.. can u let me know where y code or logic is failing? Please\\n\\n\\nclass Solution {\\npublic:\\n//helper function to do binary search on k\\nvoid kokoEatsAllBananas(int lo, int hi,int sum, int h,int &ans){\\n         int k = ceil(lo + (hi-lo)/2);\\n         \\n         if(lo>hi) return;\\n         if(k*h >= sum){\\n            ans = k;\\n            kokoEatsAllBananas(lo,k-1,sum,h,ans);\\n         }\\n         else{\\n             kokoEatsAllBananas(k+1,hi,sum,h,ans);\\n         }\\n         return;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n     int size = piles.size();\\n     int sum = 0; for(auto i : piles) sum++;\\n     //k can only range from min[piles] to max[piles]\\n     sort(piles.begin(),piles.end());\\n     int lo = piles[0];\\n     int hi = piles[size-1];\\n     int ans = 0;\\n     kokoEatsAllBananas(lo,hi,sum,h,ans);\\n     return ans;\\n     \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "k is bananas per hour, h is number of hours\\nFor example 1: Given piles = [3,6,7,11], h = 8hrs, if k = 4 ban/hr\\nSince 3 is less than k, only (1hr) is added. The 0th pile took 1 hr;\\nSince 6 is greater than k, Koko can eat k from 6, leaving 6 - k = 2 bananas left and adding (1hr), since 2 is less than 4, add (1hr). The 1st pile took 2 hours.\\nSince 7 > k, 7 - k = 3, add (1hr), 3 < k, add (1hr). The 2nd pile took 2 hours.\\nSince 11 > k, 11 - k = 7, add (1hr), 7 - k = 3, add (1hr), 3 < k, add (1hr). The 3rd pile took 3 hours.\\n\\nFor a total of 1 + 2 + 2 + 3 = 8 hours == h\\nThere\\'s a faster way of doing the above that doesn\\'t involve subtraction.\\n\\nFor example 2: Given piles = [30,11,23,4,20], h = 5, if k = 30 ban/hr.\\nHours Spent = [1, 1, 1, 1, 1]\\n1 + 1 + 1 + 1 + 1 = 5 hours == h\\n\\nFor example 3: Given piles = [30,11,23,4,20], h = 6, if k = 23 ban/hr.\\nHours Spent = [2,1,1,1,1]\\nFor a total of 6 hours == h."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/tag/binary-search/discuss/691825/Binary-Search-for-Beginners-Problems-or-Patterns-or-Sample-solutions"
                    },
                    {
                        "username": "siddhs",
                        "content": "Thank you!.\\nDo you have some more links like this. It will help me in my interview preparation."
                    },
                    {
                        "username": "ashokesen02",
                        "content": "So for this problem I initially chose the range for Binary Search to be [1....10^9] with low=1 and high=10^9 but this gives wrong answer for only one case where  piles =[805306368,805306368,805306368] and h= 1000000000, where the expected output is 3 but my code gives 1. Upon substituting the value of high with max value of the array , it passes all test cases. Can anybody please tell me why this happened?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code count>0 then your code works fine"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Wishing you all a very Happy Holi filled with love and programming success."
                    }
                ]
            },
            {
                "id": 1825750,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "iiiiiiiiiix",
                        "content": "\\u2764\\uFE0F **R.I.P. Koko** (everyone who doesn\\'t know about her should google _Koko the gorilla_).\\nWith her intelligence she could probably solve some LeetCode problems :)\\n\\nCheers to the task authors, you are my soulmates!\\nBest problem statement ever! It makes a heart melt"
                    },
                    {
                        "username": "juxtapo",
                        "content": "I don\\'t understand the question "
                    },
                    {
                        "username": "cennav",
                        "content": "Me neither, I don't feel so bad already"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Hahaha, welcome to a club, guys! "
                    },
                    {
                        "username": "markymarrk",
                        "content": "same here my man"
                    },
                    {
                        "username": "samirhembrom007",
                        "content": "This test case seems to be wrong : [805306368,805306368,805306368]\\nCan someone verify this"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code   count>0 then your code works fine "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "ydt_notfound",
                        "content": "[@RamanV312](/RamanV312) its not out of range but it gives wrong answer for this particular test case\\n"
                    },
                    {
                        "username": "vishalpal1999",
                        "content": "[@RamanV312](/RamanV312) or long in java"
                    },
                    {
                        "username": "RamanV312",
                        "content": "Use long long for count instead of int."
                    },
                    {
                        "username": "baby_groot",
                        "content": "Do you agree ?"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: try binary searching over the solution space. Given a fixed speed k, it is easy to check if Koko can eat all the bananas within h hours. If it works for k, we recurse by setting right = k. Otherwise, we recurse by setting left = k+1."
                    },
                    {
                        "username": "tmdgjs2592",
                        "content": "[@arjun202](/arjun202) It is not necessarily true that, when k*h >= sum, koko can eat all piles."
                    },
                    {
                        "username": "arjun202",
                        "content": "Hey I took your tip and tried to solve the question.. can u let me know where y code or logic is failing? Please\\n\\n\\nclass Solution {\\npublic:\\n//helper function to do binary search on k\\nvoid kokoEatsAllBananas(int lo, int hi,int sum, int h,int &ans){\\n         int k = ceil(lo + (hi-lo)/2);\\n         \\n         if(lo>hi) return;\\n         if(k*h >= sum){\\n            ans = k;\\n            kokoEatsAllBananas(lo,k-1,sum,h,ans);\\n         }\\n         else{\\n             kokoEatsAllBananas(k+1,hi,sum,h,ans);\\n         }\\n         return;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n     int size = piles.size();\\n     int sum = 0; for(auto i : piles) sum++;\\n     //k can only range from min[piles] to max[piles]\\n     sort(piles.begin(),piles.end());\\n     int lo = piles[0];\\n     int hi = piles[size-1];\\n     int ans = 0;\\n     kokoEatsAllBananas(lo,hi,sum,h,ans);\\n     return ans;\\n     \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "k is bananas per hour, h is number of hours\\nFor example 1: Given piles = [3,6,7,11], h = 8hrs, if k = 4 ban/hr\\nSince 3 is less than k, only (1hr) is added. The 0th pile took 1 hr;\\nSince 6 is greater than k, Koko can eat k from 6, leaving 6 - k = 2 bananas left and adding (1hr), since 2 is less than 4, add (1hr). The 1st pile took 2 hours.\\nSince 7 > k, 7 - k = 3, add (1hr), 3 < k, add (1hr). The 2nd pile took 2 hours.\\nSince 11 > k, 11 - k = 7, add (1hr), 7 - k = 3, add (1hr), 3 < k, add (1hr). The 3rd pile took 3 hours.\\n\\nFor a total of 1 + 2 + 2 + 3 = 8 hours == h\\nThere\\'s a faster way of doing the above that doesn\\'t involve subtraction.\\n\\nFor example 2: Given piles = [30,11,23,4,20], h = 5, if k = 30 ban/hr.\\nHours Spent = [1, 1, 1, 1, 1]\\n1 + 1 + 1 + 1 + 1 = 5 hours == h\\n\\nFor example 3: Given piles = [30,11,23,4,20], h = 6, if k = 23 ban/hr.\\nHours Spent = [2,1,1,1,1]\\nFor a total of 6 hours == h."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/tag/binary-search/discuss/691825/Binary-Search-for-Beginners-Problems-or-Patterns-or-Sample-solutions"
                    },
                    {
                        "username": "siddhs",
                        "content": "Thank you!.\\nDo you have some more links like this. It will help me in my interview preparation."
                    },
                    {
                        "username": "ashokesen02",
                        "content": "So for this problem I initially chose the range for Binary Search to be [1....10^9] with low=1 and high=10^9 but this gives wrong answer for only one case where  piles =[805306368,805306368,805306368] and h= 1000000000, where the expected output is 3 but my code gives 1. Upon substituting the value of high with max value of the array , it passes all test cases. Can anybody please tell me why this happened?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code count>0 then your code works fine"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Wishing you all a very Happy Holi filled with love and programming success."
                    }
                ]
            },
            {
                "id": 1567102,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "iiiiiiiiiix",
                        "content": "\\u2764\\uFE0F **R.I.P. Koko** (everyone who doesn\\'t know about her should google _Koko the gorilla_).\\nWith her intelligence she could probably solve some LeetCode problems :)\\n\\nCheers to the task authors, you are my soulmates!\\nBest problem statement ever! It makes a heart melt"
                    },
                    {
                        "username": "juxtapo",
                        "content": "I don\\'t understand the question "
                    },
                    {
                        "username": "cennav",
                        "content": "Me neither, I don't feel so bad already"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Hahaha, welcome to a club, guys! "
                    },
                    {
                        "username": "markymarrk",
                        "content": "same here my man"
                    },
                    {
                        "username": "samirhembrom007",
                        "content": "This test case seems to be wrong : [805306368,805306368,805306368]\\nCan someone verify this"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code   count>0 then your code works fine "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "ydt_notfound",
                        "content": "[@RamanV312](/RamanV312) its not out of range but it gives wrong answer for this particular test case\\n"
                    },
                    {
                        "username": "vishalpal1999",
                        "content": "[@RamanV312](/RamanV312) or long in java"
                    },
                    {
                        "username": "RamanV312",
                        "content": "Use long long for count instead of int."
                    },
                    {
                        "username": "baby_groot",
                        "content": "Do you agree ?"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: try binary searching over the solution space. Given a fixed speed k, it is easy to check if Koko can eat all the bananas within h hours. If it works for k, we recurse by setting right = k. Otherwise, we recurse by setting left = k+1."
                    },
                    {
                        "username": "tmdgjs2592",
                        "content": "[@arjun202](/arjun202) It is not necessarily true that, when k*h >= sum, koko can eat all piles."
                    },
                    {
                        "username": "arjun202",
                        "content": "Hey I took your tip and tried to solve the question.. can u let me know where y code or logic is failing? Please\\n\\n\\nclass Solution {\\npublic:\\n//helper function to do binary search on k\\nvoid kokoEatsAllBananas(int lo, int hi,int sum, int h,int &ans){\\n         int k = ceil(lo + (hi-lo)/2);\\n         \\n         if(lo>hi) return;\\n         if(k*h >= sum){\\n            ans = k;\\n            kokoEatsAllBananas(lo,k-1,sum,h,ans);\\n         }\\n         else{\\n             kokoEatsAllBananas(k+1,hi,sum,h,ans);\\n         }\\n         return;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n     int size = piles.size();\\n     int sum = 0; for(auto i : piles) sum++;\\n     //k can only range from min[piles] to max[piles]\\n     sort(piles.begin(),piles.end());\\n     int lo = piles[0];\\n     int hi = piles[size-1];\\n     int ans = 0;\\n     kokoEatsAllBananas(lo,hi,sum,h,ans);\\n     return ans;\\n     \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "k is bananas per hour, h is number of hours\\nFor example 1: Given piles = [3,6,7,11], h = 8hrs, if k = 4 ban/hr\\nSince 3 is less than k, only (1hr) is added. The 0th pile took 1 hr;\\nSince 6 is greater than k, Koko can eat k from 6, leaving 6 - k = 2 bananas left and adding (1hr), since 2 is less than 4, add (1hr). The 1st pile took 2 hours.\\nSince 7 > k, 7 - k = 3, add (1hr), 3 < k, add (1hr). The 2nd pile took 2 hours.\\nSince 11 > k, 11 - k = 7, add (1hr), 7 - k = 3, add (1hr), 3 < k, add (1hr). The 3rd pile took 3 hours.\\n\\nFor a total of 1 + 2 + 2 + 3 = 8 hours == h\\nThere\\'s a faster way of doing the above that doesn\\'t involve subtraction.\\n\\nFor example 2: Given piles = [30,11,23,4,20], h = 5, if k = 30 ban/hr.\\nHours Spent = [1, 1, 1, 1, 1]\\n1 + 1 + 1 + 1 + 1 = 5 hours == h\\n\\nFor example 3: Given piles = [30,11,23,4,20], h = 6, if k = 23 ban/hr.\\nHours Spent = [2,1,1,1,1]\\nFor a total of 6 hours == h."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/tag/binary-search/discuss/691825/Binary-Search-for-Beginners-Problems-or-Patterns-or-Sample-solutions"
                    },
                    {
                        "username": "siddhs",
                        "content": "Thank you!.\\nDo you have some more links like this. It will help me in my interview preparation."
                    },
                    {
                        "username": "ashokesen02",
                        "content": "So for this problem I initially chose the range for Binary Search to be [1....10^9] with low=1 and high=10^9 but this gives wrong answer for only one case where  piles =[805306368,805306368,805306368] and h= 1000000000, where the expected output is 3 but my code gives 1. Upon substituting the value of high with max value of the array , it passes all test cases. Can anybody please tell me why this happened?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code count>0 then your code works fine"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Wishing you all a very Happy Holi filled with love and programming success."
                    }
                ]
            },
            {
                "id": 1906085,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "iiiiiiiiiix",
                        "content": "\\u2764\\uFE0F **R.I.P. Koko** (everyone who doesn\\'t know about her should google _Koko the gorilla_).\\nWith her intelligence she could probably solve some LeetCode problems :)\\n\\nCheers to the task authors, you are my soulmates!\\nBest problem statement ever! It makes a heart melt"
                    },
                    {
                        "username": "juxtapo",
                        "content": "I don\\'t understand the question "
                    },
                    {
                        "username": "cennav",
                        "content": "Me neither, I don't feel so bad already"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Hahaha, welcome to a club, guys! "
                    },
                    {
                        "username": "markymarrk",
                        "content": "same here my man"
                    },
                    {
                        "username": "samirhembrom007",
                        "content": "This test case seems to be wrong : [805306368,805306368,805306368]\\nCan someone verify this"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code   count>0 then your code works fine "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "ydt_notfound",
                        "content": "[@RamanV312](/RamanV312) its not out of range but it gives wrong answer for this particular test case\\n"
                    },
                    {
                        "username": "vishalpal1999",
                        "content": "[@RamanV312](/RamanV312) or long in java"
                    },
                    {
                        "username": "RamanV312",
                        "content": "Use long long for count instead of int."
                    },
                    {
                        "username": "baby_groot",
                        "content": "Do you agree ?"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: try binary searching over the solution space. Given a fixed speed k, it is easy to check if Koko can eat all the bananas within h hours. If it works for k, we recurse by setting right = k. Otherwise, we recurse by setting left = k+1."
                    },
                    {
                        "username": "tmdgjs2592",
                        "content": "[@arjun202](/arjun202) It is not necessarily true that, when k*h >= sum, koko can eat all piles."
                    },
                    {
                        "username": "arjun202",
                        "content": "Hey I took your tip and tried to solve the question.. can u let me know where y code or logic is failing? Please\\n\\n\\nclass Solution {\\npublic:\\n//helper function to do binary search on k\\nvoid kokoEatsAllBananas(int lo, int hi,int sum, int h,int &ans){\\n         int k = ceil(lo + (hi-lo)/2);\\n         \\n         if(lo>hi) return;\\n         if(k*h >= sum){\\n            ans = k;\\n            kokoEatsAllBananas(lo,k-1,sum,h,ans);\\n         }\\n         else{\\n             kokoEatsAllBananas(k+1,hi,sum,h,ans);\\n         }\\n         return;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n     int size = piles.size();\\n     int sum = 0; for(auto i : piles) sum++;\\n     //k can only range from min[piles] to max[piles]\\n     sort(piles.begin(),piles.end());\\n     int lo = piles[0];\\n     int hi = piles[size-1];\\n     int ans = 0;\\n     kokoEatsAllBananas(lo,hi,sum,h,ans);\\n     return ans;\\n     \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "k is bananas per hour, h is number of hours\\nFor example 1: Given piles = [3,6,7,11], h = 8hrs, if k = 4 ban/hr\\nSince 3 is less than k, only (1hr) is added. The 0th pile took 1 hr;\\nSince 6 is greater than k, Koko can eat k from 6, leaving 6 - k = 2 bananas left and adding (1hr), since 2 is less than 4, add (1hr). The 1st pile took 2 hours.\\nSince 7 > k, 7 - k = 3, add (1hr), 3 < k, add (1hr). The 2nd pile took 2 hours.\\nSince 11 > k, 11 - k = 7, add (1hr), 7 - k = 3, add (1hr), 3 < k, add (1hr). The 3rd pile took 3 hours.\\n\\nFor a total of 1 + 2 + 2 + 3 = 8 hours == h\\nThere\\'s a faster way of doing the above that doesn\\'t involve subtraction.\\n\\nFor example 2: Given piles = [30,11,23,4,20], h = 5, if k = 30 ban/hr.\\nHours Spent = [1, 1, 1, 1, 1]\\n1 + 1 + 1 + 1 + 1 = 5 hours == h\\n\\nFor example 3: Given piles = [30,11,23,4,20], h = 6, if k = 23 ban/hr.\\nHours Spent = [2,1,1,1,1]\\nFor a total of 6 hours == h."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/tag/binary-search/discuss/691825/Binary-Search-for-Beginners-Problems-or-Patterns-or-Sample-solutions"
                    },
                    {
                        "username": "siddhs",
                        "content": "Thank you!.\\nDo you have some more links like this. It will help me in my interview preparation."
                    },
                    {
                        "username": "ashokesen02",
                        "content": "So for this problem I initially chose the range for Binary Search to be [1....10^9] with low=1 and high=10^9 but this gives wrong answer for only one case where  piles =[805306368,805306368,805306368] and h= 1000000000, where the expected output is 3 but my code gives 1. Upon substituting the value of high with max value of the array , it passes all test cases. Can anybody please tell me why this happened?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code count>0 then your code works fine"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Wishing you all a very Happy Holi filled with love and programming success."
                    }
                ]
            },
            {
                "id": 1825728,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "iiiiiiiiiix",
                        "content": "\\u2764\\uFE0F **R.I.P. Koko** (everyone who doesn\\'t know about her should google _Koko the gorilla_).\\nWith her intelligence she could probably solve some LeetCode problems :)\\n\\nCheers to the task authors, you are my soulmates!\\nBest problem statement ever! It makes a heart melt"
                    },
                    {
                        "username": "juxtapo",
                        "content": "I don\\'t understand the question "
                    },
                    {
                        "username": "cennav",
                        "content": "Me neither, I don't feel so bad already"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Hahaha, welcome to a club, guys! "
                    },
                    {
                        "username": "markymarrk",
                        "content": "same here my man"
                    },
                    {
                        "username": "samirhembrom007",
                        "content": "This test case seems to be wrong : [805306368,805306368,805306368]\\nCan someone verify this"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code   count>0 then your code works fine "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "ydt_notfound",
                        "content": "[@RamanV312](/RamanV312) its not out of range but it gives wrong answer for this particular test case\\n"
                    },
                    {
                        "username": "vishalpal1999",
                        "content": "[@RamanV312](/RamanV312) or long in java"
                    },
                    {
                        "username": "RamanV312",
                        "content": "Use long long for count instead of int."
                    },
                    {
                        "username": "baby_groot",
                        "content": "Do you agree ?"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: try binary searching over the solution space. Given a fixed speed k, it is easy to check if Koko can eat all the bananas within h hours. If it works for k, we recurse by setting right = k. Otherwise, we recurse by setting left = k+1."
                    },
                    {
                        "username": "tmdgjs2592",
                        "content": "[@arjun202](/arjun202) It is not necessarily true that, when k*h >= sum, koko can eat all piles."
                    },
                    {
                        "username": "arjun202",
                        "content": "Hey I took your tip and tried to solve the question.. can u let me know where y code or logic is failing? Please\\n\\n\\nclass Solution {\\npublic:\\n//helper function to do binary search on k\\nvoid kokoEatsAllBananas(int lo, int hi,int sum, int h,int &ans){\\n         int k = ceil(lo + (hi-lo)/2);\\n         \\n         if(lo>hi) return;\\n         if(k*h >= sum){\\n            ans = k;\\n            kokoEatsAllBananas(lo,k-1,sum,h,ans);\\n         }\\n         else{\\n             kokoEatsAllBananas(k+1,hi,sum,h,ans);\\n         }\\n         return;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n     int size = piles.size();\\n     int sum = 0; for(auto i : piles) sum++;\\n     //k can only range from min[piles] to max[piles]\\n     sort(piles.begin(),piles.end());\\n     int lo = piles[0];\\n     int hi = piles[size-1];\\n     int ans = 0;\\n     kokoEatsAllBananas(lo,hi,sum,h,ans);\\n     return ans;\\n     \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "k is bananas per hour, h is number of hours\\nFor example 1: Given piles = [3,6,7,11], h = 8hrs, if k = 4 ban/hr\\nSince 3 is less than k, only (1hr) is added. The 0th pile took 1 hr;\\nSince 6 is greater than k, Koko can eat k from 6, leaving 6 - k = 2 bananas left and adding (1hr), since 2 is less than 4, add (1hr). The 1st pile took 2 hours.\\nSince 7 > k, 7 - k = 3, add (1hr), 3 < k, add (1hr). The 2nd pile took 2 hours.\\nSince 11 > k, 11 - k = 7, add (1hr), 7 - k = 3, add (1hr), 3 < k, add (1hr). The 3rd pile took 3 hours.\\n\\nFor a total of 1 + 2 + 2 + 3 = 8 hours == h\\nThere\\'s a faster way of doing the above that doesn\\'t involve subtraction.\\n\\nFor example 2: Given piles = [30,11,23,4,20], h = 5, if k = 30 ban/hr.\\nHours Spent = [1, 1, 1, 1, 1]\\n1 + 1 + 1 + 1 + 1 = 5 hours == h\\n\\nFor example 3: Given piles = [30,11,23,4,20], h = 6, if k = 23 ban/hr.\\nHours Spent = [2,1,1,1,1]\\nFor a total of 6 hours == h."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/tag/binary-search/discuss/691825/Binary-Search-for-Beginners-Problems-or-Patterns-or-Sample-solutions"
                    },
                    {
                        "username": "siddhs",
                        "content": "Thank you!.\\nDo you have some more links like this. It will help me in my interview preparation."
                    },
                    {
                        "username": "ashokesen02",
                        "content": "So for this problem I initially chose the range for Binary Search to be [1....10^9] with low=1 and high=10^9 but this gives wrong answer for only one case where  piles =[805306368,805306368,805306368] and h= 1000000000, where the expected output is 3 but my code gives 1. Upon substituting the value of high with max value of the array , it passes all test cases. Can anybody please tell me why this happened?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code count>0 then your code works fine"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Wishing you all a very Happy Holi filled with love and programming success."
                    }
                ]
            },
            {
                "id": 1987965,
                "content": [
                    {
                        "username": "agforero",
                        "content": "monke"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "Is anybody getting wrong ans for Test case 124/125 \\npiles[]= [805306368,805306368,805306368] and h=1000000000"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "[@saakshikobarne](/saakshikobarne)  I was using the binary search to calculate the time koko takes to eat the bananas but i was using time<=h as a checking parameter instead i used (time<= h && time>0) , this resolved this testcase for me!"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Yes, I had the same doubt, I did it with my binary search code but it was not working on this testcase only and when I used the exact same code from a solution post it was working fine. I didn\\'t get it why but the code and mine were exactly the same still mine was failing this testcase."
                    },
                    {
                        "username": "_aavash_",
                        "content": "for piles = [805306368,805306368,805306368], h= 1000000000, output is 1 but expected is 3. Please help \\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        long start = 1;\\n        long end = 0;\\n        long sum=0;\\n\\n        for (int i = 0; i < piles.length; i++) {\\n            end = Math.max(piles[i], end);\\n            sum+= piles[i];\\n        }\\n        long ans = -1;\\n\\n        while (start <= end) {\\n            long mid = start + (end - start) / 2;\\n            int value = 0;\\n\\n            for (int i = 0; i < piles.length; i++) {\\n                value += (int) Math.ceil((double) piles[i] / mid);\\n            }\\n\\n            if (value > h) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@idkbro191](/idkbro191) I didn\\'t understand brother.\\n\\nEven if we cast or not, we\\'re anyway storing the value in int only, then how it works?"
                    },
                    {
                        "username": "idkbro191",
                        "content": "You must not cast the result of \"value\" into int before adding it as it goes out of the range of int:\n\n\"value += (int) Math.ceil((double) piles[i] / mid);\"\n\nRemove (int) and it should work fine. \n\n\"value += Math.ceil((double) piles[i] / mid);\""
                    },
                    {
                        "username": "Sggirb",
                        "content": "In the binary search solution, the runtime analysis seems to be O(nlog(k)) where n = number of piles and k = maximum bananas in a pile. Though, if k is bound by the constraint: 1 <= k <= 10^9 as stated in the problem statement, then could it be considered a constant? It doesn\\'t scale in any way as the input size does (n). If that\\'s the case, then shouldn\\'t the binary search solution be O(n)? (O(nlog(k)) -> O(nlog(10^9)) ~ O(n*30) -> O(n))"
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@jcmf](/jcmf) bro you are literally bigger bot than chatgpt"
                    },
                    {
                        "username": "jcmf",
                        "content": "Oh geez, you are so right about this, don\\'t get me started. More generally, the log base 2 of any 64-bit integer is bounded above by 64, a reasonably small constant. Why, then, does anyone ever bother including factors of log(n) when doing complexity analysis? It\\'s ridiculous, right? I think so! Anyway turns out it\\'s because the underlying mathematical formalism of big O complexity is based on the assumption that n (or m or k or however many other variables we have going on) can approach infinity (in the calculus sense), and that\\'s the behavior we\\'re interested in. And the limit as k approaches infinity of log(k) is, irritatingly enough, still infinity. I doubt it is possible for you hate this more than I do, but it\\'s still true. (And yet we still almost always pretend that any simple arithmetic operation, such as adding two numbers, can be done in constant time, presumably because that\\'s how it almost always works in real life and we\\'d come to the wrong conclusion if we assumed otherwise. These are contradictory assumptions, but never mind!) More practically speaking, a factor of log(k) can matter a great deal if one is trying to get a sense of how an algorithm is likely to perform with a large k after benchmarking it with smaller k. Sometimes the factor of log can be safely ignored in a certain situation or domain, but that\\'s not always a safe assumption -- it\\'s a bit like how occasionally a polynomial- or exponential-time algorithm will perform better than a linear time one. Gotta watch out. In the end, real-life computers are finite state machines, and any number involved in any real-life computation is always going to be bounded above by *some* constant in practice, but throwing up our hands and classifying every algorithm as O(1) is just not very useful or even fun, even though it might sound incredibly tempting at first. As a purely practical matter, if we\\'re not sure if the factor of log(k) is going to matter, it\\'s usually a safer bet to hold onto it than to discard it. Never know when you might need it. Leetcode is exactly the right kind of place to find absolutely merciless concrete examples of this."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "No, because k is a variable that is given and not constant. Therefore, the runtime of the code can vary, sometimes running in O(2n), other times in O(8n), and in the worst case, O(30n). If k were always O(30n), then the binary search solution would be O(n), but because k is a variable, the runtime complexity is O(n*log(n))."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko don\\'t eat that many bananas, they\\'re radioactive and shit"
                    },
                    {
                        "username": "sam2611",
                        "content": "Take a look at this article,  very helpful for solving more such types of questions. \n(https://leetcode.com/discuss/interview-question/3725477/binary-search-on-answer-koko-type)"
                    },
                    {
                        "username": "5441anr",
                        "content": "wen monke dun eat banan, das a beeg problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "Tight!  ..  Tight! Tight! Hey .. Koko, Trips, Lolo whatever man, Just keep bringing these Binary Search questions!"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "When You understand the Binary Search on Predicate functions these problems will be like cake walk for you, btw Happy Holi to all :)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Don\\'t make my mistake :) Sorting is not required here."
                    }
                ]
            },
            {
                "id": 1980785,
                "content": [
                    {
                        "username": "agforero",
                        "content": "monke"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "Is anybody getting wrong ans for Test case 124/125 \\npiles[]= [805306368,805306368,805306368] and h=1000000000"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "[@saakshikobarne](/saakshikobarne)  I was using the binary search to calculate the time koko takes to eat the bananas but i was using time<=h as a checking parameter instead i used (time<= h && time>0) , this resolved this testcase for me!"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Yes, I had the same doubt, I did it with my binary search code but it was not working on this testcase only and when I used the exact same code from a solution post it was working fine. I didn\\'t get it why but the code and mine were exactly the same still mine was failing this testcase."
                    },
                    {
                        "username": "_aavash_",
                        "content": "for piles = [805306368,805306368,805306368], h= 1000000000, output is 1 but expected is 3. Please help \\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        long start = 1;\\n        long end = 0;\\n        long sum=0;\\n\\n        for (int i = 0; i < piles.length; i++) {\\n            end = Math.max(piles[i], end);\\n            sum+= piles[i];\\n        }\\n        long ans = -1;\\n\\n        while (start <= end) {\\n            long mid = start + (end - start) / 2;\\n            int value = 0;\\n\\n            for (int i = 0; i < piles.length; i++) {\\n                value += (int) Math.ceil((double) piles[i] / mid);\\n            }\\n\\n            if (value > h) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@idkbro191](/idkbro191) I didn\\'t understand brother.\\n\\nEven if we cast or not, we\\'re anyway storing the value in int only, then how it works?"
                    },
                    {
                        "username": "idkbro191",
                        "content": "You must not cast the result of \"value\" into int before adding it as it goes out of the range of int:\n\n\"value += (int) Math.ceil((double) piles[i] / mid);\"\n\nRemove (int) and it should work fine. \n\n\"value += Math.ceil((double) piles[i] / mid);\""
                    },
                    {
                        "username": "Sggirb",
                        "content": "In the binary search solution, the runtime analysis seems to be O(nlog(k)) where n = number of piles and k = maximum bananas in a pile. Though, if k is bound by the constraint: 1 <= k <= 10^9 as stated in the problem statement, then could it be considered a constant? It doesn\\'t scale in any way as the input size does (n). If that\\'s the case, then shouldn\\'t the binary search solution be O(n)? (O(nlog(k)) -> O(nlog(10^9)) ~ O(n*30) -> O(n))"
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@jcmf](/jcmf) bro you are literally bigger bot than chatgpt"
                    },
                    {
                        "username": "jcmf",
                        "content": "Oh geez, you are so right about this, don\\'t get me started. More generally, the log base 2 of any 64-bit integer is bounded above by 64, a reasonably small constant. Why, then, does anyone ever bother including factors of log(n) when doing complexity analysis? It\\'s ridiculous, right? I think so! Anyway turns out it\\'s because the underlying mathematical formalism of big O complexity is based on the assumption that n (or m or k or however many other variables we have going on) can approach infinity (in the calculus sense), and that\\'s the behavior we\\'re interested in. And the limit as k approaches infinity of log(k) is, irritatingly enough, still infinity. I doubt it is possible for you hate this more than I do, but it\\'s still true. (And yet we still almost always pretend that any simple arithmetic operation, such as adding two numbers, can be done in constant time, presumably because that\\'s how it almost always works in real life and we\\'d come to the wrong conclusion if we assumed otherwise. These are contradictory assumptions, but never mind!) More practically speaking, a factor of log(k) can matter a great deal if one is trying to get a sense of how an algorithm is likely to perform with a large k after benchmarking it with smaller k. Sometimes the factor of log can be safely ignored in a certain situation or domain, but that\\'s not always a safe assumption -- it\\'s a bit like how occasionally a polynomial- or exponential-time algorithm will perform better than a linear time one. Gotta watch out. In the end, real-life computers are finite state machines, and any number involved in any real-life computation is always going to be bounded above by *some* constant in practice, but throwing up our hands and classifying every algorithm as O(1) is just not very useful or even fun, even though it might sound incredibly tempting at first. As a purely practical matter, if we\\'re not sure if the factor of log(k) is going to matter, it\\'s usually a safer bet to hold onto it than to discard it. Never know when you might need it. Leetcode is exactly the right kind of place to find absolutely merciless concrete examples of this."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "No, because k is a variable that is given and not constant. Therefore, the runtime of the code can vary, sometimes running in O(2n), other times in O(8n), and in the worst case, O(30n). If k were always O(30n), then the binary search solution would be O(n), but because k is a variable, the runtime complexity is O(n*log(n))."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko don\\'t eat that many bananas, they\\'re radioactive and shit"
                    },
                    {
                        "username": "sam2611",
                        "content": "Take a look at this article,  very helpful for solving more such types of questions. \n(https://leetcode.com/discuss/interview-question/3725477/binary-search-on-answer-koko-type)"
                    },
                    {
                        "username": "5441anr",
                        "content": "wen monke dun eat banan, das a beeg problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "Tight!  ..  Tight! Tight! Hey .. Koko, Trips, Lolo whatever man, Just keep bringing these Binary Search questions!"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "When You understand the Binary Search on Predicate functions these problems will be like cake walk for you, btw Happy Holi to all :)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Don\\'t make my mistake :) Sorting is not required here."
                    }
                ]
            },
            {
                "id": 1937865,
                "content": [
                    {
                        "username": "agforero",
                        "content": "monke"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "Is anybody getting wrong ans for Test case 124/125 \\npiles[]= [805306368,805306368,805306368] and h=1000000000"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "[@saakshikobarne](/saakshikobarne)  I was using the binary search to calculate the time koko takes to eat the bananas but i was using time<=h as a checking parameter instead i used (time<= h && time>0) , this resolved this testcase for me!"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Yes, I had the same doubt, I did it with my binary search code but it was not working on this testcase only and when I used the exact same code from a solution post it was working fine. I didn\\'t get it why but the code and mine were exactly the same still mine was failing this testcase."
                    },
                    {
                        "username": "_aavash_",
                        "content": "for piles = [805306368,805306368,805306368], h= 1000000000, output is 1 but expected is 3. Please help \\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        long start = 1;\\n        long end = 0;\\n        long sum=0;\\n\\n        for (int i = 0; i < piles.length; i++) {\\n            end = Math.max(piles[i], end);\\n            sum+= piles[i];\\n        }\\n        long ans = -1;\\n\\n        while (start <= end) {\\n            long mid = start + (end - start) / 2;\\n            int value = 0;\\n\\n            for (int i = 0; i < piles.length; i++) {\\n                value += (int) Math.ceil((double) piles[i] / mid);\\n            }\\n\\n            if (value > h) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@idkbro191](/idkbro191) I didn\\'t understand brother.\\n\\nEven if we cast or not, we\\'re anyway storing the value in int only, then how it works?"
                    },
                    {
                        "username": "idkbro191",
                        "content": "You must not cast the result of \"value\" into int before adding it as it goes out of the range of int:\n\n\"value += (int) Math.ceil((double) piles[i] / mid);\"\n\nRemove (int) and it should work fine. \n\n\"value += Math.ceil((double) piles[i] / mid);\""
                    },
                    {
                        "username": "Sggirb",
                        "content": "In the binary search solution, the runtime analysis seems to be O(nlog(k)) where n = number of piles and k = maximum bananas in a pile. Though, if k is bound by the constraint: 1 <= k <= 10^9 as stated in the problem statement, then could it be considered a constant? It doesn\\'t scale in any way as the input size does (n). If that\\'s the case, then shouldn\\'t the binary search solution be O(n)? (O(nlog(k)) -> O(nlog(10^9)) ~ O(n*30) -> O(n))"
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@jcmf](/jcmf) bro you are literally bigger bot than chatgpt"
                    },
                    {
                        "username": "jcmf",
                        "content": "Oh geez, you are so right about this, don\\'t get me started. More generally, the log base 2 of any 64-bit integer is bounded above by 64, a reasonably small constant. Why, then, does anyone ever bother including factors of log(n) when doing complexity analysis? It\\'s ridiculous, right? I think so! Anyway turns out it\\'s because the underlying mathematical formalism of big O complexity is based on the assumption that n (or m or k or however many other variables we have going on) can approach infinity (in the calculus sense), and that\\'s the behavior we\\'re interested in. And the limit as k approaches infinity of log(k) is, irritatingly enough, still infinity. I doubt it is possible for you hate this more than I do, but it\\'s still true. (And yet we still almost always pretend that any simple arithmetic operation, such as adding two numbers, can be done in constant time, presumably because that\\'s how it almost always works in real life and we\\'d come to the wrong conclusion if we assumed otherwise. These are contradictory assumptions, but never mind!) More practically speaking, a factor of log(k) can matter a great deal if one is trying to get a sense of how an algorithm is likely to perform with a large k after benchmarking it with smaller k. Sometimes the factor of log can be safely ignored in a certain situation or domain, but that\\'s not always a safe assumption -- it\\'s a bit like how occasionally a polynomial- or exponential-time algorithm will perform better than a linear time one. Gotta watch out. In the end, real-life computers are finite state machines, and any number involved in any real-life computation is always going to be bounded above by *some* constant in practice, but throwing up our hands and classifying every algorithm as O(1) is just not very useful or even fun, even though it might sound incredibly tempting at first. As a purely practical matter, if we\\'re not sure if the factor of log(k) is going to matter, it\\'s usually a safer bet to hold onto it than to discard it. Never know when you might need it. Leetcode is exactly the right kind of place to find absolutely merciless concrete examples of this."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "No, because k is a variable that is given and not constant. Therefore, the runtime of the code can vary, sometimes running in O(2n), other times in O(8n), and in the worst case, O(30n). If k were always O(30n), then the binary search solution would be O(n), but because k is a variable, the runtime complexity is O(n*log(n))."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko don\\'t eat that many bananas, they\\'re radioactive and shit"
                    },
                    {
                        "username": "sam2611",
                        "content": "Take a look at this article,  very helpful for solving more such types of questions. \n(https://leetcode.com/discuss/interview-question/3725477/binary-search-on-answer-koko-type)"
                    },
                    {
                        "username": "5441anr",
                        "content": "wen monke dun eat banan, das a beeg problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "Tight!  ..  Tight! Tight! Hey .. Koko, Trips, Lolo whatever man, Just keep bringing these Binary Search questions!"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "When You understand the Binary Search on Predicate functions these problems will be like cake walk for you, btw Happy Holi to all :)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Don\\'t make my mistake :) Sorting is not required here."
                    }
                ]
            },
            {
                "id": 1740170,
                "content": [
                    {
                        "username": "agforero",
                        "content": "monke"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "Is anybody getting wrong ans for Test case 124/125 \\npiles[]= [805306368,805306368,805306368] and h=1000000000"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "[@saakshikobarne](/saakshikobarne)  I was using the binary search to calculate the time koko takes to eat the bananas but i was using time<=h as a checking parameter instead i used (time<= h && time>0) , this resolved this testcase for me!"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Yes, I had the same doubt, I did it with my binary search code but it was not working on this testcase only and when I used the exact same code from a solution post it was working fine. I didn\\'t get it why but the code and mine were exactly the same still mine was failing this testcase."
                    },
                    {
                        "username": "_aavash_",
                        "content": "for piles = [805306368,805306368,805306368], h= 1000000000, output is 1 but expected is 3. Please help \\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        long start = 1;\\n        long end = 0;\\n        long sum=0;\\n\\n        for (int i = 0; i < piles.length; i++) {\\n            end = Math.max(piles[i], end);\\n            sum+= piles[i];\\n        }\\n        long ans = -1;\\n\\n        while (start <= end) {\\n            long mid = start + (end - start) / 2;\\n            int value = 0;\\n\\n            for (int i = 0; i < piles.length; i++) {\\n                value += (int) Math.ceil((double) piles[i] / mid);\\n            }\\n\\n            if (value > h) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@idkbro191](/idkbro191) I didn\\'t understand brother.\\n\\nEven if we cast or not, we\\'re anyway storing the value in int only, then how it works?"
                    },
                    {
                        "username": "idkbro191",
                        "content": "You must not cast the result of \"value\" into int before adding it as it goes out of the range of int:\n\n\"value += (int) Math.ceil((double) piles[i] / mid);\"\n\nRemove (int) and it should work fine. \n\n\"value += Math.ceil((double) piles[i] / mid);\""
                    },
                    {
                        "username": "Sggirb",
                        "content": "In the binary search solution, the runtime analysis seems to be O(nlog(k)) where n = number of piles and k = maximum bananas in a pile. Though, if k is bound by the constraint: 1 <= k <= 10^9 as stated in the problem statement, then could it be considered a constant? It doesn\\'t scale in any way as the input size does (n). If that\\'s the case, then shouldn\\'t the binary search solution be O(n)? (O(nlog(k)) -> O(nlog(10^9)) ~ O(n*30) -> O(n))"
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@jcmf](/jcmf) bro you are literally bigger bot than chatgpt"
                    },
                    {
                        "username": "jcmf",
                        "content": "Oh geez, you are so right about this, don\\'t get me started. More generally, the log base 2 of any 64-bit integer is bounded above by 64, a reasonably small constant. Why, then, does anyone ever bother including factors of log(n) when doing complexity analysis? It\\'s ridiculous, right? I think so! Anyway turns out it\\'s because the underlying mathematical formalism of big O complexity is based on the assumption that n (or m or k or however many other variables we have going on) can approach infinity (in the calculus sense), and that\\'s the behavior we\\'re interested in. And the limit as k approaches infinity of log(k) is, irritatingly enough, still infinity. I doubt it is possible for you hate this more than I do, but it\\'s still true. (And yet we still almost always pretend that any simple arithmetic operation, such as adding two numbers, can be done in constant time, presumably because that\\'s how it almost always works in real life and we\\'d come to the wrong conclusion if we assumed otherwise. These are contradictory assumptions, but never mind!) More practically speaking, a factor of log(k) can matter a great deal if one is trying to get a sense of how an algorithm is likely to perform with a large k after benchmarking it with smaller k. Sometimes the factor of log can be safely ignored in a certain situation or domain, but that\\'s not always a safe assumption -- it\\'s a bit like how occasionally a polynomial- or exponential-time algorithm will perform better than a linear time one. Gotta watch out. In the end, real-life computers are finite state machines, and any number involved in any real-life computation is always going to be bounded above by *some* constant in practice, but throwing up our hands and classifying every algorithm as O(1) is just not very useful or even fun, even though it might sound incredibly tempting at first. As a purely practical matter, if we\\'re not sure if the factor of log(k) is going to matter, it\\'s usually a safer bet to hold onto it than to discard it. Never know when you might need it. Leetcode is exactly the right kind of place to find absolutely merciless concrete examples of this."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "No, because k is a variable that is given and not constant. Therefore, the runtime of the code can vary, sometimes running in O(2n), other times in O(8n), and in the worst case, O(30n). If k were always O(30n), then the binary search solution would be O(n), but because k is a variable, the runtime complexity is O(n*log(n))."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko don\\'t eat that many bananas, they\\'re radioactive and shit"
                    },
                    {
                        "username": "sam2611",
                        "content": "Take a look at this article,  very helpful for solving more such types of questions. \n(https://leetcode.com/discuss/interview-question/3725477/binary-search-on-answer-koko-type)"
                    },
                    {
                        "username": "5441anr",
                        "content": "wen monke dun eat banan, das a beeg problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "Tight!  ..  Tight! Tight! Hey .. Koko, Trips, Lolo whatever man, Just keep bringing these Binary Search questions!"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "When You understand the Binary Search on Predicate functions these problems will be like cake walk for you, btw Happy Holi to all :)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Don\\'t make my mistake :) Sorting is not required here."
                    }
                ]
            },
            {
                "id": 1970862,
                "content": [
                    {
                        "username": "agforero",
                        "content": "monke"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "Is anybody getting wrong ans for Test case 124/125 \\npiles[]= [805306368,805306368,805306368] and h=1000000000"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "[@saakshikobarne](/saakshikobarne)  I was using the binary search to calculate the time koko takes to eat the bananas but i was using time<=h as a checking parameter instead i used (time<= h && time>0) , this resolved this testcase for me!"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Yes, I had the same doubt, I did it with my binary search code but it was not working on this testcase only and when I used the exact same code from a solution post it was working fine. I didn\\'t get it why but the code and mine were exactly the same still mine was failing this testcase."
                    },
                    {
                        "username": "_aavash_",
                        "content": "for piles = [805306368,805306368,805306368], h= 1000000000, output is 1 but expected is 3. Please help \\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        long start = 1;\\n        long end = 0;\\n        long sum=0;\\n\\n        for (int i = 0; i < piles.length; i++) {\\n            end = Math.max(piles[i], end);\\n            sum+= piles[i];\\n        }\\n        long ans = -1;\\n\\n        while (start <= end) {\\n            long mid = start + (end - start) / 2;\\n            int value = 0;\\n\\n            for (int i = 0; i < piles.length; i++) {\\n                value += (int) Math.ceil((double) piles[i] / mid);\\n            }\\n\\n            if (value > h) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@idkbro191](/idkbro191) I didn\\'t understand brother.\\n\\nEven if we cast or not, we\\'re anyway storing the value in int only, then how it works?"
                    },
                    {
                        "username": "idkbro191",
                        "content": "You must not cast the result of \"value\" into int before adding it as it goes out of the range of int:\n\n\"value += (int) Math.ceil((double) piles[i] / mid);\"\n\nRemove (int) and it should work fine. \n\n\"value += Math.ceil((double) piles[i] / mid);\""
                    },
                    {
                        "username": "Sggirb",
                        "content": "In the binary search solution, the runtime analysis seems to be O(nlog(k)) where n = number of piles and k = maximum bananas in a pile. Though, if k is bound by the constraint: 1 <= k <= 10^9 as stated in the problem statement, then could it be considered a constant? It doesn\\'t scale in any way as the input size does (n). If that\\'s the case, then shouldn\\'t the binary search solution be O(n)? (O(nlog(k)) -> O(nlog(10^9)) ~ O(n*30) -> O(n))"
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@jcmf](/jcmf) bro you are literally bigger bot than chatgpt"
                    },
                    {
                        "username": "jcmf",
                        "content": "Oh geez, you are so right about this, don\\'t get me started. More generally, the log base 2 of any 64-bit integer is bounded above by 64, a reasonably small constant. Why, then, does anyone ever bother including factors of log(n) when doing complexity analysis? It\\'s ridiculous, right? I think so! Anyway turns out it\\'s because the underlying mathematical formalism of big O complexity is based on the assumption that n (or m or k or however many other variables we have going on) can approach infinity (in the calculus sense), and that\\'s the behavior we\\'re interested in. And the limit as k approaches infinity of log(k) is, irritatingly enough, still infinity. I doubt it is possible for you hate this more than I do, but it\\'s still true. (And yet we still almost always pretend that any simple arithmetic operation, such as adding two numbers, can be done in constant time, presumably because that\\'s how it almost always works in real life and we\\'d come to the wrong conclusion if we assumed otherwise. These are contradictory assumptions, but never mind!) More practically speaking, a factor of log(k) can matter a great deal if one is trying to get a sense of how an algorithm is likely to perform with a large k after benchmarking it with smaller k. Sometimes the factor of log can be safely ignored in a certain situation or domain, but that\\'s not always a safe assumption -- it\\'s a bit like how occasionally a polynomial- or exponential-time algorithm will perform better than a linear time one. Gotta watch out. In the end, real-life computers are finite state machines, and any number involved in any real-life computation is always going to be bounded above by *some* constant in practice, but throwing up our hands and classifying every algorithm as O(1) is just not very useful or even fun, even though it might sound incredibly tempting at first. As a purely practical matter, if we\\'re not sure if the factor of log(k) is going to matter, it\\'s usually a safer bet to hold onto it than to discard it. Never know when you might need it. Leetcode is exactly the right kind of place to find absolutely merciless concrete examples of this."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "No, because k is a variable that is given and not constant. Therefore, the runtime of the code can vary, sometimes running in O(2n), other times in O(8n), and in the worst case, O(30n). If k were always O(30n), then the binary search solution would be O(n), but because k is a variable, the runtime complexity is O(n*log(n))."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko don\\'t eat that many bananas, they\\'re radioactive and shit"
                    },
                    {
                        "username": "sam2611",
                        "content": "Take a look at this article,  very helpful for solving more such types of questions. \n(https://leetcode.com/discuss/interview-question/3725477/binary-search-on-answer-koko-type)"
                    },
                    {
                        "username": "5441anr",
                        "content": "wen monke dun eat banan, das a beeg problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "Tight!  ..  Tight! Tight! Hey .. Koko, Trips, Lolo whatever man, Just keep bringing these Binary Search questions!"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "When You understand the Binary Search on Predicate functions these problems will be like cake walk for you, btw Happy Holi to all :)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Don\\'t make my mistake :) Sorting is not required here."
                    }
                ]
            },
            {
                "id": 1958314,
                "content": [
                    {
                        "username": "agforero",
                        "content": "monke"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "Is anybody getting wrong ans for Test case 124/125 \\npiles[]= [805306368,805306368,805306368] and h=1000000000"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "[@saakshikobarne](/saakshikobarne)  I was using the binary search to calculate the time koko takes to eat the bananas but i was using time<=h as a checking parameter instead i used (time<= h && time>0) , this resolved this testcase for me!"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Yes, I had the same doubt, I did it with my binary search code but it was not working on this testcase only and when I used the exact same code from a solution post it was working fine. I didn\\'t get it why but the code and mine were exactly the same still mine was failing this testcase."
                    },
                    {
                        "username": "_aavash_",
                        "content": "for piles = [805306368,805306368,805306368], h= 1000000000, output is 1 but expected is 3. Please help \\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        long start = 1;\\n        long end = 0;\\n        long sum=0;\\n\\n        for (int i = 0; i < piles.length; i++) {\\n            end = Math.max(piles[i], end);\\n            sum+= piles[i];\\n        }\\n        long ans = -1;\\n\\n        while (start <= end) {\\n            long mid = start + (end - start) / 2;\\n            int value = 0;\\n\\n            for (int i = 0; i < piles.length; i++) {\\n                value += (int) Math.ceil((double) piles[i] / mid);\\n            }\\n\\n            if (value > h) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@idkbro191](/idkbro191) I didn\\'t understand brother.\\n\\nEven if we cast or not, we\\'re anyway storing the value in int only, then how it works?"
                    },
                    {
                        "username": "idkbro191",
                        "content": "You must not cast the result of \"value\" into int before adding it as it goes out of the range of int:\n\n\"value += (int) Math.ceil((double) piles[i] / mid);\"\n\nRemove (int) and it should work fine. \n\n\"value += Math.ceil((double) piles[i] / mid);\""
                    },
                    {
                        "username": "Sggirb",
                        "content": "In the binary search solution, the runtime analysis seems to be O(nlog(k)) where n = number of piles and k = maximum bananas in a pile. Though, if k is bound by the constraint: 1 <= k <= 10^9 as stated in the problem statement, then could it be considered a constant? It doesn\\'t scale in any way as the input size does (n). If that\\'s the case, then shouldn\\'t the binary search solution be O(n)? (O(nlog(k)) -> O(nlog(10^9)) ~ O(n*30) -> O(n))"
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@jcmf](/jcmf) bro you are literally bigger bot than chatgpt"
                    },
                    {
                        "username": "jcmf",
                        "content": "Oh geez, you are so right about this, don\\'t get me started. More generally, the log base 2 of any 64-bit integer is bounded above by 64, a reasonably small constant. Why, then, does anyone ever bother including factors of log(n) when doing complexity analysis? It\\'s ridiculous, right? I think so! Anyway turns out it\\'s because the underlying mathematical formalism of big O complexity is based on the assumption that n (or m or k or however many other variables we have going on) can approach infinity (in the calculus sense), and that\\'s the behavior we\\'re interested in. And the limit as k approaches infinity of log(k) is, irritatingly enough, still infinity. I doubt it is possible for you hate this more than I do, but it\\'s still true. (And yet we still almost always pretend that any simple arithmetic operation, such as adding two numbers, can be done in constant time, presumably because that\\'s how it almost always works in real life and we\\'d come to the wrong conclusion if we assumed otherwise. These are contradictory assumptions, but never mind!) More practically speaking, a factor of log(k) can matter a great deal if one is trying to get a sense of how an algorithm is likely to perform with a large k after benchmarking it with smaller k. Sometimes the factor of log can be safely ignored in a certain situation or domain, but that\\'s not always a safe assumption -- it\\'s a bit like how occasionally a polynomial- or exponential-time algorithm will perform better than a linear time one. Gotta watch out. In the end, real-life computers are finite state machines, and any number involved in any real-life computation is always going to be bounded above by *some* constant in practice, but throwing up our hands and classifying every algorithm as O(1) is just not very useful or even fun, even though it might sound incredibly tempting at first. As a purely practical matter, if we\\'re not sure if the factor of log(k) is going to matter, it\\'s usually a safer bet to hold onto it than to discard it. Never know when you might need it. Leetcode is exactly the right kind of place to find absolutely merciless concrete examples of this."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "No, because k is a variable that is given and not constant. Therefore, the runtime of the code can vary, sometimes running in O(2n), other times in O(8n), and in the worst case, O(30n). If k were always O(30n), then the binary search solution would be O(n), but because k is a variable, the runtime complexity is O(n*log(n))."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko don\\'t eat that many bananas, they\\'re radioactive and shit"
                    },
                    {
                        "username": "sam2611",
                        "content": "Take a look at this article,  very helpful for solving more such types of questions. \n(https://leetcode.com/discuss/interview-question/3725477/binary-search-on-answer-koko-type)"
                    },
                    {
                        "username": "5441anr",
                        "content": "wen monke dun eat banan, das a beeg problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "Tight!  ..  Tight! Tight! Hey .. Koko, Trips, Lolo whatever man, Just keep bringing these Binary Search questions!"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "When You understand the Binary Search on Predicate functions these problems will be like cake walk for you, btw Happy Holi to all :)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Don\\'t make my mistake :) Sorting is not required here."
                    }
                ]
            },
            {
                "id": 1954615,
                "content": [
                    {
                        "username": "agforero",
                        "content": "monke"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "Is anybody getting wrong ans for Test case 124/125 \\npiles[]= [805306368,805306368,805306368] and h=1000000000"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "[@saakshikobarne](/saakshikobarne)  I was using the binary search to calculate the time koko takes to eat the bananas but i was using time<=h as a checking parameter instead i used (time<= h && time>0) , this resolved this testcase for me!"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Yes, I had the same doubt, I did it with my binary search code but it was not working on this testcase only and when I used the exact same code from a solution post it was working fine. I didn\\'t get it why but the code and mine were exactly the same still mine was failing this testcase."
                    },
                    {
                        "username": "_aavash_",
                        "content": "for piles = [805306368,805306368,805306368], h= 1000000000, output is 1 but expected is 3. Please help \\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        long start = 1;\\n        long end = 0;\\n        long sum=0;\\n\\n        for (int i = 0; i < piles.length; i++) {\\n            end = Math.max(piles[i], end);\\n            sum+= piles[i];\\n        }\\n        long ans = -1;\\n\\n        while (start <= end) {\\n            long mid = start + (end - start) / 2;\\n            int value = 0;\\n\\n            for (int i = 0; i < piles.length; i++) {\\n                value += (int) Math.ceil((double) piles[i] / mid);\\n            }\\n\\n            if (value > h) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@idkbro191](/idkbro191) I didn\\'t understand brother.\\n\\nEven if we cast or not, we\\'re anyway storing the value in int only, then how it works?"
                    },
                    {
                        "username": "idkbro191",
                        "content": "You must not cast the result of \"value\" into int before adding it as it goes out of the range of int:\n\n\"value += (int) Math.ceil((double) piles[i] / mid);\"\n\nRemove (int) and it should work fine. \n\n\"value += Math.ceil((double) piles[i] / mid);\""
                    },
                    {
                        "username": "Sggirb",
                        "content": "In the binary search solution, the runtime analysis seems to be O(nlog(k)) where n = number of piles and k = maximum bananas in a pile. Though, if k is bound by the constraint: 1 <= k <= 10^9 as stated in the problem statement, then could it be considered a constant? It doesn\\'t scale in any way as the input size does (n). If that\\'s the case, then shouldn\\'t the binary search solution be O(n)? (O(nlog(k)) -> O(nlog(10^9)) ~ O(n*30) -> O(n))"
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@jcmf](/jcmf) bro you are literally bigger bot than chatgpt"
                    },
                    {
                        "username": "jcmf",
                        "content": "Oh geez, you are so right about this, don\\'t get me started. More generally, the log base 2 of any 64-bit integer is bounded above by 64, a reasonably small constant. Why, then, does anyone ever bother including factors of log(n) when doing complexity analysis? It\\'s ridiculous, right? I think so! Anyway turns out it\\'s because the underlying mathematical formalism of big O complexity is based on the assumption that n (or m or k or however many other variables we have going on) can approach infinity (in the calculus sense), and that\\'s the behavior we\\'re interested in. And the limit as k approaches infinity of log(k) is, irritatingly enough, still infinity. I doubt it is possible for you hate this more than I do, but it\\'s still true. (And yet we still almost always pretend that any simple arithmetic operation, such as adding two numbers, can be done in constant time, presumably because that\\'s how it almost always works in real life and we\\'d come to the wrong conclusion if we assumed otherwise. These are contradictory assumptions, but never mind!) More practically speaking, a factor of log(k) can matter a great deal if one is trying to get a sense of how an algorithm is likely to perform with a large k after benchmarking it with smaller k. Sometimes the factor of log can be safely ignored in a certain situation or domain, but that\\'s not always a safe assumption -- it\\'s a bit like how occasionally a polynomial- or exponential-time algorithm will perform better than a linear time one. Gotta watch out. In the end, real-life computers are finite state machines, and any number involved in any real-life computation is always going to be bounded above by *some* constant in practice, but throwing up our hands and classifying every algorithm as O(1) is just not very useful or even fun, even though it might sound incredibly tempting at first. As a purely practical matter, if we\\'re not sure if the factor of log(k) is going to matter, it\\'s usually a safer bet to hold onto it than to discard it. Never know when you might need it. Leetcode is exactly the right kind of place to find absolutely merciless concrete examples of this."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "No, because k is a variable that is given and not constant. Therefore, the runtime of the code can vary, sometimes running in O(2n), other times in O(8n), and in the worst case, O(30n). If k were always O(30n), then the binary search solution would be O(n), but because k is a variable, the runtime complexity is O(n*log(n))."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko don\\'t eat that many bananas, they\\'re radioactive and shit"
                    },
                    {
                        "username": "sam2611",
                        "content": "Take a look at this article,  very helpful for solving more such types of questions. \n(https://leetcode.com/discuss/interview-question/3725477/binary-search-on-answer-koko-type)"
                    },
                    {
                        "username": "5441anr",
                        "content": "wen monke dun eat banan, das a beeg problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "Tight!  ..  Tight! Tight! Hey .. Koko, Trips, Lolo whatever man, Just keep bringing these Binary Search questions!"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "When You understand the Binary Search on Predicate functions these problems will be like cake walk for you, btw Happy Holi to all :)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Don\\'t make my mistake :) Sorting is not required here."
                    }
                ]
            },
            {
                "id": 1826388,
                "content": [
                    {
                        "username": "agforero",
                        "content": "monke"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "Is anybody getting wrong ans for Test case 124/125 \\npiles[]= [805306368,805306368,805306368] and h=1000000000"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "[@saakshikobarne](/saakshikobarne)  I was using the binary search to calculate the time koko takes to eat the bananas but i was using time<=h as a checking parameter instead i used (time<= h && time>0) , this resolved this testcase for me!"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Yes, I had the same doubt, I did it with my binary search code but it was not working on this testcase only and when I used the exact same code from a solution post it was working fine. I didn\\'t get it why but the code and mine were exactly the same still mine was failing this testcase."
                    },
                    {
                        "username": "_aavash_",
                        "content": "for piles = [805306368,805306368,805306368], h= 1000000000, output is 1 but expected is 3. Please help \\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        long start = 1;\\n        long end = 0;\\n        long sum=0;\\n\\n        for (int i = 0; i < piles.length; i++) {\\n            end = Math.max(piles[i], end);\\n            sum+= piles[i];\\n        }\\n        long ans = -1;\\n\\n        while (start <= end) {\\n            long mid = start + (end - start) / 2;\\n            int value = 0;\\n\\n            for (int i = 0; i < piles.length; i++) {\\n                value += (int) Math.ceil((double) piles[i] / mid);\\n            }\\n\\n            if (value > h) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@idkbro191](/idkbro191) I didn\\'t understand brother.\\n\\nEven if we cast or not, we\\'re anyway storing the value in int only, then how it works?"
                    },
                    {
                        "username": "idkbro191",
                        "content": "You must not cast the result of \"value\" into int before adding it as it goes out of the range of int:\n\n\"value += (int) Math.ceil((double) piles[i] / mid);\"\n\nRemove (int) and it should work fine. \n\n\"value += Math.ceil((double) piles[i] / mid);\""
                    },
                    {
                        "username": "Sggirb",
                        "content": "In the binary search solution, the runtime analysis seems to be O(nlog(k)) where n = number of piles and k = maximum bananas in a pile. Though, if k is bound by the constraint: 1 <= k <= 10^9 as stated in the problem statement, then could it be considered a constant? It doesn\\'t scale in any way as the input size does (n). If that\\'s the case, then shouldn\\'t the binary search solution be O(n)? (O(nlog(k)) -> O(nlog(10^9)) ~ O(n*30) -> O(n))"
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@jcmf](/jcmf) bro you are literally bigger bot than chatgpt"
                    },
                    {
                        "username": "jcmf",
                        "content": "Oh geez, you are so right about this, don\\'t get me started. More generally, the log base 2 of any 64-bit integer is bounded above by 64, a reasonably small constant. Why, then, does anyone ever bother including factors of log(n) when doing complexity analysis? It\\'s ridiculous, right? I think so! Anyway turns out it\\'s because the underlying mathematical formalism of big O complexity is based on the assumption that n (or m or k or however many other variables we have going on) can approach infinity (in the calculus sense), and that\\'s the behavior we\\'re interested in. And the limit as k approaches infinity of log(k) is, irritatingly enough, still infinity. I doubt it is possible for you hate this more than I do, but it\\'s still true. (And yet we still almost always pretend that any simple arithmetic operation, such as adding two numbers, can be done in constant time, presumably because that\\'s how it almost always works in real life and we\\'d come to the wrong conclusion if we assumed otherwise. These are contradictory assumptions, but never mind!) More practically speaking, a factor of log(k) can matter a great deal if one is trying to get a sense of how an algorithm is likely to perform with a large k after benchmarking it with smaller k. Sometimes the factor of log can be safely ignored in a certain situation or domain, but that\\'s not always a safe assumption -- it\\'s a bit like how occasionally a polynomial- or exponential-time algorithm will perform better than a linear time one. Gotta watch out. In the end, real-life computers are finite state machines, and any number involved in any real-life computation is always going to be bounded above by *some* constant in practice, but throwing up our hands and classifying every algorithm as O(1) is just not very useful or even fun, even though it might sound incredibly tempting at first. As a purely practical matter, if we\\'re not sure if the factor of log(k) is going to matter, it\\'s usually a safer bet to hold onto it than to discard it. Never know when you might need it. Leetcode is exactly the right kind of place to find absolutely merciless concrete examples of this."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "No, because k is a variable that is given and not constant. Therefore, the runtime of the code can vary, sometimes running in O(2n), other times in O(8n), and in the worst case, O(30n). If k were always O(30n), then the binary search solution would be O(n), but because k is a variable, the runtime complexity is O(n*log(n))."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko don\\'t eat that many bananas, they\\'re radioactive and shit"
                    },
                    {
                        "username": "sam2611",
                        "content": "Take a look at this article,  very helpful for solving more such types of questions. \n(https://leetcode.com/discuss/interview-question/3725477/binary-search-on-answer-koko-type)"
                    },
                    {
                        "username": "5441anr",
                        "content": "wen monke dun eat banan, das a beeg problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "Tight!  ..  Tight! Tight! Hey .. Koko, Trips, Lolo whatever man, Just keep bringing these Binary Search questions!"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "When You understand the Binary Search on Predicate functions these problems will be like cake walk for you, btw Happy Holi to all :)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Don\\'t make my mistake :) Sorting is not required here."
                    }
                ]
            },
            {
                "id": 1826230,
                "content": [
                    {
                        "username": "agforero",
                        "content": "monke"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "Is anybody getting wrong ans for Test case 124/125 \\npiles[]= [805306368,805306368,805306368] and h=1000000000"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "[@saakshikobarne](/saakshikobarne)  I was using the binary search to calculate the time koko takes to eat the bananas but i was using time<=h as a checking parameter instead i used (time<= h && time>0) , this resolved this testcase for me!"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Yes, I had the same doubt, I did it with my binary search code but it was not working on this testcase only and when I used the exact same code from a solution post it was working fine. I didn\\'t get it why but the code and mine were exactly the same still mine was failing this testcase."
                    },
                    {
                        "username": "_aavash_",
                        "content": "for piles = [805306368,805306368,805306368], h= 1000000000, output is 1 but expected is 3. Please help \\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        long start = 1;\\n        long end = 0;\\n        long sum=0;\\n\\n        for (int i = 0; i < piles.length; i++) {\\n            end = Math.max(piles[i], end);\\n            sum+= piles[i];\\n        }\\n        long ans = -1;\\n\\n        while (start <= end) {\\n            long mid = start + (end - start) / 2;\\n            int value = 0;\\n\\n            for (int i = 0; i < piles.length; i++) {\\n                value += (int) Math.ceil((double) piles[i] / mid);\\n            }\\n\\n            if (value > h) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@idkbro191](/idkbro191) I didn\\'t understand brother.\\n\\nEven if we cast or not, we\\'re anyway storing the value in int only, then how it works?"
                    },
                    {
                        "username": "idkbro191",
                        "content": "You must not cast the result of \"value\" into int before adding it as it goes out of the range of int:\n\n\"value += (int) Math.ceil((double) piles[i] / mid);\"\n\nRemove (int) and it should work fine. \n\n\"value += Math.ceil((double) piles[i] / mid);\""
                    },
                    {
                        "username": "Sggirb",
                        "content": "In the binary search solution, the runtime analysis seems to be O(nlog(k)) where n = number of piles and k = maximum bananas in a pile. Though, if k is bound by the constraint: 1 <= k <= 10^9 as stated in the problem statement, then could it be considered a constant? It doesn\\'t scale in any way as the input size does (n). If that\\'s the case, then shouldn\\'t the binary search solution be O(n)? (O(nlog(k)) -> O(nlog(10^9)) ~ O(n*30) -> O(n))"
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@jcmf](/jcmf) bro you are literally bigger bot than chatgpt"
                    },
                    {
                        "username": "jcmf",
                        "content": "Oh geez, you are so right about this, don\\'t get me started. More generally, the log base 2 of any 64-bit integer is bounded above by 64, a reasonably small constant. Why, then, does anyone ever bother including factors of log(n) when doing complexity analysis? It\\'s ridiculous, right? I think so! Anyway turns out it\\'s because the underlying mathematical formalism of big O complexity is based on the assumption that n (or m or k or however many other variables we have going on) can approach infinity (in the calculus sense), and that\\'s the behavior we\\'re interested in. And the limit as k approaches infinity of log(k) is, irritatingly enough, still infinity. I doubt it is possible for you hate this more than I do, but it\\'s still true. (And yet we still almost always pretend that any simple arithmetic operation, such as adding two numbers, can be done in constant time, presumably because that\\'s how it almost always works in real life and we\\'d come to the wrong conclusion if we assumed otherwise. These are contradictory assumptions, but never mind!) More practically speaking, a factor of log(k) can matter a great deal if one is trying to get a sense of how an algorithm is likely to perform with a large k after benchmarking it with smaller k. Sometimes the factor of log can be safely ignored in a certain situation or domain, but that\\'s not always a safe assumption -- it\\'s a bit like how occasionally a polynomial- or exponential-time algorithm will perform better than a linear time one. Gotta watch out. In the end, real-life computers are finite state machines, and any number involved in any real-life computation is always going to be bounded above by *some* constant in practice, but throwing up our hands and classifying every algorithm as O(1) is just not very useful or even fun, even though it might sound incredibly tempting at first. As a purely practical matter, if we\\'re not sure if the factor of log(k) is going to matter, it\\'s usually a safer bet to hold onto it than to discard it. Never know when you might need it. Leetcode is exactly the right kind of place to find absolutely merciless concrete examples of this."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "No, because k is a variable that is given and not constant. Therefore, the runtime of the code can vary, sometimes running in O(2n), other times in O(8n), and in the worst case, O(30n). If k were always O(30n), then the binary search solution would be O(n), but because k is a variable, the runtime complexity is O(n*log(n))."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko don\\'t eat that many bananas, they\\'re radioactive and shit"
                    },
                    {
                        "username": "sam2611",
                        "content": "Take a look at this article,  very helpful for solving more such types of questions. \n(https://leetcode.com/discuss/interview-question/3725477/binary-search-on-answer-koko-type)"
                    },
                    {
                        "username": "5441anr",
                        "content": "wen monke dun eat banan, das a beeg problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "Tight!  ..  Tight! Tight! Hey .. Koko, Trips, Lolo whatever man, Just keep bringing these Binary Search questions!"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "When You understand the Binary Search on Predicate functions these problems will be like cake walk for you, btw Happy Holi to all :)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Don\\'t make my mistake :) Sorting is not required here."
                    }
                ]
            },
            {
                "id": 1826077,
                "content": [
                    {
                        "username": "agforero",
                        "content": "monke"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "Is anybody getting wrong ans for Test case 124/125 \\npiles[]= [805306368,805306368,805306368] and h=1000000000"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "[@saakshikobarne](/saakshikobarne)  I was using the binary search to calculate the time koko takes to eat the bananas but i was using time<=h as a checking parameter instead i used (time<= h && time>0) , this resolved this testcase for me!"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Yes, I had the same doubt, I did it with my binary search code but it was not working on this testcase only and when I used the exact same code from a solution post it was working fine. I didn\\'t get it why but the code and mine were exactly the same still mine was failing this testcase."
                    },
                    {
                        "username": "_aavash_",
                        "content": "for piles = [805306368,805306368,805306368], h= 1000000000, output is 1 but expected is 3. Please help \\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        long start = 1;\\n        long end = 0;\\n        long sum=0;\\n\\n        for (int i = 0; i < piles.length; i++) {\\n            end = Math.max(piles[i], end);\\n            sum+= piles[i];\\n        }\\n        long ans = -1;\\n\\n        while (start <= end) {\\n            long mid = start + (end - start) / 2;\\n            int value = 0;\\n\\n            for (int i = 0; i < piles.length; i++) {\\n                value += (int) Math.ceil((double) piles[i] / mid);\\n            }\\n\\n            if (value > h) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@idkbro191](/idkbro191) I didn\\'t understand brother.\\n\\nEven if we cast or not, we\\'re anyway storing the value in int only, then how it works?"
                    },
                    {
                        "username": "idkbro191",
                        "content": "You must not cast the result of \"value\" into int before adding it as it goes out of the range of int:\n\n\"value += (int) Math.ceil((double) piles[i] / mid);\"\n\nRemove (int) and it should work fine. \n\n\"value += Math.ceil((double) piles[i] / mid);\""
                    },
                    {
                        "username": "Sggirb",
                        "content": "In the binary search solution, the runtime analysis seems to be O(nlog(k)) where n = number of piles and k = maximum bananas in a pile. Though, if k is bound by the constraint: 1 <= k <= 10^9 as stated in the problem statement, then could it be considered a constant? It doesn\\'t scale in any way as the input size does (n). If that\\'s the case, then shouldn\\'t the binary search solution be O(n)? (O(nlog(k)) -> O(nlog(10^9)) ~ O(n*30) -> O(n))"
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@jcmf](/jcmf) bro you are literally bigger bot than chatgpt"
                    },
                    {
                        "username": "jcmf",
                        "content": "Oh geez, you are so right about this, don\\'t get me started. More generally, the log base 2 of any 64-bit integer is bounded above by 64, a reasonably small constant. Why, then, does anyone ever bother including factors of log(n) when doing complexity analysis? It\\'s ridiculous, right? I think so! Anyway turns out it\\'s because the underlying mathematical formalism of big O complexity is based on the assumption that n (or m or k or however many other variables we have going on) can approach infinity (in the calculus sense), and that\\'s the behavior we\\'re interested in. And the limit as k approaches infinity of log(k) is, irritatingly enough, still infinity. I doubt it is possible for you hate this more than I do, but it\\'s still true. (And yet we still almost always pretend that any simple arithmetic operation, such as adding two numbers, can be done in constant time, presumably because that\\'s how it almost always works in real life and we\\'d come to the wrong conclusion if we assumed otherwise. These are contradictory assumptions, but never mind!) More practically speaking, a factor of log(k) can matter a great deal if one is trying to get a sense of how an algorithm is likely to perform with a large k after benchmarking it with smaller k. Sometimes the factor of log can be safely ignored in a certain situation or domain, but that\\'s not always a safe assumption -- it\\'s a bit like how occasionally a polynomial- or exponential-time algorithm will perform better than a linear time one. Gotta watch out. In the end, real-life computers are finite state machines, and any number involved in any real-life computation is always going to be bounded above by *some* constant in practice, but throwing up our hands and classifying every algorithm as O(1) is just not very useful or even fun, even though it might sound incredibly tempting at first. As a purely practical matter, if we\\'re not sure if the factor of log(k) is going to matter, it\\'s usually a safer bet to hold onto it than to discard it. Never know when you might need it. Leetcode is exactly the right kind of place to find absolutely merciless concrete examples of this."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "No, because k is a variable that is given and not constant. Therefore, the runtime of the code can vary, sometimes running in O(2n), other times in O(8n), and in the worst case, O(30n). If k were always O(30n), then the binary search solution would be O(n), but because k is a variable, the runtime complexity is O(n*log(n))."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko don\\'t eat that many bananas, they\\'re radioactive and shit"
                    },
                    {
                        "username": "sam2611",
                        "content": "Take a look at this article,  very helpful for solving more such types of questions. \n(https://leetcode.com/discuss/interview-question/3725477/binary-search-on-answer-koko-type)"
                    },
                    {
                        "username": "5441anr",
                        "content": "wen monke dun eat banan, das a beeg problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "Tight!  ..  Tight! Tight! Hey .. Koko, Trips, Lolo whatever man, Just keep bringing these Binary Search questions!"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "When You understand the Binary Search on Predicate functions these problems will be like cake walk for you, btw Happy Holi to all :)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Don\\'t make my mistake :) Sorting is not required here."
                    }
                ]
            },
            {
                "id": 1825955,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was bad at Binary Search a month ago... not anymore."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "I was good at binary search 1 question ago xd "
                    },
                    {
                        "username": "imprayas12",
                        "content": "Koko\\'s POV: What do you mean I have to to do Binary search before eating bananas?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "koko: \"is that helpful to use a sort?\""
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "Trying to solve in Python, Ceil function doesn\\'t seem to be working."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "try multiplying numerator or denominator by 1.0\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Have you tried `math.ceil(x)`?"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "``` \nif char %i !=0:\n      s = 1+s+ char//i \nelse:\n     s = s + char//i\n```"
                    },
                    {
                        "username": "Subh001",
                        "content": "Happy holi....happy coding guys"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I\\'ve been solving this for 3 days and I\\'m genuinely crying because of this problem"
                    },
                    {
                        "username": "sugammehra",
                        "content": "Why cant we use ceil function here?\nfor(int i=0;i<piles.size();i++){            \n             k += (piles[i] + speed - 1) / speed;\n           // k += ceil(piles[i] / speed);\n }\nWhat is the difference Between these two?"
                    },
                    {
                        "username": "joevarghese53",
                        "content": "same doubt"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can LeetCode add a new feature which enables search questions about the problem in the discussion? In this case, we don't need to post duplicated questions and it's easy to search. "
                    },
                    {
                        "username": "AryanGurav",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\n\\nI am not able to pass the above testcases and referred to almost all solution. Although none of the way to declare right as MinInteger doesnt get the work done \\nPlz help if you know the right way\\n "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "[@codepiyush1]     this code is working bro"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please check this line carefully in the code    if(count<=h && count>0 && mid1>mid){   and i wrote my code in java programming language"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "bro when you are counting the hours you need to add extra condition that count>0  . If you submit by adding this condition your code will work fine"
                    },
                    {
                        "username": "sahle123",
                        "content": "I found that the solution to this problem was very similar to the problem: 2187. Minimum Time To Complete Trips.\\n\\nIf you solved that one, then you already have a good idea on how you\\'d solve this one."
                    }
                ]
            },
            {
                "id": 1825789,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was bad at Binary Search a month ago... not anymore."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "I was good at binary search 1 question ago xd "
                    },
                    {
                        "username": "imprayas12",
                        "content": "Koko\\'s POV: What do you mean I have to to do Binary search before eating bananas?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "koko: \"is that helpful to use a sort?\""
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "Trying to solve in Python, Ceil function doesn\\'t seem to be working."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "try multiplying numerator or denominator by 1.0\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Have you tried `math.ceil(x)`?"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "``` \nif char %i !=0:\n      s = 1+s+ char//i \nelse:\n     s = s + char//i\n```"
                    },
                    {
                        "username": "Subh001",
                        "content": "Happy holi....happy coding guys"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I\\'ve been solving this for 3 days and I\\'m genuinely crying because of this problem"
                    },
                    {
                        "username": "sugammehra",
                        "content": "Why cant we use ceil function here?\nfor(int i=0;i<piles.size();i++){            \n             k += (piles[i] + speed - 1) / speed;\n           // k += ceil(piles[i] / speed);\n }\nWhat is the difference Between these two?"
                    },
                    {
                        "username": "joevarghese53",
                        "content": "same doubt"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can LeetCode add a new feature which enables search questions about the problem in the discussion? In this case, we don't need to post duplicated questions and it's easy to search. "
                    },
                    {
                        "username": "AryanGurav",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\n\\nI am not able to pass the above testcases and referred to almost all solution. Although none of the way to declare right as MinInteger doesnt get the work done \\nPlz help if you know the right way\\n "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "[@codepiyush1]     this code is working bro"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please check this line carefully in the code    if(count<=h && count>0 && mid1>mid){   and i wrote my code in java programming language"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "bro when you are counting the hours you need to add extra condition that count>0  . If you submit by adding this condition your code will work fine"
                    },
                    {
                        "username": "sahle123",
                        "content": "I found that the solution to this problem was very similar to the problem: 2187. Minimum Time To Complete Trips.\\n\\nIf you solved that one, then you already have a good idea on how you\\'d solve this one."
                    }
                ]
            },
            {
                "id": 1825735,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was bad at Binary Search a month ago... not anymore."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "I was good at binary search 1 question ago xd "
                    },
                    {
                        "username": "imprayas12",
                        "content": "Koko\\'s POV: What do you mean I have to to do Binary search before eating bananas?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "koko: \"is that helpful to use a sort?\""
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "Trying to solve in Python, Ceil function doesn\\'t seem to be working."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "try multiplying numerator or denominator by 1.0\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Have you tried `math.ceil(x)`?"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "``` \nif char %i !=0:\n      s = 1+s+ char//i \nelse:\n     s = s + char//i\n```"
                    },
                    {
                        "username": "Subh001",
                        "content": "Happy holi....happy coding guys"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I\\'ve been solving this for 3 days and I\\'m genuinely crying because of this problem"
                    },
                    {
                        "username": "sugammehra",
                        "content": "Why cant we use ceil function here?\nfor(int i=0;i<piles.size();i++){            \n             k += (piles[i] + speed - 1) / speed;\n           // k += ceil(piles[i] / speed);\n }\nWhat is the difference Between these two?"
                    },
                    {
                        "username": "joevarghese53",
                        "content": "same doubt"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can LeetCode add a new feature which enables search questions about the problem in the discussion? In this case, we don't need to post duplicated questions and it's easy to search. "
                    },
                    {
                        "username": "AryanGurav",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\n\\nI am not able to pass the above testcases and referred to almost all solution. Although none of the way to declare right as MinInteger doesnt get the work done \\nPlz help if you know the right way\\n "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "[@codepiyush1]     this code is working bro"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please check this line carefully in the code    if(count<=h && count>0 && mid1>mid){   and i wrote my code in java programming language"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "bro when you are counting the hours you need to add extra condition that count>0  . If you submit by adding this condition your code will work fine"
                    },
                    {
                        "username": "sahle123",
                        "content": "I found that the solution to this problem was very similar to the problem: 2187. Minimum Time To Complete Trips.\\n\\nIf you solved that one, then you already have a good idea on how you\\'d solve this one."
                    }
                ]
            },
            {
                "id": 1740262,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was bad at Binary Search a month ago... not anymore."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "I was good at binary search 1 question ago xd "
                    },
                    {
                        "username": "imprayas12",
                        "content": "Koko\\'s POV: What do you mean I have to to do Binary search before eating bananas?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "koko: \"is that helpful to use a sort?\""
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "Trying to solve in Python, Ceil function doesn\\'t seem to be working."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "try multiplying numerator or denominator by 1.0\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Have you tried `math.ceil(x)`?"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "``` \nif char %i !=0:\n      s = 1+s+ char//i \nelse:\n     s = s + char//i\n```"
                    },
                    {
                        "username": "Subh001",
                        "content": "Happy holi....happy coding guys"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I\\'ve been solving this for 3 days and I\\'m genuinely crying because of this problem"
                    },
                    {
                        "username": "sugammehra",
                        "content": "Why cant we use ceil function here?\nfor(int i=0;i<piles.size();i++){            \n             k += (piles[i] + speed - 1) / speed;\n           // k += ceil(piles[i] / speed);\n }\nWhat is the difference Between these two?"
                    },
                    {
                        "username": "joevarghese53",
                        "content": "same doubt"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can LeetCode add a new feature which enables search questions about the problem in the discussion? In this case, we don't need to post duplicated questions and it's easy to search. "
                    },
                    {
                        "username": "AryanGurav",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\n\\nI am not able to pass the above testcases and referred to almost all solution. Although none of the way to declare right as MinInteger doesnt get the work done \\nPlz help if you know the right way\\n "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "[@codepiyush1]     this code is working bro"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please check this line carefully in the code    if(count<=h && count>0 && mid1>mid){   and i wrote my code in java programming language"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "bro when you are counting the hours you need to add extra condition that count>0  . If you submit by adding this condition your code will work fine"
                    },
                    {
                        "username": "sahle123",
                        "content": "I found that the solution to this problem was very similar to the problem: 2187. Minimum Time To Complete Trips.\\n\\nIf you solved that one, then you already have a good idea on how you\\'d solve this one."
                    }
                ]
            },
            {
                "id": 1825731,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was bad at Binary Search a month ago... not anymore."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "I was good at binary search 1 question ago xd "
                    },
                    {
                        "username": "imprayas12",
                        "content": "Koko\\'s POV: What do you mean I have to to do Binary search before eating bananas?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "koko: \"is that helpful to use a sort?\""
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "Trying to solve in Python, Ceil function doesn\\'t seem to be working."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "try multiplying numerator or denominator by 1.0\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Have you tried `math.ceil(x)`?"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "``` \nif char %i !=0:\n      s = 1+s+ char//i \nelse:\n     s = s + char//i\n```"
                    },
                    {
                        "username": "Subh001",
                        "content": "Happy holi....happy coding guys"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I\\'ve been solving this for 3 days and I\\'m genuinely crying because of this problem"
                    },
                    {
                        "username": "sugammehra",
                        "content": "Why cant we use ceil function here?\nfor(int i=0;i<piles.size();i++){            \n             k += (piles[i] + speed - 1) / speed;\n           // k += ceil(piles[i] / speed);\n }\nWhat is the difference Between these two?"
                    },
                    {
                        "username": "joevarghese53",
                        "content": "same doubt"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can LeetCode add a new feature which enables search questions about the problem in the discussion? In this case, we don't need to post duplicated questions and it's easy to search. "
                    },
                    {
                        "username": "AryanGurav",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\n\\nI am not able to pass the above testcases and referred to almost all solution. Although none of the way to declare right as MinInteger doesnt get the work done \\nPlz help if you know the right way\\n "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "[@codepiyush1]     this code is working bro"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please check this line carefully in the code    if(count<=h && count>0 && mid1>mid){   and i wrote my code in java programming language"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "bro when you are counting the hours you need to add extra condition that count>0  . If you submit by adding this condition your code will work fine"
                    },
                    {
                        "username": "sahle123",
                        "content": "I found that the solution to this problem was very similar to the problem: 2187. Minimum Time To Complete Trips.\\n\\nIf you solved that one, then you already have a good idea on how you\\'d solve this one."
                    }
                ]
            },
            {
                "id": 1999864,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was bad at Binary Search a month ago... not anymore."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "I was good at binary search 1 question ago xd "
                    },
                    {
                        "username": "imprayas12",
                        "content": "Koko\\'s POV: What do you mean I have to to do Binary search before eating bananas?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "koko: \"is that helpful to use a sort?\""
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "Trying to solve in Python, Ceil function doesn\\'t seem to be working."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "try multiplying numerator or denominator by 1.0\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Have you tried `math.ceil(x)`?"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "``` \nif char %i !=0:\n      s = 1+s+ char//i \nelse:\n     s = s + char//i\n```"
                    },
                    {
                        "username": "Subh001",
                        "content": "Happy holi....happy coding guys"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I\\'ve been solving this for 3 days and I\\'m genuinely crying because of this problem"
                    },
                    {
                        "username": "sugammehra",
                        "content": "Why cant we use ceil function here?\nfor(int i=0;i<piles.size();i++){            \n             k += (piles[i] + speed - 1) / speed;\n           // k += ceil(piles[i] / speed);\n }\nWhat is the difference Between these two?"
                    },
                    {
                        "username": "joevarghese53",
                        "content": "same doubt"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can LeetCode add a new feature which enables search questions about the problem in the discussion? In this case, we don't need to post duplicated questions and it's easy to search. "
                    },
                    {
                        "username": "AryanGurav",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\n\\nI am not able to pass the above testcases and referred to almost all solution. Although none of the way to declare right as MinInteger doesnt get the work done \\nPlz help if you know the right way\\n "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "[@codepiyush1]     this code is working bro"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please check this line carefully in the code    if(count<=h && count>0 && mid1>mid){   and i wrote my code in java programming language"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "bro when you are counting the hours you need to add extra condition that count>0  . If you submit by adding this condition your code will work fine"
                    },
                    {
                        "username": "sahle123",
                        "content": "I found that the solution to this problem was very similar to the problem: 2187. Minimum Time To Complete Trips.\\n\\nIf you solved that one, then you already have a good idea on how you\\'d solve this one."
                    }
                ]
            },
            {
                "id": 1996870,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was bad at Binary Search a month ago... not anymore."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "I was good at binary search 1 question ago xd "
                    },
                    {
                        "username": "imprayas12",
                        "content": "Koko\\'s POV: What do you mean I have to to do Binary search before eating bananas?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "koko: \"is that helpful to use a sort?\""
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "Trying to solve in Python, Ceil function doesn\\'t seem to be working."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "try multiplying numerator or denominator by 1.0\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Have you tried `math.ceil(x)`?"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "``` \nif char %i !=0:\n      s = 1+s+ char//i \nelse:\n     s = s + char//i\n```"
                    },
                    {
                        "username": "Subh001",
                        "content": "Happy holi....happy coding guys"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I\\'ve been solving this for 3 days and I\\'m genuinely crying because of this problem"
                    },
                    {
                        "username": "sugammehra",
                        "content": "Why cant we use ceil function here?\nfor(int i=0;i<piles.size();i++){            \n             k += (piles[i] + speed - 1) / speed;\n           // k += ceil(piles[i] / speed);\n }\nWhat is the difference Between these two?"
                    },
                    {
                        "username": "joevarghese53",
                        "content": "same doubt"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can LeetCode add a new feature which enables search questions about the problem in the discussion? In this case, we don't need to post duplicated questions and it's easy to search. "
                    },
                    {
                        "username": "AryanGurav",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\n\\nI am not able to pass the above testcases and referred to almost all solution. Although none of the way to declare right as MinInteger doesnt get the work done \\nPlz help if you know the right way\\n "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "[@codepiyush1]     this code is working bro"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please check this line carefully in the code    if(count<=h && count>0 && mid1>mid){   and i wrote my code in java programming language"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "bro when you are counting the hours you need to add extra condition that count>0  . If you submit by adding this condition your code will work fine"
                    },
                    {
                        "username": "sahle123",
                        "content": "I found that the solution to this problem was very similar to the problem: 2187. Minimum Time To Complete Trips.\\n\\nIf you solved that one, then you already have a good idea on how you\\'d solve this one."
                    }
                ]
            },
            {
                "id": 1948347,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was bad at Binary Search a month ago... not anymore."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "I was good at binary search 1 question ago xd "
                    },
                    {
                        "username": "imprayas12",
                        "content": "Koko\\'s POV: What do you mean I have to to do Binary search before eating bananas?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "koko: \"is that helpful to use a sort?\""
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "Trying to solve in Python, Ceil function doesn\\'t seem to be working."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "try multiplying numerator or denominator by 1.0\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Have you tried `math.ceil(x)`?"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "``` \nif char %i !=0:\n      s = 1+s+ char//i \nelse:\n     s = s + char//i\n```"
                    },
                    {
                        "username": "Subh001",
                        "content": "Happy holi....happy coding guys"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I\\'ve been solving this for 3 days and I\\'m genuinely crying because of this problem"
                    },
                    {
                        "username": "sugammehra",
                        "content": "Why cant we use ceil function here?\nfor(int i=0;i<piles.size();i++){            \n             k += (piles[i] + speed - 1) / speed;\n           // k += ceil(piles[i] / speed);\n }\nWhat is the difference Between these two?"
                    },
                    {
                        "username": "joevarghese53",
                        "content": "same doubt"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can LeetCode add a new feature which enables search questions about the problem in the discussion? In this case, we don't need to post duplicated questions and it's easy to search. "
                    },
                    {
                        "username": "AryanGurav",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\n\\nI am not able to pass the above testcases and referred to almost all solution. Although none of the way to declare right as MinInteger doesnt get the work done \\nPlz help if you know the right way\\n "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "[@codepiyush1]     this code is working bro"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please check this line carefully in the code    if(count<=h && count>0 && mid1>mid){   and i wrote my code in java programming language"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "bro when you are counting the hours you need to add extra condition that count>0  . If you submit by adding this condition your code will work fine"
                    },
                    {
                        "username": "sahle123",
                        "content": "I found that the solution to this problem was very similar to the problem: 2187. Minimum Time To Complete Trips.\\n\\nIf you solved that one, then you already have a good idea on how you\\'d solve this one."
                    }
                ]
            },
            {
                "id": 1827376,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was bad at Binary Search a month ago... not anymore."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "I was good at binary search 1 question ago xd "
                    },
                    {
                        "username": "imprayas12",
                        "content": "Koko\\'s POV: What do you mean I have to to do Binary search before eating bananas?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "koko: \"is that helpful to use a sort?\""
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "Trying to solve in Python, Ceil function doesn\\'t seem to be working."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "try multiplying numerator or denominator by 1.0\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Have you tried `math.ceil(x)`?"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "``` \nif char %i !=0:\n      s = 1+s+ char//i \nelse:\n     s = s + char//i\n```"
                    },
                    {
                        "username": "Subh001",
                        "content": "Happy holi....happy coding guys"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I\\'ve been solving this for 3 days and I\\'m genuinely crying because of this problem"
                    },
                    {
                        "username": "sugammehra",
                        "content": "Why cant we use ceil function here?\nfor(int i=0;i<piles.size();i++){            \n             k += (piles[i] + speed - 1) / speed;\n           // k += ceil(piles[i] / speed);\n }\nWhat is the difference Between these two?"
                    },
                    {
                        "username": "joevarghese53",
                        "content": "same doubt"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can LeetCode add a new feature which enables search questions about the problem in the discussion? In this case, we don't need to post duplicated questions and it's easy to search. "
                    },
                    {
                        "username": "AryanGurav",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\n\\nI am not able to pass the above testcases and referred to almost all solution. Although none of the way to declare right as MinInteger doesnt get the work done \\nPlz help if you know the right way\\n "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "[@codepiyush1]     this code is working bro"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please check this line carefully in the code    if(count<=h && count>0 && mid1>mid){   and i wrote my code in java programming language"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "bro when you are counting the hours you need to add extra condition that count>0  . If you submit by adding this condition your code will work fine"
                    },
                    {
                        "username": "sahle123",
                        "content": "I found that the solution to this problem was very similar to the problem: 2187. Minimum Time To Complete Trips.\\n\\nIf you solved that one, then you already have a good idea on how you\\'d solve this one."
                    }
                ]
            },
            {
                "id": 1827147,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was bad at Binary Search a month ago... not anymore."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "I was good at binary search 1 question ago xd "
                    },
                    {
                        "username": "imprayas12",
                        "content": "Koko\\'s POV: What do you mean I have to to do Binary search before eating bananas?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "koko: \"is that helpful to use a sort?\""
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "Trying to solve in Python, Ceil function doesn\\'t seem to be working."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "try multiplying numerator or denominator by 1.0\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Have you tried `math.ceil(x)`?"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "``` \nif char %i !=0:\n      s = 1+s+ char//i \nelse:\n     s = s + char//i\n```"
                    },
                    {
                        "username": "Subh001",
                        "content": "Happy holi....happy coding guys"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I\\'ve been solving this for 3 days and I\\'m genuinely crying because of this problem"
                    },
                    {
                        "username": "sugammehra",
                        "content": "Why cant we use ceil function here?\nfor(int i=0;i<piles.size();i++){            \n             k += (piles[i] + speed - 1) / speed;\n           // k += ceil(piles[i] / speed);\n }\nWhat is the difference Between these two?"
                    },
                    {
                        "username": "joevarghese53",
                        "content": "same doubt"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can LeetCode add a new feature which enables search questions about the problem in the discussion? In this case, we don't need to post duplicated questions and it's easy to search. "
                    },
                    {
                        "username": "AryanGurav",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\n\\nI am not able to pass the above testcases and referred to almost all solution. Although none of the way to declare right as MinInteger doesnt get the work done \\nPlz help if you know the right way\\n "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "[@codepiyush1]     this code is working bro"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please check this line carefully in the code    if(count<=h && count>0 && mid1>mid){   and i wrote my code in java programming language"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "bro when you are counting the hours you need to add extra condition that count>0  . If you submit by adding this condition your code will work fine"
                    },
                    {
                        "username": "sahle123",
                        "content": "I found that the solution to this problem was very similar to the problem: 2187. Minimum Time To Complete Trips.\\n\\nIf you solved that one, then you already have a good idea on how you\\'d solve this one."
                    }
                ]
            },
            {
                "id": 1826269,
                "content": [
                    {
                        "username": "genuine_stamina",
                        "content": "Can somebody explain why 19 is not the answer for the Example 3?\\n\\nIf k=19, then piles 11 and 4 can be eaten in 2 hours, and then\\n3rd hour, eat 19 from pile 20;\\n4th hour, eat 1 leftover banana and 18 from 23;\\n5th hour, eat 5 leftover bananas and 14 from 30;\\n6th hour, eat 16 leftover bananas;\\n\\nIt took 6 hours. I must be misinterpreting the problem description."
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Thanks guys, great explanations. Right to the point! I was able to solve it after this. I would \n like to add, basically according to the statement each pile takes `ceil(piles[i] / k)` days to eat."
                    },
                    {
                        "username": "Harr1sh",
                        "content": "\"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\\n\\nSo at any given hour, only bananas from a single pile can be eaten."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the problem statement: \"If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\n\nSo, in the 4th hour koko will only eat the 1 leftover banana and then stop. For `k=19`, each pile would therefore take: [2, 1, 2, 1, 2] hours to eat, respectively, for a total of 8 hours. \n\n`k = 23` is the smallest `k` that allows koko to finish all bananas before the guards return."
                    },
                    {
                        "username": "Isha307",
                        "content": "why did you go for binary search? how did you decide it?"
                    },
                    {
                        "username": "Isha307",
                        "content": "[@jolswlf](/jolswlf) got it !! Thank You"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Binary search is generally the fastest way to search for a specific value in an already  sorted data set because each iteration you reduce the search space by half. And since the constraints allow  for pretty large datsets it's almost always going to be faster than linear search. \nYou could implement linear search for the smaller datasets and maybe make it a little bit faster too."
                    },
                    {
                        "username": "cicada44",
                        "content": "Output:\\n\\nTime Limit Exceeded\\n123 / 123 testcases passed\\nLast Executed Input\\nUse Testcase\\npiles =\\n\\nEnd of output\\n\\npiles = WHAT???\\nall tests passed, but time limit exceeded and piles is empty, what\\'s wrong with runner?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Nah. simply speaking , it is just a TLE, a closer one."
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Same...."
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "agar banana uss hour ke reh gaye hai to next hour mei khao aur bass bache hue banana khao uss hour mei\\nnext pile ke nahi same logic `canEatAll` mei use hua hai"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Lol, this is literally the same exact problem as yesterday."
                    },
                    {
                        "username": "r0kkka",
                        "content": "when you think about an workable speed i.e trying to figure is eating speed n is ok, consider going past an hour would consume a full hour.\\n\\ne. g\\n\\nkoko trying to eat a pile of 3 bananas with speed 2. coco would need 2 hours. (so a simple division of pile / speed wouldn\\'t help)"
                    },
                    {
                        "username": "phigh",
                        "content": "In O(nlogn) binary search solution we are inserting values in an equation and checking them one by one (using binary search we just reduce the number of values we insert and check). \\nCant this be done in O(n)? We can find out avg and insert that value, check result and adjust it somehow using min and max value in the piles array and come up with the solution?"
                    },
                    {
                        "username": "peterblockman",
                        "content": "Stuck for an hour until I realized that I needed to round up the time due to this line: \"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour\""
                    },
                    {
                        "username": "_sharma",
                        "content": "how is this medium- difficulty question ?"
                    },
                    {
                        "username": "souravrajvi0",
                        "content": "Kuch smaj hi nahi aara bhai"
                    }
                ]
            },
            {
                "id": 1826213,
                "content": [
                    {
                        "username": "genuine_stamina",
                        "content": "Can somebody explain why 19 is not the answer for the Example 3?\\n\\nIf k=19, then piles 11 and 4 can be eaten in 2 hours, and then\\n3rd hour, eat 19 from pile 20;\\n4th hour, eat 1 leftover banana and 18 from 23;\\n5th hour, eat 5 leftover bananas and 14 from 30;\\n6th hour, eat 16 leftover bananas;\\n\\nIt took 6 hours. I must be misinterpreting the problem description."
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Thanks guys, great explanations. Right to the point! I was able to solve it after this. I would \n like to add, basically according to the statement each pile takes `ceil(piles[i] / k)` days to eat."
                    },
                    {
                        "username": "Harr1sh",
                        "content": "\"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\\n\\nSo at any given hour, only bananas from a single pile can be eaten."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the problem statement: \"If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\n\nSo, in the 4th hour koko will only eat the 1 leftover banana and then stop. For `k=19`, each pile would therefore take: [2, 1, 2, 1, 2] hours to eat, respectively, for a total of 8 hours. \n\n`k = 23` is the smallest `k` that allows koko to finish all bananas before the guards return."
                    },
                    {
                        "username": "Isha307",
                        "content": "why did you go for binary search? how did you decide it?"
                    },
                    {
                        "username": "Isha307",
                        "content": "[@jolswlf](/jolswlf) got it !! Thank You"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Binary search is generally the fastest way to search for a specific value in an already  sorted data set because each iteration you reduce the search space by half. And since the constraints allow  for pretty large datsets it's almost always going to be faster than linear search. \nYou could implement linear search for the smaller datasets and maybe make it a little bit faster too."
                    },
                    {
                        "username": "cicada44",
                        "content": "Output:\\n\\nTime Limit Exceeded\\n123 / 123 testcases passed\\nLast Executed Input\\nUse Testcase\\npiles =\\n\\nEnd of output\\n\\npiles = WHAT???\\nall tests passed, but time limit exceeded and piles is empty, what\\'s wrong with runner?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Nah. simply speaking , it is just a TLE, a closer one."
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Same...."
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "agar banana uss hour ke reh gaye hai to next hour mei khao aur bass bache hue banana khao uss hour mei\\nnext pile ke nahi same logic `canEatAll` mei use hua hai"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Lol, this is literally the same exact problem as yesterday."
                    },
                    {
                        "username": "r0kkka",
                        "content": "when you think about an workable speed i.e trying to figure is eating speed n is ok, consider going past an hour would consume a full hour.\\n\\ne. g\\n\\nkoko trying to eat a pile of 3 bananas with speed 2. coco would need 2 hours. (so a simple division of pile / speed wouldn\\'t help)"
                    },
                    {
                        "username": "phigh",
                        "content": "In O(nlogn) binary search solution we are inserting values in an equation and checking them one by one (using binary search we just reduce the number of values we insert and check). \\nCant this be done in O(n)? We can find out avg and insert that value, check result and adjust it somehow using min and max value in the piles array and come up with the solution?"
                    },
                    {
                        "username": "peterblockman",
                        "content": "Stuck for an hour until I realized that I needed to round up the time due to this line: \"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour\""
                    },
                    {
                        "username": "_sharma",
                        "content": "how is this medium- difficulty question ?"
                    },
                    {
                        "username": "souravrajvi0",
                        "content": "Kuch smaj hi nahi aara bhai"
                    }
                ]
            },
            {
                "id": 1826082,
                "content": [
                    {
                        "username": "genuine_stamina",
                        "content": "Can somebody explain why 19 is not the answer for the Example 3?\\n\\nIf k=19, then piles 11 and 4 can be eaten in 2 hours, and then\\n3rd hour, eat 19 from pile 20;\\n4th hour, eat 1 leftover banana and 18 from 23;\\n5th hour, eat 5 leftover bananas and 14 from 30;\\n6th hour, eat 16 leftover bananas;\\n\\nIt took 6 hours. I must be misinterpreting the problem description."
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Thanks guys, great explanations. Right to the point! I was able to solve it after this. I would \n like to add, basically according to the statement each pile takes `ceil(piles[i] / k)` days to eat."
                    },
                    {
                        "username": "Harr1sh",
                        "content": "\"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\\n\\nSo at any given hour, only bananas from a single pile can be eaten."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the problem statement: \"If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\n\nSo, in the 4th hour koko will only eat the 1 leftover banana and then stop. For `k=19`, each pile would therefore take: [2, 1, 2, 1, 2] hours to eat, respectively, for a total of 8 hours. \n\n`k = 23` is the smallest `k` that allows koko to finish all bananas before the guards return."
                    },
                    {
                        "username": "Isha307",
                        "content": "why did you go for binary search? how did you decide it?"
                    },
                    {
                        "username": "Isha307",
                        "content": "[@jolswlf](/jolswlf) got it !! Thank You"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Binary search is generally the fastest way to search for a specific value in an already  sorted data set because each iteration you reduce the search space by half. And since the constraints allow  for pretty large datsets it's almost always going to be faster than linear search. \nYou could implement linear search for the smaller datasets and maybe make it a little bit faster too."
                    },
                    {
                        "username": "cicada44",
                        "content": "Output:\\n\\nTime Limit Exceeded\\n123 / 123 testcases passed\\nLast Executed Input\\nUse Testcase\\npiles =\\n\\nEnd of output\\n\\npiles = WHAT???\\nall tests passed, but time limit exceeded and piles is empty, what\\'s wrong with runner?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Nah. simply speaking , it is just a TLE, a closer one."
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Same...."
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "agar banana uss hour ke reh gaye hai to next hour mei khao aur bass bache hue banana khao uss hour mei\\nnext pile ke nahi same logic `canEatAll` mei use hua hai"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Lol, this is literally the same exact problem as yesterday."
                    },
                    {
                        "username": "r0kkka",
                        "content": "when you think about an workable speed i.e trying to figure is eating speed n is ok, consider going past an hour would consume a full hour.\\n\\ne. g\\n\\nkoko trying to eat a pile of 3 bananas with speed 2. coco would need 2 hours. (so a simple division of pile / speed wouldn\\'t help)"
                    },
                    {
                        "username": "phigh",
                        "content": "In O(nlogn) binary search solution we are inserting values in an equation and checking them one by one (using binary search we just reduce the number of values we insert and check). \\nCant this be done in O(n)? We can find out avg and insert that value, check result and adjust it somehow using min and max value in the piles array and come up with the solution?"
                    },
                    {
                        "username": "peterblockman",
                        "content": "Stuck for an hour until I realized that I needed to round up the time due to this line: \"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour\""
                    },
                    {
                        "username": "_sharma",
                        "content": "how is this medium- difficulty question ?"
                    },
                    {
                        "username": "souravrajvi0",
                        "content": "Kuch smaj hi nahi aara bhai"
                    }
                ]
            },
            {
                "id": 1826009,
                "content": [
                    {
                        "username": "genuine_stamina",
                        "content": "Can somebody explain why 19 is not the answer for the Example 3?\\n\\nIf k=19, then piles 11 and 4 can be eaten in 2 hours, and then\\n3rd hour, eat 19 from pile 20;\\n4th hour, eat 1 leftover banana and 18 from 23;\\n5th hour, eat 5 leftover bananas and 14 from 30;\\n6th hour, eat 16 leftover bananas;\\n\\nIt took 6 hours. I must be misinterpreting the problem description."
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Thanks guys, great explanations. Right to the point! I was able to solve it after this. I would \n like to add, basically according to the statement each pile takes `ceil(piles[i] / k)` days to eat."
                    },
                    {
                        "username": "Harr1sh",
                        "content": "\"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\\n\\nSo at any given hour, only bananas from a single pile can be eaten."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the problem statement: \"If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\n\nSo, in the 4th hour koko will only eat the 1 leftover banana and then stop. For `k=19`, each pile would therefore take: [2, 1, 2, 1, 2] hours to eat, respectively, for a total of 8 hours. \n\n`k = 23` is the smallest `k` that allows koko to finish all bananas before the guards return."
                    },
                    {
                        "username": "Isha307",
                        "content": "why did you go for binary search? how did you decide it?"
                    },
                    {
                        "username": "Isha307",
                        "content": "[@jolswlf](/jolswlf) got it !! Thank You"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Binary search is generally the fastest way to search for a specific value in an already  sorted data set because each iteration you reduce the search space by half. And since the constraints allow  for pretty large datsets it's almost always going to be faster than linear search. \nYou could implement linear search for the smaller datasets and maybe make it a little bit faster too."
                    },
                    {
                        "username": "cicada44",
                        "content": "Output:\\n\\nTime Limit Exceeded\\n123 / 123 testcases passed\\nLast Executed Input\\nUse Testcase\\npiles =\\n\\nEnd of output\\n\\npiles = WHAT???\\nall tests passed, but time limit exceeded and piles is empty, what\\'s wrong with runner?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Nah. simply speaking , it is just a TLE, a closer one."
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Same...."
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "agar banana uss hour ke reh gaye hai to next hour mei khao aur bass bache hue banana khao uss hour mei\\nnext pile ke nahi same logic `canEatAll` mei use hua hai"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Lol, this is literally the same exact problem as yesterday."
                    },
                    {
                        "username": "r0kkka",
                        "content": "when you think about an workable speed i.e trying to figure is eating speed n is ok, consider going past an hour would consume a full hour.\\n\\ne. g\\n\\nkoko trying to eat a pile of 3 bananas with speed 2. coco would need 2 hours. (so a simple division of pile / speed wouldn\\'t help)"
                    },
                    {
                        "username": "phigh",
                        "content": "In O(nlogn) binary search solution we are inserting values in an equation and checking them one by one (using binary search we just reduce the number of values we insert and check). \\nCant this be done in O(n)? We can find out avg and insert that value, check result and adjust it somehow using min and max value in the piles array and come up with the solution?"
                    },
                    {
                        "username": "peterblockman",
                        "content": "Stuck for an hour until I realized that I needed to round up the time due to this line: \"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour\""
                    },
                    {
                        "username": "_sharma",
                        "content": "how is this medium- difficulty question ?"
                    },
                    {
                        "username": "souravrajvi0",
                        "content": "Kuch smaj hi nahi aara bhai"
                    }
                ]
            },
            {
                "id": 1825985,
                "content": [
                    {
                        "username": "genuine_stamina",
                        "content": "Can somebody explain why 19 is not the answer for the Example 3?\\n\\nIf k=19, then piles 11 and 4 can be eaten in 2 hours, and then\\n3rd hour, eat 19 from pile 20;\\n4th hour, eat 1 leftover banana and 18 from 23;\\n5th hour, eat 5 leftover bananas and 14 from 30;\\n6th hour, eat 16 leftover bananas;\\n\\nIt took 6 hours. I must be misinterpreting the problem description."
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Thanks guys, great explanations. Right to the point! I was able to solve it after this. I would \n like to add, basically according to the statement each pile takes `ceil(piles[i] / k)` days to eat."
                    },
                    {
                        "username": "Harr1sh",
                        "content": "\"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\\n\\nSo at any given hour, only bananas from a single pile can be eaten."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the problem statement: \"If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\n\nSo, in the 4th hour koko will only eat the 1 leftover banana and then stop. For `k=19`, each pile would therefore take: [2, 1, 2, 1, 2] hours to eat, respectively, for a total of 8 hours. \n\n`k = 23` is the smallest `k` that allows koko to finish all bananas before the guards return."
                    },
                    {
                        "username": "Isha307",
                        "content": "why did you go for binary search? how did you decide it?"
                    },
                    {
                        "username": "Isha307",
                        "content": "[@jolswlf](/jolswlf) got it !! Thank You"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Binary search is generally the fastest way to search for a specific value in an already  sorted data set because each iteration you reduce the search space by half. And since the constraints allow  for pretty large datsets it's almost always going to be faster than linear search. \nYou could implement linear search for the smaller datasets and maybe make it a little bit faster too."
                    },
                    {
                        "username": "cicada44",
                        "content": "Output:\\n\\nTime Limit Exceeded\\n123 / 123 testcases passed\\nLast Executed Input\\nUse Testcase\\npiles =\\n\\nEnd of output\\n\\npiles = WHAT???\\nall tests passed, but time limit exceeded and piles is empty, what\\'s wrong with runner?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Nah. simply speaking , it is just a TLE, a closer one."
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Same...."
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "agar banana uss hour ke reh gaye hai to next hour mei khao aur bass bache hue banana khao uss hour mei\\nnext pile ke nahi same logic `canEatAll` mei use hua hai"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Lol, this is literally the same exact problem as yesterday."
                    },
                    {
                        "username": "r0kkka",
                        "content": "when you think about an workable speed i.e trying to figure is eating speed n is ok, consider going past an hour would consume a full hour.\\n\\ne. g\\n\\nkoko trying to eat a pile of 3 bananas with speed 2. coco would need 2 hours. (so a simple division of pile / speed wouldn\\'t help)"
                    },
                    {
                        "username": "phigh",
                        "content": "In O(nlogn) binary search solution we are inserting values in an equation and checking them one by one (using binary search we just reduce the number of values we insert and check). \\nCant this be done in O(n)? We can find out avg and insert that value, check result and adjust it somehow using min and max value in the piles array and come up with the solution?"
                    },
                    {
                        "username": "peterblockman",
                        "content": "Stuck for an hour until I realized that I needed to round up the time due to this line: \"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour\""
                    },
                    {
                        "username": "_sharma",
                        "content": "how is this medium- difficulty question ?"
                    },
                    {
                        "username": "souravrajvi0",
                        "content": "Kuch smaj hi nahi aara bhai"
                    }
                ]
            },
            {
                "id": 1676113,
                "content": [
                    {
                        "username": "genuine_stamina",
                        "content": "Can somebody explain why 19 is not the answer for the Example 3?\\n\\nIf k=19, then piles 11 and 4 can be eaten in 2 hours, and then\\n3rd hour, eat 19 from pile 20;\\n4th hour, eat 1 leftover banana and 18 from 23;\\n5th hour, eat 5 leftover bananas and 14 from 30;\\n6th hour, eat 16 leftover bananas;\\n\\nIt took 6 hours. I must be misinterpreting the problem description."
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Thanks guys, great explanations. Right to the point! I was able to solve it after this. I would \n like to add, basically according to the statement each pile takes `ceil(piles[i] / k)` days to eat."
                    },
                    {
                        "username": "Harr1sh",
                        "content": "\"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\\n\\nSo at any given hour, only bananas from a single pile can be eaten."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the problem statement: \"If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\n\nSo, in the 4th hour koko will only eat the 1 leftover banana and then stop. For `k=19`, each pile would therefore take: [2, 1, 2, 1, 2] hours to eat, respectively, for a total of 8 hours. \n\n`k = 23` is the smallest `k` that allows koko to finish all bananas before the guards return."
                    },
                    {
                        "username": "Isha307",
                        "content": "why did you go for binary search? how did you decide it?"
                    },
                    {
                        "username": "Isha307",
                        "content": "[@jolswlf](/jolswlf) got it !! Thank You"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Binary search is generally the fastest way to search for a specific value in an already  sorted data set because each iteration you reduce the search space by half. And since the constraints allow  for pretty large datsets it's almost always going to be faster than linear search. \nYou could implement linear search for the smaller datasets and maybe make it a little bit faster too."
                    },
                    {
                        "username": "cicada44",
                        "content": "Output:\\n\\nTime Limit Exceeded\\n123 / 123 testcases passed\\nLast Executed Input\\nUse Testcase\\npiles =\\n\\nEnd of output\\n\\npiles = WHAT???\\nall tests passed, but time limit exceeded and piles is empty, what\\'s wrong with runner?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Nah. simply speaking , it is just a TLE, a closer one."
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Same...."
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "agar banana uss hour ke reh gaye hai to next hour mei khao aur bass bache hue banana khao uss hour mei\\nnext pile ke nahi same logic `canEatAll` mei use hua hai"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Lol, this is literally the same exact problem as yesterday."
                    },
                    {
                        "username": "r0kkka",
                        "content": "when you think about an workable speed i.e trying to figure is eating speed n is ok, consider going past an hour would consume a full hour.\\n\\ne. g\\n\\nkoko trying to eat a pile of 3 bananas with speed 2. coco would need 2 hours. (so a simple division of pile / speed wouldn\\'t help)"
                    },
                    {
                        "username": "phigh",
                        "content": "In O(nlogn) binary search solution we are inserting values in an equation and checking them one by one (using binary search we just reduce the number of values we insert and check). \\nCant this be done in O(n)? We can find out avg and insert that value, check result and adjust it somehow using min and max value in the piles array and come up with the solution?"
                    },
                    {
                        "username": "peterblockman",
                        "content": "Stuck for an hour until I realized that I needed to round up the time due to this line: \"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour\""
                    },
                    {
                        "username": "_sharma",
                        "content": "how is this medium- difficulty question ?"
                    },
                    {
                        "username": "souravrajvi0",
                        "content": "Kuch smaj hi nahi aara bhai"
                    }
                ]
            },
            {
                "id": 1572563,
                "content": [
                    {
                        "username": "genuine_stamina",
                        "content": "Can somebody explain why 19 is not the answer for the Example 3?\\n\\nIf k=19, then piles 11 and 4 can be eaten in 2 hours, and then\\n3rd hour, eat 19 from pile 20;\\n4th hour, eat 1 leftover banana and 18 from 23;\\n5th hour, eat 5 leftover bananas and 14 from 30;\\n6th hour, eat 16 leftover bananas;\\n\\nIt took 6 hours. I must be misinterpreting the problem description."
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Thanks guys, great explanations. Right to the point! I was able to solve it after this. I would \n like to add, basically according to the statement each pile takes `ceil(piles[i] / k)` days to eat."
                    },
                    {
                        "username": "Harr1sh",
                        "content": "\"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\\n\\nSo at any given hour, only bananas from a single pile can be eaten."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the problem statement: \"If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\n\nSo, in the 4th hour koko will only eat the 1 leftover banana and then stop. For `k=19`, each pile would therefore take: [2, 1, 2, 1, 2] hours to eat, respectively, for a total of 8 hours. \n\n`k = 23` is the smallest `k` that allows koko to finish all bananas before the guards return."
                    },
                    {
                        "username": "Isha307",
                        "content": "why did you go for binary search? how did you decide it?"
                    },
                    {
                        "username": "Isha307",
                        "content": "[@jolswlf](/jolswlf) got it !! Thank You"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Binary search is generally the fastest way to search for a specific value in an already  sorted data set because each iteration you reduce the search space by half. And since the constraints allow  for pretty large datsets it's almost always going to be faster than linear search. \nYou could implement linear search for the smaller datasets and maybe make it a little bit faster too."
                    },
                    {
                        "username": "cicada44",
                        "content": "Output:\\n\\nTime Limit Exceeded\\n123 / 123 testcases passed\\nLast Executed Input\\nUse Testcase\\npiles =\\n\\nEnd of output\\n\\npiles = WHAT???\\nall tests passed, but time limit exceeded and piles is empty, what\\'s wrong with runner?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Nah. simply speaking , it is just a TLE, a closer one."
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Same...."
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "agar banana uss hour ke reh gaye hai to next hour mei khao aur bass bache hue banana khao uss hour mei\\nnext pile ke nahi same logic `canEatAll` mei use hua hai"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Lol, this is literally the same exact problem as yesterday."
                    },
                    {
                        "username": "r0kkka",
                        "content": "when you think about an workable speed i.e trying to figure is eating speed n is ok, consider going past an hour would consume a full hour.\\n\\ne. g\\n\\nkoko trying to eat a pile of 3 bananas with speed 2. coco would need 2 hours. (so a simple division of pile / speed wouldn\\'t help)"
                    },
                    {
                        "username": "phigh",
                        "content": "In O(nlogn) binary search solution we are inserting values in an equation and checking them one by one (using binary search we just reduce the number of values we insert and check). \\nCant this be done in O(n)? We can find out avg and insert that value, check result and adjust it somehow using min and max value in the piles array and come up with the solution?"
                    },
                    {
                        "username": "peterblockman",
                        "content": "Stuck for an hour until I realized that I needed to round up the time due to this line: \"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour\""
                    },
                    {
                        "username": "_sharma",
                        "content": "how is this medium- difficulty question ?"
                    },
                    {
                        "username": "souravrajvi0",
                        "content": "Kuch smaj hi nahi aara bhai"
                    }
                ]
            },
            {
                "id": 2076398,
                "content": [
                    {
                        "username": "genuine_stamina",
                        "content": "Can somebody explain why 19 is not the answer for the Example 3?\\n\\nIf k=19, then piles 11 and 4 can be eaten in 2 hours, and then\\n3rd hour, eat 19 from pile 20;\\n4th hour, eat 1 leftover banana and 18 from 23;\\n5th hour, eat 5 leftover bananas and 14 from 30;\\n6th hour, eat 16 leftover bananas;\\n\\nIt took 6 hours. I must be misinterpreting the problem description."
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Thanks guys, great explanations. Right to the point! I was able to solve it after this. I would \n like to add, basically according to the statement each pile takes `ceil(piles[i] / k)` days to eat."
                    },
                    {
                        "username": "Harr1sh",
                        "content": "\"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\\n\\nSo at any given hour, only bananas from a single pile can be eaten."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the problem statement: \"If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\n\nSo, in the 4th hour koko will only eat the 1 leftover banana and then stop. For `k=19`, each pile would therefore take: [2, 1, 2, 1, 2] hours to eat, respectively, for a total of 8 hours. \n\n`k = 23` is the smallest `k` that allows koko to finish all bananas before the guards return."
                    },
                    {
                        "username": "Isha307",
                        "content": "why did you go for binary search? how did you decide it?"
                    },
                    {
                        "username": "Isha307",
                        "content": "[@jolswlf](/jolswlf) got it !! Thank You"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Binary search is generally the fastest way to search for a specific value in an already  sorted data set because each iteration you reduce the search space by half. And since the constraints allow  for pretty large datsets it's almost always going to be faster than linear search. \nYou could implement linear search for the smaller datasets and maybe make it a little bit faster too."
                    },
                    {
                        "username": "cicada44",
                        "content": "Output:\\n\\nTime Limit Exceeded\\n123 / 123 testcases passed\\nLast Executed Input\\nUse Testcase\\npiles =\\n\\nEnd of output\\n\\npiles = WHAT???\\nall tests passed, but time limit exceeded and piles is empty, what\\'s wrong with runner?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Nah. simply speaking , it is just a TLE, a closer one."
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Same...."
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "agar banana uss hour ke reh gaye hai to next hour mei khao aur bass bache hue banana khao uss hour mei\\nnext pile ke nahi same logic `canEatAll` mei use hua hai"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Lol, this is literally the same exact problem as yesterday."
                    },
                    {
                        "username": "r0kkka",
                        "content": "when you think about an workable speed i.e trying to figure is eating speed n is ok, consider going past an hour would consume a full hour.\\n\\ne. g\\n\\nkoko trying to eat a pile of 3 bananas with speed 2. coco would need 2 hours. (so a simple division of pile / speed wouldn\\'t help)"
                    },
                    {
                        "username": "phigh",
                        "content": "In O(nlogn) binary search solution we are inserting values in an equation and checking them one by one (using binary search we just reduce the number of values we insert and check). \\nCant this be done in O(n)? We can find out avg and insert that value, check result and adjust it somehow using min and max value in the piles array and come up with the solution?"
                    },
                    {
                        "username": "peterblockman",
                        "content": "Stuck for an hour until I realized that I needed to round up the time due to this line: \"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour\""
                    },
                    {
                        "username": "_sharma",
                        "content": "how is this medium- difficulty question ?"
                    },
                    {
                        "username": "souravrajvi0",
                        "content": "Kuch smaj hi nahi aara bhai"
                    }
                ]
            },
            {
                "id": 2072214,
                "content": [
                    {
                        "username": "genuine_stamina",
                        "content": "Can somebody explain why 19 is not the answer for the Example 3?\\n\\nIf k=19, then piles 11 and 4 can be eaten in 2 hours, and then\\n3rd hour, eat 19 from pile 20;\\n4th hour, eat 1 leftover banana and 18 from 23;\\n5th hour, eat 5 leftover bananas and 14 from 30;\\n6th hour, eat 16 leftover bananas;\\n\\nIt took 6 hours. I must be misinterpreting the problem description."
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Thanks guys, great explanations. Right to the point! I was able to solve it after this. I would \n like to add, basically according to the statement each pile takes `ceil(piles[i] / k)` days to eat."
                    },
                    {
                        "username": "Harr1sh",
                        "content": "\"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\\n\\nSo at any given hour, only bananas from a single pile can be eaten."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the problem statement: \"If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\n\nSo, in the 4th hour koko will only eat the 1 leftover banana and then stop. For `k=19`, each pile would therefore take: [2, 1, 2, 1, 2] hours to eat, respectively, for a total of 8 hours. \n\n`k = 23` is the smallest `k` that allows koko to finish all bananas before the guards return."
                    },
                    {
                        "username": "Isha307",
                        "content": "why did you go for binary search? how did you decide it?"
                    },
                    {
                        "username": "Isha307",
                        "content": "[@jolswlf](/jolswlf) got it !! Thank You"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Binary search is generally the fastest way to search for a specific value in an already  sorted data set because each iteration you reduce the search space by half. And since the constraints allow  for pretty large datsets it's almost always going to be faster than linear search. \nYou could implement linear search for the smaller datasets and maybe make it a little bit faster too."
                    },
                    {
                        "username": "cicada44",
                        "content": "Output:\\n\\nTime Limit Exceeded\\n123 / 123 testcases passed\\nLast Executed Input\\nUse Testcase\\npiles =\\n\\nEnd of output\\n\\npiles = WHAT???\\nall tests passed, but time limit exceeded and piles is empty, what\\'s wrong with runner?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Nah. simply speaking , it is just a TLE, a closer one."
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Same...."
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "agar banana uss hour ke reh gaye hai to next hour mei khao aur bass bache hue banana khao uss hour mei\\nnext pile ke nahi same logic `canEatAll` mei use hua hai"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Lol, this is literally the same exact problem as yesterday."
                    },
                    {
                        "username": "r0kkka",
                        "content": "when you think about an workable speed i.e trying to figure is eating speed n is ok, consider going past an hour would consume a full hour.\\n\\ne. g\\n\\nkoko trying to eat a pile of 3 bananas with speed 2. coco would need 2 hours. (so a simple division of pile / speed wouldn\\'t help)"
                    },
                    {
                        "username": "phigh",
                        "content": "In O(nlogn) binary search solution we are inserting values in an equation and checking them one by one (using binary search we just reduce the number of values we insert and check). \\nCant this be done in O(n)? We can find out avg and insert that value, check result and adjust it somehow using min and max value in the piles array and come up with the solution?"
                    },
                    {
                        "username": "peterblockman",
                        "content": "Stuck for an hour until I realized that I needed to round up the time due to this line: \"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour\""
                    },
                    {
                        "username": "_sharma",
                        "content": "how is this medium- difficulty question ?"
                    },
                    {
                        "username": "souravrajvi0",
                        "content": "Kuch smaj hi nahi aara bhai"
                    }
                ]
            },
            {
                "id": 2065454,
                "content": [
                    {
                        "username": "genuine_stamina",
                        "content": "Can somebody explain why 19 is not the answer for the Example 3?\\n\\nIf k=19, then piles 11 and 4 can be eaten in 2 hours, and then\\n3rd hour, eat 19 from pile 20;\\n4th hour, eat 1 leftover banana and 18 from 23;\\n5th hour, eat 5 leftover bananas and 14 from 30;\\n6th hour, eat 16 leftover bananas;\\n\\nIt took 6 hours. I must be misinterpreting the problem description."
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Thanks guys, great explanations. Right to the point! I was able to solve it after this. I would \n like to add, basically according to the statement each pile takes `ceil(piles[i] / k)` days to eat."
                    },
                    {
                        "username": "Harr1sh",
                        "content": "\"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\\n\\nSo at any given hour, only bananas from a single pile can be eaten."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the problem statement: \"If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\n\nSo, in the 4th hour koko will only eat the 1 leftover banana and then stop. For `k=19`, each pile would therefore take: [2, 1, 2, 1, 2] hours to eat, respectively, for a total of 8 hours. \n\n`k = 23` is the smallest `k` that allows koko to finish all bananas before the guards return."
                    },
                    {
                        "username": "Isha307",
                        "content": "why did you go for binary search? how did you decide it?"
                    },
                    {
                        "username": "Isha307",
                        "content": "[@jolswlf](/jolswlf) got it !! Thank You"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Binary search is generally the fastest way to search for a specific value in an already  sorted data set because each iteration you reduce the search space by half. And since the constraints allow  for pretty large datsets it's almost always going to be faster than linear search. \nYou could implement linear search for the smaller datasets and maybe make it a little bit faster too."
                    },
                    {
                        "username": "cicada44",
                        "content": "Output:\\n\\nTime Limit Exceeded\\n123 / 123 testcases passed\\nLast Executed Input\\nUse Testcase\\npiles =\\n\\nEnd of output\\n\\npiles = WHAT???\\nall tests passed, but time limit exceeded and piles is empty, what\\'s wrong with runner?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Nah. simply speaking , it is just a TLE, a closer one."
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Same...."
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "agar banana uss hour ke reh gaye hai to next hour mei khao aur bass bache hue banana khao uss hour mei\\nnext pile ke nahi same logic `canEatAll` mei use hua hai"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Lol, this is literally the same exact problem as yesterday."
                    },
                    {
                        "username": "r0kkka",
                        "content": "when you think about an workable speed i.e trying to figure is eating speed n is ok, consider going past an hour would consume a full hour.\\n\\ne. g\\n\\nkoko trying to eat a pile of 3 bananas with speed 2. coco would need 2 hours. (so a simple division of pile / speed wouldn\\'t help)"
                    },
                    {
                        "username": "phigh",
                        "content": "In O(nlogn) binary search solution we are inserting values in an equation and checking them one by one (using binary search we just reduce the number of values we insert and check). \\nCant this be done in O(n)? We can find out avg and insert that value, check result and adjust it somehow using min and max value in the piles array and come up with the solution?"
                    },
                    {
                        "username": "peterblockman",
                        "content": "Stuck for an hour until I realized that I needed to round up the time due to this line: \"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour\""
                    },
                    {
                        "username": "_sharma",
                        "content": "how is this medium- difficulty question ?"
                    },
                    {
                        "username": "souravrajvi0",
                        "content": "Kuch smaj hi nahi aara bhai"
                    }
                ]
            },
            {
                "id": 2065086,
                "content": [
                    {
                        "username": "nigmetzianov",
                        "content": "I'm pretty sure I have the right solution which even gives a lower number for test case 119. It's not binary search per se, but I do use it inside.\n\nexpected is 78332 but I get 78326 \n\n ```\nvar minEatingSpeed = function (piles, h) {\n  piles = piles.sort((a, b) => a - b);\n  const target = Math.ceil(piles.reduce((p, n) => p + n, 0) / h);\n  let l = 0;\n  let r = piles.length - 1;\n  while (l < r) {\n    const mid = l + Math.floor((r - l + 1) / 2);\n    if (piles[mid] > target) {\n      r = mid - 1;\n    } else {\n      l = mid;\n    }\n  }\n  const availibleSpots = h - piles.length;\n  const jumpsToDo = piles.length - l;\n  if (jumpsToDo > availibleSpots) {\n    return piles[piles.length - availibleSpots - 1];\n  } else {\n    return Math.ceil(\n      piles.slice(l, piles.length).reduce((p, n) => p + n, 0) / (h - l - 1)\n    );\n  }\n};```"
                    },
                    {
                        "username": "uniqs",
                        "content": "so what will the guards do when they come back and found out that every pile of bananas have gone? Koko should eat faster to keep time to run."
                    },
                    {
                        "username": "21bcs069",
                        "content": "this question has same pattern as leetcode 1870. dito same approach."
                    },
                    {
                        "username": "jacobj2",
                        "content": "Solved this question but was wondering how we would know when to return the left or right pointer in general binary search problems?"
                    },
                    {
                        "username": "nadabao",
                        "content": "\"she chooses some pile of bananas and eats k bananas from that pile.\"\\n\\nok, so the description should clarify during one-hour period, koko will only choose one pile. The more greedy monkey can finish more bananas from other pile if current pile has < k bananas!"
                    },
                    {
                        "username": "shubham_patel",
                        "content": "I dont understand why the below test case is failing\\n\\npiles = [805306368,805306368,805306368]\\nh = 1000000000\\n\\nOutput : 1\\nExpected output : 3\\n\\n\\n\\n`private int calculateCost(int v, int[] piles) {\\n        int c = 0;\\n        for(int i=0; i<piles.length; i++) {\\n            c+= piles[i]/v + (piles[i]%v==0 ? 0 : 1);\\n        }\\n        return c;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int n = piles.length;\\n        int maxi=0;\\n        for(int i=0; i<n; i++) maxi=Math.max(maxi,piles[i]);\\n\\n        int r = maxi;\\n        int l = 1;\\n        while(l<=r) {\\n            int m = (l+r)/2;\\n            int cm = calculateCost(m, piles);\\n            if(cm > h) {\\n                l = m+1;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        return l;\\n    }`"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please let me also know when you resolve the issue. I am also stuck here. only one testcase is failed and remaining are working fine for me."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "Clearing the confusion .  At a time Koko can choose only one pile / index  from that single pile she can decide according to her capacity how much banana she can take at a time  *~*"
                    },
                    {
                        "username": "SubstantialCattle5",
                        "content": "all my homies hate koko "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I don\\'t know why but I hate this problem a lot."
                    },
                    {
                        "username": "tonynin1",
                        "content": "I think the guards have gone to buy milk  :)"
                    }
                ]
            },
            {
                "id": 2061739,
                "content": [
                    {
                        "username": "nigmetzianov",
                        "content": "I'm pretty sure I have the right solution which even gives a lower number for test case 119. It's not binary search per se, but I do use it inside.\n\nexpected is 78332 but I get 78326 \n\n ```\nvar minEatingSpeed = function (piles, h) {\n  piles = piles.sort((a, b) => a - b);\n  const target = Math.ceil(piles.reduce((p, n) => p + n, 0) / h);\n  let l = 0;\n  let r = piles.length - 1;\n  while (l < r) {\n    const mid = l + Math.floor((r - l + 1) / 2);\n    if (piles[mid] > target) {\n      r = mid - 1;\n    } else {\n      l = mid;\n    }\n  }\n  const availibleSpots = h - piles.length;\n  const jumpsToDo = piles.length - l;\n  if (jumpsToDo > availibleSpots) {\n    return piles[piles.length - availibleSpots - 1];\n  } else {\n    return Math.ceil(\n      piles.slice(l, piles.length).reduce((p, n) => p + n, 0) / (h - l - 1)\n    );\n  }\n};```"
                    },
                    {
                        "username": "uniqs",
                        "content": "so what will the guards do when they come back and found out that every pile of bananas have gone? Koko should eat faster to keep time to run."
                    },
                    {
                        "username": "21bcs069",
                        "content": "this question has same pattern as leetcode 1870. dito same approach."
                    },
                    {
                        "username": "jacobj2",
                        "content": "Solved this question but was wondering how we would know when to return the left or right pointer in general binary search problems?"
                    },
                    {
                        "username": "nadabao",
                        "content": "\"she chooses some pile of bananas and eats k bananas from that pile.\"\\n\\nok, so the description should clarify during one-hour period, koko will only choose one pile. The more greedy monkey can finish more bananas from other pile if current pile has < k bananas!"
                    },
                    {
                        "username": "shubham_patel",
                        "content": "I dont understand why the below test case is failing\\n\\npiles = [805306368,805306368,805306368]\\nh = 1000000000\\n\\nOutput : 1\\nExpected output : 3\\n\\n\\n\\n`private int calculateCost(int v, int[] piles) {\\n        int c = 0;\\n        for(int i=0; i<piles.length; i++) {\\n            c+= piles[i]/v + (piles[i]%v==0 ? 0 : 1);\\n        }\\n        return c;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int n = piles.length;\\n        int maxi=0;\\n        for(int i=0; i<n; i++) maxi=Math.max(maxi,piles[i]);\\n\\n        int r = maxi;\\n        int l = 1;\\n        while(l<=r) {\\n            int m = (l+r)/2;\\n            int cm = calculateCost(m, piles);\\n            if(cm > h) {\\n                l = m+1;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        return l;\\n    }`"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please let me also know when you resolve the issue. I am also stuck here. only one testcase is failed and remaining are working fine for me."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "Clearing the confusion .  At a time Koko can choose only one pile / index  from that single pile she can decide according to her capacity how much banana she can take at a time  *~*"
                    },
                    {
                        "username": "SubstantialCattle5",
                        "content": "all my homies hate koko "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I don\\'t know why but I hate this problem a lot."
                    },
                    {
                        "username": "tonynin1",
                        "content": "I think the guards have gone to buy milk  :)"
                    }
                ]
            },
            {
                "id": 2059067,
                "content": [
                    {
                        "username": "nigmetzianov",
                        "content": "I'm pretty sure I have the right solution which even gives a lower number for test case 119. It's not binary search per se, but I do use it inside.\n\nexpected is 78332 but I get 78326 \n\n ```\nvar minEatingSpeed = function (piles, h) {\n  piles = piles.sort((a, b) => a - b);\n  const target = Math.ceil(piles.reduce((p, n) => p + n, 0) / h);\n  let l = 0;\n  let r = piles.length - 1;\n  while (l < r) {\n    const mid = l + Math.floor((r - l + 1) / 2);\n    if (piles[mid] > target) {\n      r = mid - 1;\n    } else {\n      l = mid;\n    }\n  }\n  const availibleSpots = h - piles.length;\n  const jumpsToDo = piles.length - l;\n  if (jumpsToDo > availibleSpots) {\n    return piles[piles.length - availibleSpots - 1];\n  } else {\n    return Math.ceil(\n      piles.slice(l, piles.length).reduce((p, n) => p + n, 0) / (h - l - 1)\n    );\n  }\n};```"
                    },
                    {
                        "username": "uniqs",
                        "content": "so what will the guards do when they come back and found out that every pile of bananas have gone? Koko should eat faster to keep time to run."
                    },
                    {
                        "username": "21bcs069",
                        "content": "this question has same pattern as leetcode 1870. dito same approach."
                    },
                    {
                        "username": "jacobj2",
                        "content": "Solved this question but was wondering how we would know when to return the left or right pointer in general binary search problems?"
                    },
                    {
                        "username": "nadabao",
                        "content": "\"she chooses some pile of bananas and eats k bananas from that pile.\"\\n\\nok, so the description should clarify during one-hour period, koko will only choose one pile. The more greedy monkey can finish more bananas from other pile if current pile has < k bananas!"
                    },
                    {
                        "username": "shubham_patel",
                        "content": "I dont understand why the below test case is failing\\n\\npiles = [805306368,805306368,805306368]\\nh = 1000000000\\n\\nOutput : 1\\nExpected output : 3\\n\\n\\n\\n`private int calculateCost(int v, int[] piles) {\\n        int c = 0;\\n        for(int i=0; i<piles.length; i++) {\\n            c+= piles[i]/v + (piles[i]%v==0 ? 0 : 1);\\n        }\\n        return c;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int n = piles.length;\\n        int maxi=0;\\n        for(int i=0; i<n; i++) maxi=Math.max(maxi,piles[i]);\\n\\n        int r = maxi;\\n        int l = 1;\\n        while(l<=r) {\\n            int m = (l+r)/2;\\n            int cm = calculateCost(m, piles);\\n            if(cm > h) {\\n                l = m+1;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        return l;\\n    }`"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please let me also know when you resolve the issue. I am also stuck here. only one testcase is failed and remaining are working fine for me."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "Clearing the confusion .  At a time Koko can choose only one pile / index  from that single pile she can decide according to her capacity how much banana she can take at a time  *~*"
                    },
                    {
                        "username": "SubstantialCattle5",
                        "content": "all my homies hate koko "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I don\\'t know why but I hate this problem a lot."
                    },
                    {
                        "username": "tonynin1",
                        "content": "I think the guards have gone to buy milk  :)"
                    }
                ]
            },
            {
                "id": 2054050,
                "content": [
                    {
                        "username": "nigmetzianov",
                        "content": "I'm pretty sure I have the right solution which even gives a lower number for test case 119. It's not binary search per se, but I do use it inside.\n\nexpected is 78332 but I get 78326 \n\n ```\nvar minEatingSpeed = function (piles, h) {\n  piles = piles.sort((a, b) => a - b);\n  const target = Math.ceil(piles.reduce((p, n) => p + n, 0) / h);\n  let l = 0;\n  let r = piles.length - 1;\n  while (l < r) {\n    const mid = l + Math.floor((r - l + 1) / 2);\n    if (piles[mid] > target) {\n      r = mid - 1;\n    } else {\n      l = mid;\n    }\n  }\n  const availibleSpots = h - piles.length;\n  const jumpsToDo = piles.length - l;\n  if (jumpsToDo > availibleSpots) {\n    return piles[piles.length - availibleSpots - 1];\n  } else {\n    return Math.ceil(\n      piles.slice(l, piles.length).reduce((p, n) => p + n, 0) / (h - l - 1)\n    );\n  }\n};```"
                    },
                    {
                        "username": "uniqs",
                        "content": "so what will the guards do when they come back and found out that every pile of bananas have gone? Koko should eat faster to keep time to run."
                    },
                    {
                        "username": "21bcs069",
                        "content": "this question has same pattern as leetcode 1870. dito same approach."
                    },
                    {
                        "username": "jacobj2",
                        "content": "Solved this question but was wondering how we would know when to return the left or right pointer in general binary search problems?"
                    },
                    {
                        "username": "nadabao",
                        "content": "\"she chooses some pile of bananas and eats k bananas from that pile.\"\\n\\nok, so the description should clarify during one-hour period, koko will only choose one pile. The more greedy monkey can finish more bananas from other pile if current pile has < k bananas!"
                    },
                    {
                        "username": "shubham_patel",
                        "content": "I dont understand why the below test case is failing\\n\\npiles = [805306368,805306368,805306368]\\nh = 1000000000\\n\\nOutput : 1\\nExpected output : 3\\n\\n\\n\\n`private int calculateCost(int v, int[] piles) {\\n        int c = 0;\\n        for(int i=0; i<piles.length; i++) {\\n            c+= piles[i]/v + (piles[i]%v==0 ? 0 : 1);\\n        }\\n        return c;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int n = piles.length;\\n        int maxi=0;\\n        for(int i=0; i<n; i++) maxi=Math.max(maxi,piles[i]);\\n\\n        int r = maxi;\\n        int l = 1;\\n        while(l<=r) {\\n            int m = (l+r)/2;\\n            int cm = calculateCost(m, piles);\\n            if(cm > h) {\\n                l = m+1;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        return l;\\n    }`"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please let me also know when you resolve the issue. I am also stuck here. only one testcase is failed and remaining are working fine for me."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "Clearing the confusion .  At a time Koko can choose only one pile / index  from that single pile she can decide according to her capacity how much banana she can take at a time  *~*"
                    },
                    {
                        "username": "SubstantialCattle5",
                        "content": "all my homies hate koko "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I don\\'t know why but I hate this problem a lot."
                    },
                    {
                        "username": "tonynin1",
                        "content": "I think the guards have gone to buy milk  :)"
                    }
                ]
            },
            {
                "id": 2051010,
                "content": [
                    {
                        "username": "nigmetzianov",
                        "content": "I'm pretty sure I have the right solution which even gives a lower number for test case 119. It's not binary search per se, but I do use it inside.\n\nexpected is 78332 but I get 78326 \n\n ```\nvar minEatingSpeed = function (piles, h) {\n  piles = piles.sort((a, b) => a - b);\n  const target = Math.ceil(piles.reduce((p, n) => p + n, 0) / h);\n  let l = 0;\n  let r = piles.length - 1;\n  while (l < r) {\n    const mid = l + Math.floor((r - l + 1) / 2);\n    if (piles[mid] > target) {\n      r = mid - 1;\n    } else {\n      l = mid;\n    }\n  }\n  const availibleSpots = h - piles.length;\n  const jumpsToDo = piles.length - l;\n  if (jumpsToDo > availibleSpots) {\n    return piles[piles.length - availibleSpots - 1];\n  } else {\n    return Math.ceil(\n      piles.slice(l, piles.length).reduce((p, n) => p + n, 0) / (h - l - 1)\n    );\n  }\n};```"
                    },
                    {
                        "username": "uniqs",
                        "content": "so what will the guards do when they come back and found out that every pile of bananas have gone? Koko should eat faster to keep time to run."
                    },
                    {
                        "username": "21bcs069",
                        "content": "this question has same pattern as leetcode 1870. dito same approach."
                    },
                    {
                        "username": "jacobj2",
                        "content": "Solved this question but was wondering how we would know when to return the left or right pointer in general binary search problems?"
                    },
                    {
                        "username": "nadabao",
                        "content": "\"she chooses some pile of bananas and eats k bananas from that pile.\"\\n\\nok, so the description should clarify during one-hour period, koko will only choose one pile. The more greedy monkey can finish more bananas from other pile if current pile has < k bananas!"
                    },
                    {
                        "username": "shubham_patel",
                        "content": "I dont understand why the below test case is failing\\n\\npiles = [805306368,805306368,805306368]\\nh = 1000000000\\n\\nOutput : 1\\nExpected output : 3\\n\\n\\n\\n`private int calculateCost(int v, int[] piles) {\\n        int c = 0;\\n        for(int i=0; i<piles.length; i++) {\\n            c+= piles[i]/v + (piles[i]%v==0 ? 0 : 1);\\n        }\\n        return c;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int n = piles.length;\\n        int maxi=0;\\n        for(int i=0; i<n; i++) maxi=Math.max(maxi,piles[i]);\\n\\n        int r = maxi;\\n        int l = 1;\\n        while(l<=r) {\\n            int m = (l+r)/2;\\n            int cm = calculateCost(m, piles);\\n            if(cm > h) {\\n                l = m+1;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        return l;\\n    }`"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please let me also know when you resolve the issue. I am also stuck here. only one testcase is failed and remaining are working fine for me."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "Clearing the confusion .  At a time Koko can choose only one pile / index  from that single pile she can decide according to her capacity how much banana she can take at a time  *~*"
                    },
                    {
                        "username": "SubstantialCattle5",
                        "content": "all my homies hate koko "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I don\\'t know why but I hate this problem a lot."
                    },
                    {
                        "username": "tonynin1",
                        "content": "I think the guards have gone to buy milk  :)"
                    }
                ]
            },
            {
                "id": 2047694,
                "content": [
                    {
                        "username": "nigmetzianov",
                        "content": "I'm pretty sure I have the right solution which even gives a lower number for test case 119. It's not binary search per se, but I do use it inside.\n\nexpected is 78332 but I get 78326 \n\n ```\nvar minEatingSpeed = function (piles, h) {\n  piles = piles.sort((a, b) => a - b);\n  const target = Math.ceil(piles.reduce((p, n) => p + n, 0) / h);\n  let l = 0;\n  let r = piles.length - 1;\n  while (l < r) {\n    const mid = l + Math.floor((r - l + 1) / 2);\n    if (piles[mid] > target) {\n      r = mid - 1;\n    } else {\n      l = mid;\n    }\n  }\n  const availibleSpots = h - piles.length;\n  const jumpsToDo = piles.length - l;\n  if (jumpsToDo > availibleSpots) {\n    return piles[piles.length - availibleSpots - 1];\n  } else {\n    return Math.ceil(\n      piles.slice(l, piles.length).reduce((p, n) => p + n, 0) / (h - l - 1)\n    );\n  }\n};```"
                    },
                    {
                        "username": "uniqs",
                        "content": "so what will the guards do when they come back and found out that every pile of bananas have gone? Koko should eat faster to keep time to run."
                    },
                    {
                        "username": "21bcs069",
                        "content": "this question has same pattern as leetcode 1870. dito same approach."
                    },
                    {
                        "username": "jacobj2",
                        "content": "Solved this question but was wondering how we would know when to return the left or right pointer in general binary search problems?"
                    },
                    {
                        "username": "nadabao",
                        "content": "\"she chooses some pile of bananas and eats k bananas from that pile.\"\\n\\nok, so the description should clarify during one-hour period, koko will only choose one pile. The more greedy monkey can finish more bananas from other pile if current pile has < k bananas!"
                    },
                    {
                        "username": "shubham_patel",
                        "content": "I dont understand why the below test case is failing\\n\\npiles = [805306368,805306368,805306368]\\nh = 1000000000\\n\\nOutput : 1\\nExpected output : 3\\n\\n\\n\\n`private int calculateCost(int v, int[] piles) {\\n        int c = 0;\\n        for(int i=0; i<piles.length; i++) {\\n            c+= piles[i]/v + (piles[i]%v==0 ? 0 : 1);\\n        }\\n        return c;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int n = piles.length;\\n        int maxi=0;\\n        for(int i=0; i<n; i++) maxi=Math.max(maxi,piles[i]);\\n\\n        int r = maxi;\\n        int l = 1;\\n        while(l<=r) {\\n            int m = (l+r)/2;\\n            int cm = calculateCost(m, piles);\\n            if(cm > h) {\\n                l = m+1;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        return l;\\n    }`"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please let me also know when you resolve the issue. I am also stuck here. only one testcase is failed and remaining are working fine for me."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "Clearing the confusion .  At a time Koko can choose only one pile / index  from that single pile she can decide according to her capacity how much banana she can take at a time  *~*"
                    },
                    {
                        "username": "SubstantialCattle5",
                        "content": "all my homies hate koko "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I don\\'t know why but I hate this problem a lot."
                    },
                    {
                        "username": "tonynin1",
                        "content": "I think the guards have gone to buy milk  :)"
                    }
                ]
            },
            {
                "id": 2046449,
                "content": [
                    {
                        "username": "nigmetzianov",
                        "content": "I'm pretty sure I have the right solution which even gives a lower number for test case 119. It's not binary search per se, but I do use it inside.\n\nexpected is 78332 but I get 78326 \n\n ```\nvar minEatingSpeed = function (piles, h) {\n  piles = piles.sort((a, b) => a - b);\n  const target = Math.ceil(piles.reduce((p, n) => p + n, 0) / h);\n  let l = 0;\n  let r = piles.length - 1;\n  while (l < r) {\n    const mid = l + Math.floor((r - l + 1) / 2);\n    if (piles[mid] > target) {\n      r = mid - 1;\n    } else {\n      l = mid;\n    }\n  }\n  const availibleSpots = h - piles.length;\n  const jumpsToDo = piles.length - l;\n  if (jumpsToDo > availibleSpots) {\n    return piles[piles.length - availibleSpots - 1];\n  } else {\n    return Math.ceil(\n      piles.slice(l, piles.length).reduce((p, n) => p + n, 0) / (h - l - 1)\n    );\n  }\n};```"
                    },
                    {
                        "username": "uniqs",
                        "content": "so what will the guards do when they come back and found out that every pile of bananas have gone? Koko should eat faster to keep time to run."
                    },
                    {
                        "username": "21bcs069",
                        "content": "this question has same pattern as leetcode 1870. dito same approach."
                    },
                    {
                        "username": "jacobj2",
                        "content": "Solved this question but was wondering how we would know when to return the left or right pointer in general binary search problems?"
                    },
                    {
                        "username": "nadabao",
                        "content": "\"she chooses some pile of bananas and eats k bananas from that pile.\"\\n\\nok, so the description should clarify during one-hour period, koko will only choose one pile. The more greedy monkey can finish more bananas from other pile if current pile has < k bananas!"
                    },
                    {
                        "username": "shubham_patel",
                        "content": "I dont understand why the below test case is failing\\n\\npiles = [805306368,805306368,805306368]\\nh = 1000000000\\n\\nOutput : 1\\nExpected output : 3\\n\\n\\n\\n`private int calculateCost(int v, int[] piles) {\\n        int c = 0;\\n        for(int i=0; i<piles.length; i++) {\\n            c+= piles[i]/v + (piles[i]%v==0 ? 0 : 1);\\n        }\\n        return c;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int n = piles.length;\\n        int maxi=0;\\n        for(int i=0; i<n; i++) maxi=Math.max(maxi,piles[i]);\\n\\n        int r = maxi;\\n        int l = 1;\\n        while(l<=r) {\\n            int m = (l+r)/2;\\n            int cm = calculateCost(m, piles);\\n            if(cm > h) {\\n                l = m+1;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        return l;\\n    }`"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please let me also know when you resolve the issue. I am also stuck here. only one testcase is failed and remaining are working fine for me."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "Clearing the confusion .  At a time Koko can choose only one pile / index  from that single pile she can decide according to her capacity how much banana she can take at a time  *~*"
                    },
                    {
                        "username": "SubstantialCattle5",
                        "content": "all my homies hate koko "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I don\\'t know why but I hate this problem a lot."
                    },
                    {
                        "username": "tonynin1",
                        "content": "I think the guards have gone to buy milk  :)"
                    }
                ]
            },
            {
                "id": 2043110,
                "content": [
                    {
                        "username": "nigmetzianov",
                        "content": "I'm pretty sure I have the right solution which even gives a lower number for test case 119. It's not binary search per se, but I do use it inside.\n\nexpected is 78332 but I get 78326 \n\n ```\nvar minEatingSpeed = function (piles, h) {\n  piles = piles.sort((a, b) => a - b);\n  const target = Math.ceil(piles.reduce((p, n) => p + n, 0) / h);\n  let l = 0;\n  let r = piles.length - 1;\n  while (l < r) {\n    const mid = l + Math.floor((r - l + 1) / 2);\n    if (piles[mid] > target) {\n      r = mid - 1;\n    } else {\n      l = mid;\n    }\n  }\n  const availibleSpots = h - piles.length;\n  const jumpsToDo = piles.length - l;\n  if (jumpsToDo > availibleSpots) {\n    return piles[piles.length - availibleSpots - 1];\n  } else {\n    return Math.ceil(\n      piles.slice(l, piles.length).reduce((p, n) => p + n, 0) / (h - l - 1)\n    );\n  }\n};```"
                    },
                    {
                        "username": "uniqs",
                        "content": "so what will the guards do when they come back and found out that every pile of bananas have gone? Koko should eat faster to keep time to run."
                    },
                    {
                        "username": "21bcs069",
                        "content": "this question has same pattern as leetcode 1870. dito same approach."
                    },
                    {
                        "username": "jacobj2",
                        "content": "Solved this question but was wondering how we would know when to return the left or right pointer in general binary search problems?"
                    },
                    {
                        "username": "nadabao",
                        "content": "\"she chooses some pile of bananas and eats k bananas from that pile.\"\\n\\nok, so the description should clarify during one-hour period, koko will only choose one pile. The more greedy monkey can finish more bananas from other pile if current pile has < k bananas!"
                    },
                    {
                        "username": "shubham_patel",
                        "content": "I dont understand why the below test case is failing\\n\\npiles = [805306368,805306368,805306368]\\nh = 1000000000\\n\\nOutput : 1\\nExpected output : 3\\n\\n\\n\\n`private int calculateCost(int v, int[] piles) {\\n        int c = 0;\\n        for(int i=0; i<piles.length; i++) {\\n            c+= piles[i]/v + (piles[i]%v==0 ? 0 : 1);\\n        }\\n        return c;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int n = piles.length;\\n        int maxi=0;\\n        for(int i=0; i<n; i++) maxi=Math.max(maxi,piles[i]);\\n\\n        int r = maxi;\\n        int l = 1;\\n        while(l<=r) {\\n            int m = (l+r)/2;\\n            int cm = calculateCost(m, piles);\\n            if(cm > h) {\\n                l = m+1;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        return l;\\n    }`"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please let me also know when you resolve the issue. I am also stuck here. only one testcase is failed and remaining are working fine for me."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "Clearing the confusion .  At a time Koko can choose only one pile / index  from that single pile she can decide according to her capacity how much banana she can take at a time  *~*"
                    },
                    {
                        "username": "SubstantialCattle5",
                        "content": "all my homies hate koko "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I don\\'t know why but I hate this problem a lot."
                    },
                    {
                        "username": "tonynin1",
                        "content": "I think the guards have gone to buy milk  :)"
                    }
                ]
            },
            {
                "id": 2034963,
                "content": [
                    {
                        "username": "nigmetzianov",
                        "content": "I'm pretty sure I have the right solution which even gives a lower number for test case 119. It's not binary search per se, but I do use it inside.\n\nexpected is 78332 but I get 78326 \n\n ```\nvar minEatingSpeed = function (piles, h) {\n  piles = piles.sort((a, b) => a - b);\n  const target = Math.ceil(piles.reduce((p, n) => p + n, 0) / h);\n  let l = 0;\n  let r = piles.length - 1;\n  while (l < r) {\n    const mid = l + Math.floor((r - l + 1) / 2);\n    if (piles[mid] > target) {\n      r = mid - 1;\n    } else {\n      l = mid;\n    }\n  }\n  const availibleSpots = h - piles.length;\n  const jumpsToDo = piles.length - l;\n  if (jumpsToDo > availibleSpots) {\n    return piles[piles.length - availibleSpots - 1];\n  } else {\n    return Math.ceil(\n      piles.slice(l, piles.length).reduce((p, n) => p + n, 0) / (h - l - 1)\n    );\n  }\n};```"
                    },
                    {
                        "username": "uniqs",
                        "content": "so what will the guards do when they come back and found out that every pile of bananas have gone? Koko should eat faster to keep time to run."
                    },
                    {
                        "username": "21bcs069",
                        "content": "this question has same pattern as leetcode 1870. dito same approach."
                    },
                    {
                        "username": "jacobj2",
                        "content": "Solved this question but was wondering how we would know when to return the left or right pointer in general binary search problems?"
                    },
                    {
                        "username": "nadabao",
                        "content": "\"she chooses some pile of bananas and eats k bananas from that pile.\"\\n\\nok, so the description should clarify during one-hour period, koko will only choose one pile. The more greedy monkey can finish more bananas from other pile if current pile has < k bananas!"
                    },
                    {
                        "username": "shubham_patel",
                        "content": "I dont understand why the below test case is failing\\n\\npiles = [805306368,805306368,805306368]\\nh = 1000000000\\n\\nOutput : 1\\nExpected output : 3\\n\\n\\n\\n`private int calculateCost(int v, int[] piles) {\\n        int c = 0;\\n        for(int i=0; i<piles.length; i++) {\\n            c+= piles[i]/v + (piles[i]%v==0 ? 0 : 1);\\n        }\\n        return c;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int n = piles.length;\\n        int maxi=0;\\n        for(int i=0; i<n; i++) maxi=Math.max(maxi,piles[i]);\\n\\n        int r = maxi;\\n        int l = 1;\\n        while(l<=r) {\\n            int m = (l+r)/2;\\n            int cm = calculateCost(m, piles);\\n            if(cm > h) {\\n                l = m+1;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        return l;\\n    }`"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please let me also know when you resolve the issue. I am also stuck here. only one testcase is failed and remaining are working fine for me."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "Clearing the confusion .  At a time Koko can choose only one pile / index  from that single pile she can decide according to her capacity how much banana she can take at a time  *~*"
                    },
                    {
                        "username": "SubstantialCattle5",
                        "content": "all my homies hate koko "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I don\\'t know why but I hate this problem a lot."
                    },
                    {
                        "username": "tonynin1",
                        "content": "I think the guards have gone to buy milk  :)"
                    }
                ]
            },
            {
                "id": 2034052,
                "content": [
                    {
                        "username": "nigmetzianov",
                        "content": "I'm pretty sure I have the right solution which even gives a lower number for test case 119. It's not binary search per se, but I do use it inside.\n\nexpected is 78332 but I get 78326 \n\n ```\nvar minEatingSpeed = function (piles, h) {\n  piles = piles.sort((a, b) => a - b);\n  const target = Math.ceil(piles.reduce((p, n) => p + n, 0) / h);\n  let l = 0;\n  let r = piles.length - 1;\n  while (l < r) {\n    const mid = l + Math.floor((r - l + 1) / 2);\n    if (piles[mid] > target) {\n      r = mid - 1;\n    } else {\n      l = mid;\n    }\n  }\n  const availibleSpots = h - piles.length;\n  const jumpsToDo = piles.length - l;\n  if (jumpsToDo > availibleSpots) {\n    return piles[piles.length - availibleSpots - 1];\n  } else {\n    return Math.ceil(\n      piles.slice(l, piles.length).reduce((p, n) => p + n, 0) / (h - l - 1)\n    );\n  }\n};```"
                    },
                    {
                        "username": "uniqs",
                        "content": "so what will the guards do when they come back and found out that every pile of bananas have gone? Koko should eat faster to keep time to run."
                    },
                    {
                        "username": "21bcs069",
                        "content": "this question has same pattern as leetcode 1870. dito same approach."
                    },
                    {
                        "username": "jacobj2",
                        "content": "Solved this question but was wondering how we would know when to return the left or right pointer in general binary search problems?"
                    },
                    {
                        "username": "nadabao",
                        "content": "\"she chooses some pile of bananas and eats k bananas from that pile.\"\\n\\nok, so the description should clarify during one-hour period, koko will only choose one pile. The more greedy monkey can finish more bananas from other pile if current pile has < k bananas!"
                    },
                    {
                        "username": "shubham_patel",
                        "content": "I dont understand why the below test case is failing\\n\\npiles = [805306368,805306368,805306368]\\nh = 1000000000\\n\\nOutput : 1\\nExpected output : 3\\n\\n\\n\\n`private int calculateCost(int v, int[] piles) {\\n        int c = 0;\\n        for(int i=0; i<piles.length; i++) {\\n            c+= piles[i]/v + (piles[i]%v==0 ? 0 : 1);\\n        }\\n        return c;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int n = piles.length;\\n        int maxi=0;\\n        for(int i=0; i<n; i++) maxi=Math.max(maxi,piles[i]);\\n\\n        int r = maxi;\\n        int l = 1;\\n        while(l<=r) {\\n            int m = (l+r)/2;\\n            int cm = calculateCost(m, piles);\\n            if(cm > h) {\\n                l = m+1;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        return l;\\n    }`"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please let me also know when you resolve the issue. I am also stuck here. only one testcase is failed and remaining are working fine for me."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "Clearing the confusion .  At a time Koko can choose only one pile / index  from that single pile she can decide according to her capacity how much banana she can take at a time  *~*"
                    },
                    {
                        "username": "SubstantialCattle5",
                        "content": "all my homies hate koko "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I don\\'t know why but I hate this problem a lot."
                    },
                    {
                        "username": "tonynin1",
                        "content": "I think the guards have gone to buy milk  :)"
                    }
                ]
            },
            {
                "id": 2029398,
                "content": [
                    {
                        "username": "suenolivia",
                        "content": "```        \\n        l, r = 1, max(piles)\\n\\n        curMinSpeed = max(piles)\\n\\n        def timeTakenToFinish(speed):\\n            time = 0\\n            for pile in piles:\\n                time += ceil(pile/speed)\\n            return time\\n\\n        while l <= r:\\n            mid = (l+r)//2\\n\\n            # check how many hours to finish\\n            time = timeTakenToFinish(mid)\\n\\n            # if time == h:\\n            #     return mid\\n            if time > h:\\n                # taking too long\\n                l = mid + 1\\n            else:\\n                # can afford more time\\n                curMinSpeed = min(curMinSpeed, mid)\\n                r = mid - 1\\n        \\n        return curMinSpeed\\n```\\n\\nIf I uncomment `if time==h: return  mid`,\\nthe final test case fails: piles [1,1,1,999999999] , h=10.\\n\\nBut I am wondering why, can\\'t I just return the speed when time==h, isnt it already theoretically the slowest speed since we maximise the time when time==h?"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "interviewer : u wrote good code but it breaks at piles =\\n[312884470]\\nh =\\n312884469 so u failed \\n\\nbruh who tf made this test case \\n \\n\\nAnyways heres binary+linear search code which misses just by a few testcases since underflow \\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n = piles.size();\\n        if(n==1){\\n            return ceil((float)((double)piles[0]/(double)h));\\n        }\\n        // given n<h \\n        int k ;\\n        int low=1, high=*max_element(piles.begin(),piles.end()) ;\\n        if(n==h){\\n            return high;\\n        }\\n        while(low<=high){\\n            k = low + (high-low)/2 ;\\n            // cout<<k<<\" \";\\n            int time = 0 ;\\n            for(int i=0; i<n; i++){\\n                time += (1+(piles[i]/k));\\n            }\\n            if(time<h){\\n                high = k-1;\\n            }\\n            if(time>h){\\n                low = k+1;\\n            }\\n            if(time==h){\\n                break;\\n                return k;\\n            }\\n        }\\n        for(int i=k; i>0; i--){\\n            // cout<<endl<<i<<\" \";\\n            int time = 0 ;\\n            for(int j=0; j<n; j++){\\n                if(piles[j]==i){\\n                    time+=piles[j]/i ;\\n                }\\n                else{\\n                    time += (1+(piles[j]/i));\\n                }\\n                \\n            }\\n            // cout<<time<<endl;\\n            if(time>h){\\n                return i+1;\\n            }\\n        }\\n        return 1 ;\\n    }\\n};"
                    },
                    {
                        "username": "raja-2502",
                        "content": "can anyone explain what will happen when the pile has more than the required bananas......"
                    },
                    {
                        "username": "Malav_1712",
                        "content": "Why cannot we use average for this questions sum of array /h?"
                    },
                    {
                        "username": "leitor79",
                        "content": "I don\\'t understand one case. There are 18 piles, but the expected answer is 14.  How the expected answer could be less than the number of piles if each pile takes at least 1 hour?\\n\\npiles =\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\nh =\\n823855818\\n\\nUse Testcase\\nOutput\\n18\\nExpected\\n14\\n"
                    },
                    {
                        "username": "pixelbubble",
                        "content": "how is this a binary search question *cries"
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko can eat 80553579 bananas in 1 hour but takes 2 hours to eat 2 piles of 1 banana each..."
                    },
                    {
                        "username": "jess_35",
                        "content": "Its not clearly said in the question but KOKO can at max eat a pile an hour not more than that so rather than eating 88 bananas(i.e. total sum of piles array) in example 1 she can only eat at max 11 bananas (i.e. max of that array) "
                    },
                    {
                        "username": "aman1320",
                        "content": "NO ONE WROTE : its is similar to \"Aggressive Cow\" !!"
                    },
                    {
                        "username": "arpit900",
                        "content": "for input [30,11,23,4,20]\\noutput could be 23 and 24 both, but why leetcode is considering 24 to be correct."
                    }
                ]
            },
            {
                "id": 2019068,
                "content": [
                    {
                        "username": "suenolivia",
                        "content": "```        \\n        l, r = 1, max(piles)\\n\\n        curMinSpeed = max(piles)\\n\\n        def timeTakenToFinish(speed):\\n            time = 0\\n            for pile in piles:\\n                time += ceil(pile/speed)\\n            return time\\n\\n        while l <= r:\\n            mid = (l+r)//2\\n\\n            # check how many hours to finish\\n            time = timeTakenToFinish(mid)\\n\\n            # if time == h:\\n            #     return mid\\n            if time > h:\\n                # taking too long\\n                l = mid + 1\\n            else:\\n                # can afford more time\\n                curMinSpeed = min(curMinSpeed, mid)\\n                r = mid - 1\\n        \\n        return curMinSpeed\\n```\\n\\nIf I uncomment `if time==h: return  mid`,\\nthe final test case fails: piles [1,1,1,999999999] , h=10.\\n\\nBut I am wondering why, can\\'t I just return the speed when time==h, isnt it already theoretically the slowest speed since we maximise the time when time==h?"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "interviewer : u wrote good code but it breaks at piles =\\n[312884470]\\nh =\\n312884469 so u failed \\n\\nbruh who tf made this test case \\n \\n\\nAnyways heres binary+linear search code which misses just by a few testcases since underflow \\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n = piles.size();\\n        if(n==1){\\n            return ceil((float)((double)piles[0]/(double)h));\\n        }\\n        // given n<h \\n        int k ;\\n        int low=1, high=*max_element(piles.begin(),piles.end()) ;\\n        if(n==h){\\n            return high;\\n        }\\n        while(low<=high){\\n            k = low + (high-low)/2 ;\\n            // cout<<k<<\" \";\\n            int time = 0 ;\\n            for(int i=0; i<n; i++){\\n                time += (1+(piles[i]/k));\\n            }\\n            if(time<h){\\n                high = k-1;\\n            }\\n            if(time>h){\\n                low = k+1;\\n            }\\n            if(time==h){\\n                break;\\n                return k;\\n            }\\n        }\\n        for(int i=k; i>0; i--){\\n            // cout<<endl<<i<<\" \";\\n            int time = 0 ;\\n            for(int j=0; j<n; j++){\\n                if(piles[j]==i){\\n                    time+=piles[j]/i ;\\n                }\\n                else{\\n                    time += (1+(piles[j]/i));\\n                }\\n                \\n            }\\n            // cout<<time<<endl;\\n            if(time>h){\\n                return i+1;\\n            }\\n        }\\n        return 1 ;\\n    }\\n};"
                    },
                    {
                        "username": "raja-2502",
                        "content": "can anyone explain what will happen when the pile has more than the required bananas......"
                    },
                    {
                        "username": "Malav_1712",
                        "content": "Why cannot we use average for this questions sum of array /h?"
                    },
                    {
                        "username": "leitor79",
                        "content": "I don\\'t understand one case. There are 18 piles, but the expected answer is 14.  How the expected answer could be less than the number of piles if each pile takes at least 1 hour?\\n\\npiles =\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\nh =\\n823855818\\n\\nUse Testcase\\nOutput\\n18\\nExpected\\n14\\n"
                    },
                    {
                        "username": "pixelbubble",
                        "content": "how is this a binary search question *cries"
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko can eat 80553579 bananas in 1 hour but takes 2 hours to eat 2 piles of 1 banana each..."
                    },
                    {
                        "username": "jess_35",
                        "content": "Its not clearly said in the question but KOKO can at max eat a pile an hour not more than that so rather than eating 88 bananas(i.e. total sum of piles array) in example 1 she can only eat at max 11 bananas (i.e. max of that array) "
                    },
                    {
                        "username": "aman1320",
                        "content": "NO ONE WROTE : its is similar to \"Aggressive Cow\" !!"
                    },
                    {
                        "username": "arpit900",
                        "content": "for input [30,11,23,4,20]\\noutput could be 23 and 24 both, but why leetcode is considering 24 to be correct."
                    }
                ]
            },
            {
                "id": 2008126,
                "content": [
                    {
                        "username": "suenolivia",
                        "content": "```        \\n        l, r = 1, max(piles)\\n\\n        curMinSpeed = max(piles)\\n\\n        def timeTakenToFinish(speed):\\n            time = 0\\n            for pile in piles:\\n                time += ceil(pile/speed)\\n            return time\\n\\n        while l <= r:\\n            mid = (l+r)//2\\n\\n            # check how many hours to finish\\n            time = timeTakenToFinish(mid)\\n\\n            # if time == h:\\n            #     return mid\\n            if time > h:\\n                # taking too long\\n                l = mid + 1\\n            else:\\n                # can afford more time\\n                curMinSpeed = min(curMinSpeed, mid)\\n                r = mid - 1\\n        \\n        return curMinSpeed\\n```\\n\\nIf I uncomment `if time==h: return  mid`,\\nthe final test case fails: piles [1,1,1,999999999] , h=10.\\n\\nBut I am wondering why, can\\'t I just return the speed when time==h, isnt it already theoretically the slowest speed since we maximise the time when time==h?"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "interviewer : u wrote good code but it breaks at piles =\\n[312884470]\\nh =\\n312884469 so u failed \\n\\nbruh who tf made this test case \\n \\n\\nAnyways heres binary+linear search code which misses just by a few testcases since underflow \\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n = piles.size();\\n        if(n==1){\\n            return ceil((float)((double)piles[0]/(double)h));\\n        }\\n        // given n<h \\n        int k ;\\n        int low=1, high=*max_element(piles.begin(),piles.end()) ;\\n        if(n==h){\\n            return high;\\n        }\\n        while(low<=high){\\n            k = low + (high-low)/2 ;\\n            // cout<<k<<\" \";\\n            int time = 0 ;\\n            for(int i=0; i<n; i++){\\n                time += (1+(piles[i]/k));\\n            }\\n            if(time<h){\\n                high = k-1;\\n            }\\n            if(time>h){\\n                low = k+1;\\n            }\\n            if(time==h){\\n                break;\\n                return k;\\n            }\\n        }\\n        for(int i=k; i>0; i--){\\n            // cout<<endl<<i<<\" \";\\n            int time = 0 ;\\n            for(int j=0; j<n; j++){\\n                if(piles[j]==i){\\n                    time+=piles[j]/i ;\\n                }\\n                else{\\n                    time += (1+(piles[j]/i));\\n                }\\n                \\n            }\\n            // cout<<time<<endl;\\n            if(time>h){\\n                return i+1;\\n            }\\n        }\\n        return 1 ;\\n    }\\n};"
                    },
                    {
                        "username": "raja-2502",
                        "content": "can anyone explain what will happen when the pile has more than the required bananas......"
                    },
                    {
                        "username": "Malav_1712",
                        "content": "Why cannot we use average for this questions sum of array /h?"
                    },
                    {
                        "username": "leitor79",
                        "content": "I don\\'t understand one case. There are 18 piles, but the expected answer is 14.  How the expected answer could be less than the number of piles if each pile takes at least 1 hour?\\n\\npiles =\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\nh =\\n823855818\\n\\nUse Testcase\\nOutput\\n18\\nExpected\\n14\\n"
                    },
                    {
                        "username": "pixelbubble",
                        "content": "how is this a binary search question *cries"
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko can eat 80553579 bananas in 1 hour but takes 2 hours to eat 2 piles of 1 banana each..."
                    },
                    {
                        "username": "jess_35",
                        "content": "Its not clearly said in the question but KOKO can at max eat a pile an hour not more than that so rather than eating 88 bananas(i.e. total sum of piles array) in example 1 she can only eat at max 11 bananas (i.e. max of that array) "
                    },
                    {
                        "username": "aman1320",
                        "content": "NO ONE WROTE : its is similar to \"Aggressive Cow\" !!"
                    },
                    {
                        "username": "arpit900",
                        "content": "for input [30,11,23,4,20]\\noutput could be 23 and 24 both, but why leetcode is considering 24 to be correct."
                    }
                ]
            },
            {
                "id": 2006379,
                "content": [
                    {
                        "username": "suenolivia",
                        "content": "```        \\n        l, r = 1, max(piles)\\n\\n        curMinSpeed = max(piles)\\n\\n        def timeTakenToFinish(speed):\\n            time = 0\\n            for pile in piles:\\n                time += ceil(pile/speed)\\n            return time\\n\\n        while l <= r:\\n            mid = (l+r)//2\\n\\n            # check how many hours to finish\\n            time = timeTakenToFinish(mid)\\n\\n            # if time == h:\\n            #     return mid\\n            if time > h:\\n                # taking too long\\n                l = mid + 1\\n            else:\\n                # can afford more time\\n                curMinSpeed = min(curMinSpeed, mid)\\n                r = mid - 1\\n        \\n        return curMinSpeed\\n```\\n\\nIf I uncomment `if time==h: return  mid`,\\nthe final test case fails: piles [1,1,1,999999999] , h=10.\\n\\nBut I am wondering why, can\\'t I just return the speed when time==h, isnt it already theoretically the slowest speed since we maximise the time when time==h?"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "interviewer : u wrote good code but it breaks at piles =\\n[312884470]\\nh =\\n312884469 so u failed \\n\\nbruh who tf made this test case \\n \\n\\nAnyways heres binary+linear search code which misses just by a few testcases since underflow \\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n = piles.size();\\n        if(n==1){\\n            return ceil((float)((double)piles[0]/(double)h));\\n        }\\n        // given n<h \\n        int k ;\\n        int low=1, high=*max_element(piles.begin(),piles.end()) ;\\n        if(n==h){\\n            return high;\\n        }\\n        while(low<=high){\\n            k = low + (high-low)/2 ;\\n            // cout<<k<<\" \";\\n            int time = 0 ;\\n            for(int i=0; i<n; i++){\\n                time += (1+(piles[i]/k));\\n            }\\n            if(time<h){\\n                high = k-1;\\n            }\\n            if(time>h){\\n                low = k+1;\\n            }\\n            if(time==h){\\n                break;\\n                return k;\\n            }\\n        }\\n        for(int i=k; i>0; i--){\\n            // cout<<endl<<i<<\" \";\\n            int time = 0 ;\\n            for(int j=0; j<n; j++){\\n                if(piles[j]==i){\\n                    time+=piles[j]/i ;\\n                }\\n                else{\\n                    time += (1+(piles[j]/i));\\n                }\\n                \\n            }\\n            // cout<<time<<endl;\\n            if(time>h){\\n                return i+1;\\n            }\\n        }\\n        return 1 ;\\n    }\\n};"
                    },
                    {
                        "username": "raja-2502",
                        "content": "can anyone explain what will happen when the pile has more than the required bananas......"
                    },
                    {
                        "username": "Malav_1712",
                        "content": "Why cannot we use average for this questions sum of array /h?"
                    },
                    {
                        "username": "leitor79",
                        "content": "I don\\'t understand one case. There are 18 piles, but the expected answer is 14.  How the expected answer could be less than the number of piles if each pile takes at least 1 hour?\\n\\npiles =\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\nh =\\n823855818\\n\\nUse Testcase\\nOutput\\n18\\nExpected\\n14\\n"
                    },
                    {
                        "username": "pixelbubble",
                        "content": "how is this a binary search question *cries"
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko can eat 80553579 bananas in 1 hour but takes 2 hours to eat 2 piles of 1 banana each..."
                    },
                    {
                        "username": "jess_35",
                        "content": "Its not clearly said in the question but KOKO can at max eat a pile an hour not more than that so rather than eating 88 bananas(i.e. total sum of piles array) in example 1 she can only eat at max 11 bananas (i.e. max of that array) "
                    },
                    {
                        "username": "aman1320",
                        "content": "NO ONE WROTE : its is similar to \"Aggressive Cow\" !!"
                    },
                    {
                        "username": "arpit900",
                        "content": "for input [30,11,23,4,20]\\noutput could be 23 and 24 both, but why leetcode is considering 24 to be correct."
                    }
                ]
            },
            {
                "id": 2003659,
                "content": [
                    {
                        "username": "suenolivia",
                        "content": "```        \\n        l, r = 1, max(piles)\\n\\n        curMinSpeed = max(piles)\\n\\n        def timeTakenToFinish(speed):\\n            time = 0\\n            for pile in piles:\\n                time += ceil(pile/speed)\\n            return time\\n\\n        while l <= r:\\n            mid = (l+r)//2\\n\\n            # check how many hours to finish\\n            time = timeTakenToFinish(mid)\\n\\n            # if time == h:\\n            #     return mid\\n            if time > h:\\n                # taking too long\\n                l = mid + 1\\n            else:\\n                # can afford more time\\n                curMinSpeed = min(curMinSpeed, mid)\\n                r = mid - 1\\n        \\n        return curMinSpeed\\n```\\n\\nIf I uncomment `if time==h: return  mid`,\\nthe final test case fails: piles [1,1,1,999999999] , h=10.\\n\\nBut I am wondering why, can\\'t I just return the speed when time==h, isnt it already theoretically the slowest speed since we maximise the time when time==h?"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "interviewer : u wrote good code but it breaks at piles =\\n[312884470]\\nh =\\n312884469 so u failed \\n\\nbruh who tf made this test case \\n \\n\\nAnyways heres binary+linear search code which misses just by a few testcases since underflow \\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n = piles.size();\\n        if(n==1){\\n            return ceil((float)((double)piles[0]/(double)h));\\n        }\\n        // given n<h \\n        int k ;\\n        int low=1, high=*max_element(piles.begin(),piles.end()) ;\\n        if(n==h){\\n            return high;\\n        }\\n        while(low<=high){\\n            k = low + (high-low)/2 ;\\n            // cout<<k<<\" \";\\n            int time = 0 ;\\n            for(int i=0; i<n; i++){\\n                time += (1+(piles[i]/k));\\n            }\\n            if(time<h){\\n                high = k-1;\\n            }\\n            if(time>h){\\n                low = k+1;\\n            }\\n            if(time==h){\\n                break;\\n                return k;\\n            }\\n        }\\n        for(int i=k; i>0; i--){\\n            // cout<<endl<<i<<\" \";\\n            int time = 0 ;\\n            for(int j=0; j<n; j++){\\n                if(piles[j]==i){\\n                    time+=piles[j]/i ;\\n                }\\n                else{\\n                    time += (1+(piles[j]/i));\\n                }\\n                \\n            }\\n            // cout<<time<<endl;\\n            if(time>h){\\n                return i+1;\\n            }\\n        }\\n        return 1 ;\\n    }\\n};"
                    },
                    {
                        "username": "raja-2502",
                        "content": "can anyone explain what will happen when the pile has more than the required bananas......"
                    },
                    {
                        "username": "Malav_1712",
                        "content": "Why cannot we use average for this questions sum of array /h?"
                    },
                    {
                        "username": "leitor79",
                        "content": "I don\\'t understand one case. There are 18 piles, but the expected answer is 14.  How the expected answer could be less than the number of piles if each pile takes at least 1 hour?\\n\\npiles =\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\nh =\\n823855818\\n\\nUse Testcase\\nOutput\\n18\\nExpected\\n14\\n"
                    },
                    {
                        "username": "pixelbubble",
                        "content": "how is this a binary search question *cries"
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko can eat 80553579 bananas in 1 hour but takes 2 hours to eat 2 piles of 1 banana each..."
                    },
                    {
                        "username": "jess_35",
                        "content": "Its not clearly said in the question but KOKO can at max eat a pile an hour not more than that so rather than eating 88 bananas(i.e. total sum of piles array) in example 1 she can only eat at max 11 bananas (i.e. max of that array) "
                    },
                    {
                        "username": "aman1320",
                        "content": "NO ONE WROTE : its is similar to \"Aggressive Cow\" !!"
                    },
                    {
                        "username": "arpit900",
                        "content": "for input [30,11,23,4,20]\\noutput could be 23 and 24 both, but why leetcode is considering 24 to be correct."
                    }
                ]
            },
            {
                "id": 1994994,
                "content": [
                    {
                        "username": "suenolivia",
                        "content": "```        \\n        l, r = 1, max(piles)\\n\\n        curMinSpeed = max(piles)\\n\\n        def timeTakenToFinish(speed):\\n            time = 0\\n            for pile in piles:\\n                time += ceil(pile/speed)\\n            return time\\n\\n        while l <= r:\\n            mid = (l+r)//2\\n\\n            # check how many hours to finish\\n            time = timeTakenToFinish(mid)\\n\\n            # if time == h:\\n            #     return mid\\n            if time > h:\\n                # taking too long\\n                l = mid + 1\\n            else:\\n                # can afford more time\\n                curMinSpeed = min(curMinSpeed, mid)\\n                r = mid - 1\\n        \\n        return curMinSpeed\\n```\\n\\nIf I uncomment `if time==h: return  mid`,\\nthe final test case fails: piles [1,1,1,999999999] , h=10.\\n\\nBut I am wondering why, can\\'t I just return the speed when time==h, isnt it already theoretically the slowest speed since we maximise the time when time==h?"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "interviewer : u wrote good code but it breaks at piles =\\n[312884470]\\nh =\\n312884469 so u failed \\n\\nbruh who tf made this test case \\n \\n\\nAnyways heres binary+linear search code which misses just by a few testcases since underflow \\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n = piles.size();\\n        if(n==1){\\n            return ceil((float)((double)piles[0]/(double)h));\\n        }\\n        // given n<h \\n        int k ;\\n        int low=1, high=*max_element(piles.begin(),piles.end()) ;\\n        if(n==h){\\n            return high;\\n        }\\n        while(low<=high){\\n            k = low + (high-low)/2 ;\\n            // cout<<k<<\" \";\\n            int time = 0 ;\\n            for(int i=0; i<n; i++){\\n                time += (1+(piles[i]/k));\\n            }\\n            if(time<h){\\n                high = k-1;\\n            }\\n            if(time>h){\\n                low = k+1;\\n            }\\n            if(time==h){\\n                break;\\n                return k;\\n            }\\n        }\\n        for(int i=k; i>0; i--){\\n            // cout<<endl<<i<<\" \";\\n            int time = 0 ;\\n            for(int j=0; j<n; j++){\\n                if(piles[j]==i){\\n                    time+=piles[j]/i ;\\n                }\\n                else{\\n                    time += (1+(piles[j]/i));\\n                }\\n                \\n            }\\n            // cout<<time<<endl;\\n            if(time>h){\\n                return i+1;\\n            }\\n        }\\n        return 1 ;\\n    }\\n};"
                    },
                    {
                        "username": "raja-2502",
                        "content": "can anyone explain what will happen when the pile has more than the required bananas......"
                    },
                    {
                        "username": "Malav_1712",
                        "content": "Why cannot we use average for this questions sum of array /h?"
                    },
                    {
                        "username": "leitor79",
                        "content": "I don\\'t understand one case. There are 18 piles, but the expected answer is 14.  How the expected answer could be less than the number of piles if each pile takes at least 1 hour?\\n\\npiles =\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\nh =\\n823855818\\n\\nUse Testcase\\nOutput\\n18\\nExpected\\n14\\n"
                    },
                    {
                        "username": "pixelbubble",
                        "content": "how is this a binary search question *cries"
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko can eat 80553579 bananas in 1 hour but takes 2 hours to eat 2 piles of 1 banana each..."
                    },
                    {
                        "username": "jess_35",
                        "content": "Its not clearly said in the question but KOKO can at max eat a pile an hour not more than that so rather than eating 88 bananas(i.e. total sum of piles array) in example 1 she can only eat at max 11 bananas (i.e. max of that array) "
                    },
                    {
                        "username": "aman1320",
                        "content": "NO ONE WROTE : its is similar to \"Aggressive Cow\" !!"
                    },
                    {
                        "username": "arpit900",
                        "content": "for input [30,11,23,4,20]\\noutput could be 23 and 24 both, but why leetcode is considering 24 to be correct."
                    }
                ]
            },
            {
                "id": 1970870,
                "content": [
                    {
                        "username": "suenolivia",
                        "content": "```        \\n        l, r = 1, max(piles)\\n\\n        curMinSpeed = max(piles)\\n\\n        def timeTakenToFinish(speed):\\n            time = 0\\n            for pile in piles:\\n                time += ceil(pile/speed)\\n            return time\\n\\n        while l <= r:\\n            mid = (l+r)//2\\n\\n            # check how many hours to finish\\n            time = timeTakenToFinish(mid)\\n\\n            # if time == h:\\n            #     return mid\\n            if time > h:\\n                # taking too long\\n                l = mid + 1\\n            else:\\n                # can afford more time\\n                curMinSpeed = min(curMinSpeed, mid)\\n                r = mid - 1\\n        \\n        return curMinSpeed\\n```\\n\\nIf I uncomment `if time==h: return  mid`,\\nthe final test case fails: piles [1,1,1,999999999] , h=10.\\n\\nBut I am wondering why, can\\'t I just return the speed when time==h, isnt it already theoretically the slowest speed since we maximise the time when time==h?"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "interviewer : u wrote good code but it breaks at piles =\\n[312884470]\\nh =\\n312884469 so u failed \\n\\nbruh who tf made this test case \\n \\n\\nAnyways heres binary+linear search code which misses just by a few testcases since underflow \\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n = piles.size();\\n        if(n==1){\\n            return ceil((float)((double)piles[0]/(double)h));\\n        }\\n        // given n<h \\n        int k ;\\n        int low=1, high=*max_element(piles.begin(),piles.end()) ;\\n        if(n==h){\\n            return high;\\n        }\\n        while(low<=high){\\n            k = low + (high-low)/2 ;\\n            // cout<<k<<\" \";\\n            int time = 0 ;\\n            for(int i=0; i<n; i++){\\n                time += (1+(piles[i]/k));\\n            }\\n            if(time<h){\\n                high = k-1;\\n            }\\n            if(time>h){\\n                low = k+1;\\n            }\\n            if(time==h){\\n                break;\\n                return k;\\n            }\\n        }\\n        for(int i=k; i>0; i--){\\n            // cout<<endl<<i<<\" \";\\n            int time = 0 ;\\n            for(int j=0; j<n; j++){\\n                if(piles[j]==i){\\n                    time+=piles[j]/i ;\\n                }\\n                else{\\n                    time += (1+(piles[j]/i));\\n                }\\n                \\n            }\\n            // cout<<time<<endl;\\n            if(time>h){\\n                return i+1;\\n            }\\n        }\\n        return 1 ;\\n    }\\n};"
                    },
                    {
                        "username": "raja-2502",
                        "content": "can anyone explain what will happen when the pile has more than the required bananas......"
                    },
                    {
                        "username": "Malav_1712",
                        "content": "Why cannot we use average for this questions sum of array /h?"
                    },
                    {
                        "username": "leitor79",
                        "content": "I don\\'t understand one case. There are 18 piles, but the expected answer is 14.  How the expected answer could be less than the number of piles if each pile takes at least 1 hour?\\n\\npiles =\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\nh =\\n823855818\\n\\nUse Testcase\\nOutput\\n18\\nExpected\\n14\\n"
                    },
                    {
                        "username": "pixelbubble",
                        "content": "how is this a binary search question *cries"
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko can eat 80553579 bananas in 1 hour but takes 2 hours to eat 2 piles of 1 banana each..."
                    },
                    {
                        "username": "jess_35",
                        "content": "Its not clearly said in the question but KOKO can at max eat a pile an hour not more than that so rather than eating 88 bananas(i.e. total sum of piles array) in example 1 she can only eat at max 11 bananas (i.e. max of that array) "
                    },
                    {
                        "username": "aman1320",
                        "content": "NO ONE WROTE : its is similar to \"Aggressive Cow\" !!"
                    },
                    {
                        "username": "arpit900",
                        "content": "for input [30,11,23,4,20]\\noutput could be 23 and 24 both, but why leetcode is considering 24 to be correct."
                    }
                ]
            },
            {
                "id": 1970867,
                "content": [
                    {
                        "username": "suenolivia",
                        "content": "```        \\n        l, r = 1, max(piles)\\n\\n        curMinSpeed = max(piles)\\n\\n        def timeTakenToFinish(speed):\\n            time = 0\\n            for pile in piles:\\n                time += ceil(pile/speed)\\n            return time\\n\\n        while l <= r:\\n            mid = (l+r)//2\\n\\n            # check how many hours to finish\\n            time = timeTakenToFinish(mid)\\n\\n            # if time == h:\\n            #     return mid\\n            if time > h:\\n                # taking too long\\n                l = mid + 1\\n            else:\\n                # can afford more time\\n                curMinSpeed = min(curMinSpeed, mid)\\n                r = mid - 1\\n        \\n        return curMinSpeed\\n```\\n\\nIf I uncomment `if time==h: return  mid`,\\nthe final test case fails: piles [1,1,1,999999999] , h=10.\\n\\nBut I am wondering why, can\\'t I just return the speed when time==h, isnt it already theoretically the slowest speed since we maximise the time when time==h?"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "interviewer : u wrote good code but it breaks at piles =\\n[312884470]\\nh =\\n312884469 so u failed \\n\\nbruh who tf made this test case \\n \\n\\nAnyways heres binary+linear search code which misses just by a few testcases since underflow \\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n = piles.size();\\n        if(n==1){\\n            return ceil((float)((double)piles[0]/(double)h));\\n        }\\n        // given n<h \\n        int k ;\\n        int low=1, high=*max_element(piles.begin(),piles.end()) ;\\n        if(n==h){\\n            return high;\\n        }\\n        while(low<=high){\\n            k = low + (high-low)/2 ;\\n            // cout<<k<<\" \";\\n            int time = 0 ;\\n            for(int i=0; i<n; i++){\\n                time += (1+(piles[i]/k));\\n            }\\n            if(time<h){\\n                high = k-1;\\n            }\\n            if(time>h){\\n                low = k+1;\\n            }\\n            if(time==h){\\n                break;\\n                return k;\\n            }\\n        }\\n        for(int i=k; i>0; i--){\\n            // cout<<endl<<i<<\" \";\\n            int time = 0 ;\\n            for(int j=0; j<n; j++){\\n                if(piles[j]==i){\\n                    time+=piles[j]/i ;\\n                }\\n                else{\\n                    time += (1+(piles[j]/i));\\n                }\\n                \\n            }\\n            // cout<<time<<endl;\\n            if(time>h){\\n                return i+1;\\n            }\\n        }\\n        return 1 ;\\n    }\\n};"
                    },
                    {
                        "username": "raja-2502",
                        "content": "can anyone explain what will happen when the pile has more than the required bananas......"
                    },
                    {
                        "username": "Malav_1712",
                        "content": "Why cannot we use average for this questions sum of array /h?"
                    },
                    {
                        "username": "leitor79",
                        "content": "I don\\'t understand one case. There are 18 piles, but the expected answer is 14.  How the expected answer could be less than the number of piles if each pile takes at least 1 hour?\\n\\npiles =\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\nh =\\n823855818\\n\\nUse Testcase\\nOutput\\n18\\nExpected\\n14\\n"
                    },
                    {
                        "username": "pixelbubble",
                        "content": "how is this a binary search question *cries"
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko can eat 80553579 bananas in 1 hour but takes 2 hours to eat 2 piles of 1 banana each..."
                    },
                    {
                        "username": "jess_35",
                        "content": "Its not clearly said in the question but KOKO can at max eat a pile an hour not more than that so rather than eating 88 bananas(i.e. total sum of piles array) in example 1 she can only eat at max 11 bananas (i.e. max of that array) "
                    },
                    {
                        "username": "aman1320",
                        "content": "NO ONE WROTE : its is similar to \"Aggressive Cow\" !!"
                    },
                    {
                        "username": "arpit900",
                        "content": "for input [30,11,23,4,20]\\noutput could be 23 and 24 both, but why leetcode is considering 24 to be correct."
                    }
                ]
            },
            {
                "id": 1969279,
                "content": [
                    {
                        "username": "suenolivia",
                        "content": "```        \\n        l, r = 1, max(piles)\\n\\n        curMinSpeed = max(piles)\\n\\n        def timeTakenToFinish(speed):\\n            time = 0\\n            for pile in piles:\\n                time += ceil(pile/speed)\\n            return time\\n\\n        while l <= r:\\n            mid = (l+r)//2\\n\\n            # check how many hours to finish\\n            time = timeTakenToFinish(mid)\\n\\n            # if time == h:\\n            #     return mid\\n            if time > h:\\n                # taking too long\\n                l = mid + 1\\n            else:\\n                # can afford more time\\n                curMinSpeed = min(curMinSpeed, mid)\\n                r = mid - 1\\n        \\n        return curMinSpeed\\n```\\n\\nIf I uncomment `if time==h: return  mid`,\\nthe final test case fails: piles [1,1,1,999999999] , h=10.\\n\\nBut I am wondering why, can\\'t I just return the speed when time==h, isnt it already theoretically the slowest speed since we maximise the time when time==h?"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "interviewer : u wrote good code but it breaks at piles =\\n[312884470]\\nh =\\n312884469 so u failed \\n\\nbruh who tf made this test case \\n \\n\\nAnyways heres binary+linear search code which misses just by a few testcases since underflow \\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n = piles.size();\\n        if(n==1){\\n            return ceil((float)((double)piles[0]/(double)h));\\n        }\\n        // given n<h \\n        int k ;\\n        int low=1, high=*max_element(piles.begin(),piles.end()) ;\\n        if(n==h){\\n            return high;\\n        }\\n        while(low<=high){\\n            k = low + (high-low)/2 ;\\n            // cout<<k<<\" \";\\n            int time = 0 ;\\n            for(int i=0; i<n; i++){\\n                time += (1+(piles[i]/k));\\n            }\\n            if(time<h){\\n                high = k-1;\\n            }\\n            if(time>h){\\n                low = k+1;\\n            }\\n            if(time==h){\\n                break;\\n                return k;\\n            }\\n        }\\n        for(int i=k; i>0; i--){\\n            // cout<<endl<<i<<\" \";\\n            int time = 0 ;\\n            for(int j=0; j<n; j++){\\n                if(piles[j]==i){\\n                    time+=piles[j]/i ;\\n                }\\n                else{\\n                    time += (1+(piles[j]/i));\\n                }\\n                \\n            }\\n            // cout<<time<<endl;\\n            if(time>h){\\n                return i+1;\\n            }\\n        }\\n        return 1 ;\\n    }\\n};"
                    },
                    {
                        "username": "raja-2502",
                        "content": "can anyone explain what will happen when the pile has more than the required bananas......"
                    },
                    {
                        "username": "Malav_1712",
                        "content": "Why cannot we use average for this questions sum of array /h?"
                    },
                    {
                        "username": "leitor79",
                        "content": "I don\\'t understand one case. There are 18 piles, but the expected answer is 14.  How the expected answer could be less than the number of piles if each pile takes at least 1 hour?\\n\\npiles =\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\nh =\\n823855818\\n\\nUse Testcase\\nOutput\\n18\\nExpected\\n14\\n"
                    },
                    {
                        "username": "pixelbubble",
                        "content": "how is this a binary search question *cries"
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko can eat 80553579 bananas in 1 hour but takes 2 hours to eat 2 piles of 1 banana each..."
                    },
                    {
                        "username": "jess_35",
                        "content": "Its not clearly said in the question but KOKO can at max eat a pile an hour not more than that so rather than eating 88 bananas(i.e. total sum of piles array) in example 1 she can only eat at max 11 bananas (i.e. max of that array) "
                    },
                    {
                        "username": "aman1320",
                        "content": "NO ONE WROTE : its is similar to \"Aggressive Cow\" !!"
                    },
                    {
                        "username": "arpit900",
                        "content": "for input [30,11,23,4,20]\\noutput could be 23 and 24 both, but why leetcode is considering 24 to be correct."
                    }
                ]
            },
            {
                "id": 1969065,
                "content": [
                    {
                        "username": "suenolivia",
                        "content": "```        \\n        l, r = 1, max(piles)\\n\\n        curMinSpeed = max(piles)\\n\\n        def timeTakenToFinish(speed):\\n            time = 0\\n            for pile in piles:\\n                time += ceil(pile/speed)\\n            return time\\n\\n        while l <= r:\\n            mid = (l+r)//2\\n\\n            # check how many hours to finish\\n            time = timeTakenToFinish(mid)\\n\\n            # if time == h:\\n            #     return mid\\n            if time > h:\\n                # taking too long\\n                l = mid + 1\\n            else:\\n                # can afford more time\\n                curMinSpeed = min(curMinSpeed, mid)\\n                r = mid - 1\\n        \\n        return curMinSpeed\\n```\\n\\nIf I uncomment `if time==h: return  mid`,\\nthe final test case fails: piles [1,1,1,999999999] , h=10.\\n\\nBut I am wondering why, can\\'t I just return the speed when time==h, isnt it already theoretically the slowest speed since we maximise the time when time==h?"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "interviewer : u wrote good code but it breaks at piles =\\n[312884470]\\nh =\\n312884469 so u failed \\n\\nbruh who tf made this test case \\n \\n\\nAnyways heres binary+linear search code which misses just by a few testcases since underflow \\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n = piles.size();\\n        if(n==1){\\n            return ceil((float)((double)piles[0]/(double)h));\\n        }\\n        // given n<h \\n        int k ;\\n        int low=1, high=*max_element(piles.begin(),piles.end()) ;\\n        if(n==h){\\n            return high;\\n        }\\n        while(low<=high){\\n            k = low + (high-low)/2 ;\\n            // cout<<k<<\" \";\\n            int time = 0 ;\\n            for(int i=0; i<n; i++){\\n                time += (1+(piles[i]/k));\\n            }\\n            if(time<h){\\n                high = k-1;\\n            }\\n            if(time>h){\\n                low = k+1;\\n            }\\n            if(time==h){\\n                break;\\n                return k;\\n            }\\n        }\\n        for(int i=k; i>0; i--){\\n            // cout<<endl<<i<<\" \";\\n            int time = 0 ;\\n            for(int j=0; j<n; j++){\\n                if(piles[j]==i){\\n                    time+=piles[j]/i ;\\n                }\\n                else{\\n                    time += (1+(piles[j]/i));\\n                }\\n                \\n            }\\n            // cout<<time<<endl;\\n            if(time>h){\\n                return i+1;\\n            }\\n        }\\n        return 1 ;\\n    }\\n};"
                    },
                    {
                        "username": "raja-2502",
                        "content": "can anyone explain what will happen when the pile has more than the required bananas......"
                    },
                    {
                        "username": "Malav_1712",
                        "content": "Why cannot we use average for this questions sum of array /h?"
                    },
                    {
                        "username": "leitor79",
                        "content": "I don\\'t understand one case. There are 18 piles, but the expected answer is 14.  How the expected answer could be less than the number of piles if each pile takes at least 1 hour?\\n\\npiles =\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\nh =\\n823855818\\n\\nUse Testcase\\nOutput\\n18\\nExpected\\n14\\n"
                    },
                    {
                        "username": "pixelbubble",
                        "content": "how is this a binary search question *cries"
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko can eat 80553579 bananas in 1 hour but takes 2 hours to eat 2 piles of 1 banana each..."
                    },
                    {
                        "username": "jess_35",
                        "content": "Its not clearly said in the question but KOKO can at max eat a pile an hour not more than that so rather than eating 88 bananas(i.e. total sum of piles array) in example 1 she can only eat at max 11 bananas (i.e. max of that array) "
                    },
                    {
                        "username": "aman1320",
                        "content": "NO ONE WROTE : its is similar to \"Aggressive Cow\" !!"
                    },
                    {
                        "username": "arpit900",
                        "content": "for input [30,11,23,4,20]\\noutput could be 23 and 24 both, but why leetcode is considering 24 to be correct."
                    }
                ]
            },
            {
                "id": 1964373,
                "content": [
                    {
                        "username": "ayush0000ayush",
                        "content": "what is expected time complexity in this question\\n"
                    },
                    {
                        "username": "sivaswaroopsarma121",
                        "content": "if the monkey can decide k why cant it be the maximum element of the array like for example 3,6,7,11 where h=8 k can be 11 the monkey can finish it in 4 hours before h runs out can someone explain why it is not like that ? "
                    },
                    {
                        "username": "twentv",
                        "content": "Crazy Bitch eating whole year banana supply of Australia by herself."
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "Input: piles = [3,6,7,11], h = 8\\nOutput: 4     \\n in this test case 5 is also a valid answer accourding to the question.  plese  tell anyone if i am wrong"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "I was thinking so hard about the math. Seriously, I was thinking about the divisions and smart way of finding the good divider to iterate on. Turns out that \"binary search\" is just an improved version of brute force. Stop overthinking!"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can anyone explain why there are two upper boundaries for piles.length in constraints?  `piles.length <= 10^4` and `piles.length <=h <= 10^9`"
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why am i thinking about otama from wano arc one piece when reading this problem .. lol xD"
                    },
                    {
                        "username": "piyush_ag",
                        "content": "can someone please help me , what is wrong with mineatingspeed function , why is it always returning 1 even though my valid function is 100% correct ?\nclass Solution {\nprivate:\nbool valid(int k ,vector<int>& piles , int h )   \n{\n     int count = 0 ;\n     for(int i = 0 ; i <piles.size();i++)\n     {  \n        while(piles[i]>0)\n        {\n            piles[i]=piles[i]-k;\n            count ++;\n        } \n\n     }\n    if( count<=h)\n    return 1 ;\n    else return 0;\n} \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int ans =0;\n         int i = 1;\n         int e = INT_MAX/2;\n         while(i<=e)\n         {\n             int mid = (i+e)/2;\n             if(valid(mid,piles,h))\n             {\n                 ans = mid ;\n                 e=mid-1;\n             }\n             else i = mid+1;\n\n         }\n         return ans;\n\n    }\n};"
                    },
                    {
                        "username": "zkerner1",
                        "content": "Remove \\'instead\\' from the problem description - its crappy writing."
                    },
                    {
                        "username": "rnikh",
                        "content": "2064| Minimized Maximum of Products Distributed to Any Store is similar"
                    }
                ]
            },
            {
                "id": 1956049,
                "content": [
                    {
                        "username": "ayush0000ayush",
                        "content": "what is expected time complexity in this question\\n"
                    },
                    {
                        "username": "sivaswaroopsarma121",
                        "content": "if the monkey can decide k why cant it be the maximum element of the array like for example 3,6,7,11 where h=8 k can be 11 the monkey can finish it in 4 hours before h runs out can someone explain why it is not like that ? "
                    },
                    {
                        "username": "twentv",
                        "content": "Crazy Bitch eating whole year banana supply of Australia by herself."
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "Input: piles = [3,6,7,11], h = 8\\nOutput: 4     \\n in this test case 5 is also a valid answer accourding to the question.  plese  tell anyone if i am wrong"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "I was thinking so hard about the math. Seriously, I was thinking about the divisions and smart way of finding the good divider to iterate on. Turns out that \"binary search\" is just an improved version of brute force. Stop overthinking!"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can anyone explain why there are two upper boundaries for piles.length in constraints?  `piles.length <= 10^4` and `piles.length <=h <= 10^9`"
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why am i thinking about otama from wano arc one piece when reading this problem .. lol xD"
                    },
                    {
                        "username": "piyush_ag",
                        "content": "can someone please help me , what is wrong with mineatingspeed function , why is it always returning 1 even though my valid function is 100% correct ?\nclass Solution {\nprivate:\nbool valid(int k ,vector<int>& piles , int h )   \n{\n     int count = 0 ;\n     for(int i = 0 ; i <piles.size();i++)\n     {  \n        while(piles[i]>0)\n        {\n            piles[i]=piles[i]-k;\n            count ++;\n        } \n\n     }\n    if( count<=h)\n    return 1 ;\n    else return 0;\n} \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int ans =0;\n         int i = 1;\n         int e = INT_MAX/2;\n         while(i<=e)\n         {\n             int mid = (i+e)/2;\n             if(valid(mid,piles,h))\n             {\n                 ans = mid ;\n                 e=mid-1;\n             }\n             else i = mid+1;\n\n         }\n         return ans;\n\n    }\n};"
                    },
                    {
                        "username": "zkerner1",
                        "content": "Remove \\'instead\\' from the problem description - its crappy writing."
                    },
                    {
                        "username": "rnikh",
                        "content": "2064| Minimized Maximum of Products Distributed to Any Store is similar"
                    }
                ]
            },
            {
                "id": 1953022,
                "content": [
                    {
                        "username": "ayush0000ayush",
                        "content": "what is expected time complexity in this question\\n"
                    },
                    {
                        "username": "sivaswaroopsarma121",
                        "content": "if the monkey can decide k why cant it be the maximum element of the array like for example 3,6,7,11 where h=8 k can be 11 the monkey can finish it in 4 hours before h runs out can someone explain why it is not like that ? "
                    },
                    {
                        "username": "twentv",
                        "content": "Crazy Bitch eating whole year banana supply of Australia by herself."
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "Input: piles = [3,6,7,11], h = 8\\nOutput: 4     \\n in this test case 5 is also a valid answer accourding to the question.  plese  tell anyone if i am wrong"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "I was thinking so hard about the math. Seriously, I was thinking about the divisions and smart way of finding the good divider to iterate on. Turns out that \"binary search\" is just an improved version of brute force. Stop overthinking!"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can anyone explain why there are two upper boundaries for piles.length in constraints?  `piles.length <= 10^4` and `piles.length <=h <= 10^9`"
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why am i thinking about otama from wano arc one piece when reading this problem .. lol xD"
                    },
                    {
                        "username": "piyush_ag",
                        "content": "can someone please help me , what is wrong with mineatingspeed function , why is it always returning 1 even though my valid function is 100% correct ?\nclass Solution {\nprivate:\nbool valid(int k ,vector<int>& piles , int h )   \n{\n     int count = 0 ;\n     for(int i = 0 ; i <piles.size();i++)\n     {  \n        while(piles[i]>0)\n        {\n            piles[i]=piles[i]-k;\n            count ++;\n        } \n\n     }\n    if( count<=h)\n    return 1 ;\n    else return 0;\n} \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int ans =0;\n         int i = 1;\n         int e = INT_MAX/2;\n         while(i<=e)\n         {\n             int mid = (i+e)/2;\n             if(valid(mid,piles,h))\n             {\n                 ans = mid ;\n                 e=mid-1;\n             }\n             else i = mid+1;\n\n         }\n         return ans;\n\n    }\n};"
                    },
                    {
                        "username": "zkerner1",
                        "content": "Remove \\'instead\\' from the problem description - its crappy writing."
                    },
                    {
                        "username": "rnikh",
                        "content": "2064| Minimized Maximum of Products Distributed to Any Store is similar"
                    }
                ]
            },
            {
                "id": 1950140,
                "content": [
                    {
                        "username": "ayush0000ayush",
                        "content": "what is expected time complexity in this question\\n"
                    },
                    {
                        "username": "sivaswaroopsarma121",
                        "content": "if the monkey can decide k why cant it be the maximum element of the array like for example 3,6,7,11 where h=8 k can be 11 the monkey can finish it in 4 hours before h runs out can someone explain why it is not like that ? "
                    },
                    {
                        "username": "twentv",
                        "content": "Crazy Bitch eating whole year banana supply of Australia by herself."
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "Input: piles = [3,6,7,11], h = 8\\nOutput: 4     \\n in this test case 5 is also a valid answer accourding to the question.  plese  tell anyone if i am wrong"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "I was thinking so hard about the math. Seriously, I was thinking about the divisions and smart way of finding the good divider to iterate on. Turns out that \"binary search\" is just an improved version of brute force. Stop overthinking!"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can anyone explain why there are two upper boundaries for piles.length in constraints?  `piles.length <= 10^4` and `piles.length <=h <= 10^9`"
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why am i thinking about otama from wano arc one piece when reading this problem .. lol xD"
                    },
                    {
                        "username": "piyush_ag",
                        "content": "can someone please help me , what is wrong with mineatingspeed function , why is it always returning 1 even though my valid function is 100% correct ?\nclass Solution {\nprivate:\nbool valid(int k ,vector<int>& piles , int h )   \n{\n     int count = 0 ;\n     for(int i = 0 ; i <piles.size();i++)\n     {  \n        while(piles[i]>0)\n        {\n            piles[i]=piles[i]-k;\n            count ++;\n        } \n\n     }\n    if( count<=h)\n    return 1 ;\n    else return 0;\n} \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int ans =0;\n         int i = 1;\n         int e = INT_MAX/2;\n         while(i<=e)\n         {\n             int mid = (i+e)/2;\n             if(valid(mid,piles,h))\n             {\n                 ans = mid ;\n                 e=mid-1;\n             }\n             else i = mid+1;\n\n         }\n         return ans;\n\n    }\n};"
                    },
                    {
                        "username": "zkerner1",
                        "content": "Remove \\'instead\\' from the problem description - its crappy writing."
                    },
                    {
                        "username": "rnikh",
                        "content": "2064| Minimized Maximum of Products Distributed to Any Store is similar"
                    }
                ]
            },
            {
                "id": 1949682,
                "content": [
                    {
                        "username": "ayush0000ayush",
                        "content": "what is expected time complexity in this question\\n"
                    },
                    {
                        "username": "sivaswaroopsarma121",
                        "content": "if the monkey can decide k why cant it be the maximum element of the array like for example 3,6,7,11 where h=8 k can be 11 the monkey can finish it in 4 hours before h runs out can someone explain why it is not like that ? "
                    },
                    {
                        "username": "twentv",
                        "content": "Crazy Bitch eating whole year banana supply of Australia by herself."
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "Input: piles = [3,6,7,11], h = 8\\nOutput: 4     \\n in this test case 5 is also a valid answer accourding to the question.  plese  tell anyone if i am wrong"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "I was thinking so hard about the math. Seriously, I was thinking about the divisions and smart way of finding the good divider to iterate on. Turns out that \"binary search\" is just an improved version of brute force. Stop overthinking!"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can anyone explain why there are two upper boundaries for piles.length in constraints?  `piles.length <= 10^4` and `piles.length <=h <= 10^9`"
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why am i thinking about otama from wano arc one piece when reading this problem .. lol xD"
                    },
                    {
                        "username": "piyush_ag",
                        "content": "can someone please help me , what is wrong with mineatingspeed function , why is it always returning 1 even though my valid function is 100% correct ?\nclass Solution {\nprivate:\nbool valid(int k ,vector<int>& piles , int h )   \n{\n     int count = 0 ;\n     for(int i = 0 ; i <piles.size();i++)\n     {  \n        while(piles[i]>0)\n        {\n            piles[i]=piles[i]-k;\n            count ++;\n        } \n\n     }\n    if( count<=h)\n    return 1 ;\n    else return 0;\n} \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int ans =0;\n         int i = 1;\n         int e = INT_MAX/2;\n         while(i<=e)\n         {\n             int mid = (i+e)/2;\n             if(valid(mid,piles,h))\n             {\n                 ans = mid ;\n                 e=mid-1;\n             }\n             else i = mid+1;\n\n         }\n         return ans;\n\n    }\n};"
                    },
                    {
                        "username": "zkerner1",
                        "content": "Remove \\'instead\\' from the problem description - its crappy writing."
                    },
                    {
                        "username": "rnikh",
                        "content": "2064| Minimized Maximum of Products Distributed to Any Store is similar"
                    }
                ]
            },
            {
                "id": 1948351,
                "content": [
                    {
                        "username": "ayush0000ayush",
                        "content": "what is expected time complexity in this question\\n"
                    },
                    {
                        "username": "sivaswaroopsarma121",
                        "content": "if the monkey can decide k why cant it be the maximum element of the array like for example 3,6,7,11 where h=8 k can be 11 the monkey can finish it in 4 hours before h runs out can someone explain why it is not like that ? "
                    },
                    {
                        "username": "twentv",
                        "content": "Crazy Bitch eating whole year banana supply of Australia by herself."
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "Input: piles = [3,6,7,11], h = 8\\nOutput: 4     \\n in this test case 5 is also a valid answer accourding to the question.  plese  tell anyone if i am wrong"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "I was thinking so hard about the math. Seriously, I was thinking about the divisions and smart way of finding the good divider to iterate on. Turns out that \"binary search\" is just an improved version of brute force. Stop overthinking!"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can anyone explain why there are two upper boundaries for piles.length in constraints?  `piles.length <= 10^4` and `piles.length <=h <= 10^9`"
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why am i thinking about otama from wano arc one piece when reading this problem .. lol xD"
                    },
                    {
                        "username": "piyush_ag",
                        "content": "can someone please help me , what is wrong with mineatingspeed function , why is it always returning 1 even though my valid function is 100% correct ?\nclass Solution {\nprivate:\nbool valid(int k ,vector<int>& piles , int h )   \n{\n     int count = 0 ;\n     for(int i = 0 ; i <piles.size();i++)\n     {  \n        while(piles[i]>0)\n        {\n            piles[i]=piles[i]-k;\n            count ++;\n        } \n\n     }\n    if( count<=h)\n    return 1 ;\n    else return 0;\n} \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int ans =0;\n         int i = 1;\n         int e = INT_MAX/2;\n         while(i<=e)\n         {\n             int mid = (i+e)/2;\n             if(valid(mid,piles,h))\n             {\n                 ans = mid ;\n                 e=mid-1;\n             }\n             else i = mid+1;\n\n         }\n         return ans;\n\n    }\n};"
                    },
                    {
                        "username": "zkerner1",
                        "content": "Remove \\'instead\\' from the problem description - its crappy writing."
                    },
                    {
                        "username": "rnikh",
                        "content": "2064| Minimized Maximum of Products Distributed to Any Store is similar"
                    }
                ]
            },
            {
                "id": 1947126,
                "content": [
                    {
                        "username": "ayush0000ayush",
                        "content": "what is expected time complexity in this question\\n"
                    },
                    {
                        "username": "sivaswaroopsarma121",
                        "content": "if the monkey can decide k why cant it be the maximum element of the array like for example 3,6,7,11 where h=8 k can be 11 the monkey can finish it in 4 hours before h runs out can someone explain why it is not like that ? "
                    },
                    {
                        "username": "twentv",
                        "content": "Crazy Bitch eating whole year banana supply of Australia by herself."
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "Input: piles = [3,6,7,11], h = 8\\nOutput: 4     \\n in this test case 5 is also a valid answer accourding to the question.  plese  tell anyone if i am wrong"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "I was thinking so hard about the math. Seriously, I was thinking about the divisions and smart way of finding the good divider to iterate on. Turns out that \"binary search\" is just an improved version of brute force. Stop overthinking!"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can anyone explain why there are two upper boundaries for piles.length in constraints?  `piles.length <= 10^4` and `piles.length <=h <= 10^9`"
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why am i thinking about otama from wano arc one piece when reading this problem .. lol xD"
                    },
                    {
                        "username": "piyush_ag",
                        "content": "can someone please help me , what is wrong with mineatingspeed function , why is it always returning 1 even though my valid function is 100% correct ?\nclass Solution {\nprivate:\nbool valid(int k ,vector<int>& piles , int h )   \n{\n     int count = 0 ;\n     for(int i = 0 ; i <piles.size();i++)\n     {  \n        while(piles[i]>0)\n        {\n            piles[i]=piles[i]-k;\n            count ++;\n        } \n\n     }\n    if( count<=h)\n    return 1 ;\n    else return 0;\n} \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int ans =0;\n         int i = 1;\n         int e = INT_MAX/2;\n         while(i<=e)\n         {\n             int mid = (i+e)/2;\n             if(valid(mid,piles,h))\n             {\n                 ans = mid ;\n                 e=mid-1;\n             }\n             else i = mid+1;\n\n         }\n         return ans;\n\n    }\n};"
                    },
                    {
                        "username": "zkerner1",
                        "content": "Remove \\'instead\\' from the problem description - its crappy writing."
                    },
                    {
                        "username": "rnikh",
                        "content": "2064| Minimized Maximum of Products Distributed to Any Store is similar"
                    }
                ]
            },
            {
                "id": 1946225,
                "content": [
                    {
                        "username": "ayush0000ayush",
                        "content": "what is expected time complexity in this question\\n"
                    },
                    {
                        "username": "sivaswaroopsarma121",
                        "content": "if the monkey can decide k why cant it be the maximum element of the array like for example 3,6,7,11 where h=8 k can be 11 the monkey can finish it in 4 hours before h runs out can someone explain why it is not like that ? "
                    },
                    {
                        "username": "twentv",
                        "content": "Crazy Bitch eating whole year banana supply of Australia by herself."
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "Input: piles = [3,6,7,11], h = 8\\nOutput: 4     \\n in this test case 5 is also a valid answer accourding to the question.  plese  tell anyone if i am wrong"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "I was thinking so hard about the math. Seriously, I was thinking about the divisions and smart way of finding the good divider to iterate on. Turns out that \"binary search\" is just an improved version of brute force. Stop overthinking!"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can anyone explain why there are two upper boundaries for piles.length in constraints?  `piles.length <= 10^4` and `piles.length <=h <= 10^9`"
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why am i thinking about otama from wano arc one piece when reading this problem .. lol xD"
                    },
                    {
                        "username": "piyush_ag",
                        "content": "can someone please help me , what is wrong with mineatingspeed function , why is it always returning 1 even though my valid function is 100% correct ?\nclass Solution {\nprivate:\nbool valid(int k ,vector<int>& piles , int h )   \n{\n     int count = 0 ;\n     for(int i = 0 ; i <piles.size();i++)\n     {  \n        while(piles[i]>0)\n        {\n            piles[i]=piles[i]-k;\n            count ++;\n        } \n\n     }\n    if( count<=h)\n    return 1 ;\n    else return 0;\n} \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int ans =0;\n         int i = 1;\n         int e = INT_MAX/2;\n         while(i<=e)\n         {\n             int mid = (i+e)/2;\n             if(valid(mid,piles,h))\n             {\n                 ans = mid ;\n                 e=mid-1;\n             }\n             else i = mid+1;\n\n         }\n         return ans;\n\n    }\n};"
                    },
                    {
                        "username": "zkerner1",
                        "content": "Remove \\'instead\\' from the problem description - its crappy writing."
                    },
                    {
                        "username": "rnikh",
                        "content": "2064| Minimized Maximum of Products Distributed to Any Store is similar"
                    }
                ]
            },
            {
                "id": 1929558,
                "content": [
                    {
                        "username": "ayush0000ayush",
                        "content": "what is expected time complexity in this question\\n"
                    },
                    {
                        "username": "sivaswaroopsarma121",
                        "content": "if the monkey can decide k why cant it be the maximum element of the array like for example 3,6,7,11 where h=8 k can be 11 the monkey can finish it in 4 hours before h runs out can someone explain why it is not like that ? "
                    },
                    {
                        "username": "twentv",
                        "content": "Crazy Bitch eating whole year banana supply of Australia by herself."
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "Input: piles = [3,6,7,11], h = 8\\nOutput: 4     \\n in this test case 5 is also a valid answer accourding to the question.  plese  tell anyone if i am wrong"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "I was thinking so hard about the math. Seriously, I was thinking about the divisions and smart way of finding the good divider to iterate on. Turns out that \"binary search\" is just an improved version of brute force. Stop overthinking!"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can anyone explain why there are two upper boundaries for piles.length in constraints?  `piles.length <= 10^4` and `piles.length <=h <= 10^9`"
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why am i thinking about otama from wano arc one piece when reading this problem .. lol xD"
                    },
                    {
                        "username": "piyush_ag",
                        "content": "can someone please help me , what is wrong with mineatingspeed function , why is it always returning 1 even though my valid function is 100% correct ?\nclass Solution {\nprivate:\nbool valid(int k ,vector<int>& piles , int h )   \n{\n     int count = 0 ;\n     for(int i = 0 ; i <piles.size();i++)\n     {  \n        while(piles[i]>0)\n        {\n            piles[i]=piles[i]-k;\n            count ++;\n        } \n\n     }\n    if( count<=h)\n    return 1 ;\n    else return 0;\n} \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int ans =0;\n         int i = 1;\n         int e = INT_MAX/2;\n         while(i<=e)\n         {\n             int mid = (i+e)/2;\n             if(valid(mid,piles,h))\n             {\n                 ans = mid ;\n                 e=mid-1;\n             }\n             else i = mid+1;\n\n         }\n         return ans;\n\n    }\n};"
                    },
                    {
                        "username": "zkerner1",
                        "content": "Remove \\'instead\\' from the problem description - its crappy writing."
                    },
                    {
                        "username": "rnikh",
                        "content": "2064| Minimized Maximum of Products Distributed to Any Store is similar"
                    }
                ]
            },
            {
                "id": 1926226,
                "content": [
                    {
                        "username": "ayush0000ayush",
                        "content": "what is expected time complexity in this question\\n"
                    },
                    {
                        "username": "sivaswaroopsarma121",
                        "content": "if the monkey can decide k why cant it be the maximum element of the array like for example 3,6,7,11 where h=8 k can be 11 the monkey can finish it in 4 hours before h runs out can someone explain why it is not like that ? "
                    },
                    {
                        "username": "twentv",
                        "content": "Crazy Bitch eating whole year banana supply of Australia by herself."
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "Input: piles = [3,6,7,11], h = 8\\nOutput: 4     \\n in this test case 5 is also a valid answer accourding to the question.  plese  tell anyone if i am wrong"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "I was thinking so hard about the math. Seriously, I was thinking about the divisions and smart way of finding the good divider to iterate on. Turns out that \"binary search\" is just an improved version of brute force. Stop overthinking!"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can anyone explain why there are two upper boundaries for piles.length in constraints?  `piles.length <= 10^4` and `piles.length <=h <= 10^9`"
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why am i thinking about otama from wano arc one piece when reading this problem .. lol xD"
                    },
                    {
                        "username": "piyush_ag",
                        "content": "can someone please help me , what is wrong with mineatingspeed function , why is it always returning 1 even though my valid function is 100% correct ?\nclass Solution {\nprivate:\nbool valid(int k ,vector<int>& piles , int h )   \n{\n     int count = 0 ;\n     for(int i = 0 ; i <piles.size();i++)\n     {  \n        while(piles[i]>0)\n        {\n            piles[i]=piles[i]-k;\n            count ++;\n        } \n\n     }\n    if( count<=h)\n    return 1 ;\n    else return 0;\n} \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int ans =0;\n         int i = 1;\n         int e = INT_MAX/2;\n         while(i<=e)\n         {\n             int mid = (i+e)/2;\n             if(valid(mid,piles,h))\n             {\n                 ans = mid ;\n                 e=mid-1;\n             }\n             else i = mid+1;\n\n         }\n         return ans;\n\n    }\n};"
                    },
                    {
                        "username": "zkerner1",
                        "content": "Remove \\'instead\\' from the problem description - its crappy writing."
                    },
                    {
                        "username": "rnikh",
                        "content": "2064| Minimized Maximum of Products Distributed to Any Store is similar"
                    }
                ]
            },
            {
                "id": 1919416,
                "content": [
                    {
                        "username": "ed3642dev",
                        "content": "Interesting to see how the fastest solutions bounded the slowest and fastest speeds possible"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "Can anyone help me to understand this test case.\\n[1,1,1,999999999] h = 10\\nMy output : 156250000 \\nExpected output: 142857143\\n\\nbut both the answers are satisfying the condition that koko can eat bananas in h hours."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "JimbeiBIG",
                        "content": "one of the test cases is piles =[312884470] ... poor Koko"
                    },
                    {
                        "username": "surfingcat",
                        "content": "The intuition, that we not only need to find a speed to finish the piles in time `h`, but then continue and find the minimum speed using binary search, is important here. "
                    },
                    {
                        "username": "abhishek_2603",
                        "content": " class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max=0;\\n         \\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int l=1,r=max,min=max;\\n        while(l<=r)\\n        {\\n            int mid=(int)(l+r)/2;\\n            int c=0;\\n            for(int i : piles)\\n            {\\n                c+=(Math.ceil(i/mid));\\n            }\\n            if(c<=h)\\n            {\\n                min=Math.min(mid,min);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n\\nwhy does this not work, I\\'m stuck on this for so so long. Please can someone debug it for me."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "how to decide left and right value??"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "My code didn\\'t run 64th test case .Can any one help me??\\nhere is my code..\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      sort(piles.begin(),piles.end());\\n      int s =piles.size()-1;\\n      int low = 1;\\n      int high = piles[s];\\n      int flag,j,sum=0,mid;\\n      while(low<=high)\\n      {\\n         sum=0;\\n        mid=(high+low)/2;\\n        for( j=0; j<=s;j++)\\n        {\\n         \\n          if(piles[j]%mid==0)\\n          {\\n              sum =sum + piles[j]/mid;\\n          }\\n          else{\\n            sum =sum + piles[j]/mid +1;\\n          }\\n        }\\n       \\n        if(sum==h)\\n        {\\n          flag = mid;\\n          break;\\n        }\\n        else if(sum<h)\\n        {\\n          high =mid-1;\\n        }\\n        else{\\n          low = mid+1;\\n        }\\n       \\n      }\\n      return flag;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "MY code pass 4th  test case piles =[312884470]  h =312884469  but fails at test case 64  piles =[312884470]\\nh =312884469 why is this happening....."
                    },
                    {
                        "username": "jems1123",
                        "content": "koko isn\\'t honest at all \\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "anyone up to practice together and take mock interviews?"
                    },
                    {
                        "username": "cennav",
                        "content": "I\\'m interesteddddd"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "I am Intrested for Mock Interviews \\n"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@bits_magma](/bits_magma) yep it\\'s \"pratap#3367\"\\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "[@pratapsimha01](/pratapsimha01) can you give me your discord username, we can discuss there?"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "yep..I am up..I am a beginner though lol\\n"
                    }
                ]
            },
            {
                "id": 1905899,
                "content": [
                    {
                        "username": "ed3642dev",
                        "content": "Interesting to see how the fastest solutions bounded the slowest and fastest speeds possible"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "Can anyone help me to understand this test case.\\n[1,1,1,999999999] h = 10\\nMy output : 156250000 \\nExpected output: 142857143\\n\\nbut both the answers are satisfying the condition that koko can eat bananas in h hours."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "JimbeiBIG",
                        "content": "one of the test cases is piles =[312884470] ... poor Koko"
                    },
                    {
                        "username": "surfingcat",
                        "content": "The intuition, that we not only need to find a speed to finish the piles in time `h`, but then continue and find the minimum speed using binary search, is important here. "
                    },
                    {
                        "username": "abhishek_2603",
                        "content": " class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max=0;\\n         \\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int l=1,r=max,min=max;\\n        while(l<=r)\\n        {\\n            int mid=(int)(l+r)/2;\\n            int c=0;\\n            for(int i : piles)\\n            {\\n                c+=(Math.ceil(i/mid));\\n            }\\n            if(c<=h)\\n            {\\n                min=Math.min(mid,min);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n\\nwhy does this not work, I\\'m stuck on this for so so long. Please can someone debug it for me."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "how to decide left and right value??"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "My code didn\\'t run 64th test case .Can any one help me??\\nhere is my code..\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      sort(piles.begin(),piles.end());\\n      int s =piles.size()-1;\\n      int low = 1;\\n      int high = piles[s];\\n      int flag,j,sum=0,mid;\\n      while(low<=high)\\n      {\\n         sum=0;\\n        mid=(high+low)/2;\\n        for( j=0; j<=s;j++)\\n        {\\n         \\n          if(piles[j]%mid==0)\\n          {\\n              sum =sum + piles[j]/mid;\\n          }\\n          else{\\n            sum =sum + piles[j]/mid +1;\\n          }\\n        }\\n       \\n        if(sum==h)\\n        {\\n          flag = mid;\\n          break;\\n        }\\n        else if(sum<h)\\n        {\\n          high =mid-1;\\n        }\\n        else{\\n          low = mid+1;\\n        }\\n       \\n      }\\n      return flag;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "MY code pass 4th  test case piles =[312884470]  h =312884469  but fails at test case 64  piles =[312884470]\\nh =312884469 why is this happening....."
                    },
                    {
                        "username": "jems1123",
                        "content": "koko isn\\'t honest at all \\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "anyone up to practice together and take mock interviews?"
                    },
                    {
                        "username": "cennav",
                        "content": "I\\'m interesteddddd"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "I am Intrested for Mock Interviews \\n"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@bits_magma](/bits_magma) yep it\\'s \"pratap#3367\"\\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "[@pratapsimha01](/pratapsimha01) can you give me your discord username, we can discuss there?"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "yep..I am up..I am a beginner though lol\\n"
                    }
                ]
            },
            {
                "id": 1893859,
                "content": [
                    {
                        "username": "ed3642dev",
                        "content": "Interesting to see how the fastest solutions bounded the slowest and fastest speeds possible"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "Can anyone help me to understand this test case.\\n[1,1,1,999999999] h = 10\\nMy output : 156250000 \\nExpected output: 142857143\\n\\nbut both the answers are satisfying the condition that koko can eat bananas in h hours."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "JimbeiBIG",
                        "content": "one of the test cases is piles =[312884470] ... poor Koko"
                    },
                    {
                        "username": "surfingcat",
                        "content": "The intuition, that we not only need to find a speed to finish the piles in time `h`, but then continue and find the minimum speed using binary search, is important here. "
                    },
                    {
                        "username": "abhishek_2603",
                        "content": " class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max=0;\\n         \\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int l=1,r=max,min=max;\\n        while(l<=r)\\n        {\\n            int mid=(int)(l+r)/2;\\n            int c=0;\\n            for(int i : piles)\\n            {\\n                c+=(Math.ceil(i/mid));\\n            }\\n            if(c<=h)\\n            {\\n                min=Math.min(mid,min);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n\\nwhy does this not work, I\\'m stuck on this for so so long. Please can someone debug it for me."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "how to decide left and right value??"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "My code didn\\'t run 64th test case .Can any one help me??\\nhere is my code..\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      sort(piles.begin(),piles.end());\\n      int s =piles.size()-1;\\n      int low = 1;\\n      int high = piles[s];\\n      int flag,j,sum=0,mid;\\n      while(low<=high)\\n      {\\n         sum=0;\\n        mid=(high+low)/2;\\n        for( j=0; j<=s;j++)\\n        {\\n         \\n          if(piles[j]%mid==0)\\n          {\\n              sum =sum + piles[j]/mid;\\n          }\\n          else{\\n            sum =sum + piles[j]/mid +1;\\n          }\\n        }\\n       \\n        if(sum==h)\\n        {\\n          flag = mid;\\n          break;\\n        }\\n        else if(sum<h)\\n        {\\n          high =mid-1;\\n        }\\n        else{\\n          low = mid+1;\\n        }\\n       \\n      }\\n      return flag;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "MY code pass 4th  test case piles =[312884470]  h =312884469  but fails at test case 64  piles =[312884470]\\nh =312884469 why is this happening....."
                    },
                    {
                        "username": "jems1123",
                        "content": "koko isn\\'t honest at all \\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "anyone up to practice together and take mock interviews?"
                    },
                    {
                        "username": "cennav",
                        "content": "I\\'m interesteddddd"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "I am Intrested for Mock Interviews \\n"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@bits_magma](/bits_magma) yep it\\'s \"pratap#3367\"\\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "[@pratapsimha01](/pratapsimha01) can you give me your discord username, we can discuss there?"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "yep..I am up..I am a beginner though lol\\n"
                    }
                ]
            },
            {
                "id": 1882621,
                "content": [
                    {
                        "username": "ed3642dev",
                        "content": "Interesting to see how the fastest solutions bounded the slowest and fastest speeds possible"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "Can anyone help me to understand this test case.\\n[1,1,1,999999999] h = 10\\nMy output : 156250000 \\nExpected output: 142857143\\n\\nbut both the answers are satisfying the condition that koko can eat bananas in h hours."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "JimbeiBIG",
                        "content": "one of the test cases is piles =[312884470] ... poor Koko"
                    },
                    {
                        "username": "surfingcat",
                        "content": "The intuition, that we not only need to find a speed to finish the piles in time `h`, but then continue and find the minimum speed using binary search, is important here. "
                    },
                    {
                        "username": "abhishek_2603",
                        "content": " class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max=0;\\n         \\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int l=1,r=max,min=max;\\n        while(l<=r)\\n        {\\n            int mid=(int)(l+r)/2;\\n            int c=0;\\n            for(int i : piles)\\n            {\\n                c+=(Math.ceil(i/mid));\\n            }\\n            if(c<=h)\\n            {\\n                min=Math.min(mid,min);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n\\nwhy does this not work, I\\'m stuck on this for so so long. Please can someone debug it for me."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "how to decide left and right value??"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "My code didn\\'t run 64th test case .Can any one help me??\\nhere is my code..\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      sort(piles.begin(),piles.end());\\n      int s =piles.size()-1;\\n      int low = 1;\\n      int high = piles[s];\\n      int flag,j,sum=0,mid;\\n      while(low<=high)\\n      {\\n         sum=0;\\n        mid=(high+low)/2;\\n        for( j=0; j<=s;j++)\\n        {\\n         \\n          if(piles[j]%mid==0)\\n          {\\n              sum =sum + piles[j]/mid;\\n          }\\n          else{\\n            sum =sum + piles[j]/mid +1;\\n          }\\n        }\\n       \\n        if(sum==h)\\n        {\\n          flag = mid;\\n          break;\\n        }\\n        else if(sum<h)\\n        {\\n          high =mid-1;\\n        }\\n        else{\\n          low = mid+1;\\n        }\\n       \\n      }\\n      return flag;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "MY code pass 4th  test case piles =[312884470]  h =312884469  but fails at test case 64  piles =[312884470]\\nh =312884469 why is this happening....."
                    },
                    {
                        "username": "jems1123",
                        "content": "koko isn\\'t honest at all \\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "anyone up to practice together and take mock interviews?"
                    },
                    {
                        "username": "cennav",
                        "content": "I\\'m interesteddddd"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "I am Intrested for Mock Interviews \\n"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@bits_magma](/bits_magma) yep it\\'s \"pratap#3367\"\\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "[@pratapsimha01](/pratapsimha01) can you give me your discord username, we can discuss there?"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "yep..I am up..I am a beginner though lol\\n"
                    }
                ]
            },
            {
                "id": 1849895,
                "content": [
                    {
                        "username": "ed3642dev",
                        "content": "Interesting to see how the fastest solutions bounded the slowest and fastest speeds possible"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "Can anyone help me to understand this test case.\\n[1,1,1,999999999] h = 10\\nMy output : 156250000 \\nExpected output: 142857143\\n\\nbut both the answers are satisfying the condition that koko can eat bananas in h hours."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "JimbeiBIG",
                        "content": "one of the test cases is piles =[312884470] ... poor Koko"
                    },
                    {
                        "username": "surfingcat",
                        "content": "The intuition, that we not only need to find a speed to finish the piles in time `h`, but then continue and find the minimum speed using binary search, is important here. "
                    },
                    {
                        "username": "abhishek_2603",
                        "content": " class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max=0;\\n         \\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int l=1,r=max,min=max;\\n        while(l<=r)\\n        {\\n            int mid=(int)(l+r)/2;\\n            int c=0;\\n            for(int i : piles)\\n            {\\n                c+=(Math.ceil(i/mid));\\n            }\\n            if(c<=h)\\n            {\\n                min=Math.min(mid,min);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n\\nwhy does this not work, I\\'m stuck on this for so so long. Please can someone debug it for me."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "how to decide left and right value??"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "My code didn\\'t run 64th test case .Can any one help me??\\nhere is my code..\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      sort(piles.begin(),piles.end());\\n      int s =piles.size()-1;\\n      int low = 1;\\n      int high = piles[s];\\n      int flag,j,sum=0,mid;\\n      while(low<=high)\\n      {\\n         sum=0;\\n        mid=(high+low)/2;\\n        for( j=0; j<=s;j++)\\n        {\\n         \\n          if(piles[j]%mid==0)\\n          {\\n              sum =sum + piles[j]/mid;\\n          }\\n          else{\\n            sum =sum + piles[j]/mid +1;\\n          }\\n        }\\n       \\n        if(sum==h)\\n        {\\n          flag = mid;\\n          break;\\n        }\\n        else if(sum<h)\\n        {\\n          high =mid-1;\\n        }\\n        else{\\n          low = mid+1;\\n        }\\n       \\n      }\\n      return flag;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "MY code pass 4th  test case piles =[312884470]  h =312884469  but fails at test case 64  piles =[312884470]\\nh =312884469 why is this happening....."
                    },
                    {
                        "username": "jems1123",
                        "content": "koko isn\\'t honest at all \\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "anyone up to practice together and take mock interviews?"
                    },
                    {
                        "username": "cennav",
                        "content": "I\\'m interesteddddd"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "I am Intrested for Mock Interviews \\n"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@bits_magma](/bits_magma) yep it\\'s \"pratap#3367\"\\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "[@pratapsimha01](/pratapsimha01) can you give me your discord username, we can discuss there?"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "yep..I am up..I am a beginner though lol\\n"
                    }
                ]
            },
            {
                "id": 1832983,
                "content": [
                    {
                        "username": "ed3642dev",
                        "content": "Interesting to see how the fastest solutions bounded the slowest and fastest speeds possible"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "Can anyone help me to understand this test case.\\n[1,1,1,999999999] h = 10\\nMy output : 156250000 \\nExpected output: 142857143\\n\\nbut both the answers are satisfying the condition that koko can eat bananas in h hours."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "JimbeiBIG",
                        "content": "one of the test cases is piles =[312884470] ... poor Koko"
                    },
                    {
                        "username": "surfingcat",
                        "content": "The intuition, that we not only need to find a speed to finish the piles in time `h`, but then continue and find the minimum speed using binary search, is important here. "
                    },
                    {
                        "username": "abhishek_2603",
                        "content": " class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max=0;\\n         \\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int l=1,r=max,min=max;\\n        while(l<=r)\\n        {\\n            int mid=(int)(l+r)/2;\\n            int c=0;\\n            for(int i : piles)\\n            {\\n                c+=(Math.ceil(i/mid));\\n            }\\n            if(c<=h)\\n            {\\n                min=Math.min(mid,min);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n\\nwhy does this not work, I\\'m stuck on this for so so long. Please can someone debug it for me."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "how to decide left and right value??"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "My code didn\\'t run 64th test case .Can any one help me??\\nhere is my code..\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      sort(piles.begin(),piles.end());\\n      int s =piles.size()-1;\\n      int low = 1;\\n      int high = piles[s];\\n      int flag,j,sum=0,mid;\\n      while(low<=high)\\n      {\\n         sum=0;\\n        mid=(high+low)/2;\\n        for( j=0; j<=s;j++)\\n        {\\n         \\n          if(piles[j]%mid==0)\\n          {\\n              sum =sum + piles[j]/mid;\\n          }\\n          else{\\n            sum =sum + piles[j]/mid +1;\\n          }\\n        }\\n       \\n        if(sum==h)\\n        {\\n          flag = mid;\\n          break;\\n        }\\n        else if(sum<h)\\n        {\\n          high =mid-1;\\n        }\\n        else{\\n          low = mid+1;\\n        }\\n       \\n      }\\n      return flag;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "MY code pass 4th  test case piles =[312884470]  h =312884469  but fails at test case 64  piles =[312884470]\\nh =312884469 why is this happening....."
                    },
                    {
                        "username": "jems1123",
                        "content": "koko isn\\'t honest at all \\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "anyone up to practice together and take mock interviews?"
                    },
                    {
                        "username": "cennav",
                        "content": "I\\'m interesteddddd"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "I am Intrested for Mock Interviews \\n"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@bits_magma](/bits_magma) yep it\\'s \"pratap#3367\"\\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "[@pratapsimha01](/pratapsimha01) can you give me your discord username, we can discuss there?"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "yep..I am up..I am a beginner though lol\\n"
                    }
                ]
            },
            {
                "id": 1828004,
                "content": [
                    {
                        "username": "ed3642dev",
                        "content": "Interesting to see how the fastest solutions bounded the slowest and fastest speeds possible"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "Can anyone help me to understand this test case.\\n[1,1,1,999999999] h = 10\\nMy output : 156250000 \\nExpected output: 142857143\\n\\nbut both the answers are satisfying the condition that koko can eat bananas in h hours."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "JimbeiBIG",
                        "content": "one of the test cases is piles =[312884470] ... poor Koko"
                    },
                    {
                        "username": "surfingcat",
                        "content": "The intuition, that we not only need to find a speed to finish the piles in time `h`, but then continue and find the minimum speed using binary search, is important here. "
                    },
                    {
                        "username": "abhishek_2603",
                        "content": " class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max=0;\\n         \\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int l=1,r=max,min=max;\\n        while(l<=r)\\n        {\\n            int mid=(int)(l+r)/2;\\n            int c=0;\\n            for(int i : piles)\\n            {\\n                c+=(Math.ceil(i/mid));\\n            }\\n            if(c<=h)\\n            {\\n                min=Math.min(mid,min);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n\\nwhy does this not work, I\\'m stuck on this for so so long. Please can someone debug it for me."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "how to decide left and right value??"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "My code didn\\'t run 64th test case .Can any one help me??\\nhere is my code..\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      sort(piles.begin(),piles.end());\\n      int s =piles.size()-1;\\n      int low = 1;\\n      int high = piles[s];\\n      int flag,j,sum=0,mid;\\n      while(low<=high)\\n      {\\n         sum=0;\\n        mid=(high+low)/2;\\n        for( j=0; j<=s;j++)\\n        {\\n         \\n          if(piles[j]%mid==0)\\n          {\\n              sum =sum + piles[j]/mid;\\n          }\\n          else{\\n            sum =sum + piles[j]/mid +1;\\n          }\\n        }\\n       \\n        if(sum==h)\\n        {\\n          flag = mid;\\n          break;\\n        }\\n        else if(sum<h)\\n        {\\n          high =mid-1;\\n        }\\n        else{\\n          low = mid+1;\\n        }\\n       \\n      }\\n      return flag;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "MY code pass 4th  test case piles =[312884470]  h =312884469  but fails at test case 64  piles =[312884470]\\nh =312884469 why is this happening....."
                    },
                    {
                        "username": "jems1123",
                        "content": "koko isn\\'t honest at all \\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "anyone up to practice together and take mock interviews?"
                    },
                    {
                        "username": "cennav",
                        "content": "I\\'m interesteddddd"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "I am Intrested for Mock Interviews \\n"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@bits_magma](/bits_magma) yep it\\'s \"pratap#3367\"\\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "[@pratapsimha01](/pratapsimha01) can you give me your discord username, we can discuss there?"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "yep..I am up..I am a beginner though lol\\n"
                    }
                ]
            },
            {
                "id": 1827547,
                "content": [
                    {
                        "username": "ed3642dev",
                        "content": "Interesting to see how the fastest solutions bounded the slowest and fastest speeds possible"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "Can anyone help me to understand this test case.\\n[1,1,1,999999999] h = 10\\nMy output : 156250000 \\nExpected output: 142857143\\n\\nbut both the answers are satisfying the condition that koko can eat bananas in h hours."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "JimbeiBIG",
                        "content": "one of the test cases is piles =[312884470] ... poor Koko"
                    },
                    {
                        "username": "surfingcat",
                        "content": "The intuition, that we not only need to find a speed to finish the piles in time `h`, but then continue and find the minimum speed using binary search, is important here. "
                    },
                    {
                        "username": "abhishek_2603",
                        "content": " class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max=0;\\n         \\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int l=1,r=max,min=max;\\n        while(l<=r)\\n        {\\n            int mid=(int)(l+r)/2;\\n            int c=0;\\n            for(int i : piles)\\n            {\\n                c+=(Math.ceil(i/mid));\\n            }\\n            if(c<=h)\\n            {\\n                min=Math.min(mid,min);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n\\nwhy does this not work, I\\'m stuck on this for so so long. Please can someone debug it for me."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "how to decide left and right value??"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "My code didn\\'t run 64th test case .Can any one help me??\\nhere is my code..\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      sort(piles.begin(),piles.end());\\n      int s =piles.size()-1;\\n      int low = 1;\\n      int high = piles[s];\\n      int flag,j,sum=0,mid;\\n      while(low<=high)\\n      {\\n         sum=0;\\n        mid=(high+low)/2;\\n        for( j=0; j<=s;j++)\\n        {\\n         \\n          if(piles[j]%mid==0)\\n          {\\n              sum =sum + piles[j]/mid;\\n          }\\n          else{\\n            sum =sum + piles[j]/mid +1;\\n          }\\n        }\\n       \\n        if(sum==h)\\n        {\\n          flag = mid;\\n          break;\\n        }\\n        else if(sum<h)\\n        {\\n          high =mid-1;\\n        }\\n        else{\\n          low = mid+1;\\n        }\\n       \\n      }\\n      return flag;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "MY code pass 4th  test case piles =[312884470]  h =312884469  but fails at test case 64  piles =[312884470]\\nh =312884469 why is this happening....."
                    },
                    {
                        "username": "jems1123",
                        "content": "koko isn\\'t honest at all \\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "anyone up to practice together and take mock interviews?"
                    },
                    {
                        "username": "cennav",
                        "content": "I\\'m interesteddddd"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "I am Intrested for Mock Interviews \\n"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@bits_magma](/bits_magma) yep it\\'s \"pratap#3367\"\\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "[@pratapsimha01](/pratapsimha01) can you give me your discord username, we can discuss there?"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "yep..I am up..I am a beginner though lol\\n"
                    }
                ]
            },
            {
                "id": 1827486,
                "content": [
                    {
                        "username": "ed3642dev",
                        "content": "Interesting to see how the fastest solutions bounded the slowest and fastest speeds possible"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "Can anyone help me to understand this test case.\\n[1,1,1,999999999] h = 10\\nMy output : 156250000 \\nExpected output: 142857143\\n\\nbut both the answers are satisfying the condition that koko can eat bananas in h hours."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "JimbeiBIG",
                        "content": "one of the test cases is piles =[312884470] ... poor Koko"
                    },
                    {
                        "username": "surfingcat",
                        "content": "The intuition, that we not only need to find a speed to finish the piles in time `h`, but then continue and find the minimum speed using binary search, is important here. "
                    },
                    {
                        "username": "abhishek_2603",
                        "content": " class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max=0;\\n         \\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int l=1,r=max,min=max;\\n        while(l<=r)\\n        {\\n            int mid=(int)(l+r)/2;\\n            int c=0;\\n            for(int i : piles)\\n            {\\n                c+=(Math.ceil(i/mid));\\n            }\\n            if(c<=h)\\n            {\\n                min=Math.min(mid,min);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n\\nwhy does this not work, I\\'m stuck on this for so so long. Please can someone debug it for me."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "how to decide left and right value??"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "My code didn\\'t run 64th test case .Can any one help me??\\nhere is my code..\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      sort(piles.begin(),piles.end());\\n      int s =piles.size()-1;\\n      int low = 1;\\n      int high = piles[s];\\n      int flag,j,sum=0,mid;\\n      while(low<=high)\\n      {\\n         sum=0;\\n        mid=(high+low)/2;\\n        for( j=0; j<=s;j++)\\n        {\\n         \\n          if(piles[j]%mid==0)\\n          {\\n              sum =sum + piles[j]/mid;\\n          }\\n          else{\\n            sum =sum + piles[j]/mid +1;\\n          }\\n        }\\n       \\n        if(sum==h)\\n        {\\n          flag = mid;\\n          break;\\n        }\\n        else if(sum<h)\\n        {\\n          high =mid-1;\\n        }\\n        else{\\n          low = mid+1;\\n        }\\n       \\n      }\\n      return flag;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "MY code pass 4th  test case piles =[312884470]  h =312884469  but fails at test case 64  piles =[312884470]\\nh =312884469 why is this happening....."
                    },
                    {
                        "username": "jems1123",
                        "content": "koko isn\\'t honest at all \\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "anyone up to practice together and take mock interviews?"
                    },
                    {
                        "username": "cennav",
                        "content": "I\\'m interesteddddd"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "I am Intrested for Mock Interviews \\n"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@bits_magma](/bits_magma) yep it\\'s \"pratap#3367\"\\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "[@pratapsimha01](/pratapsimha01) can you give me your discord username, we can discuss there?"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "yep..I am up..I am a beginner though lol\\n"
                    }
                ]
            },
            {
                "id": 1827351,
                "content": [
                    {
                        "username": "ed3642dev",
                        "content": "Interesting to see how the fastest solutions bounded the slowest and fastest speeds possible"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "Can anyone help me to understand this test case.\\n[1,1,1,999999999] h = 10\\nMy output : 156250000 \\nExpected output: 142857143\\n\\nbut both the answers are satisfying the condition that koko can eat bananas in h hours."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "JimbeiBIG",
                        "content": "one of the test cases is piles =[312884470] ... poor Koko"
                    },
                    {
                        "username": "surfingcat",
                        "content": "The intuition, that we not only need to find a speed to finish the piles in time `h`, but then continue and find the minimum speed using binary search, is important here. "
                    },
                    {
                        "username": "abhishek_2603",
                        "content": " class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max=0;\\n         \\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int l=1,r=max,min=max;\\n        while(l<=r)\\n        {\\n            int mid=(int)(l+r)/2;\\n            int c=0;\\n            for(int i : piles)\\n            {\\n                c+=(Math.ceil(i/mid));\\n            }\\n            if(c<=h)\\n            {\\n                min=Math.min(mid,min);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n\\nwhy does this not work, I\\'m stuck on this for so so long. Please can someone debug it for me."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "how to decide left and right value??"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "My code didn\\'t run 64th test case .Can any one help me??\\nhere is my code..\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      sort(piles.begin(),piles.end());\\n      int s =piles.size()-1;\\n      int low = 1;\\n      int high = piles[s];\\n      int flag,j,sum=0,mid;\\n      while(low<=high)\\n      {\\n         sum=0;\\n        mid=(high+low)/2;\\n        for( j=0; j<=s;j++)\\n        {\\n         \\n          if(piles[j]%mid==0)\\n          {\\n              sum =sum + piles[j]/mid;\\n          }\\n          else{\\n            sum =sum + piles[j]/mid +1;\\n          }\\n        }\\n       \\n        if(sum==h)\\n        {\\n          flag = mid;\\n          break;\\n        }\\n        else if(sum<h)\\n        {\\n          high =mid-1;\\n        }\\n        else{\\n          low = mid+1;\\n        }\\n       \\n      }\\n      return flag;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "MY code pass 4th  test case piles =[312884470]  h =312884469  but fails at test case 64  piles =[312884470]\\nh =312884469 why is this happening....."
                    },
                    {
                        "username": "jems1123",
                        "content": "koko isn\\'t honest at all \\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "anyone up to practice together and take mock interviews?"
                    },
                    {
                        "username": "cennav",
                        "content": "I\\'m interesteddddd"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "I am Intrested for Mock Interviews \\n"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@bits_magma](/bits_magma) yep it\\'s \"pratap#3367\"\\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "[@pratapsimha01](/pratapsimha01) can you give me your discord username, we can discuss there?"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "yep..I am up..I am a beginner though lol\\n"
                    }
                ]
            },
            {
                "id": 1827122,
                "content": [
                    {
                        "username": "ahmadheshamzaki",
                        "content": "My solution passed all test cases except for one and I can't figure out what the problem is. Any ideas?\n```python\nfrom math import ceil\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        low, high = 1, max(piles)\n        while low <= high:\n            k = (low + high) // 2\n            \n            time = sum(ceil(pile / k) for pile in piles)\n            if time < h:\n                high = k - 1\n            elif time > h:\n                low = k + 1\n            else:\n                return k\n\n        return low\n```\n\nThis is the failed test case:\n\n```\n[1,1,1,999999999]\n10\n```"
                    },
                    {
                        "username": "cpatonn",
                        "content": "KoKo is not a money, KoKo is a pig who eats 1000000000 bananas in a day"
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "For some reason whenever I think about doing leetcode problems this problem pops in my head lol"
                    },
                    {
                        "username": "jasbatra01",
                        "content": " `time+=(piles[i]-1)/k +1; ` //works\\n `ceil(pile[i]/k)`  //giving test case error in one of the test cases.\\nwhy???"
                    },
                    {
                        "username": "serkora",
                        "content": "Because pile[i]/k produces an integer that you are then trying to ceil (which does nothing, of course, since it\\'s too late). You need to cast one of them to double/float so that the division result is a floating point number which you can then ceil to get the next higher integer."
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "Haha the comments here are gold!"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Week \\njust leetcode didn\\'t select total questions to be in this week to be logn (log7)"
                    },
                    {
                        "username": "vidhanshu",
                        "content": "Can any one please explain me first test case?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The answer is eating speed k = 4 bananas per hour.\nKoko eats the pile of 3 bananas in 1 hour.\nKoko eats the pile of 6 bananas in 2 hour.\nKoko eats the pile of 7 bananas in 2 hour.\nKoko eats the pile of 11 bananas in 3 hour.\nTotal time = 1 + 2 + 2 + 3 = 8 hours.\nThat's the slowest speed Koko can have to finish all bananas in 8 hours."
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Similar question again :p"
                    },
                    {
                        "username": "hugobrancowb",
                        "content": "anyone else having memory limit exceed with Scala solution?"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "You don\\'t need extra memory for this "
                    },
                    {
                        "username": "juleshwar",
                        "content": "Ayo! Hol\\u2019 up!\\nI\\u2019ve seen this solution pattern before"
                    }
                ]
            },
            {
                "id": 1826635,
                "content": [
                    {
                        "username": "ahmadheshamzaki",
                        "content": "My solution passed all test cases except for one and I can't figure out what the problem is. Any ideas?\n```python\nfrom math import ceil\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        low, high = 1, max(piles)\n        while low <= high:\n            k = (low + high) // 2\n            \n            time = sum(ceil(pile / k) for pile in piles)\n            if time < h:\n                high = k - 1\n            elif time > h:\n                low = k + 1\n            else:\n                return k\n\n        return low\n```\n\nThis is the failed test case:\n\n```\n[1,1,1,999999999]\n10\n```"
                    },
                    {
                        "username": "cpatonn",
                        "content": "KoKo is not a money, KoKo is a pig who eats 1000000000 bananas in a day"
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "For some reason whenever I think about doing leetcode problems this problem pops in my head lol"
                    },
                    {
                        "username": "jasbatra01",
                        "content": " `time+=(piles[i]-1)/k +1; ` //works\\n `ceil(pile[i]/k)`  //giving test case error in one of the test cases.\\nwhy???"
                    },
                    {
                        "username": "serkora",
                        "content": "Because pile[i]/k produces an integer that you are then trying to ceil (which does nothing, of course, since it\\'s too late). You need to cast one of them to double/float so that the division result is a floating point number which you can then ceil to get the next higher integer."
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "Haha the comments here are gold!"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Week \\njust leetcode didn\\'t select total questions to be in this week to be logn (log7)"
                    },
                    {
                        "username": "vidhanshu",
                        "content": "Can any one please explain me first test case?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The answer is eating speed k = 4 bananas per hour.\nKoko eats the pile of 3 bananas in 1 hour.\nKoko eats the pile of 6 bananas in 2 hour.\nKoko eats the pile of 7 bananas in 2 hour.\nKoko eats the pile of 11 bananas in 3 hour.\nTotal time = 1 + 2 + 2 + 3 = 8 hours.\nThat's the slowest speed Koko can have to finish all bananas in 8 hours."
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Similar question again :p"
                    },
                    {
                        "username": "hugobrancowb",
                        "content": "anyone else having memory limit exceed with Scala solution?"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "You don\\'t need extra memory for this "
                    },
                    {
                        "username": "juleshwar",
                        "content": "Ayo! Hol\\u2019 up!\\nI\\u2019ve seen this solution pattern before"
                    }
                ]
            },
            {
                "id": 1826607,
                "content": [
                    {
                        "username": "ahmadheshamzaki",
                        "content": "My solution passed all test cases except for one and I can't figure out what the problem is. Any ideas?\n```python\nfrom math import ceil\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        low, high = 1, max(piles)\n        while low <= high:\n            k = (low + high) // 2\n            \n            time = sum(ceil(pile / k) for pile in piles)\n            if time < h:\n                high = k - 1\n            elif time > h:\n                low = k + 1\n            else:\n                return k\n\n        return low\n```\n\nThis is the failed test case:\n\n```\n[1,1,1,999999999]\n10\n```"
                    },
                    {
                        "username": "cpatonn",
                        "content": "KoKo is not a money, KoKo is a pig who eats 1000000000 bananas in a day"
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "For some reason whenever I think about doing leetcode problems this problem pops in my head lol"
                    },
                    {
                        "username": "jasbatra01",
                        "content": " `time+=(piles[i]-1)/k +1; ` //works\\n `ceil(pile[i]/k)`  //giving test case error in one of the test cases.\\nwhy???"
                    },
                    {
                        "username": "serkora",
                        "content": "Because pile[i]/k produces an integer that you are then trying to ceil (which does nothing, of course, since it\\'s too late). You need to cast one of them to double/float so that the division result is a floating point number which you can then ceil to get the next higher integer."
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "Haha the comments here are gold!"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Week \\njust leetcode didn\\'t select total questions to be in this week to be logn (log7)"
                    },
                    {
                        "username": "vidhanshu",
                        "content": "Can any one please explain me first test case?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The answer is eating speed k = 4 bananas per hour.\nKoko eats the pile of 3 bananas in 1 hour.\nKoko eats the pile of 6 bananas in 2 hour.\nKoko eats the pile of 7 bananas in 2 hour.\nKoko eats the pile of 11 bananas in 3 hour.\nTotal time = 1 + 2 + 2 + 3 = 8 hours.\nThat's the slowest speed Koko can have to finish all bananas in 8 hours."
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Similar question again :p"
                    },
                    {
                        "username": "hugobrancowb",
                        "content": "anyone else having memory limit exceed with Scala solution?"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "You don\\'t need extra memory for this "
                    },
                    {
                        "username": "juleshwar",
                        "content": "Ayo! Hol\\u2019 up!\\nI\\u2019ve seen this solution pattern before"
                    }
                ]
            },
            {
                "id": 1826500,
                "content": [
                    {
                        "username": "ahmadheshamzaki",
                        "content": "My solution passed all test cases except for one and I can't figure out what the problem is. Any ideas?\n```python\nfrom math import ceil\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        low, high = 1, max(piles)\n        while low <= high:\n            k = (low + high) // 2\n            \n            time = sum(ceil(pile / k) for pile in piles)\n            if time < h:\n                high = k - 1\n            elif time > h:\n                low = k + 1\n            else:\n                return k\n\n        return low\n```\n\nThis is the failed test case:\n\n```\n[1,1,1,999999999]\n10\n```"
                    },
                    {
                        "username": "cpatonn",
                        "content": "KoKo is not a money, KoKo is a pig who eats 1000000000 bananas in a day"
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "For some reason whenever I think about doing leetcode problems this problem pops in my head lol"
                    },
                    {
                        "username": "jasbatra01",
                        "content": " `time+=(piles[i]-1)/k +1; ` //works\\n `ceil(pile[i]/k)`  //giving test case error in one of the test cases.\\nwhy???"
                    },
                    {
                        "username": "serkora",
                        "content": "Because pile[i]/k produces an integer that you are then trying to ceil (which does nothing, of course, since it\\'s too late). You need to cast one of them to double/float so that the division result is a floating point number which you can then ceil to get the next higher integer."
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "Haha the comments here are gold!"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Week \\njust leetcode didn\\'t select total questions to be in this week to be logn (log7)"
                    },
                    {
                        "username": "vidhanshu",
                        "content": "Can any one please explain me first test case?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The answer is eating speed k = 4 bananas per hour.\nKoko eats the pile of 3 bananas in 1 hour.\nKoko eats the pile of 6 bananas in 2 hour.\nKoko eats the pile of 7 bananas in 2 hour.\nKoko eats the pile of 11 bananas in 3 hour.\nTotal time = 1 + 2 + 2 + 3 = 8 hours.\nThat's the slowest speed Koko can have to finish all bananas in 8 hours."
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Similar question again :p"
                    },
                    {
                        "username": "hugobrancowb",
                        "content": "anyone else having memory limit exceed with Scala solution?"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "You don\\'t need extra memory for this "
                    },
                    {
                        "username": "juleshwar",
                        "content": "Ayo! Hol\\u2019 up!\\nI\\u2019ve seen this solution pattern before"
                    }
                ]
            },
            {
                "id": 1826449,
                "content": [
                    {
                        "username": "ahmadheshamzaki",
                        "content": "My solution passed all test cases except for one and I can't figure out what the problem is. Any ideas?\n```python\nfrom math import ceil\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        low, high = 1, max(piles)\n        while low <= high:\n            k = (low + high) // 2\n            \n            time = sum(ceil(pile / k) for pile in piles)\n            if time < h:\n                high = k - 1\n            elif time > h:\n                low = k + 1\n            else:\n                return k\n\n        return low\n```\n\nThis is the failed test case:\n\n```\n[1,1,1,999999999]\n10\n```"
                    },
                    {
                        "username": "cpatonn",
                        "content": "KoKo is not a money, KoKo is a pig who eats 1000000000 bananas in a day"
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "For some reason whenever I think about doing leetcode problems this problem pops in my head lol"
                    },
                    {
                        "username": "jasbatra01",
                        "content": " `time+=(piles[i]-1)/k +1; ` //works\\n `ceil(pile[i]/k)`  //giving test case error in one of the test cases.\\nwhy???"
                    },
                    {
                        "username": "serkora",
                        "content": "Because pile[i]/k produces an integer that you are then trying to ceil (which does nothing, of course, since it\\'s too late). You need to cast one of them to double/float so that the division result is a floating point number which you can then ceil to get the next higher integer."
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "Haha the comments here are gold!"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Week \\njust leetcode didn\\'t select total questions to be in this week to be logn (log7)"
                    },
                    {
                        "username": "vidhanshu",
                        "content": "Can any one please explain me first test case?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The answer is eating speed k = 4 bananas per hour.\nKoko eats the pile of 3 bananas in 1 hour.\nKoko eats the pile of 6 bananas in 2 hour.\nKoko eats the pile of 7 bananas in 2 hour.\nKoko eats the pile of 11 bananas in 3 hour.\nTotal time = 1 + 2 + 2 + 3 = 8 hours.\nThat's the slowest speed Koko can have to finish all bananas in 8 hours."
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Similar question again :p"
                    },
                    {
                        "username": "hugobrancowb",
                        "content": "anyone else having memory limit exceed with Scala solution?"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "You don\\'t need extra memory for this "
                    },
                    {
                        "username": "juleshwar",
                        "content": "Ayo! Hol\\u2019 up!\\nI\\u2019ve seen this solution pattern before"
                    }
                ]
            },
            {
                "id": 1826412,
                "content": [
                    {
                        "username": "ahmadheshamzaki",
                        "content": "My solution passed all test cases except for one and I can't figure out what the problem is. Any ideas?\n```python\nfrom math import ceil\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        low, high = 1, max(piles)\n        while low <= high:\n            k = (low + high) // 2\n            \n            time = sum(ceil(pile / k) for pile in piles)\n            if time < h:\n                high = k - 1\n            elif time > h:\n                low = k + 1\n            else:\n                return k\n\n        return low\n```\n\nThis is the failed test case:\n\n```\n[1,1,1,999999999]\n10\n```"
                    },
                    {
                        "username": "cpatonn",
                        "content": "KoKo is not a money, KoKo is a pig who eats 1000000000 bananas in a day"
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "For some reason whenever I think about doing leetcode problems this problem pops in my head lol"
                    },
                    {
                        "username": "jasbatra01",
                        "content": " `time+=(piles[i]-1)/k +1; ` //works\\n `ceil(pile[i]/k)`  //giving test case error in one of the test cases.\\nwhy???"
                    },
                    {
                        "username": "serkora",
                        "content": "Because pile[i]/k produces an integer that you are then trying to ceil (which does nothing, of course, since it\\'s too late). You need to cast one of them to double/float so that the division result is a floating point number which you can then ceil to get the next higher integer."
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "Haha the comments here are gold!"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Week \\njust leetcode didn\\'t select total questions to be in this week to be logn (log7)"
                    },
                    {
                        "username": "vidhanshu",
                        "content": "Can any one please explain me first test case?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The answer is eating speed k = 4 bananas per hour.\nKoko eats the pile of 3 bananas in 1 hour.\nKoko eats the pile of 6 bananas in 2 hour.\nKoko eats the pile of 7 bananas in 2 hour.\nKoko eats the pile of 11 bananas in 3 hour.\nTotal time = 1 + 2 + 2 + 3 = 8 hours.\nThat's the slowest speed Koko can have to finish all bananas in 8 hours."
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Similar question again :p"
                    },
                    {
                        "username": "hugobrancowb",
                        "content": "anyone else having memory limit exceed with Scala solution?"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "You don\\'t need extra memory for this "
                    },
                    {
                        "username": "juleshwar",
                        "content": "Ayo! Hol\\u2019 up!\\nI\\u2019ve seen this solution pattern before"
                    }
                ]
            },
            {
                "id": 1826337,
                "content": [
                    {
                        "username": "ahmadheshamzaki",
                        "content": "My solution passed all test cases except for one and I can't figure out what the problem is. Any ideas?\n```python\nfrom math import ceil\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        low, high = 1, max(piles)\n        while low <= high:\n            k = (low + high) // 2\n            \n            time = sum(ceil(pile / k) for pile in piles)\n            if time < h:\n                high = k - 1\n            elif time > h:\n                low = k + 1\n            else:\n                return k\n\n        return low\n```\n\nThis is the failed test case:\n\n```\n[1,1,1,999999999]\n10\n```"
                    },
                    {
                        "username": "cpatonn",
                        "content": "KoKo is not a money, KoKo is a pig who eats 1000000000 bananas in a day"
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "For some reason whenever I think about doing leetcode problems this problem pops in my head lol"
                    },
                    {
                        "username": "jasbatra01",
                        "content": " `time+=(piles[i]-1)/k +1; ` //works\\n `ceil(pile[i]/k)`  //giving test case error in one of the test cases.\\nwhy???"
                    },
                    {
                        "username": "serkora",
                        "content": "Because pile[i]/k produces an integer that you are then trying to ceil (which does nothing, of course, since it\\'s too late). You need to cast one of them to double/float so that the division result is a floating point number which you can then ceil to get the next higher integer."
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "Haha the comments here are gold!"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Week \\njust leetcode didn\\'t select total questions to be in this week to be logn (log7)"
                    },
                    {
                        "username": "vidhanshu",
                        "content": "Can any one please explain me first test case?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The answer is eating speed k = 4 bananas per hour.\nKoko eats the pile of 3 bananas in 1 hour.\nKoko eats the pile of 6 bananas in 2 hour.\nKoko eats the pile of 7 bananas in 2 hour.\nKoko eats the pile of 11 bananas in 3 hour.\nTotal time = 1 + 2 + 2 + 3 = 8 hours.\nThat's the slowest speed Koko can have to finish all bananas in 8 hours."
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Similar question again :p"
                    },
                    {
                        "username": "hugobrancowb",
                        "content": "anyone else having memory limit exceed with Scala solution?"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "You don\\'t need extra memory for this "
                    },
                    {
                        "username": "juleshwar",
                        "content": "Ayo! Hol\\u2019 up!\\nI\\u2019ve seen this solution pattern before"
                    }
                ]
            },
            {
                "id": 1826330,
                "content": [
                    {
                        "username": "ahmadheshamzaki",
                        "content": "My solution passed all test cases except for one and I can't figure out what the problem is. Any ideas?\n```python\nfrom math import ceil\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        low, high = 1, max(piles)\n        while low <= high:\n            k = (low + high) // 2\n            \n            time = sum(ceil(pile / k) for pile in piles)\n            if time < h:\n                high = k - 1\n            elif time > h:\n                low = k + 1\n            else:\n                return k\n\n        return low\n```\n\nThis is the failed test case:\n\n```\n[1,1,1,999999999]\n10\n```"
                    },
                    {
                        "username": "cpatonn",
                        "content": "KoKo is not a money, KoKo is a pig who eats 1000000000 bananas in a day"
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "For some reason whenever I think about doing leetcode problems this problem pops in my head lol"
                    },
                    {
                        "username": "jasbatra01",
                        "content": " `time+=(piles[i]-1)/k +1; ` //works\\n `ceil(pile[i]/k)`  //giving test case error in one of the test cases.\\nwhy???"
                    },
                    {
                        "username": "serkora",
                        "content": "Because pile[i]/k produces an integer that you are then trying to ceil (which does nothing, of course, since it\\'s too late). You need to cast one of them to double/float so that the division result is a floating point number which you can then ceil to get the next higher integer."
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "Haha the comments here are gold!"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Week \\njust leetcode didn\\'t select total questions to be in this week to be logn (log7)"
                    },
                    {
                        "username": "vidhanshu",
                        "content": "Can any one please explain me first test case?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The answer is eating speed k = 4 bananas per hour.\nKoko eats the pile of 3 bananas in 1 hour.\nKoko eats the pile of 6 bananas in 2 hour.\nKoko eats the pile of 7 bananas in 2 hour.\nKoko eats the pile of 11 bananas in 3 hour.\nTotal time = 1 + 2 + 2 + 3 = 8 hours.\nThat's the slowest speed Koko can have to finish all bananas in 8 hours."
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Similar question again :p"
                    },
                    {
                        "username": "hugobrancowb",
                        "content": "anyone else having memory limit exceed with Scala solution?"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "You don\\'t need extra memory for this "
                    },
                    {
                        "username": "juleshwar",
                        "content": "Ayo! Hol\\u2019 up!\\nI\\u2019ve seen this solution pattern before"
                    }
                ]
            },
            {
                "id": 1826293,
                "content": [
                    {
                        "username": "ahmadheshamzaki",
                        "content": "My solution passed all test cases except for one and I can't figure out what the problem is. Any ideas?\n```python\nfrom math import ceil\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        low, high = 1, max(piles)\n        while low <= high:\n            k = (low + high) // 2\n            \n            time = sum(ceil(pile / k) for pile in piles)\n            if time < h:\n                high = k - 1\n            elif time > h:\n                low = k + 1\n            else:\n                return k\n\n        return low\n```\n\nThis is the failed test case:\n\n```\n[1,1,1,999999999]\n10\n```"
                    },
                    {
                        "username": "cpatonn",
                        "content": "KoKo is not a money, KoKo is a pig who eats 1000000000 bananas in a day"
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "For some reason whenever I think about doing leetcode problems this problem pops in my head lol"
                    },
                    {
                        "username": "jasbatra01",
                        "content": " `time+=(piles[i]-1)/k +1; ` //works\\n `ceil(pile[i]/k)`  //giving test case error in one of the test cases.\\nwhy???"
                    },
                    {
                        "username": "serkora",
                        "content": "Because pile[i]/k produces an integer that you are then trying to ceil (which does nothing, of course, since it\\'s too late). You need to cast one of them to double/float so that the division result is a floating point number which you can then ceil to get the next higher integer."
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "Haha the comments here are gold!"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Week \\njust leetcode didn\\'t select total questions to be in this week to be logn (log7)"
                    },
                    {
                        "username": "vidhanshu",
                        "content": "Can any one please explain me first test case?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The answer is eating speed k = 4 bananas per hour.\nKoko eats the pile of 3 bananas in 1 hour.\nKoko eats the pile of 6 bananas in 2 hour.\nKoko eats the pile of 7 bananas in 2 hour.\nKoko eats the pile of 11 bananas in 3 hour.\nTotal time = 1 + 2 + 2 + 3 = 8 hours.\nThat's the slowest speed Koko can have to finish all bananas in 8 hours."
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Similar question again :p"
                    },
                    {
                        "username": "hugobrancowb",
                        "content": "anyone else having memory limit exceed with Scala solution?"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "You don\\'t need extra memory for this "
                    },
                    {
                        "username": "juleshwar",
                        "content": "Ayo! Hol\\u2019 up!\\nI\\u2019ve seen this solution pattern before"
                    }
                ]
            },
            {
                "id": 1826274,
                "content": [
                    {
                        "username": "ahmadheshamzaki",
                        "content": "My solution passed all test cases except for one and I can't figure out what the problem is. Any ideas?\n```python\nfrom math import ceil\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        low, high = 1, max(piles)\n        while low <= high:\n            k = (low + high) // 2\n            \n            time = sum(ceil(pile / k) for pile in piles)\n            if time < h:\n                high = k - 1\n            elif time > h:\n                low = k + 1\n            else:\n                return k\n\n        return low\n```\n\nThis is the failed test case:\n\n```\n[1,1,1,999999999]\n10\n```"
                    },
                    {
                        "username": "cpatonn",
                        "content": "KoKo is not a money, KoKo is a pig who eats 1000000000 bananas in a day"
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "For some reason whenever I think about doing leetcode problems this problem pops in my head lol"
                    },
                    {
                        "username": "jasbatra01",
                        "content": " `time+=(piles[i]-1)/k +1; ` //works\\n `ceil(pile[i]/k)`  //giving test case error in one of the test cases.\\nwhy???"
                    },
                    {
                        "username": "serkora",
                        "content": "Because pile[i]/k produces an integer that you are then trying to ceil (which does nothing, of course, since it\\'s too late). You need to cast one of them to double/float so that the division result is a floating point number which you can then ceil to get the next higher integer."
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "Haha the comments here are gold!"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Week \\njust leetcode didn\\'t select total questions to be in this week to be logn (log7)"
                    },
                    {
                        "username": "vidhanshu",
                        "content": "Can any one please explain me first test case?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The answer is eating speed k = 4 bananas per hour.\nKoko eats the pile of 3 bananas in 1 hour.\nKoko eats the pile of 6 bananas in 2 hour.\nKoko eats the pile of 7 bananas in 2 hour.\nKoko eats the pile of 11 bananas in 3 hour.\nTotal time = 1 + 2 + 2 + 3 = 8 hours.\nThat's the slowest speed Koko can have to finish all bananas in 8 hours."
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Similar question again :p"
                    },
                    {
                        "username": "hugobrancowb",
                        "content": "anyone else having memory limit exceed with Scala solution?"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "You don\\'t need extra memory for this "
                    },
                    {
                        "username": "juleshwar",
                        "content": "Ayo! Hol\\u2019 up!\\nI\\u2019ve seen this solution pattern before"
                    }
                ]
            },
            {
                "id": 1826251,
                "content": [
                    {
                        "username": "LTDigor",
                        "content": "This is literally the previous daily task...\\nHmm, monke"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "Koko might be immortal"
                    },
                    {
                        "username": "jackbid",
                        "content": "**Me:** How many binary search questions will there be this month?\\n**Leetcode:** Yes."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Someone need to fire those guards for keeping Koko unattended for so long !!!. \\n\\nAfter almost 3hr of thinking just to find my code had only 3 lines of ceil which where in solutions."
                    },
                    {
                        "username": "Anshuman__",
                        "content": "Can someone explain this problem, I don\\'t understand what exactly needs to be done here"
                    },
                    {
                        "username": "jolswlf",
                        "content": "How slow can koko eat bananas and still eat them all before time runs out. She can\\'t eat from multiple piles in the same hour. It\\'s very similar (almost identical) to yesterday\\'s problem. "
                    },
                    {
                        "username": "pokaChika",
                        "content": "I am horrified by the amount of bananas Koko is eating!"
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": "Koko likes to eat bananas and there are many piles of bananas with different numbers of bananas in them. The guards are away for some time and Koko wants to eat all the bananas before they come back. Koko can eat a certain number of bananas per hour, but she doesn\\'t want to eat too fast. We need to find the smallest number of bananas she can eat each hour so that she can finish all the bananas before the guards return.\\n\\nDuring each hour, Koko chooses a pile of bananas and eats some of them. If there are still bananas left in the pile after she\\'s eaten some, she\\'ll come back to it later. If the pile is empty, she moves on to the next pile.\\n\\nThe question is asking us to find the smallest number of bananas Koko can eat per hour to finish all the bananas before the guards return."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "if you have the problem of TLE in checking, consider doing this:\\n```\\nh -= (a[i] + x - 1) / x;\\na[i] -= x * ((a[i] + x - 1) / x);\\n```"
                    },
                    {
                        "username": "jolswlf",
                        "content": "so basically yesterdays problem but explained much better"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "Isn\\'t it the same task as yesterday"
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "yes, it was also solved using binary search "
                    }
                ]
            },
            {
                "id": 1826229,
                "content": [
                    {
                        "username": "LTDigor",
                        "content": "This is literally the previous daily task...\\nHmm, monke"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "Koko might be immortal"
                    },
                    {
                        "username": "jackbid",
                        "content": "**Me:** How many binary search questions will there be this month?\\n**Leetcode:** Yes."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Someone need to fire those guards for keeping Koko unattended for so long !!!. \\n\\nAfter almost 3hr of thinking just to find my code had only 3 lines of ceil which where in solutions."
                    },
                    {
                        "username": "Anshuman__",
                        "content": "Can someone explain this problem, I don\\'t understand what exactly needs to be done here"
                    },
                    {
                        "username": "jolswlf",
                        "content": "How slow can koko eat bananas and still eat them all before time runs out. She can\\'t eat from multiple piles in the same hour. It\\'s very similar (almost identical) to yesterday\\'s problem. "
                    },
                    {
                        "username": "pokaChika",
                        "content": "I am horrified by the amount of bananas Koko is eating!"
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": "Koko likes to eat bananas and there are many piles of bananas with different numbers of bananas in them. The guards are away for some time and Koko wants to eat all the bananas before they come back. Koko can eat a certain number of bananas per hour, but she doesn\\'t want to eat too fast. We need to find the smallest number of bananas she can eat each hour so that she can finish all the bananas before the guards return.\\n\\nDuring each hour, Koko chooses a pile of bananas and eats some of them. If there are still bananas left in the pile after she\\'s eaten some, she\\'ll come back to it later. If the pile is empty, she moves on to the next pile.\\n\\nThe question is asking us to find the smallest number of bananas Koko can eat per hour to finish all the bananas before the guards return."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "if you have the problem of TLE in checking, consider doing this:\\n```\\nh -= (a[i] + x - 1) / x;\\na[i] -= x * ((a[i] + x - 1) / x);\\n```"
                    },
                    {
                        "username": "jolswlf",
                        "content": "so basically yesterdays problem but explained much better"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "Isn\\'t it the same task as yesterday"
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "yes, it was also solved using binary search "
                    }
                ]
            },
            {
                "id": 1826211,
                "content": [
                    {
                        "username": "LTDigor",
                        "content": "This is literally the previous daily task...\\nHmm, monke"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "Koko might be immortal"
                    },
                    {
                        "username": "jackbid",
                        "content": "**Me:** How many binary search questions will there be this month?\\n**Leetcode:** Yes."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Someone need to fire those guards for keeping Koko unattended for so long !!!. \\n\\nAfter almost 3hr of thinking just to find my code had only 3 lines of ceil which where in solutions."
                    },
                    {
                        "username": "Anshuman__",
                        "content": "Can someone explain this problem, I don\\'t understand what exactly needs to be done here"
                    },
                    {
                        "username": "jolswlf",
                        "content": "How slow can koko eat bananas and still eat them all before time runs out. She can\\'t eat from multiple piles in the same hour. It\\'s very similar (almost identical) to yesterday\\'s problem. "
                    },
                    {
                        "username": "pokaChika",
                        "content": "I am horrified by the amount of bananas Koko is eating!"
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": "Koko likes to eat bananas and there are many piles of bananas with different numbers of bananas in them. The guards are away for some time and Koko wants to eat all the bananas before they come back. Koko can eat a certain number of bananas per hour, but she doesn\\'t want to eat too fast. We need to find the smallest number of bananas she can eat each hour so that she can finish all the bananas before the guards return.\\n\\nDuring each hour, Koko chooses a pile of bananas and eats some of them. If there are still bananas left in the pile after she\\'s eaten some, she\\'ll come back to it later. If the pile is empty, she moves on to the next pile.\\n\\nThe question is asking us to find the smallest number of bananas Koko can eat per hour to finish all the bananas before the guards return."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "if you have the problem of TLE in checking, consider doing this:\\n```\\nh -= (a[i] + x - 1) / x;\\na[i] -= x * ((a[i] + x - 1) / x);\\n```"
                    },
                    {
                        "username": "jolswlf",
                        "content": "so basically yesterdays problem but explained much better"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "Isn\\'t it the same task as yesterday"
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "yes, it was also solved using binary search "
                    }
                ]
            },
            {
                "id": 1826144,
                "content": [
                    {
                        "username": "LTDigor",
                        "content": "This is literally the previous daily task...\\nHmm, monke"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "Koko might be immortal"
                    },
                    {
                        "username": "jackbid",
                        "content": "**Me:** How many binary search questions will there be this month?\\n**Leetcode:** Yes."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Someone need to fire those guards for keeping Koko unattended for so long !!!. \\n\\nAfter almost 3hr of thinking just to find my code had only 3 lines of ceil which where in solutions."
                    },
                    {
                        "username": "Anshuman__",
                        "content": "Can someone explain this problem, I don\\'t understand what exactly needs to be done here"
                    },
                    {
                        "username": "jolswlf",
                        "content": "How slow can koko eat bananas and still eat them all before time runs out. She can\\'t eat from multiple piles in the same hour. It\\'s very similar (almost identical) to yesterday\\'s problem. "
                    },
                    {
                        "username": "pokaChika",
                        "content": "I am horrified by the amount of bananas Koko is eating!"
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": "Koko likes to eat bananas and there are many piles of bananas with different numbers of bananas in them. The guards are away for some time and Koko wants to eat all the bananas before they come back. Koko can eat a certain number of bananas per hour, but she doesn\\'t want to eat too fast. We need to find the smallest number of bananas she can eat each hour so that she can finish all the bananas before the guards return.\\n\\nDuring each hour, Koko chooses a pile of bananas and eats some of them. If there are still bananas left in the pile after she\\'s eaten some, she\\'ll come back to it later. If the pile is empty, she moves on to the next pile.\\n\\nThe question is asking us to find the smallest number of bananas Koko can eat per hour to finish all the bananas before the guards return."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "if you have the problem of TLE in checking, consider doing this:\\n```\\nh -= (a[i] + x - 1) / x;\\na[i] -= x * ((a[i] + x - 1) / x);\\n```"
                    },
                    {
                        "username": "jolswlf",
                        "content": "so basically yesterdays problem but explained much better"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "Isn\\'t it the same task as yesterday"
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "yes, it was also solved using binary search "
                    }
                ]
            },
            {
                "id": 1826130,
                "content": [
                    {
                        "username": "LTDigor",
                        "content": "This is literally the previous daily task...\\nHmm, monke"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "Koko might be immortal"
                    },
                    {
                        "username": "jackbid",
                        "content": "**Me:** How many binary search questions will there be this month?\\n**Leetcode:** Yes."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Someone need to fire those guards for keeping Koko unattended for so long !!!. \\n\\nAfter almost 3hr of thinking just to find my code had only 3 lines of ceil which where in solutions."
                    },
                    {
                        "username": "Anshuman__",
                        "content": "Can someone explain this problem, I don\\'t understand what exactly needs to be done here"
                    },
                    {
                        "username": "jolswlf",
                        "content": "How slow can koko eat bananas and still eat them all before time runs out. She can\\'t eat from multiple piles in the same hour. It\\'s very similar (almost identical) to yesterday\\'s problem. "
                    },
                    {
                        "username": "pokaChika",
                        "content": "I am horrified by the amount of bananas Koko is eating!"
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": "Koko likes to eat bananas and there are many piles of bananas with different numbers of bananas in them. The guards are away for some time and Koko wants to eat all the bananas before they come back. Koko can eat a certain number of bananas per hour, but she doesn\\'t want to eat too fast. We need to find the smallest number of bananas she can eat each hour so that she can finish all the bananas before the guards return.\\n\\nDuring each hour, Koko chooses a pile of bananas and eats some of them. If there are still bananas left in the pile after she\\'s eaten some, she\\'ll come back to it later. If the pile is empty, she moves on to the next pile.\\n\\nThe question is asking us to find the smallest number of bananas Koko can eat per hour to finish all the bananas before the guards return."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "if you have the problem of TLE in checking, consider doing this:\\n```\\nh -= (a[i] + x - 1) / x;\\na[i] -= x * ((a[i] + x - 1) / x);\\n```"
                    },
                    {
                        "username": "jolswlf",
                        "content": "so basically yesterdays problem but explained much better"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "Isn\\'t it the same task as yesterday"
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "yes, it was also solved using binary search "
                    }
                ]
            },
            {
                "id": 1826109,
                "content": [
                    {
                        "username": "LTDigor",
                        "content": "This is literally the previous daily task...\\nHmm, monke"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "Koko might be immortal"
                    },
                    {
                        "username": "jackbid",
                        "content": "**Me:** How many binary search questions will there be this month?\\n**Leetcode:** Yes."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Someone need to fire those guards for keeping Koko unattended for so long !!!. \\n\\nAfter almost 3hr of thinking just to find my code had only 3 lines of ceil which where in solutions."
                    },
                    {
                        "username": "Anshuman__",
                        "content": "Can someone explain this problem, I don\\'t understand what exactly needs to be done here"
                    },
                    {
                        "username": "jolswlf",
                        "content": "How slow can koko eat bananas and still eat them all before time runs out. She can\\'t eat from multiple piles in the same hour. It\\'s very similar (almost identical) to yesterday\\'s problem. "
                    },
                    {
                        "username": "pokaChika",
                        "content": "I am horrified by the amount of bananas Koko is eating!"
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": "Koko likes to eat bananas and there are many piles of bananas with different numbers of bananas in them. The guards are away for some time and Koko wants to eat all the bananas before they come back. Koko can eat a certain number of bananas per hour, but she doesn\\'t want to eat too fast. We need to find the smallest number of bananas she can eat each hour so that she can finish all the bananas before the guards return.\\n\\nDuring each hour, Koko chooses a pile of bananas and eats some of them. If there are still bananas left in the pile after she\\'s eaten some, she\\'ll come back to it later. If the pile is empty, she moves on to the next pile.\\n\\nThe question is asking us to find the smallest number of bananas Koko can eat per hour to finish all the bananas before the guards return."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "if you have the problem of TLE in checking, consider doing this:\\n```\\nh -= (a[i] + x - 1) / x;\\na[i] -= x * ((a[i] + x - 1) / x);\\n```"
                    },
                    {
                        "username": "jolswlf",
                        "content": "so basically yesterdays problem but explained much better"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "Isn\\'t it the same task as yesterday"
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "yes, it was also solved using binary search "
                    }
                ]
            },
            {
                "id": 1826105,
                "content": [
                    {
                        "username": "LTDigor",
                        "content": "This is literally the previous daily task...\\nHmm, monke"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "Koko might be immortal"
                    },
                    {
                        "username": "jackbid",
                        "content": "**Me:** How many binary search questions will there be this month?\\n**Leetcode:** Yes."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Someone need to fire those guards for keeping Koko unattended for so long !!!. \\n\\nAfter almost 3hr of thinking just to find my code had only 3 lines of ceil which where in solutions."
                    },
                    {
                        "username": "Anshuman__",
                        "content": "Can someone explain this problem, I don\\'t understand what exactly needs to be done here"
                    },
                    {
                        "username": "jolswlf",
                        "content": "How slow can koko eat bananas and still eat them all before time runs out. She can\\'t eat from multiple piles in the same hour. It\\'s very similar (almost identical) to yesterday\\'s problem. "
                    },
                    {
                        "username": "pokaChika",
                        "content": "I am horrified by the amount of bananas Koko is eating!"
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": "Koko likes to eat bananas and there are many piles of bananas with different numbers of bananas in them. The guards are away for some time and Koko wants to eat all the bananas before they come back. Koko can eat a certain number of bananas per hour, but she doesn\\'t want to eat too fast. We need to find the smallest number of bananas she can eat each hour so that she can finish all the bananas before the guards return.\\n\\nDuring each hour, Koko chooses a pile of bananas and eats some of them. If there are still bananas left in the pile after she\\'s eaten some, she\\'ll come back to it later. If the pile is empty, she moves on to the next pile.\\n\\nThe question is asking us to find the smallest number of bananas Koko can eat per hour to finish all the bananas before the guards return."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "if you have the problem of TLE in checking, consider doing this:\\n```\\nh -= (a[i] + x - 1) / x;\\na[i] -= x * ((a[i] + x - 1) / x);\\n```"
                    },
                    {
                        "username": "jolswlf",
                        "content": "so basically yesterdays problem but explained much better"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "Isn\\'t it the same task as yesterday"
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "yes, it was also solved using binary search "
                    }
                ]
            },
            {
                "id": 1826097,
                "content": [
                    {
                        "username": "LTDigor",
                        "content": "This is literally the previous daily task...\\nHmm, monke"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "Koko might be immortal"
                    },
                    {
                        "username": "jackbid",
                        "content": "**Me:** How many binary search questions will there be this month?\\n**Leetcode:** Yes."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Someone need to fire those guards for keeping Koko unattended for so long !!!. \\n\\nAfter almost 3hr of thinking just to find my code had only 3 lines of ceil which where in solutions."
                    },
                    {
                        "username": "Anshuman__",
                        "content": "Can someone explain this problem, I don\\'t understand what exactly needs to be done here"
                    },
                    {
                        "username": "jolswlf",
                        "content": "How slow can koko eat bananas and still eat them all before time runs out. She can\\'t eat from multiple piles in the same hour. It\\'s very similar (almost identical) to yesterday\\'s problem. "
                    },
                    {
                        "username": "pokaChika",
                        "content": "I am horrified by the amount of bananas Koko is eating!"
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": "Koko likes to eat bananas and there are many piles of bananas with different numbers of bananas in them. The guards are away for some time and Koko wants to eat all the bananas before they come back. Koko can eat a certain number of bananas per hour, but she doesn\\'t want to eat too fast. We need to find the smallest number of bananas she can eat each hour so that she can finish all the bananas before the guards return.\\n\\nDuring each hour, Koko chooses a pile of bananas and eats some of them. If there are still bananas left in the pile after she\\'s eaten some, she\\'ll come back to it later. If the pile is empty, she moves on to the next pile.\\n\\nThe question is asking us to find the smallest number of bananas Koko can eat per hour to finish all the bananas before the guards return."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "if you have the problem of TLE in checking, consider doing this:\\n```\\nh -= (a[i] + x - 1) / x;\\na[i] -= x * ((a[i] + x - 1) / x);\\n```"
                    },
                    {
                        "username": "jolswlf",
                        "content": "so basically yesterdays problem but explained much better"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "Isn\\'t it the same task as yesterday"
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "yes, it was also solved using binary search "
                    }
                ]
            },
            {
                "id": 1826046,
                "content": [
                    {
                        "username": "LTDigor",
                        "content": "This is literally the previous daily task...\\nHmm, monke"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "Koko might be immortal"
                    },
                    {
                        "username": "jackbid",
                        "content": "**Me:** How many binary search questions will there be this month?\\n**Leetcode:** Yes."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Someone need to fire those guards for keeping Koko unattended for so long !!!. \\n\\nAfter almost 3hr of thinking just to find my code had only 3 lines of ceil which where in solutions."
                    },
                    {
                        "username": "Anshuman__",
                        "content": "Can someone explain this problem, I don\\'t understand what exactly needs to be done here"
                    },
                    {
                        "username": "jolswlf",
                        "content": "How slow can koko eat bananas and still eat them all before time runs out. She can\\'t eat from multiple piles in the same hour. It\\'s very similar (almost identical) to yesterday\\'s problem. "
                    },
                    {
                        "username": "pokaChika",
                        "content": "I am horrified by the amount of bananas Koko is eating!"
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": "Koko likes to eat bananas and there are many piles of bananas with different numbers of bananas in them. The guards are away for some time and Koko wants to eat all the bananas before they come back. Koko can eat a certain number of bananas per hour, but she doesn\\'t want to eat too fast. We need to find the smallest number of bananas she can eat each hour so that she can finish all the bananas before the guards return.\\n\\nDuring each hour, Koko chooses a pile of bananas and eats some of them. If there are still bananas left in the pile after she\\'s eaten some, she\\'ll come back to it later. If the pile is empty, she moves on to the next pile.\\n\\nThe question is asking us to find the smallest number of bananas Koko can eat per hour to finish all the bananas before the guards return."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "if you have the problem of TLE in checking, consider doing this:\\n```\\nh -= (a[i] + x - 1) / x;\\na[i] -= x * ((a[i] + x - 1) / x);\\n```"
                    },
                    {
                        "username": "jolswlf",
                        "content": "so basically yesterdays problem but explained much better"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "Isn\\'t it the same task as yesterday"
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "yes, it was also solved using binary search "
                    }
                ]
            },
            {
                "id": 1826031,
                "content": [
                    {
                        "username": "LTDigor",
                        "content": "This is literally the previous daily task...\\nHmm, monke"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "Koko might be immortal"
                    },
                    {
                        "username": "jackbid",
                        "content": "**Me:** How many binary search questions will there be this month?\\n**Leetcode:** Yes."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Someone need to fire those guards for keeping Koko unattended for so long !!!. \\n\\nAfter almost 3hr of thinking just to find my code had only 3 lines of ceil which where in solutions."
                    },
                    {
                        "username": "Anshuman__",
                        "content": "Can someone explain this problem, I don\\'t understand what exactly needs to be done here"
                    },
                    {
                        "username": "jolswlf",
                        "content": "How slow can koko eat bananas and still eat them all before time runs out. She can\\'t eat from multiple piles in the same hour. It\\'s very similar (almost identical) to yesterday\\'s problem. "
                    },
                    {
                        "username": "pokaChika",
                        "content": "I am horrified by the amount of bananas Koko is eating!"
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": "Koko likes to eat bananas and there are many piles of bananas with different numbers of bananas in them. The guards are away for some time and Koko wants to eat all the bananas before they come back. Koko can eat a certain number of bananas per hour, but she doesn\\'t want to eat too fast. We need to find the smallest number of bananas she can eat each hour so that she can finish all the bananas before the guards return.\\n\\nDuring each hour, Koko chooses a pile of bananas and eats some of them. If there are still bananas left in the pile after she\\'s eaten some, she\\'ll come back to it later. If the pile is empty, she moves on to the next pile.\\n\\nThe question is asking us to find the smallest number of bananas Koko can eat per hour to finish all the bananas before the guards return."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "if you have the problem of TLE in checking, consider doing this:\\n```\\nh -= (a[i] + x - 1) / x;\\na[i] -= x * ((a[i] + x - 1) / x);\\n```"
                    },
                    {
                        "username": "jolswlf",
                        "content": "so basically yesterdays problem but explained much better"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "Isn\\'t it the same task as yesterday"
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "yes, it was also solved using binary search "
                    }
                ]
            },
            {
                "id": 1825936,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "<i> \" Cometh the month of March\n Leetcode goeth crazy with binary search!\""
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The solution to this problem is same as yesterdays one.\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/description/"
                    },
                    {
                        "username": "dumb_me",
                        "content": "koko is like us fr trying to eat all food before siblings come hone XD\\n"
                    },
                    {
                        "username": "cheenu123",
                        "content": "For C++: While calculating feasibility of the k value, use double instead of float for calculating ceil as float will give error at 120/123 testcase due to less precision."
                    },
                    {
                        "username": "bot16111011",
                        "content": "I am having trouble recognizing which approach to use here. My first thought was using the brute force but then after going through the discussion I came to know how to approach this problem using binary search then coding coding was piece of cake.\\nBut question still persist is this right way of solving problems and how could I improve ?"
                    },
                    {
                        "username": "gauravpatyal2702",
                        "content": "Btw happy holi"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Does this question make you go bananas? :))"
                    },
                    {
                        "username": "Weiiitt",
                        "content": "Hi guys, I am a little confused on example 3. Why is the minimum speed 23? from my math, it seems that 19 works as well. since it\\'ll take 2 hours for koko to eat 11 and 4 bananas, she is left with 73 bananas to eat for the next 4 hours. With this, 73/4 is equal to 19 rounded up."
                    },
                    {
                        "username": "djmoore26",
                        "content": "Because of the constraint that once a pile is finished, koko does not start a new pile in the same hour. if k is 19, it would take koko 2 hours each to eat the 3 remaining piles"
                    },
                    {
                        "username": "halfengineer",
                        "content": "120/123 \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\n[1000000000]\\n2\\n"
                    },
                    {
                        "username": "hitendra_singh1729",
                        "content": "Good job leetcode. Making me strong in Binary search."
                    }
                ]
            },
            {
                "id": 1825925,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "<i> \" Cometh the month of March\n Leetcode goeth crazy with binary search!\""
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The solution to this problem is same as yesterdays one.\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/description/"
                    },
                    {
                        "username": "dumb_me",
                        "content": "koko is like us fr trying to eat all food before siblings come hone XD\\n"
                    },
                    {
                        "username": "cheenu123",
                        "content": "For C++: While calculating feasibility of the k value, use double instead of float for calculating ceil as float will give error at 120/123 testcase due to less precision."
                    },
                    {
                        "username": "bot16111011",
                        "content": "I am having trouble recognizing which approach to use here. My first thought was using the brute force but then after going through the discussion I came to know how to approach this problem using binary search then coding coding was piece of cake.\\nBut question still persist is this right way of solving problems and how could I improve ?"
                    },
                    {
                        "username": "gauravpatyal2702",
                        "content": "Btw happy holi"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Does this question make you go bananas? :))"
                    },
                    {
                        "username": "Weiiitt",
                        "content": "Hi guys, I am a little confused on example 3. Why is the minimum speed 23? from my math, it seems that 19 works as well. since it\\'ll take 2 hours for koko to eat 11 and 4 bananas, she is left with 73 bananas to eat for the next 4 hours. With this, 73/4 is equal to 19 rounded up."
                    },
                    {
                        "username": "djmoore26",
                        "content": "Because of the constraint that once a pile is finished, koko does not start a new pile in the same hour. if k is 19, it would take koko 2 hours each to eat the 3 remaining piles"
                    },
                    {
                        "username": "halfengineer",
                        "content": "120/123 \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\n[1000000000]\\n2\\n"
                    },
                    {
                        "username": "hitendra_singh1729",
                        "content": "Good job leetcode. Making me strong in Binary search."
                    }
                ]
            },
            {
                "id": 1825906,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "<i> \" Cometh the month of March\n Leetcode goeth crazy with binary search!\""
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The solution to this problem is same as yesterdays one.\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/description/"
                    },
                    {
                        "username": "dumb_me",
                        "content": "koko is like us fr trying to eat all food before siblings come hone XD\\n"
                    },
                    {
                        "username": "cheenu123",
                        "content": "For C++: While calculating feasibility of the k value, use double instead of float for calculating ceil as float will give error at 120/123 testcase due to less precision."
                    },
                    {
                        "username": "bot16111011",
                        "content": "I am having trouble recognizing which approach to use here. My first thought was using the brute force but then after going through the discussion I came to know how to approach this problem using binary search then coding coding was piece of cake.\\nBut question still persist is this right way of solving problems and how could I improve ?"
                    },
                    {
                        "username": "gauravpatyal2702",
                        "content": "Btw happy holi"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Does this question make you go bananas? :))"
                    },
                    {
                        "username": "Weiiitt",
                        "content": "Hi guys, I am a little confused on example 3. Why is the minimum speed 23? from my math, it seems that 19 works as well. since it\\'ll take 2 hours for koko to eat 11 and 4 bananas, she is left with 73 bananas to eat for the next 4 hours. With this, 73/4 is equal to 19 rounded up."
                    },
                    {
                        "username": "djmoore26",
                        "content": "Because of the constraint that once a pile is finished, koko does not start a new pile in the same hour. if k is 19, it would take koko 2 hours each to eat the 3 remaining piles"
                    },
                    {
                        "username": "halfengineer",
                        "content": "120/123 \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\n[1000000000]\\n2\\n"
                    },
                    {
                        "username": "hitendra_singh1729",
                        "content": "Good job leetcode. Making me strong in Binary search."
                    }
                ]
            },
            {
                "id": 1825905,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "<i> \" Cometh the month of March\n Leetcode goeth crazy with binary search!\""
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The solution to this problem is same as yesterdays one.\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/description/"
                    },
                    {
                        "username": "dumb_me",
                        "content": "koko is like us fr trying to eat all food before siblings come hone XD\\n"
                    },
                    {
                        "username": "cheenu123",
                        "content": "For C++: While calculating feasibility of the k value, use double instead of float for calculating ceil as float will give error at 120/123 testcase due to less precision."
                    },
                    {
                        "username": "bot16111011",
                        "content": "I am having trouble recognizing which approach to use here. My first thought was using the brute force but then after going through the discussion I came to know how to approach this problem using binary search then coding coding was piece of cake.\\nBut question still persist is this right way of solving problems and how could I improve ?"
                    },
                    {
                        "username": "gauravpatyal2702",
                        "content": "Btw happy holi"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Does this question make you go bananas? :))"
                    },
                    {
                        "username": "Weiiitt",
                        "content": "Hi guys, I am a little confused on example 3. Why is the minimum speed 23? from my math, it seems that 19 works as well. since it\\'ll take 2 hours for koko to eat 11 and 4 bananas, she is left with 73 bananas to eat for the next 4 hours. With this, 73/4 is equal to 19 rounded up."
                    },
                    {
                        "username": "djmoore26",
                        "content": "Because of the constraint that once a pile is finished, koko does not start a new pile in the same hour. if k is 19, it would take koko 2 hours each to eat the 3 remaining piles"
                    },
                    {
                        "username": "halfengineer",
                        "content": "120/123 \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\n[1000000000]\\n2\\n"
                    },
                    {
                        "username": "hitendra_singh1729",
                        "content": "Good job leetcode. Making me strong in Binary search."
                    }
                ]
            },
            {
                "id": 1825890,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "<i> \" Cometh the month of March\n Leetcode goeth crazy with binary search!\""
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The solution to this problem is same as yesterdays one.\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/description/"
                    },
                    {
                        "username": "dumb_me",
                        "content": "koko is like us fr trying to eat all food before siblings come hone XD\\n"
                    },
                    {
                        "username": "cheenu123",
                        "content": "For C++: While calculating feasibility of the k value, use double instead of float for calculating ceil as float will give error at 120/123 testcase due to less precision."
                    },
                    {
                        "username": "bot16111011",
                        "content": "I am having trouble recognizing which approach to use here. My first thought was using the brute force but then after going through the discussion I came to know how to approach this problem using binary search then coding coding was piece of cake.\\nBut question still persist is this right way of solving problems and how could I improve ?"
                    },
                    {
                        "username": "gauravpatyal2702",
                        "content": "Btw happy holi"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Does this question make you go bananas? :))"
                    },
                    {
                        "username": "Weiiitt",
                        "content": "Hi guys, I am a little confused on example 3. Why is the minimum speed 23? from my math, it seems that 19 works as well. since it\\'ll take 2 hours for koko to eat 11 and 4 bananas, she is left with 73 bananas to eat for the next 4 hours. With this, 73/4 is equal to 19 rounded up."
                    },
                    {
                        "username": "djmoore26",
                        "content": "Because of the constraint that once a pile is finished, koko does not start a new pile in the same hour. if k is 19, it would take koko 2 hours each to eat the 3 remaining piles"
                    },
                    {
                        "username": "halfengineer",
                        "content": "120/123 \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\n[1000000000]\\n2\\n"
                    },
                    {
                        "username": "hitendra_singh1729",
                        "content": "Good job leetcode. Making me strong in Binary search."
                    }
                ]
            },
            {
                "id": 1825889,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "<i> \" Cometh the month of March\n Leetcode goeth crazy with binary search!\""
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The solution to this problem is same as yesterdays one.\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/description/"
                    },
                    {
                        "username": "dumb_me",
                        "content": "koko is like us fr trying to eat all food before siblings come hone XD\\n"
                    },
                    {
                        "username": "cheenu123",
                        "content": "For C++: While calculating feasibility of the k value, use double instead of float for calculating ceil as float will give error at 120/123 testcase due to less precision."
                    },
                    {
                        "username": "bot16111011",
                        "content": "I am having trouble recognizing which approach to use here. My first thought was using the brute force but then after going through the discussion I came to know how to approach this problem using binary search then coding coding was piece of cake.\\nBut question still persist is this right way of solving problems and how could I improve ?"
                    },
                    {
                        "username": "gauravpatyal2702",
                        "content": "Btw happy holi"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Does this question make you go bananas? :))"
                    },
                    {
                        "username": "Weiiitt",
                        "content": "Hi guys, I am a little confused on example 3. Why is the minimum speed 23? from my math, it seems that 19 works as well. since it\\'ll take 2 hours for koko to eat 11 and 4 bananas, she is left with 73 bananas to eat for the next 4 hours. With this, 73/4 is equal to 19 rounded up."
                    },
                    {
                        "username": "djmoore26",
                        "content": "Because of the constraint that once a pile is finished, koko does not start a new pile in the same hour. if k is 19, it would take koko 2 hours each to eat the 3 remaining piles"
                    },
                    {
                        "username": "halfengineer",
                        "content": "120/123 \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\n[1000000000]\\n2\\n"
                    },
                    {
                        "username": "hitendra_singh1729",
                        "content": "Good job leetcode. Making me strong in Binary search."
                    }
                ]
            },
            {
                "id": 1825860,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "<i> \" Cometh the month of March\n Leetcode goeth crazy with binary search!\""
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The solution to this problem is same as yesterdays one.\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/description/"
                    },
                    {
                        "username": "dumb_me",
                        "content": "koko is like us fr trying to eat all food before siblings come hone XD\\n"
                    },
                    {
                        "username": "cheenu123",
                        "content": "For C++: While calculating feasibility of the k value, use double instead of float for calculating ceil as float will give error at 120/123 testcase due to less precision."
                    },
                    {
                        "username": "bot16111011",
                        "content": "I am having trouble recognizing which approach to use here. My first thought was using the brute force but then after going through the discussion I came to know how to approach this problem using binary search then coding coding was piece of cake.\\nBut question still persist is this right way of solving problems and how could I improve ?"
                    },
                    {
                        "username": "gauravpatyal2702",
                        "content": "Btw happy holi"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Does this question make you go bananas? :))"
                    },
                    {
                        "username": "Weiiitt",
                        "content": "Hi guys, I am a little confused on example 3. Why is the minimum speed 23? from my math, it seems that 19 works as well. since it\\'ll take 2 hours for koko to eat 11 and 4 bananas, she is left with 73 bananas to eat for the next 4 hours. With this, 73/4 is equal to 19 rounded up."
                    },
                    {
                        "username": "djmoore26",
                        "content": "Because of the constraint that once a pile is finished, koko does not start a new pile in the same hour. if k is 19, it would take koko 2 hours each to eat the 3 remaining piles"
                    },
                    {
                        "username": "halfengineer",
                        "content": "120/123 \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\n[1000000000]\\n2\\n"
                    },
                    {
                        "username": "hitendra_singh1729",
                        "content": "Good job leetcode. Making me strong in Binary search."
                    }
                ]
            },
            {
                "id": 1825857,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "<i> \" Cometh the month of March\n Leetcode goeth crazy with binary search!\""
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The solution to this problem is same as yesterdays one.\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/description/"
                    },
                    {
                        "username": "dumb_me",
                        "content": "koko is like us fr trying to eat all food before siblings come hone XD\\n"
                    },
                    {
                        "username": "cheenu123",
                        "content": "For C++: While calculating feasibility of the k value, use double instead of float for calculating ceil as float will give error at 120/123 testcase due to less precision."
                    },
                    {
                        "username": "bot16111011",
                        "content": "I am having trouble recognizing which approach to use here. My first thought was using the brute force but then after going through the discussion I came to know how to approach this problem using binary search then coding coding was piece of cake.\\nBut question still persist is this right way of solving problems and how could I improve ?"
                    },
                    {
                        "username": "gauravpatyal2702",
                        "content": "Btw happy holi"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Does this question make you go bananas? :))"
                    },
                    {
                        "username": "Weiiitt",
                        "content": "Hi guys, I am a little confused on example 3. Why is the minimum speed 23? from my math, it seems that 19 works as well. since it\\'ll take 2 hours for koko to eat 11 and 4 bananas, she is left with 73 bananas to eat for the next 4 hours. With this, 73/4 is equal to 19 rounded up."
                    },
                    {
                        "username": "djmoore26",
                        "content": "Because of the constraint that once a pile is finished, koko does not start a new pile in the same hour. if k is 19, it would take koko 2 hours each to eat the 3 remaining piles"
                    },
                    {
                        "username": "halfengineer",
                        "content": "120/123 \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\n[1000000000]\\n2\\n"
                    },
                    {
                        "username": "hitendra_singh1729",
                        "content": "Good job leetcode. Making me strong in Binary search."
                    }
                ]
            },
            {
                "id": 1825817,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "<i> \" Cometh the month of March\n Leetcode goeth crazy with binary search!\""
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The solution to this problem is same as yesterdays one.\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/description/"
                    },
                    {
                        "username": "dumb_me",
                        "content": "koko is like us fr trying to eat all food before siblings come hone XD\\n"
                    },
                    {
                        "username": "cheenu123",
                        "content": "For C++: While calculating feasibility of the k value, use double instead of float for calculating ceil as float will give error at 120/123 testcase due to less precision."
                    },
                    {
                        "username": "bot16111011",
                        "content": "I am having trouble recognizing which approach to use here. My first thought was using the brute force but then after going through the discussion I came to know how to approach this problem using binary search then coding coding was piece of cake.\\nBut question still persist is this right way of solving problems and how could I improve ?"
                    },
                    {
                        "username": "gauravpatyal2702",
                        "content": "Btw happy holi"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Does this question make you go bananas? :))"
                    },
                    {
                        "username": "Weiiitt",
                        "content": "Hi guys, I am a little confused on example 3. Why is the minimum speed 23? from my math, it seems that 19 works as well. since it\\'ll take 2 hours for koko to eat 11 and 4 bananas, she is left with 73 bananas to eat for the next 4 hours. With this, 73/4 is equal to 19 rounded up."
                    },
                    {
                        "username": "djmoore26",
                        "content": "Because of the constraint that once a pile is finished, koko does not start a new pile in the same hour. if k is 19, it would take koko 2 hours each to eat the 3 remaining piles"
                    },
                    {
                        "username": "halfengineer",
                        "content": "120/123 \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\n[1000000000]\\n2\\n"
                    },
                    {
                        "username": "hitendra_singh1729",
                        "content": "Good job leetcode. Making me strong in Binary search."
                    }
                ]
            },
            {
                "id": 1825797,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "<i> \" Cometh the month of March\n Leetcode goeth crazy with binary search!\""
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The solution to this problem is same as yesterdays one.\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/description/"
                    },
                    {
                        "username": "dumb_me",
                        "content": "koko is like us fr trying to eat all food before siblings come hone XD\\n"
                    },
                    {
                        "username": "cheenu123",
                        "content": "For C++: While calculating feasibility of the k value, use double instead of float for calculating ceil as float will give error at 120/123 testcase due to less precision."
                    },
                    {
                        "username": "bot16111011",
                        "content": "I am having trouble recognizing which approach to use here. My first thought was using the brute force but then after going through the discussion I came to know how to approach this problem using binary search then coding coding was piece of cake.\\nBut question still persist is this right way of solving problems and how could I improve ?"
                    },
                    {
                        "username": "gauravpatyal2702",
                        "content": "Btw happy holi"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Does this question make you go bananas? :))"
                    },
                    {
                        "username": "Weiiitt",
                        "content": "Hi guys, I am a little confused on example 3. Why is the minimum speed 23? from my math, it seems that 19 works as well. since it\\'ll take 2 hours for koko to eat 11 and 4 bananas, she is left with 73 bananas to eat for the next 4 hours. With this, 73/4 is equal to 19 rounded up."
                    },
                    {
                        "username": "djmoore26",
                        "content": "Because of the constraint that once a pile is finished, koko does not start a new pile in the same hour. if k is 19, it would take koko 2 hours each to eat the 3 remaining piles"
                    },
                    {
                        "username": "halfengineer",
                        "content": "120/123 \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\n[1000000000]\\n2\\n"
                    },
                    {
                        "username": "hitendra_singh1729",
                        "content": "Good job leetcode. Making me strong in Binary search."
                    }
                ]
            },
            {
                "id": 1825791,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Warning for C++ folks: For calculating hours spent per pile, if you decide to use ceil function, then don\\'t use float as it will lead to wrong answer due to less precision, use double instead."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Check out one of the easiest explanations here.\\n\\n[Here](https://leetcode.com/problems/koko-eating-bananas/solutions/1705032/java-binary-search-solution-easily-explained-even-for-beginners/?orderBy=most_votes)"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Binary Search everywhere \\uD83D\\uDE2F\\n\\nBtw Happy Holi Everyone"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is again a question for binary search. The explanation is much clearer than the one on yesterday.https://leetcode.com/problems/minimum-time-to-complete-trips/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Happy Holi ! Almost Same problem as yesterday."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach using Binary Search :-\\n\\n1.Find the maximum pile size in the array.\\n\\n2.Set a lower bound to 1 and an upper bound to the maximum pile size.\\n\\n3.Use binary search to find the minimum number of bananas per hour.\\n\\n4.For each midpoint, calculate the number of hours it would take to finish all the bananas by dividing each pile size by the midpoint and rounding up to the nearest integer.\\n\\n5.If the total number of hours exceeds the given time, update the lower bound to the midpoint + 1. Otherwise, update the upper bound to the midpoint.\\n\\n6.Continue until the lower bound and upper bound converge to the same value.\\n\\n7.Return the lower bound as the minimum number of bananas per hour needed to finish all the bananas within the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/3270555/detailed-solution-with-approach/?orderBy=most_votes"
                    },
                    {
                        "username": "leonfrer",
                        "content": "Many solutions are mistakenly labeled as Binary Tree when they are actually Binary Search"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "use binary search. find the minimum and maximum possible values for k, which are 1 and the maximum number of bananas in a pile, respectively. Then, check if it is possible for Koko to eat all the bananas within h hours using that midpoint as her eating speed.\\n"
                    },
                    {
                        "username": "Saalman",
                        "content": "oh shit!? here we go again "
                    },
                    {
                        "username": "cJayesh",
                        "content": "Aah... Same logic as yesterday(7th March)."
                    },
                    {
                        "username": "user1084vL",
                        "content": "Yeah, just in reverse basically."
                    }
                ]
            },
            {
                "id": 1825790,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Warning for C++ folks: For calculating hours spent per pile, if you decide to use ceil function, then don\\'t use float as it will lead to wrong answer due to less precision, use double instead."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Check out one of the easiest explanations here.\\n\\n[Here](https://leetcode.com/problems/koko-eating-bananas/solutions/1705032/java-binary-search-solution-easily-explained-even-for-beginners/?orderBy=most_votes)"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Binary Search everywhere \\uD83D\\uDE2F\\n\\nBtw Happy Holi Everyone"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is again a question for binary search. The explanation is much clearer than the one on yesterday.https://leetcode.com/problems/minimum-time-to-complete-trips/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Happy Holi ! Almost Same problem as yesterday."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach using Binary Search :-\\n\\n1.Find the maximum pile size in the array.\\n\\n2.Set a lower bound to 1 and an upper bound to the maximum pile size.\\n\\n3.Use binary search to find the minimum number of bananas per hour.\\n\\n4.For each midpoint, calculate the number of hours it would take to finish all the bananas by dividing each pile size by the midpoint and rounding up to the nearest integer.\\n\\n5.If the total number of hours exceeds the given time, update the lower bound to the midpoint + 1. Otherwise, update the upper bound to the midpoint.\\n\\n6.Continue until the lower bound and upper bound converge to the same value.\\n\\n7.Return the lower bound as the minimum number of bananas per hour needed to finish all the bananas within the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/3270555/detailed-solution-with-approach/?orderBy=most_votes"
                    },
                    {
                        "username": "leonfrer",
                        "content": "Many solutions are mistakenly labeled as Binary Tree when they are actually Binary Search"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "use binary search. find the minimum and maximum possible values for k, which are 1 and the maximum number of bananas in a pile, respectively. Then, check if it is possible for Koko to eat all the bananas within h hours using that midpoint as her eating speed.\\n"
                    },
                    {
                        "username": "Saalman",
                        "content": "oh shit!? here we go again "
                    },
                    {
                        "username": "cJayesh",
                        "content": "Aah... Same logic as yesterday(7th March)."
                    },
                    {
                        "username": "user1084vL",
                        "content": "Yeah, just in reverse basically."
                    }
                ]
            },
            {
                "id": 1825781,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Warning for C++ folks: For calculating hours spent per pile, if you decide to use ceil function, then don\\'t use float as it will lead to wrong answer due to less precision, use double instead."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Check out one of the easiest explanations here.\\n\\n[Here](https://leetcode.com/problems/koko-eating-bananas/solutions/1705032/java-binary-search-solution-easily-explained-even-for-beginners/?orderBy=most_votes)"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Binary Search everywhere \\uD83D\\uDE2F\\n\\nBtw Happy Holi Everyone"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is again a question for binary search. The explanation is much clearer than the one on yesterday.https://leetcode.com/problems/minimum-time-to-complete-trips/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Happy Holi ! Almost Same problem as yesterday."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach using Binary Search :-\\n\\n1.Find the maximum pile size in the array.\\n\\n2.Set a lower bound to 1 and an upper bound to the maximum pile size.\\n\\n3.Use binary search to find the minimum number of bananas per hour.\\n\\n4.For each midpoint, calculate the number of hours it would take to finish all the bananas by dividing each pile size by the midpoint and rounding up to the nearest integer.\\n\\n5.If the total number of hours exceeds the given time, update the lower bound to the midpoint + 1. Otherwise, update the upper bound to the midpoint.\\n\\n6.Continue until the lower bound and upper bound converge to the same value.\\n\\n7.Return the lower bound as the minimum number of bananas per hour needed to finish all the bananas within the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/3270555/detailed-solution-with-approach/?orderBy=most_votes"
                    },
                    {
                        "username": "leonfrer",
                        "content": "Many solutions are mistakenly labeled as Binary Tree when they are actually Binary Search"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "use binary search. find the minimum and maximum possible values for k, which are 1 and the maximum number of bananas in a pile, respectively. Then, check if it is possible for Koko to eat all the bananas within h hours using that midpoint as her eating speed.\\n"
                    },
                    {
                        "username": "Saalman",
                        "content": "oh shit!? here we go again "
                    },
                    {
                        "username": "cJayesh",
                        "content": "Aah... Same logic as yesterday(7th March)."
                    },
                    {
                        "username": "user1084vL",
                        "content": "Yeah, just in reverse basically."
                    }
                ]
            },
            {
                "id": 1825779,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Warning for C++ folks: For calculating hours spent per pile, if you decide to use ceil function, then don\\'t use float as it will lead to wrong answer due to less precision, use double instead."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Check out one of the easiest explanations here.\\n\\n[Here](https://leetcode.com/problems/koko-eating-bananas/solutions/1705032/java-binary-search-solution-easily-explained-even-for-beginners/?orderBy=most_votes)"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Binary Search everywhere \\uD83D\\uDE2F\\n\\nBtw Happy Holi Everyone"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is again a question for binary search. The explanation is much clearer than the one on yesterday.https://leetcode.com/problems/minimum-time-to-complete-trips/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Happy Holi ! Almost Same problem as yesterday."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach using Binary Search :-\\n\\n1.Find the maximum pile size in the array.\\n\\n2.Set a lower bound to 1 and an upper bound to the maximum pile size.\\n\\n3.Use binary search to find the minimum number of bananas per hour.\\n\\n4.For each midpoint, calculate the number of hours it would take to finish all the bananas by dividing each pile size by the midpoint and rounding up to the nearest integer.\\n\\n5.If the total number of hours exceeds the given time, update the lower bound to the midpoint + 1. Otherwise, update the upper bound to the midpoint.\\n\\n6.Continue until the lower bound and upper bound converge to the same value.\\n\\n7.Return the lower bound as the minimum number of bananas per hour needed to finish all the bananas within the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/3270555/detailed-solution-with-approach/?orderBy=most_votes"
                    },
                    {
                        "username": "leonfrer",
                        "content": "Many solutions are mistakenly labeled as Binary Tree when they are actually Binary Search"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "use binary search. find the minimum and maximum possible values for k, which are 1 and the maximum number of bananas in a pile, respectively. Then, check if it is possible for Koko to eat all the bananas within h hours using that midpoint as her eating speed.\\n"
                    },
                    {
                        "username": "Saalman",
                        "content": "oh shit!? here we go again "
                    },
                    {
                        "username": "cJayesh",
                        "content": "Aah... Same logic as yesterday(7th March)."
                    },
                    {
                        "username": "user1084vL",
                        "content": "Yeah, just in reverse basically."
                    }
                ]
            },
            {
                "id": 1825768,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Warning for C++ folks: For calculating hours spent per pile, if you decide to use ceil function, then don\\'t use float as it will lead to wrong answer due to less precision, use double instead."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Check out one of the easiest explanations here.\\n\\n[Here](https://leetcode.com/problems/koko-eating-bananas/solutions/1705032/java-binary-search-solution-easily-explained-even-for-beginners/?orderBy=most_votes)"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Binary Search everywhere \\uD83D\\uDE2F\\n\\nBtw Happy Holi Everyone"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is again a question for binary search. The explanation is much clearer than the one on yesterday.https://leetcode.com/problems/minimum-time-to-complete-trips/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Happy Holi ! Almost Same problem as yesterday."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach using Binary Search :-\\n\\n1.Find the maximum pile size in the array.\\n\\n2.Set a lower bound to 1 and an upper bound to the maximum pile size.\\n\\n3.Use binary search to find the minimum number of bananas per hour.\\n\\n4.For each midpoint, calculate the number of hours it would take to finish all the bananas by dividing each pile size by the midpoint and rounding up to the nearest integer.\\n\\n5.If the total number of hours exceeds the given time, update the lower bound to the midpoint + 1. Otherwise, update the upper bound to the midpoint.\\n\\n6.Continue until the lower bound and upper bound converge to the same value.\\n\\n7.Return the lower bound as the minimum number of bananas per hour needed to finish all the bananas within the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/3270555/detailed-solution-with-approach/?orderBy=most_votes"
                    },
                    {
                        "username": "leonfrer",
                        "content": "Many solutions are mistakenly labeled as Binary Tree when they are actually Binary Search"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "use binary search. find the minimum and maximum possible values for k, which are 1 and the maximum number of bananas in a pile, respectively. Then, check if it is possible for Koko to eat all the bananas within h hours using that midpoint as her eating speed.\\n"
                    },
                    {
                        "username": "Saalman",
                        "content": "oh shit!? here we go again "
                    },
                    {
                        "username": "cJayesh",
                        "content": "Aah... Same logic as yesterday(7th March)."
                    },
                    {
                        "username": "user1084vL",
                        "content": "Yeah, just in reverse basically."
                    }
                ]
            },
            {
                "id": 1825744,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Warning for C++ folks: For calculating hours spent per pile, if you decide to use ceil function, then don\\'t use float as it will lead to wrong answer due to less precision, use double instead."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Check out one of the easiest explanations here.\\n\\n[Here](https://leetcode.com/problems/koko-eating-bananas/solutions/1705032/java-binary-search-solution-easily-explained-even-for-beginners/?orderBy=most_votes)"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Binary Search everywhere \\uD83D\\uDE2F\\n\\nBtw Happy Holi Everyone"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is again a question for binary search. The explanation is much clearer than the one on yesterday.https://leetcode.com/problems/minimum-time-to-complete-trips/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Happy Holi ! Almost Same problem as yesterday."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach using Binary Search :-\\n\\n1.Find the maximum pile size in the array.\\n\\n2.Set a lower bound to 1 and an upper bound to the maximum pile size.\\n\\n3.Use binary search to find the minimum number of bananas per hour.\\n\\n4.For each midpoint, calculate the number of hours it would take to finish all the bananas by dividing each pile size by the midpoint and rounding up to the nearest integer.\\n\\n5.If the total number of hours exceeds the given time, update the lower bound to the midpoint + 1. Otherwise, update the upper bound to the midpoint.\\n\\n6.Continue until the lower bound and upper bound converge to the same value.\\n\\n7.Return the lower bound as the minimum number of bananas per hour needed to finish all the bananas within the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/3270555/detailed-solution-with-approach/?orderBy=most_votes"
                    },
                    {
                        "username": "leonfrer",
                        "content": "Many solutions are mistakenly labeled as Binary Tree when they are actually Binary Search"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "use binary search. find the minimum and maximum possible values for k, which are 1 and the maximum number of bananas in a pile, respectively. Then, check if it is possible for Koko to eat all the bananas within h hours using that midpoint as her eating speed.\\n"
                    },
                    {
                        "username": "Saalman",
                        "content": "oh shit!? here we go again "
                    },
                    {
                        "username": "cJayesh",
                        "content": "Aah... Same logic as yesterday(7th March)."
                    },
                    {
                        "username": "user1084vL",
                        "content": "Yeah, just in reverse basically."
                    }
                ]
            },
            {
                "id": 1825711,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Warning for C++ folks: For calculating hours spent per pile, if you decide to use ceil function, then don\\'t use float as it will lead to wrong answer due to less precision, use double instead."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Check out one of the easiest explanations here.\\n\\n[Here](https://leetcode.com/problems/koko-eating-bananas/solutions/1705032/java-binary-search-solution-easily-explained-even-for-beginners/?orderBy=most_votes)"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Binary Search everywhere \\uD83D\\uDE2F\\n\\nBtw Happy Holi Everyone"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is again a question for binary search. The explanation is much clearer than the one on yesterday.https://leetcode.com/problems/minimum-time-to-complete-trips/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Happy Holi ! Almost Same problem as yesterday."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach using Binary Search :-\\n\\n1.Find the maximum pile size in the array.\\n\\n2.Set a lower bound to 1 and an upper bound to the maximum pile size.\\n\\n3.Use binary search to find the minimum number of bananas per hour.\\n\\n4.For each midpoint, calculate the number of hours it would take to finish all the bananas by dividing each pile size by the midpoint and rounding up to the nearest integer.\\n\\n5.If the total number of hours exceeds the given time, update the lower bound to the midpoint + 1. Otherwise, update the upper bound to the midpoint.\\n\\n6.Continue until the lower bound and upper bound converge to the same value.\\n\\n7.Return the lower bound as the minimum number of bananas per hour needed to finish all the bananas within the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/3270555/detailed-solution-with-approach/?orderBy=most_votes"
                    },
                    {
                        "username": "leonfrer",
                        "content": "Many solutions are mistakenly labeled as Binary Tree when they are actually Binary Search"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "use binary search. find the minimum and maximum possible values for k, which are 1 and the maximum number of bananas in a pile, respectively. Then, check if it is possible for Koko to eat all the bananas within h hours using that midpoint as her eating speed.\\n"
                    },
                    {
                        "username": "Saalman",
                        "content": "oh shit!? here we go again "
                    },
                    {
                        "username": "cJayesh",
                        "content": "Aah... Same logic as yesterday(7th March)."
                    },
                    {
                        "username": "user1084vL",
                        "content": "Yeah, just in reverse basically."
                    }
                ]
            },
            {
                "id": 1825696,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Warning for C++ folks: For calculating hours spent per pile, if you decide to use ceil function, then don\\'t use float as it will lead to wrong answer due to less precision, use double instead."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Check out one of the easiest explanations here.\\n\\n[Here](https://leetcode.com/problems/koko-eating-bananas/solutions/1705032/java-binary-search-solution-easily-explained-even-for-beginners/?orderBy=most_votes)"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Binary Search everywhere \\uD83D\\uDE2F\\n\\nBtw Happy Holi Everyone"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is again a question for binary search. The explanation is much clearer than the one on yesterday.https://leetcode.com/problems/minimum-time-to-complete-trips/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Happy Holi ! Almost Same problem as yesterday."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach using Binary Search :-\\n\\n1.Find the maximum pile size in the array.\\n\\n2.Set a lower bound to 1 and an upper bound to the maximum pile size.\\n\\n3.Use binary search to find the minimum number of bananas per hour.\\n\\n4.For each midpoint, calculate the number of hours it would take to finish all the bananas by dividing each pile size by the midpoint and rounding up to the nearest integer.\\n\\n5.If the total number of hours exceeds the given time, update the lower bound to the midpoint + 1. Otherwise, update the upper bound to the midpoint.\\n\\n6.Continue until the lower bound and upper bound converge to the same value.\\n\\n7.Return the lower bound as the minimum number of bananas per hour needed to finish all the bananas within the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/3270555/detailed-solution-with-approach/?orderBy=most_votes"
                    },
                    {
                        "username": "leonfrer",
                        "content": "Many solutions are mistakenly labeled as Binary Tree when they are actually Binary Search"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "use binary search. find the minimum and maximum possible values for k, which are 1 and the maximum number of bananas in a pile, respectively. Then, check if it is possible for Koko to eat all the bananas within h hours using that midpoint as her eating speed.\\n"
                    },
                    {
                        "username": "Saalman",
                        "content": "oh shit!? here we go again "
                    },
                    {
                        "username": "cJayesh",
                        "content": "Aah... Same logic as yesterday(7th March)."
                    },
                    {
                        "username": "user1084vL",
                        "content": "Yeah, just in reverse basically."
                    }
                ]
            },
            {
                "id": 1825678,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Warning for C++ folks: For calculating hours spent per pile, if you decide to use ceil function, then don\\'t use float as it will lead to wrong answer due to less precision, use double instead."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Check out one of the easiest explanations here.\\n\\n[Here](https://leetcode.com/problems/koko-eating-bananas/solutions/1705032/java-binary-search-solution-easily-explained-even-for-beginners/?orderBy=most_votes)"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Binary Search everywhere \\uD83D\\uDE2F\\n\\nBtw Happy Holi Everyone"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is again a question for binary search. The explanation is much clearer than the one on yesterday.https://leetcode.com/problems/minimum-time-to-complete-trips/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Happy Holi ! Almost Same problem as yesterday."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach using Binary Search :-\\n\\n1.Find the maximum pile size in the array.\\n\\n2.Set a lower bound to 1 and an upper bound to the maximum pile size.\\n\\n3.Use binary search to find the minimum number of bananas per hour.\\n\\n4.For each midpoint, calculate the number of hours it would take to finish all the bananas by dividing each pile size by the midpoint and rounding up to the nearest integer.\\n\\n5.If the total number of hours exceeds the given time, update the lower bound to the midpoint + 1. Otherwise, update the upper bound to the midpoint.\\n\\n6.Continue until the lower bound and upper bound converge to the same value.\\n\\n7.Return the lower bound as the minimum number of bananas per hour needed to finish all the bananas within the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/3270555/detailed-solution-with-approach/?orderBy=most_votes"
                    },
                    {
                        "username": "leonfrer",
                        "content": "Many solutions are mistakenly labeled as Binary Tree when they are actually Binary Search"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "use binary search. find the minimum and maximum possible values for k, which are 1 and the maximum number of bananas in a pile, respectively. Then, check if it is possible for Koko to eat all the bananas within h hours using that midpoint as her eating speed.\\n"
                    },
                    {
                        "username": "Saalman",
                        "content": "oh shit!? here we go again "
                    },
                    {
                        "username": "cJayesh",
                        "content": "Aah... Same logic as yesterday(7th March)."
                    },
                    {
                        "username": "user1084vL",
                        "content": "Yeah, just in reverse basically."
                    }
                ]
            },
            {
                "id": 1825669,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Warning for C++ folks: For calculating hours spent per pile, if you decide to use ceil function, then don\\'t use float as it will lead to wrong answer due to less precision, use double instead."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Check out one of the easiest explanations here.\\n\\n[Here](https://leetcode.com/problems/koko-eating-bananas/solutions/1705032/java-binary-search-solution-easily-explained-even-for-beginners/?orderBy=most_votes)"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Binary Search everywhere \\uD83D\\uDE2F\\n\\nBtw Happy Holi Everyone"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is again a question for binary search. The explanation is much clearer than the one on yesterday.https://leetcode.com/problems/minimum-time-to-complete-trips/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Happy Holi ! Almost Same problem as yesterday."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach using Binary Search :-\\n\\n1.Find the maximum pile size in the array.\\n\\n2.Set a lower bound to 1 and an upper bound to the maximum pile size.\\n\\n3.Use binary search to find the minimum number of bananas per hour.\\n\\n4.For each midpoint, calculate the number of hours it would take to finish all the bananas by dividing each pile size by the midpoint and rounding up to the nearest integer.\\n\\n5.If the total number of hours exceeds the given time, update the lower bound to the midpoint + 1. Otherwise, update the upper bound to the midpoint.\\n\\n6.Continue until the lower bound and upper bound converge to the same value.\\n\\n7.Return the lower bound as the minimum number of bananas per hour needed to finish all the bananas within the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/3270555/detailed-solution-with-approach/?orderBy=most_votes"
                    },
                    {
                        "username": "leonfrer",
                        "content": "Many solutions are mistakenly labeled as Binary Tree when they are actually Binary Search"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "use binary search. find the minimum and maximum possible values for k, which are 1 and the maximum number of bananas in a pile, respectively. Then, check if it is possible for Koko to eat all the bananas within h hours using that midpoint as her eating speed.\\n"
                    },
                    {
                        "username": "Saalman",
                        "content": "oh shit!? here we go again "
                    },
                    {
                        "username": "cJayesh",
                        "content": "Aah... Same logic as yesterday(7th March)."
                    },
                    {
                        "username": "user1084vL",
                        "content": "Yeah, just in reverse basically."
                    }
                ]
            },
            {
                "id": 1825652,
                "content": [
                    {
                        "username": "AMerrill",
                        "content": "Copy Paste from yesterday?"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Welcome to the Binary search week!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This question is basically the same as yesterday, except a weirder scenario..."
                    },
                    {
                        "username": "iammsm",
                        "content": "MY CODE SHOWS RUNTIME ERROR : DIVISION BY ZERO\\nCAN YOU GUYS LOOK AT IT Why IT COMES and how to overcome \\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& piles,int h,int mid){\\n        long long int hourCount=0;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]<= mid) hourCount++;\\n            else{\\n                if(piles[i] % mid !=0){\\n                    hourCount+=(piles[i]/mid)+1;    }\\n                else hourCount+= piles[i]/mid;      }\\n        }\\n        return hourCount;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=0;  int sum=0;\\n        for(int i=0; i<piles.size() ;i++){\\n            sum+=piles[i];  }\\n        int high=sum;\\n        int k=-1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(isPossible(piles,h,mid)){\\n                k=mid;\\n                high=mid-1;     }\\n            else low=mid+1;\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "This question similar as\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/?envType=study-plan&id=binary-search-ii"
                    },
                    {
                        "username": "buddyhuddy",
                        "content": "Is anyone else getting a Stack Overflow error when using Math.ceil on this problem? \\n\\nTest Case that is causing the Stack Overflow.\\npiles =\\n[312884470]\\nh =\\n312884469"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guy who added the test case no 118 has my respect doubled..\\n"
                    },
                    {
                        "username": "gs_1902",
                        "content": "// tle error help!!!!!!!!!!!!!!\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int max=piles[0];\\n         int sum=0;\\n         int j=1;\\n         for(int i=1;i<piles.size();i++)\\n            {\\n                if(piles[i]>max)\\n                max=piles[i];\\n            }\\n             while(j<max)\\n             {  sum=0;\\n                 for(int i=0;i<piles.size();i++)\\n                { if(piles[i]%j!=0)\\n                     sum=sum+(piles[i]/j)+1;\\n                     else\\n                       sum=sum+(piles[i]/j);\\n                }\\n                 if(sum==h)\\n                 break;\\n                 else\\n                 j++;\\n             }\\n        \\n        if(h==piles.size())\\n        return max;\\n        else\\n        return j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "0xatul",
                        "content": "Binary Search with both `high > low` and `high >= low`\\n\\n [Solution](https://leetcode.com/problems/koko-eating-bananas/solutions/2988144/using-both-low-high-and-low-high/) "
                    },
                    {
                        "username": "harsh_09__",
                        "content": "help me 1 testcase is not running\\n"
                    },
                    {
                        "username": "Mr_Amazing",
                        "content": "add this in top of your code. It worked for me.\n```\n\nif(piles[0]==805306368){\n   return 3;\n}\n\n```\n"
                    },
                    {
                        "username": "MahikaGarg",
                        "content": "[@Sridevinavin](/Sridevinavin) ...same test case is not running for my code too"
                    },
                    {
                        "username": "Sridevinavin",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\nIs this the above test case, I am also facing the same problem.Please reply me if you have found the solution."
                    }
                ]
            },
            {
                "id": 1825648,
                "content": [
                    {
                        "username": "AMerrill",
                        "content": "Copy Paste from yesterday?"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Welcome to the Binary search week!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This question is basically the same as yesterday, except a weirder scenario..."
                    },
                    {
                        "username": "iammsm",
                        "content": "MY CODE SHOWS RUNTIME ERROR : DIVISION BY ZERO\\nCAN YOU GUYS LOOK AT IT Why IT COMES and how to overcome \\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& piles,int h,int mid){\\n        long long int hourCount=0;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]<= mid) hourCount++;\\n            else{\\n                if(piles[i] % mid !=0){\\n                    hourCount+=(piles[i]/mid)+1;    }\\n                else hourCount+= piles[i]/mid;      }\\n        }\\n        return hourCount;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=0;  int sum=0;\\n        for(int i=0; i<piles.size() ;i++){\\n            sum+=piles[i];  }\\n        int high=sum;\\n        int k=-1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(isPossible(piles,h,mid)){\\n                k=mid;\\n                high=mid-1;     }\\n            else low=mid+1;\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "This question similar as\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/?envType=study-plan&id=binary-search-ii"
                    },
                    {
                        "username": "buddyhuddy",
                        "content": "Is anyone else getting a Stack Overflow error when using Math.ceil on this problem? \\n\\nTest Case that is causing the Stack Overflow.\\npiles =\\n[312884470]\\nh =\\n312884469"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guy who added the test case no 118 has my respect doubled..\\n"
                    },
                    {
                        "username": "gs_1902",
                        "content": "// tle error help!!!!!!!!!!!!!!\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int max=piles[0];\\n         int sum=0;\\n         int j=1;\\n         for(int i=1;i<piles.size();i++)\\n            {\\n                if(piles[i]>max)\\n                max=piles[i];\\n            }\\n             while(j<max)\\n             {  sum=0;\\n                 for(int i=0;i<piles.size();i++)\\n                { if(piles[i]%j!=0)\\n                     sum=sum+(piles[i]/j)+1;\\n                     else\\n                       sum=sum+(piles[i]/j);\\n                }\\n                 if(sum==h)\\n                 break;\\n                 else\\n                 j++;\\n             }\\n        \\n        if(h==piles.size())\\n        return max;\\n        else\\n        return j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "0xatul",
                        "content": "Binary Search with both `high > low` and `high >= low`\\n\\n [Solution](https://leetcode.com/problems/koko-eating-bananas/solutions/2988144/using-both-low-high-and-low-high/) "
                    },
                    {
                        "username": "harsh_09__",
                        "content": "help me 1 testcase is not running\\n"
                    },
                    {
                        "username": "Mr_Amazing",
                        "content": "add this in top of your code. It worked for me.\n```\n\nif(piles[0]==805306368){\n   return 3;\n}\n\n```\n"
                    },
                    {
                        "username": "MahikaGarg",
                        "content": "[@Sridevinavin](/Sridevinavin) ...same test case is not running for my code too"
                    },
                    {
                        "username": "Sridevinavin",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\nIs this the above test case, I am also facing the same problem.Please reply me if you have found the solution."
                    }
                ]
            },
            {
                "id": 1825645,
                "content": [
                    {
                        "username": "AMerrill",
                        "content": "Copy Paste from yesterday?"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Welcome to the Binary search week!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This question is basically the same as yesterday, except a weirder scenario..."
                    },
                    {
                        "username": "iammsm",
                        "content": "MY CODE SHOWS RUNTIME ERROR : DIVISION BY ZERO\\nCAN YOU GUYS LOOK AT IT Why IT COMES and how to overcome \\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& piles,int h,int mid){\\n        long long int hourCount=0;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]<= mid) hourCount++;\\n            else{\\n                if(piles[i] % mid !=0){\\n                    hourCount+=(piles[i]/mid)+1;    }\\n                else hourCount+= piles[i]/mid;      }\\n        }\\n        return hourCount;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=0;  int sum=0;\\n        for(int i=0; i<piles.size() ;i++){\\n            sum+=piles[i];  }\\n        int high=sum;\\n        int k=-1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(isPossible(piles,h,mid)){\\n                k=mid;\\n                high=mid-1;     }\\n            else low=mid+1;\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "This question similar as\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/?envType=study-plan&id=binary-search-ii"
                    },
                    {
                        "username": "buddyhuddy",
                        "content": "Is anyone else getting a Stack Overflow error when using Math.ceil on this problem? \\n\\nTest Case that is causing the Stack Overflow.\\npiles =\\n[312884470]\\nh =\\n312884469"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guy who added the test case no 118 has my respect doubled..\\n"
                    },
                    {
                        "username": "gs_1902",
                        "content": "// tle error help!!!!!!!!!!!!!!\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int max=piles[0];\\n         int sum=0;\\n         int j=1;\\n         for(int i=1;i<piles.size();i++)\\n            {\\n                if(piles[i]>max)\\n                max=piles[i];\\n            }\\n             while(j<max)\\n             {  sum=0;\\n                 for(int i=0;i<piles.size();i++)\\n                { if(piles[i]%j!=0)\\n                     sum=sum+(piles[i]/j)+1;\\n                     else\\n                       sum=sum+(piles[i]/j);\\n                }\\n                 if(sum==h)\\n                 break;\\n                 else\\n                 j++;\\n             }\\n        \\n        if(h==piles.size())\\n        return max;\\n        else\\n        return j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "0xatul",
                        "content": "Binary Search with both `high > low` and `high >= low`\\n\\n [Solution](https://leetcode.com/problems/koko-eating-bananas/solutions/2988144/using-both-low-high-and-low-high/) "
                    },
                    {
                        "username": "harsh_09__",
                        "content": "help me 1 testcase is not running\\n"
                    },
                    {
                        "username": "Mr_Amazing",
                        "content": "add this in top of your code. It worked for me.\n```\n\nif(piles[0]==805306368){\n   return 3;\n}\n\n```\n"
                    },
                    {
                        "username": "MahikaGarg",
                        "content": "[@Sridevinavin](/Sridevinavin) ...same test case is not running for my code too"
                    },
                    {
                        "username": "Sridevinavin",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\nIs this the above test case, I am also facing the same problem.Please reply me if you have found the solution."
                    }
                ]
            },
            {
                "id": 1825518,
                "content": [
                    {
                        "username": "AMerrill",
                        "content": "Copy Paste from yesterday?"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Welcome to the Binary search week!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This question is basically the same as yesterday, except a weirder scenario..."
                    },
                    {
                        "username": "iammsm",
                        "content": "MY CODE SHOWS RUNTIME ERROR : DIVISION BY ZERO\\nCAN YOU GUYS LOOK AT IT Why IT COMES and how to overcome \\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& piles,int h,int mid){\\n        long long int hourCount=0;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]<= mid) hourCount++;\\n            else{\\n                if(piles[i] % mid !=0){\\n                    hourCount+=(piles[i]/mid)+1;    }\\n                else hourCount+= piles[i]/mid;      }\\n        }\\n        return hourCount;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=0;  int sum=0;\\n        for(int i=0; i<piles.size() ;i++){\\n            sum+=piles[i];  }\\n        int high=sum;\\n        int k=-1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(isPossible(piles,h,mid)){\\n                k=mid;\\n                high=mid-1;     }\\n            else low=mid+1;\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "This question similar as\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/?envType=study-plan&id=binary-search-ii"
                    },
                    {
                        "username": "buddyhuddy",
                        "content": "Is anyone else getting a Stack Overflow error when using Math.ceil on this problem? \\n\\nTest Case that is causing the Stack Overflow.\\npiles =\\n[312884470]\\nh =\\n312884469"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guy who added the test case no 118 has my respect doubled..\\n"
                    },
                    {
                        "username": "gs_1902",
                        "content": "// tle error help!!!!!!!!!!!!!!\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int max=piles[0];\\n         int sum=0;\\n         int j=1;\\n         for(int i=1;i<piles.size();i++)\\n            {\\n                if(piles[i]>max)\\n                max=piles[i];\\n            }\\n             while(j<max)\\n             {  sum=0;\\n                 for(int i=0;i<piles.size();i++)\\n                { if(piles[i]%j!=0)\\n                     sum=sum+(piles[i]/j)+1;\\n                     else\\n                       sum=sum+(piles[i]/j);\\n                }\\n                 if(sum==h)\\n                 break;\\n                 else\\n                 j++;\\n             }\\n        \\n        if(h==piles.size())\\n        return max;\\n        else\\n        return j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "0xatul",
                        "content": "Binary Search with both `high > low` and `high >= low`\\n\\n [Solution](https://leetcode.com/problems/koko-eating-bananas/solutions/2988144/using-both-low-high-and-low-high/) "
                    },
                    {
                        "username": "harsh_09__",
                        "content": "help me 1 testcase is not running\\n"
                    },
                    {
                        "username": "Mr_Amazing",
                        "content": "add this in top of your code. It worked for me.\n```\n\nif(piles[0]==805306368){\n   return 3;\n}\n\n```\n"
                    },
                    {
                        "username": "MahikaGarg",
                        "content": "[@Sridevinavin](/Sridevinavin) ...same test case is not running for my code too"
                    },
                    {
                        "username": "Sridevinavin",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\nIs this the above test case, I am also facing the same problem.Please reply me if you have found the solution."
                    }
                ]
            },
            {
                "id": 1799402,
                "content": [
                    {
                        "username": "AMerrill",
                        "content": "Copy Paste from yesterday?"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Welcome to the Binary search week!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This question is basically the same as yesterday, except a weirder scenario..."
                    },
                    {
                        "username": "iammsm",
                        "content": "MY CODE SHOWS RUNTIME ERROR : DIVISION BY ZERO\\nCAN YOU GUYS LOOK AT IT Why IT COMES and how to overcome \\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& piles,int h,int mid){\\n        long long int hourCount=0;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]<= mid) hourCount++;\\n            else{\\n                if(piles[i] % mid !=0){\\n                    hourCount+=(piles[i]/mid)+1;    }\\n                else hourCount+= piles[i]/mid;      }\\n        }\\n        return hourCount;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=0;  int sum=0;\\n        for(int i=0; i<piles.size() ;i++){\\n            sum+=piles[i];  }\\n        int high=sum;\\n        int k=-1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(isPossible(piles,h,mid)){\\n                k=mid;\\n                high=mid-1;     }\\n            else low=mid+1;\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "This question similar as\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/?envType=study-plan&id=binary-search-ii"
                    },
                    {
                        "username": "buddyhuddy",
                        "content": "Is anyone else getting a Stack Overflow error when using Math.ceil on this problem? \\n\\nTest Case that is causing the Stack Overflow.\\npiles =\\n[312884470]\\nh =\\n312884469"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guy who added the test case no 118 has my respect doubled..\\n"
                    },
                    {
                        "username": "gs_1902",
                        "content": "// tle error help!!!!!!!!!!!!!!\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int max=piles[0];\\n         int sum=0;\\n         int j=1;\\n         for(int i=1;i<piles.size();i++)\\n            {\\n                if(piles[i]>max)\\n                max=piles[i];\\n            }\\n             while(j<max)\\n             {  sum=0;\\n                 for(int i=0;i<piles.size();i++)\\n                { if(piles[i]%j!=0)\\n                     sum=sum+(piles[i]/j)+1;\\n                     else\\n                       sum=sum+(piles[i]/j);\\n                }\\n                 if(sum==h)\\n                 break;\\n                 else\\n                 j++;\\n             }\\n        \\n        if(h==piles.size())\\n        return max;\\n        else\\n        return j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "0xatul",
                        "content": "Binary Search with both `high > low` and `high >= low`\\n\\n [Solution](https://leetcode.com/problems/koko-eating-bananas/solutions/2988144/using-both-low-high-and-low-high/) "
                    },
                    {
                        "username": "harsh_09__",
                        "content": "help me 1 testcase is not running\\n"
                    },
                    {
                        "username": "Mr_Amazing",
                        "content": "add this in top of your code. It worked for me.\n```\n\nif(piles[0]==805306368){\n   return 3;\n}\n\n```\n"
                    },
                    {
                        "username": "MahikaGarg",
                        "content": "[@Sridevinavin](/Sridevinavin) ...same test case is not running for my code too"
                    },
                    {
                        "username": "Sridevinavin",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\nIs this the above test case, I am also facing the same problem.Please reply me if you have found the solution."
                    }
                ]
            },
            {
                "id": 1798904,
                "content": [
                    {
                        "username": "AMerrill",
                        "content": "Copy Paste from yesterday?"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Welcome to the Binary search week!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This question is basically the same as yesterday, except a weirder scenario..."
                    },
                    {
                        "username": "iammsm",
                        "content": "MY CODE SHOWS RUNTIME ERROR : DIVISION BY ZERO\\nCAN YOU GUYS LOOK AT IT Why IT COMES and how to overcome \\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& piles,int h,int mid){\\n        long long int hourCount=0;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]<= mid) hourCount++;\\n            else{\\n                if(piles[i] % mid !=0){\\n                    hourCount+=(piles[i]/mid)+1;    }\\n                else hourCount+= piles[i]/mid;      }\\n        }\\n        return hourCount;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=0;  int sum=0;\\n        for(int i=0; i<piles.size() ;i++){\\n            sum+=piles[i];  }\\n        int high=sum;\\n        int k=-1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(isPossible(piles,h,mid)){\\n                k=mid;\\n                high=mid-1;     }\\n            else low=mid+1;\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "This question similar as\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/?envType=study-plan&id=binary-search-ii"
                    },
                    {
                        "username": "buddyhuddy",
                        "content": "Is anyone else getting a Stack Overflow error when using Math.ceil on this problem? \\n\\nTest Case that is causing the Stack Overflow.\\npiles =\\n[312884470]\\nh =\\n312884469"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guy who added the test case no 118 has my respect doubled..\\n"
                    },
                    {
                        "username": "gs_1902",
                        "content": "// tle error help!!!!!!!!!!!!!!\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int max=piles[0];\\n         int sum=0;\\n         int j=1;\\n         for(int i=1;i<piles.size();i++)\\n            {\\n                if(piles[i]>max)\\n                max=piles[i];\\n            }\\n             while(j<max)\\n             {  sum=0;\\n                 for(int i=0;i<piles.size();i++)\\n                { if(piles[i]%j!=0)\\n                     sum=sum+(piles[i]/j)+1;\\n                     else\\n                       sum=sum+(piles[i]/j);\\n                }\\n                 if(sum==h)\\n                 break;\\n                 else\\n                 j++;\\n             }\\n        \\n        if(h==piles.size())\\n        return max;\\n        else\\n        return j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "0xatul",
                        "content": "Binary Search with both `high > low` and `high >= low`\\n\\n [Solution](https://leetcode.com/problems/koko-eating-bananas/solutions/2988144/using-both-low-high-and-low-high/) "
                    },
                    {
                        "username": "harsh_09__",
                        "content": "help me 1 testcase is not running\\n"
                    },
                    {
                        "username": "Mr_Amazing",
                        "content": "add this in top of your code. It worked for me.\n```\n\nif(piles[0]==805306368){\n   return 3;\n}\n\n```\n"
                    },
                    {
                        "username": "MahikaGarg",
                        "content": "[@Sridevinavin](/Sridevinavin) ...same test case is not running for my code too"
                    },
                    {
                        "username": "Sridevinavin",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\nIs this the above test case, I am also facing the same problem.Please reply me if you have found the solution."
                    }
                ]
            },
            {
                "id": 1773897,
                "content": [
                    {
                        "username": "AMerrill",
                        "content": "Copy Paste from yesterday?"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Welcome to the Binary search week!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This question is basically the same as yesterday, except a weirder scenario..."
                    },
                    {
                        "username": "iammsm",
                        "content": "MY CODE SHOWS RUNTIME ERROR : DIVISION BY ZERO\\nCAN YOU GUYS LOOK AT IT Why IT COMES and how to overcome \\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& piles,int h,int mid){\\n        long long int hourCount=0;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]<= mid) hourCount++;\\n            else{\\n                if(piles[i] % mid !=0){\\n                    hourCount+=(piles[i]/mid)+1;    }\\n                else hourCount+= piles[i]/mid;      }\\n        }\\n        return hourCount;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=0;  int sum=0;\\n        for(int i=0; i<piles.size() ;i++){\\n            sum+=piles[i];  }\\n        int high=sum;\\n        int k=-1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(isPossible(piles,h,mid)){\\n                k=mid;\\n                high=mid-1;     }\\n            else low=mid+1;\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "This question similar as\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/?envType=study-plan&id=binary-search-ii"
                    },
                    {
                        "username": "buddyhuddy",
                        "content": "Is anyone else getting a Stack Overflow error when using Math.ceil on this problem? \\n\\nTest Case that is causing the Stack Overflow.\\npiles =\\n[312884470]\\nh =\\n312884469"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guy who added the test case no 118 has my respect doubled..\\n"
                    },
                    {
                        "username": "gs_1902",
                        "content": "// tle error help!!!!!!!!!!!!!!\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int max=piles[0];\\n         int sum=0;\\n         int j=1;\\n         for(int i=1;i<piles.size();i++)\\n            {\\n                if(piles[i]>max)\\n                max=piles[i];\\n            }\\n             while(j<max)\\n             {  sum=0;\\n                 for(int i=0;i<piles.size();i++)\\n                { if(piles[i]%j!=0)\\n                     sum=sum+(piles[i]/j)+1;\\n                     else\\n                       sum=sum+(piles[i]/j);\\n                }\\n                 if(sum==h)\\n                 break;\\n                 else\\n                 j++;\\n             }\\n        \\n        if(h==piles.size())\\n        return max;\\n        else\\n        return j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "0xatul",
                        "content": "Binary Search with both `high > low` and `high >= low`\\n\\n [Solution](https://leetcode.com/problems/koko-eating-bananas/solutions/2988144/using-both-low-high-and-low-high/) "
                    },
                    {
                        "username": "harsh_09__",
                        "content": "help me 1 testcase is not running\\n"
                    },
                    {
                        "username": "Mr_Amazing",
                        "content": "add this in top of your code. It worked for me.\n```\n\nif(piles[0]==805306368){\n   return 3;\n}\n\n```\n"
                    },
                    {
                        "username": "MahikaGarg",
                        "content": "[@Sridevinavin](/Sridevinavin) ...same test case is not running for my code too"
                    },
                    {
                        "username": "Sridevinavin",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\nIs this the above test case, I am also facing the same problem.Please reply me if you have found the solution."
                    }
                ]
            },
            {
                "id": 1741012,
                "content": [
                    {
                        "username": "AMerrill",
                        "content": "Copy Paste from yesterday?"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Welcome to the Binary search week!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This question is basically the same as yesterday, except a weirder scenario..."
                    },
                    {
                        "username": "iammsm",
                        "content": "MY CODE SHOWS RUNTIME ERROR : DIVISION BY ZERO\\nCAN YOU GUYS LOOK AT IT Why IT COMES and how to overcome \\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& piles,int h,int mid){\\n        long long int hourCount=0;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]<= mid) hourCount++;\\n            else{\\n                if(piles[i] % mid !=0){\\n                    hourCount+=(piles[i]/mid)+1;    }\\n                else hourCount+= piles[i]/mid;      }\\n        }\\n        return hourCount;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=0;  int sum=0;\\n        for(int i=0; i<piles.size() ;i++){\\n            sum+=piles[i];  }\\n        int high=sum;\\n        int k=-1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(isPossible(piles,h,mid)){\\n                k=mid;\\n                high=mid-1;     }\\n            else low=mid+1;\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "This question similar as\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/?envType=study-plan&id=binary-search-ii"
                    },
                    {
                        "username": "buddyhuddy",
                        "content": "Is anyone else getting a Stack Overflow error when using Math.ceil on this problem? \\n\\nTest Case that is causing the Stack Overflow.\\npiles =\\n[312884470]\\nh =\\n312884469"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guy who added the test case no 118 has my respect doubled..\\n"
                    },
                    {
                        "username": "gs_1902",
                        "content": "// tle error help!!!!!!!!!!!!!!\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int max=piles[0];\\n         int sum=0;\\n         int j=1;\\n         for(int i=1;i<piles.size();i++)\\n            {\\n                if(piles[i]>max)\\n                max=piles[i];\\n            }\\n             while(j<max)\\n             {  sum=0;\\n                 for(int i=0;i<piles.size();i++)\\n                { if(piles[i]%j!=0)\\n                     sum=sum+(piles[i]/j)+1;\\n                     else\\n                       sum=sum+(piles[i]/j);\\n                }\\n                 if(sum==h)\\n                 break;\\n                 else\\n                 j++;\\n             }\\n        \\n        if(h==piles.size())\\n        return max;\\n        else\\n        return j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "0xatul",
                        "content": "Binary Search with both `high > low` and `high >= low`\\n\\n [Solution](https://leetcode.com/problems/koko-eating-bananas/solutions/2988144/using-both-low-high-and-low-high/) "
                    },
                    {
                        "username": "harsh_09__",
                        "content": "help me 1 testcase is not running\\n"
                    },
                    {
                        "username": "Mr_Amazing",
                        "content": "add this in top of your code. It worked for me.\n```\n\nif(piles[0]==805306368){\n   return 3;\n}\n\n```\n"
                    },
                    {
                        "username": "MahikaGarg",
                        "content": "[@Sridevinavin](/Sridevinavin) ...same test case is not running for my code too"
                    },
                    {
                        "username": "Sridevinavin",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\nIs this the above test case, I am also facing the same problem.Please reply me if you have found the solution."
                    }
                ]
            },
            {
                "id": 1738596,
                "content": [
                    {
                        "username": "AMerrill",
                        "content": "Copy Paste from yesterday?"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Welcome to the Binary search week!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This question is basically the same as yesterday, except a weirder scenario..."
                    },
                    {
                        "username": "iammsm",
                        "content": "MY CODE SHOWS RUNTIME ERROR : DIVISION BY ZERO\\nCAN YOU GUYS LOOK AT IT Why IT COMES and how to overcome \\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& piles,int h,int mid){\\n        long long int hourCount=0;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]<= mid) hourCount++;\\n            else{\\n                if(piles[i] % mid !=0){\\n                    hourCount+=(piles[i]/mid)+1;    }\\n                else hourCount+= piles[i]/mid;      }\\n        }\\n        return hourCount;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=0;  int sum=0;\\n        for(int i=0; i<piles.size() ;i++){\\n            sum+=piles[i];  }\\n        int high=sum;\\n        int k=-1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(isPossible(piles,h,mid)){\\n                k=mid;\\n                high=mid-1;     }\\n            else low=mid+1;\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "This question similar as\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/?envType=study-plan&id=binary-search-ii"
                    },
                    {
                        "username": "buddyhuddy",
                        "content": "Is anyone else getting a Stack Overflow error when using Math.ceil on this problem? \\n\\nTest Case that is causing the Stack Overflow.\\npiles =\\n[312884470]\\nh =\\n312884469"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guy who added the test case no 118 has my respect doubled..\\n"
                    },
                    {
                        "username": "gs_1902",
                        "content": "// tle error help!!!!!!!!!!!!!!\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int max=piles[0];\\n         int sum=0;\\n         int j=1;\\n         for(int i=1;i<piles.size();i++)\\n            {\\n                if(piles[i]>max)\\n                max=piles[i];\\n            }\\n             while(j<max)\\n             {  sum=0;\\n                 for(int i=0;i<piles.size();i++)\\n                { if(piles[i]%j!=0)\\n                     sum=sum+(piles[i]/j)+1;\\n                     else\\n                       sum=sum+(piles[i]/j);\\n                }\\n                 if(sum==h)\\n                 break;\\n                 else\\n                 j++;\\n             }\\n        \\n        if(h==piles.size())\\n        return max;\\n        else\\n        return j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "0xatul",
                        "content": "Binary Search with both `high > low` and `high >= low`\\n\\n [Solution](https://leetcode.com/problems/koko-eating-bananas/solutions/2988144/using-both-low-high-and-low-high/) "
                    },
                    {
                        "username": "harsh_09__",
                        "content": "help me 1 testcase is not running\\n"
                    },
                    {
                        "username": "Mr_Amazing",
                        "content": "add this in top of your code. It worked for me.\n```\n\nif(piles[0]==805306368){\n   return 3;\n}\n\n```\n"
                    },
                    {
                        "username": "MahikaGarg",
                        "content": "[@Sridevinavin](/Sridevinavin) ...same test case is not running for my code too"
                    },
                    {
                        "username": "Sridevinavin",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\nIs this the above test case, I am also facing the same problem.Please reply me if you have found the solution."
                    }
                ]
            },
            {
                "id": 1687204,
                "content": [
                    {
                        "username": "AMerrill",
                        "content": "Copy Paste from yesterday?"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Welcome to the Binary search week!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This question is basically the same as yesterday, except a weirder scenario..."
                    },
                    {
                        "username": "iammsm",
                        "content": "MY CODE SHOWS RUNTIME ERROR : DIVISION BY ZERO\\nCAN YOU GUYS LOOK AT IT Why IT COMES and how to overcome \\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& piles,int h,int mid){\\n        long long int hourCount=0;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]<= mid) hourCount++;\\n            else{\\n                if(piles[i] % mid !=0){\\n                    hourCount+=(piles[i]/mid)+1;    }\\n                else hourCount+= piles[i]/mid;      }\\n        }\\n        return hourCount;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=0;  int sum=0;\\n        for(int i=0; i<piles.size() ;i++){\\n            sum+=piles[i];  }\\n        int high=sum;\\n        int k=-1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(isPossible(piles,h,mid)){\\n                k=mid;\\n                high=mid-1;     }\\n            else low=mid+1;\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "This question similar as\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/?envType=study-plan&id=binary-search-ii"
                    },
                    {
                        "username": "buddyhuddy",
                        "content": "Is anyone else getting a Stack Overflow error when using Math.ceil on this problem? \\n\\nTest Case that is causing the Stack Overflow.\\npiles =\\n[312884470]\\nh =\\n312884469"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guy who added the test case no 118 has my respect doubled..\\n"
                    },
                    {
                        "username": "gs_1902",
                        "content": "// tle error help!!!!!!!!!!!!!!\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int max=piles[0];\\n         int sum=0;\\n         int j=1;\\n         for(int i=1;i<piles.size();i++)\\n            {\\n                if(piles[i]>max)\\n                max=piles[i];\\n            }\\n             while(j<max)\\n             {  sum=0;\\n                 for(int i=0;i<piles.size();i++)\\n                { if(piles[i]%j!=0)\\n                     sum=sum+(piles[i]/j)+1;\\n                     else\\n                       sum=sum+(piles[i]/j);\\n                }\\n                 if(sum==h)\\n                 break;\\n                 else\\n                 j++;\\n             }\\n        \\n        if(h==piles.size())\\n        return max;\\n        else\\n        return j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "0xatul",
                        "content": "Binary Search with both `high > low` and `high >= low`\\n\\n [Solution](https://leetcode.com/problems/koko-eating-bananas/solutions/2988144/using-both-low-high-and-low-high/) "
                    },
                    {
                        "username": "harsh_09__",
                        "content": "help me 1 testcase is not running\\n"
                    },
                    {
                        "username": "Mr_Amazing",
                        "content": "add this in top of your code. It worked for me.\n```\n\nif(piles[0]==805306368){\n   return 3;\n}\n\n```\n"
                    },
                    {
                        "username": "MahikaGarg",
                        "content": "[@Sridevinavin](/Sridevinavin) ...same test case is not running for my code too"
                    },
                    {
                        "username": "Sridevinavin",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\nIs this the above test case, I am also facing the same problem.Please reply me if you have found the solution."
                    }
                ]
            }
        ]
    },
    {
        "title": "Cells with Odd Values in a Matrix",
        "question_content": "<p>There is an <code>m x n</code> matrix that is initialized to all <code>0</code>&#39;s. There is also a 2D array <code>indices</code> where each <code>indices[i] = [r<sub>i</sub>, c<sub>i</sub>]</code> represents a <strong>0-indexed location</strong> to perform some increment operations on the matrix.</p>\n\n<p>For each location <code>indices[i]</code>, do <strong>both</strong> of the following:</p>\n\n<ol>\n\t<li>Increment <strong>all</strong> the cells on row <code>r<sub>i</sub></code>.</li>\n\t<li>Increment <strong>all</strong> the cells on column <code>c<sub>i</sub></code>.</li>\n</ol>\n\n<p>Given <code>m</code>, <code>n</code>, and <code>indices</code>, return <em>the <strong>number of odd-valued cells</strong> in the matrix after applying the increment to all locations in </em><code>indices</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/10/30/e1.png\" style=\"width: 600px; height: 118px;\" />\n<pre>\n<strong>Input:</strong> m = 2, n = 3, indices = [[0,1],[1,1]]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> Initial matrix = [[0,0,0],[0,0,0]].\nAfter applying first increment it becomes [[1,2,1],[0,1,0]].\nThe final matrix is [[1,3,1],[1,3,1]], which contains 6 odd numbers.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/10/30/e2.png\" style=\"width: 600px; height: 150px;\" />\n<pre>\n<strong>Input:</strong> m = 2, n = 2, indices = [[1,1],[0,0]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Final matrix = [[2,2],[2,2]]. There are no odd numbers in the final matrix.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>1 &lt;= indices.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= r<sub>i</sub> &lt; m</code></li>\n\t<li><code>0 &lt;= c<sub>i</sub> &lt; n</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you solve this in <code>O(n + m + indices.length)</code> time with only <code>O(n + m)</code> extra space?</p>\n",
        "solutions": [
            {
                "id": 425100,
                "title": "java-python-3-2-methods-time-o-m-n-l-and-o-l-codes-w-comment-and-analysis",
                "content": "**Method 1:**\\n1. Count the rows and columns that appear odd times;\\n2. Traverse all cells to get the answer.\\n```java\\n    public int oddCells(int n, int m, int[][] indices) {\\n        boolean[] oddRows = new boolean[n], oddCols = new boolean[m];\\n        for (int[] idx : indices) {\\n            oddRows[idx[0]] ^= true; // if row idx[0] appears odd times, it will correspond to true.\\n            oddCols[idx[1]] ^= true; // if column idx[1] appears odd times, it will correspond to true.\\n        }\\n        int cnt = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                cnt += oddRows[i] ^ oddCols[j] ? 1 : 0; // only cell (i, j) with odd times count of row + column would get odd values.\\n            }\\n        }\\n        return cnt;\\n    }\\n```\\n```python\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        odd_rows, odd_cols = [False] * n, [False] * m\\n        for r, c in indices:\\n            odd_rows[r] ^= True\\n            odd_cols[c] ^= True\\n        return sum(ro ^ cl for ro in odd_rows for cl in odd_cols)\\n```\\n\\n**Analysis:**\\n\\nTime: O(m * n + L), space: O(m + n), where L = indices.length.\\n\\n----\\n\\n**Method 2:**\\nWe actually only care about the number of rows and columns with odd times of increments respectively.\\n1. Count the rows and columns that appear odd times;\\n2. Compute the number of cells in aforementioned rows and columns respectively, then both deduct the cells located on odd rows and odd columns (they become evens, because odd + odd results even).\\n**Note:** Easier alternative way for 2 is `odd_cols * even_rows + even_cols * odd_rows` -- credit to **@lenchen1112**.\\n```java\\n    public int oddCells(int n, int m, int[][] indices) {\\n        boolean[] oddRows = new boolean[n], oddCols = new boolean[m];\\n        int cntRow = 0, cntCol = 0;\\n        for (int[] idx : indices) {\\n            oddRows[idx[0]] ^= true;\\n            oddCols[idx[1]] ^= true;\\n        }\\n        for (boolean r : oddRows)\\n            cntRow += r ? 1 : 0;\\n        for (boolean c : oddCols)\\n            cntCol += c ? 1 : 0;\\n        // return m * cntRow + n * cntCol - 2 * cntRow * cntCol;\\n        return (m - cntCol) * cntRow + (n - cntRow) * cntCol;\\n    }\\n```\\n\\n```python\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        odd_rows, odd_cols = [False] * n, [False] * m\\n        for r, c in indices:\\n            odd_rows[r] ^= True\\n            odd_cols[c] ^= True\\n        # return m * sum(odd_rows) + n * sum(odd_cols) - 2 * sum(odd_rows) * sum(odd_cols)\\n        return (m - sum(odd_cols)) * sum(odd_rows) + (n - sum(odd_rows))* sum(odd_cols)\\n```\\n\\n**Analysis:**\\n\\nTime: O(L + m + n), space: O(m + n), where L = indices.length.\\n\\nor optimize the above further as follows:\\n```java\\n    public int oddCells(int n, int m, int[][] indices) {\\n        boolean[] oddRows = new boolean[n], oddCols = new boolean[m];\\n        int cntRow = 0, cntCol = 0;\\n        for (int[] idx : indices) {\\n            oddRows[idx[0]] ^= true;\\n            oddCols[idx[1]] ^= true;\\n            cntRow += oddRows[idx[0]] ? 1 : -1;\\n            cntCol += oddCols[idx[1]] ? 1 : -1;\\n        }\\n        // return m * cntRow + n * cntCol - 2 * cntRow * cntCol;\\n        return (m - cntCol) * cntRow + (n - cntRow) * cntCol;\\n    }\\n```\\n```python\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        odd_rows, odd_cols, cntRow, cntCol = [False] * n, [False] * m, 0, 0\\n        for r, c in indices:\\n            odd_rows[r] ^= True\\n            odd_cols[c] ^= True\\n            cntRow += 1 if odd_rows[r] else -1 \\n            cntCol += 1 if odd_cols[c] else -1 \\n        # return m * cntRow + n * cntCol - 2 * cntRow * cntCol\\n        return (m - cntCol) * cntRow + (n - cntRow) * cntCol\\n```\\n\\n**Analysis:**\\n\\nTime: O(L), space: O(m + n), where L = indices.length.\\n\\n----\\n\\nUse `BitSet`, credit to **@mishak**.\\n```java\\n    public int oddCells(int n, int m, int[][] indices) {\\n        BitSet oddRows = new BitSet(n), oddCols = new BitSet(m);\\n        int cntRow = 0, cntCol = 0;\\n        for (int[] idx : indices) {\\n            oddRows.flip(idx[0]);\\n            oddCols.flip(idx[1]);\\n            cntRow += oddRows.get(idx[0]) ? 1 : -1;\\n            cntCol += oddCols.get(idx[1]) ? 1 : -1;\\n        }\\n        return (m - cntCol) * cntRow + (n - cntRow) * cntCol;   \\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int oddCells(int n, int m, int[][] indices) {\\n        boolean[] oddRows = new boolean[n], oddCols = new boolean[m];\\n        for (int[] idx : indices) {\\n            oddRows[idx[0]] ^= true; // if row idx[0] appears odd times, it will correspond to true.\\n            oddCols[idx[1]] ^= true; // if column idx[1] appears odd times, it will correspond to true.\\n        }\\n        int cnt = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                cnt += oddRows[i] ^ oddCols[j] ? 1 : 0; // only cell (i, j) with odd times count of row + column would get odd values.\\n            }\\n        }\\n        return cnt;\\n    }\\n```\n```python\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        odd_rows, odd_cols = [False] * n, [False] * m\\n        for r, c in indices:\\n            odd_rows[r] ^= True\\n            odd_cols[c] ^= True\\n        return sum(ro ^ cl for ro in odd_rows for cl in odd_cols)\\n```\n```java\\n    public int oddCells(int n, int m, int[][] indices) {\\n        boolean[] oddRows = new boolean[n], oddCols = new boolean[m];\\n        int cntRow = 0, cntCol = 0;\\n        for (int[] idx : indices) {\\n            oddRows[idx[0]] ^= true;\\n            oddCols[idx[1]] ^= true;\\n        }\\n        for (boolean r : oddRows)\\n            cntRow += r ? 1 : 0;\\n        for (boolean c : oddCols)\\n            cntCol += c ? 1 : 0;\\n        // return m * cntRow + n * cntCol - 2 * cntRow * cntCol;\\n        return (m - cntCol) * cntRow + (n - cntRow) * cntCol;\\n    }\\n```\n```python\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        odd_rows, odd_cols = [False] * n, [False] * m\\n        for r, c in indices:\\n            odd_rows[r] ^= True\\n            odd_cols[c] ^= True\\n        # return m * sum(odd_rows) + n * sum(odd_cols) - 2 * sum(odd_rows) * sum(odd_cols)\\n        return (m - sum(odd_cols)) * sum(odd_rows) + (n - sum(odd_rows))* sum(odd_cols)\\n```\n```java\\n    public int oddCells(int n, int m, int[][] indices) {\\n        boolean[] oddRows = new boolean[n], oddCols = new boolean[m];\\n        int cntRow = 0, cntCol = 0;\\n        for (int[] idx : indices) {\\n            oddRows[idx[0]] ^= true;\\n            oddCols[idx[1]] ^= true;\\n            cntRow += oddRows[idx[0]] ? 1 : -1;\\n            cntCol += oddCols[idx[1]] ? 1 : -1;\\n        }\\n        // return m * cntRow + n * cntCol - 2 * cntRow * cntCol;\\n        return (m - cntCol) * cntRow + (n - cntRow) * cntCol;\\n    }\\n```\n```python\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        odd_rows, odd_cols, cntRow, cntCol = [False] * n, [False] * m, 0, 0\\n        for r, c in indices:\\n            odd_rows[r] ^= True\\n            odd_cols[c] ^= True\\n            cntRow += 1 if odd_rows[r] else -1 \\n            cntCol += 1 if odd_cols[c] else -1 \\n        # return m * cntRow + n * cntCol - 2 * cntRow * cntCol\\n        return (m - cntCol) * cntRow + (n - cntRow) * cntCol\\n```\n```java\\n    public int oddCells(int n, int m, int[][] indices) {\\n        BitSet oddRows = new BitSet(n), oddCols = new BitSet(m);\\n        int cntRow = 0, cntCol = 0;\\n        for (int[] idx : indices) {\\n            oddRows.flip(idx[0]);\\n            oddCols.flip(idx[1]);\\n            cntRow += oddRows.get(idx[0]) ? 1 : -1;\\n            cntCol += oddCols.get(idx[1]) ? 1 : -1;\\n        }\\n        return (m - cntCol) * cntRow + (n - cntRow) * cntCol;   \\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 431013,
                "title": "simple-fast-java-solution-with-explanation",
                "content": "Steps:\\n1) Count how many times each row and column is incremented using row and column array.\\n2) Add row and col value to get corresponding array element value.\\n3) If it\\'s odd increment counter\\n\\n\\n```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        int count = 0;\\n        int row[] = new int [n];\\n        int col[] = new int [m];\\n        for(int x[] : indices)\\n        {\\n            row[x[0]]++;\\n            col[x[1]]++;\\n        }    \\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n            {\\n                if((row[i]+col[j])%2!=0)\\n                    count++;\\n            }        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        int count = 0;\\n        int row[] = new int [n];\\n        int col[] = new int [m];\\n        for(int x[] : indices)\\n        {\\n            row[x[0]]++;\\n            col[x[1]]++;\\n        }    \\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n            {\\n                if((row[i]+col[j])%2!=0)\\n                    count++;\\n            }        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 426647,
                "title": "c-0ms-9-2mb-faster-than-100-and-uses-lesser-memory-than-100-submissions",
                "content": "This can be done in **O(m+n)** time and **O(m+n)** space \\nFirstly notice that the order in which we add 1 does not matter. You could add 1 to all rows and then proceed to adding 1 to all columns.\\n\\nNow suppose you add 1 to the same row twice, the resultant elements in that row are even. So applying the operation to the same row/col is as good as not applying anything there. \\n\\nApplying operation to a same row/col any odd number of times is as good as applying the operation only once.\\n\\nSo now suppose there are `r` such rows where you apply the operation odd number of times. And `c` such cols where you apply operation odd number of times.\\n\\nThen\\n\\n1. All `m` elements in each row are odd => `r*m`\\n2. All `n` elements in each row are odd => `c*n`\\n3. You double count `r*c` elements => `-1 * r * c`\\n4. Also, these `r*c` elements are even => `-1 * r * c`\\n\\nSo total odd elements is `r*m + c*n - 2*r*c`\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<bool> N(n, false);\\n        vector<bool> M(m, false);\\n        \\n        for(int i=0; i<indices.size(); i++) {\\n            N[indices[i][0]] = N[indices[i][0]]^true;\\n            M[indices[i][1]] = M[indices[i][1]]^true;\\n        }\\n        \\n        int r = 0;\\n        int c = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(N[i])\\n                r++;\\n        }\\n        \\n        for(int j=0; j<m; j++) {\\n            if(M[j])\\n                c++;\\n        }\\n        \\n        return  r*m + c*n - 2*r*c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<bool> N(n, false);\\n        vector<bool> M(m, false);\\n        \\n        for(int i=0; i<indices.size(); i++) {\\n            N[indices[i][0]] = N[indices[i][0]]^true;\\n            M[indices[i][1]] = M[indices[i][1]]^true;\\n        }\\n        \\n        int r = 0;\\n        int c = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(N[i])\\n                r++;\\n        }\\n        \\n        for(int j=0; j<m; j++) {\\n            if(M[j])\\n                c++;\\n        }\\n        \\n        return  r*m + c*n - 2*r*c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546912,
                "title": "python-explained-in-plain-english",
                "content": "```\\nclass Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        \\n        x,y = [0]*n,[0]*m\\n        #print(x)\\n        #print(y)\\n        for r,c in indices:\\n            x[r] += 1\\n            y[c] += 1\\n        #print(indices)\\n        #print(x)\\n        #print(y)\\n        return sum([ (r+c)%2 for c in y for r in x])  \\n```\\n\\nOk, I think I have an idea what they are trying to ask for, but it\\'s confusing. When you read it, please, open Example 1 in the Description of the task to follow it along.\\n\\nSo based on the description and most importantly based on the hints provided ...\\n\\nA brief summary would be - if you look at the example, effectively you need to make some operations on a 2d NxM matrix (calculate a sum of cell with odd values), so a brute force approach would be to create a NxM matrix, populate the cells based on the value of the indices array provided and calculate the sum - that would look exactly like the 3 matrix picture in that example. But it would require space of (NxM). Based on the hints, it look like they want you to calculate that sum more efficiently without constructing the whole matrix with all values and do it with less space instead.\\n\\nHow?\\n\\nOk, now follow the code above.\\n\\nI\\'m trying to literally follow the problem text sentence by sentence.\\n\\nStep 1:\\n`Given n and m which are the dimensions of a matrix initialized by zeros ` - this is done by :\\n\\n```\\nx,y = [0]*n,[0]*m\\n```\\n\\nThe output:\\n```\\nx: [0, 0]\\ny: [0, 0, 0]\\n```\\nThe indices values are:\\n```\\n[[0, 1], [1, 1]]\\n```\\n\\nStep 2:\\n`For each pair of [ri, ci] you have to increment all cells in row ri and column ci by 1.` \\nNow we do:\\n\\n```\\n        for r,c in indices:\\n            x[r] += 1\\n            y[c] += 1\\n```\\n\\nThe output:\\n```\\nx: [1, 1]\\ny: [0, 2, 0]\\n```\\nThis is the most important step, they key to this problem. If you look at the Example 1, they have the final matrix:\\n\\n```\\n1,3,1\\n1,3,1\\n```\\n so if you think about it, [1,1],[0,2,0] is just another representation of the same matrix. but instead of NxM numbers we only use N+M. So the higher N,M - the more efficiently that representation is.\\n \\n How to convert one into another? just as the description says `For each pair of [ri, ci] you have to increment all cells in row ri and column ci by 1.`\\n \\n For example, the top line is 1,3,1. if you look at `[1,1],[0,2,0] `, that means each value would have 1 plus the middle value would have 2 on top. Basically if you can see how `[1,1],[0,2,0] ` can represent (just add the + value for the row and the column to calculate each cell):\\n```\\n      +0 +2  +0\\n+1:   1,  3,  1\\n+1:   1,  3,  1\\n```\\nthe rest is trivial.\\n\\nStep 3:\\n\\n`Return the number of cells with odd values in the matrix after applying the increment to all indices.` \\n\\nNow we simply run a loop for all NxM cells:\\n\\n```\\n return sum([ (r+c)%2 for c in y for r in x]) \\n ```\\n and check if the value (it would be x[r] + y[c]) is odd or not by applying %2 and return the total.\\n \\n So if you just blindly follow the directions, it\\'s very easy to produce the result they are looking for. I think the hardest part is it is hard to imagine some real life activity behind this process. \\n \\n Ok, one more thing ... In some solutions instead of \\n \\n ```\\n             x[r] += 1\\n            y[c] += 1\\n```\\nyou\\'ll see:\\n\\n```\\n            x[r] ^= 1\\n            y[c] ^= 1\\n```\\n\\nWhat is it about?\\n \\nThe problem is asking to calculate the number of cells with odd values. So we don\\'t care what exactly the value is, all we need to know if it\\'s odd or even. That means instead of :\\n\\n```\\n1 3 1\\n1 3 1\\n```\\nwe can use:\\n```\\n1 1 1\\n1 1 1\\n```\\n\\nand instead of \\n```\\n2 3 1\\n2 3 1\\n```\\n\\n```\\n0 1 1\\n0 1 1\\n```\\n\\nbasically we just need to track the last bit of the value. So instead of incrementing values we can just use a bit operation to \"increment\" the last bit using `^= 1` instead of ` += 1`.\\n\\nIt doesn\\'t seem to affect performance specs much at this scale.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        \\n        x,y = [0]*n,[0]*m\\n        #print(x)\\n        #print(y)\\n        for r,c in indices:\\n            x[r] += 1\\n            y[c] += 1\\n        #print(indices)\\n        #print(x)\\n        #print(y)\\n        return sum([ (r+c)%2 for c in y for r in x])  \\n```\n```\\nx,y = [0]*n,[0]*m\\n```\n```\\nx: [0, 0]\\ny: [0, 0, 0]\\n```\n```\\n[[0, 1], [1, 1]]\\n```\n```\\n        for r,c in indices:\\n            x[r] += 1\\n            y[c] += 1\\n```\n```\\nx: [1, 1]\\ny: [0, 2, 0]\\n```\n```\\n1,3,1\\n1,3,1\\n```\n```\\n      +0 +2  +0\\n+1:   1,  3,  1\\n+1:   1,  3,  1\\n```\n```\\n return sum([ (r+c)%2 for c in y for r in x]) \\n ```\n```\\n             x[r] += 1\\n            y[c] += 1\\n```\n```\\n            x[r] ^= 1\\n            y[c] ^= 1\\n```\n```\\n1 3 1\\n1 3 1\\n```\n```\\n1 1 1\\n1 1 1\\n```\n```\\n2 3 1\\n2 3 1\\n```\n```\\n0 1 1\\n0 1 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425212,
                "title": "simple-python-solution",
                "content": "```\\nodd_count = 0\\nrows = [0] * n\\ncols = [0] * m\\n\\nfor i, j in indices:\\n\\trows[i] = rows[i] ^ 1\\n\\tcols[j] = cols[j] ^ 1\\n\\nfor i in range(n):\\n\\tfor j in range(m):\\n\\t\\tif(rows[i] ^ cols[j] == 1): odd_count += 1\\n\\nreturn odd_count\\n```",
                "solutionTags": [],
                "code": "```\\nodd_count = 0\\nrows = [0] * n\\ncols = [0] * m\\n\\nfor i, j in indices:\\n\\trows[i] = rows[i] ^ 1\\n\\tcols[j] = cols[j] ^ 1\\n\\nfor i in range(n):\\n\\tfor j in range(m):\\n\\t\\tif(rows[i] ^ cols[j] == 1): odd_count += 1\\n\\nreturn odd_count\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 618929,
                "title": "java-100-time-and-space-in-o-m-n-using-number-prop-boolean-arrays-with-detailed-explanation",
                "content": "* **Step 1**: You need to know how many times each row and coloumn are to be incremneted. Now the key is we dont want the eaxact number of time the row or col is implemented we just need to know is the incrementation was done even number of times or odd number of times. so instead of storing numbers have a **boolean array** when **Even means false** and **Odd means true** (because default value if false (for 0 count)) and eah time that index has to be incremented just toggel the prev value : make true->false and false->true as every even number when incremented becomes odd and odd becomes even\\n* **Step 2** :  Now we now that **odd+even=odd** | **even+odd=odd** | odd+odd=even | even+even=even. now our concern is only with the odd numbers so we only want all the combinations of **rowOdd x colEven and rowEven x colOdd** because all these combinations will generate odd numbers. \\n\\n```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        boolean []row =new boolean[n];\\n        boolean []col=new boolean[m];\\n\\t\\t\\n\\t\\t//------- calculating is the index count is even or odd-----\\n        for(int i=0;i<indices.length;i++){\\n            int a=indices[i][0];\\n            int b=indices[i][1];\\n            row[a]=!row[a];\\n            col[b]=!col[b];\\n        }\\n\\t\\t\\n        int rowEven=0;\\n        int colEven=0;\\n        int rowOdd=0;\\n        int colOdd=0;\\n\\t\\t\\n\\t\\t//-----counting number of odds and evens in a row----\\n        for(int i=0;i<n;i++){\\n            if(row[i]==true)\\n                rowOdd++;\\n            else\\n                rowEven++;\\n        }\\n\\t\\t\\n\\t\\t//-----counting number of odds and evens in a coloumn----\\n        for(int j=0;j<m;j++){\\n            if(col[j]==true)\\n                colOdd++;\\n            else\\n                colEven++;\\n        }\\n\\t\\t\\n\\t\\t//----all the combinations which generate odd number-----\\n        return rowEven*colOdd+rowOdd*colEven;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        boolean []row =new boolean[n];\\n        boolean []col=new boolean[m];\\n\\t\\t\\n\\t\\t//------- calculating is the index count is even or odd-----\\n        for(int i=0;i<indices.length;i++){\\n            int a=indices[i][0];\\n            int b=indices[i][1];\\n            row[a]=!row[a];\\n            col[b]=!col[b];\\n        }\\n\\t\\t\\n        int rowEven=0;\\n        int colEven=0;\\n        int rowOdd=0;\\n        int colOdd=0;\\n\\t\\t\\n\\t\\t//-----counting number of odds and evens in a row----\\n        for(int i=0;i<n;i++){\\n            if(row[i]==true)\\n                rowOdd++;\\n            else\\n                rowEven++;\\n        }\\n\\t\\t\\n\\t\\t//-----counting number of odds and evens in a coloumn----\\n        for(int j=0;j<m;j++){\\n            if(col[j]==true)\\n                colOdd++;\\n            else\\n                colEven++;\\n        }\\n\\t\\t\\n\\t\\t//----all the combinations which generate odd number-----\\n        return rowEven*colOdd+rowOdd*colEven;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428116,
                "title": "javascript-easy-to-understand-3-solutions",
                "content": "### SOLUTION 1\\n\\nIt\\'s a brute force way.\\n\\n1. We do all operations from the problem description to the matrix according to data in `indices`\\n2. Traversal the matrix to find the result\\n\\n```js\\nconst oddCells = (row, column, indices) => {\\n  const matrix = [];\\n  let ret = 0;\\n\\n  for (let i = 0; i < row; ++i) matrix[i] = new Uint8Array(column);\\n\\n  for (let i = 0; i < indices.length; ++i) {\\n    const [r, c] = indices[i];\\n    for (let j = 0; j < column; ++j) ++matrix[r][j];\\n    for (let j = 0; j < row; ++j) ++matrix[j][c];\\n  }\\n\\n  for (let i = 0; i < row; ++i) {\\n    for (let j = 0; j < column; ++j) {\\n      if (matrix[i][j] % 2 === 1) ++ret;\\n    }\\n  }\\n\\n  return ret;\\n};\\n```\\n\\nTime complexity: O(indices.length * (row + column) + row * column)\\nSpace complexity: O(row * column)\\n\\n### SOLUTION 2\\n\\nWe don\\'t need to do the operation for all cells. We just need to know the operation count for every row and column, and based on that, we can calculate whether each cell is odd.\\n\\n1. Traversal the indices and counting for every row and column\\n2. Traversal all the cells and check whether the value is odd\\n\\n```js\\nconst oddCells = (row, column, indices) => {\\n  const rowCount = new Uint8Array(row);\\n  const columnCount = new Uint8Array(column);\\n  let ret = 0;\\n\\n  for (let i = 0; i < indices.length; ++i) {\\n    ++rowCount[indices[i][0]];\\n    ++columnCount[indices[i][1]];\\n  }\\n\\n  for (let i = 0; i < row; ++i) {\\n    for (let j = 0; j < column; ++j) {\\n      ((rowCount[i] ^ columnCount[j]) & 1) === 1 && ++ret; // & 1 is to get the last bit\\n    }\\n  }\\n\\n  return ret;\\n};\\n```\\n\\nTime complexity: O(indices.length + row * column)\\nSpace complexity: O(row + column)\\n\\n### SOLUTION 3\\n\\nActually, we don\\'t need to care about which row is odd or which column is odd. To find the result, the only thing we need is that the odd row count and odd column count. And then, we calculate the result.\\n\\n```js\\nconst oddCells = (row, column, indices) => {\\n  const rowCount = new Uint8Array(row);\\n  const columnCount = new Uint8Array(column);\\n  let oddRow = 0;\\n  let oddColumn = 0;\\n\\n  for (let i = 0; i < indices.length; ++i) {\\n    (++rowCount[indices[i][0]] & 1) === 1 ? ++oddRow : --oddRow;\\n    (++columnCount[indices[i][1]] & 1) === 1 ? ++oddColumn : --oddColumn;\\n  }\\n\\n  return oddRow * column + oddColumn * row - 2 * oddRow * oddColumn; // for detail explanation, please see. the comment\\n};\\n```\\n\\nTime complexity: O(indices.length)\\nSpace complexity: O(row + column)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst oddCells = (row, column, indices) => {\\n  const matrix = [];\\n  let ret = 0;\\n\\n  for (let i = 0; i < row; ++i) matrix[i] = new Uint8Array(column);\\n\\n  for (let i = 0; i < indices.length; ++i) {\\n    const [r, c] = indices[i];\\n    for (let j = 0; j < column; ++j) ++matrix[r][j];\\n    for (let j = 0; j < row; ++j) ++matrix[j][c];\\n  }\\n\\n  for (let i = 0; i < row; ++i) {\\n    for (let j = 0; j < column; ++j) {\\n      if (matrix[i][j] % 2 === 1) ++ret;\\n    }\\n  }\\n\\n  return ret;\\n};\\n```\n```js\\nconst oddCells = (row, column, indices) => {\\n  const rowCount = new Uint8Array(row);\\n  const columnCount = new Uint8Array(column);\\n  let ret = 0;\\n\\n  for (let i = 0; i < indices.length; ++i) {\\n    ++rowCount[indices[i][0]];\\n    ++columnCount[indices[i][1]];\\n  }\\n\\n  for (let i = 0; i < row; ++i) {\\n    for (let j = 0; j < column; ++j) {\\n      ((rowCount[i] ^ columnCount[j]) & 1) === 1 && ++ret; // & 1 is to get the last bit\\n    }\\n  }\\n\\n  return ret;\\n};\\n```\n```js\\nconst oddCells = (row, column, indices) => {\\n  const rowCount = new Uint8Array(row);\\n  const columnCount = new Uint8Array(column);\\n  let oddRow = 0;\\n  let oddColumn = 0;\\n\\n  for (let i = 0; i < indices.length; ++i) {\\n    (++rowCount[indices[i][0]] & 1) === 1 ? ++oddRow : --oddRow;\\n    (++columnCount[indices[i][1]] & 1) === 1 ? ++oddColumn : --oddColumn;\\n  }\\n\\n  return oddRow * column + oddColumn * row - 2 * oddRow * oddColumn; // for detail explanation, please see. the comment\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 425290,
                "title": "c-bool-simulation",
                "content": "```\\nint oddCells(int n, int m, vector<vector<int>>& indices) {\\n  vector<vector<bool>> mt(n, vector<bool>(m));\\n  for (auto& idx : indices) {\\n    auto r = idx[0], c = idx[1];\\n    for (auto i = 0; i < n; ++i) mt[i][c] = !mt[i][c];\\n    for (auto j = 0; j < m; ++j) mt[r][j] = !mt[r][j];\\n  }\\n  return accumulate(begin(mt), end(mt), 0, [](int s, vector<bool>& r) {\\n    return s + accumulate(begin(r), end(r), 0); });\\n}\\n```\\nNow, as you work on the solution, you migth get an insight that you are flipping the same bits multiple times. So, intead of modifying `n + m` bits for every index, we may just track whether a column or row is \\'flipped\\' or not.\\n\\n```cpp\\nint oddCells(int n, int m, vector<vector<int>>& indices, int res = 0) {\\n  vector<bool> rows(n), cols(m);\\n  for (auto& idx : indices)\\n    rows[idx[0]] = !rows[idx[0]], cols[idx[1]] = !cols[idx[1]];\\n  for (auto i = 0; i < n; ++i)\\n    for (auto j = 0; j < m; ++j)\\n      res += rows[i] ^ cols[j];\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint oddCells(int n, int m, vector<vector<int>>& indices) {\\n  vector<vector<bool>> mt(n, vector<bool>(m));\\n  for (auto& idx : indices) {\\n    auto r = idx[0], c = idx[1];\\n    for (auto i = 0; i < n; ++i) mt[i][c] = !mt[i][c];\\n    for (auto j = 0; j < m; ++j) mt[r][j] = !mt[r][j];\\n  }\\n  return accumulate(begin(mt), end(mt), 0, [](int s, vector<bool>& r) {\\n    return s + accumulate(begin(r), end(r), 0); });\\n}\\n```\n```cpp\\nint oddCells(int n, int m, vector<vector<int>>& indices, int res = 0) {\\n  vector<bool> rows(n), cols(m);\\n  for (auto& idx : indices)\\n    rows[idx[0]] = !rows[idx[0]], cols[idx[1]] = !cols[idx[1]];\\n  for (auto i = 0; i < n; ++i)\\n    for (auto j = 0; j < m; ++j)\\n      res += rows[i] ^ cols[j];\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 841127,
                "title": "python3-math-solution-beats-99-32-ms-13-9-mb",
                "content": "```\\nclass Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        row, col = [0] * n, [0] * m\\n\\t\\tfor [i,j] in indices:      # determine pivot rows/cols\\n            row[i] ^= 1\\n            col[j] ^= 1 \\n        R, C = sum(row), sum(col)  # count # of pivot rows/cols\\n        return R*m + C*n - 2*R*C   # inclusion-exclusion\\n```\\nFirst observe that we only need to keep track of the entries of the matrix mod 2 and then count the number of 1\\'s that occur. Next observe that rows and columns can be treated independently i.e. updating the matrix  can be done by incrementing the row/col by 1 (mod 2) in either order (row first then col or vice versa). Let\\'s call this *\"incrementing by 1 (mod 2)\"* process a **flip** since it changes each 0 to a 1 and vice versa in the respective row or col. \\n\\nNow here\\'s the key observation: The entire process doesn\\'t have to be simulated, instead we can just figure out which rows/cols occur an odd number of times and then just flip those rows/cols once each. This will result in the same final matrix (mod 2) as the full simulation. To see this, note that two flips of a row cancel out, so only an odd number of flips results in a cumulative change. Let\\'s call a row/col that occurs an odd number of times a **pivot**.\\n\\nArmed with this observation, we determine which rows/cols are pivots in the for loop by incrementing by 1 mod 2 each time we see that row/col (this is done using the ^ operator which is XOR and so is equivalent). We denote the number of pivot rows/cols by ```R``` and ```C``` respectively.\\n\\nIgnoring interactions between rows/cols, we note that flipping all cells in all the pivot rows results in ```R*m``` 1\\'s and flipping all the cells in each pivot col results in ```C*n``` 1\\'s. Without considering the interactions, this would lead to ```R*m + C*n``` 1\\'s. To account for the interaction, we need to realize that there are ```R*C``` cells which lie on both a pivot col and a pivot row. Thus we subtract by ```2*R*C``` to correct for double counting those cells when they shouldn\\'t contribute at all (they will be 0). \\n\\nThus, the final output is ```R*m + C*n - 2*R*C```.\\n\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        row, col = [0] * n, [0] * m\\n\\t\\tfor [i,j] in indices:      # determine pivot rows/cols\\n            row[i] ^= 1\\n            col[j] ^= 1 \\n        R, C = sum(row), sum(col)  # count # of pivot rows/cols\\n        return R*m + C*n - 2*R*C   # inclusion-exclusion\\n```\n```R```\n```C```\n```R*m```\n```C*n```\n```R*m + C*n```\n```R*C```\n```2*R*C```\n```R*m + C*n - 2*R*C```",
                "codeTag": "Java"
            },
            {
                "id": 3093489,
                "title": "o-m-n-indicessize-beats-100-with-simple-mathematical-calculations-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to count the cells that are incremented odd number of times. The `indices` can be though of as a list of rows and columns to be incremented, represented by 0th and 1st index respectively.\\n\\nLets consider our row list as list of `0th` element of each `indices` element.\\ncolumn list as list of `1st` element of each `indices` element.\\n\\nThere are four categories of cells. For a cell `[i, j]` it can be \\n    1. Not incremented at all. `i` does not belong to the row list and `j` does not belong the columns list. This has no contribution in the final odd count.\\n    2. Only incremented through some row increment operation.  `i` belongs to the row list but `j` does not belong to the columns list. \\n    3. Only incremented through some column increment operation.  `i` does not belong to the row list but `j` belongs to the columns list\\n    4. Incremented both by row and column increment operations. `i` belongs to the row list and `j` belongs to the columns list. These will contribute if overall increment is odd number of times.\\n\\nAny rows or columns incremented even number of times will not have any effect on the number of odd cells.\\n\\n# Approach\\n\\nFirst compute the number of rows that are incremented odd number of times through row increment operations. It is simply finding the frequency of each row index in the row list. Total number of such cells will be `m` times the number of such rows.\\n\\nNext find the number of columns incremented odd number of times through the column increment operations. Total number of such cells will be `n` times the number of such columns.\\n\\nFinally intersection of such rows and columns have to be subtracted 2 times because they will become even after incrementing odd times both through columns and through rows. 2 times because these are added in both row and column increment computation.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(m + n + indicesSize)$$ we have to iterate once through the indices, once through rows frequency and once through columns frequency. \\n\\n- Space complexity:\\n$$O(m + n)$$ for storing the frequencies.\\n\\n# Code\\n```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        //Freq of rows and columns to be incremented\\n        int[] r = new int[m];\\n        int[] c = new int[n];\\n\\n        for (int i = 0 ; i < indices.length; i++) {\\n            r[indices[i][0]]++;\\n            c[indices[i][1]]++;\\n        }\\n\\n        //Count odd rows\\n        int oddRows = 0;\\n        for(int i =0; i < m; i++) {\\n            if(r[i]%2 == 1) {\\n                oddRows++;\\n            }            \\n        }\\n        \\n        //count odd columns\\n        int oddColumns = 0;\\n        for(int i =0; i < n; i++){ \\n            if(c[i]%2 == 1) {\\n                oddColumns++;\\n            }\\n        }\\n\\n        //return Final value\\n        return oddRows * n + oddColumns * m - 2*oddRows*oddColumns;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        //Freq of rows and columns to be incremented\\n        int[] r = new int[m];\\n        int[] c = new int[n];\\n\\n        for (int i = 0 ; i < indices.length; i++) {\\n            r[indices[i][0]]++;\\n            c[indices[i][1]]++;\\n        }\\n\\n        //Count odd rows\\n        int oddRows = 0;\\n        for(int i =0; i < m; i++) {\\n            if(r[i]%2 == 1) {\\n                oddRows++;\\n            }            \\n        }\\n        \\n        //count odd columns\\n        int oddColumns = 0;\\n        for(int i =0; i < n; i++){ \\n            if(c[i]%2 == 1) {\\n                oddColumns++;\\n            }\\n        }\\n\\n        //return Final value\\n        return oddRows * n + oddColumns * m - 2*oddRows*oddColumns;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662066,
                "title": "java-two-approaches",
                "content": "Kindly upvote, if it helps you!\\n```\\nBrute Force Approach-\\n public int oddCells(int m, int n, int[][] indices) {\\n        int[][] mat = new int[m][n];\\n        for(int i=0; i<indices.length; i++){\\n                //increment all the cells on row\\n                   int row = indices[i][0]; \\n                   for(int k=0; k<n; k++){\\n                       mat[row][k]++;\\n                   } \\n                //increment all the cells on column\\n                    int col = indices[i][1];\\n                    for(int k=0; k<m; k++){\\n                        mat[k][col]++;\\n                    }\\n        }\\n        int count =0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(mat[i][j]%2 != 0)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\t\\nSecond Approach-\\npublic int oddCells(int m, int n, int[][] indices) {\\n        int[] row = new int[m];\\n        int[] col = new int[n];\\n        for(int[] ind : indices){\\n            row[ind[0]]++;\\n            col[ind[1]]++;\\n        }\\n        int count =0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if((row[i]+col[j])%2 != 0)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "Kindly upvote, if it helps you!\\n```\\nBrute Force Approach-\\n public int oddCells(int m, int n, int[][] indices) {\\n        int[][] mat = new int[m][n];\\n        for(int i=0; i<indices.length; i++){\\n                //increment all the cells on row\\n                   int row = indices[i][0]; \\n                   for(int k=0; k<n; k++){\\n                       mat[row][k]++;\\n                   } \\n                //increment all the cells on column\\n                    int col = indices[i][1];\\n                    for(int k=0; k<m; k++){\\n                        mat[k][col]++;\\n                    }\\n        }\\n        int count =0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(mat[i][j]%2 != 0)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\t\\nSecond Approach-\\npublic int oddCells(int m, int n, int[][] indices) {\\n        int[] row = new int[m];\\n        int[] col = new int[n];\\n        for(int[] ind : indices){\\n            row[ind[0]]++;\\n            col[ind[1]]++;\\n        }\\n        int count =0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if((row[i]+col[j])%2 != 0)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 461300,
                "title": "java-o-n-m-educational-edition",
                "content": "```\\nclass Solution {\\n    /**\\n    * The idea is following: since we increment whole rows/columns at once there is no need\\n    * to keep the matrix model and insted we can have 2 separate arrays for rows[n] and columns[m].\\n    * \\n    * By iterating through the indices array we\\'ll be incrementing corresponding values for rows and columns in\\n    * their dedicated arrays.\\n    *\\n    * The second important thing - how to interpret those and see which numbers we\\'ll have? For those purposes we\\'ll\\n    * be using several things:\\n    * 0. Imagine our matrix as a linear array where all the rows go one after another (quite common practice to\\n    *    display multi-dimensional data structures) so that n=0 would mean first m elements, then n=1 -> next m \\n    *    elemenst and so on.\\n    * 1. overall matrix size (or number of numbers if you like) -> n*m\\n    * 2. the fact that by updating the row array by 1, we\\'re updating the whole row to 1\\n    *    e.g. if we have n=2 and m=3, then 1 row updated to 1 would mean first 3 numbers in the matrix are 1s\\n    * 3. Similar goes for the columns -> +1 to columns at a specific index means we\\'re updating every m-th element in\\n    *    that imaginary matrix to +1\\n    */\\n    public int oddCells(int n, int m, int[][] indices) {\\n            int[] rows = new int[n];\\n            int[] columns = new int [m];\\n        \\n            //Updating the corresponding arrays in O(n)\\n            //here we\\'ll keep track of the updates for each row and column\\n            //based on indices array\\n            for(int ind=0; ind<indices.length; ind++){\\n                rows[indices[ind][0]] ++;\\n                columns[indices[ind][1]] ++;\\n            }\\n        \\n        \\n            //Now the fun part - interpreting which numbers we have in result.\\n            //Starting from rows array. As you remember, it shows which rows were incremented and how many times.\\n            //e.g. [2, 1] would say `first row was incremented twice so we now have all dueces there and\\n            // the second one we\\'ve incremented only once - so all the elements will be 1s`\\n        \\n            int oddNumbers = 0;\\n            int matrixSize = n*m;\\n            for(int i=0; i<matrixSize; i++){\\n                \\n                int rowsIncrementIndex = i/m; //e.g. 0,0,0,1,1,1\\n                int colsIncrementIndex = i%m; //e.g. 0,1,2,0,1,2\\n                \\n                //then we\\'ll be iterating through n*m numbers in total \\n                //the rows[0] would display how we should update our first `n` numbers\\n                //the cols[0] - how we additionally should update every `m`-th number\\n                //so in order to get the information on how to update this particular number by its index\\n                //we can use such calculations (notice how we don\\'t really need n value there):\\n                //if i is the current index, then `i/m` would let us get the value from rows array\\n                //and the `i%m` - for the columns. Then we just sum those 2 values to get the current number in\\n                //the matrix which, in turn, we don\\'t really need to put anything and just increment our oddNumbers\\n                //if it is actuall odd.\\n                //\\n                //e.g. let\\'s go over some example iterations\\n                //     consider our rows are [2, 1] and columns are [1,0,1]\\n                //i=0  ->  row_index = i/3 = 0;  col_index = i%3 =0; -> 2 + 1 = 3; -> oddNumbers++\\n                //i=1  ->  row_index = i/3 = 0;  col_index = i%3 =1; -> 2 + 0 = 2;\\n                //i=2  ->  row_index = i/3 = 0;  col_index = i%3 =2; -> 2 + 1 = 3; -> oddNumbers++\\n                //i=3  ->  row_index = i/3 = 1;  col_index = i%3 =0; -> 1 + 1 = 2;\\n                //i=4  ->  row_index = i/3 = 1;  col_index = i%3 =1; -> 1 + 2 = 1; -> oddNumbers++\\n                //i=5  ->  row_index = i/3 = 1;  col_index = i%3 =2; -> 1 + 1 = 2;\\n                //\\n                //and the result: oddNumbers==3\\n                if((rows[rowsIncrementIndex] + columns[colsIncrementIndex]) %2 == 1) {\\n                    oddNumbers++;\\n                }\\n            }\\n            return oddNumbers;\\n    }\\n\\t```\\n}",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /**\\n    * The idea is following: since we increment whole rows/columns at once there is no need\\n    * to keep the matrix model and insted we can have 2 separate arrays for rows[n] and columns[m].\\n    * \\n    * By iterating through the indices array we\\'ll be incrementing corresponding values for rows and columns in\\n    * their dedicated arrays.\\n    *\\n    * The second important thing - how to interpret those and see which numbers we\\'ll have? For those purposes we\\'ll\\n    * be using several things:\\n    * 0. Imagine our matrix as a linear array where all the rows go one after another (quite common practice to\\n    *    display multi-dimensional data structures) so that n=0 would mean first m elements, then n=1 -> next m \\n    *    elemenst and so on.\\n    * 1. overall matrix size (or number of numbers if you like) -> n*m\\n    * 2. the fact that by updating the row array by 1, we\\'re updating the whole row to 1\\n    *    e.g. if we have n=2 and m=3, then 1 row updated to 1 would mean first 3 numbers in the matrix are 1s\\n    * 3. Similar goes for the columns -> +1 to columns at a specific index means we\\'re updating every m-th element in\\n    *    that imaginary matrix to +1\\n    */\\n    public int oddCells(int n, int m, int[][] indices) {\\n            int[] rows = new int[n];\\n            int[] columns = new int [m];\\n        \\n            //Updating the corresponding arrays in O(n)\\n            //here we\\'ll keep track of the updates for each row and column\\n            //based on indices array\\n            for(int ind=0; ind<indices.length; ind++){\\n                rows[indices[ind][0]] ++;\\n                columns[indices[ind][1]] ++;\\n            }\\n        \\n        \\n            //Now the fun part - interpreting which numbers we have in result.\\n            //Starting from rows array. As you remember, it shows which rows were incremented and how many times.\\n            //e.g. [2, 1] would say `first row was incremented twice so we now have all dueces there and\\n            // the second one we\\'ve incremented only once - so all the elements will be 1s`\\n        \\n            int oddNumbers = 0;\\n            int matrixSize = n*m;\\n            for(int i=0; i<matrixSize; i++){\\n                \\n                int rowsIncrementIndex = i/m; //e.g. 0,0,0,1,1,1\\n                int colsIncrementIndex = i%m; //e.g. 0,1,2,0,1,2\\n                \\n                //then we\\'ll be iterating through n*m numbers in total \\n                //the rows[0] would display how we should update our first `n` numbers\\n                //the cols[0] - how we additionally should update every `m`-th number\\n                //so in order to get the information on how to update this particular number by its index\\n                //we can use such calculations (notice how we don\\'t really need n value there):\\n                //if i is the current index, then `i/m` would let us get the value from rows array\\n                //and the `i%m` - for the columns. Then we just sum those 2 values to get the current number in\\n                //the matrix which, in turn, we don\\'t really need to put anything and just increment our oddNumbers\\n                //if it is actuall odd.\\n                //\\n                //e.g. let\\'s go over some example iterations\\n                //     consider our rows are [2, 1] and columns are [1,0,1]\\n                //i=0  ->  row_index = i/3 = 0;  col_index = i%3 =0; -> 2 + 1 = 3; -> oddNumbers++\\n                //i=1  ->  row_index = i/3 = 0;  col_index = i%3 =1; -> 2 + 0 = 2;\\n                //i=2  ->  row_index = i/3 = 0;  col_index = i%3 =2; -> 2 + 1 = 3; -> oddNumbers++\\n                //i=3  ->  row_index = i/3 = 1;  col_index = i%3 =0; -> 1 + 1 = 2;\\n                //i=4  ->  row_index = i/3 = 1;  col_index = i%3 =1; -> 1 + 2 = 1; -> oddNumbers++\\n                //i=5  ->  row_index = i/3 = 1;  col_index = i%3 =2; -> 1 + 1 = 2;\\n                //\\n                //and the result: oddNumbers==3\\n                if((rows[rowsIncrementIndex] + columns[colsIncrementIndex]) %2 == 1) {\\n                    oddNumbers++;\\n                }\\n            }\\n            return oddNumbers;\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1024137,
                "title": "java-solution-beats-100-time-without-using-hashmaps",
                "content": "A naive solution is to initialize the array of zeros and increment that based on the **indices** array.\\n\\nInstead of that, in this solution, I have created two arrays representing rows and columns of the resulting array. Incremented those indices of **rows** and **columns** array which the **indices** array tells us to.\\n\\nFinally, added the values of **rows** and **columns** array in matrix fashion(i.e., rows[i] + columns[j]) and checked if it is odd. Returned total odd occurrences as the solution.\\n\\n```\\npublic int oddCells(int n, int m, int[][] indices) {\\n        int[] rows = new int[n]; //array to hold increments in rows\\n        int[] columns = new int[m]; //array to hold increments in columns\\n        \\n        for(int i = 0; i < indices.length; i++){\\n            rows[indices[i][0]] += 1;   //increment the indices of rows array based on \"indices\" array\\n            columns[indices[i][1]] += 1; //increment the indices of columns array based on \"indices\" array\\n        }\\n        \\n        int odds = 0;\\n        for(int i = 0; i < rows.length; i++){\\n            for(int j = 0; j < columns.length; j++){\\n                if((rows[i] + columns[j]) % 2 != 0){ //adding rows[i] and columns[j] will give the value in final array. check whether it is odd or even\\n                    odds += 1; \\n                }\\n            }\\n        }\\n        return odds;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int oddCells(int n, int m, int[][] indices) {\\n        int[] rows = new int[n]; //array to hold increments in rows\\n        int[] columns = new int[m]; //array to hold increments in columns\\n        \\n        for(int i = 0; i < indices.length; i++){\\n            rows[indices[i][0]] += 1;   //increment the indices of rows array based on \"indices\" array\\n            columns[indices[i][1]] += 1; //increment the indices of columns array based on \"indices\" array\\n        }\\n        \\n        int odds = 0;\\n        for(int i = 0; i < rows.length; i++){\\n            for(int j = 0; j < columns.length; j++){\\n                if((rows[i] + columns[j]) % 2 != 0){ //adding rows[i] and columns[j] will give the value in final array. check whether it is odd or even\\n                    odds += 1; \\n                }\\n            }\\n        }\\n        return odds;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 572636,
                "title": "python-clean-solution",
                "content": "```python\\nclass Solution:\\n    \\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        \\n        matrix = [[0 for i in range(m)] for j in range(n)] \\n        \\n        def inc(x, y):\\n            \\n            for i in range(m):\\n                matrix[x][i] += 1\\n            \\n            for i in range(n):\\n                matrix[i][y] += 1\\n                \\n        for ind in indices:\\n            inc(ind[0], ind[1])\\n            \\n            \\n        return sum([0 if n % 2 == 0 else 1 for l in matrix for n in l])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    \\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        \\n        matrix = [[0 for i in range(m)] for j in range(n)] \\n        \\n        def inc(x, y):\\n            \\n            for i in range(m):\\n                matrix[x][i] += 1\\n            \\n            for i in range(n):\\n                matrix[i][y] += 1\\n                \\n        for ind in indices:\\n            inc(ind[0], ind[1])\\n            \\n            \\n        return sum([0 if n % 2 == 0 else 1 for l in matrix for n in l])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472649,
                "title": "100-00-efficient-in-memory-and-faster-in-runtime-c-solution",
                "content": "/// Don\\'t have time to arrange this- learning stl, i compared and pushing the whole. Extract meaningful from this and ignore duplicate approaches \\n\\n------\\nRuntime: 4 ms, faster than 82.62% of C++ online submissions for Cells with Odd Values in a Matrix.\\nMemory Usage: 9.3 MB, less than 100.00% of C++ online submissions for Cells with Odd Values in a Matrix.\\nThis can be done in **O(m+n)** time and **O(m+n)** space\\nFirstly notice that the order in which we add 1 does not matter. You could add 1 to all rows and then proceed to adding 1 to all columns.\\nNow suppose you add 1 to the same row twice, the resultant elements in that row are even. So applying the operation to the same row/col is as good as not applying anything there.\\nApplying operation to a same row/col any odd number of times is as good as applying the operation only once.\\nSo now suppose there are r such rows where you apply the operation odd number of times. And c such cols where you apply operation odd number of times.\\nAll m elements in each row are odd => r*m\\nAll n elements in each row are odd => c*n\\nYou double count r*c elements => -1 * r * c\\nAlso, these r*c elements are even => -1 * r * c\\n\\n```\\nstatic int x = []() {\\nstd::ios::sync_with_stdio(false);\\ncin.tie(nullptr);\\nreturn 0; }();\\n\\nclass Solution { // tc: O(n+m) & sc: O(n+m)\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<bool> rows(n,false),cols(m,false);\\n        for(auto index: indices){\\n            rows[index[0]] = rows[index[0]] ^ true;\\n            cols[index[1]] = cols[index[1]] ^ true;\\n        }\\n        \\n        int r(0),c(0);\\n        for(int i(0);i<n;i++){\\n            if(rows[i]) r++;\\n        }\\n        \\n        for(int i(0);i<m;i++){\\n            if(cols[i]) c++;\\n        }\\n        return r*(m-c) + c*(n-r); // (or) return (r*m + c*n - 2*r*c);\\n    }\\n};\\n```\\nRuntime: 8 ms, faster than 28.45% of C++ online submissions for Cells with Odd Values in a Matrix.\\nMemory Usage: 9.5 MB, less than 100.00% of C++ online submissions for Cells with Odd Values in a Matrix.\\n\\n------\\nWe only have to care if we have a line crossing a row or a column.\\n\\n```\\nclass Solution { // without manipulating array\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        int oddCellsCount(0);\\n        unordered_set<int> rows;\\n        unordered_set<int> cols;\\n        \\n        for(auto index: indices){\\n            if(rows.count(index[0])==0) rows.insert(index[0]);\\n            else rows.erase(index[0]); // remove row as it has been flipped back to even\\n            \\n            if(cols.count(index[1])==0) cols.insert(index[1]);\\n            else cols.erase(index[1]);  // remove col as it has been flipped back to even\\n        }\\n        \\n// Where flipped rows and columns cross, that number remains even.\\n//i.e. The number of odds corresponds to - (the product of odd rows and number of columns that haven\\'t been flipped), added to (the product of odd columns and number of rows that haven\\'t been flipped).\\n        \\n        return rows.size()*(m-cols.size()) + cols.size()*(n-rows.size());\\n        \\n        // i.e. return (r*m + c*n - 2*r*c);\\n    }\\n};\\n```\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        int row[n] = {0}, colm[m] = {0};\\n        for(auto pair : indices){\\n            row[pair[0]] ++;\\n            colm[pair[1]] ++;\\n        }\\n        int even_row = 0, even_colm = 0; \\n        for(auto num : row){\\n            if(num % 2 == 0) even_row++; //count the number of even row\\n        }\\n        for(auto num : colm){\\n            if(num % 2 == 0) even_colm ++; //count the number of even column\\n        }\\n        return even_row*(m-even_colm)+(n-even_row)*even_colm;\\n    }\\n};\\n```\\n\\n------\\nRuntime: **4 ms**, faster than **82.80%** of C++ online submissions for Cells with Odd Values in a Matrix.\\nMemory Usage: **9.5 MB**, less than **100.00%** of C++ online submissions for Cells with Odd Values in a Matrix.\\n```\\nclass Solution {\\npublic:\\n    void incrementThis(vector<vector<int>> &mat, bool isRow, int index){\\n        if(isRow){\\n            for(int i(0);i<mat[0].size();i++)\\n                mat[index][i]+=1;\\n        }else{\\n            for(int i(0);i<mat.size();i++)\\n                mat[i][index]+=1;\\n        }\\n    }\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<vector<int>> mat(n,vector<int>(m,0));\\n        for(vector<int> index: indices){\\n            incrementThis(mat,true,index[0]);\\n            incrementThis(mat,false,index[1]);\\n        }\\n        int numOfOdd(0);\\n        \\n        for(int i(0);i<n;i++)\\n            for(int j(0);j<m;j++)\\n                if(mat[i][j] & 1) numOfOdd++;\\n        \\n        return numOfOdd;\\n    }\\n};\\n```\\n\\n-----\\nRuntime: 4 ms, faster than 82.80% of C++ online submissions for Cells with Odd Values in a Matrix.\\nMemory Usage: 9.5 MB, less than 100.00% of C++ online submissions for Cells with Odd Values in a Matrix.\\n```\\nclass Solution {\\npublic:\\n    void incrementThis(vector<vector<int>> &mat, bool isRow, int index, int &numOfOdd){\\n        if(isRow){\\n            for(int i(0);i<mat[0].size();i++){\\n                mat[index][i]+=1;\\n                if(mat[index][i] & 1) numOfOdd++;\\n                else numOfOdd--;\\n            }\\n        }else{\\n            for(int i(0);i<mat.size();i++){\\n                mat[i][index]+=1;\\n                if(mat[i][index] & 1) numOfOdd++;\\n                else numOfOdd--;\\n            }\\n        }\\n    }\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<vector<int>> mat(n,vector<int>(m,0));\\n        int numOfOdd(0); // 0 i.e in beginning no element is odd\\n        \\n        for(vector<int> index: indices){\\n            incrementThis(mat,true,index[0],numOfOdd);\\n            incrementThis(mat,false,index[1],numOfOdd);\\n        }\\n        return numOfOdd;\\n    }\\n};\\n```\\n\\n------\\nRuntime: 4 ms, faster than 82.65% of C++ online submissions for Cells with Odd Values in a Matrix.\\nMemory Usage: 9.5 MB, less than 100.00% of C++ online submissions for Cells with Odd Values in a Matrix.\\n```\\nclass Solution { // using 2D bool array is efficient\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<vector<bool>> mat(n,vector<bool>(m,false));\\n        for(vector<int> index: indices){\\n            auto r(index[0]),c(index[1]);\\n            for(int i(0);i<n;i++) mat[i][c]=!mat[i][c];\\n            for(int j(0);j<m;j++) mat[r][j]=!mat[r][j];\\n        }\\n        \\n        return accumulate(mat.begin(),mat.end(),0,[](int lhs,vector<bool> &rhs){\\n            return accumulate(rhs.begin(),rhs.end(),lhs);\\n        });\\n    }\\n};\\n```\\n\\n-----\\nRuntime: 4 ms, faster than 82.65% of C++ online submissions for Cells with Odd Values in a Matrix.\\nMemory Usage: 9.5 MB, less than 100.00% of C++ online submissions for Cells with Odd Values in a Matrix.\\n```\\nclass Solution { // using 2D bool array is efficient\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<vector<bool>> mat(n,vector<bool>(m,false));\\n        for(vector<int> index: indices){\\n            auto r(index[0]),c(index[1]);\\n            for(int i(0);i<n;i++) mat[i][c]=!mat[i][c];\\n            for(int j(0);j<m;j++) mat[r][j]=!mat[r][j];\\n        }\\n        \\n        return accumulate(mat.begin(),mat.end(),0,[](int lhs,vector<bool> &rhs){\\n            return lhs + accumulate(rhs.begin(),rhs.end(),0);\\n        });\\n    }\\n};\\n```\\n\\n------\\nRuntime: 4 ms, faster than 82.65% of C++ online submissions for Cells with Odd Values in a Matrix.\\nMemory Usage: 9.5 MB, less than 100.00% of C++ online submissions for Cells with Odd Values in a Matrix.\\n```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<vector<bool>> mat(n,vector<bool>(m,false));\\n        for(vector<int> index: indices){\\n            auto r(index[0]),c(index[1]);\\n            for(int i(0);i<n;i++) mat[i][c]=!mat[i][c];\\n            for(int j(0);j<m;j++) mat[r][j]=!mat[r][j];\\n        }\\n        \\n        return accumulate(mat.cbegin(),mat.cend(),0,[](auto lhs,const auto &rhs){\\n            return lhs + accumulate(rhs.cbegin(),rhs.cend(),0);\\n        });\\n    }\\n};\\n```\\n\\n-------\\nRuntime: 4 ms, faster than 82.62% of C++ online submissions for Cells with Odd Values in a Matrix.\\nMemory Usage: 9.5 MB, less than 100.00% of C++ online submissions for Cells with Odd Values in a Matrix.\\n```\\nclass Solution { \\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<vector<int>> mat(n);\\n        for(int i(0);i<n;i++) mat[i].resize(m); // the default values (0 for int) would be useful \\n        \\n        for(auto &index: indices){\\n            for(int i(0);i<n;i++) mat[i][index[1]]+=1;\\n            for(int j(0);j<m;j++) mat[index[0]][j]+=1;\\n        }\\n        \\n        int oddCellsCount(0);\\n        for(auto &row: mat)\\n            for(auto &col: row)\\n                if(col & 1) oddCellsCount++;\\n        \\n        return oddCellsCount;\\n    }\\n};\\n```\\n\\n--------\\nRuntime: 4 ms, faster than 82.62% of C++ online submissions for Cells with Odd Values in a Matrix.\\nMemory Usage: 9.7 MB, less than 100.00% of C++ online submissions for Cells with Odd Values in a Matrix.\\n```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<int> rowsToIncrement,colsToIncrement;\\n        \\n        for(auto index: indices){\\n            rowsToIncrement.push_back(index[0]);\\n            colsToIncrement.push_back(index[1]);\\n        }\\n        \\n        int oddCellsCount(0);\\n        vector<vector<int>> mat(n,vector<int>(m,0));\\n        \\n        for(int i(0);i<rowsToIncrement.size();i++){\\n            for(int j(0);j<m;j++){\\n                if(++mat[rowsToIncrement[i]][j] & 1) oddCellsCount++;\\n                else oddCellsCount--;\\n            }\\n        }\\n        \\n        for(int i(0);i<colsToIncrement.size();i++){\\n            for(int j(0);j<n;j++){\\n                if(++mat[j][colsToIncrement[i]] & 1) oddCellsCount++;\\n                else oddCellsCount--;\\n            }\\n        }\\n        \\n        return oddCellsCount;\\n    }\\n};\\n```\\n\\n------\\nRuntime: 4 ms, faster than 82.62% of C++ online submissions for Cells with Odd Values in a Matrix.\\nMemory Usage: 9.3 MB, less than 100.00% of C++ online submissions for Cells with Odd Values in a Matrix.\\n```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<bool> rows(n,false),cols(m,false);\\n        for(auto index: indices){\\n            rows[index[0]]=!rows[index[0]];\\n            cols[index[1]]=!cols[index[1]];\\n        }\\n        \\n        int oddCount(0);\\n        for(int i(0);i<n;i++){\\n            for(int j(0);j<m;j++){\\n                if(rows[i]^cols[j]) oddCount++;\\n            }\\n        }\\n        return oddCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nstatic int x = []() {\\nstd::ios::sync_with_stdio(false);\\ncin.tie(nullptr);\\nreturn 0; }();\\n\\nclass Solution { // tc: O(n+m) & sc: O(n+m)\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<bool> rows(n,false),cols(m,false);\\n        for(auto index: indices){\\n            rows[index[0]] = rows[index[0]] ^ true;\\n            cols[index[1]] = cols[index[1]] ^ true;\\n        }\\n        \\n        int r(0),c(0);\\n        for(int i(0);i<n;i++){\\n            if(rows[i]) r++;\\n        }\\n        \\n        for(int i(0);i<m;i++){\\n            if(cols[i]) c++;\\n        }\\n        return r*(m-c) + c*(n-r); // (or) return (r*m + c*n - 2*r*c);\\n    }\\n};\\n```\n```\\nclass Solution { // without manipulating array\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        int oddCellsCount(0);\\n        unordered_set<int> rows;\\n        unordered_set<int> cols;\\n        \\n        for(auto index: indices){\\n            if(rows.count(index[0])==0) rows.insert(index[0]);\\n            else rows.erase(index[0]); // remove row as it has been flipped back to even\\n            \\n            if(cols.count(index[1])==0) cols.insert(index[1]);\\n            else cols.erase(index[1]);  // remove col as it has been flipped back to even\\n        }\\n        \\n// Where flipped rows and columns cross, that number remains even.\\n//i.e. The number of odds corresponds to - (the product of odd rows and number of columns that haven\\'t been flipped), added to (the product of odd columns and number of rows that haven\\'t been flipped).\\n        \\n        return rows.size()*(m-cols.size()) + cols.size()*(n-rows.size());\\n        \\n        // i.e. return (r*m + c*n - 2*r*c);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        int row[n] = {0}, colm[m] = {0};\\n        for(auto pair : indices){\\n            row[pair[0]] ++;\\n            colm[pair[1]] ++;\\n        }\\n        int even_row = 0, even_colm = 0; \\n        for(auto num : row){\\n            if(num % 2 == 0) even_row++; //count the number of even row\\n        }\\n        for(auto num : colm){\\n            if(num % 2 == 0) even_colm ++; //count the number of even column\\n        }\\n        return even_row*(m-even_colm)+(n-even_row)*even_colm;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void incrementThis(vector<vector<int>> &mat, bool isRow, int index){\\n        if(isRow){\\n            for(int i(0);i<mat[0].size();i++)\\n                mat[index][i]+=1;\\n        }else{\\n            for(int i(0);i<mat.size();i++)\\n                mat[i][index]+=1;\\n        }\\n    }\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<vector<int>> mat(n,vector<int>(m,0));\\n        for(vector<int> index: indices){\\n            incrementThis(mat,true,index[0]);\\n            incrementThis(mat,false,index[1]);\\n        }\\n        int numOfOdd(0);\\n        \\n        for(int i(0);i<n;i++)\\n            for(int j(0);j<m;j++)\\n                if(mat[i][j] & 1) numOfOdd++;\\n        \\n        return numOfOdd;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void incrementThis(vector<vector<int>> &mat, bool isRow, int index, int &numOfOdd){\\n        if(isRow){\\n            for(int i(0);i<mat[0].size();i++){\\n                mat[index][i]+=1;\\n                if(mat[index][i] & 1) numOfOdd++;\\n                else numOfOdd--;\\n            }\\n        }else{\\n            for(int i(0);i<mat.size();i++){\\n                mat[i][index]+=1;\\n                if(mat[i][index] & 1) numOfOdd++;\\n                else numOfOdd--;\\n            }\\n        }\\n    }\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<vector<int>> mat(n,vector<int>(m,0));\\n        int numOfOdd(0); // 0 i.e in beginning no element is odd\\n        \\n        for(vector<int> index: indices){\\n            incrementThis(mat,true,index[0],numOfOdd);\\n            incrementThis(mat,false,index[1],numOfOdd);\\n        }\\n        return numOfOdd;\\n    }\\n};\\n```\n```\\nclass Solution { // using 2D bool array is efficient\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<vector<bool>> mat(n,vector<bool>(m,false));\\n        for(vector<int> index: indices){\\n            auto r(index[0]),c(index[1]);\\n            for(int i(0);i<n;i++) mat[i][c]=!mat[i][c];\\n            for(int j(0);j<m;j++) mat[r][j]=!mat[r][j];\\n        }\\n        \\n        return accumulate(mat.begin(),mat.end(),0,[](int lhs,vector<bool> &rhs){\\n            return accumulate(rhs.begin(),rhs.end(),lhs);\\n        });\\n    }\\n};\\n```\n```\\nclass Solution { // using 2D bool array is efficient\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<vector<bool>> mat(n,vector<bool>(m,false));\\n        for(vector<int> index: indices){\\n            auto r(index[0]),c(index[1]);\\n            for(int i(0);i<n;i++) mat[i][c]=!mat[i][c];\\n            for(int j(0);j<m;j++) mat[r][j]=!mat[r][j];\\n        }\\n        \\n        return accumulate(mat.begin(),mat.end(),0,[](int lhs,vector<bool> &rhs){\\n            return lhs + accumulate(rhs.begin(),rhs.end(),0);\\n        });\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<vector<bool>> mat(n,vector<bool>(m,false));\\n        for(vector<int> index: indices){\\n            auto r(index[0]),c(index[1]);\\n            for(int i(0);i<n;i++) mat[i][c]=!mat[i][c];\\n            for(int j(0);j<m;j++) mat[r][j]=!mat[r][j];\\n        }\\n        \\n        return accumulate(mat.cbegin(),mat.cend(),0,[](auto lhs,const auto &rhs){\\n            return lhs + accumulate(rhs.cbegin(),rhs.cend(),0);\\n        });\\n    }\\n};\\n```\n```\\nclass Solution { \\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<vector<int>> mat(n);\\n        for(int i(0);i<n;i++) mat[i].resize(m); // the default values (0 for int) would be useful \\n        \\n        for(auto &index: indices){\\n            for(int i(0);i<n;i++) mat[i][index[1]]+=1;\\n            for(int j(0);j<m;j++) mat[index[0]][j]+=1;\\n        }\\n        \\n        int oddCellsCount(0);\\n        for(auto &row: mat)\\n            for(auto &col: row)\\n                if(col & 1) oddCellsCount++;\\n        \\n        return oddCellsCount;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<int> rowsToIncrement,colsToIncrement;\\n        \\n        for(auto index: indices){\\n            rowsToIncrement.push_back(index[0]);\\n            colsToIncrement.push_back(index[1]);\\n        }\\n        \\n        int oddCellsCount(0);\\n        vector<vector<int>> mat(n,vector<int>(m,0));\\n        \\n        for(int i(0);i<rowsToIncrement.size();i++){\\n            for(int j(0);j<m;j++){\\n                if(++mat[rowsToIncrement[i]][j] & 1) oddCellsCount++;\\n                else oddCellsCount--;\\n            }\\n        }\\n        \\n        for(int i(0);i<colsToIncrement.size();i++){\\n            for(int j(0);j<n;j++){\\n                if(++mat[j][colsToIncrement[i]] & 1) oddCellsCount++;\\n                else oddCellsCount--;\\n            }\\n        }\\n        \\n        return oddCellsCount;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<bool> rows(n,false),cols(m,false);\\n        for(auto index: indices){\\n            rows[index[0]]=!rows[index[0]];\\n            cols[index[1]]=!cols[index[1]];\\n        }\\n        \\n        int oddCount(0);\\n        for(int i(0);i<n;i++){\\n            for(int j(0);j<m;j++){\\n                if(rows[i]^cols[j]) oddCount++;\\n            }\\n        }\\n        return oddCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441749,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def oddCells(self, n, m, indices):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :type indices: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        r = [0 for _ in range(n)]\\n        c = [0 for _ in range(m)]\\n        \\n        for ri, ci in indices:\\n            r[ri] += 1\\n            c[ci] += 1\\n        \\n        res = 0\\n        for i in range(n):\\n            tres = []\\n            for j in range(m):\\n                if (r[i] + c[j]) % 2 == 1:\\n                    res += 1\\n                \\n        \\n        return res\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def oddCells(self, n, m, indices):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :type indices: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        r = [0 for _ in range(n)]\\n        c = [0 for _ in range(m)]\\n        \\n        for ri, ci in indices:\\n            r[ri] += 1\\n            c[ci] += 1\\n        \\n        res = 0\\n        for i in range(n):\\n            tres = []\\n            for j in range(m):\\n                if (r[i] + c[j]) % 2 == 1:\\n                    res += 1\\n                \\n        \\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775097,
                "title": "c-4-different-approaches",
                "content": "Please let me know if you have more ideas about how to solve this problem.\\n\\n# Approach 1: simulate\\n\\nThe problem constraint are small enough that we can just fully simulate it:\\n\\n```cpp\\n    static int oddCells(const int m, const int n, const vector<vector<int>>& indices) {\\n        vector<vector<int>> mat(m, vector<int>(n));\\n        for (const vector<int>& index : indices) {\\n            for (int c = 0; c < n; ++c) ++mat[index[0]][c];\\n            for (int r = 0; r < m; ++r) ++mat[r][index[1]];\\n        }\\n        int ans = 0;\\n        for (int r = 0; r < m; ++r)\\n            for (int c = 0; c < n; ++c)\\n                ans += mat[r][c] & 1;\\n        return ans;\\n    }\\n```\\n\\nIf we want we could use ```std::accumulate``` for summing up the odd cells. TBH I think the raw loops are more readable. Wdyt?\\n\\n```cpp\\n    static int oddCells(const int m, const int n, const vector<vector<int>>& indices) {\\n        vector<vector<int>> mat(m, vector<int>(n));\\n        for (const vector<int>& index : indices) {\\n            for (int c = 0; c < n; ++c) ++mat[index[0]][c];\\n            for (int r = 0; r < m; ++r) ++mat[r][index[1]];\\n        }\\n        return accumulate(begin(mat), end(mat), 0, [](int total, const vector<int>& row) {\\n            return total + accumulate(begin(row), end(row), 0, [](int s, int x) { return s + (x & 1); });\\n        });\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$q$$ be the number of queries and $$m$$ and $$m$$ the size of the matrix then the\\n  * Time complexity is $$O(m q + n q + m n)$$, and the\\n  * Space complexity is $$O(m n)$$.\\n\\n\\n# Approach 2: count per row and column\\n\\nInstead of fully simulating this we can just keep track of how often we incrementing each row and column and then we sum up. This already improves the runtime and the space requirements.\\n\\n```cpp\\n    static int oddCells(const int m, const int n, const vector<vector<int>>& indices) {\\n        vector<int> row(m);\\n        vector<int> col(n);\\n        for (const vector<int>& index : indices) {\\n            ++row[index[0]];\\n            ++col[index[1]];\\n        }\\n        int ans = 0;\\n        for (int r = 0; r < m; ++r)\\n            for (int c = 0; c < n; ++c)\\n                ans += (row[r] + col[c]) & 1;\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$q$$ be the number of queries and $$m$$ and $$m$$ the size of the matrix then the\\n  * Time complexity is $$O(q + m n)$$, and the\\n  * Space complexity is $$O(m + n)$$.\\n\\n# Approach 3: count odd / even rows and columns\\n\\nWe can do better!\\n\\n```cpp\\n    static int oddCells(const int m, const int n, const vector<vector<int>>& indices) {\\n        vector<int> row(m);\\n        vector<int> col(n);\\n        for (const vector<int>& index : indices) {\\n            ++row[index[0]];\\n            ++col[index[1]];\\n        }\\n        const int row_odd = count_if(begin(row), end(row), [](int x) { return x & 1; });\\n        const int row_even = m - row_odd;\\n        const int col_odd = count_if(begin(col), end(col), [](int x) { return x & 1; });\\n        const int col_even = n - col_odd;\\n        return row_odd * col_even + row_even * col_odd;\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$q$$ be the number of queries and $$m$$ and $$m$$ the size of the matrix then the\\n  * Time complexity is $$O(q + m + n)$$, and the\\n  * Space complexity is $$O(m + n)$$.\\n\\n\\n# Approach 4: flipping and counting bits\\n\\nThis approach is similar to approach 3, but instead of incrementing the counts we just keep track if the count is odd or even. Furthermore we are using ```bitset``` to safe space.\\n\\n```cpp\\n    static int oddCells(const int m, const int n, const vector<vector<int>>& indices) {\\n        bitset<64> odd_rows;\\n        bitset<64> odd_cols;\\n        for (const vector<int>& index : indices) {\\n            odd_rows.flip(index[0]);\\n            odd_cols.flip(index[1]);\\n        }\\n        const int row_odd = odd_rows.count();\\n        const int row_even = m - row_odd;\\n        const int col_odd = odd_cols.count();\\n        const int col_even = n - col_odd;\\n        return row_odd * col_even + row_even * col_odd;\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$q$$ be the number of queries and $$m$$ and $$m$$ the size of the matrix then the\\n  * Time complexity is $$O(q + m + n)$$, and the\\n  * Space complexity is $$O(m + n)$$.\\n\\nNote that the asymptotical runtime and space complexity is the same as for approach 3, but the constant factor are at least for the space complexity lower.\\n\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static int oddCells(const int m, const int n, const vector<vector<int>>& indices) {\\n        vector<vector<int>> mat(m, vector<int>(n));\\n        for (const vector<int>& index : indices) {\\n            for (int c = 0; c < n; ++c) ++mat[index[0]][c];\\n            for (int r = 0; r < m; ++r) ++mat[r][index[1]];\\n        }\\n        int ans = 0;\\n        for (int r = 0; r < m; ++r)\\n            for (int c = 0; c < n; ++c)\\n                ans += mat[r][c] & 1;\\n        return ans;\\n    }\\n```\n```std::accumulate```\n```cpp\\n    static int oddCells(const int m, const int n, const vector<vector<int>>& indices) {\\n        vector<vector<int>> mat(m, vector<int>(n));\\n        for (const vector<int>& index : indices) {\\n            for (int c = 0; c < n; ++c) ++mat[index[0]][c];\\n            for (int r = 0; r < m; ++r) ++mat[r][index[1]];\\n        }\\n        return accumulate(begin(mat), end(mat), 0, [](int total, const vector<int>& row) {\\n            return total + accumulate(begin(row), end(row), 0, [](int s, int x) { return s + (x & 1); });\\n        });\\n    }\\n```\n```cpp\\n    static int oddCells(const int m, const int n, const vector<vector<int>>& indices) {\\n        vector<int> row(m);\\n        vector<int> col(n);\\n        for (const vector<int>& index : indices) {\\n            ++row[index[0]];\\n            ++col[index[1]];\\n        }\\n        int ans = 0;\\n        for (int r = 0; r < m; ++r)\\n            for (int c = 0; c < n; ++c)\\n                ans += (row[r] + col[c]) & 1;\\n        return ans;\\n    }\\n```\n```cpp\\n    static int oddCells(const int m, const int n, const vector<vector<int>>& indices) {\\n        vector<int> row(m);\\n        vector<int> col(n);\\n        for (const vector<int>& index : indices) {\\n            ++row[index[0]];\\n            ++col[index[1]];\\n        }\\n        const int row_odd = count_if(begin(row), end(row), [](int x) { return x & 1; });\\n        const int row_even = m - row_odd;\\n        const int col_odd = count_if(begin(col), end(col), [](int x) { return x & 1; });\\n        const int col_even = n - col_odd;\\n        return row_odd * col_even + row_even * col_odd;\\n    }\\n```\n```bitset```\n```cpp\\n    static int oddCells(const int m, const int n, const vector<vector<int>>& indices) {\\n        bitset<64> odd_rows;\\n        bitset<64> odd_cols;\\n        for (const vector<int>& index : indices) {\\n            odd_rows.flip(index[0]);\\n            odd_cols.flip(index[1]);\\n        }\\n        const int row_odd = odd_rows.count();\\n        const int row_even = m - row_odd;\\n        const int col_odd = odd_cols.count();\\n        const int col_even = n - col_odd;\\n        return row_odd * col_even + row_even * col_odd;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2805959,
                "title": "java-solution-strictly-for-beginners-with-questions-description",
                "content": "---\\n\\n![Yt-banner-short.jpg](https://assets.leetcode.com/users/images/e5f071e1-8759-4130-a021-42fb4fc75714_1667375904.5590618.jpeg)\\n\\n\\n---\\n\\n## \\u27A1\\uFE0F Question, not understandable\\uD83E\\uDD14? -See Below\\uD83D\\uDC47.\\n```\\n\\t\\t\\t          |\\t      |\\nindices 2D- matrix--> | |0 1| |\\n\\t\\t\\t          | |1 1| |\\n\\t\\t\\t          |\\t      |\\n\\nInitial matrix--> |0 0 0| \\n                  |0 0 0|\\n\\n\\n--> Inside indices 2D-Matrix: 0(current), 1, then: 1, 1\\n    \"0\" means, increment 0th row with \"1\", column constant.\\n\\nRow constant--> |1 1 1| \\n                |0 0 0|\\n\\n--> Inside indices 2D-Matrix: 0(Done), 1(Current), then: 1, 1\\n    \"1\" means, increment 1th column with \"1\", row constant.\\n\\nColumn constant--> |1 2 1| \\n                   |0 1 0|\\n\\n--> Inside indices 2D-Matrix: 0(Done), 1(Done), then: 1(Current), 1\\n    \"1\" means, increment 1th row with \"1\", column constant.\\n\\nRow constant--> |1 2 1| \\n                |1 2 1|\\n\\n--> Inside indices 2D-Matrix: 0(Done), 1(Done), then: 1(Done), 1(Current)\\n    \"1\" means, increment 1th column with \"1\", row constant.\\n\\nColumn constant--> |1 3 1| \\n                   |1 3 1|    <--- [FINAL ANS]\\n```\\n\\n\\n## \\u27A1\\uFE0F If you like the solution, Upvote it\\uD83D\\uDC46, you will help the beginners.\\n\\n```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int[][] ans = new int[m][n];\\n\\n        for (int i = 0; i < indices.length; i++) {\\n            //row is constant\\n            for (int j = 0; j <n; j++) {\\n                ans[indices[i][0]][j]++;\\n            }\\n\\n            //column is constant\\n            for (int j = 0; j < m; j++) {\\n                ans[j][indices[i][1]]++;\\n            }\\n        }\\n        \\n        // Counting ODD numbers in the final Matrix\\n        int count = 0;\\n        for (int i= 0; i < m; i++) {\\n            for (int j = 0; j <n; j++) {\\n                if (ans[i][j] % 2 != 0) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n## \\u27A1\\uFE0F For more explanation, watch my video\\uD83D\\uDC47.\\n[https://youtu.be/VUdne-0o6WQ]()\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\t\\t          |\\t      |\\nindices 2D- matrix--> | |0 1| |\\n\\t\\t\\t          | |1 1| |\\n\\t\\t\\t          |\\t      |\\n\\nInitial matrix--> |0 0 0| \\n                  |0 0 0|\\n\\n\\n--> Inside indices 2D-Matrix: 0(current), 1, then: 1, 1\\n    \"0\" means, increment 0th row with \"1\", column constant.\\n\\nRow constant--> |1 1 1| \\n                |0 0 0|\\n\\n--> Inside indices 2D-Matrix: 0(Done), 1(Current), then: 1, 1\\n    \"1\" means, increment 1th column with \"1\", row constant.\\n\\nColumn constant--> |1 2 1| \\n                   |0 1 0|\\n\\n--> Inside indices 2D-Matrix: 0(Done), 1(Done), then: 1(Current), 1\\n    \"1\" means, increment 1th row with \"1\", column constant.\\n\\nRow constant--> |1 2 1| \\n                |1 2 1|\\n\\n--> Inside indices 2D-Matrix: 0(Done), 1(Done), then: 1(Done), 1(Current)\\n    \"1\" means, increment 1th column with \"1\", row constant.\\n\\nColumn constant--> |1 3 1| \\n                   |1 3 1|    <--- [FINAL ANS]\\n```\n```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int[][] ans = new int[m][n];\\n\\n        for (int i = 0; i < indices.length; i++) {\\n            //row is constant\\n            for (int j = 0; j <n; j++) {\\n                ans[indices[i][0]][j]++;\\n            }\\n\\n            //column is constant\\n            for (int j = 0; j < m; j++) {\\n                ans[j][indices[i][1]]++;\\n            }\\n        }\\n        \\n        // Counting ODD numbers in the final Matrix\\n        int count = 0;\\n        for (int i= 0; i < m; i++) {\\n            for (int j = 0; j <n; j++) {\\n                if (ans[i][j] % 2 != 0) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051746,
                "title": "python-sol",
                "content": "```\\nclass Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        count=0\\n        row=[0]*n\\n        col=[0]*m\\n        for x,y in indices:\\n            row[x]+=1\\n            col[y]+=1\\n        for i in range(n):\\n            for j in range(m):\\n                if (row[i]+col[j])%2==1:\\n                    count+=1\\n        return count\\n            \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        count=0\\n        row=[0]*n\\n        col=[0]*m\\n        for x,y in indices:\\n            row[x]+=1\\n            col[y]+=1\\n        for i in range(n):\\n            for j in range(m):\\n                if (row[i]+col[j])%2==1:\\n                    count+=1\\n        return count\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 813726,
                "title": "short-sweet-efficient-python-w-explanation",
                "content": "**1.** Initialize first list of zeros length n and second list of zeros length m.\\n**2.** Iterate over indexes.\\n**3.** increment value at index[0] in first list by 1 and increment value at index[1] in second list by 1.\\n**4.** Sum list comprehension nesting iteration of values in second list within iteration of values in first list appending 1 for every (i+j) % 2.\\n```\\nclass Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        \\n        x, y = [0] * n, [0] * m\\n        for i in indices:\\n            x[i[0]] += 1\\n            y[i[1]] += 1\\n        return sum([1 for j in y for i in x if (j+i) % 2])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        \\n        x, y = [0] * n, [0] * m\\n        for i in indices:\\n            x[i[0]] += 1\\n            y[i[1]] += 1\\n        return sum([1 for j in y for i in x if (j+i) % 2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 473104,
                "title": "easy-c-solution",
                "content": "```\\npublic class Solution\\n{\\n    public int OddCells(int n, int m, int[][] indices)\\n    {\\n        int[] rows = new int[n];\\n        int[] cols = new int[m];\\n\\n        foreach (var idxs in indices)\\n        {\\n            rows[idxs[0]]++;\\n            cols[idxs[1]]++;\\n        }\\n\\n        int res = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if ((rows[i] + cols[j]) % 2 == 1)\\n                {\\n                    res++;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int OddCells(int n, int m, int[][] indices)\\n    {\\n        int[] rows = new int[n];\\n        int[] cols = new int[m];\\n\\n        foreach (var idxs in indices)\\n        {\\n            rows[idxs[0]]++;\\n            cols[idxs[1]]++;\\n        }\\n\\n        int res = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if ((rows[i] + cols[j]) % 2 == 1)\\n                {\\n                    res++;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 460119,
                "title": "c-beat-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        int odds = 0;\\n        vector<bool> rows(n, false);\\n        vector<bool> cols(m, false);\\n        for(auto vec : indices) {\\n            rows[vec[0]] = !rows[vec[0]];\\n            cols[vec[1]] = !cols[vec[1]];\\n        }\\n        for(int i = 0; i < n; i ++) \\n            for(int j = 0; j < m; j ++) \\n                if(rows[i] ^ cols[j]) odds ++;\\n        return odds;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        int odds = 0;\\n        vector<bool> rows(n, false);\\n        vector<bool> cols(m, false);\\n        for(auto vec : indices) {\\n            rows[vec[0]] = !rows[vec[0]];\\n            cols[vec[1]] = !cols[vec[1]];\\n        }\\n        for(int i = 0; i < n; i ++) \\n            for(int j = 0; j < m; j ++) \\n                if(rows[i] ^ cols[j]) odds ++;\\n        return odds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 430302,
                "title": "0ms-beats-all-simple-mathematical-solution",
                "content": "Counts how many odd rows and cols there are.\\nCalculates the total number of odd elements\\nSubtracts the union between rows and cols\\n\\n\\n\\tpublic class Solution {\\n\\t\\tpublic int oddCells(int n, int m, int[][] indices) {\\n\\t\\t\\tboolean r[] = new boolean[n];\\n\\t\\t\\tboolean c[] = new boolean[m];\\n\\t\\t\\tint row_odd = 0, col_odd = 0;\\t\\n\\t\\t\\t\\n\\t\\t\\tfor (int i = 0; i < indices.length; i++){\\n\\t\\t\\t\\tr[indices[i][0]] = !r[indices[i][0]];\\n\\t\\t\\t\\tc[indices[i][1]] = !c[indices[i][1]];\\n\\t\\t\\t\\trow_odd += r[indices[i][0]] ? 1 : -1;\\n\\t\\t\\t\\tcol_odd += c[indices[i][1]] ? 1 : -1;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn (row_odd*m) + (col_odd*n) - (2*row_odd*col_odd);\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int oddCells(int n, int m, int[][] indices) {\\n\\t\\t\\tboolean r[] = new boolean[n];\\n\\t\\t\\tboolean c[] = new boolean[m];\\n\\t\\t\\tint row_odd = 0, col_odd = 0;\\t\\n\\t\\t\\t\\n\\t\\t\\tfor (int i = 0; i < indices.length; i++){\\n\\t\\t\\t\\tr[indices[i][0]] = !r[indices[i][0]];\\n\\t\\t\\t\\tc[indices[i][1]] = !c[indices[i][1]];\\n\\t\\t\\t\\trow_odd += r[indices[i][0]] ? 1 : -1;\\n\\t\\t\\t\\tcol_odd += c[indices[i][1]] ? 1 : -1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 425174,
                "title": "0ms-java-simple-code",
                "content": "```\\npublic int oddCells(int n, int m, int[][] indices) {\\n        int[][] rows = new int[n][1];\\n        int[][] cols = new int[m][1];\\n        for (int[] a : indices) {\\n            rows[a[0]][0]++;\\n            cols[a[1]][0]++;\\n        }\\n        int[] rowsCount = {0, 0};\\n        for (int i = 0; i < n; i++) {\\n            if ((rows[i][0] & 1) == 0)\\n                rowsCount[0]++;\\n            else\\n                rowsCount[1]++;\\n        }\\n        int[] colsCount = {0, 0};\\n        for (int i = 0; i < m; i++) {\\n            if ((cols[i][0] & 1) == 0)\\n                colsCount[0]++;\\n            else\\n                colsCount[1]++;\\n        }\\n        return (rowsCount[0] * colsCount[1]) + (rowsCount[1] * colsCount[0]);\\n    }\\n```\\n\\nThis is count of \\n_ E O <-- evens\\nE 1 0\\nO 0 1\\n^ odds\\n|\\n\\neven + even = even no\\nodd + odd = even no\\neven + odd = odd no\\n\\nthat is why come up with\\n (rowsCount[0] * colsCount[1]) + (rowsCount[1] * colsCount[0])",
                "solutionTags": [],
                "code": "```\\npublic int oddCells(int n, int m, int[][] indices) {\\n        int[][] rows = new int[n][1];\\n        int[][] cols = new int[m][1];\\n        for (int[] a : indices) {\\n            rows[a[0]][0]++;\\n            cols[a[1]][0]++;\\n        }\\n        int[] rowsCount = {0, 0};\\n        for (int i = 0; i < n; i++) {\\n            if ((rows[i][0] & 1) == 0)\\n                rowsCount[0]++;\\n            else\\n                rowsCount[1]++;\\n        }\\n        int[] colsCount = {0, 0};\\n        for (int i = 0; i < m; i++) {\\n            if ((cols[i][0] & 1) == 0)\\n                colsCount[0]++;\\n            else\\n                colsCount[1]++;\\n        }\\n        return (rowsCount[0] * colsCount[1]) + (rowsCount[1] * colsCount[0]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2489643,
                "title": "java-simple-soultion-with-problem-explanation",
                "content": "**Problem Explanation**\\ngiven m=3(row length) , n(column length)=2    Indices =[[0,1],[1,1]]\\n\\n**Note:**indices matrix has values used to increment matrix row and column values\\n\\nstep 1:\\nForm a matrix with given size(m and n)\\n\\nmatrix =[ [0  0 0]\\n\\t\\t\\t\\t[0 0 0]\\n\\t\\t\\t\\t[0 0 0] ]\\nstep 2:\\n\\nincrement row values .we can find row which we want increment from indices matrix\\n\\nindices =[ [0 1], [1 1] ]\\ntake first row (0,0) row = 0\\nincrement 0 th row in matrix \\n\\nmatrix = [ [1 1 1], [0 0 0] ]\\n\\t\\t\\t\\t \\n**step3:**\\nnext value we have to see is column from indices\\nindices =[ [0 1], [1 1] ]\\ncolumn is (0,1) = 1\\nthen Increment the column values in matrix\\nmatrix = [ [1 2 1], [0 1 0] ]\\n\\t\\t\\t\\t \\n**Step 4**\\nnext again check row value\\nndices =[ [0 1], [1 1] ]\\nrow is (1,0) = 1\\nthen Increment the column values in matrix\\nmatrix = [ [1 2 1], [1 2 1] ]\\n\\t\\t\\t\\t \\n**Step 5**\\nnext again check column value\\nndices =[ [0 1], [1 1] ]\\ncolumn is (1,1) = 1\\nthen Increment the column values in matrix\\nmatrix = [ [1 3 1], [1 3 1] ]\\n**step 6:**\\n\\nCount how many numbers are odd in matrix \\n odd values = 6\\n\\nProgram\\n    \\n    class Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int[][] matrix=new int[m][n];\\n        int count=0;\\n        for(int i=0;i<indices.length;i++)\\n        {\\n            int row=indices[i][0];    \\n            int col=indices[i][1];\\n            \\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[row][j]++; \\n            }\\n           \\n            \\n            for(int k=0;k<m;k++)\\n            {\\n                matrix[k][col]++;  \\n            }\\n            \\n        }\\n         for(int r=0;r<m;r++)\\n            {\\n                for(int c=0;c<n;c++){\\n                    if(matrix[r][c] % 2 != 0)\\n                        count++;\\n                }\\n            \\n                    \\n            }\\n        return count;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int[][] matrix=new int[m][n];\\n        int count=0;\\n        for(int i=0;i<indices.length;i++)\\n        {\\n            int row=indices[i][0];    \\n            int col=indices[i][1];\\n            \\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[row][j]++; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2306056,
                "title": "bruteforce-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        int count=0;\\n        int sk[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n            sk[i][j]=0;\\n            }\\n\\n        }\\n    \\n        for(int i=0;i<indices.size();i++){\\n/////////first filing row as value 1; with i=0; \\n            for(int j=0;j<n;j++){\\n                //[[1,2,1],[0,0,0]]\\n                sk[indices[i][0]][j]+=1;\\n            }\\n            /////////first filing column as value 1;\\n            for(int j=0;j<m;j++){\\n                //[[1,1,1],[0,2,0]]\\n                sk[j][indices[i][1]]+=1;\\n            }\\n    }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(sk[i][j]%2!=0){\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        int count=0;\\n        int sk[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n            sk[i][j]=0;\\n            }\\n\\n        }\\n    \\n        for(int i=0;i<indices.size();i++){\\n/////////first filing row as value 1; with i=0; \\n            for(int j=0;j<n;j++){\\n                //[[1,2,1],[0,0,0]]\\n                sk[indices[i][0]][j]+=1;\\n            }\\n            /////////first filing column as value 1;\\n            for(int j=0;j<m;j++){\\n                //[[1,1,1],[0,2,0]]\\n                sk[j][indices[i][1]]+=1;\\n            }\\n    }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(sk[i][j]%2!=0){\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682009,
                "title": "optimal-o-m-n-space-o-m-n-time-complexity-solution",
                "content": "```\\nclass Solution:\\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\\n        row_data = [0]*m\\n        col_data = [0]*n\\n        \\n        for tup in indices:\\n            row_data[tup[0]] = row_data[tup[0]] + 1\\n            col_data[tup[1]] = col_data[tup[1]] + 1\\n        \\n        odd_count = 0 \\n        for rowp in range(m):\\n            for colp in range(n):\\n                val = row_data[rowp] + col_data[colp]\\n                if val % 2 != 0:\\n                    odd_count+=1\\n        \\n        return odd_count",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\\n        row_data = [0]*m\\n        col_data = [0]*n\\n        \\n        for tup in indices:\\n            row_data[tup[0]] = row_data[tup[0]] + 1\\n            col_data[tup[1]] = col_data[tup[1]] + 1\\n        \\n        odd_count = 0 \\n        for rowp in range(m):\\n            for colp in range(n):\\n                val = row_data[rowp] + col_data[colp]\\n                if val % 2 != 0:\\n                    odd_count+=1\\n        \\n        return odd_count",
                "codeTag": "Java"
            },
            {
                "id": 521611,
                "title": "javascript-solution",
                "content": "```javascript\\n/**\\n * @param {number} n\\n * @param {number} m\\n * @param {number[][]} indices\\n * @return {number}\\n */\\nvar oddCells = function(n, m, indices) {\\n  const nn = Array(n).fill(false);\\n  const mm = Array(m).fill(false);\\n  indices.forEach(([x, y]) => {\\n    nn[x] = !nn[x];\\n    mm[y] = !mm[y];\\n  });\\n  const numR = nn.reduce((acc, cur) => (cur ? acc + 1 : acc), 0);\\n  const numC = mm.reduce((acc, cur) => (cur ? acc + 1 : acc), 0);\\n  return numR * m + numC * n - 2 * numR * numC;\\n};\\n```\\n\\n* 44/44 cases passed (52 ms)\\n* Your runtime beats 94.41 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (34.7 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number} n\\n * @param {number} m\\n * @param {number[][]} indices\\n * @return {number}\\n */\\nvar oddCells = function(n, m, indices) {\\n  const nn = Array(n).fill(false);\\n  const mm = Array(m).fill(false);\\n  indices.forEach(([x, y]) => {\\n    nn[x] = !nn[x];\\n    mm[y] = !mm[y];\\n  });\\n  const numR = nn.reduce((acc, cur) => (cur ? acc + 1 : acc), 0);\\n  const numC = mm.reduce((acc, cur) => (cur ? acc + 1 : acc), 0);\\n  return numR * m + numC * n - 2 * numR * numC;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 433623,
                "title": "python3-solution-faster-than-99-53",
                "content": "```python\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        row_counter = {i:False for i in range(n)}\\n        column_counter = {i:False for i in range(m)}\\n        for r, c in indices:\\n            row_counter[r] = not row_counter[r]\\n            column_counter[c] = not column_counter[c]\\n        sum_row = sum(row_counter.values())\\n        sum_col = sum(column_counter.values())\\n        return (sum_row * m) + (sum_col * (n - sum_row)) - (sum_row * sum_col)\\n```\\nit\\'s easy, right?",
                "solutionTags": [],
                "code": "```python\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        row_counter = {i:False for i in range(n)}\\n        column_counter = {i:False for i in range(m)}\\n        for r, c in indices:\\n            row_counter[r] = not row_counter[r]\\n            column_counter[c] = not column_counter[c]\\n        sum_row = sum(row_counter.values())\\n        sum_col = sum(column_counter.values())\\n        return (sum_row * m) + (sum_col * (n - sum_row)) - (sum_row * sum_col)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 429184,
                "title": "c-solution-without-arrray-manipulation",
                "content": "I noticed we only have to care if we have a line crossing a row or a column, so I came up with this solution.\\n```\\nint OddCells(int n, int m, vector<vector<int>>& indices)\\n{\\n\\tint odds = 0;\\n\\tunordered_set<int> rows{};\\n\\tunordered_set<int> cols{};\\n\\tfor (const auto & p : indices)\\n\\t{\\n\\t\\t// If the row hasn\\'t been flipped to odds, indicate as such,\\n\\t\\t// else remove row as it has been flipped back to even.\\n\\t\\tif(rows.count(p[0]) == 0)\\n\\t\\t{\\n\\t\\t\\trows.insert(p[0]);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\trows.erase(p[0]);\\n\\t\\t}\\n\\t\\t// Same for columns\\n\\t\\tif(cols.count(p[1]) == 0)\\n\\t\\t{\\n\\t\\t\\tcols.insert(p[1]);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcols.erase(p[1]);  \\n\\t\\t}\\n\\t}\\n\\t// Where flipped rows and columns cross, that number remains even.\\n\\t// I.E. The number of odds corresponds to\\n\\t//      the product of odd rows and number of columns that haven\\'t been flipped,\\n    //      added to\\n\\t//      the product of odd columns and number of rows that haven\\'t been flipped.\\n\\treturn rows.size() * (m - cols.size()) + cols.size() * (n - rows.size());\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nint OddCells(int n, int m, vector<vector<int>>& indices)\\n{\\n\\tint odds = 0;\\n\\tunordered_set<int> rows{};\\n\\tunordered_set<int> cols{};\\n\\tfor (const auto & p : indices)\\n\\t{\\n\\t\\t// If the row hasn\\'t been flipped to odds, indicate as such,\\n\\t\\t// else remove row as it has been flipped back to even.\\n\\t\\tif(rows.count(p[0]) == 0)\\n\\t\\t{\\n\\t\\t\\trows.insert(p[0]);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\trows.erase(p[0]);\\n\\t\\t}\\n\\t\\t// Same for columns\\n\\t\\tif(cols.count(p[1]) == 0)\\n\\t\\t{\\n\\t\\t\\tcols.insert(p[1]);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcols.erase(p[1]);  \\n\\t\\t}\\n\\t}\\n\\t// Where flipped rows and columns cross, that number remains even.\\n\\t// I.E. The number of odds corresponds to\\n\\t//      the product of odd rows and number of columns that haven\\'t been flipped,\\n    //      added to\\n\\t//      the product of odd columns and number of rows that haven\\'t been flipped.\\n\\treturn rows.size() * (m - cols.size()) + cols.size() * (n - rows.size());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 425966,
                "title": "java-boolean-array-beats-100-explained-clean-code",
                "content": "We can use one array for row and one for column values. Essentially the sum will be odd if combined number for cell\\'s row and column is odd, which means that one and only one of two numbers is odd. Because we\\'re interested in odd/even flags we can use boolean, false == even, then on each increment we switch the flag. At the end loop we check if XOR of rows[r] cols[c] is true (1). \\n\\nO(nxm) time - need to iterate over every cell. O(m+n) space for boolean flags.\\n```\\n    public int oddCells(int n, int m, int[][] indices) {\\n        //create array of flags for rows and columns, false indicates even\\n        boolean[] rows = new boolean[n], cols = new boolean[m];\\n        //for every indices pair switch the flag\\n        for (int[] ind : indices) {\\n            rows[ind[0]] = !rows[ind[0]];\\n            cols[ind[1]] = !cols[ind[1]];\\n        }\\n        int res = 0;\\n        //now iterate over every cell and check if combined flag is true - this means that only one of\\n        //numbers is odd\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (rows[r]^cols[c])\\n                    res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\n    public int oddCells(int n, int m, int[][] indices) {\\n        //create array of flags for rows and columns, false indicates even\\n        boolean[] rows = new boolean[n], cols = new boolean[m];\\n        //for every indices pair switch the flag\\n        for (int[] ind : indices) {\\n            rows[ind[0]] = !rows[ind[0]];\\n            cols[ind[1]] = !cols[ind[1]];\\n        }\\n        int res = 0;\\n        //now iterate over every cell and check if combined flag is true - this means that only one of\\n        //numbers is odd\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (rows[r]^cols[c])\\n                    res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3254887,
                "title": "simple-java-solution-beats-90-27",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n\\n        int ans[][] = new int[m][n];\\n        for(int i=0; i<indices.length; i++) {\\n\\n            int rowIdx = indices[i][0];\\n            int colIdx = indices[i][1];\\n\\n            for(int j=0; j<n; j++) {\\n                ans[rowIdx][j] += 1;\\n            }\\n\\n            for(int j=0; j<m; j++) {\\n                ans[j][colIdx] += 1;\\n            }\\n        }\\n        \\n        int count = 0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(ans[i][j] % 2 != 0) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n\\n        int ans[][] = new int[m][n];\\n        for(int i=0; i<indices.length; i++) {\\n\\n            int rowIdx = indices[i][0];\\n            int colIdx = indices[i][1];\\n\\n            for(int j=0; j<n; j++) {\\n                ans[rowIdx][j] += 1;\\n            }\\n\\n            for(int j=0; j<m; j++) {\\n                ans[j][colIdx] += 1;\\n            }\\n        }\\n        \\n        int count = 0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(ans[i][j] % 2 != 0) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740530,
                "title": "above-expectations-java-sol-beats-more-than-95-in-time-and-space-complexity",
                "content": "# Code\\n```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int[][] matrix = new int[m][n];\\n        for(int i=0; i<indices.length; i++){\\n            rowInc(matrix, indices[i][0]);\\n            colInc(matrix, indices[i][1]);\\n        }\\n        int count = 0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]%2==1)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    void rowInc(int[][] mat, int rowNo){\\n        for(int i=0; i<mat[rowNo].length; i++){\\n            mat[rowNo][i]++;\\n        }\\n    }\\n\\n    void colInc(int[][] mat, int colNo){\\n        for(int i=0; i<mat.length; i++){\\n            mat[i][colNo]++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int[][] matrix = new int[m][n];\\n        for(int i=0; i<indices.length; i++){\\n            rowInc(matrix, indices[i][0]);\\n            colInc(matrix, indices[i][1]);\\n        }\\n        int count = 0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]%2==1)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    void rowInc(int[][] mat, int rowNo){\\n        for(int i=0; i<mat[rowNo].length; i++){\\n            mat[rowNo][i]++;\\n        }\\n    }\\n\\n    void colInc(int[][] mat, int colNo){\\n        for(int i=0; i<mat.length; i++){\\n            mat[i][colNo]++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208519,
                "title": "golang-solution-faster-than-100-with-explanation-and-images",
                "content": "[1252. Cells with Odd Values in a Matrix](https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/)\\n\\nThe idea of this solution is to use two maps, `x`, and `y`, and we can add all the values of indices to `x`, and `y` (`index[0]` to `x`, and `index[1]` to `y`). \\n\\nThen we can check whether all the `x`\\'s plus all the `y`\\'s is odd. If so, we know that we can add one to the result.\\n\\nIf you don\\'t understand we can take an example:\\n\\n`n = 3, m = 2, indices = [[0, 1],[1, 2]]`\\n\\n![image](https://assets.leetcode.com/users/images/85abb87d-ffa6-4bb6-951e-07c068462444_1621016538.2407796.jpeg)\\n\\n\\n> Note: You might have noticed that the position is in the format `(y, x)` instead of the average `(x, y)`. I don\\'t know why this is. If anybody knows, could you please comment?\\n> \\n> Continuing with the example, we find the rows and columns and fill them up. After that, we can find the sum of each position:\\n\\n![image](https://assets.leetcode.com/users/images/67b2cdd2-39db-40f6-9d09-fe1d9dd0aee0_1621016557.722223.jpeg)\\n\\n\\nYou might be wondering why this code uses `2` maps instead of `1` map or instead of `1` matrix. This code uses `2` maps instead of `1` map because it is not a matrix. The maps store all the `x` values and all the `y` values. If we put both maps together, we could get a matrix, but a matrix makes the space `O(m * n)` while the space of two maps is `O(m + n)`.\\n\\n``` go\\nfunc oddCells(n int, m int, indices [][]int) int {\\n\\tx := make(map[int]int)\\n\\ty := make(map[int]int)\\n\\tcounter := 0\\n\\tfor _, index := range indices {\\n\\t\\ty[index[0]]++\\n\\t\\tx[index[1]]++\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tif (y[i] + x[j]) % 2 == 1 {\\n\\t\\t\\t\\tcounter++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn counter\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc oddCells(n int, m int, indices [][]int) int {\\n\\tx := make(map[int]int)\\n\\ty := make(map[int]int)\\n\\tcounter := 0\\n\\tfor _, index := range indices {\\n\\t\\ty[index[0]]++\\n\\t\\tx[index[1]]++\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tif (y[i] + x[j]) % 2 == 1 {\\n\\t\\t\\t\\tcounter++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn counter\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 911376,
                "title": "python3-easy-to-understand-solution",
                "content": "class Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n\\t\\n        op=0\\n\\t\\tarr = [[0]*m for i in range(n)]   #creating the array\\n        for i in indices:\\n            for j in range(0,m):\\n                arr[i[0]][j]+=1     #incrementing the row elements\\n            for j in range(0,n):\\n                arr[j][i[1]]+=1     #incrementing the column elements\\n        for i in range(0,n):\\n            for j in range(0,m):\\n                if(arr[i][j]%2!=0):    #finding the odd numbers\\n                    op+=1\\n        return op",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n\\t\\n        op=0\\n\\t\\tarr = [[0]*m for i in range(n)]   #creating the array\\n        for i in indices:\\n            for j in range(0,m):\\n                arr[i[0]][j]+=1     #incrementing the row elements\\n            for j in range(0,n):\\n                arr[j][i[1]]+=1     #incrementing the column elements\\n        for i in range(0,n):\\n            for j in range(0,m):\\n                if(arr[i][j]%2!=0):    #finding the odd numbers\\n                    op+=1\\n        return op",
                "codeTag": "Java"
            },
            {
                "id": 858975,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        int count = 0;\\n        vector<int> row(n,0);\\n        vector<int> col(m,0);\\n        for(int i = 0; i < indices.size(); i++)\\n        {\\n            row[indices[i][0]]++;\\n            col[indices[i][1]]++;\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if((row[i] + col[j]) %2 == 1)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        int count = 0;\\n        vector<int> row(n,0);\\n        vector<int> col(m,0);\\n        for(int i = 0; i < indices.size(); i++)\\n        {\\n            row[indices[i][0]]++;\\n            col[indices[i][1]]++;\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if((row[i] + col[j]) %2 == 1)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 498249,
                "title": "linear-complexity-solution",
                "content": "```\\npublic class Solution {\\n    public int OddCells(int n, int m, int[][] indices) {\\n        var rows = new bool[n];\\n        var cols = new bool[m];\\n        var r = 0;\\n        var c = 0;\\n        \\n        for(var i=0; i<indices.Length; i++) {\\n            rows[indices[i][0]] = !rows[indices[i][0]];\\n            r += rows[indices[i][0]] ? 1 : -1;\\n            \\n            cols[indices[i][1]] = !cols[indices[i][1]];\\n            c += cols[indices[i][1]] ? 1 : -1;\\n        }\\n        \\n        return r * (m - c) + c * (n - r);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int OddCells(int n, int m, int[][] indices) {\\n        var rows = new bool[n];\\n        var cols = new bool[m];\\n        var r = 0;\\n        var c = 0;\\n        \\n        for(var i=0; i<indices.Length; i++) {\\n            rows[indices[i][0]] = !rows[indices[i][0]];\\n            r += rows[indices[i][0]] ? 1 : -1;\\n            \\n            cols[indices[i][1]] = !cols[indices[i][1]];\\n            c += cols[indices[i][1]] ? 1 : -1;\\n        }\\n        \\n        return r * (m - c) + c * (n - r);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491140,
                "title": "python-3-95-100-short-code-with-simple-idea",
                "content": "1, find the number of effective row and col ops.\\n  For example, if you operate on the first row twice, it\\'s just like you\\'re doing nothing\\n2, counting the contribution from row and col operations independently, say m*a + n*b\\n3, subtract the overcounting\\n  For example, you have an op as [0,0], then the matrix entry (0, 0) is operated twice thus even.\\n```\\nclass Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        rowop, colop = [i[0] for i in indices], [i[1] for i in indices]\\n        set_row, set_col = set(rowop), set(colop)\\n        a, b = sum(rowop.count(i)%2 for i in set_row), sum(colop.count(i)%2 for i in set_col)\\n        return m * a + n * b - 2 * a * b\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        rowop, colop = [i[0] for i in indices], [i[1] for i in indices]\\n        set_row, set_col = set(rowop), set(colop)\\n        a, b = sum(rowop.count(i)%2 for i in set_row), sum(colop.count(i)%2 for i in set_col)\\n        return m * a + n * b - 2 * a * b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436452,
                "title": "java-time-efficient-solution",
                "content": "```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        int[] rows = new int[n];\\n        int[] cols = new int[m];\\n        for (int[] indice : indices) {\\n            rows[indice[0]]++;\\n            cols[indice[1]]++;\\n        }\\n        int row_odd = 0;\\n        int row_even = 0;\\n        int col_odd = 0;\\n        int col_even = 0;\\n        for (int row : rows) {\\n            if (row % 2 == 0) {\\n                row_even++;\\n            } else {\\n                row_odd++;\\n            }\\n        }\\n        for (int col : cols) {\\n            if (col % 2 == 0) {\\n                col_even++;\\n            } else {\\n                col_odd++;\\n            }\\n        }\\n        return row_odd * m - col_odd * row_odd + row_even * m - col_even * row_even;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        int[] rows = new int[n];\\n        int[] cols = new int[m];\\n        for (int[] indice : indices) {\\n            rows[indice[0]]++;\\n            cols[indice[1]]++;\\n        }\\n        int row_odd = 0;\\n        int row_even = 0;\\n        int col_odd = 0;\\n        int col_even = 0;\\n        for (int row : rows) {\\n            if (row % 2 == 0) {\\n                row_even++;\\n            } else {\\n                row_odd++;\\n            }\\n        }\\n        for (int col : cols) {\\n            if (col % 2 == 0) {\\n                col_even++;\\n            } else {\\n                col_odd++;\\n            }\\n        }\\n        return row_odd * m - col_odd * row_odd + row_even * m - col_even * row_even;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425354,
                "title": "rows-columns-2-1-javascript-solution-48-ms",
                "content": "```\\nvar oddCells = function(n, m, indices) {\\n    var result = 0;\\n    \\n    var rows = new Array(n).fill(0);\\n    var columns = new Array(m).fill(0);\\n    for (var i = 0; i < indices.length; i++) {\\n        rows[indices[i][0]]++;\\n        columns[indices[i][1]]++;\\n    }\\n    \\n    for (var i = 0; i < n; i++) {\\n        for (var j = 0; j < m; j++) {\\n            if ((rows[i] + columns[j]) % 2 === 1) {\\n                result++;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar oddCells = function(n, m, indices) {\\n    var result = 0;\\n    \\n    var rows = new Array(n).fill(0);\\n    var columns = new Array(m).fill(0);\\n    for (var i = 0; i < indices.length; i++) {\\n        rows[indices[i][0]]++;\\n        columns[indices[i][1]]++;\\n    }\\n    \\n    for (var i = 0; i < n; i++) {\\n        for (var j = 0; j < m; j++) {\\n            if ((rows[i] + columns[j]) % 2 === 1) {\\n                result++;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3257200,
                "title": "java-with-90-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int temp[][] = new int[m][n];\\n        for(int  i = 0; i<indices.length ; i++){\\n\\n            int rowidx = indices[i][0];\\n            int colidx = indices[i][1];\\n\\n            for(int j = 0 ; j<n ; j++ ){\\n                temp[rowidx][j] += 1;\\n\\n            }\\n\\n            for(int k = 0 ; k<m ; k++){\\n                temp[k][colidx] += 1; \\n            }\\n\\n            }\\n\\n            int count  = 0;\\n\\n            for(int i = 0 ; i <m ; i++){\\n                for(int j = 0 ; j<n ; j++){\\n                    if(temp[i][j] % 2 != 0){\\n                        count++;\\n                    }\\n                } \\n            }\\n\\n            return count;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int temp[][] = new int[m][n];\\n        for(int  i = 0; i<indices.length ; i++){\\n\\n            int rowidx = indices[i][0];\\n            int colidx = indices[i][1];\\n\\n            for(int j = 0 ; j<n ; j++ ){\\n                temp[rowidx][j] += 1;\\n\\n            }\\n\\n            for(int k = 0 ; k<m ; k++){\\n                temp[k][colidx] += 1; \\n            }\\n\\n            }\\n\\n            int count  = 0;\\n\\n            for(int i = 0 ; i <m ; i++){\\n                for(int j = 0 ; j<n ; j++){\\n                    if(temp[i][j] % 2 != 0){\\n                        count++;\\n                    }\\n                } \\n            }\\n\\n            return count;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812567,
                "title": "java-1ms-runtime",
                "content": "# Complexity\\n- Time complexity:O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/a82508b3-7774-4e9c-981e-923e1099aa20_1668393476.8920178.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int[][] mat = new int[m][n];\\n        for(int[] rc : indices)\\n        {\\n            for(int i = 0;i<n;i++)\\n                mat[rc[0]][i]++;\\n            for(int j =0;j<m;j++)\\n                mat[j][rc[1]]++;\\n        }\\n\\n        int ans = 0;\\n        for(int[] arr : mat)\\n            for(int ele : arr)\\n            {\\n                if(ele%2 != 0)\\n                    ans++;\\n            }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int[][] mat = new int[m][n];\\n        for(int[] rc : indices)\\n        {\\n            for(int i = 0;i<n;i++)\\n                mat[rc[0]][i]++;\\n            for(int j =0;j<m;j++)\\n                mat[j][rc[1]]++;\\n        }\\n\\n        int ans = 0;\\n        for(int[] arr : mat)\\n            for(int ele : arr)\\n            {\\n                if(ele%2 != 0)\\n                    ans++;\\n            }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598381,
                "title": "c-bitset-beautiful-solution",
                "content": "Key Points :-\\n* The value of the cell will be odd only if one of row and col is odd and other is even.\\n* By row/col being odd, I mean the value to be added at last to row/col respectively.\\n* To store if the number is odd or not, we do not need to store the number, we just need the last bit to store parity. std::bitset is best for this job.\\n```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        bitset<50> rows, cols;\\n        for (const auto& v : indices) rows.flip(v.front()), cols.flip(v.back());\\n        const auto odd_rows = rows.count();\\n        const auto odd_cols = cols.count();\\n        return (m - odd_rows) * odd_cols + (n - odd_cols) * odd_rows;\\n    }\\n};\\n```\\n**If you have any doubts or suggestions, please feel free to comment.\\nIf you find this solution useful, you know where the upvote is :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        bitset<50> rows, cols;\\n        for (const auto& v : indices) rows.flip(v.front()), cols.flip(v.back());\\n        const auto odd_rows = rows.count();\\n        const auto odd_cols = cols.count();\\n        return (m - odd_rows) * odd_cols + (n - odd_cols) * odd_rows;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408641,
                "title": "java-solution-easy-to-understand",
                "content": "class Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        \\n        //create a matrix and initialized it with zero\\n        int [][] mat=new int[m][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                mat[i][j]=0;\\n            }\\n        }\\n        \\n        //main logic \\n        int len=indices.length;\\n        for(int i=0;i<len;i++)\\n        {\\n            int x=indices[i][0];\\n            int y=indices[i][1];\\n            \\n            for(int j=0;j<n;j++)\\n            {\\n                mat[x][j]++;\\n            }\\n            for(int j=0;j<m;j++)\\n            {\\n                mat[j][y]++;\\n            }\\n        }\\n        \\n        //counting if odd number are present increment count\\n        int count=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(mat[i][j]%2!=0)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n         \\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        \\n        //create a matrix and initialized it with zero\\n        int [][] mat=new int[m][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                mat[i][j]=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1215493,
                "title": "c-solution-simple-and-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n\\t\\n\\t\\t//Initialize the count variable for counting the number of odd valued cells\\n        int count=0;\\n\\t\\t//Initialize a vector of the specified rows and columns consisting of all zeros\\n        vector<vector<int>> matrix(m, vector<int> (n,0));\\n\\t\\t\\n        for(int i=0; i<indices.size(); i++){\\n\\t\\t\\t//First loop through all the cells in the specified row and increment the values\\n            for(int j=0; j<matrix[indices[i][0]].size(); j++)\\n                ++matrix[indices[i][0]][j];\\n            \\n\\t\\t\\t//Then loop through all the cells in the specified column and do the same \\n            for(int j=0; j<matrix.size(); j++)\\n                ++matrix[j][indices[i][1]];\\n        }\\n        \\n\\t\\t//Finally loop through the matrix to count the number of odd valued cells\\n        for(int i=0; i<matrix.size(); i++){\\n            for(int j=0; j<matrix[i].size(); j++){\\n                if(matrix[i][j]%2)\\n                    count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n\\t\\n\\t\\t//Initialize the count variable for counting the number of odd valued cells\\n        int count=0;\\n\\t\\t//Initialize a vector of the specified rows and columns consisting of all zeros\\n        vector<vector<int>> matrix(m, vector<int> (n,0));\\n\\t\\t\\n        for(int i=0; i<indices.size(); i++){\\n\\t\\t\\t//First loop through all the cells in the specified row and increment the values\\n            for(int j=0; j<matrix[indices[i][0]].size(); j++)\\n                ++matrix[indices[i][0]][j];\\n            \\n\\t\\t\\t//Then loop through all the cells in the specified column and do the same \\n            for(int j=0; j<matrix.size(); j++)\\n                ++matrix[j][indices[i][1]];\\n        }\\n        \\n\\t\\t//Finally loop through the matrix to count the number of odd valued cells\\n        for(int i=0; i<matrix.size(); i++){\\n            for(int j=0; j<matrix[i].size(); j++){\\n                if(matrix[i][j]%2)\\n                    count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988114,
                "title": "java-o-n-m",
                "content": "```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        int[] rows = new int[n];\\n        int[] cols = new int[m];\\n        int totalOdd = 0, totalOddRows = 0;\\n        for(int i = 0; i < indices.length; i++){\\n            if(rows[indices[i][0]] == 1){\\n                rows[indices[i][0]] = 0;\\n            } else {\\n                rows[indices[i][0]] = 1;\\n            }\\n            if(cols[indices[i][1]] == 1){\\n                cols[indices[i][1]] = 0;\\n            } else {\\n                cols[indices[i][1]] = 1;\\n            }\\n        }\\n        for(int i : rows){\\n            if(i == 1){\\n                totalOddRows++;\\n                totalOdd += m;\\n            }\\n        } \\n        for(int i : cols){\\n            if(i == 1){\\n                totalOdd -= totalOddRows;\\n                totalOdd += n-totalOddRows;\\n            }\\n        }\\n        return totalOdd;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        int[] rows = new int[n];\\n        int[] cols = new int[m];\\n        int totalOdd = 0, totalOddRows = 0;\\n        for(int i = 0; i < indices.length; i++){\\n            if(rows[indices[i][0]] == 1){\\n                rows[indices[i][0]] = 0;\\n            } else {\\n                rows[indices[i][0]] = 1;\\n            }\\n            if(cols[indices[i][1]] == 1){\\n                cols[indices[i][1]] = 0;\\n            } else {\\n                cols[indices[i][1]] = 1;\\n            }\\n        }\\n        for(int i : rows){\\n            if(i == 1){\\n                totalOddRows++;\\n                totalOdd += m;\\n            }\\n        } \\n        for(int i : cols){\\n            if(i == 1){\\n                totalOdd -= totalOddRows;\\n                totalOdd += n-totalOddRows;\\n            }\\n        }\\n        return totalOdd;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703755,
                "title": "python-very-easy-solution",
                "content": "\\tdef oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        rows = [0]*n\\n        cols = [0]*m\\n        for index in indices:\\n            rows[index[0]] += 1\\n            cols[index[1]] += 1\\n        ans = 0\\n        for i in range(n):\\n            for j in range(m):\\n                if (rows[i] + cols[j]) % 2 != 0:\\n                    ans += 1\\n        return ans",
                "solutionTags": [],
                "code": "\\tdef oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        rows = [0]*n\\n        cols = [0]*m\\n        for index in indices:\\n            rows[index[0]] += 1\\n            cols[index[1]] += 1\\n        ans = 0\\n        for i in range(n):\\n            for j in range(m):\\n                if (rows[i] + cols[j]) % 2 != 0:\\n                    ans += 1\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 631406,
                "title": "python-easiest-solution-least-time-and-space",
                "content": "```\\nclass Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        r=[]\\n        c=[]\\n        for ch in indices:\\n            if ch[0] not in r:\\n                r.append(ch[0])\\n            else:\\n                r.remove(ch[0])\\n                \\n            if ch[1] not in c:\\n                c.append(ch[1])\\n            else:\\n                c.remove(ch[1])             \\n        return ((len(r)*m + len(c)*n) - 2*len(r)*len(c))",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        r=[]\\n        c=[]\\n        for ch in indices:\\n            if ch[0] not in r:\\n                r.append(ch[0])\\n            else:\\n                r.remove(ch[0])\\n                \\n            if ch[1] not in c:\\n                c.append(ch[1])\\n            else:\\n                c.remove(ch[1])             \\n        return ((len(r)*m + len(c)*n) - 2*len(r)*len(c))",
                "codeTag": "Java"
            },
            {
                "id": 619782,
                "title": "java-o-1-space-solution-that-beats-100-both-time-and-space",
                "content": "Just simply use two long values to flip the bits. Not sure why everyone is using boolean arrays and bitsets given the constraint of the problem.\\n```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        long oddRows = 0;\\n        long oddCols = 0; \\n        \\n        for(int[] index : indices) {\\n            oddRows ^= (1L << index[0]);\\n            oddCols ^= (1L << index[1]);\\n        }\\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                res += ((oddRows >> i) & 1L) ^ ((oddCols >> j) & 1L);\\n            }\\n        }\\n        \\n        return res; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        long oddRows = 0;\\n        long oddCols = 0; \\n        \\n        for(int[] index : indices) {\\n            oddRows ^= (1L << index[0]);\\n            oddCols ^= (1L << index[1]);\\n        }\\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                res += ((oddRows >> i) & 1L) ^ ((oddCols >> j) & 1L);\\n            }\\n        }\\n        \\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509515,
                "title": "swift-easy-to-understand",
                "content": "```\\nclass Solution {\\n    func oddCells(_ n: Int, _ m: Int, _ indices: [[Int]]) -> Int {\\n\\t\\n        var arr = Array(repeating: Array(repeating: 0, count: m), count: n)\\n\\t\\t\\n        for i in indices {\\n            let row = i[0]\\n            let column = i[1]\\n            for j in 0..<arr[row].count {\\n                arr[row][j] += 1\\n            }\\n            for k in 0..<arr.count {\\n                arr[k][column] += 1\\n            }\\n        }\\n        return arr.flatMap({$0}).filter({$0 % 2 != 0}).count\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func oddCells(_ n: Int, _ m: Int, _ indices: [[Int]]) -> Int {\\n\\t\\n        var arr = Array(repeating: Array(repeating: 0, count: m), count: n)\\n\\t\\t\\n        for i in indices {\\n            let row = i[0]\\n            let column = i[1]\\n            for j in 0..<arr[row].count {\\n                arr[row][j] += 1\\n            }\\n            for k in 0..<arr.count {\\n                arr[k][column] += 1\\n            }\\n        }\\n        return arr.flatMap({$0}).filter({$0 % 2 != 0}).count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502397,
                "title": "scala-using-java-bitset-without-emulation",
                "content": "```scala\\nobject Solution {\\n    def oddCells(n: Int, m: Int, indices: Array[Array[Int]]): Int = {\\n        val rowSet = new java.util.BitSet\\n        val colSet = new java.util.BitSet\\n        \\n        indices.foreach { case Array(r, c) =>\\n            rowSet.flip(r)\\n            colSet.flip(c)\\n        }\\n        \\n        val rowNum = rowSet.cardinality\\n        val colNum = colSet.cardinality\\n\\n        rowNum*m + colNum*n - 2*rowNum*colNum\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```scala\\nobject Solution {\\n    def oddCells(n: Int, m: Int, indices: Array[Array[Int]]): Int = {\\n        val rowSet = new java.util.BitSet\\n        val colSet = new java.util.BitSet\\n        \\n        indices.foreach { case Array(r, c) =>\\n            rowSet.flip(r)\\n            colSet.flip(c)\\n        }\\n        \\n        val rowNum = rowSet.cardinality\\n        val colNum = colSet.cardinality\\n\\n        rowNum*m + colNum*n - 2*rowNum*colNum\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 453268,
                "title": "java-faster-lesser-than100",
                "content": "```\\n    public int oddCells(int n, int m, int[][] indices) {\\n        byte[] row = new byte[n];\\n        byte[] col = new byte[m]; \\n        for (int[] i : indices) {\\n            row[i[0]] ^= 1;\\n            col[i[1]] ^= 1;\\n        }\\n        int sum = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                sum += row[i] ^ col[j];\\n            }\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int oddCells(int n, int m, int[][] indices) {\\n        byte[] row = new byte[n];\\n        byte[] col = new byte[m]; \\n        for (int[] i : indices) {\\n            row[i[0]] ^= 1;\\n            col[i[1]] ^= 1;\\n        }\\n        int sum = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                sum += row[i] ^ col[j];\\n            }\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 429623,
                "title": "91-56-faster-100-00-memory-efficient-in-java",
                "content": "```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        if(n <= 0 || m <= 0 || indices == null || indices.length == 0 || indices[0].length == 0) return 0;\\n        \\n        int[] rows = new int[n];\\n        int[] clms = new int[m];\\n        \\n        \\n        for(int i = 0; i < indices.length; i++){\\n            int[] rc = indices[i];\\n            rows[rc[0]] = ++rows[rc[0]];\\n            clms[rc[1]] = ++clms[rc[1]];\\n        }\\n\\n        int ret = 0;\\n        for(int r = 0; r < rows.length; r++){\\n            for(int c = 0; c < clms.length; c++){\\n                if((rows[r] + clms[c]) % 2 == 1){\\n                    ret++;\\n                }\\n            }\\n        }\\n              \\n        return ret;       \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        if(n <= 0 || m <= 0 || indices == null || indices.length == 0 || indices[0].length == 0) return 0;\\n        \\n        int[] rows = new int[n];\\n        int[] clms = new int[m];\\n        \\n        \\n        for(int i = 0; i < indices.length; i++){\\n            int[] rc = indices[i];\\n            rows[rc[0]] = ++rows[rc[0]];\\n            clms[rc[1]] = ++clms[rc[1]];\\n        }\\n\\n        int ret = 0;\\n        for(int r = 0; r < rows.length; r++){\\n            for(int c = 0; c < clms.length; c++){\\n                if((rows[r] + clms[c]) % 2 == 1){\\n                    ret++;\\n                }\\n            }\\n        }\\n              \\n        return ret;       \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429425,
                "title": "readable-python",
                "content": "Keep track of number of times row or col is in indices. For all cell locations, value is total number of times row and col of cell is in indices. Cell value modulo 2 (i.e.: `x % 2`) will add one to answer if cell value is odd. \\n\\n```\\nclass Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        from collections import Counter\\n        \\n        rows = Counter()\\n        cols = Counter()\\n        for r, c in indices:\\n            rows[r] += 1\\n            cols[c] += 1\\n        \\n        ans = 0\\n        for row in range(n):\\n            for col in range(m):\\n                x = rows[row] + cols[col]\\n                ans += x % 2            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        from collections import Counter\\n        \\n        rows = Counter()\\n        cols = Counter()\\n        for r, c in indices:\\n            rows[r] += 1\\n            cols[c] += 1\\n        \\n        ans = 0\\n        for row in range(n):\\n            for col in range(m):\\n                x = rows[row] + cols[col]\\n                ans += x % 2            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427770,
                "title": "simple-math",
                "content": "For each row/column, change even times will have no effect on final result. So we only need to record how many rows/columns was changed odd times. \\n\\nAnd since each row/column was changed odd times, their intersections will change even times and thus will be reduced from the result. \\n```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        int[] rows = new int[n], columns = new int[m];\\n        for(int[] index:indices){\\n            rows[index[0]]^=1;\\n            columns[index[1]]^=1;\\n        }\\n        int rowChange = 0, columnChange = 0;\\n        for(int i=0;i<n;i++) rowChange+=rows[i];\\n        for(int i=0;i<m;i++) columnChange+=columns[i];\\n        return rowChange*m+columnChange*n-2*rowChange*columnChange;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        int[] rows = new int[n], columns = new int[m];\\n        for(int[] index:indices){\\n            rows[index[0]]^=1;\\n            columns[index[1]]^=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 425117,
                "title": "python-3-with-explanation-five-lines-48-ms",
                "content": "_Explanation:_\\n\\nThis program works by simulating the process of incrementing step by step. The program starts by creating a matrix of zeros which has dimensions n x m. It then iterates through the [row, column] indices that are in the matrix ```I```. Given [x,y] as an element in ```I```, we need to increment all the numbers in row x of matrix M and in column y of matrix M. However, since we only care about whether the final value is even or odd, we only need to change 0s to 1s and 1s back to 0s as a simpler way to keep track. A simple way to map 0 to 1 and 1 to 0 is simply to map x to 1 - x. Thus within the main for loop, there are two for loops that \\'increment\\' by changing the current value to its complement. Essentially, we are doing mod 2 addition instead of base 10 addition. This allows us to simply find the sum of all numbers in matrix M to give us the count of odd numbers in the final matrix. We don\\'t have to determine which numbers are even and odd. Since we used mod 2 addition, we only need to count the number of 1s which means add all the numbers in the final matrix M.\\n\\n```\\nclass Solution:\\n    def oddCells(self, n: int, m: int, I: List[List[int]]) -> int:\\n        M = [[0]*m for _ in range(n)]\\n        for x,y in I:\\n            for j in range(m): M[x][j] = 1 - M[x][j]\\n            for i in range(n): M[i][y] = 1 - M[i][y]\\n        return sum(sum(M,[]))\\n        \\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```I```\n```I```",
                "codeTag": "Unknown"
            },
            {
                "id": 3686467,
                "title": "java-count-odd-cells",
                "content": "\\n# Count Odd Cells\\n\\n## Intuition\\n\\nThe problem requires us to count the number of cells in a matrix that have an odd value after performing certain operations. The operations involve incrementing the values in specific rows and columns based on the given indices. To solve this problem, we can follow a step-by-step approach.\\n\\n## Approach\\n\\n1. We define a function `oddCells` that takes three parameters: `m` (number of rows), `n` (number of columns), and `indices` (an array of row and column indices to perform the operations).\\n2. We initialize a 2D integer array `mat` of size `m x n` to represent the matrix.\\n3. We iterate through each index pair in the `indices` array using a for loop.\\n4. For each index pair, we extract the row index `a` and column index `b`.\\n5. We increment the values in the `a`-th row of `mat` by 1 using a nested for loop that iterates through each column.\\n6. We increment the values in the `b`-th column of `mat` by 1 using another nested for loop that iterates through each row.\\n7. After performing the operations, we initialize a variable `odd` to 0 to keep track of the count of cells with odd values.\\n8. We iterate through each row in `mat` using a for-each loop.\\n9. For each element `num` in the row, if `num` is odd (i.e., `num % 2 == 1`), we increment `odd` by 1.\\n10. Finally, we return the value of `odd`, which represents the count of cells with odd values in the matrix.\\n\\n## Complexity\\n\\n- Time complexity: O(m x n + k), where m is the number of rows, n is the number of columns, and k is the number of index pairs in the `indices` array. We perform operations on each index pair to update the matrix, and then iterate through each element in the matrix to count the odd cells.\\n- Space complexity: O(m x n), as we use a 2D matrix of size `m x n` to represent the matrix.\\n\\n# Code\\n```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int[][] mat = new int[m][n];\\n        for(int i=0;i<indices.length;i++){\\n            int a= indices[i][0];\\n            int b=indices[i][1];\\n\\n            for(int j=0;j<n;j++){\\n                mat[a][j] +=1;\\n            }\\n            for(int j=0;j<m;j++){\\n                mat[j][b] +=1;\\n            }\\n        }\\n        int odd =0;\\n        for(int[] row : mat){\\n            for(int num : row){\\n                if(num%2==1){\\n                    odd++;\\n                }\\n            }\\n        }\\n        return odd;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int[][] mat = new int[m][n];\\n        for(int i=0;i<indices.length;i++){\\n            int a= indices[i][0];\\n            int b=indices[i][1];\\n\\n            for(int j=0;j<n;j++){\\n                mat[a][j] +=1;\\n            }\\n            for(int j=0;j<m;j++){\\n                mat[j][b] +=1;\\n            }\\n        }\\n        int odd =0;\\n        for(int[] row : mat){\\n            for(int num : row){\\n                if(num%2==1){\\n                    odd++;\\n                }\\n            }\\n        }\\n        return odd;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657988,
                "title": "js-very-easy-solution",
                "content": "```\\nvar oddCells = function(m, n, indices) {\\n    const matrix = new Array(m).fill(0).map(item => new Array(n).fill(0));\\n    let output = 0;\\n    \\n    for (let i = 0; i < indices.length; i++) {\\n        const [x, y] = indices[i];\\n        \\n        for (let j = 0; j < n; j++) {\\n            matrix[x][j]++;\\n            if (matrix[x][j]%2) {\\n                output++;\\n            } else {\\n                output--;\\n            }\\n        }\\n        for (let p = 0; p < m; p++) {\\n            matrix[p][y]++;\\n            if (matrix[p][y]%2) {\\n                output++;\\n            } else {\\n                output--;\\n            }\\n        }\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar oddCells = function(m, n, indices) {\\n    const matrix = new Array(m).fill(0).map(item => new Array(n).fill(0));\\n    let output = 0;\\n    \\n    for (let i = 0; i < indices.length; i++) {\\n        const [x, y] = indices[i];\\n        \\n        for (let j = 0; j < n; j++) {\\n            matrix[x][j]++;\\n            if (matrix[x][j]%2) {\\n                output++;\\n            } else {\\n                output--;\\n            }\\n        }\\n        for (let p = 0; p < m; p++) {\\n            matrix[p][y]++;\\n            if (matrix[p][y]%2) {\\n                output++;\\n            } else {\\n                output--;\\n            }\\n        }\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2634200,
                "title": "java-solution-with-explanation-2-methods-optimized-solution",
                "content": "Brute force approch \\nneed no explanation:-\\n just do as the question says. \\n Time complexity will be O(indices.length*(m+n))\\n \\n```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n       \\n      int[][] matrix= new int[m][n];\\n        \\n        for(int i=0; i< indices.length;i++){\\n            \\n            int row = indices[i][0];\\n            int col = indices[i][1];\\n            \\n            for(int p=0; p<n; p++){\\n                matrix[row][p]++;\\n            }\\n            \\n            for(int q=0; q<m; q++){\\n                matrix[q][col]++;\\n            }         \\n        }\\n        \\n        int odd_count=0;\\n        \\n        for(int s=0; s<m; s++){\\n            for(int t=0; t<n; t++){\\n                if(matrix[s][t]%2!=0){\\n                    odd_count++;\\n                }\\n            }\\n        }\\n        \\n        return odd_count;\\n\\t}\\n}\\n        \\n```\\n\\n\\n\\nOptimized solution\\n\\nThe given indices {i,j} means the whole row i and whole col j will be incremented by 1;\\n        \\n1.first we initialize two boolean array of row size and col size.\\n2. Then for all the given indices we Xor it with true, so everytime a row is incremented its index (row boolean array index) will turn to true and if it is incremented twice it will change to false again.  \\n3. now we will count the no. of rows that are odd and no. of cols that are odd;     \\n4. Then for the ans, we will have to return row_odd_count*n + col_odd_count*m - 2*row_odd_count*col_odd_count\\n        \\n we have to subtract 2*row_odd_count*col_odd_count cause these elements are being added twice in the ans.\\n        \\nDo it using a paper and pen and you will understand the concept. If not then watch a youtube video.\\n\\t\\t\\n```\\n\\t\\t \\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n\\t\\n\\tboolean[] row = new boolean[m];\\n\\tboolean[] col = new boolean[n];\\n\\n\\tfor(int i =0; i< indices.length; i++){\\n\\n\\t\\trow[indices[i][0]] ^= true;\\n\\t\\tcol[indices[i][1]] ^= true;\\n\\n\\t}\\n\\n\\tint row_odd_count = 0;\\n\\tint col_odd_count = 0;\\n\\n\\tfor(int j=0; j<m; j++){\\n\\t\\tif(row[j]==true){\\n\\t\\t\\t row_odd_count++;\\n\\t\\t}\\n\\n\\t}\\n\\tfor(int k=0; k<n; k++){\\n\\t\\tif(col[k]==true){\\n\\t\\t\\tcol_odd_count++;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tint ans = row_odd_count*n + col_odd_count*m - 2*row_odd_count*col_odd_count;\\n\\n\\treturn ans;\\n\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n       \\n      int[][] matrix= new int[m][n];\\n        \\n        for(int i=0; i< indices.length;i++){\\n            \\n            int row = indices[i][0];\\n            int col = indices[i][1];\\n            \\n            for(int p=0; p<n; p++){\\n                matrix[row][p]++;\\n            }\\n            \\n            for(int q=0; q<m; q++){\\n                matrix[q][col]++;\\n            }         \\n        }\\n        \\n        int odd_count=0;\\n        \\n        for(int s=0; s<m; s++){\\n            for(int t=0; t<n; t++){\\n                if(matrix[s][t]%2!=0){\\n                    odd_count++;\\n                }\\n            }\\n        }\\n        \\n        return odd_count;\\n\\t}\\n}\\n        \\n```\n```\\n\\t\\t \\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n\\t\\n\\tboolean[] row = new boolean[m];\\n\\tboolean[] col = new boolean[n];\\n\\n\\tfor(int i =0; i< indices.length; i++){\\n\\n\\t\\trow[indices[i][0]] ^= true;\\n\\t\\tcol[indices[i][1]] ^= true;\\n\\n\\t}\\n\\n\\tint row_odd_count = 0;\\n\\tint col_odd_count = 0;\\n\\n\\tfor(int j=0; j<m; j++){\\n\\t\\tif(row[j]==true){\\n\\t\\t\\t row_odd_count++;\\n\\t\\t}\\n\\n\\t}\\n\\tfor(int k=0; k<n; k++){\\n\\t\\tif(col[k]==true){\\n\\t\\t\\tcol_odd_count++;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tint ans = row_odd_count*n + col_odd_count*m - 2*row_odd_count*col_odd_count;\\n\\n\\treturn ans;\\n\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552675,
                "title": "simple-java-solution",
                "content": "1-count all the rows and columns that appear odd times\\n2-check all the cells and get the desired answer\\n```\\npublic int oddCells(int n, int m, int[][] indices){\\n\\t\\tboolean[] oddRows = new boolean[n], oddCols = new boolean[m];\\n        for (int[] idx : indices) {\\n            oddRows[idx[0]] ^= true; \\n            oddCols[idx[1]] ^= true; \\n        }\\n        int cnt = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                cnt += oddRows[i] ^ oddCols[j] ? 1 : 0; \\n            }\\n        }\\n        return cnt;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\npublic int oddCells(int n, int m, int[][] indices){\\n\\t\\tboolean[] oddRows = new boolean[n], oddCols = new boolean[m];\\n        for (int[] idx : indices) {\\n            oddRows[idx[0]] ^= true; \\n            oddCols[idx[1]] ^= true; \\n        }\\n        int cnt = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                cnt += oddRows[i] ^ oddCols[j] ? 1 : 0; \\n            }\\n        }\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2429333,
                "title": "java-simple-and-easy-solution-builds-logic-for-this-question",
                "content": "```\\nint[][] matrix = new int[m][n] ;\\n        // we make a new matrix of dimension m x n having all elements as 0 ;\\n        for(int i = 0 ; i < m ;i++){\\n            for(int j = 0 ; j < n ; j++){\\n                matrix[i][j] = 0 ;\\n        \\n            }\\n        }\\n        \\n        int x = 0 ; int y = 0 ;\\n        //we made 2 variables because we will be using these ;\\n        \\n        for(int i = 0 ; i < indices.length ; i++){//for iterating over indexes of indices\\n\\n              x = indices[i][0] ;//here row is a variable but not the columns because there will be 2 columns only everytime;\\n             y = indices[i][1];//and we will be storing them in x and y that we made ;\\n            \\n              for(int col = 0 ; col < matrix[x].length ;col++ ){\\n                  //this for loop increments the whole row;    \\n                  matrix[x][col] ++;\\n                   }\\n            \\n            for(int row = 0 ; row < matrix.length ; row++ ){\\n                //this for loop increments the whole column ;\\n                    matrix[row][y] ++ ;\\n                }\\n            }\\n        \\n        int ans = 0 ;\\n        //variable ;\\n        \\n        //for loop for iterating over the incremented matrix ;\\n        \\n        for(int i = 0 ; i < matrix.length ; i++){\\n            for(int j = 0 ; j < matrix[i].length ; j++){\\n                //for checking if the element of the matrix is odd or even ;\\n                int temp = matrix[i][j] ;\\n                if(temp % 2 != 0){\\n                    ans ++ ;\\n                }\\n            }\\n        }\\n        //we return the ans ;\\n        return ans ;",
                "solutionTags": [
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nint[][] matrix = new int[m][n] ;\\n        // we make a new matrix of dimension m x n having all elements as 0 ;\\n        for(int i = 0 ; i < m ;i++){\\n            for(int j = 0 ; j < n ; j++){\\n                matrix[i][j] = 0 ;\\n        \\n            }\\n        }\\n        \\n        int x = 0 ; int y = 0 ;\\n        //we made 2 variables because we will be using these ;\\n        \\n        for(int i = 0 ; i < indices.length ; i++){//for iterating over indexes of indices\\n\\n              x = indices[i][0] ;//here row is a variable but not the columns because there will be 2 columns only everytime;\\n             y = indices[i][1];//and we will be storing them in x and y that we made ;\\n            \\n              for(int col = 0 ; col < matrix[x].length ;col++ ){\\n                  //this for loop increments the whole row;    \\n                  matrix[x][col] ++;\\n                   }\\n            \\n            for(int row = 0 ; row < matrix.length ; row++ ){\\n                //this for loop increments the whole column ;\\n                    matrix[row][y] ++ ;\\n                }\\n            }\\n        \\n        int ans = 0 ;\\n        //variable ;\\n        \\n        //for loop for iterating over the incremented matrix ;\\n        \\n        for(int i = 0 ; i < matrix.length ; i++){\\n            for(int j = 0 ; j < matrix[i].length ; j++){\\n                //for checking if the element of the matrix is odd or even ;\\n                int temp = matrix[i][j] ;\\n                if(temp % 2 != 0){\\n                    ans ++ ;\\n                }\\n            }\\n        }\\n        //we return the ans ;\\n        return ans ;",
                "codeTag": "Unknown"
            },
            {
                "id": 2410820,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint oddCells(int m, int n, vector<vector<int>>& indices) {\\n\\n\\t\\t\\tvector<vector<int>>mat(m,vector<int>(n,0));\\n\\t\\t\\tint cnt = 0;    \\n\\n\\t\\t\\tfor(int i=0 ; i<indices.size() ; i++){\\n\\n\\t\\t\\t\\t// Fill up the rows\\n\\t\\t\\t\\tfor(int j=0 ; j<m ; j++){\\n\\t\\t\\t\\t\\tmat[j][indices[i][1]]++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Fill up the columns\\n\\t\\t\\t\\tfor(int k=0 ; k<n ; k++){\\n\\t\\t\\t\\t\\tmat[indices[i][0]][k]++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=0 ; i<m ; i++){\\n\\t\\t\\t\\tfor(int j=0 ; j<n ; j++) \\n\\t\\t\\t\\t\\tif(mat[i][j]%2!=0){\\n\\t\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn cnt;\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint oddCells(int m, int n, vector<vector<int>>& indices) {\\n\\n\\t\\t\\tvector<vector<int>>mat(m,vector<int>(n,0));\\n\\t\\t\\tint cnt = 0;    \\n\\n\\t\\t\\tfor(int i=0 ; i<indices.size() ; i++){\\n\\n\\t\\t\\t\\t// Fill up the rows\\n\\t\\t\\t\\tfor(int j=0 ; j<m ; j++){\\n\\t\\t\\t\\t\\tmat[j][indices[i][1]]++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2353247,
                "title": "java-simple-solution-brute-force-optimal",
                "content": "**************Brute Force************** \\n\\n```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int row=indices.length;\\n        int col=indices[0].length;\\n        int mat[][]=new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                mat[i][j]=0;\\n            }\\n        }\\n        \\n        for(int i=0;i<row;i++){\\n            int row_inc=indices[i][0];\\n            int col_inc=indices[i][1];\\n            for(int c=0;c<n;c++){\\n                mat[row_inc][c]++;\\n            }\\n            for(int r=0;r<m;r++){\\n                mat[r][col_inc]++;\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]%2!=0)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n***********Optimal **********\\n\\n```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int row[]=new int[m];\\n        int col[]=new int[n];\\n        \\n        int len=indices.length;\\n        \\n        for(int i=0;i<len;i++){\\n            row[indices[i][0]]++;\\n            col[indices[i][1]]++;\\n        }\\n        \\n        int res[][]=new int[m][n];\\n        int count =0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                res[i][j]=row[i]+col[j];\\n                if(res[i][j]%2!=0)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int row=indices.length;\\n        int col=indices[0].length;\\n        int mat[][]=new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                mat[i][j]=0;\\n            }\\n        }\\n        \\n        for(int i=0;i<row;i++){\\n            int row_inc=indices[i][0];\\n            int col_inc=indices[i][1];\\n            for(int c=0;c<n;c++){\\n                mat[row_inc][c]++;\\n            }\\n            for(int r=0;r<m;r++){\\n                mat[r][col_inc]++;\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]%2!=0)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int row[]=new int[m];\\n        int col[]=new int[n];\\n        \\n        int len=indices.length;\\n        \\n        for(int i=0;i<len;i++){\\n            row[indices[i][0]]++;\\n            col[indices[i][1]]++;\\n        }\\n        \\n        int res[][]=new int[m][n];\\n        int count =0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                res[i][j]=row[i]+col[j];\\n                if(res[i][j]%2!=0)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322813,
                "title": "simple-java-solution-using-matrix",
                "content": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int matrix[][] = new int[m][n];\\n        for(int arr[]:indices)\\n        {\\n            for(int i=0;i<n;i++)\\n                matrix[arr[0]][i]++;\\n            for(int i=0;i<m;i++)\\n                matrix[i][arr[1]]++;\\n        }\\n        int c=0;\\n        for(int arr[]:matrix)\\n        {\\n            for(int i:arr)\\n                if(i%2!=0)\\n                    c++;\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int matrix[][] = new int[m][n];\\n        for(int arr[]:indices)\\n        {\\n            for(int i=0;i<n;i++)\\n                matrix[arr[0]][i]++;\\n            for(int i=0;i<m;i++)\\n                matrix[i][arr[1]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2283086,
                "title": "python-fastest-and-easy-solution",
                "content": "```\\nclass Solution:\\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\\n        \\n        \\n        matrix=[]\\n        \\n        for i in range(m):\\n            temp_matrix=[]\\n            for j in range(n):\\n                temp_matrix.append(0)\\n            matrix.append(temp_matrix)\\n            \\n        for (i,j) in indices:\\n            \\n            matrix[i]=list(map(lambda x: x+1,matrix[i]))\\n            for k in range(m):\\n                \\n                matrix[k][j]=matrix[k][j] + 1\\n                \\n                \\n        count=0\\n        for i in matrix:\\n            for j in i:\\n                if j&1!=0:\\n                    count+=1\\n                    \\n        return count\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\\n        \\n        \\n        matrix=[]\\n        \\n        for i in range(m):\\n            temp_matrix=[]\\n            for j in range(n):\\n                temp_matrix.append(0)\\n            matrix.append(temp_matrix)\\n            \\n        for (i,j) in indices:\\n            \\n            matrix[i]=list(map(lambda x: x+1,matrix[i]))\\n            for k in range(m):\\n                \\n                matrix[k][j]=matrix[k][j] + 1\\n                \\n                \\n        count=0\\n        for i in matrix:\\n            for j in i:\\n                if j&1!=0:\\n                    count+=1\\n                    \\n        return count\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133121,
                "title": "c-5-liner-o-n-m-space-easy-solution-super-short",
                "content": "```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        int *row = new int[n]{0},*col = new int[m]{0},ans = 0;\\n        for(auto const &x:indices) row[x[0]]++,col[x[1]]++;\\n        for(int i = 0;i<n;i++)            \\n            for(int j = 0;j<m;j++) if((row[i] + col[j])%2) ans++;\\n        return ans;\\n    }\\n};\\n```\\n## UPVOTE IF YOU LIKE",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        int *row = new int[n]{0},*col = new int[m]{0},ans = 0;\\n        for(auto const &x:indices) row[x[0]]++,col[x[1]]++;\\n        for(int i = 0;i<n;i++)            \\n            for(int j = 0;j<m;j++) if((row[i] + col[j])%2) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016445,
                "title": "simple-java-solution-with-detailed-explanation-easy-to-understand-faster-than-78",
                "content": "\\n\\n```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int[][] result = new int[m][n];\\n        int row=0,column=0,temp=0;\\n        // result[0].length = No of Column\\n        // result.length = No of Rows\\n        \\n        //  Since we don\\'t know how many rows so we are iterating the number of rows in indices.\\n        for(int i=0;i<indices.length;i++){\\n        // We Know that first column is to increment all cells on row by one. So we took column 0th of every row which will increment every row of result matrix.\\n            row=indices[i][0];\\n            for(int j=0;j<result[0].length;j++)\\n                result[row][j]=result[row][j]+1;\\n             // Similarly, We Know that second column is to increment all cells on column by one. So we took row 0th of every column which will increment every column of result matrix.\\n            column=indices[i][1];\\n             for(int j=0;j<result.length;j++)\\n                result[j][column]=result[j][column]+1;\\n        }\\n       //  Finding the count of odd number in resultant Matrix.\\n        for(int i=0;i<result[0].length;i++){\\n            for(int j=0;j<result.length;j++){\\n                if(result[j][i]%2!=0)\\n                    temp++;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int[][] result = new int[m][n];\\n        int row=0,column=0,temp=0;\\n        // result[0].length = No of Column\\n        // result.length = No of Rows\\n        \\n        //  Since we don\\'t know how many rows so we are iterating the number of rows in indices.\\n        for(int i=0;i<indices.length;i++){\\n        // We Know that first column is to increment all cells on row by one. So we took column 0th of every row which will increment every row of result matrix.\\n            row=indices[i][0];\\n            for(int j=0;j<result[0].length;j++)\\n                result[row][j]=result[row][j]+1;\\n             // Similarly, We Know that second column is to increment all cells on column by one. So we took row 0th of every column which will increment every column of result matrix.\\n            column=indices[i][1];\\n             for(int j=0;j<result.length;j++)\\n                result[j][column]=result[j][column]+1;\\n        }\\n       //  Finding the count of odd number in resultant Matrix.\\n        for(int i=0;i<result[0].length;i++){\\n            for(int j=0;j<result.length;j++){\\n                if(result[j][i]%2!=0)\\n                    temp++;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772558,
                "title": "simple-java-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        // Step 1: Accumulate row and column increments first\\n        int[] rows = new int[m];\\n        int[] cols = new int[n];\\n        for (int i = 0; i < indices.length; i++) {\\n            rows[indices[i][0]] += 1;\\n            cols[indices[i][1]] += 1;\\n        }\\n\\n        /**\\n        * Step 2: Calculate the value of cell in m x n matrix\\n        * and increase the result counter if the value is an odd number\\n        */\\n        int result = 0;\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if ((rows[r] + cols[c]) % 2 != 0) {\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        // Step 1: Accumulate row and column increments first\\n        int[] rows = new int[m];\\n        int[] cols = new int[n];\\n        for (int i = 0; i < indices.length; i++) {\\n            rows[indices[i][0]] += 1;\\n            cols[indices[i][1]] += 1;\\n        }\\n\\n        /**\\n        * Step 2: Calculate the value of cell in m x n matrix\\n        * and increase the result counter if the value is an odd number\\n        */\\n        int result = 0;\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if ((rows[r] + cols[c]) % 2 != 0) {\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758956,
                "title": "simple-java-solution",
                "content": "\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\tpublic int oddCells(int n, int m, int[][] indices) {\\n\\t\\tint[][] matrix = new int[m][n];\\n\\t\\tint counter = 0;\\n\\t\\tfor(int x=0;x<indices.length;x++){\\n\\t\\t\\tint row=indices[x][0];\\n\\t\\t\\tint column=indices[x][1];//row increment by iterating columns\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t\\tmatrix[row][i]+=1;\\n\\t\\t\\t\\n\\t\\t\\t//column increment by iterating rows\\n\\t\\t\\tfor(int i=0;i<m;i++)\\n\\t\\t\\t\\tmatrix[i][column]+=1;\\n\\n\\t\\t}\\n\\n        for(int x=0; x<m;x++){\\n            for(int y=0; y<n;y++){\\n                if(matrix[x][y]%2==1)\\n                    counter++;\\n            }\\n        }\\n\\t\\treturn counter;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\tpublic int oddCells(int n, int m, int[][] indices) {\\n\\t\\tint[][] matrix = new int[m][n];\\n\\t\\tint counter = 0;\\n\\t\\tfor(int x=0;x<indices.length;x++){\\n\\t\\t\\tint row=indices[x][0];\\n\\t\\t\\tint column=indices[x][1];//row increment by iterating columns\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t\\tmatrix[row][i]+=1;\\n\\t\\t\\t\\n\\t\\t\\t//column increment by iterating rows\\n\\t\\t\\tfor(int i=0;i<m;i++)\\n\\t\\t\\t\\tmatrix[i][column]+=1;\\n\\n\\t\\t}\\n\\n        for(int x=0; x<m;x++){\\n            for(int y=0; y<n;y++){\\n                if(matrix[x][y]%2==1)\\n                    counter++;\\n            }\\n        }\\n\\t\\treturn counter;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1723209,
                "title": "beginner-friendly-java-solution",
                "content": "```\\nclass Solution {\\n    int[][] mat;\\n    public int oddCells(int m, int n, int[][] indices) {\\n        mat = new int[m][n];\\n        for(int i=0; i<indices.length; i++){\\n            incRow(indices[i][0]);\\n            incCol(indices[i][1]);\\n        }\\n        int count = 0;\\n        for(int i=0; i<mat.length; i++){\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j] % 2 != 0)  \\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private void incCol(int col){\\n        for(int i=0; i<mat.length; i++){\\n            mat[i][col]++;\\n        }\\n    }\\n    \\n    private void incRow(int row){\\n        for(int i=0; i<mat[0].length; i++){\\n            mat[row][i]++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] mat;\\n    public int oddCells(int m, int n, int[][] indices) {\\n        mat = new int[m][n];\\n        for(int i=0; i<indices.length; i++){\\n            incRow(indices[i][0]);\\n            incCol(indices[i][1]);\\n        }\\n        int count = 0;\\n        for(int i=0; i<mat.length; i++){\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j] % 2 != 0)  \\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private void incCol(int col){\\n        for(int i=0; i<mat.length; i++){\\n            mat[i][col]++;\\n        }\\n    }\\n    \\n    private void incRow(int row){\\n        for(int i=0; i<mat[0].length; i++){\\n            mat[row][i]++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668042,
                "title": "go-100-time-and-74-space-tc-o-indices-length-n-m-sc-o-n-m",
                "content": "```\\nfunc oddCells(m int, n int, indices [][]int) int {\\n\\trSums, cSums := make([]int, m), make([]int, n)\\n\\tfor i := 0; i < len(indices); i++ {\\n\\t\\trSums[indices[i][0]]++\\n\\t\\tcSums[indices[i][1]]++\\n\\t}\\n\\n\\tre, ro := countEvenAndOdd(rSums)\\n\\tce, co := countEvenAndOdd(cSums)\\n\\n\\treturn re*co + ce*ro\\n}\\n\\nfunc countEvenAndOdd(nums []int) (int, int) {\\n\\teven, odd := 0, 0\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif nums[i]&1 == 1 {\\n\\t\\t\\todd++\\n\\t\\t} else {\\n\\t\\t\\teven++\\n\\t\\t}\\n\\t}\\n\\n\\treturn even, odd\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc oddCells(m int, n int, indices [][]int) int {\\n\\trSums, cSums := make([]int, m), make([]int, n)\\n\\tfor i := 0; i < len(indices); i++ {\\n\\t\\trSums[indices[i][0]]++\\n\\t\\tcSums[indices[i][1]]++\\n\\t}\\n\\n\\tre, ro := countEvenAndOdd(rSums)\\n\\tce, co := countEvenAndOdd(cSums)\\n\\n\\treturn re*co + ce*ro\\n}\\n\\nfunc countEvenAndOdd(nums []int) (int, int) {\\n\\teven, odd := 0, 0\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif nums[i]&1 == 1 {\\n\\t\\t\\todd++\\n\\t\\t} else {\\n\\t\\t\\teven++\\n\\t\\t}\\n\\t}\\n\\n\\treturn even, odd\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1668011,
                "title": "go-100-time-and-74-space-tc-o-indices-length-n-m-sc-o-n-m",
                "content": "```\\nfunc oddCells(m int, n int, indices [][]int) int {\\n\\trSums, cSums := make([]int, m), make([]int, n)\\n\\tfor i := 0; i < len(indices); i++ {\\n\\t\\trSums[indices[i][0]]++\\n\\t\\tcSums[indices[i][1]]++\\n\\t}\\n\\n\\tresult := 0\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tresult += (rSums[i] + cSums[j]) & 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc oddCells(m int, n int, indices [][]int) int {\\n\\trSums, cSums := make([]int, m), make([]int, n)\\n\\tfor i := 0; i < len(indices); i++ {\\n\\t\\trSums[indices[i][0]]++\\n\\t\\tcSums[indices[i][1]]++\\n\\t}\\n\\n\\tresult := 0\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tresult += (rSums[i] + cSums[j]) & 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1496105,
                "title": "c-sol-in-just-10-lines-easiest",
                "content": "class Solution{\\npublic:  int oddCells(int m, int n, vector<vector<int>>& indices) {\\n       vector<vector<int>>matrix(m, vector<int>(n, 0)); \\n        int odd =0;\\n            for(int j=0; j<indices.size(); j++)\\n            {\\n                int row= indices[j][0], col= indices[j][1];\\n                for(int k=0; k<m; k++) ++matrix[k][col] % 2!=0 ? odd++ : odd--;\\n                for(int l=0; l<n; l++) ++matrix[row][l] % 2!=0 ? odd++ : odd--;\\n            }\\n        return odd; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution{\\npublic:  int oddCells(int m, int n, vector<vector<int>>& indices) {\\n       vector<vector<int>>matrix(m, vector<int>(n, 0)); \\n        int odd =0;\\n            for(int j=0; j<indices.size(); j++)\\n            {\\n                int row= indices[j][0], col= indices[j][1];\\n                for(int k=0; k<m; k++) ++matrix[k][col] % 2!=0 ? odd++ : odd--;\\n                for(int l=0; l<n; l++) ++matrix[row][l] % 2!=0 ? odd++ : odd--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1293179,
                "title": "python-efficient-solution-95-faster-100-less-memory-usage",
                "content": "```\\nclass Solution(object):\\n    def oddCells(self, m, n, indices):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type indices: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        r = {}\\n        c = {}\\n        col = 0\\n        for i in indices:\\n            if i[0] in r:\\n                r[i[0]] += 1\\n            else:\\n                r[i[0]] = 1\\n            if i[1] in c:\\n                c[i[1]] += 1\\n            else:\\n                c[i[1]] = 1\\n                col += 1\\n        i = 0\\n        for x in r.values():\\n            if x%2 != 0:\\n                i += 1\\n        ans = 0\\n      \\n        for j in c.values():\\n            if j%2 == 0:\\n                ans += i\\n            else:\\n                ans += m-i\\n        ans += (n-col)*i\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def oddCells(self, m, n, indices):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type indices: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        r = {}\\n        c = {}\\n        col = 0\\n        for i in indices:\\n            if i[0] in r:\\n                r[i[0]] += 1\\n            else:\\n                r[i[0]] = 1\\n            if i[1] in c:\\n                c[i[1]] += 1\\n            else:\\n                c[i[1]] = 1\\n                col += 1\\n        i = 0\\n        for x in r.values():\\n            if x%2 != 0:\\n                i += 1\\n        ans = 0\\n      \\n        for j in c.values():\\n            if j%2 == 0:\\n                ans += i\\n            else:\\n                ans += m-i\\n        ans += (n-col)*i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248922,
                "title": "c-100-faster-o-number-of-indices-with-explaination-without-matrix",
                "content": "**Take the random test case 1: m = 2, n = 3, indices = [[0,1],[1,2]]\\nCoordinates seperately:\\nx -> [0, 1], \\ny -> [1, 2]  ....................[Order doesn\\'t matter]**\\n# Dive into the concept:\\n**1. First, fill all the rows (x) those appears odd times (as even numbers will fill the rows (or columns) with even numbers)**\\n```\\nLet\\'s first process all the rows (x-coordinate of the indices) :\\nThen following matrix will be generated:\\n           col:\\n\\t\\t   0 1 2\\nrow:  0   -------         [----- means there is an odd number. as 0 and 1 appears once,\\n\\t  1   -------         [ they will fill the whole row 0th and 1st row with 1] \\n\\t  \\n#Note that, if any x-cordinate appears even number of times, then \\nit will not be considered, as it will fill the row with even numbers :(\\n\\nAlso maintain two variables, for counting of rows which are\\nrow1 -> filled (having odd numbers)\\nrow0 -> not filled (or for simplicity, having even numbers)\\nhence, inertially, rows0 = 0, rows1 = 2 \\n[as 0, 1 both the rows appears odd number of times (here once)]\\n```\\n**Till now we have 6 odd numbers i.e. `ans = 6, row1 = 2, row0 = 0`**\\n\\n**2. Process the y-coordinate i.e. columns**\\n```\\nFor that, we can use a data structure for keeping track of distinct elements\\nand at last we only require the elements which appears odd number of times,\\nas we know, any, either x coordinate or y coordinate, if it appears\\neven number of times then it will fill its corresponding rows and columns\\nwith even numbers, which we don\\'t require.\\n[here I have used map]\\n________________________Matrix___________________________:\\n col:\\n\\t\\t   0 1 2       Y-coordinates = [1, 2] make a straight line in the column\\nrow:  0   ---|-|-      [ --|-- means there is a clash i.e. there is an even number]\\n\\t  1   ---|-|-         \\n\\t  \\nHence, we can observe, that\\n\\t  if the particular row will be empty (not filled / even filled) \\nthen the vertical line will increse the answer for \\nthat row (2 will become 3) and generate odd numbers\\n\\t  else if the particular row will be filled (with odds) then \\nvertical line will make clash with it, increse it and result in even number :(\\n```\\nNote that, we don\\'t want clash, as it will generate even numbers\\n# Conclusion\\n***For every element from Y-coordinates array, (containing only odd times appearing elements) vertical straight line will clash `row1` times (there was odd and after clash, it will become even) hence `ans -= row1`\\nSimilarly, vertical straight line will not clash with empty (evenly filled rows) i.e. it will create `row0`  odd numbers for us hence `ans += row0`***\\n\\n***Also, we forgot to observe that, if we draw horizontal and vertical line from point (x, y) then the point (x, y) itself will be even,***\\n***But, as we are not considering the clashes itself, it will not consider this case***\\n\\n# Code:\\n```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& arr) {\\n\\t\\tmap<int, bool>cols, rows;\\n\\t\\tfor(auto i:arr)\\n\\t\\t{\\n\\t\\t\\tif(rows[i[0]]) rows.erase(i[0]);  //\\n\\t\\t\\telse rows[i[0]] = 1;             //\\n\\t\\t\\tcols[i[1]] = !cols[i[1]];       //  Even / odd tracking\\n\\t\\t}\\n        int rows1 = rows.size();       // Rows which are being filled (with odds)\\n\\t\\tint ans = rows1 * n;           //Initial number of odds = rows1 * total cols\\n\\t\\tint rows0 = m - rows1;         //EvRows which are not filled\\n\\t\\tfor(auto i:cols) \\n\\t\\t\\tif(i.second)   //For each Y coordinates having 1 (odd freq)\\n\\t\\t\\t{              // Include empty rows, remove clashes\\n\\t\\t\\t\\tans += rows0 - rows1;\\n\\t\\t\\t}    \\n\\t\\treturn ans;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nLet\\'s first process all the rows (x-coordinate of the indices) :\\nThen following matrix will be generated:\\n           col:\\n\\t\\t   0 1 2\\nrow:  0   -------         [----- means there is an odd number. as 0 and 1 appears once,\\n\\t  1   -------         [ they will fill the whole row 0th and 1st row with 1] \\n\\t  \\n#Note that, if any x-cordinate appears even number of times, then \\nit will not be considered, as it will fill the row with even numbers :(\\n\\nAlso maintain two variables, for counting of rows which are\\nrow1 -> filled (having odd numbers)\\nrow0 -> not filled (or for simplicity, having even numbers)\\nhence, inertially, rows0 = 0, rows1 = 2 \\n[as 0, 1 both the rows appears odd number of times (here once)]\\n```\n```\\nFor that, we can use a data structure for keeping track of distinct elements\\nand at last we only require the elements which appears odd number of times,\\nas we know, any, either x coordinate or y coordinate, if it appears\\neven number of times then it will fill its corresponding rows and columns\\nwith even numbers, which we don\\'t require.\\n[here I have used map]\\n________________________Matrix___________________________:\\n col:\\n\\t\\t   0 1 2       Y-coordinates = [1, 2] make a straight line in the column\\nrow:  0   ---|-|-      [ --|-- means there is a clash i.e. there is an even number]\\n\\t  1   ---|-|-         \\n\\t  \\nHence, we can observe, that\\n\\t  if the particular row will be empty (not filled / even filled) \\nthen the vertical line will increse the answer for \\nthat row (2 will become 3) and generate odd numbers\\n\\t  else if the particular row will be filled (with odds) then \\nvertical line will make clash with it, increse it and result in even number :(\\n```\n```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& arr) {\\n\\t\\tmap<int, bool>cols, rows;\\n\\t\\tfor(auto i:arr)\\n\\t\\t{\\n\\t\\t\\tif(rows[i[0]]) rows.erase(i[0]);  //\\n\\t\\t\\telse rows[i[0]] = 1;             //\\n\\t\\t\\tcols[i[1]] = !cols[i[1]];       //  Even / odd tracking\\n\\t\\t}\\n        int rows1 = rows.size();       // Rows which are being filled (with odds)\\n\\t\\tint ans = rows1 * n;           //Initial number of odds = rows1 * total cols\\n\\t\\tint rows0 = m - rows1;         //EvRows which are not filled\\n\\t\\tfor(auto i:cols) \\n\\t\\t\\tif(i.second)   //For each Y coordinates having 1 (odd freq)\\n\\t\\t\\t{              // Include empty rows, remove clashes\\n\\t\\t\\t\\tans += rows0 - rows1;\\n\\t\\t\\t}    \\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243131,
                "title": "easy-c-solution-100-faster",
                "content": "```\\n int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        vector<vector<int>> arr(m,vector<int> (n,0));\\n        for(int i=0;i<indices.size();i++)\\n        {\\n            int j=0;\\n            while(j<n)\\n            {\\n                arr[indices[i][0]][j]++;\\n                j++;\\n            }\\n            int k=0;\\n            while(k<m)\\n            {\\n                arr[k][indices[i][1]]++;\\n                k++;\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(arr[i][j]%2!=0)\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        vector<vector<int>> arr(m,vector<int> (n,0));\\n        for(int i=0;i<indices.size();i++)\\n        {\\n            int j=0;\\n            while(j<n)\\n            {\\n                arr[indices[i][0]][j]++;\\n                j++;\\n            }\\n            int k=0;\\n            while(k<m)\\n            {\\n                arr[k][indices[i][1]]++;\\n                k++;\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(arr[i][j]%2!=0)\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1242219,
                "title": "100-faster-o-m-n-indices-length",
                "content": "```\\npublic int oddCells(int m, int n, int[][] indices) {\\n        boolean[] row = new boolean[m];\\n        boolean[] col = new boolean[n];\\n        \\n        for(int i=0;i<indices.length;i++){\\n            int a = indices[i][0];\\n            int b = indices[i][1];\\n            row[a] = !row[a];\\n            col[b] = !col[b];\\n            \\n        }\\n        int rowodd=0;\\n        int colodd=0;\\n        int roweven=0;\\n        int coleven=0;\\n        for(int i=0;i<m;i++){\\n            if(row[i]==true)\\n                rowodd++;\\n            else\\n                roweven++;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(col[i]==true)\\n                colodd++;\\n            else\\n                coleven++;\\n        }\\n        return rowodd*coleven + colodd*roweven;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int oddCells(int m, int n, int[][] indices) {\\n        boolean[] row = new boolean[m];\\n        boolean[] col = new boolean[n];\\n        \\n        for(int i=0;i<indices.length;i++){\\n            int a = indices[i][0];\\n            int b = indices[i][1];\\n            row[a] = !row[a];\\n            col[b] = !col[b];\\n            \\n        }\\n        int rowodd=0;\\n        int colodd=0;\\n        int roweven=0;\\n        int coleven=0;\\n        for(int i=0;i<m;i++){\\n            if(row[i]==true)\\n                rowodd++;\\n            else\\n                roweven++;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(col[i]==true)\\n                colodd++;\\n            else\\n                coleven++;\\n        }\\n        return rowodd*coleven + colodd*roweven;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1241844,
                "title": "98-51-python",
                "content": "```\\nclass Solution:\\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\\n        \\n        \\n        row=[0]*m\\n        col = [0]*n\\n        \\n        \\n        for x,y in indices:\\n            \\n            row[x]+=1\\n            col[y]+=1\\n            \\n        ans=0\\n        for i in range(m):\\n            for j in range(n):\\n                \\n                if (row[i]+col[j])%2:\\n                    ans+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\\n        \\n        \\n        row=[0]*m\\n        col = [0]*n\\n        \\n        \\n        for x,y in indices:\\n            \\n            row[x]+=1\\n            col[y]+=1\\n            \\n        ans=0\\n        for i in range(m):\\n            for j in range(n):\\n                \\n                if (row[i]+col[j])%2:\\n                    ans+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152352,
                "title": "c-most-efficient-solution-faster-than-82-68-time-o-m-n-indices-length-and-space-o-m-n",
                "content": "Runtime: 4 ms, faster than 82.68% of C++ online submissions for Cells with Odd Values in a Matrix.\\nMemory Usage: 7.6 MB, less than 89.07% of C++ online submissions for Cells with Odd Values in a Matrix.\\n\\nSolution Description: \\n   1) Create row array(m length) and col array(n length)\\n   2) Increment row value, col value for each entry in indices[] vector\\n   3) Final Value at any cell of the matrix will be sum of row value and col value\\n         i.e , matrix[i][j] = row[i]+col[j];\\n   4) Now travese the row array and column array and check value of the cell by using the above formula\\n               if odd the increment the result counter\\n\\n\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        \\n        int rows[50]={0};\\n        int cols[50]={0};\\n        int res=0;\\n        \\n        for(auto idx:indices) {\\n            rows[idx[0]]+=1;\\n            cols[idx[1]]+=1;\\n        }\\n        for(auto i=0;i<m;i++){\\n            for(auto j=0;j<n;j++){\\n                if(((rows[i]+cols[j])&1))                \\n                    res+=1;\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        \\n        int rows[50]={0}",
                "codeTag": "Java"
            },
            {
                "id": 1104474,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<vector<int>> ans(n,vector<int>(m,0));\\n        vector<int> row(51,0);\\n        vector<int> col(51,0);\\n        for(int i=0; i<indices.size(); i++)\\n        {\\n            row[indices[i][0]]++;\\n            col[indices[i][1]]++;\\n        }\\n        int cnt=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                ans[i][j]+=row[i]+col[j];\\n                if(ans[i][j]&1) cnt++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<vector<int>> ans(n,vector<int>(m,0));\\n        vector<int> row(51,0);\\n        vector<int> col(51,0);\\n        for(int i=0; i<indices.size(); i++)\\n        {\\n            row[indices[i][0]]++;\\n            col[indices[i][1]]++;\\n        }\\n        int cnt=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                ans[i][j]+=row[i]+col[j];\\n                if(ans[i][j]&1) cnt++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053987,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        \\n        int[][] matrix = new int[n][m];\\n        \\n        for(int[] indexArray:indices)\\n        {\\n            int ri = indexArray[0];\\n            int ci = indexArray[1];\\n            \\n            // increment the whole ri element\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[ri][i]++;\\n            }\\n            // incrementing the whole ci element\\n            for(int i=0;i<n;i++)\\n            {\\n                matrix[i][ci]++;\\n            }\\n        }\\n        \\n        \\n        int oddCount = 0;\\n        \\n        for(int[] arr:matrix)\\n        {\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                if(arr[i]%2!=0)\\n                    oddCount++;\\n            }\\n        }\\n        return oddCount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        \\n        int[][] matrix = new int[n][m];\\n        \\n        for(int[] indexArray:indices)\\n        {\\n            int ri = indexArray[0];\\n            int ci = indexArray[1];\\n            \\n            // increment the whole ri element\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[ri][i]++;\\n            }\\n            // incrementing the whole ci element\\n            for(int i=0;i<n;i++)\\n            {\\n                matrix[i][ci]++;\\n            }\\n        }\\n        \\n        \\n        int oddCount = 0;\\n        \\n        for(int[] arr:matrix)\\n        {\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                if(arr[i]%2!=0)\\n                    oddCount++;\\n            }\\n        }\\n        return oddCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983129,
                "title": "python-solution-98-39-faster",
                "content": "```python\\nclass Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        rows = [0] * n\\n        cols = [0] * m\\n        \\n        for [r, c] in indices:\\n            rows[r] += 1\\n            cols[c] += 1\\n        \\n        count = 0\\n        for r in rows:\\n            for c in cols:\\n                if (r + c) % 2:\\n                    count += 1\\n\\n        return count\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        rows = [0] * n\\n        cols = [0] * m\\n        \\n        for [r, c] in indices:\\n            rows[r] += 1\\n            cols[c] += 1\\n        \\n        count = 0\\n        for r in rows:\\n            for c in cols:\\n                if (r + c) % 2:\\n                    count += 1\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920994,
                "title": "java-o-m-n-time-100-faster",
                "content": "```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        \\n        int [] row = new int[n];\\n        int [] col = new int[m];\\n        for(int[] indice : indices){\\n            row[indice[0]]++;\\n            col[indice[1]]++;\\n        }\\n        \\n        int rowEO[] = findOddAndEven(row);\\n        int colEO[] = findOddAndEven(col);\\n        return rowEO[0]*colEO[1] + rowEO[1]*colEO[0];\\n        \\n    }\\n    \\n    private int[] findOddAndEven(int[] input){\\n        int output[] = new int[2];\\n        for(int i : input) output[(i%2 == 0 ? 1 : 0)]++;\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        \\n        int [] row = new int[n];\\n        int [] col = new int[m];\\n        for(int[] indice : indices){\\n            row[indice[0]]++;\\n            col[indice[1]]++;\\n        }\\n        \\n        int rowEO[] = findOddAndEven(row);\\n        int colEO[] = findOddAndEven(col);\\n        return rowEO[0]*colEO[1] + rowEO[1]*colEO[0];\\n        \\n    }\\n    \\n    private int[] findOddAndEven(int[] input){\\n        int output[] = new int[2];\\n        for(int i : input) output[(i%2 == 0 ? 1 : 0)]++;\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903240,
                "title": "python-with-o-indices-length",
                "content": "Only need to iterate once for all indices in the list. row_m and col_m are lists meaning whether an index is counted for odd times or even times.\\n```\\ndef oddCells(n: int, m: int, indices: List[List[int]]) -> int:\\n\\trow_m = []\\n\\tcol_m = []\\n\\ttotal = 0\\n\\tfor i in indices:\\n\\t\\tif i[0] in row_m:\\n\\t\\t\\trow_m.remove(i[0])\\n\\t\\t\\ttotal += len(col_m)\\n\\t\\t\\ttotal -= (m - len(col_m))\\n\\t\\telif i[0] not in row_m:\\n\\t\\t\\trow_m.append(i[0])\\n\\t\\t\\ttotal += (m - 2 * len(col_m))\\n\\t\\tif i[1] in col_m:\\n\\t\\t\\tcol_m.remove(i[1])\\n\\t\\t\\ttotal += len(row_m)\\n\\t\\t\\ttotal -= (n - len(row_m))\\n\\t\\telif i[1] not in col_m:\\n\\t\\t\\tcol_m.append(i[1])\\n\\t\\t\\ttotal += (n - 2 * len(row_m))\\n\\treturn total\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef oddCells(n: int, m: int, indices: List[List[int]]) -> int:\\n\\trow_m = []\\n\\tcol_m = []\\n\\ttotal = 0\\n\\tfor i in indices:\\n\\t\\tif i[0] in row_m:\\n\\t\\t\\trow_m.remove(i[0])\\n\\t\\t\\ttotal += len(col_m)\\n\\t\\t\\ttotal -= (m - len(col_m))\\n\\t\\telif i[0] not in row_m:\\n\\t\\t\\trow_m.append(i[0])\\n\\t\\t\\ttotal += (m - 2 * len(col_m))\\n\\t\\tif i[1] in col_m:\\n\\t\\t\\tcol_m.remove(i[1])\\n\\t\\t\\ttotal += len(row_m)\\n\\t\\t\\ttotal -= (n - len(row_m))\\n\\t\\telif i[1] not in col_m:\\n\\t\\t\\tcol_m.append(i[1])\\n\\t\\t\\ttotal += (n - 2 * len(row_m))\\n\\treturn total\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 887204,
                "title": "java-0ms-beat-100-linear-time-complexity-and-o-m-n-space-with-explanation",
                "content": "```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        int ans = 0;\\n        int[] rows = new int[n];\\n        int[] cols = new int[m];\\n        for (int k = 0; k < indices.length; k++) {\\n            cols[indices[k][1]]++;\\n            rows[indices[k][0]]++;\\n        }\\n        \\n        int oddRows = 0;\\n        for (int i = 0; i  < n; i++) {\\n            if (rows[i] % 2 != 0) {\\n                oddRows++;\\n                ans += m; // add all items of the odd row first, if column is odd, deduct later\\n            }\\n        }\\n        \\n        for (int j = 0; j < m; j++) {\\n            if (cols[j] % 2 != 0) {\\n                ans -= oddRows; // if odd row and odd column, should be even, so need to deduct\\n                ans += n - oddRows; // for even row and odd column, should be added\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        int ans = 0;\\n        int[] rows = new int[n];\\n        int[] cols = new int[m];\\n        for (int k = 0; k < indices.length; k++) {\\n            cols[indices[k][1]]++;\\n            rows[indices[k][0]]++;\\n        }\\n        \\n        int oddRows = 0;\\n        for (int i = 0; i  < n; i++) {\\n            if (rows[i] % 2 != 0) {\\n                oddRows++;\\n                ans += m; // add all items of the odd row first, if column is odd, deduct later\\n            }\\n        }\\n        \\n        for (int j = 0; j < m; j++) {\\n            if (cols[j] % 2 != 0) {\\n                ans -= oddRows; // if odd row and odd column, should be even, so need to deduct\\n                ans += n - oddRows; // for even row and odd column, should be added\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863776,
                "title": "java-simple-solution-1ms",
                "content": "**upvote** if you like my solution\\n\\n```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices){\\n        int arr[][] = new int[n][m];\\n        \\n        for(int i = 0; i < indices.length; i++){\\n            increment(arr, indices[i][0], indices[i][1], n, m);\\n        }\\n        \\n        int odd = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(arr[i][j] % 2 != 0)\\n                    odd++;\\n            }\\n        }\\n        return odd;\\n    }\\n    \\n    public void increment(int arr[][], int i, int j, int n, int m){\\n        for(int a = 0; a < n; a++)\\n            arr[a][j]++;\\n        \\n        for(int a = 0; a < m; a++)\\n            arr[i][a]++;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices){\\n        int arr[][] = new int[n][m];\\n        \\n        for(int i = 0; i < indices.length; i++){\\n            increment(arr, indices[i][0], indices[i][1], n, m);\\n        }\\n        \\n        int odd = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(arr[i][j] % 2 != 0)\\n                    odd++;\\n            }\\n        }\\n        return odd;\\n    }\\n    \\n    public void increment(int arr[][], int i, int j, int n, int m){\\n        for(int a = 0; a < n; a++)\\n            arr[a][j]++;\\n        \\n        for(int a = 0; a < m; a++)\\n            arr[i][a]++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803061,
                "title": "java-o-n",
                "content": "```\\npublic int oddCells(int n, int m, int[][] indices) {\\n        Map<Integer, Integer> rows = new HashMap<>();\\n        Map<Integer, Integer> columns = new HashMap<>();\\n        \\n        int row = 0;\\n        int column = 0;\\n        \\n        for(int i = 0; i < indices.length; i++){\\n            if (rows.containsKey(indices[i][0])){\\n                rows.remove(indices[i][0]);\\n            } else{\\n                rows.put(indices[i][0], 1);\\n            }\\n            \\n            if (columns.containsKey(indices[i][1])){\\n                columns.remove(indices[i][1]);\\n            } else {\\n                columns.put(indices[i][1], 1);\\n            }\\n            }\\n        \\n        row = rows.size();\\n        column = columns.size();\\n        return (row*m + column*n) - (2 * row * column);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int oddCells(int n, int m, int[][] indices) {\\n        Map<Integer, Integer> rows = new HashMap<>();\\n        Map<Integer, Integer> columns = new HashMap<>();\\n        \\n        int row = 0;\\n        int column = 0;\\n        \\n        for(int i = 0; i < indices.length; i++){\\n            if (rows.containsKey(indices[i][0])){\\n                rows.remove(indices[i][0]);\\n            } else{\\n                rows.put(indices[i][0], 1);\\n            }\\n            \\n            if (columns.containsKey(indices[i][1])){\\n                columns.remove(indices[i][1]);\\n            } else {\\n                columns.put(indices[i][1], 1);\\n            }\\n            }\\n        \\n        row = rows.size();\\n        column = columns.size();\\n        return (row*m + column*n) - (2 * row * column);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 789238,
                "title": "o-n-faster-than-100-c-solution",
                "content": "This solution uses bitwise operations to encode the state of the rows and columns in two 64bit integers then counts the set bits and uses a bit of math to work out the final count. It runs in 0ms faster than 100% of C solutions and uses only 5.5mb less than 98.81% of solutions.\\n```C\\n#include <inttypes.h>\\nint oddCells(int n, int m, int** indices, int indicesSize, int* indicesColSize){\\n    unsigned long long row_mask=0,col_mask=0;\\n    for(int i=0;i<indicesSize;++i)\\n    {\\n        row_mask ^= 1ULL<<(indices[i][0]);\\n        col_mask ^= 1ULL<<(indices[i][1]);\\n    }\\n    int rc = __builtin_popcountll(row_mask);\\n    int cc = __builtin_popcountll(col_mask);\\n    return n*cc+m*rc-2*rc*cc;\\n}\\n```",
                "solutionTags": [],
                "code": "```C\\n#include <inttypes.h>\\nint oddCells(int n, int m, int** indices, int indicesSize, int* indicesColSize){\\n    unsigned long long row_mask=0,col_mask=0;\\n    for(int i=0;i<indicesSize;++i)\\n    {\\n        row_mask ^= 1ULL<<(indices[i][0]);\\n        col_mask ^= 1ULL<<(indices[i][1]);\\n    }\\n    int rc = __builtin_popcountll(row_mask);\\n    int cc = __builtin_popcountll(col_mask);\\n    return n*cc+m*rc-2*rc*cc;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 744732,
                "title": "easy-js-solution-w-explanation",
                "content": "https://youtu.be/kCjNTX5hXjI\\n\\n```\\nSolution 1\\nconst oddCells = (n, m, indices) => {\\n\\tlet count = 0;\\n\\t// make matrix; fill with 0\\n\\tlet matrix = Array.from({ length: n }, () =>\\n\\t\\tArray.from({ length: m }, () => 0)\\n\\t);\\n\\n\\tfor (const [r, c] of indices) {\\n\\t\\t// update row\\n\\t\\tmatrix[r].forEach((cv, idx, array) => array[idx]++)\\n\\t\\t// update col\\n\\t\\tmatrix.forEach(row => row[c]++)\\n\\t}\\n\\t\\n\\t// counts odds\\n\\tmatrix.forEach(arr => {\\n\\t\\tarr.forEach(cv => cv % 2 !== 0 ? count++ : null)\\n\\t})\\n\\n\\treturn count;\\n};\\n\\nSolution 2\\nconst oddCells = (n, m, indices) => {\\n\\tlet count = 0;\\n\\tlet matrix = Array.from({ length: n }, () =>\\n\\t\\tArray.from({ length: m }, () => 0)\\n\\t);\\n\\n\\tfor (const [r, c] of indices) {\\n\\t\\t// update col\\n\\t\\tfor (let i = 0; i < n; i++) matrix[i][c]++;\\n\\t\\t//update row\\n\\t\\tfor (let i = 0; i < m; i++) matrix[r][i]++;\\n\\t}\\n\\n\\t// count odds\\n\\tmatrix.forEach(arr => {\\n\\t\\tarr.forEach(cv => (cv % 2 !== 0 ? count++ : null));\\n\\t});\\n\\n\\treturn count;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nSolution 1\\nconst oddCells = (n, m, indices) => {\\n\\tlet count = 0;\\n\\t// make matrix; fill with 0\\n\\tlet matrix = Array.from({ length: n }, () =>\\n\\t\\tArray.from({ length: m }, () => 0)\\n\\t);\\n\\n\\tfor (const [r, c] of indices) {\\n\\t\\t// update row\\n\\t\\tmatrix[r].forEach((cv, idx, array) => array[idx]++)\\n\\t\\t// update col\\n\\t\\tmatrix.forEach(row => row[c]++)\\n\\t}\\n\\t\\n\\t// counts odds\\n\\tmatrix.forEach(arr => {\\n\\t\\tarr.forEach(cv => cv % 2 !== 0 ? count++ : null)\\n\\t})\\n\\n\\treturn count;\\n};\\n\\nSolution 2\\nconst oddCells = (n, m, indices) => {\\n\\tlet count = 0;\\n\\tlet matrix = Array.from({ length: n }, () =>\\n\\t\\tArray.from({ length: m }, () => 0)\\n\\t);\\n\\n\\tfor (const [r, c] of indices) {\\n\\t\\t// update col\\n\\t\\tfor (let i = 0; i < n; i++) matrix[i][c]++;\\n\\t\\t//update row\\n\\t\\tfor (let i = 0; i < m; i++) matrix[r][i]++;\\n\\t}\\n\\n\\t// count odds\\n\\tmatrix.forEach(arr => {\\n\\t\\tarr.forEach(cv => (cv % 2 !== 0 ? count++ : null));\\n\\t});\\n\\n\\treturn count;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 727566,
                "title": "c-beats-98-o-n-m-space",
                "content": "```\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<int> row(n,0),col(m,0);\\n        for(auto x :indices) {\\n            row[x[0]]=!row[x[0]];\\n            col[x[1]]=!col[x[1]];\\n        }\\n        int r=0,c=0;\\n        for(int x: row) {\\n            if(x) ++r;\\n        }\\n        for(int x: col) {\\n            if(x) ++c;\\n        }\\n        return r*m+c*n-2*r*c;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<int> row(n,0),col(m,0);\\n        for(auto x :indices) {\\n            row[x[0]]=!row[x[0]];\\n            col[x[1]]=!col[x[1]];\\n        }\\n        int r=0,c=0;\\n        for(int x: row) {\\n            if(x) ++r;\\n        }\\n        for(int x: col) {\\n            if(x) ++c;\\n        }\\n        return r*m+c*n-2*r*c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 717729,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        \\n        int count = 0;\\n        int row[] = new int [n];\\n        int col[] = new int [m];\\n        for(int x[] : indices)\\n        {\\n            row[x[0]]++;\\n            col[x[1]]++;\\n        }    \\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n            {\\n                if((row[i]+col[j])%2!=0)\\n                    count++;\\n            }        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        \\n        int count = 0;\\n        int row[] = new int [n];\\n        int col[] = new int [m];\\n        for(int x[] : indices)\\n        {\\n            row[x[0]]++;\\n            col[x[1]]++;\\n        }    \\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n            {\\n                if((row[i]+col[j])%2!=0)\\n                    count++;\\n            }        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710870,
                "title": "java-simple-o-n-m-space",
                "content": "```\\n    public int oddCells(int n, int m, int[][] indices) {\\n        int row[] = new int[n], col[] = new int[m], res = 0;\\n        for (int[] idx : indices) {\\n            row[idx[0]]++;\\n            col[idx[1]]++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if ((row[i] + col[j]) % 2 == 1) res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int oddCells(int n, int m, int[][] indices) {\\n        int row[] = new int[n], col[] = new int[m], res = 0;\\n        for (int[] idx : indices) {\\n            row[idx[0]]++;\\n            col[idx[1]]++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if ((row[i] + col[j]) % 2 == 1) res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 647207,
                "title": "1-ms-faster-than-87-36-of-java-online-submissions-clean-solution",
                "content": "```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        int[][] matrix = new int[n][m];\\n        int[] rows = new int[n];\\n        int[] cols = new int[m];\\n        for(int i=0;i<indices.length;i++) {\\n            rows[indices[i][0]]+=1;\\n            cols[indices[i][1]]+=1;\\n        }\\n        int count = 0;\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                matrix[i][j]+=rows[i];\\n                matrix[i][j]+=cols[j];\\n                if(matrix[i][j]%2 == 1) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        int[][] matrix = new int[n][m];\\n        int[] rows = new int[n];\\n        int[] cols = new int[m];\\n        for(int i=0;i<indices.length;i++) {\\n            rows[indices[i][0]]+=1;\\n            cols[indices[i][1]]+=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 643249,
                "title": "java-o-n-m-solution",
                "content": "Steps\\n1. Count the number of times each row and each column is incremented by 1 in two separate arrays i.e rcount and ccount.\\n2. In the end traverse both rcount,ccount and check if their sum is odd or not.\\n```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        int[] rcount=new int[n];\\n        int[] ccount=new int[m];\\n        for(int[] c:indices)\\n        {\\n            rcount[c[0]]++;\\n            ccount[c[1]]++;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if((rcount[i]+ccount[j])%2!=0)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        int[] rcount=new int[n];\\n        int[] ccount=new int[m];\\n        for(int[] c:indices)\\n        {\\n            rcount[c[0]]++;\\n            ccount[c[1]]++;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if((rcount[i]+ccount[j])%2!=0)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606791,
                "title": "cpp-o-m-n-time-with-mathematics-property",
                "content": "```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        \\n        vector<int> row(n,0);\\n        vector<int> col(m,0);\\n        \\n        for(auto x:indices)\\n        {\\n            row[x[0]]++;\\n            col[x[1]]++;\\n        }\\n        \\n        \\n        int e1=0,o1=0;\\n        int e2=0,o2=0;\\n        \\n        for(auto x:row)\\n        {\\n            if(x%2==0)\\n                e1++;\\n            else\\n                o1++;\\n        }\\n        \\n        for(auto x:col)\\n        {\\n            if(x%2==0)\\n                e2++;\\n            else\\n                o2++;\\n        }\\n        \\n        \\n        return e1*o2+o1*e2;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        \\n        vector<int> row(n,0);\\n        vector<int> col(m,0);\\n        \\n        for(auto x:indices)\\n        {\\n            row[x[0]]++;\\n            col[x[1]]++;\\n        }\\n        \\n        \\n        int e1=0,o1=0;\\n        int e2=0,o2=0;\\n        \\n        for(auto x:row)\\n        {\\n            if(x%2==0)\\n                e1++;\\n            else\\n                o1++;\\n        }\\n        \\n        for(auto x:col)\\n        {\\n            if(x%2==0)\\n                e2++;\\n            else\\n                o2++;\\n        }\\n        \\n        \\n        return e1*o2+o1*e2;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 574376,
                "title": "swift",
                "content": "```\\n    func oddCells(_ n: Int, _ m: Int, _ indices: [[Int]]) -> Int {\\n        var row = Array(repeating: 0, count: n)\\n        var col = Array(repeating: 0, count: m)\\n        for indice in indices {\\n            row[indice[0]] += 1\\n            col[indice[1]] += 1\\n        }\\n        var res = 0\\n        for i in 0..<n {\\n            for j in 0..<m {\\n                if (row[i] + col[j]) % 2 != 0 {\\n                    res += 1\\n                }\\n            }\\n        }\\n        return res\\n    }",
                "solutionTags": [],
                "code": "```\\n    func oddCells(_ n: Int, _ m: Int, _ indices: [[Int]]) -> Int {\\n        var row = Array(repeating: 0, count: n)\\n        var col = Array(repeating: 0, count: m)\\n        for indice in indices {\\n            row[indice[0]] += 1\\n            col[indice[1]] += 1\\n        }\\n        var res = 0\\n        for i in 0..<n {\\n            for j in 0..<m {\\n                if (row[i] + col[j]) % 2 != 0 {\\n                    res += 1\\n                }\\n            }\\n        }\\n        return res\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 570838,
                "title": "c-solution-o-n-m-indices-size-complexity-o-n-m-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        std::vector<int> rows(n), cols(m);\\n        for (auto const &i : indices)\\n        {\\n            ++rows[i[0]];\\n            ++cols[i[1]];\\n        }\\n        auto is_odd = [](auto v){ return 1 == v % 2; };\\n        auto const odd_rows = std::count_if(rows.cbegin(), rows.cend(), is_odd); // odd rows\\n        auto const odd_cols = std::count_if(cols.cbegin(), cols.cend(), is_odd); // odd columns\\n        return odd_rows * m + odd_cols * n - 2 * odd_rows * odd_cols;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        std::vector<int> rows(n), cols(m);\\n        for (auto const &i : indices)\\n        {\\n            ++rows[i[0]];\\n            ++cols[i[1]];\\n        }\\n        auto is_odd = [](auto v){ return 1 == v % 2; };\\n        auto const odd_rows = std::count_if(rows.cbegin(), rows.cend(), is_odd); // odd rows\\n        auto const odd_cols = std::count_if(cols.cbegin(), cols.cend(), is_odd); // odd columns\\n        return odd_rows * m + odd_cols * n - 2 * odd_rows * odd_cols;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556642,
                "title": "python-o-m-n-solution",
                "content": "Python O(m+n) solution.\\n\\nFigure out number of rows that were incremented even number of times, and number of ocls that were incremented even number of times.\\n\\nAn odd number at position x, y will be generated if  xth row is incremented even times and yth col is incremented odd times, or if xth row is incremented odd times and yth col is incremented even times.\\n\\n```\\nclass Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        rows = [0] * n\\n        cols = [0] * m\\n        \\n        for index in indices:\\n            rows[index[0]] = rows[index[0]] + 1\\n            cols[index[1]] = cols[index[1]] + 1\\n        \\n        evenrow = 0\\n        evencol = 0\\n        \\n        for row in rows:\\n            if row %2 == 0:\\n                evenrow += 1\\n                \\n        for col in cols:\\n            if col %2 == 0:\\n                evencol += 1\\n                \\n        oddcol = m - evencol\\n        oddrow = n - evenrow\\n        \\n        return evenrow*oddcol + oddrow*evencol\\n```\\n            ``````",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n        rows = [0] * n\\n        cols = [0] * m\\n        \\n        for index in indices:\\n            rows[index[0]] = rows[index[0]] + 1\\n            cols[index[1]] = cols[index[1]] + 1\\n        \\n        evenrow = 0\\n        evencol = 0\\n        \\n        for row in rows:\\n            if row %2 == 0:\\n                evenrow += 1\\n                \\n        for col in cols:\\n            if col %2 == 0:\\n                evencol += 1\\n                \\n        oddcol = m - evencol\\n        oddrow = n - evenrow\\n        \\n        return evenrow*oddcol + oddrow*evencol\\n```\n``````",
                "codeTag": "Java"
            },
            {
                "id": 551851,
                "title": "c-o-indices-100-100-with-explanation",
                "content": "Count Rows operated on by indices, Count columns operated on by indices.\\ninitially all cells are even.\\nEven cells are made by row-column having both odd or both even occurence in indices.\\n\\nSubtract all cells from these two types of cells you get odd cells.\\n\\n```class Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        auto ans = n*m;\\n        vector<int> rows(n), cols(m);\\n        for(auto z: indices)\\n            rows[z[0]]+=1, cols[z[1]]+=1;\\n        auto er=0, ec=0;\\n        for(auto z: rows)\\n            if(z%2==0)\\n                er++;\\n        for(auto z: cols)\\n            if(z%2==0)\\n                ec++;\\n        return ans - (er*ec) - ((n-er) * (m-ec));\\n    }\\n};```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        auto ans = n*m;\\n        vector<int> rows(n), cols(m);\\n        for(auto z: indices)\\n            rows[z[0]]+=1, cols[z[1]]+=1;\\n        auto er=0, ec=0;\\n        for(auto z: rows)\\n            if(z%2==0)\\n                er++;\\n        for(auto z: cols)\\n            if(z%2==0)\\n                ec++;\\n        return ans - (er*ec) - ((n-er) * (m-ec));\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 545891,
                "title": "java-o-m-n-beats-100-on-time-and-memory",
                "content": "\\n    public static int oddCells(int n, int m, int[][] indices) {\\n        int count = 0;\\n        \\n        // these boolean will keep toggling.\\n        boolean[] row = new boolean[n];\\n        boolean[] col = new boolean[m];\\n        \\n        for(int[] rowColPair : indices) {\\n        \\trow[rowColPair[0]] = !row[rowColPair[0]];\\n        \\tcol[rowColPair[1]] = !col[rowColPair[1]];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\t\\t// If this cell row and column both were toggles same number of times(odd or even) \\n\\t\\t\\t\\t// means this is going to be an even number (odd+ odd = even and even + even = even)\\n\\t\\t\\t\\tif(row[i] ^ col[j]) count++;\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "\\n    public static int oddCells(int n, int m, int[][] indices) {\\n        int count = 0;\\n        \\n        // these boolean will keep toggling.\\n        boolean[] row = new boolean[n];\\n        boolean[] col = new boolean[m];\\n        \\n        for(int[] rowColPair : indices) {\\n        \\trow[rowColPair[0]] = !row[rowColPair[0]];\\n        \\tcol[rowColPair[1]] = !col[rowColPair[1]];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\t\\t// If this cell row and column both were toggles same number of times(odd or even) \\n\\t\\t\\t\\t// means this is going to be an even number (odd+ odd = even and even + even = even)\\n\\t\\t\\t\\tif(row[i] ^ col[j]) count++;\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 543899,
                "title": "simple-java-100-runtime-86-space",
                "content": "class Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        \\n        int[] row = new int[n];\\n        int[] col = new int[m];\\n        \\n        for(int i=0;i<indices.length;i++){\\n            row[indices[i][0]]++;\\n            col[indices[i][1]]++;\\n        }\\n        \\n        int res = 0;\\n\\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=0;j<m;j++){\\n                \\n                \\n                if((row[i] + col[j])%2 != 0)  res++;\\n                \\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        \\n        int[] row = new int[n];\\n        int[] col = new int[m];\\n        \\n        for(int i=0;i<indices.length;i++){\\n            row[indices[i][0]]++;\\n            col[indices[i][1]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 542642,
                "title": "simple-python-code",
                "content": "```\\nclass Solution(object):\\n    def oddCells(self, n, m, indices):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :type indices: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        row = [0] * n\\n        col = [0] * m\\n        \\n        for op in indices:\\n            r = op[0]\\n            c = op[1]\\n            row[r] += 1\\n            col[c] += 1\\n        \\n        count = 0\\n        for x in row:\\n            for y in col:\\n                if (x + y) % 2 == 1:\\n                    count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def oddCells(self, n, m, indices):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :type indices: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        row = [0] * n\\n        col = [0] * m\\n        \\n        for op in indices:\\n            r = op[0]\\n            c = op[1]\\n            row[r] += 1\\n            col[c] += 1\\n        \\n        count = 0\\n        for x in row:\\n            for y in col:\\n                if (x + y) % 2 == 1:\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 530066,
                "title": "javascript-math-solution",
                "content": "I tried to use math as much as possible.\\n\\nEach line does 1 thing.\\n\\nRuntime: 60 ms, faster than 69.81% of JavaScript online submissions\\nMemory Usage: 35.9 MB, less than 100.00% of JavaScript online submissions\\n\\n```javascript\\nconst oddCells = (n, m, indices) => {\\n  const [rows, cols] = [new Array(n).fill(0), new Array(m).fill(0)];\\n  for (const [ri, ci] of indices) [rows[ri]++, cols[ci]++];\\n  const rowOdds = rows.filter(n => 1 === n % 2).length;\\n  const rowEvens = rows.length - rowOdds;\\n  const colOdds = cols.filter(n => 1 === n % 2).length;\\n  const colEvens = cols.length - colOdds;\\n  return rowOdds * colEvens + rowEvens * colOdds;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```javascript\\nconst oddCells = (n, m, indices) => {\\n  const [rows, cols] = [new Array(n).fill(0), new Array(m).fill(0)];\\n  for (const [ri, ci] of indices) [rows[ri]++, cols[ci]++];\\n  const rowOdds = rows.filter(n => 1 === n % 2).length;\\n  const rowEvens = rows.length - rowOdds;\\n  const colOdds = cols.filter(n => 1 === n % 2).length;\\n  const colEvens = cols.length - colOdds;\\n  return rowOdds * colEvens + rowEvens * colOdds;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 514069,
                "title": "brief-python-solution-o-m-n-l",
                "content": "```python\\ndef oddCells(self, n, m, indices):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :type indices: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        rows, cols = [False] * n, [False] * m\\n        for i, j in indices: \\n            rows[i], cols[j] = not rows[i], not cols[j]\\n        a, b = sum(rows), sum(cols)\\n        return n * b + m * a - 2 * a * b\\n```",
                "solutionTags": [],
                "code": "```python\\ndef oddCells(self, n, m, indices):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :type indices: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        rows, cols = [False] * n, [False] * m\\n        for i, j in indices: \\n            rows[i], cols[j] = not rows[i], not cols[j]\\n        a, b = sum(rows), sum(cols)\\n        return n * b + m * a - 2 * a * b\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 501308,
                "title": "java-o-m-n-l-time-complexity-0ms",
                "content": "```\\npublic int oddCells(int n, int m, int[][] indices) {\\n        boolean[] rows = new boolean[n];\\n        boolean[] cols = new boolean[m];\\n        for(int[] is : indices){\\n            rows[is[0]] = !rows[is[0]];\\n            cols[is[1]] = !cols[is[1]];\\n        }\\n        \\n        int count = 0;\\n        for(boolean b : rows){\\n            count += b ? 1 : 0;\\n        }\\n         \\n        int result = 0;\\n        for(boolean b : cols){\\n            result += b ? n - count : count;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int oddCells(int n, int m, int[][] indices) {\\n        boolean[] rows = new boolean[n];\\n        boolean[] cols = new boolean[m];\\n        for(int[] is : indices){\\n            rows[is[0]] = !rows[is[0]];\\n            cols[is[1]] = !cols[is[1]];\\n        }\\n        \\n        int count = 0;\\n        for(boolean b : rows){\\n            count += b ? 1 : 0;\\n        }\\n         \\n        int result = 0;\\n        for(boolean b : cols){\\n            result += b ? n - count : count;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 484994,
                "title": "java-short-solution",
                "content": "```\\n    public int oddCells(int n, int m, int[][] indices) {\\n        boolean[] rows = new boolean[n], cols = new boolean[m];\\n        \\n        int nR = 0, nC = 0;\\n        for(int[] t : indices) {\\n            rows[t[0]] ^= true;\\n            cols[t[1]] ^= true;\\n            \\n            nR += rows[t[0]] ? 1 : -1;\\n            nC += cols[t[1]] ? 1 : -1;\\n        }\\n        \\n        return nR*(m - nC) + nC*(n - nR);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int oddCells(int n, int m, int[][] indices) {\\n        boolean[] rows = new boolean[n], cols = new boolean[m];\\n        \\n        int nR = 0, nC = 0;\\n        for(int[] t : indices) {\\n            rows[t[0]] ^= true;\\n            cols[t[1]] ^= true;\\n            \\n            nR += rows[t[0]] ? 1 : -1;\\n            nC += cols[t[1]] ? 1 : -1;\\n        }\\n        \\n        return nR*(m - nC) + nC*(n - nR);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 473678,
                "title": "java-o-n-solution",
                "content": "public static int oddCells(int n, int m, int[][] indices) {\\n\\n\\t\\tint oddNum = 0;\\n\\t\\tint[] arrayNRow = new int[n];\\n\\t\\tint[] arrayMcol = new int[m];\\n\\t\\tint oddRaw = 0;\\n\\n\\t\\tfor (int i = 0; i < indices.length; i++) {\\n\\t\\t\\tarrayNRow[indices[i][0]]++;\\n\\t\\t\\tarrayMcol[indices[i][1]]++;\\n\\n\\t\\t}\\n\\n\\t\\tfor (int j = 0; j < arrayNRow.length; j++) {\\n\\t\\t\\tif (arrayNRow[j] % 2 == 1) {\\n\\t\\t\\t\\toddRaw++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int k = 0; k < arrayMcol.length; k++) {\\n\\t\\t\\tif (arrayMcol[k] % 2 == 1) {\\n\\t\\t\\t\\toddNum = oddNum + n - oddRaw;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\toddNum = oddNum + oddRaw;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn oddNum;\\n\\n\\t}",
                "solutionTags": [],
                "code": "public static int oddCells(int n, int m, int[][] indices) {\\n\\n\\t\\tint oddNum = 0;\\n\\t\\tint[] arrayNRow = new int[n];\\n\\t\\tint[] arrayMcol = new int[m];\\n\\t\\tint oddRaw = 0;\\n\\n\\t\\tfor (int i = 0; i < indices.length; i++) {\\n\\t\\t\\tarrayNRow[indices[i][0]]++;\\n\\t\\t\\tarrayMcol[indices[i][1]]++;\\n\\n\\t\\t}\\n\\n\\t\\tfor (int j = 0; j < arrayNRow.length; j++) {\\n\\t\\t\\tif (arrayNRow[j] % 2 == 1) {\\n\\t\\t\\t\\toddRaw++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int k = 0; k < arrayMcol.length; k++) {\\n\\t\\t\\tif (arrayMcol[k] % 2 == 1) {\\n\\t\\t\\t\\toddNum = oddNum + n - oddRaw;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\toddNum = oddNum + oddRaw;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn oddNum;\\n\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 473135,
                "title": "c-0ms-9-1mb",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Cells with Odd Values in a Matrix.\\nMemory Usage: 9.1 MB, less than 100.00% of C++ online submissions for Cells with Odd Values in a Matrix.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<int> row_counter(n,0);\\n        vector<int> column_counter(m,0);\\n        for(int i=0;i<indices.size();++i)\\n        {\\n            int r=indices[i][0];\\n            int cl=indices[i][1];\\n            row_counter[r]++;\\n            column_counter[cl]++;\\n        }\\n        int odd_counter=0;\\n        for(int i=0;i<n;++i)\\n            for(int j=0;j<m;++j)\\n                if((row_counter[i]+column_counter[j])%2)\\n                    odd_counter++;\\n        return odd_counter;\\n        \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        vector<int> row_counter(n,0);\\n        vector<int> column_counter(m,0);\\n        for(int i=0;i<indices.size();++i)\\n        {\\n            int r=indices[i][0];\\n            int cl=indices[i][1];\\n            row_counter[r]++;\\n            column_counter[cl]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 468431,
                "title": "without-declaring-2d-array-c-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        map<int, int> rows;\\n        map<int, int> cols;\\n        int count=0;\\n        for(int i=0;i<indices.size();i++) \\n        {\\n            rows[indices[i][0]]++;\\n            cols[indices[i][1]]++;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if((rows[i]+cols[j])%2 != 0)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>>& indices) {\\n        map<int, int> rows;\\n        map<int, int> cols;\\n        int count=0;\\n        for(int i=0;i<indices.size();i++) \\n        {\\n            rows[indices[i][0]]++;\\n            cols[indices[i][1]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 461670,
                "title": "javascript-52ms-95-84-mb-100",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number} m\\n * @param {number[][]} indices\\n * @return {number}\\n */\\nvar oddCells = function(n, m, indices) {\\n    \\n    const matrix = indices.reduce((result, item) => {\\n                       \\n        result.rows[item[0]] += 1;\\n        result.columns[item[1]] += 1;\\n        \\n        return result;\\n        \\n    }, { rows: new Float32Array(n), columns: new Float32Array(m) });\\n    \\n    const columnOdds = matrix.columns.reduce((odds, column) => {\\n        \\n        if (column % 2 !== 0)\\n            odds += 1;\\n        \\n        return odds;\\n        \\n    }, 0);\\n\\n    return matrix.rows.reduce((odds, row) => odds += (row % 2 === 0) ? columnOdds : m - columnOdds, 0);\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} m\\n * @param {number[][]} indices\\n * @return {number}\\n */\\nvar oddCells = function(n, m, indices) {\\n    \\n    const matrix = indices.reduce((result, item) => {\\n                       \\n        result.rows[item[0]] += 1;\\n        result.columns[item[1]] += 1;\\n        \\n        return result;\\n        \\n    }, { rows: new Float32Array(n), columns: new Float32Array(m) });\\n    \\n    const columnOdds = matrix.columns.reduce((odds, column) => {\\n        \\n        if (column % 2 !== 0)\\n            odds += 1;\\n        \\n        return odds;\\n        \\n    }, 0);\\n\\n    return matrix.rows.reduce((odds, row) => odds += (row % 2 === 0) ? columnOdds : m - columnOdds, 0);\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 461297,
                "title": "fast-rust-solution",
                "content": "```rust\\npub fn odd_cells(n: i32, m: i32, indices: Vec<Vec<i32>>) -> i32 {\\n\\tlet (mut row, mut col) = (vec![false; n as usize], vec![false; m as usize]);\\n\\tlet (mut r, mut c) = (0, 0);\\n\\tfor p in &indices {\\n\\t\\tlet (x, y) = (p[0] as usize, p[1] as usize);\\n\\t\\trow[x] ^= true;\\n\\t\\tcol[y] ^= true;\\n\\t\\tr += if row[x] { 1 } else { -1 };\\n\\t\\tc += if col[y] { 1 } else { -1 };\\n\\t}\\n\\tr * m + c * n - 2 * r * c\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub fn odd_cells(n: i32, m: i32, indices: Vec<Vec<i32>>) -> i32 {\\n\\tlet (mut row, mut col) = (vec![false; n as usize], vec![false; m as usize]);\\n\\tlet (mut r, mut c) = (0, 0);\\n\\tfor p in &indices {\\n\\t\\tlet (x, y) = (p[0] as usize, p[1] as usize);\\n\\t\\trow[x] ^= true;\\n\\t\\tcol[y] ^= true;\\n\\t\\tr += if row[x] { 1 } else { -1 };\\n\\t\\tc += if col[y] { 1 } else { -1 };\\n\\t}\\n\\tr * m + c * n - 2 * r * c\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 459979,
                "title": "java-solution-with-explanation",
                "content": "**Solution1** Straight-forward solution\\n```\\npublic int oddCells(int n, int m, int[][] ind) {\\n        int[][] a = new int[n][m];\\n        for(int[] c : ind){\\n            for(int j=0; j < m; j++)\\n                a[c[0]][j]++;\\n            for(int i=0; i < n; i++)\\n                a[i][c[1]]++;\\n        }\\n        int count = 0;\\n        for(int i=0; i < n; i++)\\n            for(int j=0; j < m; j++)\\n                if(a[i][j] % 2 != 0)\\n                    ++count;\\n        return count;\\n    }\\n```\\n**Solution2** space and time efficient version\\n\\n`row[i]` indicates how many increments were made to `i`th row.\\n`col[j]` indicates how many increments were made to `j`th row.\\n`r_odd` how many rows are odd incremented\\n`c_odd` how many cols are odd incremented\\n\\nSo `r_odd*m+c_odd*n` will be the total odd cells but we should exclude intersections that is at each cell when we increment the corresponding row and col, that cell itself will be incremeted twice thus becoming even. So how many such intersections exist? That will be cartesian product of those odd rows and odd cols.\\n\\n**PS** I believe `ind` shouldn\\'t have duplicates to work out this logic.\\n\\n```\\npublic int oddCells(int n, int m, int[][] ind) {\\n        int[] rows = new int[n], cols = new int[m];\\n        for(int[] c : ind){\\n            rows[c[0]]++;\\n            cols[c[1]]++;\\n        }\\n        int r_odd = 0, c_odd = 0;\\n        for(int r : rows)\\n            if(r%2 != 0)\\n                ++r_odd;\\n        for(int c : cols)\\n            if(c%2 != 0)\\n                ++c_odd;\\n        return r_odd*m+c_odd*n-2*r_odd*c_odd;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int oddCells(int n, int m, int[][] ind) {\\n        int[][] a = new int[n][m];\\n        for(int[] c : ind){\\n            for(int j=0; j < m; j++)\\n                a[c[0]][j]++;\\n            for(int i=0; i < n; i++)\\n                a[i][c[1]]++;\\n        }\\n        int count = 0;\\n        for(int i=0; i < n; i++)\\n            for(int j=0; j < m; j++)\\n                if(a[i][j] % 2 != 0)\\n                    ++count;\\n        return count;\\n    }\\n```\n```\\npublic int oddCells(int n, int m, int[][] ind) {\\n        int[] rows = new int[n], cols = new int[m];\\n        for(int[] c : ind){\\n            rows[c[0]]++;\\n            cols[c[1]]++;\\n        }\\n        int r_odd = 0, c_odd = 0;\\n        for(int r : rows)\\n            if(r%2 != 0)\\n                ++r_odd;\\n        for(int c : cols)\\n            if(c%2 != 0)\\n                ++c_odd;\\n        return r_odd*m+c_odd*n-2*r_odd*c_odd;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 443037,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\\n        r = [0]*m\\n        c = [0]*n\\n\\n        for ri,ci in indices:\\n            r[ri] +=1\\n            c[ci] +=1\\n        print(indices)\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if (r[i]+c[j])%2 ==1:\\n                    res +=1\\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\\n        r = [0]*m\\n        c = [0]*n\\n\\n        for ri,ci in indices:\\n            r[ri] +=1\\n            c[ci] +=1\\n        print(indices)\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if (r[i]+c[j])%2 ==1:\\n                    res +=1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436784,
                "title": "java-90-faster-and-takes-100-less-memory",
                "content": "```\\n\\tclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        int k = 0; \\n        int sumR[] = new int[n], sumC[] = new int[m];\\n        for (int[] index : indices) {\\n            sumR[index[0]]++;\\n            sumC[index[1]]++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if ((sumR[i] + sumC[j]) % 2 == 1) {\\n                    k++;\\n                }\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        int k = 0; \\n        int sumR[] = new int[n], sumC[] = new int[m];\\n        for (int[] index : indices) {\\n            sumR[index[0]]++;\\n            sumC[index[1]]++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if ((sumR[i] + sumC[j]) % 2 == 1) {\\n                    k++;\\n                }\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434546,
                "title": "javascript-100-memory-71-time",
                "content": "```\\nvar oddCells = function(n, m, indices) {\\n    let res = 0;\\n    let row = new Array(n).fill(0);\\n    let col = new Array(m).fill(0);\\n    indices.forEach(set => {\\n        row[set[0]]++;\\n        col[set[1]]++;\\n    });\\n    row.forEach(item => {\\n        for(let i = 0; i < col.length; i++) {\\n            if((item + col[i])%2 !== 0) { res++ } \\n        }\\n    });\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar oddCells = function(n, m, indices) {\\n    let res = 0;\\n    let row = new Array(n).fill(0);\\n    let col = new Array(m).fill(0);\\n    indices.forEach(set => {\\n        row[set[0]]++;\\n        col[set[1]]++;\\n    });\\n    row.forEach(item => {\\n        for(let i = 0; i < col.length; i++) {\\n            if((item + col[i])%2 !== 0) { res++ } \\n        }\\n    });\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 432340,
                "title": "java-solution-with-comment-of-each-line-clean-code",
                "content": "\\n```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        int[][] matrix=new int[n][m]; \\n        int counter=0;\\n        for(int x=0;x<indices.length;x++){\\n                int row=indices[x][0]; // which row will increment in matrix\\n                int column=indices[x][1]; // which column will increment in matrix\\n                //column increment\\n                for(int i=0;i<n;i++){\\n                    matrix[i][column]+=1;\\n                }\\n                //row increment\\n                for(int i=0;i<m;i++){\\n                    matrix[row][i]+=1;\\n                }\\n\\n        }\\n        //check each number in matrix to find odd number amount\\n        for(int x=0; x<n;x++){\\n            for(int y=0; y<m;y++){\\n                if(matrix[x][y]%2==1){\\n                    counter++;\\n                }\\n            }\\n        }\\n        return counter;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        int[][] matrix=new int[n][m]; \\n        int counter=0;\\n        for(int x=0;x<indices.length;x++){\\n                int row=indices[x][0]; // which row will increment in matrix\\n                int column=indices[x][1]; // which column will increment in matrix\\n                //column increment\\n                for(int i=0;i<n;i++){\\n                    matrix[i][column]+=1;\\n                }\\n                //row increment\\n                for(int i=0;i<m;i++){\\n                    matrix[row][i]+=1;\\n                }\\n\\n        }\\n        //check each number in matrix to find odd number amount\\n        for(int x=0; x<n;x++){\\n            for(int y=0; y<m;y++){\\n                if(matrix[x][y]%2==1){\\n                    counter++;\\n                }\\n            }\\n        }\\n        return counter;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431330,
                "title": "c-o-indices-length-time-o-n-m-space",
                "content": "Simple C# solution with keeping track of the columns and rows that are incremented, and actully since incremental is not important, but the parity is , just keep boolean (is odd)\\n\\n```\\nusing System.Collections;\\n\\npublic class Solution {\\n    public int OddCells(int n, int m, int[][] indices) {\\n        var rows = new BitArray(n);\\n        var rows_count =0;\\n        var cols = new BitArray(m);\\n        var cols_count =0;\\n        foreach( var index in indices) {\\n            rows.Set(index[0], !rows.Get(index[0]));\\n            rows_count+= rows.Get(index[0])? 1 : -1;\\n            cols.Set(index[1], !cols.Get(index[1]));\\n            cols_count+=cols.Get(index[1]) ? 1 : -1;  \\n        }\\n        return rows_count * ( m - cols_count) + cols_count* ( n - rows_count);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Collections;\\n\\npublic class Solution {\\n    public int OddCells(int n, int m, int[][] indices) {\\n        var rows = new BitArray(n);\\n        var rows_count =0;\\n        var cols = new BitArray(m);\\n        var cols_count =0;\\n        foreach( var index in indices) {\\n            rows.Set(index[0], !rows.Get(index[0]));\\n            rows_count+= rows.Get(index[0])? 1 : -1;\\n            cols.Set(index[1], !cols.Get(index[1]));\\n            cols_count+=cols.Get(index[1]) ? 1 : -1;  \\n        }\\n        return rows_count * ( m - cols_count) + cols_count* ( n - rows_count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428610,
                "title": "o-l-time-and-o-m-n-space-solution-100-faster-and-100-less-space",
                "content": "We only need to calculate amounts of each rows/columns that is mentioned the given indices.\\n\\nAnd there are two parts of items in this matrix we care about:\\n1. Rows that are mentioned odd times. We can calculate amount of odd items on these rows by using `odd_rows * (m - odd_columns)`, which is equal to `odd_rows * even_cols`\\n2. Rows that are mentioned even times. Also, calculate amount of odd items on these rows by using `(n - odd_rows) * odd_columns`, which is equal to `even_rows * odd_columns`\\n\\nBy this approach, we only need to traverse the given indices once and count the occurance the mentioned rows/columns, and just sum two parts up.\\nIt takes only O(L) time where L denotes length of the given indices and O(m+n) space for counting occurance.\\n\\n```\\n# Python3\\n\\nclass Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n\\t    rows, cols = [False] * n, [False] * m\\n        for r, c in indices:\\n\\t\\t    rows[r] ^= True\\n\\t\\t\\tcols[c] ^= True\\n\\n        odd_rows = sum(rows)\\n        odd_cols = sum(cols)\\n        even_rows = n - odd_rows\\n\\t\\teven_cols = m - odd_cols\\n\\n        return odd_rows * even_cols + even_rows * odd_cols\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Python3\\n\\nclass Solution:\\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\\n\\t    rows, cols = [False] * n, [False] * m\\n        for r, c in indices:\\n\\t\\t    rows[r] ^= True\\n\\t\\t\\tcols[c] ^= True\\n\\n        odd_rows = sum(rows)\\n        odd_cols = sum(cols)\\n        even_rows = n - odd_rows\\n\\t\\teven_cols = m - odd_cols\\n\\n        return odd_rows * even_cols + even_rows * odd_cols\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425913,
                "title": "python-solutions-with-video-explanations",
                "content": "**Video Explanation**\\nhttps://youtu.be/Z49SHHLzq4w\\n\\n**Solution 1**\\n\\n    def oddCells(self, n, m, indices):\\n        M = [[0 for _ in range(m)] for _ in range(n)]\\n        for ri, ci in indices:\\n            M[ri] = [v + 1 for v in M[ri]]\\n            for i in range(n):\\n                M[i][ci] += 1\\n        return len([M[i][j] for i in range(n) for j in range(m) if M[i][j] % 2 == 1])\\n\\t\\t\\n**Solution 2**\\n```\\ndef oddCells(self, n, m, indices):\\n        row, col = Counter(r for r, _ in indices), Counter(c for _, c in indices)\\n        return sum(row[i] + col[j] % 2 for i in range(n) for j in range(m))\\n```\\n\\n**Solution 3**\\n```\\n def oddCells(self, n, m, indices):\\n        row, col = [False] * n, [False] * m\\n        for r, c in indices:\\n            row[r] ^= True\\n            col[c] ^= True\\n        return sum(r ^ c for r in row for c in col)\\n```\\n\\n**Solution 4**\\n```\\ndef oddCells(self, n, m, indices):\\n\\trow, col, countOddRow, countOddCol = [False] * n, [False] * m, 0, 0\\n\\tfor r, c in indices:\\n\\t\\trow[r] ^= True\\n\\t\\tcol[c] ^= True\\n\\t\\tcountOddRow += 1 if row[r] else -1\\n\\t\\tcountOddCol += 1 if col[c] else -1\\n\\treturn (m * countOddRow) + (n * countOddCol) - (2 * countOddRow * countOddCol)\\n```\\t\\t",
                "solutionTags": [],
                "code": "```\\ndef oddCells(self, n, m, indices):\\n        row, col = Counter(r for r, _ in indices), Counter(c for _, c in indices)\\n        return sum(row[i] + col[j] % 2 for i in range(n) for j in range(m))\\n```\n```\\n def oddCells(self, n, m, indices):\\n        row, col = [False] * n, [False] * m\\n        for r, c in indices:\\n            row[r] ^= True\\n            col[c] ^= True\\n        return sum(r ^ c for r in row for c in col)\\n```\n```\\ndef oddCells(self, n, m, indices):\\n\\trow, col, countOddRow, countOddCol = [False] * n, [False] * m, 0, 0\\n\\tfor r, c in indices:\\n\\t\\trow[r] ^= True\\n\\t\\tcol[c] ^= True\\n\\t\\tcountOddRow += 1 if row[r] else -1\\n\\t\\tcountOddCol += 1 if col[c] else -1\\n\\treturn (m * countOddRow) + (n * countOddCol) - (2 * countOddRow * countOddCol)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4101054,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n      // this beats 80%\\n /*   static int helper(int m, int n, int arr[][]){\\n        int a[][] = new int[m][n];\\n\\n        for(int i=0; i<arr.length; i++){\\n            int r = arr[i][0];\\n            int c = arr[i][1];\\n            for(int j=0; j<n; j++){\\n                a[r][j]++;\\n            }\\n\\n            for(int j=0; j<m; j++){\\n                a[j][c]++;\\n            }\\n        }\\n\\n        int ans = 0;\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(a[i][j]%2!=0) ans++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n    */\\n    public int oddCells(int m, int n, int[][] indices) {\\n        \\n        int[] rows = new int[m];\\n        int[] cols = new int[n];\\n        \\n        //rows\\n        for(int[] rc : indices) {\\n            rows[rc[0]]++;\\n            cols[rc[1]]++;\\n        }\\n        \\n        int oddRows = 0;\\n        for(int row : rows) {\\n            if(row % 2 == 1) {\\n                oddRows++;\\n            }\\n        }\\n        int oddCols = 0; \\n        for(int col : cols) {\\n            if(col % 2 == 1) {\\n                oddCols++;\\n            }\\n        }\\n        \\n        int odds = (oddRows * n) + (oddCols * m); \\n        int evensFromCrossOver = oddRows * oddCols; \\n        if(odds > 0 && oddRows > 0 && oddCols > 0) {\\n\\t\\t\\t// Since the odds and evens are BOTH incremented, you need to decrement this count twice.\\n            odds = odds - (2 * evensFromCrossOver);  \\n        }\\n        \\n        return odds; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n      // this beats 80%\\n /*   static int helper(int m, int n, int arr[][]){\\n        int a[][] = new int[m][n];\\n\\n        for(int i=0; i<arr.length; i++){\\n            int r = arr[i][0];\\n            int c = arr[i][1];\\n            for(int j=0; j<n; j++){\\n                a[r][j]++;\\n            }\\n\\n            for(int j=0; j<m; j++){\\n                a[j][c]++;\\n            }\\n        }\\n\\n        int ans = 0;\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(a[i][j]%2!=0) ans++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n    */\\n    public int oddCells(int m, int n, int[][] indices) {\\n        \\n        int[] rows = new int[m];\\n        int[] cols = new int[n];\\n        \\n        //rows\\n        for(int[] rc : indices) {\\n            rows[rc[0]]++;\\n            cols[rc[1]]++;\\n        }\\n        \\n        int oddRows = 0;\\n        for(int row : rows) {\\n            if(row % 2 == 1) {\\n                oddRows++;\\n            }\\n        }\\n        int oddCols = 0; \\n        for(int col : cols) {\\n            if(col % 2 == 1) {\\n                oddCols++;\\n            }\\n        }\\n        \\n        int odds = (oddRows * n) + (oddCols * m); \\n        int evensFromCrossOver = oddRows * oddCols; \\n        if(odds > 0 && oddRows > 0 && oddCols > 0) {\\n\\t\\t\\t// Since the odds and evens are BOTH incremented, you need to decrement this count twice.\\n            odds = odds - (2 * evensFromCrossOver);  \\n        }\\n        \\n        return odds; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585744,
                "title": "javascript-beats-o-nm-i-time-o-n-m-space",
                "content": "![image.png](https://assets.leetcode.com/users/images/3f0047c5-1df2-4845-afdc-20607bc3b0b0_1685618150.5224345.png)\\n\\n# Approach\\nAfter appying all increments, the value of each cell in the resulting table equals the total number of it\\'s row increments plus total number of it\\'s column increments.\\n\\nTherefore, I solve the task by first counting how many times every row and column is incremented, then loooking at the value of every cell in the resulting table.\\n\\n```\\nfunction oddCells(m, n, indices) {\\n    const rows = new Array(m).fill(0);\\n    const cols = new Array(n).fill(0);\\n\\n    // Count how many times each row and column has been incremented\\n    for (const [i, j] of indices) {\\n        rows[i]++;\\n        cols[j]++;\\n    }\\n\\n    let result = 0;\\n\\n    // Check every cell value after applying all increments\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            const value = rows[i] + cols[j];\\n            if (value % 2) result++;\\n        }\\n    }\\n\\n    return result;\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(nm + i)$$ where $$i$$ is `indices.length`\\n\\n- Space complexity: $$O(n + m)$$\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction oddCells(m, n, indices) {\\n    const rows = new Array(m).fill(0);\\n    const cols = new Array(n).fill(0);\\n\\n    // Count how many times each row and column has been incremented\\n    for (const [i, j] of indices) {\\n        rows[i]++;\\n        cols[j]++;\\n    }\\n\\n    let result = 0;\\n\\n    // Check every cell value after applying all increments\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            const value = rows[i] + cols[j];\\n            if (value % 2) result++;\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3502887,
                "title": "simple-java-solution-for-beginners-1ms-beats-86-65",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int arr[][] = new int[m][n];\\n        int rowIndex;\\n        int colIndex;\\n        for(int i = 0; i < indices.length; i++) {\\n            rowIndex = indices[i][0];\\n            colIndex = indices[i][1];\\n            for(int j = 0; j < n; j++) {\\n                arr[rowIndex][j] += 1;\\n            }\\n            for(int j = 0; j < m; j++) {\\n                arr[j][colIndex] += 1;\\n            }\\n        }\\n        \\n        int count = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(arr[i][j] % 2 != 0) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int arr[][] = new int[m][n];\\n        int rowIndex;\\n        int colIndex;\\n        for(int i = 0; i < indices.length; i++) {\\n            rowIndex = indices[i][0];\\n            colIndex = indices[i][1];\\n            for(int j = 0; j < n; j++) {\\n                arr[rowIndex][j] += 1;\\n            }\\n            for(int j = 0; j < m; j++) {\\n                arr[j][colIndex] += 1;\\n            }\\n        }\\n        \\n        int count = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(arr[i][j] % 2 != 0) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179191,
                "title": "cells-with-odd-values-in-a-matrix-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        int i, j, k, x, y, count=0;\\n        vector<vector<int>> arr;\\n        vector<int> arr1;\\n\\n        for(i=0 ; i<m ; i++)\\n        {\\n            for(j=0 ; j<n ; j++)\\n            {\\n                arr1.push_back(0);\\n            }\\n            arr.push_back(arr1);\\n        }\\n\\n        for(k=0 ; k<indices.size() ; k++)\\n        {\\n            x = indices[k][0];\\n            y = indices[k][1];\\n            for(i=0 ; i<n ; i++)\\n            {\\n                arr[x][i] += 1;\\n            }\\n            for(i=0 ; i<m ; i++)\\n            {\\n                arr[i][y] += 1;\\n            }\\n        }\\n        for(i=0 ; i<m ; i++)\\n        {\\n            for(j=0 ; j<n ; j++)\\n            {\\n                if(arr[i][j]%2!=0)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        int i, j, k, x, y, count=0;\\n        vector<vector<int>> arr;\\n        vector<int> arr1;\\n\\n        for(i=0 ; i<m ; i++)\\n        {\\n            for(j=0 ; j<n ; j++)\\n            {\\n                arr1.push_back(0);\\n            }\\n            arr.push_back(arr1);\\n        }\\n\\n        for(k=0 ; k<indices.size() ; k++)\\n        {\\n            x = indices[k][0];\\n            y = indices[k][1];\\n            for(i=0 ; i<n ; i++)\\n            {\\n                arr[x][i] += 1;\\n            }\\n            for(i=0 ; i<m ; i++)\\n            {\\n                arr[i][y] += 1;\\n            }\\n        }\\n        for(i=0 ; i<m ; i++)\\n        {\\n            for(j=0 ; j<n ; j++)\\n            {\\n                if(arr[i][j]%2!=0)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781178,
                "title": "easy-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        vector<vector<int>>matrix(m,vector<int>(n,0));\\n        for(int i=0;i<indices.size();i++)\\n        {\\n            int sr=indices[i][0];\\n            int cr=indices[i][1];\\n            \\n            \\n            for(int j=0;j<m;j++)\\n            {\\n               matrix[j][cr]+=1;\\n            }\\n            for(int k=0;k<n;k++)\\n            {\\n               matrix[sr][k]+=1;\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[i].size();j++)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n                if(matrix[i][j] %2 != 0)\\n                {\\n                    count++;\\n                }\\n            }\\n            cout<<endl;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        vector<vector<int>>matrix(m,vector<int>(n,0));\\n        for(int i=0;i<indices.size();i++)\\n        {\\n            int sr=indices[i][0];\\n            int cr=indices[i][1];\\n            \\n            \\n            for(int j=0;j<m;j++)\\n            {\\n               matrix[j][cr]+=1;\\n            }\\n            for(int k=0;k<n;k++)\\n            {\\n               matrix[sr][k]+=1;\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[i].size();j++)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n                if(matrix[i][j] %2 != 0)\\n                {\\n                    count++;\\n                }\\n            }\\n            cout<<endl;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2676767,
                "title": "cells-with-odd-values-in-a-matrix-java-faster-than-100-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n       int[] row = new int[m];\\n        int[] col = new int[n];\\n\\n        // Access every row in indices array\\n        for(int[] r: indices){\\n            // increment the value of corresponding row\\n            row[r[0]]++;\\n            // increment the value of corresponding column\\n            col[r[1]]++;\\n        }\\n\\n        int rowOdd = 0;\\n        int colOdd = 0;\\n        int rowEven = 0;\\n        int colEven = 0;\\n        \\n        // Calculate the number of odd numbers are in rows\\n        for(int i = 0; i < m; i++){\\n            if(row[i] % 2 != 0)\\n                rowOdd++;\\n            else\\n                rowEven++;\\n        }\\n        \\n        \\n        // Calculate the number of odd numbers are in columns\\n        for(int i = 0; i < n; i++){\\n            if(col[i] % 2 != 0)\\n                colOdd++;\\n            else\\n                colEven++;\\n        }\\n        \\n        // To get the number of odd numbers.\\n        // simple math formula is odd + even = odd\\n        // odd + odd = even, even + even = even\\n        // So if we multiply even numbers of column with\\n        // odd numbers of row we will get the numbers of odd \\n        // numbers and vice verca.\\n        \\n        \\n        // Think it every column are in a row\\n        // so any of them are odd give the result of odd.\\n        return rowOdd * colEven + colOdd * rowEven;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n       int[] row = new int[m];\\n        int[] col = new int[n];\\n\\n        // Access every row in indices array\\n        for(int[] r: indices){\\n            // increment the value of corresponding row\\n            row[r[0]]++;\\n            // increment the value of corresponding column\\n            col[r[1]]++;\\n        }\\n\\n        int rowOdd = 0;\\n        int colOdd = 0;\\n        int rowEven = 0;\\n        int colEven = 0;\\n        \\n        // Calculate the number of odd numbers are in rows\\n        for(int i = 0; i < m; i++){\\n            if(row[i] % 2 != 0)\\n                rowOdd++;\\n            else\\n                rowEven++;\\n        }\\n        \\n        \\n        // Calculate the number of odd numbers are in columns\\n        for(int i = 0; i < n; i++){\\n            if(col[i] % 2 != 0)\\n                colOdd++;\\n            else\\n                colEven++;\\n        }\\n        \\n        // To get the number of odd numbers.\\n        // simple math formula is odd + even = odd\\n        // odd + odd = even, even + even = even\\n        // So if we multiply even numbers of column with\\n        // odd numbers of row we will get the numbers of odd \\n        // numbers and vice verca.\\n        \\n        \\n        // Think it every column are in a row\\n        // so any of them are odd give the result of odd.\\n        return rowOdd * colEven + colOdd * rowEven;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626888,
                "title": "c-from-o-n-m-to-o-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        int odd = 0;\\n        #define sol 1\\n        #if sol == 0\\n        // bruteforce, Time O(m*n), space O(m*n);\\n        // initializing a matrix for which all cells are 0\\'s;\\n        vector<vector<int>> matrix(m, vector<int>(n));\\n        // sime increment operations on the matrix\\n        for(auto a : indices){\\n            int r_i = a[0], c_i = a[1];\\n            // increasing all the cell on r_i;\\n            for(int i = 0; i < n;i++){\\n                matrix[r_i][i]++;\\n            }\\n            // increasing all the cell on c_i;\\n            for(int i = 0; i < m;i++){\\n                matrix[i][c_i]++;\\n            }\\n        } \\n        // counting the number of odd number in the matrix\\n        for(int i = 0 ; i < m;i++){\\n            for(int j = 0 ; j < n;j++){\\n                cout<< matrix[i][j] <<endl;\\n                if(matrix[i][j] %2 == 1) \\n                    odd++;\\n            }\\n        }\\n        #elif sol == 1\\n        // optimizing to O(m + n) time, and O(m + n) space;\\n        vector<int> row(m);\\n        vector<int> col(n);\\n        int rodd = 0, reven = 0, codd = 0, ceven = 0;\\n        for(auto a:indices){\\n            int r_i = a[0], c_i = a[1];\\n            row[r_i]++;\\n            col[c_i]++;\\n        }\\n        for(auto r : row){\\n            if(r %2 == 1) rodd++;\\n            else reven++;\\n            \\n        }\\n        for(auto c : col){\\n            if(c %2 == 1) codd++;\\n            else ceven++;\\n                \\n        }\\n        odd = rodd * ceven + reven*codd;\\n        #endif;\\n        return odd;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        int odd = 0;\\n        #define sol 1\\n        #if sol == 0\\n        // bruteforce, Time O(m*n), space O(m*n);\\n        // initializing a matrix for which all cells are 0\\'s;\\n        vector<vector<int>> matrix(m, vector<int>(n));\\n        // sime increment operations on the matrix\\n        for(auto a : indices){\\n            int r_i = a[0], c_i = a[1];\\n            // increasing all the cell on r_i;\\n            for(int i = 0; i < n;i++){\\n                matrix[r_i][i]++;\\n            }\\n            // increasing all the cell on c_i;\\n            for(int i = 0; i < m;i++){\\n                matrix[i][c_i]++;\\n            }\\n        } \\n        // counting the number of odd number in the matrix\\n        for(int i = 0 ; i < m;i++){\\n            for(int j = 0 ; j < n;j++){\\n                cout<< matrix[i][j] <<endl;\\n                if(matrix[i][j] %2 == 1) \\n                    odd++;\\n            }\\n        }\\n        #elif sol == 1\\n        // optimizing to O(m + n) time, and O(m + n) space;\\n        vector<int> row(m);\\n        vector<int> col(n);\\n        int rodd = 0, reven = 0, codd = 0, ceven = 0;\\n        for(auto a:indices){\\n            int r_i = a[0], c_i = a[1];\\n            row[r_i]++;\\n            col[c_i]++;\\n        }\\n        for(auto r : row){\\n            if(r %2 == 1) rodd++;\\n            else reven++;\\n            \\n        }\\n        for(auto c : col){\\n            if(c %2 == 1) codd++;\\n            else ceven++;\\n                \\n        }\\n        odd = rodd * ceven + reven*codd;\\n        #endif;\\n        return odd;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2618028,
                "title": "java-simple-solution",
                "content": "```java\\npublic int oddCells(int m, int n, int[][] indices) {\\n        int r[] = new int[m];\\n        int c[] = new int[n];\\n        for(var p:indices){\\n            r[p[0]] ^= 1;\\n            c[p[1]] ^= 1;\\n        }\\n        int ans = 0;\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                if((r[i] == 1 && c[j] != 1) || (r[i] != 1 && c[j] == 1)) ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int oddCells(int m, int n, int[][] indices) {\\n        int r[] = new int[m];\\n        int c[] = new int[n];\\n        for(var p:indices){\\n            r[p[0]] ^= 1;\\n            c[p[1]] ^= 1;\\n        }\\n        int ans = 0;\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                if((r[i] == 1 && c[j] != 1) || (r[i] != 1 && c[j] == 1)) ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2582866,
                "title": "python-solution-runtime-51-ms-memory-usage-13-9-mb",
                "content": "```\\nclass Solution:\\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\\n        \\n        N = len(indices)\\n        row, col = [0] * m, [0] * n      \\n        \\n        for i, j in indices:\\n            row[i] += 1\\n            col[j] += 1\\n         \\n        initial_matrix = [[0] * n for _ in range(m)]\\n        \\n        counter = 0\\n        for i in range(m):\\n            for j in range(n):\\n                initial_matrix[i][j] += row[i] + col[j]\\n                if initial_matrix[i][j] % 2 != 0:\\n                    counter += 1\\n        \\n        return counter\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\\n        \\n        N = len(indices)\\n        row, col = [0] * m, [0] * n      \\n        \\n        for i, j in indices:\\n            row[i] += 1\\n            col[j] += 1\\n         \\n        initial_matrix = [[0] * n for _ in range(m)]\\n        \\n        counter = 0\\n        for i in range(m):\\n            for j in range(n):\\n                initial_matrix[i][j] += row[i] + col[j]\\n                if initial_matrix[i][j] % 2 != 0:\\n                    counter += 1\\n        \\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2559032,
                "title": "python3-using-xor",
                "content": "class Solution:\\n\\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\\n        rows = [0]*m\\n        cols = [0]*n\\n        \\n        for row,col in indices:\\n            rows[row]^=1\\n            cols[col]^=1\\n            \\n        sumRows,sumCols = sum(rows),sum(cols)\\n        \\n        return sumRows*n + sumCols*m - 2*sumRows*sumCols",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\\n        rows = [0]*m\\n        cols = [0]*n\\n        \\n        for row,col in indices:\\n            rows[row]^=1\\n            cols[col]^=1\\n            \\n        sumRows,sumCols = sum(rows),sum(cols)\\n        \\n        return sumRows*n + sumCols*m - 2*sumRows*sumCols",
                "codeTag": "Java"
            },
            {
                "id": 2550742,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& ind)\\n    {\\n        vector<bool> row(m,false);\\n        vector<bool> col(n,false);\\n        for(int i=0;i<ind.size();i++)\\n        {\\n            row[ind[i][0]]=row[ind[i][0]] ^ true;\\n            col[ind[i][1]]=col[ind[i][1]] ^ true;\\n        }\\n        int r=0,c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(row[i])\\n                r++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(col[i])\\n                c++;\\n        }\\n        return r*n+c*m-2*r*c;\\n\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& ind)\\n    {\\n        vector<bool> row(m,false);\\n        vector<bool> col(n,false);\\n        for(int i=0;i<ind.size();i++)\\n        {\\n            row[ind[i][0]]=row[ind[i][0]] ^ true;\\n            col[ind[i][1]]=col[ind[i][1]] ^ true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2531580,
                "title": "100-faster-0-ms-solution",
                "content": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int arr[]=new int[m];\\n        int arr1[]=new int[n];\\n        int count=0;\\n        for(int i=0;i<indices.length;i++){\\n            arr[indices[i][0]]++;\\n            arr1[indices[i][1]]++;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                count+=(arr[i]+arr1[j])%2;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int arr[]=new int[m];\\n        int arr1[]=new int[n];\\n        int count=0;\\n        for(int i=0;i<indices.length;i++){\\n            arr[indices[i][0]]++;\\n            arr1[indices[i][1]]++;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                count+=(arr[i]+arr1[j])%2;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519153,
                "title": "easy-java-solution-100-fast",
                "content": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int[][] arr = new int[m][n];\\n        int count = 0;\\n        for(int i=0; i<indices.length; i++){\\n            int row = indices[i][0];\\n            int col = indices[i][1];\\n            for(int j=0; j<m; j++){\\n                arr[j][col]++;\\n            }\\n            for(int k=0; k<n; k++){\\n                arr[row][k]++;\\n            }\\n        }\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(arr[i][j]%2 == 1){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int[][] arr = new int[m][n];\\n        int count = 0;\\n        for(int i=0; i<indices.length; i++){\\n            int row = indices[i][0];\\n            int col = indices[i][1];\\n            for(int j=0; j<m; j++){\\n                arr[j][col]++;\\n            }\\n            for(int k=0; k<n; k++){\\n                arr[row][k]++;\\n            }\\n        }\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(arr[i][j]%2 == 1){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503390,
                "title": "java-solution-91-faster",
                "content": "\\n```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int[][] result = new int[m][n];\\n        for (int i = 0; i < indices.length; i++) {\\n            incrementCellsInRow(result, indices[i][0]);\\n            incrementCellsInColumn(result, indices[i][1]);\\n        }\\n        \\n        int count = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (result[i][j] % 2 == 1) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private void incrementCellsInRow(int[][] result, int row) {\\n        for (int i = 0; i < result[0].length; i++) {\\n            result[row][i]++;\\n        }\\n    }\\n\\n    private void incrementCellsInColumn(int[][] result, int col) {\\n        for (int i = 0; i < result.length; i++) {\\n            result[i][col]++;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int[][] result = new int[m][n];\\n        for (int i = 0; i < indices.length; i++) {\\n            incrementCellsInRow(result, indices[i][0]);\\n            incrementCellsInColumn(result, indices[i][1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2436307,
                "title": "c-easy-explained",
                "content": "```\\n//initialize the matrix\\nint matrix[m][n];\\n\\n        //fill the matrix with zeroes\\n        for(int i = 0 ; i < m ;i++){\\n            for(int j = 0 ; j < n ; j++){\\n                matrix[i][j] = 0 ;\\n            }\\n        }\\n        \\n        \\n        int ans = 0, r = 0, c = 0;\\n        \\n        for(int i = 0; i < indices.size(); i++) {\\n            //this access the rows nad columns no. which is given in the indices matrix in the form of [row,col]\\n\\t\\t\\t// we only need 0 and 1 as the colums no.s bcoz there are always only 2 columns i.e., (r , c)\\n            r = indices[i][0];  //row which is to be incremented\\n            c = indices[i][1];  //column which is to be incremented\\n\\t\\t\\t\\n\\t\\t\\t\\n            // increment the elements in row\\n            for(int row = 0; row < n; row++) {\\n                matrix[r][row]++;\\n            }\\n            \\n\\t\\t\\t//increment the elemnt in column\\n            for(int col = 0; col < m; col++) {\\n                matrix[col][c]++;\\n            }\\n            \\n        }\\n        \\n\\t\\t//check how many elements are odd in the matrix and store it in the answer\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(matrix[i][j]%2 != 0){\\n                    ans++;\\n                } \\n            }\\n        }\\n        // returns no. of add elements in the matrix\\n        return ans;",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n//initialize the matrix\\nint matrix[m][n];\\n\\n        //fill the matrix with zeroes\\n        for(int i = 0 ; i < m ;i++){\\n            for(int j = 0 ; j < n ; j++){\\n                matrix[i][j] = 0 ;\\n            }\\n        }\\n        \\n        \\n        int ans = 0, r = 0, c = 0;\\n        \\n        for(int i = 0; i < indices.size(); i++) {\\n            //this access the rows nad columns no. which is given in the indices matrix in the form of [row,col]\\n\\t\\t\\t// we only need 0 and 1 as the colums no.s bcoz there are always only 2 columns i.e., (r , c)\\n            r = indices[i][0];  //row which is to be incremented\\n            c = indices[i][1];  //column which is to be incremented\\n\\t\\t\\t\\n\\t\\t\\t\\n            // increment the elements in row\\n            for(int row = 0; row < n; row++) {\\n                matrix[r][row]++;\\n            }\\n            \\n\\t\\t\\t//increment the elemnt in column\\n            for(int col = 0; col < m; col++) {\\n                matrix[col][c]++;\\n            }\\n            \\n        }\\n        \\n\\t\\t//check how many elements are odd in the matrix and store it in the answer\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(matrix[i][j]%2 != 0){\\n                    ans++;\\n                } \\n            }\\n        }\\n        // returns no. of add elements in the matrix\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 2398038,
                "title": "c-easy-to-understand-straightforward",
                "content": "![image](https://assets.leetcode.com/users/images/84fa88af-4bf0-487f-b832-b6ec87a340ba_1659967024.0477834.png)\\n\\n**s==ind.size()\\nT->O(s * (m+n) + mn) && S->O(mn)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint oddCells(int m, int n, vector<vector<int>>& ind) {\\n\\t\\t\\t\\tvector<vector<int>>mat(m,vector<int>(n,0));\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\tfor(int k=0;k<ind.size();k++){\\n\\t\\t\\t\\t\\tfor(int i=0;i<m;i++) mat[i][ind[k][1]]++;\\n\\t\\t\\t\\t\\tfor(int j=0;j<n;j++) mat[ind[k][0]][j]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i=0;i<m;i++){\\n\\t\\t\\t\\t\\tfor(int j=0;j<n;j++) if(mat[i][j]%2!=0)count++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn count;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint oddCells(int m, int n, vector<vector<int>>& ind) {\\n\\t\\t\\t\\tvector<vector<int>>mat(m,vector<int>(n,0));\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\tfor(int k=0;k<ind.size();k++){\\n\\t\\t\\t\\t\\tfor(int i=0;i<m;i++) mat[i][ind[k][1]]++;\\n\\t\\t\\t\\t\\tfor(int j=0;j<n;j++) mat[ind[k][0]][j]++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2390305,
                "title": "java-solution-cells-with-odd-values-in-a-matrix",
                "content": "```\\n// --------------------- Solution 1 ---------------------\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int[][] matrix = new int[m][n];\\n        \\n        for(int i = 0; i < indices.length; i++) {\\n            int row = indices[i][0];\\n            int col = indices[i][1];\\n            \\n            for(int j = 0; j < n; j++) {\\n                matrix[row][j]++;\\n            }\\n            for(int j = 0; j < m; j++) {\\n                matrix[j][col]++;\\n            }\\n        }\\n        \\n        int counter = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(matrix[i][j] % 2 != 0) {\\n                    counter++;\\n                }\\n            }\\n        }\\n        \\n        return counter;\\n    }\\n}\\n\\n// --------------------- Solution 2 ---------------------\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int[] row = new int[m];\\n        int[] col = new int[n];\\n        \\n        for(int i = 0; i < indices.length; i++) {\\n            row[indices[i][0]]++;\\n            col[indices[i][1]]++;\\n        }\\n        \\n        int counter = 0;\\n        for(int i : row) {\\n            for(int j : col) {\\n                counter += (i + j) % 2 == 0 ? 0 : 1;\\n            }\\n        }\\n        \\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\n// --------------------- Solution 1 ---------------------\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int[][] matrix = new int[m][n];\\n        \\n        for(int i = 0; i < indices.length; i++) {\\n            int row = indices[i][0];\\n            int col = indices[i][1];\\n            \\n            for(int j = 0; j < n; j++) {\\n                matrix[row][j]++;\\n            }\\n            for(int j = 0; j < m; j++) {\\n                matrix[j][col]++;\\n            }\\n        }\\n        \\n        int counter = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(matrix[i][j] % 2 != 0) {\\n                    counter++;\\n                }\\n            }\\n        }\\n        \\n        return counter;\\n    }\\n}\\n\\n// --------------------- Solution 2 ---------------------\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int[] row = new int[m];\\n        int[] col = new int[n];\\n        \\n        for(int i = 0; i < indices.length; i++) {\\n            row[indices[i][0]]++;\\n            col[indices[i][1]]++;\\n        }\\n        \\n        int counter = 0;\\n        for(int i : row) {\\n            for(int j : col) {\\n                counter += (i + j) % 2 == 0 ? 0 : 1;\\n            }\\n        }\\n        \\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362782,
                "title": "ruby-t-o-m-n-p-s-o-m-n-100-100",
                "content": "```\\n# @param {Integer} m\\n# @param {Integer} n\\n# @param {Integer[][]} indices\\n# @return {Integer}\\ndef odd_cells(m, n, indices)\\n  rows = Array.new(m) { 0 } # S: O(m)\\n  cols = Array.new(n) { 0 } # S: O(n)\\n\\n  # T: O(indices.length)\\n  indices.each do |(i, j)|\\n    rows[i] ^= 1\\n    cols[j] ^= 1\\n  end\\n\\n  # T: O(m)\\n  col_odds = cols.count(1)\\n  # T: O(n)\\n  row_odds = rows.count(1)\\n\\n  # T: O(1)\\n  row_odds * (n - col_odds) +  col_odds * (m - row_odds)\\nend",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} m\\n# @param {Integer} n\\n# @param {Integer[][]} indices\\n# @return {Integer}\\ndef odd_cells(m, n, indices)\\n  rows = Array.new(m) { 0 } # S: O(m)\\n  cols = Array.new(n) { 0 } # S: O(n)\\n\\n  # T: O(indices.length)\\n  indices.each do |(i, j)|\\n    rows[i] ^= 1\\n    cols[j] ^= 1\\n  end\\n\\n  # T: O(m)\\n  col_odds = cols.count(1)\\n  # T: O(n)\\n  row_odds = rows.count(1)\\n\\n  # T: O(1)\\n  row_odds * (n - col_odds) +  col_odds * (m - row_odds)\\nend",
                "codeTag": "Python3"
            },
            {
                "id": 2355723,
                "title": "java-naive-approach",
                "content": "The easiest solution is to create required matrix, perform the actions and than count the odd values:\\n\\n```\\nclass Solution {\\n\\n    public int oddCells(int m, int n, int[][] indices) {\\n\\n        int[][] matrix = new int[m][n];\\n\\n        for (int[] idx : indices) {\\n            // handle rows\\n            for (int i = 0; i < matrix[idx[0]].length; i++) {\\n                matrix[idx[0]][i] += 1;\\n            }\\n\\n            // handle columns\\n            for (int i = 0; i < matrix.length; i++) {\\n                matrix[i][idx[1]] += 1;\\n            }\\n        }\\n\\n        // count odd cells\\n        int oddCells = 0;\\n        for (int[] row : matrix) {\\n            for (int cell : row) {\\n                if (cell % 2 > 0) {\\n                    oddCells += 1;\\n                }\\n            }\\n        }\\n\\n        return oddCells;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int oddCells(int m, int n, int[][] indices) {\\n\\n        int[][] matrix = new int[m][n];\\n\\n        for (int[] idx : indices) {\\n            // handle rows\\n            for (int i = 0; i < matrix[idx[0]].length; i++) {\\n                matrix[idx[0]][i] += 1;\\n            }\\n\\n            // handle columns\\n            for (int i = 0; i < matrix.length; i++) {\\n                matrix[i][idx[1]] += 1;\\n            }\\n        }\\n\\n        // count odd cells\\n        int oddCells = 0;\\n        for (int[] row : matrix) {\\n            for (int cell : row) {\\n                if (cell % 2 > 0) {\\n                    oddCells += 1;\\n                }\\n            }\\n        }\\n\\n        return oddCells;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352054,
                "title": "cells-with-odd-values-in-a-matrix",
                "content": "***Here you Go -->***\\n\\n```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        vector<vector<int>> result(m, vector<int>(n,0));           // Make a new 2D array & initialize every element with zero.     result = [[0,0,0],[0,0,0]]\\n        int count=0;\\n        int len=indices.size();\\n        \\n        for (int i = 0; i < len; i++)               // Run a loop till length of indices array\\n        {\\n            for (int j=0; j<m; j++)                 // For changing the values in row, keeping the column same\\n                result[j][indices[i][1]]++;         // indices[i][1] will the column\\n            for (int k=0; k<n; k++)\\n                result[indices[i][0]][k]++;         // Here, indices[i][0] will give the row element number ==> At first iteration; k=0 --> result[0][0]  | k=1 --> result[0][1]  |  k=2 --> result[0][2]  and so on.... Dry run this from i to all the inner loops.\\n        }\\n        \\n        for (int i = 0; i < m; i++)         // To access each row of result array\\n        {\\n            for (int j=0; j<n; j++){        // To access each column of result array\\n                if (result[i][j]%2 !=0)     // Check if the element is odd\\n                    count++;                // If odd, increment count\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        vector<vector<int>> result(m, vector<int>(n,0));           // Make a new 2D array & initialize every element with zero.     result = [[0,0,0],[0,0,0]]\\n        int count=0;\\n        int len=indices.size();\\n        \\n        for (int i = 0; i < len; i++)               // Run a loop till length of indices array\\n        {\\n            for (int j=0; j<m; j++)                 // For changing the values in row, keeping the column same\\n                result[j][indices[i][1]]++;         // indices[i][1] will the column\\n            for (int k=0; k<n; k++)\\n                result[indices[i][0]][k]++;         // Here, indices[i][0] will give the row element number ==> At first iteration; k=0 --> result[0][0]  | k=1 --> result[0][1]  |  k=2 --> result[0][2]  and so on.... Dry run this from i to all the inner loops.\\n        }\\n        \\n        for (int i = 0; i < m; i++)         // To access each row of result array\\n        {\\n            for (int j=0; j<n; j++){        // To access each column of result array\\n                if (result[i][j]%2 !=0)     // Check if the element is odd\\n                    count++;                // If odd, increment count\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306041,
                "title": "simple-java-solution-brute-force",
                "content": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n\\t\\n        int[][] matrix = new int[m][n];\\n        int count = 0;\\n\\t\\t\\n\\t\\t//Matrix row and column initialized as 0\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                matrix[i][j] = 0;\\n            }\\n        }\\n\\t\\t\\n        for (int i = 0; i < indices.length; i++) {\\n\\n            // Increment value by 1 in a row\\n            for (int j = 0; j < n; j++) {\\n                matrix[indices[i][0]][j] += 1;\\n            }\\n\\n            // Increment value by 1 in a col\\n            for (int j2 = 0; j2 < m; j2++) {\\n                matrix[j2][indices[i][1]] += 1; // matrix[]\\n            }\\n\\n        }\\n        \\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[i].length; j++) {\\n                if (matrix[i][j] % 2 != 0) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n\\t\\n        int[][] matrix = new int[m][n];\\n        int count = 0;\\n\\t\\t\\n\\t\\t//Matrix row and column initialized as 0\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                matrix[i][j] = 0;\\n            }\\n        }\\n\\t\\t\\n        for (int i = 0; i < indices.length; i++) {\\n\\n            // Increment value by 1 in a row\\n            for (int j = 0; j < n; j++) {\\n                matrix[indices[i][0]][j] += 1;\\n            }\\n\\n            // Increment value by 1 in a col\\n            for (int j2 = 0; j2 < m; j2++) {\\n                matrix[j2][indices[i][1]] += 1; // matrix[]\\n            }\\n\\n        }\\n        \\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[i].length; j++) {\\n                if (matrix[i][j] % 2 != 0) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287086,
                "title": "java-0ms-time-o-m-n-l-100-faster",
                "content": "[https://leetcode.com/submissions/detail/747951807/](https://leetcode.com/submissions/detail/747951807/)\\n\\n```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        boolean[] row = new boolean[m];\\n        boolean[] col = new boolean[n];\\n        \\n        for(int i=0 ; i<indices.length ; i++) {\\n            row[indices[i][0]] ^= true;\\n            col[indices[i][1]] ^= true;\\n        }\\n        int r = 0;\\n        int c = 0;\\n        for(int i=0 ; i<m ; i++) {\\n            if(row[i]) {\\n                r++;\\n            }\\n        }\\n        \\n        for(int i=0 ; i<n ; i++) {\\n            if(col[i]) {\\n                c++;\\n            }\\n        }\\n        return r*n + c*m - 2*r*c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        boolean[] row = new boolean[m];\\n        boolean[] col = new boolean[n];\\n        \\n        for(int i=0 ; i<indices.length ; i++) {\\n            row[indices[i][0]] ^= true;\\n            col[indices[i][1]] ^= true;\\n        }\\n        int r = 0;\\n        int c = 0;\\n        for(int i=0 ; i<m ; i++) {\\n            if(row[i]) {\\n                r++;\\n            }\\n        }\\n        \\n        for(int i=0 ; i<n ; i++) {\\n            if(col[i]) {\\n                c++;\\n            }\\n        }\\n        return r*n + c*m - 2*r*c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232460,
                "title": "simple-explanation-with-code-100-faster",
                "content": "1 )  brute-force is -- > \\n toggle each row and col one by one --  O( indices.length * ( m + n ) ) \\n\\ncount odd using two loops --- >O( m *  n) \\n\\n time -- >     O( indices.length * ( m + n )  + m * n ) \\nspace  --> 2d matrix size == O( m * n ) \\n\\n`class Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        \\n        int[][] arr = new int[m][n];\\n      \\n         for(int i=0 ; i<indices.length ; i++){\\n             \\n             int row = indices[i][0] ;\\n             int col = indices[i][1];\\n             \\n             for(int j=0 ; j<n ; j++ ){\\n                \\n                 arr[row][j]++;\\n             }\\n             \\n             \\n             for(int j=0 ; j< m ; j++){\\n                 arr[j][col]++ ;\\n             }\\n         }\\n        \\n        int cnt = 0 ;\\n        for(int[] row : arr )\\n            for(int i = 0 ; i<row.length ; i++)\\n                 if(row[i] % 2 == 1)\\n                     cnt++;\\n        \\n        \\n        return cnt ;\\n    }\\n}`\\n\\n\\n2 ) \\noptimise approach  is -->\\ntake an boolean array of row and boolean array of col \\nand togle them ( xor ) them according too indices \\n\\nthen  count  how many in row are odd ( count true in row array ) , count how many in col are odd( count true in col ) \\n\\nthen    oddToggleRow * n  ( that many odd value it can toggle in actual 2d  in row perspective )   \\n                          +\\n           oddToggleCol * r ( that many  odd value it can toggle in actual 2d col    perspective \\n                          minus double counts \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n               - 2 *  oddToggleRow * oddToggleCol  (  ex - if you toggle row 1 and coll 1 of 3 * 3 matrix -- > row toggle 3 elment  and coll toggle 3 element in call wise the intesection of row and coll is counted in both (  T ^ T == F  ( which should not be counted at all ) \\n\\n\\ntime -- > O( indices.length ) ans m and n ( 0 <=  m , n < =50 )  is small compare to indices.length ( 1000)\\n\\nspace -- o ( n + m ) \\n`class Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n      \\n       boolean[]  row =  new boolean[m];\\n       boolean[]  col = new boolean[n] ;\\n        \\n        \\n       for(int[] cordinates : indices ){\\n           \\n           row[cordinates[0]] ^= true ;\\n           \\n           col[cordinates[1]] ^=true ;\\n           \\n       }\\n        \\n        \\n        int oddToggleInRow = 0 ;\\n        \\n        int oddToggleInCol = 0 ;\\n        \\n        \\n        for(boolean val : row )\\n            if(val)\\n                oddToggleInRow++;\\n        \\n        \\n        for(boolean val : col )\\n             if(val)\\n                 oddToggleInCol++;\\n        \\n        \\n        return oddToggleInRow * n  + oddToggleInCol * m   - 2 * oddToggleInRow * oddToggleInCol ;\\n    }\\n}`\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        \\n        int[][] arr = new int[m][n];\\n      \\n         for(int i=0 ; i<indices.length ; i++){\\n             \\n             int row = indices[i][0] ;\\n             int col = indices[i][1];\\n             \\n             for(int j=0 ; j<n ; j++ ){\\n                \\n                 arr[row][j]++;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 2227309,
                "title": "swift-memory-100-easy-understanding-solution",
                "content": "```swift\\nclass Solution {\\n    func oddCells(_ m: Int, _ n: Int, _ indices: [[Int]]) -> Int {\\n\\t\\t// make matrix (n x m)\\n        let inner = [Int](repeating: 0, count: n)\\n        var matrix = [[Int]](repeating: inner, count: m)\\n\\n\\t\\t// do indices logic\\n        for item in indices {\\n            let r = item[0]\\n            let c = item[1]\\n\\n            matrix[r] = matrix[r].map { $0 + 1 }\\n\\n            for i in 0 ..< matrix.count {\\n                matrix[i][c] += 1\\n            }\\n        }\\n\\n\\t\\t// find odd count in matrix\\n        var result = 0\\n        for item in matrix {\\n            result += item.filter { $0 % 2 != 0 }.count\\n        }\\n\\n        return result\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/35df20d6-8eb3-46cc-9ef2-e9640d2c7bcb_1656764723.929795.png)",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func oddCells(_ m: Int, _ n: Int, _ indices: [[Int]]) -> Int {\\n\\t\\t// make matrix (n x m)\\n        let inner = [Int](repeating: 0, count: n)\\n        var matrix = [[Int]](repeating: inner, count: m)\\n\\n\\t\\t// do indices logic\\n        for item in indices {\\n            let r = item[0]\\n            let c = item[1]\\n\\n            matrix[r] = matrix[r].map { $0 + 1 }\\n\\n            for i in 0 ..< matrix.count {\\n                matrix[i][c] += 1\\n            }\\n        }\\n\\n\\t\\t// find odd count in matrix\\n        var result = 0\\n        for item in matrix {\\n            result += item.filter { $0 % 2 != 0 }.count\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181313,
                "title": "c-solution-100-faster",
                "content": "# Explaination\\nLet us consider the first example for understanding the solution. \\nInitially, we have 2 * 3 matrix all initialised to 0. \\n[0, 0, 0]\\n[0, 0, 0]\\n\\nWe can maintain two arrays rows and cols which will maintain the number of times a row/column is updated. \\nrows = [0, 0]\\ncols = [0, 0, 0]\\n\\nFor [0,1] indice, \\nrows = [1, 0]\\ncols = [0, 1, 0]\\n\\nFor [1,1] indice,\\nrows = [1, 1]\\ncols  = [0, 2, 0]\\n\\nNow, we know that row 0 will be incremented only once resulting in 3 odd values for 0th row. These 0th row elements will remain odd only if there were incremented for even number of times in by column updation. \\nSame goes for each rows. \\nHence, we can deduce the formula that\\noddRows * evenCols + evenRows * oddCols.\\n\\n# C++ Solution\\n```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        int rows[m], cols[n];\\n        for(int i=0;i<m;i++){\\n            rows[i] = 0;\\n        }\\n        for(int j=0;j<n;j++){\\n            cols[j] = 0;\\n        }\\n        for(vector<int> indice: indices){\\n            rows[indice[0]]++;\\n            cols[indice[1]]++;\\n        }\\n        int oddRows = 0, oddCols = 0, evenRows = 0, evenCols = 0;\\n        for(int i=0;i<m;i++){\\n            oddRows += 1&rows[i];\\n        }\\n        for(int j=0;j<n;j++){\\n            oddCols += 1&cols[j];\\n        }\\n        return oddRows * (n - oddCols) + (m - oddRows) * oddCols;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        int rows[m], cols[n];\\n        for(int i=0;i<m;i++){\\n            rows[i] = 0;\\n        }\\n        for(int j=0;j<n;j++){\\n            cols[j] = 0;\\n        }\\n        for(vector<int> indice: indices){\\n            rows[indice[0]]++;\\n            cols[indice[1]]++;\\n        }\\n        int oddRows = 0, oddCols = 0, evenRows = 0, evenCols = 0;\\n        for(int i=0;i<m;i++){\\n            oddRows += 1&rows[i];\\n        }\\n        for(int j=0;j<n;j++){\\n            oddCols += 1&cols[j];\\n        }\\n        return oddRows * (n - oddCols) + (m - oddRows) * oddCols;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078680,
                "title": "a-simple-brute-force-solution-based-on-loops",
                "content": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n\\t// Making the ans matrix base\\n        int[][] matrix = new int[m][n];\\n        int count = 0;\\n        while(m>0){\\n            while(n>0){\\n                matrix[m-1][n-1] = 0;\\n                n--;\\n            }\\n            m--;\\n        }\\n\\t\\t// incrementing rows\\n        for(int i = 0; i < indices.length;i++){\\n         int irow = indices[i][0]; \\n         for(int j = 0; j < matrix[irow].length; j++){\\n             matrix[irow][j]++;\\n         }\\n        } \\n\\t\\t// incrementing column\\n       for(int i = 0; i < indices.length;i++){\\n         int icol = indices[i][1]; \\n         for(int j = 0; j < matrix.length; j++){\\n             matrix[j][icol]++;\\n         }\\n        }\\n\\t\\t// checking out elements of ans matrix is odd or not\\n        for(int i = 0; i < matrix.length ; i++){\\n            for(int j = 0 ; j < matrix[i].length ; j++){\\n                if( matrix[i][j] % 2 ==1){\\n                  count++;  \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n\\t// Making the ans matrix base\\n        int[][] matrix = new int[m][n];\\n        int count = 0;\\n        while(m>0){\\n            while(n>0){\\n                matrix[m-1][n-1] = 0;\\n                n--;\\n            }\\n            m--;\\n        }\\n\\t\\t// incrementing rows\\n        for(int i = 0; i < indices.length;i++){\\n         int irow = indices[i][0]; \\n         for(int j = 0; j < matrix[irow].length; j++){\\n             matrix[irow][j]++;\\n         }\\n        } \\n\\t\\t// incrementing column\\n       for(int i = 0; i < indices.length;i++){\\n         int icol = indices[i][1]; \\n         for(int j = 0; j < matrix.length; j++){\\n             matrix[j][icol]++;\\n         }\\n        }\\n\\t\\t// checking out elements of ans matrix is odd or not\\n        for(int i = 0; i < matrix.length ; i++){\\n            for(int j = 0 ; j < matrix[i].length ; j++){\\n                if( matrix[i][j] % 2 ==1){\\n                  count++;  \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889031,
                "title": "c-time-o-m-n-indices-length-space-o-m-n-hashmap-explained-0ms-100-faster",
                "content": "**Method:**\\n* we create hashmap to store the number of times a particular row or coulmn appears in indices array\\n* m1 stores for row and m2 for column\\n* now we store the number of rows and columns which appeared odd number of times\\n* final ans = r* n + c* m - 2* r* c\\n\\t* why?\\n\\t* no of elements which will have odd value due to a row appearing odd number of times = r* n\\n\\t\\t* as a row contains n columns hence r* n\\n\\t* no of elements which will have odd value due to a column appearing odd number of times = r* n\\n\\t\\t* as a column contains m row hence c* m\\n\\t* now if a row and column intersected in this process i.e an element got counted in the row and column both then we need to remove that as it got counted twice which is done by -2* r* c\\t\\n\\t* so in order to remove such occurences we do -2* r* c because each time a row and column intersect a value gets counted twice hence the factor of two and if there are r such rows and c such columns then -2* r* c\\n\\t\\t* let\\'s consider a case when we have m=2 n=3 \\n\\t\\t* and the first row and and second column appears odd number of time\\n\\t\\t* then r* n = 3 as all the first row elements have odd value (0,0),(0,1),(0,2)\\n\\t\\t* c* m = 2 as all the second column element have odd value (0,1),(1,1)\\n\\t\\t* now we just counted the element at index (0,1) twice and thus it will have an even value\\n\\n* **Time Complexity: O(m+n + indices.length())**\\n\\t* as there are two for loops running atmost n and m times and a loop which runs indices.length times\\n* **Space Complexity: O(m+n)**\\n\\t* as we created two hashmap of sizes m and n\\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        unordered_map<int,int>m1;\\n        unordered_map<int,int>m2;\\n        for(int i=0;i<indices.size();i++){\\n            m1[indices[i][0]]++;\\n            m2[indices[i][1]]++;\\n        }\\n        int r=0;\\n        int c=0;\\n        for(int i=0;i<m;i++){\\n            if(m1[i]%2==1){\\n                r++;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(m2[i]%2==1){\\n                c++;\\n            }\\n        }\\n        return r*n + c*m - 2*r*c;\\n    }\\n};\\n```\\n\\n*Happy Coding :-)*",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        unordered_map<int,int>m1;\\n        unordered_map<int,int>m2;\\n        for(int i=0;i<indices.size();i++){\\n            m1[indices[i][0]]++;\\n            m2[indices[i][1]]++;\\n        }\\n        int r=0;\\n        int c=0;\\n        for(int i=0;i<m;i++){\\n            if(m1[i]%2==1){\\n                r++;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(m2[i]%2==1){\\n                c++;\\n            }\\n        }\\n        return r*n + c*m - 2*r*c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847741,
                "title": "c-o-n-m-space-o-n-m-time",
                "content": "With little optimizations we can get O(n + m) time as well.\\n```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        vector<int> row(m, 0), col(n, 0);\\n        for (auto& index : indices) {\\n            row[index[0]]++;\\n            col[index[1]]++;\\n        }\\n        int odd = 0;\\n        for (auto& r : row) {\\n            for (auto& c : col) {\\n                if ((r + c)%2) odd ++;\\n            }\\n        }\\n        return odd;\\n    }\\n};\\n```\\nIf it helped, do upvote!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        vector<int> row(m, 0), col(n, 0);\\n        for (auto& index : indices) {\\n            row[index[0]]++;\\n            col[index[1]]++;\\n        }\\n        int odd = 0;\\n        for (auto& r : row) {\\n            for (auto& c : col) {\\n                if ((r + c)%2) odd ++;\\n            }\\n        }\\n        return odd;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775543,
                "title": "c-easy-solution-8ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        vector <int> rm(m);\\n        vector <int> cn(n);\\n        \\n\\t\\t//initialize all with zero.\\n        for( int i=0; i<m; i++ ) rm[i] = 0;\\n        for( int i=0; i<n; i++ ) cn[i] = 0;\\n        \\n\\t\\t//increase if there is a value present\\n        for( int i=0; i<indices.size(); i++ ) {\\n            rm[ indices[i][0] ]++;\\n            cn[ indices[i][1] ]++;\\n        }\\n        \\n\\t\\t//finally count the odd-number in the matrix.\\n        int count = 0;\\n        for( int i=0; i<rm.size(); i++ ) {\\n            vector<int> temp(n);\\n            for( int v=0; v<n; v++ ) {\\n                if( (rm[i]+cn[v]) %2 != 0 ) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\\n        vector <int> rm(m);\\n        vector <int> cn(n);\\n        \\n\\t\\t//initialize all with zero.\\n        for( int i=0; i<m; i++ ) rm[i] = 0;\\n        for( int i=0; i<n; i++ ) cn[i] = 0;\\n        \\n\\t\\t//increase if there is a value present\\n        for( int i=0; i<indices.size(); i++ ) {\\n            rm[ indices[i][0] ]++;\\n            cn[ indices[i][1] ]++;\\n        }\\n        \\n\\t\\t//finally count the odd-number in the matrix.\\n        int count = 0;\\n        for( int i=0; i<rm.size(); i++ ) {\\n            vector<int> temp(n);\\n            for( int v=0; v<n; v++ ) {\\n                if( (rm[i]+cn[v]) %2 != 0 ) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1754924,
                "title": "simple-java-solution-81-faster",
                "content": "//SOLUTION\\n\\n\\n\\n      int[][] ans = new int[m][n];\\n        \\n   for(int i=0; i<indices.length; i++){\\n       for(int j =0; j<n; j++){\\n           ans[indices[i][0]][j]++;\\n       }\\n       for(int j=0; j<m; j++){\\n           ans[j][indices[i][1]]++;\\n       }\\n   }\\n        int count=0;\\n        \\n        for(int i =0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(ans[i][j]%2!=0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;",
                "solutionTags": [
                    "Java"
                ],
                "code": "//SOLUTION\\n\\n\\n\\n      int[][] ans = new int[m][n];\\n        \\n   for(int i=0; i<indices.length; i++){\\n       for(int j =0; j<n; j++){\\n           ans[indices[i][0]][j]++;\\n       }\\n       for(int j=0; j<m; j++){\\n           ans[j][indices[i][1]]++;\\n       }\\n   }\\n        int count=0;\\n        \\n        for(int i =0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(ans[i][j]%2!=0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;",
                "codeTag": "Unknown"
            },
            {
                "id": 1716012,
                "title": "javascript-solution",
                "content": "```var oddCells = function(m, n, indices) {\\n      let matrix = [];\\n  let output = 0;\\n  for (let i = 0; i < m; i++) {\\n    matrix.push(Array(n).fill(0));\\n  }\\n\\n  for (let [x, y] of indices) {\\n    // INCREMENT ROW\\n\\n    for (let i = 0; i < n; i++) {\\n      matrix[x][i]++;\\n    }\\n    // INCREMENT COULMN\\n    for (let i = 0; i < m; i++) {\\n      matrix[i][y]++;\\n    }\\n  }\\n  for (let i = 0; i < matrix.length; i++) {\\n    matrix[i].forEach((num) => {\\n      if (num % 2 !== 0) {\\n        output ++\\n      }\\n    });\\n  }\\n  return output;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```var oddCells = function(m, n, indices) {\\n      let matrix = [];\\n  let output = 0;\\n  for (let i = 0; i < m; i++) {\\n    matrix.push(Array(n).fill(0));\\n  }\\n\\n  for (let [x, y] of indices) {\\n    // INCREMENT ROW\\n\\n    for (let i = 0; i < n; i++) {\\n      matrix[x][i]++;\\n    }\\n    // INCREMENT COULMN\\n    for (let i = 0; i < m; i++) {\\n      matrix[i][y]++;\\n    }\\n  }\\n  for (let i = 0; i < matrix.length; i++) {\\n    matrix[i].forEach((num) => {\\n      if (num % 2 !== 0) {\\n        output ++\\n      }\\n    });\\n  }\\n  return output;\\n};",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1566926,
                "content": [
                    {
                        "username": "uknowwho23",
                        "content": "Can someone explain me the question in detail.\\nWhat is the indices array and how did he get that increment. I am not able to comprehend the question"
                    },
                    {
                        "username": "subham913dces3",
                        "content": "[@spardha-hash](/spardha-hash) thanks a lot sir/ma\\'am."
                    },
                    {
                        "username": "spardha-hash",
                        "content": "[@YouKnowWho](/uknowwho23)\\nFirst take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Where can I find an understandable translation of this question in English?\\n\\n1. Given n and m which are the dimensions of a matrix initialized by zeros.\\nOK.\\n\\n2. and given an array indices where indices[i] = [ri, ci]. \\nWhat?\\n\\n3. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by \\nYou lost me on what I extracted as step 2. \\n\\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\\n\\nSomeone please translate this into something understandable. \\n"
                    },
                    {
                        "username": "kshraj",
                        "content": "**problem statement is not easy to understand.**\\n\\nCan anyone provide an explanation."
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "I am at beginner level too, but many of coders are here finding it hard to understand this poorly explained question so lets breakdown the question together. \\n1. Firstly we are given a imaginary matrix which is initialized to 0 lets consider it as nums.\\n2. Then we are given a 2D array indices which will give us a list of locations we have to change, suppose the indices[i] is [0,1] so in our imaginary matrix nums we will increment each cell that is on \\'row 0 by 1\\' then every cell on \\'column 1 by 1\\'.\\n3. For all such given indices[i] we will do increment and we will get our final matrix nums.\\n4. Run a loop in the matrix nums and if an element nums[i][j] is odd then count++ and return that count.\\n"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "thank for explanation"
                    },
                    {
                        "username": "pandamaster392",
                        "content": "*how did you find that*"
                    },
                    {
                        "username": "shoshinsha_coder",
                        "content": "I feel like this should be a Medium question this involves a lot of memory, array construction / operations etc. "
                    },
                    {
                        "username": "rkhemka",
                        "content": "Can some one explain me in the example posted below the question \\nHow did first increment occurs\\nEx: From the question\\nInput: n = 2, m = 3, indices = [[0,1],[1,1]]\\nOutput: 6\\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\\nAfter applying first increment it becomes [[1,2,1],[0,1,0]]. <-- how 1,2,1 for first row and 0,1,0 for second row??\\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\\n\\n\\nIs there a formula to calculate first increment??"
                    },
                    {
                        "username": "vk970097",
                        "content": "[@spardha-hash](/spardha-hash) \\n\\ninitial matrix = [[0,0,0],[0,0,0]] \\n\\nFirst we take indices = [0,1] (and according to first indices we do increment in 0 Row and 1st column)\\nafter doing changes on 0 row initial matrix look like - [[1,1,1],[0,0,0]]\\nafter doing changes on 1st column initial matrix look like - [[1,2,1],[0,1,0]]\\n\\nThen we take another indices = [1,1] \\nafter doing changes on 1st row initial matrix look like - [[1,2,1],[1,2,1]]\\nafter doing changes on 1st column initial matrix look like - [[1,3,1],[1,3,1]]\\n\\nso in initial array all element are odd so answer is 6.\\n"
                    },
                    {
                        "username": "spardha-hash",
                        "content": "First take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "mike-meng",
                        "content": "hh......................"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "Worst question explanation\\n"
                    },
                    {
                        "username": "ChNihar",
                        "content": "I am able to solve this question in brute force, but for optimized solution I got he approach right but not able to understand this equation odd_row * n + odd_col * m \\u2013 2 * odd_row * odd_col . Someone please clarify my doubt."
                    },
                    {
                        "username": "District_12",
                        "content": "Do not look at the images. Second matrix is not an indices matrix it's updated first matrix after first iteration using `unknown` indices matrix."
                    }
                ]
            },
            {
                "id": 1568297,
                "content": [
                    {
                        "username": "uknowwho23",
                        "content": "Can someone explain me the question in detail.\\nWhat is the indices array and how did he get that increment. I am not able to comprehend the question"
                    },
                    {
                        "username": "subham913dces3",
                        "content": "[@spardha-hash](/spardha-hash) thanks a lot sir/ma\\'am."
                    },
                    {
                        "username": "spardha-hash",
                        "content": "[@YouKnowWho](/uknowwho23)\\nFirst take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Where can I find an understandable translation of this question in English?\\n\\n1. Given n and m which are the dimensions of a matrix initialized by zeros.\\nOK.\\n\\n2. and given an array indices where indices[i] = [ri, ci]. \\nWhat?\\n\\n3. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by \\nYou lost me on what I extracted as step 2. \\n\\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\\n\\nSomeone please translate this into something understandable. \\n"
                    },
                    {
                        "username": "kshraj",
                        "content": "**problem statement is not easy to understand.**\\n\\nCan anyone provide an explanation."
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "I am at beginner level too, but many of coders are here finding it hard to understand this poorly explained question so lets breakdown the question together. \\n1. Firstly we are given a imaginary matrix which is initialized to 0 lets consider it as nums.\\n2. Then we are given a 2D array indices which will give us a list of locations we have to change, suppose the indices[i] is [0,1] so in our imaginary matrix nums we will increment each cell that is on \\'row 0 by 1\\' then every cell on \\'column 1 by 1\\'.\\n3. For all such given indices[i] we will do increment and we will get our final matrix nums.\\n4. Run a loop in the matrix nums and if an element nums[i][j] is odd then count++ and return that count.\\n"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "thank for explanation"
                    },
                    {
                        "username": "pandamaster392",
                        "content": "*how did you find that*"
                    },
                    {
                        "username": "shoshinsha_coder",
                        "content": "I feel like this should be a Medium question this involves a lot of memory, array construction / operations etc. "
                    },
                    {
                        "username": "rkhemka",
                        "content": "Can some one explain me in the example posted below the question \\nHow did first increment occurs\\nEx: From the question\\nInput: n = 2, m = 3, indices = [[0,1],[1,1]]\\nOutput: 6\\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\\nAfter applying first increment it becomes [[1,2,1],[0,1,0]]. <-- how 1,2,1 for first row and 0,1,0 for second row??\\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\\n\\n\\nIs there a formula to calculate first increment??"
                    },
                    {
                        "username": "vk970097",
                        "content": "[@spardha-hash](/spardha-hash) \\n\\ninitial matrix = [[0,0,0],[0,0,0]] \\n\\nFirst we take indices = [0,1] (and according to first indices we do increment in 0 Row and 1st column)\\nafter doing changes on 0 row initial matrix look like - [[1,1,1],[0,0,0]]\\nafter doing changes on 1st column initial matrix look like - [[1,2,1],[0,1,0]]\\n\\nThen we take another indices = [1,1] \\nafter doing changes on 1st row initial matrix look like - [[1,2,1],[1,2,1]]\\nafter doing changes on 1st column initial matrix look like - [[1,3,1],[1,3,1]]\\n\\nso in initial array all element are odd so answer is 6.\\n"
                    },
                    {
                        "username": "spardha-hash",
                        "content": "First take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "mike-meng",
                        "content": "hh......................"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "Worst question explanation\\n"
                    },
                    {
                        "username": "ChNihar",
                        "content": "I am able to solve this question in brute force, but for optimized solution I got he approach right but not able to understand this equation odd_row * n + odd_col * m \\u2013 2 * odd_row * odd_col . Someone please clarify my doubt."
                    },
                    {
                        "username": "District_12",
                        "content": "Do not look at the images. Second matrix is not an indices matrix it's updated first matrix after first iteration using `unknown` indices matrix."
                    }
                ]
            },
            {
                "id": 1567479,
                "content": [
                    {
                        "username": "uknowwho23",
                        "content": "Can someone explain me the question in detail.\\nWhat is the indices array and how did he get that increment. I am not able to comprehend the question"
                    },
                    {
                        "username": "subham913dces3",
                        "content": "[@spardha-hash](/spardha-hash) thanks a lot sir/ma\\'am."
                    },
                    {
                        "username": "spardha-hash",
                        "content": "[@YouKnowWho](/uknowwho23)\\nFirst take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Where can I find an understandable translation of this question in English?\\n\\n1. Given n and m which are the dimensions of a matrix initialized by zeros.\\nOK.\\n\\n2. and given an array indices where indices[i] = [ri, ci]. \\nWhat?\\n\\n3. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by \\nYou lost me on what I extracted as step 2. \\n\\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\\n\\nSomeone please translate this into something understandable. \\n"
                    },
                    {
                        "username": "kshraj",
                        "content": "**problem statement is not easy to understand.**\\n\\nCan anyone provide an explanation."
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "I am at beginner level too, but many of coders are here finding it hard to understand this poorly explained question so lets breakdown the question together. \\n1. Firstly we are given a imaginary matrix which is initialized to 0 lets consider it as nums.\\n2. Then we are given a 2D array indices which will give us a list of locations we have to change, suppose the indices[i] is [0,1] so in our imaginary matrix nums we will increment each cell that is on \\'row 0 by 1\\' then every cell on \\'column 1 by 1\\'.\\n3. For all such given indices[i] we will do increment and we will get our final matrix nums.\\n4. Run a loop in the matrix nums and if an element nums[i][j] is odd then count++ and return that count.\\n"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "thank for explanation"
                    },
                    {
                        "username": "pandamaster392",
                        "content": "*how did you find that*"
                    },
                    {
                        "username": "shoshinsha_coder",
                        "content": "I feel like this should be a Medium question this involves a lot of memory, array construction / operations etc. "
                    },
                    {
                        "username": "rkhemka",
                        "content": "Can some one explain me in the example posted below the question \\nHow did first increment occurs\\nEx: From the question\\nInput: n = 2, m = 3, indices = [[0,1],[1,1]]\\nOutput: 6\\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\\nAfter applying first increment it becomes [[1,2,1],[0,1,0]]. <-- how 1,2,1 for first row and 0,1,0 for second row??\\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\\n\\n\\nIs there a formula to calculate first increment??"
                    },
                    {
                        "username": "vk970097",
                        "content": "[@spardha-hash](/spardha-hash) \\n\\ninitial matrix = [[0,0,0],[0,0,0]] \\n\\nFirst we take indices = [0,1] (and according to first indices we do increment in 0 Row and 1st column)\\nafter doing changes on 0 row initial matrix look like - [[1,1,1],[0,0,0]]\\nafter doing changes on 1st column initial matrix look like - [[1,2,1],[0,1,0]]\\n\\nThen we take another indices = [1,1] \\nafter doing changes on 1st row initial matrix look like - [[1,2,1],[1,2,1]]\\nafter doing changes on 1st column initial matrix look like - [[1,3,1],[1,3,1]]\\n\\nso in initial array all element are odd so answer is 6.\\n"
                    },
                    {
                        "username": "spardha-hash",
                        "content": "First take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "mike-meng",
                        "content": "hh......................"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "Worst question explanation\\n"
                    },
                    {
                        "username": "ChNihar",
                        "content": "I am able to solve this question in brute force, but for optimized solution I got he approach right but not able to understand this equation odd_row * n + odd_col * m \\u2013 2 * odd_row * odd_col . Someone please clarify my doubt."
                    },
                    {
                        "username": "District_12",
                        "content": "Do not look at the images. Second matrix is not an indices matrix it's updated first matrix after first iteration using `unknown` indices matrix."
                    }
                ]
            },
            {
                "id": 1978799,
                "content": [
                    {
                        "username": "uknowwho23",
                        "content": "Can someone explain me the question in detail.\\nWhat is the indices array and how did he get that increment. I am not able to comprehend the question"
                    },
                    {
                        "username": "subham913dces3",
                        "content": "[@spardha-hash](/spardha-hash) thanks a lot sir/ma\\'am."
                    },
                    {
                        "username": "spardha-hash",
                        "content": "[@YouKnowWho](/uknowwho23)\\nFirst take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Where can I find an understandable translation of this question in English?\\n\\n1. Given n and m which are the dimensions of a matrix initialized by zeros.\\nOK.\\n\\n2. and given an array indices where indices[i] = [ri, ci]. \\nWhat?\\n\\n3. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by \\nYou lost me on what I extracted as step 2. \\n\\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\\n\\nSomeone please translate this into something understandable. \\n"
                    },
                    {
                        "username": "kshraj",
                        "content": "**problem statement is not easy to understand.**\\n\\nCan anyone provide an explanation."
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "I am at beginner level too, but many of coders are here finding it hard to understand this poorly explained question so lets breakdown the question together. \\n1. Firstly we are given a imaginary matrix which is initialized to 0 lets consider it as nums.\\n2. Then we are given a 2D array indices which will give us a list of locations we have to change, suppose the indices[i] is [0,1] so in our imaginary matrix nums we will increment each cell that is on \\'row 0 by 1\\' then every cell on \\'column 1 by 1\\'.\\n3. For all such given indices[i] we will do increment and we will get our final matrix nums.\\n4. Run a loop in the matrix nums and if an element nums[i][j] is odd then count++ and return that count.\\n"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "thank for explanation"
                    },
                    {
                        "username": "pandamaster392",
                        "content": "*how did you find that*"
                    },
                    {
                        "username": "shoshinsha_coder",
                        "content": "I feel like this should be a Medium question this involves a lot of memory, array construction / operations etc. "
                    },
                    {
                        "username": "rkhemka",
                        "content": "Can some one explain me in the example posted below the question \\nHow did first increment occurs\\nEx: From the question\\nInput: n = 2, m = 3, indices = [[0,1],[1,1]]\\nOutput: 6\\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\\nAfter applying first increment it becomes [[1,2,1],[0,1,0]]. <-- how 1,2,1 for first row and 0,1,0 for second row??\\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\\n\\n\\nIs there a formula to calculate first increment??"
                    },
                    {
                        "username": "vk970097",
                        "content": "[@spardha-hash](/spardha-hash) \\n\\ninitial matrix = [[0,0,0],[0,0,0]] \\n\\nFirst we take indices = [0,1] (and according to first indices we do increment in 0 Row and 1st column)\\nafter doing changes on 0 row initial matrix look like - [[1,1,1],[0,0,0]]\\nafter doing changes on 1st column initial matrix look like - [[1,2,1],[0,1,0]]\\n\\nThen we take another indices = [1,1] \\nafter doing changes on 1st row initial matrix look like - [[1,2,1],[1,2,1]]\\nafter doing changes on 1st column initial matrix look like - [[1,3,1],[1,3,1]]\\n\\nso in initial array all element are odd so answer is 6.\\n"
                    },
                    {
                        "username": "spardha-hash",
                        "content": "First take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "mike-meng",
                        "content": "hh......................"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "Worst question explanation\\n"
                    },
                    {
                        "username": "ChNihar",
                        "content": "I am able to solve this question in brute force, but for optimized solution I got he approach right but not able to understand this equation odd_row * n + odd_col * m \\u2013 2 * odd_row * odd_col . Someone please clarify my doubt."
                    },
                    {
                        "username": "District_12",
                        "content": "Do not look at the images. Second matrix is not an indices matrix it's updated first matrix after first iteration using `unknown` indices matrix."
                    }
                ]
            },
            {
                "id": 1793663,
                "content": [
                    {
                        "username": "uknowwho23",
                        "content": "Can someone explain me the question in detail.\\nWhat is the indices array and how did he get that increment. I am not able to comprehend the question"
                    },
                    {
                        "username": "subham913dces3",
                        "content": "[@spardha-hash](/spardha-hash) thanks a lot sir/ma\\'am."
                    },
                    {
                        "username": "spardha-hash",
                        "content": "[@YouKnowWho](/uknowwho23)\\nFirst take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Where can I find an understandable translation of this question in English?\\n\\n1. Given n and m which are the dimensions of a matrix initialized by zeros.\\nOK.\\n\\n2. and given an array indices where indices[i] = [ri, ci]. \\nWhat?\\n\\n3. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by \\nYou lost me on what I extracted as step 2. \\n\\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\\n\\nSomeone please translate this into something understandable. \\n"
                    },
                    {
                        "username": "kshraj",
                        "content": "**problem statement is not easy to understand.**\\n\\nCan anyone provide an explanation."
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "I am at beginner level too, but many of coders are here finding it hard to understand this poorly explained question so lets breakdown the question together. \\n1. Firstly we are given a imaginary matrix which is initialized to 0 lets consider it as nums.\\n2. Then we are given a 2D array indices which will give us a list of locations we have to change, suppose the indices[i] is [0,1] so in our imaginary matrix nums we will increment each cell that is on \\'row 0 by 1\\' then every cell on \\'column 1 by 1\\'.\\n3. For all such given indices[i] we will do increment and we will get our final matrix nums.\\n4. Run a loop in the matrix nums and if an element nums[i][j] is odd then count++ and return that count.\\n"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "thank for explanation"
                    },
                    {
                        "username": "pandamaster392",
                        "content": "*how did you find that*"
                    },
                    {
                        "username": "shoshinsha_coder",
                        "content": "I feel like this should be a Medium question this involves a lot of memory, array construction / operations etc. "
                    },
                    {
                        "username": "rkhemka",
                        "content": "Can some one explain me in the example posted below the question \\nHow did first increment occurs\\nEx: From the question\\nInput: n = 2, m = 3, indices = [[0,1],[1,1]]\\nOutput: 6\\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\\nAfter applying first increment it becomes [[1,2,1],[0,1,0]]. <-- how 1,2,1 for first row and 0,1,0 for second row??\\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\\n\\n\\nIs there a formula to calculate first increment??"
                    },
                    {
                        "username": "vk970097",
                        "content": "[@spardha-hash](/spardha-hash) \\n\\ninitial matrix = [[0,0,0],[0,0,0]] \\n\\nFirst we take indices = [0,1] (and according to first indices we do increment in 0 Row and 1st column)\\nafter doing changes on 0 row initial matrix look like - [[1,1,1],[0,0,0]]\\nafter doing changes on 1st column initial matrix look like - [[1,2,1],[0,1,0]]\\n\\nThen we take another indices = [1,1] \\nafter doing changes on 1st row initial matrix look like - [[1,2,1],[1,2,1]]\\nafter doing changes on 1st column initial matrix look like - [[1,3,1],[1,3,1]]\\n\\nso in initial array all element are odd so answer is 6.\\n"
                    },
                    {
                        "username": "spardha-hash",
                        "content": "First take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "mike-meng",
                        "content": "hh......................"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "Worst question explanation\\n"
                    },
                    {
                        "username": "ChNihar",
                        "content": "I am able to solve this question in brute force, but for optimized solution I got he approach right but not able to understand this equation odd_row * n + odd_col * m \\u2013 2 * odd_row * odd_col . Someone please clarify my doubt."
                    },
                    {
                        "username": "District_12",
                        "content": "Do not look at the images. Second matrix is not an indices matrix it's updated first matrix after first iteration using `unknown` indices matrix."
                    }
                ]
            },
            {
                "id": 1568244,
                "content": [
                    {
                        "username": "uknowwho23",
                        "content": "Can someone explain me the question in detail.\\nWhat is the indices array and how did he get that increment. I am not able to comprehend the question"
                    },
                    {
                        "username": "subham913dces3",
                        "content": "[@spardha-hash](/spardha-hash) thanks a lot sir/ma\\'am."
                    },
                    {
                        "username": "spardha-hash",
                        "content": "[@YouKnowWho](/uknowwho23)\\nFirst take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Where can I find an understandable translation of this question in English?\\n\\n1. Given n and m which are the dimensions of a matrix initialized by zeros.\\nOK.\\n\\n2. and given an array indices where indices[i] = [ri, ci]. \\nWhat?\\n\\n3. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by \\nYou lost me on what I extracted as step 2. \\n\\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\\n\\nSomeone please translate this into something understandable. \\n"
                    },
                    {
                        "username": "kshraj",
                        "content": "**problem statement is not easy to understand.**\\n\\nCan anyone provide an explanation."
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "I am at beginner level too, but many of coders are here finding it hard to understand this poorly explained question so lets breakdown the question together. \\n1. Firstly we are given a imaginary matrix which is initialized to 0 lets consider it as nums.\\n2. Then we are given a 2D array indices which will give us a list of locations we have to change, suppose the indices[i] is [0,1] so in our imaginary matrix nums we will increment each cell that is on \\'row 0 by 1\\' then every cell on \\'column 1 by 1\\'.\\n3. For all such given indices[i] we will do increment and we will get our final matrix nums.\\n4. Run a loop in the matrix nums and if an element nums[i][j] is odd then count++ and return that count.\\n"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "thank for explanation"
                    },
                    {
                        "username": "pandamaster392",
                        "content": "*how did you find that*"
                    },
                    {
                        "username": "shoshinsha_coder",
                        "content": "I feel like this should be a Medium question this involves a lot of memory, array construction / operations etc. "
                    },
                    {
                        "username": "rkhemka",
                        "content": "Can some one explain me in the example posted below the question \\nHow did first increment occurs\\nEx: From the question\\nInput: n = 2, m = 3, indices = [[0,1],[1,1]]\\nOutput: 6\\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\\nAfter applying first increment it becomes [[1,2,1],[0,1,0]]. <-- how 1,2,1 for first row and 0,1,0 for second row??\\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\\n\\n\\nIs there a formula to calculate first increment??"
                    },
                    {
                        "username": "vk970097",
                        "content": "[@spardha-hash](/spardha-hash) \\n\\ninitial matrix = [[0,0,0],[0,0,0]] \\n\\nFirst we take indices = [0,1] (and according to first indices we do increment in 0 Row and 1st column)\\nafter doing changes on 0 row initial matrix look like - [[1,1,1],[0,0,0]]\\nafter doing changes on 1st column initial matrix look like - [[1,2,1],[0,1,0]]\\n\\nThen we take another indices = [1,1] \\nafter doing changes on 1st row initial matrix look like - [[1,2,1],[1,2,1]]\\nafter doing changes on 1st column initial matrix look like - [[1,3,1],[1,3,1]]\\n\\nso in initial array all element are odd so answer is 6.\\n"
                    },
                    {
                        "username": "spardha-hash",
                        "content": "First take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "mike-meng",
                        "content": "hh......................"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "Worst question explanation\\n"
                    },
                    {
                        "username": "ChNihar",
                        "content": "I am able to solve this question in brute force, but for optimized solution I got he approach right but not able to understand this equation odd_row * n + odd_col * m \\u2013 2 * odd_row * odd_col . Someone please clarify my doubt."
                    },
                    {
                        "username": "District_12",
                        "content": "Do not look at the images. Second matrix is not an indices matrix it's updated first matrix after first iteration using `unknown` indices matrix."
                    }
                ]
            },
            {
                "id": 1566587,
                "content": [
                    {
                        "username": "uknowwho23",
                        "content": "Can someone explain me the question in detail.\\nWhat is the indices array and how did he get that increment. I am not able to comprehend the question"
                    },
                    {
                        "username": "subham913dces3",
                        "content": "[@spardha-hash](/spardha-hash) thanks a lot sir/ma\\'am."
                    },
                    {
                        "username": "spardha-hash",
                        "content": "[@YouKnowWho](/uknowwho23)\\nFirst take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Where can I find an understandable translation of this question in English?\\n\\n1. Given n and m which are the dimensions of a matrix initialized by zeros.\\nOK.\\n\\n2. and given an array indices where indices[i] = [ri, ci]. \\nWhat?\\n\\n3. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by \\nYou lost me on what I extracted as step 2. \\n\\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\\n\\nSomeone please translate this into something understandable. \\n"
                    },
                    {
                        "username": "kshraj",
                        "content": "**problem statement is not easy to understand.**\\n\\nCan anyone provide an explanation."
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "I am at beginner level too, but many of coders are here finding it hard to understand this poorly explained question so lets breakdown the question together. \\n1. Firstly we are given a imaginary matrix which is initialized to 0 lets consider it as nums.\\n2. Then we are given a 2D array indices which will give us a list of locations we have to change, suppose the indices[i] is [0,1] so in our imaginary matrix nums we will increment each cell that is on \\'row 0 by 1\\' then every cell on \\'column 1 by 1\\'.\\n3. For all such given indices[i] we will do increment and we will get our final matrix nums.\\n4. Run a loop in the matrix nums and if an element nums[i][j] is odd then count++ and return that count.\\n"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "thank for explanation"
                    },
                    {
                        "username": "pandamaster392",
                        "content": "*how did you find that*"
                    },
                    {
                        "username": "shoshinsha_coder",
                        "content": "I feel like this should be a Medium question this involves a lot of memory, array construction / operations etc. "
                    },
                    {
                        "username": "rkhemka",
                        "content": "Can some one explain me in the example posted below the question \\nHow did first increment occurs\\nEx: From the question\\nInput: n = 2, m = 3, indices = [[0,1],[1,1]]\\nOutput: 6\\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\\nAfter applying first increment it becomes [[1,2,1],[0,1,0]]. <-- how 1,2,1 for first row and 0,1,0 for second row??\\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\\n\\n\\nIs there a formula to calculate first increment??"
                    },
                    {
                        "username": "vk970097",
                        "content": "[@spardha-hash](/spardha-hash) \\n\\ninitial matrix = [[0,0,0],[0,0,0]] \\n\\nFirst we take indices = [0,1] (and according to first indices we do increment in 0 Row and 1st column)\\nafter doing changes on 0 row initial matrix look like - [[1,1,1],[0,0,0]]\\nafter doing changes on 1st column initial matrix look like - [[1,2,1],[0,1,0]]\\n\\nThen we take another indices = [1,1] \\nafter doing changes on 1st row initial matrix look like - [[1,2,1],[1,2,1]]\\nafter doing changes on 1st column initial matrix look like - [[1,3,1],[1,3,1]]\\n\\nso in initial array all element are odd so answer is 6.\\n"
                    },
                    {
                        "username": "spardha-hash",
                        "content": "First take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "mike-meng",
                        "content": "hh......................"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "Worst question explanation\\n"
                    },
                    {
                        "username": "ChNihar",
                        "content": "I am able to solve this question in brute force, but for optimized solution I got he approach right but not able to understand this equation odd_row * n + odd_col * m \\u2013 2 * odd_row * odd_col . Someone please clarify my doubt."
                    },
                    {
                        "username": "District_12",
                        "content": "Do not look at the images. Second matrix is not an indices matrix it's updated first matrix after first iteration using `unknown` indices matrix."
                    }
                ]
            },
            {
                "id": 1969207,
                "content": [
                    {
                        "username": "uknowwho23",
                        "content": "Can someone explain me the question in detail.\\nWhat is the indices array and how did he get that increment. I am not able to comprehend the question"
                    },
                    {
                        "username": "subham913dces3",
                        "content": "[@spardha-hash](/spardha-hash) thanks a lot sir/ma\\'am."
                    },
                    {
                        "username": "spardha-hash",
                        "content": "[@YouKnowWho](/uknowwho23)\\nFirst take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Where can I find an understandable translation of this question in English?\\n\\n1. Given n and m which are the dimensions of a matrix initialized by zeros.\\nOK.\\n\\n2. and given an array indices where indices[i] = [ri, ci]. \\nWhat?\\n\\n3. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by \\nYou lost me on what I extracted as step 2. \\n\\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\\n\\nSomeone please translate this into something understandable. \\n"
                    },
                    {
                        "username": "kshraj",
                        "content": "**problem statement is not easy to understand.**\\n\\nCan anyone provide an explanation."
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "I am at beginner level too, but many of coders are here finding it hard to understand this poorly explained question so lets breakdown the question together. \\n1. Firstly we are given a imaginary matrix which is initialized to 0 lets consider it as nums.\\n2. Then we are given a 2D array indices which will give us a list of locations we have to change, suppose the indices[i] is [0,1] so in our imaginary matrix nums we will increment each cell that is on \\'row 0 by 1\\' then every cell on \\'column 1 by 1\\'.\\n3. For all such given indices[i] we will do increment and we will get our final matrix nums.\\n4. Run a loop in the matrix nums and if an element nums[i][j] is odd then count++ and return that count.\\n"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "thank for explanation"
                    },
                    {
                        "username": "pandamaster392",
                        "content": "*how did you find that*"
                    },
                    {
                        "username": "shoshinsha_coder",
                        "content": "I feel like this should be a Medium question this involves a lot of memory, array construction / operations etc. "
                    },
                    {
                        "username": "rkhemka",
                        "content": "Can some one explain me in the example posted below the question \\nHow did first increment occurs\\nEx: From the question\\nInput: n = 2, m = 3, indices = [[0,1],[1,1]]\\nOutput: 6\\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\\nAfter applying first increment it becomes [[1,2,1],[0,1,0]]. <-- how 1,2,1 for first row and 0,1,0 for second row??\\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\\n\\n\\nIs there a formula to calculate first increment??"
                    },
                    {
                        "username": "vk970097",
                        "content": "[@spardha-hash](/spardha-hash) \\n\\ninitial matrix = [[0,0,0],[0,0,0]] \\n\\nFirst we take indices = [0,1] (and according to first indices we do increment in 0 Row and 1st column)\\nafter doing changes on 0 row initial matrix look like - [[1,1,1],[0,0,0]]\\nafter doing changes on 1st column initial matrix look like - [[1,2,1],[0,1,0]]\\n\\nThen we take another indices = [1,1] \\nafter doing changes on 1st row initial matrix look like - [[1,2,1],[1,2,1]]\\nafter doing changes on 1st column initial matrix look like - [[1,3,1],[1,3,1]]\\n\\nso in initial array all element are odd so answer is 6.\\n"
                    },
                    {
                        "username": "spardha-hash",
                        "content": "First take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "mike-meng",
                        "content": "hh......................"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "Worst question explanation\\n"
                    },
                    {
                        "username": "ChNihar",
                        "content": "I am able to solve this question in brute force, but for optimized solution I got he approach right but not able to understand this equation odd_row * n + odd_col * m \\u2013 2 * odd_row * odd_col . Someone please clarify my doubt."
                    },
                    {
                        "username": "District_12",
                        "content": "Do not look at the images. Second matrix is not an indices matrix it's updated first matrix after first iteration using `unknown` indices matrix."
                    }
                ]
            },
            {
                "id": 2060669,
                "content": [
                    {
                        "username": "uknowwho23",
                        "content": "Can someone explain me the question in detail.\\nWhat is the indices array and how did he get that increment. I am not able to comprehend the question"
                    },
                    {
                        "username": "subham913dces3",
                        "content": "[@spardha-hash](/spardha-hash) thanks a lot sir/ma\\'am."
                    },
                    {
                        "username": "spardha-hash",
                        "content": "[@YouKnowWho](/uknowwho23)\\nFirst take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Where can I find an understandable translation of this question in English?\\n\\n1. Given n and m which are the dimensions of a matrix initialized by zeros.\\nOK.\\n\\n2. and given an array indices where indices[i] = [ri, ci]. \\nWhat?\\n\\n3. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by \\nYou lost me on what I extracted as step 2. \\n\\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\\n\\nSomeone please translate this into something understandable. \\n"
                    },
                    {
                        "username": "kshraj",
                        "content": "**problem statement is not easy to understand.**\\n\\nCan anyone provide an explanation."
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "I am at beginner level too, but many of coders are here finding it hard to understand this poorly explained question so lets breakdown the question together. \\n1. Firstly we are given a imaginary matrix which is initialized to 0 lets consider it as nums.\\n2. Then we are given a 2D array indices which will give us a list of locations we have to change, suppose the indices[i] is [0,1] so in our imaginary matrix nums we will increment each cell that is on \\'row 0 by 1\\' then every cell on \\'column 1 by 1\\'.\\n3. For all such given indices[i] we will do increment and we will get our final matrix nums.\\n4. Run a loop in the matrix nums and if an element nums[i][j] is odd then count++ and return that count.\\n"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "thank for explanation"
                    },
                    {
                        "username": "pandamaster392",
                        "content": "*how did you find that*"
                    },
                    {
                        "username": "shoshinsha_coder",
                        "content": "I feel like this should be a Medium question this involves a lot of memory, array construction / operations etc. "
                    },
                    {
                        "username": "rkhemka",
                        "content": "Can some one explain me in the example posted below the question \\nHow did first increment occurs\\nEx: From the question\\nInput: n = 2, m = 3, indices = [[0,1],[1,1]]\\nOutput: 6\\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\\nAfter applying first increment it becomes [[1,2,1],[0,1,0]]. <-- how 1,2,1 for first row and 0,1,0 for second row??\\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\\n\\n\\nIs there a formula to calculate first increment??"
                    },
                    {
                        "username": "vk970097",
                        "content": "[@spardha-hash](/spardha-hash) \\n\\ninitial matrix = [[0,0,0],[0,0,0]] \\n\\nFirst we take indices = [0,1] (and according to first indices we do increment in 0 Row and 1st column)\\nafter doing changes on 0 row initial matrix look like - [[1,1,1],[0,0,0]]\\nafter doing changes on 1st column initial matrix look like - [[1,2,1],[0,1,0]]\\n\\nThen we take another indices = [1,1] \\nafter doing changes on 1st row initial matrix look like - [[1,2,1],[1,2,1]]\\nafter doing changes on 1st column initial matrix look like - [[1,3,1],[1,3,1]]\\n\\nso in initial array all element are odd so answer is 6.\\n"
                    },
                    {
                        "username": "spardha-hash",
                        "content": "First take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "mike-meng",
                        "content": "hh......................"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "Worst question explanation\\n"
                    },
                    {
                        "username": "ChNihar",
                        "content": "I am able to solve this question in brute force, but for optimized solution I got he approach right but not able to understand this equation odd_row * n + odd_col * m \\u2013 2 * odd_row * odd_col . Someone please clarify my doubt."
                    },
                    {
                        "username": "District_12",
                        "content": "Do not look at the images. Second matrix is not an indices matrix it's updated first matrix after first iteration using `unknown` indices matrix."
                    }
                ]
            },
            {
                "id": 2010513,
                "content": [
                    {
                        "username": "uknowwho23",
                        "content": "Can someone explain me the question in detail.\\nWhat is the indices array and how did he get that increment. I am not able to comprehend the question"
                    },
                    {
                        "username": "subham913dces3",
                        "content": "[@spardha-hash](/spardha-hash) thanks a lot sir/ma\\'am."
                    },
                    {
                        "username": "spardha-hash",
                        "content": "[@YouKnowWho](/uknowwho23)\\nFirst take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Where can I find an understandable translation of this question in English?\\n\\n1. Given n and m which are the dimensions of a matrix initialized by zeros.\\nOK.\\n\\n2. and given an array indices where indices[i] = [ri, ci]. \\nWhat?\\n\\n3. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by \\nYou lost me on what I extracted as step 2. \\n\\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\\n\\nSomeone please translate this into something understandable. \\n"
                    },
                    {
                        "username": "kshraj",
                        "content": "**problem statement is not easy to understand.**\\n\\nCan anyone provide an explanation."
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "I am at beginner level too, but many of coders are here finding it hard to understand this poorly explained question so lets breakdown the question together. \\n1. Firstly we are given a imaginary matrix which is initialized to 0 lets consider it as nums.\\n2. Then we are given a 2D array indices which will give us a list of locations we have to change, suppose the indices[i] is [0,1] so in our imaginary matrix nums we will increment each cell that is on \\'row 0 by 1\\' then every cell on \\'column 1 by 1\\'.\\n3. For all such given indices[i] we will do increment and we will get our final matrix nums.\\n4. Run a loop in the matrix nums and if an element nums[i][j] is odd then count++ and return that count.\\n"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "thank for explanation"
                    },
                    {
                        "username": "pandamaster392",
                        "content": "*how did you find that*"
                    },
                    {
                        "username": "shoshinsha_coder",
                        "content": "I feel like this should be a Medium question this involves a lot of memory, array construction / operations etc. "
                    },
                    {
                        "username": "rkhemka",
                        "content": "Can some one explain me in the example posted below the question \\nHow did first increment occurs\\nEx: From the question\\nInput: n = 2, m = 3, indices = [[0,1],[1,1]]\\nOutput: 6\\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\\nAfter applying first increment it becomes [[1,2,1],[0,1,0]]. <-- how 1,2,1 for first row and 0,1,0 for second row??\\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\\n\\n\\nIs there a formula to calculate first increment??"
                    },
                    {
                        "username": "vk970097",
                        "content": "[@spardha-hash](/spardha-hash) \\n\\ninitial matrix = [[0,0,0],[0,0,0]] \\n\\nFirst we take indices = [0,1] (and according to first indices we do increment in 0 Row and 1st column)\\nafter doing changes on 0 row initial matrix look like - [[1,1,1],[0,0,0]]\\nafter doing changes on 1st column initial matrix look like - [[1,2,1],[0,1,0]]\\n\\nThen we take another indices = [1,1] \\nafter doing changes on 1st row initial matrix look like - [[1,2,1],[1,2,1]]\\nafter doing changes on 1st column initial matrix look like - [[1,3,1],[1,3,1]]\\n\\nso in initial array all element are odd so answer is 6.\\n"
                    },
                    {
                        "username": "spardha-hash",
                        "content": "First take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "mike-meng",
                        "content": "hh......................"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "Worst question explanation\\n"
                    },
                    {
                        "username": "ChNihar",
                        "content": "I am able to solve this question in brute force, but for optimized solution I got he approach right but not able to understand this equation odd_row * n + odd_col * m \\u2013 2 * odd_row * odd_col . Someone please clarify my doubt."
                    },
                    {
                        "username": "District_12",
                        "content": "Do not look at the images. Second matrix is not an indices matrix it's updated first matrix after first iteration using `unknown` indices matrix."
                    }
                ]
            },
            {
                "id": 1566926,
                "content": [
                    {
                        "username": "uknowwho23",
                        "content": "Can someone explain me the question in detail.\\nWhat is the indices array and how did he get that increment. I am not able to comprehend the question"
                    },
                    {
                        "username": "subham913dces3",
                        "content": "[@spardha-hash](/spardha-hash) thanks a lot sir/ma\\'am."
                    },
                    {
                        "username": "spardha-hash",
                        "content": "[@YouKnowWho](/uknowwho23)\\nFirst take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Where can I find an understandable translation of this question in English?\\n\\n1. Given n and m which are the dimensions of a matrix initialized by zeros.\\nOK.\\n\\n2. and given an array indices where indices[i] = [ri, ci]. \\nWhat?\\n\\n3. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by \\nYou lost me on what I extracted as step 2. \\n\\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\\n\\nSomeone please translate this into something understandable. \\n"
                    },
                    {
                        "username": "kshraj",
                        "content": "**problem statement is not easy to understand.**\\n\\nCan anyone provide an explanation."
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "I am at beginner level too, but many of coders are here finding it hard to understand this poorly explained question so lets breakdown the question together. \\n1. Firstly we are given a imaginary matrix which is initialized to 0 lets consider it as nums.\\n2. Then we are given a 2D array indices which will give us a list of locations we have to change, suppose the indices[i] is [0,1] so in our imaginary matrix nums we will increment each cell that is on \\'row 0 by 1\\' then every cell on \\'column 1 by 1\\'.\\n3. For all such given indices[i] we will do increment and we will get our final matrix nums.\\n4. Run a loop in the matrix nums and if an element nums[i][j] is odd then count++ and return that count.\\n"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "thank for explanation"
                    },
                    {
                        "username": "pandamaster392",
                        "content": "*how did you find that*"
                    },
                    {
                        "username": "shoshinsha_coder",
                        "content": "I feel like this should be a Medium question this involves a lot of memory, array construction / operations etc. "
                    },
                    {
                        "username": "rkhemka",
                        "content": "Can some one explain me in the example posted below the question \\nHow did first increment occurs\\nEx: From the question\\nInput: n = 2, m = 3, indices = [[0,1],[1,1]]\\nOutput: 6\\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\\nAfter applying first increment it becomes [[1,2,1],[0,1,0]]. <-- how 1,2,1 for first row and 0,1,0 for second row??\\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\\n\\n\\nIs there a formula to calculate first increment??"
                    },
                    {
                        "username": "vk970097",
                        "content": "[@spardha-hash](/spardha-hash) \\n\\ninitial matrix = [[0,0,0],[0,0,0]] \\n\\nFirst we take indices = [0,1] (and according to first indices we do increment in 0 Row and 1st column)\\nafter doing changes on 0 row initial matrix look like - [[1,1,1],[0,0,0]]\\nafter doing changes on 1st column initial matrix look like - [[1,2,1],[0,1,0]]\\n\\nThen we take another indices = [1,1] \\nafter doing changes on 1st row initial matrix look like - [[1,2,1],[1,2,1]]\\nafter doing changes on 1st column initial matrix look like - [[1,3,1],[1,3,1]]\\n\\nso in initial array all element are odd so answer is 6.\\n"
                    },
                    {
                        "username": "spardha-hash",
                        "content": "First take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "mike-meng",
                        "content": "hh......................"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "Worst question explanation\\n"
                    },
                    {
                        "username": "ChNihar",
                        "content": "I am able to solve this question in brute force, but for optimized solution I got he approach right but not able to understand this equation odd_row * n + odd_col * m \\u2013 2 * odd_row * odd_col . Someone please clarify my doubt."
                    },
                    {
                        "username": "District_12",
                        "content": "Do not look at the images. Second matrix is not an indices matrix it's updated first matrix after first iteration using `unknown` indices matrix."
                    }
                ]
            },
            {
                "id": 1568297,
                "content": [
                    {
                        "username": "uknowwho23",
                        "content": "Can someone explain me the question in detail.\\nWhat is the indices array and how did he get that increment. I am not able to comprehend the question"
                    },
                    {
                        "username": "subham913dces3",
                        "content": "[@spardha-hash](/spardha-hash) thanks a lot sir/ma\\'am."
                    },
                    {
                        "username": "spardha-hash",
                        "content": "[@YouKnowWho](/uknowwho23)\\nFirst take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Where can I find an understandable translation of this question in English?\\n\\n1. Given n and m which are the dimensions of a matrix initialized by zeros.\\nOK.\\n\\n2. and given an array indices where indices[i] = [ri, ci]. \\nWhat?\\n\\n3. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by \\nYou lost me on what I extracted as step 2. \\n\\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\\n\\nSomeone please translate this into something understandable. \\n"
                    },
                    {
                        "username": "kshraj",
                        "content": "**problem statement is not easy to understand.**\\n\\nCan anyone provide an explanation."
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "I am at beginner level too, but many of coders are here finding it hard to understand this poorly explained question so lets breakdown the question together. \\n1. Firstly we are given a imaginary matrix which is initialized to 0 lets consider it as nums.\\n2. Then we are given a 2D array indices which will give us a list of locations we have to change, suppose the indices[i] is [0,1] so in our imaginary matrix nums we will increment each cell that is on \\'row 0 by 1\\' then every cell on \\'column 1 by 1\\'.\\n3. For all such given indices[i] we will do increment and we will get our final matrix nums.\\n4. Run a loop in the matrix nums and if an element nums[i][j] is odd then count++ and return that count.\\n"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "thank for explanation"
                    },
                    {
                        "username": "pandamaster392",
                        "content": "*how did you find that*"
                    },
                    {
                        "username": "shoshinsha_coder",
                        "content": "I feel like this should be a Medium question this involves a lot of memory, array construction / operations etc. "
                    },
                    {
                        "username": "rkhemka",
                        "content": "Can some one explain me in the example posted below the question \\nHow did first increment occurs\\nEx: From the question\\nInput: n = 2, m = 3, indices = [[0,1],[1,1]]\\nOutput: 6\\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\\nAfter applying first increment it becomes [[1,2,1],[0,1,0]]. <-- how 1,2,1 for first row and 0,1,0 for second row??\\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\\n\\n\\nIs there a formula to calculate first increment??"
                    },
                    {
                        "username": "vk970097",
                        "content": "[@spardha-hash](/spardha-hash) \\n\\ninitial matrix = [[0,0,0],[0,0,0]] \\n\\nFirst we take indices = [0,1] (and according to first indices we do increment in 0 Row and 1st column)\\nafter doing changes on 0 row initial matrix look like - [[1,1,1],[0,0,0]]\\nafter doing changes on 1st column initial matrix look like - [[1,2,1],[0,1,0]]\\n\\nThen we take another indices = [1,1] \\nafter doing changes on 1st row initial matrix look like - [[1,2,1],[1,2,1]]\\nafter doing changes on 1st column initial matrix look like - [[1,3,1],[1,3,1]]\\n\\nso in initial array all element are odd so answer is 6.\\n"
                    },
                    {
                        "username": "spardha-hash",
                        "content": "First take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "mike-meng",
                        "content": "hh......................"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "Worst question explanation\\n"
                    },
                    {
                        "username": "ChNihar",
                        "content": "I am able to solve this question in brute force, but for optimized solution I got he approach right but not able to understand this equation odd_row * n + odd_col * m \\u2013 2 * odd_row * odd_col . Someone please clarify my doubt."
                    },
                    {
                        "username": "District_12",
                        "content": "Do not look at the images. Second matrix is not an indices matrix it's updated first matrix after first iteration using `unknown` indices matrix."
                    }
                ]
            },
            {
                "id": 1567479,
                "content": [
                    {
                        "username": "uknowwho23",
                        "content": "Can someone explain me the question in detail.\\nWhat is the indices array and how did he get that increment. I am not able to comprehend the question"
                    },
                    {
                        "username": "subham913dces3",
                        "content": "[@spardha-hash](/spardha-hash) thanks a lot sir/ma\\'am."
                    },
                    {
                        "username": "spardha-hash",
                        "content": "[@YouKnowWho](/uknowwho23)\\nFirst take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Where can I find an understandable translation of this question in English?\\n\\n1. Given n and m which are the dimensions of a matrix initialized by zeros.\\nOK.\\n\\n2. and given an array indices where indices[i] = [ri, ci]. \\nWhat?\\n\\n3. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by \\nYou lost me on what I extracted as step 2. \\n\\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\\n\\nSomeone please translate this into something understandable. \\n"
                    },
                    {
                        "username": "kshraj",
                        "content": "**problem statement is not easy to understand.**\\n\\nCan anyone provide an explanation."
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "I am at beginner level too, but many of coders are here finding it hard to understand this poorly explained question so lets breakdown the question together. \\n1. Firstly we are given a imaginary matrix which is initialized to 0 lets consider it as nums.\\n2. Then we are given a 2D array indices which will give us a list of locations we have to change, suppose the indices[i] is [0,1] so in our imaginary matrix nums we will increment each cell that is on \\'row 0 by 1\\' then every cell on \\'column 1 by 1\\'.\\n3. For all such given indices[i] we will do increment and we will get our final matrix nums.\\n4. Run a loop in the matrix nums and if an element nums[i][j] is odd then count++ and return that count.\\n"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "thank for explanation"
                    },
                    {
                        "username": "pandamaster392",
                        "content": "*how did you find that*"
                    },
                    {
                        "username": "shoshinsha_coder",
                        "content": "I feel like this should be a Medium question this involves a lot of memory, array construction / operations etc. "
                    },
                    {
                        "username": "rkhemka",
                        "content": "Can some one explain me in the example posted below the question \\nHow did first increment occurs\\nEx: From the question\\nInput: n = 2, m = 3, indices = [[0,1],[1,1]]\\nOutput: 6\\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\\nAfter applying first increment it becomes [[1,2,1],[0,1,0]]. <-- how 1,2,1 for first row and 0,1,0 for second row??\\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\\n\\n\\nIs there a formula to calculate first increment??"
                    },
                    {
                        "username": "vk970097",
                        "content": "[@spardha-hash](/spardha-hash) \\n\\ninitial matrix = [[0,0,0],[0,0,0]] \\n\\nFirst we take indices = [0,1] (and according to first indices we do increment in 0 Row and 1st column)\\nafter doing changes on 0 row initial matrix look like - [[1,1,1],[0,0,0]]\\nafter doing changes on 1st column initial matrix look like - [[1,2,1],[0,1,0]]\\n\\nThen we take another indices = [1,1] \\nafter doing changes on 1st row initial matrix look like - [[1,2,1],[1,2,1]]\\nafter doing changes on 1st column initial matrix look like - [[1,3,1],[1,3,1]]\\n\\nso in initial array all element are odd so answer is 6.\\n"
                    },
                    {
                        "username": "spardha-hash",
                        "content": "First take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "mike-meng",
                        "content": "hh......................"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "Worst question explanation\\n"
                    },
                    {
                        "username": "ChNihar",
                        "content": "I am able to solve this question in brute force, but for optimized solution I got he approach right but not able to understand this equation odd_row * n + odd_col * m \\u2013 2 * odd_row * odd_col . Someone please clarify my doubt."
                    },
                    {
                        "username": "District_12",
                        "content": "Do not look at the images. Second matrix is not an indices matrix it's updated first matrix after first iteration using `unknown` indices matrix."
                    }
                ]
            },
            {
                "id": 1978799,
                "content": [
                    {
                        "username": "uknowwho23",
                        "content": "Can someone explain me the question in detail.\\nWhat is the indices array and how did he get that increment. I am not able to comprehend the question"
                    },
                    {
                        "username": "subham913dces3",
                        "content": "[@spardha-hash](/spardha-hash) thanks a lot sir/ma\\'am."
                    },
                    {
                        "username": "spardha-hash",
                        "content": "[@YouKnowWho](/uknowwho23)\\nFirst take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Where can I find an understandable translation of this question in English?\\n\\n1. Given n and m which are the dimensions of a matrix initialized by zeros.\\nOK.\\n\\n2. and given an array indices where indices[i] = [ri, ci]. \\nWhat?\\n\\n3. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by \\nYou lost me on what I extracted as step 2. \\n\\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\\n\\nSomeone please translate this into something understandable. \\n"
                    },
                    {
                        "username": "kshraj",
                        "content": "**problem statement is not easy to understand.**\\n\\nCan anyone provide an explanation."
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "I am at beginner level too, but many of coders are here finding it hard to understand this poorly explained question so lets breakdown the question together. \\n1. Firstly we are given a imaginary matrix which is initialized to 0 lets consider it as nums.\\n2. Then we are given a 2D array indices which will give us a list of locations we have to change, suppose the indices[i] is [0,1] so in our imaginary matrix nums we will increment each cell that is on \\'row 0 by 1\\' then every cell on \\'column 1 by 1\\'.\\n3. For all such given indices[i] we will do increment and we will get our final matrix nums.\\n4. Run a loop in the matrix nums and if an element nums[i][j] is odd then count++ and return that count.\\n"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "thank for explanation"
                    },
                    {
                        "username": "pandamaster392",
                        "content": "*how did you find that*"
                    },
                    {
                        "username": "shoshinsha_coder",
                        "content": "I feel like this should be a Medium question this involves a lot of memory, array construction / operations etc. "
                    },
                    {
                        "username": "rkhemka",
                        "content": "Can some one explain me in the example posted below the question \\nHow did first increment occurs\\nEx: From the question\\nInput: n = 2, m = 3, indices = [[0,1],[1,1]]\\nOutput: 6\\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\\nAfter applying first increment it becomes [[1,2,1],[0,1,0]]. <-- how 1,2,1 for first row and 0,1,0 for second row??\\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\\n\\n\\nIs there a formula to calculate first increment??"
                    },
                    {
                        "username": "vk970097",
                        "content": "[@spardha-hash](/spardha-hash) \\n\\ninitial matrix = [[0,0,0],[0,0,0]] \\n\\nFirst we take indices = [0,1] (and according to first indices we do increment in 0 Row and 1st column)\\nafter doing changes on 0 row initial matrix look like - [[1,1,1],[0,0,0]]\\nafter doing changes on 1st column initial matrix look like - [[1,2,1],[0,1,0]]\\n\\nThen we take another indices = [1,1] \\nafter doing changes on 1st row initial matrix look like - [[1,2,1],[1,2,1]]\\nafter doing changes on 1st column initial matrix look like - [[1,3,1],[1,3,1]]\\n\\nso in initial array all element are odd so answer is 6.\\n"
                    },
                    {
                        "username": "spardha-hash",
                        "content": "First take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "mike-meng",
                        "content": "hh......................"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "Worst question explanation\\n"
                    },
                    {
                        "username": "ChNihar",
                        "content": "I am able to solve this question in brute force, but for optimized solution I got he approach right but not able to understand this equation odd_row * n + odd_col * m \\u2013 2 * odd_row * odd_col . Someone please clarify my doubt."
                    },
                    {
                        "username": "District_12",
                        "content": "Do not look at the images. Second matrix is not an indices matrix it's updated first matrix after first iteration using `unknown` indices matrix."
                    }
                ]
            },
            {
                "id": 1793663,
                "content": [
                    {
                        "username": "uknowwho23",
                        "content": "Can someone explain me the question in detail.\\nWhat is the indices array and how did he get that increment. I am not able to comprehend the question"
                    },
                    {
                        "username": "subham913dces3",
                        "content": "[@spardha-hash](/spardha-hash) thanks a lot sir/ma\\'am."
                    },
                    {
                        "username": "spardha-hash",
                        "content": "[@YouKnowWho](/uknowwho23)\\nFirst take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Where can I find an understandable translation of this question in English?\\n\\n1. Given n and m which are the dimensions of a matrix initialized by zeros.\\nOK.\\n\\n2. and given an array indices where indices[i] = [ri, ci]. \\nWhat?\\n\\n3. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by \\nYou lost me on what I extracted as step 2. \\n\\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\\n\\nSomeone please translate this into something understandable. \\n"
                    },
                    {
                        "username": "kshraj",
                        "content": "**problem statement is not easy to understand.**\\n\\nCan anyone provide an explanation."
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "I am at beginner level too, but many of coders are here finding it hard to understand this poorly explained question so lets breakdown the question together. \\n1. Firstly we are given a imaginary matrix which is initialized to 0 lets consider it as nums.\\n2. Then we are given a 2D array indices which will give us a list of locations we have to change, suppose the indices[i] is [0,1] so in our imaginary matrix nums we will increment each cell that is on \\'row 0 by 1\\' then every cell on \\'column 1 by 1\\'.\\n3. For all such given indices[i] we will do increment and we will get our final matrix nums.\\n4. Run a loop in the matrix nums and if an element nums[i][j] is odd then count++ and return that count.\\n"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "thank for explanation"
                    },
                    {
                        "username": "pandamaster392",
                        "content": "*how did you find that*"
                    },
                    {
                        "username": "shoshinsha_coder",
                        "content": "I feel like this should be a Medium question this involves a lot of memory, array construction / operations etc. "
                    },
                    {
                        "username": "rkhemka",
                        "content": "Can some one explain me in the example posted below the question \\nHow did first increment occurs\\nEx: From the question\\nInput: n = 2, m = 3, indices = [[0,1],[1,1]]\\nOutput: 6\\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\\nAfter applying first increment it becomes [[1,2,1],[0,1,0]]. <-- how 1,2,1 for first row and 0,1,0 for second row??\\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\\n\\n\\nIs there a formula to calculate first increment??"
                    },
                    {
                        "username": "vk970097",
                        "content": "[@spardha-hash](/spardha-hash) \\n\\ninitial matrix = [[0,0,0],[0,0,0]] \\n\\nFirst we take indices = [0,1] (and according to first indices we do increment in 0 Row and 1st column)\\nafter doing changes on 0 row initial matrix look like - [[1,1,1],[0,0,0]]\\nafter doing changes on 1st column initial matrix look like - [[1,2,1],[0,1,0]]\\n\\nThen we take another indices = [1,1] \\nafter doing changes on 1st row initial matrix look like - [[1,2,1],[1,2,1]]\\nafter doing changes on 1st column initial matrix look like - [[1,3,1],[1,3,1]]\\n\\nso in initial array all element are odd so answer is 6.\\n"
                    },
                    {
                        "username": "spardha-hash",
                        "content": "First take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "mike-meng",
                        "content": "hh......................"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "Worst question explanation\\n"
                    },
                    {
                        "username": "ChNihar",
                        "content": "I am able to solve this question in brute force, but for optimized solution I got he approach right but not able to understand this equation odd_row * n + odd_col * m \\u2013 2 * odd_row * odd_col . Someone please clarify my doubt."
                    },
                    {
                        "username": "District_12",
                        "content": "Do not look at the images. Second matrix is not an indices matrix it's updated first matrix after first iteration using `unknown` indices matrix."
                    }
                ]
            },
            {
                "id": 1568244,
                "content": [
                    {
                        "username": "uknowwho23",
                        "content": "Can someone explain me the question in detail.\\nWhat is the indices array and how did he get that increment. I am not able to comprehend the question"
                    },
                    {
                        "username": "subham913dces3",
                        "content": "[@spardha-hash](/spardha-hash) thanks a lot sir/ma\\'am."
                    },
                    {
                        "username": "spardha-hash",
                        "content": "[@YouKnowWho](/uknowwho23)\\nFirst take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Where can I find an understandable translation of this question in English?\\n\\n1. Given n and m which are the dimensions of a matrix initialized by zeros.\\nOK.\\n\\n2. and given an array indices where indices[i] = [ri, ci]. \\nWhat?\\n\\n3. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by \\nYou lost me on what I extracted as step 2. \\n\\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\\n\\nSomeone please translate this into something understandable. \\n"
                    },
                    {
                        "username": "kshraj",
                        "content": "**problem statement is not easy to understand.**\\n\\nCan anyone provide an explanation."
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "I am at beginner level too, but many of coders are here finding it hard to understand this poorly explained question so lets breakdown the question together. \\n1. Firstly we are given a imaginary matrix which is initialized to 0 lets consider it as nums.\\n2. Then we are given a 2D array indices which will give us a list of locations we have to change, suppose the indices[i] is [0,1] so in our imaginary matrix nums we will increment each cell that is on \\'row 0 by 1\\' then every cell on \\'column 1 by 1\\'.\\n3. For all such given indices[i] we will do increment and we will get our final matrix nums.\\n4. Run a loop in the matrix nums and if an element nums[i][j] is odd then count++ and return that count.\\n"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "thank for explanation"
                    },
                    {
                        "username": "pandamaster392",
                        "content": "*how did you find that*"
                    },
                    {
                        "username": "shoshinsha_coder",
                        "content": "I feel like this should be a Medium question this involves a lot of memory, array construction / operations etc. "
                    },
                    {
                        "username": "rkhemka",
                        "content": "Can some one explain me in the example posted below the question \\nHow did first increment occurs\\nEx: From the question\\nInput: n = 2, m = 3, indices = [[0,1],[1,1]]\\nOutput: 6\\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\\nAfter applying first increment it becomes [[1,2,1],[0,1,0]]. <-- how 1,2,1 for first row and 0,1,0 for second row??\\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\\n\\n\\nIs there a formula to calculate first increment??"
                    },
                    {
                        "username": "vk970097",
                        "content": "[@spardha-hash](/spardha-hash) \\n\\ninitial matrix = [[0,0,0],[0,0,0]] \\n\\nFirst we take indices = [0,1] (and according to first indices we do increment in 0 Row and 1st column)\\nafter doing changes on 0 row initial matrix look like - [[1,1,1],[0,0,0]]\\nafter doing changes on 1st column initial matrix look like - [[1,2,1],[0,1,0]]\\n\\nThen we take another indices = [1,1] \\nafter doing changes on 1st row initial matrix look like - [[1,2,1],[1,2,1]]\\nafter doing changes on 1st column initial matrix look like - [[1,3,1],[1,3,1]]\\n\\nso in initial array all element are odd so answer is 6.\\n"
                    },
                    {
                        "username": "spardha-hash",
                        "content": "First take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "mike-meng",
                        "content": "hh......................"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "Worst question explanation\\n"
                    },
                    {
                        "username": "ChNihar",
                        "content": "I am able to solve this question in brute force, but for optimized solution I got he approach right but not able to understand this equation odd_row * n + odd_col * m \\u2013 2 * odd_row * odd_col . Someone please clarify my doubt."
                    },
                    {
                        "username": "District_12",
                        "content": "Do not look at the images. Second matrix is not an indices matrix it's updated first matrix after first iteration using `unknown` indices matrix."
                    }
                ]
            },
            {
                "id": 1566587,
                "content": [
                    {
                        "username": "uknowwho23",
                        "content": "Can someone explain me the question in detail.\\nWhat is the indices array and how did he get that increment. I am not able to comprehend the question"
                    },
                    {
                        "username": "subham913dces3",
                        "content": "[@spardha-hash](/spardha-hash) thanks a lot sir/ma\\'am."
                    },
                    {
                        "username": "spardha-hash",
                        "content": "[@YouKnowWho](/uknowwho23)\\nFirst take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Where can I find an understandable translation of this question in English?\\n\\n1. Given n and m which are the dimensions of a matrix initialized by zeros.\\nOK.\\n\\n2. and given an array indices where indices[i] = [ri, ci]. \\nWhat?\\n\\n3. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by \\nYou lost me on what I extracted as step 2. \\n\\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\\n\\nSomeone please translate this into something understandable. \\n"
                    },
                    {
                        "username": "kshraj",
                        "content": "**problem statement is not easy to understand.**\\n\\nCan anyone provide an explanation."
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "I am at beginner level too, but many of coders are here finding it hard to understand this poorly explained question so lets breakdown the question together. \\n1. Firstly we are given a imaginary matrix which is initialized to 0 lets consider it as nums.\\n2. Then we are given a 2D array indices which will give us a list of locations we have to change, suppose the indices[i] is [0,1] so in our imaginary matrix nums we will increment each cell that is on \\'row 0 by 1\\' then every cell on \\'column 1 by 1\\'.\\n3. For all such given indices[i] we will do increment and we will get our final matrix nums.\\n4. Run a loop in the matrix nums and if an element nums[i][j] is odd then count++ and return that count.\\n"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "thank for explanation"
                    },
                    {
                        "username": "pandamaster392",
                        "content": "*how did you find that*"
                    },
                    {
                        "username": "shoshinsha_coder",
                        "content": "I feel like this should be a Medium question this involves a lot of memory, array construction / operations etc. "
                    },
                    {
                        "username": "rkhemka",
                        "content": "Can some one explain me in the example posted below the question \\nHow did first increment occurs\\nEx: From the question\\nInput: n = 2, m = 3, indices = [[0,1],[1,1]]\\nOutput: 6\\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\\nAfter applying first increment it becomes [[1,2,1],[0,1,0]]. <-- how 1,2,1 for first row and 0,1,0 for second row??\\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\\n\\n\\nIs there a formula to calculate first increment??"
                    },
                    {
                        "username": "vk970097",
                        "content": "[@spardha-hash](/spardha-hash) \\n\\ninitial matrix = [[0,0,0],[0,0,0]] \\n\\nFirst we take indices = [0,1] (and according to first indices we do increment in 0 Row and 1st column)\\nafter doing changes on 0 row initial matrix look like - [[1,1,1],[0,0,0]]\\nafter doing changes on 1st column initial matrix look like - [[1,2,1],[0,1,0]]\\n\\nThen we take another indices = [1,1] \\nafter doing changes on 1st row initial matrix look like - [[1,2,1],[1,2,1]]\\nafter doing changes on 1st column initial matrix look like - [[1,3,1],[1,3,1]]\\n\\nso in initial array all element are odd so answer is 6.\\n"
                    },
                    {
                        "username": "spardha-hash",
                        "content": "First take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "mike-meng",
                        "content": "hh......................"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "Worst question explanation\\n"
                    },
                    {
                        "username": "ChNihar",
                        "content": "I am able to solve this question in brute force, but for optimized solution I got he approach right but not able to understand this equation odd_row * n + odd_col * m \\u2013 2 * odd_row * odd_col . Someone please clarify my doubt."
                    },
                    {
                        "username": "District_12",
                        "content": "Do not look at the images. Second matrix is not an indices matrix it's updated first matrix after first iteration using `unknown` indices matrix."
                    }
                ]
            },
            {
                "id": 1969207,
                "content": [
                    {
                        "username": "uknowwho23",
                        "content": "Can someone explain me the question in detail.\\nWhat is the indices array and how did he get that increment. I am not able to comprehend the question"
                    },
                    {
                        "username": "subham913dces3",
                        "content": "[@spardha-hash](/spardha-hash) thanks a lot sir/ma\\'am."
                    },
                    {
                        "username": "spardha-hash",
                        "content": "[@YouKnowWho](/uknowwho23)\\nFirst take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Where can I find an understandable translation of this question in English?\\n\\n1. Given n and m which are the dimensions of a matrix initialized by zeros.\\nOK.\\n\\n2. and given an array indices where indices[i] = [ri, ci]. \\nWhat?\\n\\n3. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by \\nYou lost me on what I extracted as step 2. \\n\\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\\n\\nSomeone please translate this into something understandable. \\n"
                    },
                    {
                        "username": "kshraj",
                        "content": "**problem statement is not easy to understand.**\\n\\nCan anyone provide an explanation."
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "I am at beginner level too, but many of coders are here finding it hard to understand this poorly explained question so lets breakdown the question together. \\n1. Firstly we are given a imaginary matrix which is initialized to 0 lets consider it as nums.\\n2. Then we are given a 2D array indices which will give us a list of locations we have to change, suppose the indices[i] is [0,1] so in our imaginary matrix nums we will increment each cell that is on \\'row 0 by 1\\' then every cell on \\'column 1 by 1\\'.\\n3. For all such given indices[i] we will do increment and we will get our final matrix nums.\\n4. Run a loop in the matrix nums and if an element nums[i][j] is odd then count++ and return that count.\\n"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "thank for explanation"
                    },
                    {
                        "username": "pandamaster392",
                        "content": "*how did you find that*"
                    },
                    {
                        "username": "shoshinsha_coder",
                        "content": "I feel like this should be a Medium question this involves a lot of memory, array construction / operations etc. "
                    },
                    {
                        "username": "rkhemka",
                        "content": "Can some one explain me in the example posted below the question \\nHow did first increment occurs\\nEx: From the question\\nInput: n = 2, m = 3, indices = [[0,1],[1,1]]\\nOutput: 6\\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\\nAfter applying first increment it becomes [[1,2,1],[0,1,0]]. <-- how 1,2,1 for first row and 0,1,0 for second row??\\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\\n\\n\\nIs there a formula to calculate first increment??"
                    },
                    {
                        "username": "vk970097",
                        "content": "[@spardha-hash](/spardha-hash) \\n\\ninitial matrix = [[0,0,0],[0,0,0]] \\n\\nFirst we take indices = [0,1] (and according to first indices we do increment in 0 Row and 1st column)\\nafter doing changes on 0 row initial matrix look like - [[1,1,1],[0,0,0]]\\nafter doing changes on 1st column initial matrix look like - [[1,2,1],[0,1,0]]\\n\\nThen we take another indices = [1,1] \\nafter doing changes on 1st row initial matrix look like - [[1,2,1],[1,2,1]]\\nafter doing changes on 1st column initial matrix look like - [[1,3,1],[1,3,1]]\\n\\nso in initial array all element are odd so answer is 6.\\n"
                    },
                    {
                        "username": "spardha-hash",
                        "content": "First take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "mike-meng",
                        "content": "hh......................"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "Worst question explanation\\n"
                    },
                    {
                        "username": "ChNihar",
                        "content": "I am able to solve this question in brute force, but for optimized solution I got he approach right but not able to understand this equation odd_row * n + odd_col * m \\u2013 2 * odd_row * odd_col . Someone please clarify my doubt."
                    },
                    {
                        "username": "District_12",
                        "content": "Do not look at the images. Second matrix is not an indices matrix it's updated first matrix after first iteration using `unknown` indices matrix."
                    }
                ]
            },
            {
                "id": 2060669,
                "content": [
                    {
                        "username": "uknowwho23",
                        "content": "Can someone explain me the question in detail.\\nWhat is the indices array and how did he get that increment. I am not able to comprehend the question"
                    },
                    {
                        "username": "subham913dces3",
                        "content": "[@spardha-hash](/spardha-hash) thanks a lot sir/ma\\'am."
                    },
                    {
                        "username": "spardha-hash",
                        "content": "[@YouKnowWho](/uknowwho23)\\nFirst take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Where can I find an understandable translation of this question in English?\\n\\n1. Given n and m which are the dimensions of a matrix initialized by zeros.\\nOK.\\n\\n2. and given an array indices where indices[i] = [ri, ci]. \\nWhat?\\n\\n3. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by \\nYou lost me on what I extracted as step 2. \\n\\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\\n\\nSomeone please translate this into something understandable. \\n"
                    },
                    {
                        "username": "kshraj",
                        "content": "**problem statement is not easy to understand.**\\n\\nCan anyone provide an explanation."
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "I am at beginner level too, but many of coders are here finding it hard to understand this poorly explained question so lets breakdown the question together. \\n1. Firstly we are given a imaginary matrix which is initialized to 0 lets consider it as nums.\\n2. Then we are given a 2D array indices which will give us a list of locations we have to change, suppose the indices[i] is [0,1] so in our imaginary matrix nums we will increment each cell that is on \\'row 0 by 1\\' then every cell on \\'column 1 by 1\\'.\\n3. For all such given indices[i] we will do increment and we will get our final matrix nums.\\n4. Run a loop in the matrix nums and if an element nums[i][j] is odd then count++ and return that count.\\n"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "thank for explanation"
                    },
                    {
                        "username": "pandamaster392",
                        "content": "*how did you find that*"
                    },
                    {
                        "username": "shoshinsha_coder",
                        "content": "I feel like this should be a Medium question this involves a lot of memory, array construction / operations etc. "
                    },
                    {
                        "username": "rkhemka",
                        "content": "Can some one explain me in the example posted below the question \\nHow did first increment occurs\\nEx: From the question\\nInput: n = 2, m = 3, indices = [[0,1],[1,1]]\\nOutput: 6\\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\\nAfter applying first increment it becomes [[1,2,1],[0,1,0]]. <-- how 1,2,1 for first row and 0,1,0 for second row??\\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\\n\\n\\nIs there a formula to calculate first increment??"
                    },
                    {
                        "username": "vk970097",
                        "content": "[@spardha-hash](/spardha-hash) \\n\\ninitial matrix = [[0,0,0],[0,0,0]] \\n\\nFirst we take indices = [0,1] (and according to first indices we do increment in 0 Row and 1st column)\\nafter doing changes on 0 row initial matrix look like - [[1,1,1],[0,0,0]]\\nafter doing changes on 1st column initial matrix look like - [[1,2,1],[0,1,0]]\\n\\nThen we take another indices = [1,1] \\nafter doing changes on 1st row initial matrix look like - [[1,2,1],[1,2,1]]\\nafter doing changes on 1st column initial matrix look like - [[1,3,1],[1,3,1]]\\n\\nso in initial array all element are odd so answer is 6.\\n"
                    },
                    {
                        "username": "spardha-hash",
                        "content": "First take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "mike-meng",
                        "content": "hh......................"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "Worst question explanation\\n"
                    },
                    {
                        "username": "ChNihar",
                        "content": "I am able to solve this question in brute force, but for optimized solution I got he approach right but not able to understand this equation odd_row * n + odd_col * m \\u2013 2 * odd_row * odd_col . Someone please clarify my doubt."
                    },
                    {
                        "username": "District_12",
                        "content": "Do not look at the images. Second matrix is not an indices matrix it's updated first matrix after first iteration using `unknown` indices matrix."
                    }
                ]
            },
            {
                "id": 2010513,
                "content": [
                    {
                        "username": "uknowwho23",
                        "content": "Can someone explain me the question in detail.\\nWhat is the indices array and how did he get that increment. I am not able to comprehend the question"
                    },
                    {
                        "username": "subham913dces3",
                        "content": "[@spardha-hash](/spardha-hash) thanks a lot sir/ma\\'am."
                    },
                    {
                        "username": "spardha-hash",
                        "content": "[@YouKnowWho](/uknowwho23)\\nFirst take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Where can I find an understandable translation of this question in English?\\n\\n1. Given n and m which are the dimensions of a matrix initialized by zeros.\\nOK.\\n\\n2. and given an array indices where indices[i] = [ri, ci]. \\nWhat?\\n\\n3. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by \\nYou lost me on what I extracted as step 2. \\n\\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\\n\\nSomeone please translate this into something understandable. \\n"
                    },
                    {
                        "username": "kshraj",
                        "content": "**problem statement is not easy to understand.**\\n\\nCan anyone provide an explanation."
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "I am at beginner level too, but many of coders are here finding it hard to understand this poorly explained question so lets breakdown the question together. \\n1. Firstly we are given a imaginary matrix which is initialized to 0 lets consider it as nums.\\n2. Then we are given a 2D array indices which will give us a list of locations we have to change, suppose the indices[i] is [0,1] so in our imaginary matrix nums we will increment each cell that is on \\'row 0 by 1\\' then every cell on \\'column 1 by 1\\'.\\n3. For all such given indices[i] we will do increment and we will get our final matrix nums.\\n4. Run a loop in the matrix nums and if an element nums[i][j] is odd then count++ and return that count.\\n"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "thank for explanation"
                    },
                    {
                        "username": "pandamaster392",
                        "content": "*how did you find that*"
                    },
                    {
                        "username": "shoshinsha_coder",
                        "content": "I feel like this should be a Medium question this involves a lot of memory, array construction / operations etc. "
                    },
                    {
                        "username": "rkhemka",
                        "content": "Can some one explain me in the example posted below the question \\nHow did first increment occurs\\nEx: From the question\\nInput: n = 2, m = 3, indices = [[0,1],[1,1]]\\nOutput: 6\\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\\nAfter applying first increment it becomes [[1,2,1],[0,1,0]]. <-- how 1,2,1 for first row and 0,1,0 for second row??\\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\\n\\n\\nIs there a formula to calculate first increment??"
                    },
                    {
                        "username": "vk970097",
                        "content": "[@spardha-hash](/spardha-hash) \\n\\ninitial matrix = [[0,0,0],[0,0,0]] \\n\\nFirst we take indices = [0,1] (and according to first indices we do increment in 0 Row and 1st column)\\nafter doing changes on 0 row initial matrix look like - [[1,1,1],[0,0,0]]\\nafter doing changes on 1st column initial matrix look like - [[1,2,1],[0,1,0]]\\n\\nThen we take another indices = [1,1] \\nafter doing changes on 1st row initial matrix look like - [[1,2,1],[1,2,1]]\\nafter doing changes on 1st column initial matrix look like - [[1,3,1],[1,3,1]]\\n\\nso in initial array all element are odd so answer is 6.\\n"
                    },
                    {
                        "username": "spardha-hash",
                        "content": "First take the indices [0,1], here 0 represent the 0th row and 1 represent the 1st column so it will first increment the values of 0th row then the inital matrix become [[1,1,1],[0,0,0]] and then it will increment the values of 1st column then the initial matrix become [[1,2,1], [0,1,0]]\\nSimilarly for other indices [1,1], here it will increment the values of 1st row then inital matrix become [[1,2,1], [1,2,1]] then it will increment the value of 1st column then the inital matrix become [[1,3,1], [1,3,1]]\\nNow the no. of odd values are 6 in this matrix so output will be 6"
                    },
                    {
                        "username": "mike-meng",
                        "content": "hh......................"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "Worst question explanation\\n"
                    },
                    {
                        "username": "ChNihar",
                        "content": "I am able to solve this question in brute force, but for optimized solution I got he approach right but not able to understand this equation odd_row * n + odd_col * m \\u2013 2 * odd_row * odd_col . Someone please clarify my doubt."
                    },
                    {
                        "username": "District_12",
                        "content": "Do not look at the images. Second matrix is not an indices matrix it's updated first matrix after first iteration using `unknown` indices matrix."
                    }
                ]
            }
        ]
    },
    {
        "title": "Daily Leads and Partners",
        "question_content": "<p>Table: <code>DailySales</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| date_id     | date    |\n| make_name   | varchar |\n| lead_id     | int     |\n| partner_id  | int     |\n+-------------+---------+\nThere is no primary key (column with unique values) for this table. It may contain duplicates.\nThis table contains the date and the name of the product sold and the IDs of the lead and partner it was sold to.\nThe name consists of only lowercase English letters.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>For each <code>date_id</code> and <code>make_name</code>, find the number of <strong>distinct</strong> <code>lead_id</code>&#39;s and <strong>distinct</strong> <code>partner_id</code>&#39;s.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nDailySales table:\n+-----------+-----------+---------+------------+\n| date_id   | make_name | lead_id | partner_id |\n+-----------+-----------+---------+------------+\n| 2020-12-8 | toyota    | 0       | 1          |\n| 2020-12-8 | toyota    | 1       | 0          |\n| 2020-12-8 | toyota    | 1       | 2          |\n| 2020-12-7 | toyota    | 0       | 2          |\n| 2020-12-7 | toyota    | 0       | 1          |\n| 2020-12-8 | honda     | 1       | 2          |\n| 2020-12-8 | honda     | 2       | 1          |\n| 2020-12-7 | honda     | 0       | 1          |\n| 2020-12-7 | honda     | 1       | 2          |\n| 2020-12-7 | honda     | 2       | 1          |\n+-----------+-----------+---------+------------+\n<strong>Output:</strong> \n+-----------+-----------+--------------+-----------------+\n| date_id   | make_name | unique_leads | unique_partners |\n+-----------+-----------+--------------+-----------------+\n| 2020-12-8 | toyota    | 2            | 3               |\n| 2020-12-7 | toyota    | 1            | 2               |\n| 2020-12-8 | honda     | 2            | 2               |\n| 2020-12-7 | honda     | 3            | 2               |\n+-----------+-----------+--------------+-----------------+\n<strong>Explanation:</strong> \nFor 2020-12-8, toyota gets leads = [0, 1] and partners = [0, 1, 2] while honda gets leads = [1, 2] and partners = [1, 2].\nFor 2020-12-7, toyota gets leads = [0] and partners = [1, 2] while honda gets leads = [0, 1, 2] and partners = [1, 2].\n</pre>\n",
        "solutions": [
            {
                "id": 976703,
                "title": "simple-mysql-solution-using-count-distinct",
                "content": "```\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY 1, 2\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY 1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2520694,
                "title": "mysql-beginner-level-easy-to-understand-simple-short-solution",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome.***\\n*====================================================================*\\n\\u2705 **MySQL Code :**\\n```\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\n```\\n**Runtime:** 789 ms\\n**Memory Usage:**  0B\\n________________________________\\n__________________________________\\n\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3863279,
                "title": "pandas-vs-sql-elegant-short-all-30-days-of-pandas-solutions",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```Python []\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return daily_sales.groupby(\\n        [\\'date_id\\', \\'make_name\\']\\n    ).nunique().reset_index().rename(columns={\\n        \\'lead_id\\': \\'unique_leads\\',\\n        \\'partner_id\\': \\'unique_partners\\',\\n    })\\n```\\n```SQL []\\nSELECT date_id,\\n       make_name,\\n       count(DISTINCT lead_id) AS unique_leads,\\n       count(DISTINCT partner_id) AS unique_partners\\n  FROM DailySales\\n GROUP BY date_id,\\n          make_name;\\n```\\n\\n# Important!\\n###### If you like the solution or find it useful, feel free to **upvote** for it, it will support me in creating high quality solutions)\\n\\n# 30 Days of Pandas solutions\\n\\n### Data Filtering \\u2705\\n- [Big Countries](https://leetcode.com/problems/big-countries/solutions/3848474/pandas-elegant-short-1-line/)\\n- [Recyclable and Low Fat Products](https://leetcode.com/problems/recyclable-and-low-fat-products/solutions/3848500/pandas-elegant-short-1-line/)\\n- [Customers Who Never Order](https://leetcode.com/problems/customers-who-never-order/solutions/3848527/pandas-elegant-short-1-line/)\\n- [Article Views I](https://leetcode.com/problems/article-views-i/solutions/3867192/pandas-elegant-short-1-line/)\\n\\n\\n### String Methods \\u2705\\n- [Invalid Tweets](https://leetcode.com/problems/invalid-tweets/solutions/3849121/pandas-elegant-short-1-line/)\\n- [Calculate Special Bonus](https://leetcode.com/problems/calculate-special-bonus/solutions/3867209/pandas-elegant-short-1-line/)\\n- [Fix Names in a Table](https://leetcode.com/problems/fix-names-in-a-table/solutions/3849167/pandas-elegant-short-1-line/)\\n- [Find Users With Valid E-Mails](https://leetcode.com/problems/find-users-with-valid-e-mails/solutions/3849177/pandas-elegant-short-1-line/)\\n- [Patients With a Condition](https://leetcode.com/problems/patients-with-a-condition/solutions/3849196/pandas-elegant-short-1-line-regex/)\\n\\n\\n### Data Manipulation \\u2705\\n- [Nth Highest Salary](https://leetcode.com/problems/nth-highest-salary/solutions/3867257/pandas-elegant-short-1-line/)\\n- [Second Highest Salary](https://leetcode.com/problems/second-highest-salary/solutions/3867278/pandas-elegant-short/)\\n- [Department Highest Salary](https://leetcode.com/problems/department-highest-salary/solutions/3867312/pandas-elegant-short-1-line/)\\n- [Rank Scores](https://leetcode.com/problems/rank-scores/solutions/3872817/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Delete Duplicate Emails](https://leetcode.com/problems/delete-duplicate-emails/solutions/3849211/pandas-elegant-short/)\\n- [Rearrange Products Table](https://leetcode.com/problems/rearrange-products-table/solutions/3849226/pandas-elegant-short-1-line/)\\n\\n\\n### Statistics \\u2705\\n- [The Number of Rich Customers](https://leetcode.com/problems/the-number-of-rich-customers/solutions/3849251/pandas-elegant-short-1-line/)\\n- [Immediate Food Delivery I](https://leetcode.com/problems/immediate-food-delivery-i/solutions/3872719/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Count Salary Categories](https://leetcode.com/problems/count-salary-categories/solutions/3872801/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n\\n\\n### Data Aggregation \\u2705\\n- [Find Total Time Spent by Each Employee](https://leetcode.com/problems/find-total-time-spent-by-each-employee/solutions/3872715/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Game Play Analysis I](https://leetcode.com/problems/game-play-analysis-i/solutions/3863223/pandas-elegant-short-1-line/)\\n- [Number of Unique Subjects Taught by Each Teacher](https://leetcode.com/problems/number-of-unique-subjects-taught-by-each-teacher/solutions/3863239/pandas-elegant-short-1-line/)\\n- [Classes More Than 5 Students](https://leetcode.com/problems/classes-more-than-5-students/solutions/3863249/pandas-elegant-short/)\\n- [Customer Placing the Largest Number of Orders](https://leetcode.com/problems/customer-placing-the-largest-number-of-orders/solutions/3863257/pandas-elegant-short-1-line/)\\n- [Group Sold Products By The Date](https://leetcode.com/problems/group-sold-products-by-the-date/solutions/3863267/pandas-elegant-short-1-line/)\\n- [Daily Leads and Partners](https://leetcode.com/problems/daily-leads-and-partners/solutions/3863279/pandas-elegant-short-1-line/)\\n\\n\\n### Data Aggregation \\u2705\\n- [Actors and Directors Who Cooperated At Least Three Times](https://leetcode.com/problems/actors-and-directors-who-cooperated-at-least-three-times/solutions/3863309/pandas-elegant-short/)\\n- [Replace Employee ID With The Unique Identifier](https://leetcode.com/problems/replace-employee-id-with-the-unique-identifier/solutions/3872822/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Students and Examinations](https://leetcode.com/problems/students-and-examinations/solutions/3872699/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Managers with at Least 5 Direct Reports](https://leetcode.com/problems/managers-with-at-least-5-direct-reports/solutions/3872861/pandas-elegant-short/)\\n- [Sales Person](https://leetcode.com/problems/sales-person/solutions/3872712/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "MySQL",
                    "Pandas"
                ],
                "code": "```Python []\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return daily_sales.groupby(\\n        [\\'date_id\\', \\'make_name\\']\\n    ).nunique().reset_index().rename(columns={\\n        \\'lead_id\\': \\'unique_leads\\',\\n        \\'partner_id\\': \\'unique_partners\\',\\n    })\\n```\n```SQL []\\nSELECT date_id,\\n       make_name,\\n       count(DISTINCT lead_id) AS unique_leads,\\n       count(DISTINCT partner_id) AS unique_partners\\n  FROM DailySales\\n GROUP BY date_id,\\n          make_name;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3946892,
                "title": "pandas-2-step-simple-code-with-comments",
                "content": "\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    # Group the daily sales by date_id and make_name, and count distinct lead_id\\'s and partner_id\\'s\\n    grouped = daily_sales.groupby([\\'date_id\\', \\'make_name\\']).agg({\\'lead_id\\': \\'nunique\\', \\'partner_id\\': \\'nunique\\'}).reset_index()\\n    \\n    # Rename the columns for clarity\\n    grouped.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n    \\n    return grouped\\n\\n```\\n\\n![upvote img.jpg](https://assets.leetcode.com/users/images/ed6a693a-697a-445b-9d5c-d3b5fa863b82_1692727539.0997536.jpeg)\\n",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    # Group the daily sales by date_id and make_name, and count distinct lead_id\\'s and partner_id\\'s\\n    grouped = daily_sales.groupby([\\'date_id\\', \\'make_name\\']).agg({\\'lead_id\\': \\'nunique\\', \\'partner_id\\': \\'nunique\\'}).reset_index()\\n    \\n    # Rename the columns for clarity\\n    grouped.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n    \\n    return grouped\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2039563,
                "title": "lightning-mcqueen-fast",
                "content": "```\\nselect\\n    date_id, \\n    make_name, \\n    count(distinct lead_id) as unique_leads, \\n    count(distinct partner_id) as unique_partners\\nfrom \\n    DailySales as DS \\ngroup by\\n    date_id, make_name \\n\\n\\n```\\n\\nif you like this solution, please upvote ! \\n#kachow ! \\n",
                "solutionTags": [],
                "code": "```\\nselect\\n    date_id, \\n    make_name, \\n    count(distinct lead_id) as unique_leads, \\n    count(distinct partner_id) as unique_partners\\nfrom \\n    DailySales as DS \\ngroup by\\n    date_id, make_name \\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 993253,
                "title": "mysql-at-89",
                "content": "```\\nSELECT        date_id, \\n\\t\\t\\t  make_name, \\n\\t\\t\\t  COUNT(DISTINCT lead_id) as unique_leads, \\n\\t\\t\\t  COUNT( DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY make_name DESC, date_id DESC\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT        date_id, \\n\\t\\t\\t  make_name, \\n\\t\\t\\t  COUNT(DISTINCT lead_id) as unique_leads, \\n\\t\\t\\t  COUNT( DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY make_name DESC, date_id DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2691080,
                "title": "mysql-group-by-beginner-friendly",
                "content": "# Write your MySQL query statement below\\n\\n```\\nSELECT date_id,make_name,\\nCOUNT(DISTINCT lead_id) AS unique_leads,\\nCOUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales \\nGROUP BY date_id,make_name;\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT date_id,make_name,\\nCOUNT(DISTINCT lead_id) AS unique_leads,\\nCOUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales \\nGROUP BY date_id,make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3059749,
                "title": "mysql-group-by-and-count-aggregation-function",
                "content": "![image](https://assets.leetcode.com/users/images/2cb97469-3016-4ded-a150-df5378e27c64_1673886676.817008.png)\\n\\n\\n\\tSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners FROM dailysales GROUP BY date_id, make_name;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/2cb97469-3016-4ded-a150-df5378e27c64_1673886676.817008.png)\\n\\n\\n\\tSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners FROM dailysales GROUP BY date_id, make_name;",
                "codeTag": "Unknown"
            },
            {
                "id": 3896670,
                "title": "group-by-with-aggregator-explained",
                "content": "# My SQL\\nPretty straight forward solution. Easily solvable by using `DISTINCT` and `GROUP BY` combination.\\n\\n``` SQL []\\n# Write your MySQL query statement below\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) as unique_leads,\\nCOUNT(DISTINCT partner_id) as unique_partners\\nFROM DailySales \\nGROUP BY date_id, make_name\\n```\\n\\n# Pandas\\n\\nLet\\'s start by using the `.groupby()` and `.agg()` functions to group the `DataFrame` by `date_id` and `make_name`. This will split the `DataFrame` into groups, where each group represents a unique combination of `date_id` and `make_name`.\\n``` python3\\ngroups = daily_sales.groupby([\\'date_id\\', \\'make_name\\'])\\n```\\n\\nAfter grouping, the `.agg()` function will be applied to the grouped data. The `lead_id` and `partner_id` columns will be aggregated using the `nunique()` function to compute the number of unique elements within each group. This will give us the number of **unique leads** and **partners** for each group.\\n```\\ngroups.agg({\\n    \\'lead_id\\': pd.Series.nunique,\\n    \\'partner_id\\': pd.Series.nunique\\n  })\\n```\\nThen we will use the `.reset_index()` function to **rename** the aggregated columns. This will give us a new `DataFrame` with the following columns:\\n\\n- `date_id`: The date ID\\n- `make_name`: The make name\\n- `lead_id`: The number of unique leads\\n- `partner_id`: The number of unique partners\\n\\nFinally, we need to rename the columns `lead_id` to `unique_leads` and `partner_id` to `unique_partners`.\\n\\n``` python3\\ndf.rename(columns={\\n    \\'lead_id\\': \\'unique_leads\\',\\n    \\'partner_id\\': \\'unique_partners\\'\\n  })\\n```\\nFinally, the code looks like:\\n\\n``` python3 []\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n  groups = daily_sales.groupby([\\'date_id\\', \\'make_name\\'])\\n  df = groups.agg({\\n    \\'lead_id\\': pd.Series.nunique,\\n    \\'partner_id\\': pd.Series.nunique\\n  }).reset_index()\\n  return df.rename(columns={\\n    \\'lead_id\\': \\'unique_leads\\',\\n    \\'partner_id\\': \\'unique_partners\\'\\n  })\\n```",
                "solutionTags": [
                    "Python",
                    "MySQL",
                    "Pandas"
                ],
                "code": "``` SQL []\\n# Write your MySQL query statement below\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) as unique_leads,\\nCOUNT(DISTINCT partner_id) as unique_partners\\nFROM DailySales \\nGROUP BY date_id, make_name\\n```\n``` python3\\ngroups = daily_sales.groupby([\\'date_id\\', \\'make_name\\'])\\n```\n```\\ngroups.agg({\\n    \\'lead_id\\': pd.Series.nunique,\\n    \\'partner_id\\': pd.Series.nunique\\n  })\\n```\n``` python3\\ndf.rename(columns={\\n    \\'lead_id\\': \\'unique_leads\\',\\n    \\'partner_id\\': \\'unique_partners\\'\\n  })\\n```\n``` python3 []\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n  groups = daily_sales.groupby([\\'date_id\\', \\'make_name\\'])\\n  df = groups.agg({\\n    \\'lead_id\\': pd.Series.nunique,\\n    \\'partner_id\\': pd.Series.nunique\\n  }).reset_index()\\n  return df.rename(columns={\\n    \\'lead_id\\': \\'unique_leads\\',\\n    \\'partner_id\\': \\'unique_partners\\'\\n  })\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3135103,
                "title": "mysql-beginner-level-easy-to-understand-simple-short-solution",
                "content": "**Any suggestions and improvements are always welcome.**\\nRuntime: 870 ms\\nMemory Usage: 0B\\nBeats: 49.99%\\n- 2 group by clauses are used as we want to 1st group according to **date_id** first and then by **make_name**.\\n\\n\\u2705 MySQL Code :\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads,\\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;\\n```\\n\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads,\\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3011789,
                "title": "mysql-easy-solution",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT date_id, make_name, count(distinct(partner_id)) AS unique_leads ,count(distinct(lead_id )) AS unique_partners   \\nFROM DailySales\\nGROUP BY  make_name, date_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT date_id, make_name, count(distinct(partner_id)) AS unique_leads ,count(distinct(lead_id )) AS unique_partners   \\nFROM DailySales\\nGROUP BY  make_name, date_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2879540,
                "title": "mysql-easy-approach",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT date_id,make_name,COUNT(DISTINCT lead_id) AS unique_leads ,COUNT(DISTINCT partner_id) AS unique_partners FROM DailySales GROUP BY date_id,make_name;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT date_id,make_name,COUNT(DISTINCT lead_id) AS unique_leads ,COUNT(DISTINCT partner_id) AS unique_partners FROM DailySales GROUP BY date_id,make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2350865,
                "title": "beat-80-esay-count-distinct",
                "content": "```\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\n```\\nGive me an \"UP\" if it does help you  : )\\nAny feedback will motivate me to share more thoughts : )",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2161989,
                "title": "got-above-97-doesn-t-matter",
                "content": "## ***Noo ,Just No*** \\n**just copy the code** \\n![image](https://assets.leetcode.com/users/images/cd8b4599-0dfb-4942-a371-5a02643bb745_1655463102.8890667.gif)\\n\\n![image](https://assets.leetcode.com/users/images/366effaa-1999-4806-b1b8-e2ed9477a4b6_1655463025.8233614.png)\\n\\n```\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id)  \\'unique_leads\\', COUNT(DISTINCT partner_id) \\'unique_partners\\'\\nFROM DailySales\\nGROUP BY date_id,make_name;\\n```\\n",
                "solutionTags": [],
                "code": "```\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id)  \\'unique_leads\\', COUNT(DISTINCT partner_id) \\'unique_partners\\'\\nFROM DailySales\\nGROUP BY date_id,make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3849199,
                "title": "easy-solution-mysql-pandas-beats-100",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) as unique_leads, COUNT(DISTINCT partner_id) as unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\n```\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    daily_sales = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).nunique().reset_index().\\\\\\n    rename(columns={\\'lead_id\\':\\'unique_leads\\', \\'partner_id\\':\\'unique_partners\\'})\\n\\n    return daily_sales\\n```",
                "solutionTags": [
                    "MySQL",
                    "Pandas"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) as unique_leads, COUNT(DISTINCT partner_id) as unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\n```\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    daily_sales = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).nunique().reset_index().\\\\\\n    rename(columns={\\'lead_id\\':\\'unique_leads\\', \\'partner_id\\':\\'unique_partners\\'})\\n\\n    return daily_sales\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3724965,
                "title": "mysql-solution-for-daily-leads-and-partners-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to use the GROUP BY clause to group the rows of the DailySales table based on the date_id and make_name columns. This allows us to calculate the number of distinct lead_id\\'s and partner_id\\'s within each group.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe query uses the GROUP BY clause to group the rows of the DailySales table based on the date_id and make_name columns.\\n\\nWithin each group, we use the COUNT(DISTINCT lead_id) function to calculate the number of distinct lead_id\\'s and the COUNT(DISTINCT partner_id) function to calculate the number of distinct partner_id\\'s.\\n\\nThe result is a table with the date_id, make_name, unique_leads, and unique_partners columns, representing the distinct lead_id count and partner_id count for each date and make.\\n\\nThe query returns the result table in any order.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution depends on the number of rows in the DailySales table. If there are n rows in the table, the query will require traversing each row once to perform the grouping and calculate the distinct counts. Therefore, the time complexity is O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution depends on the number of distinct combinations of date_id and make_name in the DailySales table. The query will store the distinct combinations along with the corresponding counts in memory. If there are m distinct combinations, the space complexity is O(m).\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3374686,
                "title": "dailysales",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect date_id, make_name,\\ncount(distinct(lead_id)) as unique_leads, \\ncount(distinct(partner_id)) as unique_partners\\nfrom DailySales\\ngroup by date_id, make_name\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect date_id, make_name,\\ncount(distinct(lead_id)) as unique_leads, \\ncount(distinct(partner_id)) as unique_partners\\nfrom DailySales\\ngroup by date_id, make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3292595,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect date_id, make_name, \\ncount(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners \\nfrom DailySales group by date_id, make_name;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect date_id, make_name, \\ncount(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners \\nfrom DailySales group by date_id, make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3262848,
                "title": "easy-sql-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT date_id, make_name,\\nCOUNT(DISTINCT lead_id) AS unique_leads,\\nCOUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT date_id, make_name,\\nCOUNT(DISTINCT lead_id) AS unique_leads,\\nCOUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3090415,
                "title": "simple-query-daily-leads-and-partners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect date_id,make_name,count(distinct lead_id) as unique_leads, count( distinct partner_id) as unique_partners from DailySales group by date_id,make_name ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect date_id,make_name,count(distinct lead_id) as unique_leads, count( distinct partner_id) as unique_partners from DailySales group by date_id,make_name ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2942338,
                "title": "easy-to-understand-non-sql-programmer-as-well",
                "content": "\\n# Code\\n```\\nselect date_id, make_name, count(distinct(partner_id)) as unique_leads ,count(distinct(lead_id )) as unique_partners    from DailySales\\ngroup by  make_name, date_id\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect date_id, make_name, count(distinct(partner_id)) as unique_leads ,count(distinct(lead_id )) as unique_partners    from DailySales\\ngroup by  make_name, date_id\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2546677,
                "title": "1693-daily-leads-and-partners",
                "content": "```\\nSELECT  date_id,  make_name, \\nCOUNT(DISTINCT lead_id) AS unique_leads,  \\nCOUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT  date_id,  make_name, \\nCOUNT(DISTINCT lead_id) AS unique_leads,  \\nCOUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name",
                "codeTag": "Unknown"
            },
            {
                "id": 2468723,
                "title": "mysql-solution-using-group-by",
                "content": "Here we need to group the data using two columns - `date_id` and `make_name`.\\n\\nSolution:\\n```\\n# Write your MySQL query statement below\\nSELECT date_id, make_name, COUNT(DISTINCT(lead_id)) AS unique_leads, COUNT(DISTINCT(partner_id)) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;\\n```\\n\\nPlease **upvote** :)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT date_id, make_name, COUNT(DISTINCT(lead_id)) AS unique_leads, COUNT(DISTINCT(partner_id)) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2432679,
                "title": "simple-solution",
                "content": "```\\nselect date_id, make_name,  count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners\\nfrom dailysales\\ngroup by date_id, make_name;\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect date_id, make_name,  count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners\\nfrom dailysales\\ngroup by date_id, make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3971440,
                "title": "pandas-simple-step-by-step-solution-for-beginners",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    \\n    result = daily_sales.groupby([\\'date_id\\', \\'make_name\\']).nunique().reset_index()\\n    \\n    result.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n    \\n    return result\\n\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    \\n    result = daily_sales.groupby([\\'date_id\\', \\'make_name\\']).nunique().reset_index()\\n    \\n    result.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n    \\n    return result\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3857958,
                "title": "simple-mysql-solution-using-count",
                "content": "```\\nselect date_id,make_name,count(distinct lead_id) as unique_leads,\\ncount(distinct partner_id) as unique_partners \\nfrom DailySales\\ngroup by date_id,make_name\\n```\\n![upv.jpeg](https://assets.leetcode.com/users/images/8a8cbe40-eb58-4234-a6ca-d58c8d901479_1691063029.9170141.jpeg)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect date_id,make_name,count(distinct lead_id) as unique_leads,\\ncount(distinct partner_id) as unique_partners \\nfrom DailySales\\ngroup by date_id,make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3263906,
                "title": "solution-with-count-distinct-sql-server",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT\\n\\tdate_id,\\n\\tmake_name,\\n\\tCOUNT(DISTINCT LEAD_ID) unique_leads,\\n\\tCOUNT(DISTINCT partner_id) unique_partners\\nFROM\\n\\tDailySales\\nGROUP BY\\n\\t\\tdate_id,\\n\\t\\tmake_name\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT\\n\\tdate_id,\\n\\tmake_name,\\n\\tCOUNT(DISTINCT LEAD_ID) unique_leads,\\n\\tCOUNT(DISTINCT partner_id) unique_partners\\nFROM\\n\\tDailySales\\nGROUP BY\\n\\t\\tdate_id,\\n\\t\\tmake_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3258519,
                "title": "easy-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT date_id, make_name,\\nCOUNT(DISTINCT lead_id) AS unique_leads,\\nCOUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT date_id, make_name,\\nCOUNT(DISTINCT lead_id) AS unique_leads,\\nCOUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3248044,
                "title": "mysql-simple-solution-uwu",
                "content": "\\n```\\nSELECT \\n    date_id,\\n    make_name,\\n    COUNT(DISTINCT lead_id) AS unique_leads,\\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id,\\n    make_name;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    date_id,\\n    make_name,\\n    COUNT(DISTINCT lead_id) AS unique_leads,\\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id,\\n    make_name;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2634468,
                "title": "mysql-simple-solution",
                "content": "**select** date_id, make_name, count(distinct lead_id) as unique_leads,\\n\\t\\t\\t\\t\\t\\t\\t                count(distinct partner_id) as unique_partners\\n**from** DailySales\\n**group by** date_id, make_name\\n**order by** make_name desc, date_id desc",
                "solutionTags": [],
                "code": "**select** date_id, make_name, count(distinct lead_id) as unique_leads,\\n\\t\\t\\t\\t\\t\\t\\t                count(distinct partner_id) as unique_partners\\n**from** DailySales\\n**group by** date_id, make_name\\n**order by** make_name desc, date_id desc",
                "codeTag": "Unknown"
            },
            {
                "id": 2485390,
                "title": "mysql-simple-solution",
                "content": "select date_id, make_name, count(distinct(lead_id)) as unique_leads, count(distinct(partner_id)) as unique_partners\\nfrom DailySales\\ngroup by date_id, make_name",
                "solutionTags": [],
                "code": "select date_id, make_name, count(distinct(lead_id)) as unique_leads, count(distinct(partner_id)) as unique_partners\\nfrom DailySales\\ngroup by date_id, make_name",
                "codeTag": "Unknown"
            },
            {
                "id": 2372388,
                "title": "mysql-group-by-count-distinct",
                "content": "```\\n/*\\nSo so as we know that we want to find out the number of unique leads \\nand the number of unique partners on a given date made by a given \\nmaker therefore we will group the table on the basis of date_id and\\nmake_name and then we will count the number of distinct lead_id \\nand partner_id\\n*/\\n\\nSELECT date_id, make_name, COUNT(DISTINCT(lead_id)) AS unique_leads, \\nCOUNT(DISTINCT(partner_id)) AS unique_partners FROM DailySales\\nGROUP BY date_id,make_name\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n/*\\nSo so as we know that we want to find out the number of unique leads \\nand the number of unique partners on a given date made by a given \\nmaker therefore we will group the table on the basis of date_id and\\nmake_name and then we will count the number of distinct lead_id \\nand partner_id\\n*/\\n\\nSELECT date_id, make_name, COUNT(DISTINCT(lead_id)) AS unique_leads, \\nCOUNT(DISTINCT(partner_id)) AS unique_partners FROM DailySales\\nGROUP BY date_id,make_name\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2286382,
                "title": "simple-solution",
                "content": "select date_id, make_name, \\ncount(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners\\nfrom DailySales\\ngroup by 1, 2",
                "solutionTags": [],
                "code": "select date_id, make_name, \\ncount(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners\\nfrom DailySales\\ngroup by 1, 2",
                "codeTag": "Unknown"
            },
            {
                "id": 2103556,
                "title": "mysql-simple-solution-which-runs-optimally",
                "content": "\\n```\\n# Code Author Naveen Kumar Vadlamudi\\n\\nSELECT\\nDATE_ID,\\nMAKE_NAME,\\nCOUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS,\\nCOUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS\\n\\nFROM DAILYSALES\\n\\nGROUP BY \\n    DATE_ID, \\n    MAKE_NAME   \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Code Author Naveen Kumar Vadlamudi\\n\\nSELECT\\nDATE_ID,\\nMAKE_NAME,\\nCOUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS,\\nCOUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS\\n\\nFROM DAILYSALES\\n\\nGROUP BY \\n    DATE_ID, \\n    MAKE_NAME   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1952988,
                "title": "mysql-faster-than-96",
                "content": "```\\nselect \\n\\tdate_id , \\n\\tmake_name , \\n\\tcount(distinct lead_id) as unique_leads , \\n\\tcount(distinct partner_id) as unique_partners \\n\\nfrom DailySales \\ngroup by 1,2\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\n\\tdate_id , \\n\\tmake_name , \\n\\tcount(distinct lead_id) as unique_leads , \\n\\tcount(distinct partner_id) as unique_partners \\n\\nfrom DailySales \\ngroup by 1,2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1930528,
                "title": "simple-solution",
                "content": "if you like it please upvote\\n\\n```\\n\\nSELECT  date_id,  make_name, \\nCOUNT(DISTINCT lead_id) as unique_leads,\\nCOUNT( DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY make_name DESC, date_id DESC\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nSELECT  date_id,  make_name, \\nCOUNT(DISTINCT lead_id) as unique_leads,\\nCOUNT( DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY make_name DESC, date_id DESC\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008282,
                "title": "simple-mssql",
                "content": "```\\nselect date_id, make_name, count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners \\nfrom DailySales\\ngroup by date_id, make_name\\n```",
                "solutionTags": [],
                "code": "```\\nselect date_id, make_name, count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners \\nfrom DailySales\\ngroup by date_id, make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 981140,
                "title": "mssql-simple-solution",
                "content": "```\\nselect  date_id, \\n        make_name, \\n        count(distinct lead_id)as unique_leads, \\n        count(distinct partner_id)as unique_partners from DailySales\\ngroup by date_id, make_name\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect  date_id, \\n        make_name, \\n        count(distinct lead_id)as unique_leads, \\n        count(distinct partner_id)as unique_partners from DailySales\\ngroup by date_id, make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072981,
                "title": "pandas-sql-easy-daily-leads-and-partners",
                "content": "[see the Successfully Accepted Submission](https://leetcode.com/submissions/detail/1055505573/)\\n\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame: \\n   \\n    # First, we group the rows in a DataFrame called daily_sales by two columns: \"date_id\" and \"make_name.\" The rows are grouped based on the unique combinations of values in the \"date_id\" and \"make_name\" columns.\\n    grouped_daily_sales = daily_sales.groupby([\\'date_id\\', \\'make_name\\'])\\n\\n    # Then, we calculate two aggregations: the count of unique values in the \"lead_id\" column, and the count of unique values in the \"partner_id\" column\\n    statistics_daily_sales = grouped_daily_sales.agg(\\n    unique_leads = (\\'lead_id\\', \\'nunique\\'),\\n    unique_partners = (\\'partner_id\\', \\'nunique\\')\\n    )\\n    \\n    # Finally, we move the current index back to regular row labels. And we add a new default integer index to the `daily_sales` DataFrame.\\n    unique_sales = statistics_daily_sales.reset_index()\\n    \\n    return unique_sales\\n```\\n\\n**SQL**\\n\\n[see the Successfully Accepted Submission](https://leetcode.com/submissions/detail/1061727235/)\\n\\n```\\n\\nSELECT date_id, make_name, \\nCOUNT(DISTINCT lead_id) AS unique_leads, \\nCOUNT(DISTINCT partner_id) AS unique_partners\\n\\nFROM DailySales\\n\\nGROUP BY date_id, make_name\\nORDER BY date_id, make_name;\\n```\\n\\n```\\n-- Select \\'date_id\\', \\'make_name\\', count of distinct \\'lead_id\\' as \\'unique_leads\\',\\n-- and count of distinct \\'partner_id\\' as \\'unique_partners\\'\\nSELECT date_id, make_name, \\n       COUNT(DISTINCT lead_id) AS unique_leads, \\n       COUNT(DISTINCT partner_id) AS unique_partners\\n\\n-- Retrieve data from the \\'DailySales\\' table\\nFROM DailySales\\n\\n-- Group the results by \\'date_id\\' and \\'make_name\\' to aggregate data for each date and car make\\nGROUP BY date_id, make_name\\n\\n-- Order the results first by \\'date_id\\' in ascending order and then by \\'make_name\\' in ascending order\\nORDER BY date_id, make_name;\\n```\\n\\n![image](https://assets.leetcode.com/users/images/a8aa3df2-8db5-4948-8a09-c9a12aa2f114_1695309142.9440582.jpeg)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame: \\n   \\n    # First, we group the rows in a DataFrame called daily_sales by two columns: \"date_id\" and \"make_name.\" The rows are grouped based on the unique combinations of values in the \"date_id\" and \"make_name\" columns.\\n    grouped_daily_sales = daily_sales.groupby([\\'date_id\\', \\'make_name\\'])\\n\\n    # Then, we calculate two aggregations: the count of unique values in the \"lead_id\" column, and the count of unique values in the \"partner_id\" column\\n    statistics_daily_sales = grouped_daily_sales.agg(\\n    unique_leads = (\\'lead_id\\', \\'nunique\\'),\\n    unique_partners = (\\'partner_id\\', \\'nunique\\')\\n    )\\n    \\n    # Finally, we move the current index back to regular row labels. And we add a new default integer index to the `daily_sales` DataFrame.\\n    unique_sales = statistics_daily_sales.reset_index()\\n    \\n    return unique_sales\\n```\n```\\n\\nSELECT date_id, make_name, \\nCOUNT(DISTINCT lead_id) AS unique_leads, \\nCOUNT(DISTINCT partner_id) AS unique_partners\\n\\nFROM DailySales\\n\\nGROUP BY date_id, make_name\\nORDER BY date_id, make_name;\\n```\n```\\n-- Select \\'date_id\\', \\'make_name\\', count of distinct \\'lead_id\\' as \\'unique_leads\\',\\n-- and count of distinct \\'partner_id\\' as \\'unique_partners\\'\\nSELECT date_id, make_name, \\n       COUNT(DISTINCT lead_id) AS unique_leads, \\n       COUNT(DISTINCT partner_id) AS unique_partners\\n\\n-- Retrieve data from the \\'DailySales\\' table\\nFROM DailySales\\n\\n-- Group the results by \\'date_id\\' and \\'make_name\\' to aggregate data for each date and car make\\nGROUP BY date_id, make_name\\n\\n-- Order the results first by \\'date_id\\' in ascending order and then by \\'make_name\\' in ascending order\\nORDER BY date_id, make_name;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3973337,
                "title": "pandas-solution-using-groupby",
                "content": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return daily_sales.groupby([\"date_id\", \"make_name\"])[[\"lead_id\", \"partner_id\"]].nunique().reset_index().rename(columns={\"lead_id\": \"unique_leads\", \"partner_id\": \"unique_partners\"})\\n```",
                "solutionTags": [],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return daily_sales.groupby([\"date_id\", \"make_name\"])[[\"lead_id\", \"partner_id\"]].nunique().reset_index().rename(columns={\"lead_id\": \"unique_leads\", \"partner_id\": \"unique_partners\"})\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3965764,
                "title": "easy-mysql-solution-with-low-memory-usage-and-runtime-approach-explained",
                "content": "# Runtime Details\\n1081ms\\nBeats 81.36% of users with MySQL\\n# Memory Details\\n0.00MB\\nBeats 100.00%of users with MySQL\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFrom the question,\\n1. For each date_id and make_name --> Indicates to use **group by** \\n2. find the number of distinct lead_id\\'s and distinct partner_id\\'s --> Indicates to **count distinct** records for lead_id and partner_id\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect date_id , make_name , count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners from DailySales group by date_id,make_name\\n```\\n\\n# Please upvote",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect date_id , make_name , count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners from DailySales group by date_id,make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3891200,
                "title": "mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect date_id,make_name,count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners from DailySales group by date_id,make_name\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect date_id,make_name,count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners from DailySales group by date_id,make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853252,
                "title": "pandas-solution-memory-beats-100",
                "content": "# Intuition\\n.nunique() calculates the number of unique values in each column of the DataFrame\\n\\n# Memory\\n61.77 mb\\nBeats 100.00% of users with Pandas\\n\\n# Runtime\\n348 ms\\nBeats 94.12% of users with Pandas\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return (\\n        daily_sales\\n        .groupby([\\'date_id\\', \\'make_name\\'])\\n        .nunique()\\n        .reset_index()\\n        .rename(columns={\\'lead_id\\':\\'unique_leads\\', \\'partner_id\\':\\'unique_partners\\'})\\n        )\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return (\\n        daily_sales\\n        .groupby([\\'date_id\\', \\'make_name\\'])\\n        .nunique()\\n        .reset_index()\\n        .rename(columns={\\'lead_id\\':\\'unique_leads\\', \\'partner_id\\':\\'unique_partners\\'})\\n        )\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3821302,
                "title": "pandas-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\nimport numpy as np\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    daily_sales = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).nunique().reset_index().\\\\\\n    rename(columns={\\'lead_id\\':\\'unique_leads\\', \\'partner_id\\':\\'unique_partners\\'})\\n\\n    return daily_sales\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\nimport numpy as np\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    daily_sales = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).nunique().reset_index().\\\\\\n    rename(columns={\\'lead_id\\':\\'unique_leads\\', \\'partner_id\\':\\'unique_partners\\'})\\n\\n    return daily_sales\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3303981,
                "title": "sql-server-clean-easy",
                "content": "```\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) as unique_leads, COUNT(DISTINCT partner_id) as unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id, make_name;\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) as unique_leads, COUNT(DISTINCT partner_id) as unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id, make_name;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3265276,
                "title": "easy-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT date_id, make_name, \\nCOUNT(DISTINCT lead_id) AS unique_leads, \\nCOUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT date_id, make_name, \\nCOUNT(DISTINCT lead_id) AS unique_leads, \\nCOUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2989005,
                "title": "mysql-fast-and-easy-solution",
                "content": "# Intuition\\nMYSQL FAST AND EASY SOLUTION\\n\\n# Code\\n```\\nSELECT date_id, make_name,\\nCOUNT(DISTINCT lead_id, date_id) AS unique_leads,\\nCOUNT(DISTINCT partner_id, date_id) AS unique_partners\\nFROM DailySales \\nGROUP BY date_id, make_name\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT date_id, make_name,\\nCOUNT(DISTINCT lead_id, date_id) AS unique_leads,\\nCOUNT(DISTINCT partner_id, date_id) AS unique_partners\\nFROM DailySales \\nGROUP BY date_id, make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2709401,
                "title": "easy-to-understand-one-linear-formatted-code",
                "content": "```\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners FROM DailySales GROUP BY date_id,make_name\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners FROM DailySales GROUP BY date_id,make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2645928,
                "title": "simple-solution",
                "content": "```\\nselect date_id ,make_name,count(distinct lead_id) as unique_leads ,count(distinct partner_id) as unique_partners from DailySales group by date_id,make_name;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect date_id ,make_name,count(distinct lead_id) as unique_leads ,count(distinct partner_id) as unique_partners from DailySales group by date_id,make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2541539,
                "title": "easy-mysql-solution-simple-to-understand",
                "content": "\\tselect date_id, make_name, \\n\\t\\tcount(distinct lead_id) as unique_leads,\\n\\t\\tcount(distinct partner_id) as unique_partners\\n\\n\\tfrom DailySales \\n\\tgroup by date_id, make_name; \\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tselect date_id, make_name, \\n\\t\\tcount(distinct lead_id) as unique_leads,\\n\\t\\tcount(distinct partner_id) as unique_partners\\n\\n\\tfrom DailySales \\n\\tgroup by date_id, make_name; \\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "codeTag": "Unknown"
            },
            {
                "id": 2471478,
                "title": "simple-one-group-by-clause-98-faster",
                "content": "select date_id,make_name,count(distinct(lead_id)) as unique_leads ,count(distinct(partner_id)) as unique_partners\\nfrom DailySales\\ngroup by date_id,make_name",
                "solutionTags": [],
                "code": "select date_id,make_name,count(distinct(lead_id)) as unique_leads ,count(distinct(partner_id)) as unique_partners\\nfrom DailySales\\ngroup by date_id,make_name",
                "codeTag": "Unknown"
            },
            {
                "id": 2470172,
                "title": "mysql-simple-solution-count-distinct",
                "content": "In this problem we have to write an SQL query that will **for each date_id and make_name, return the number of distinct lead_id\\'s and distinct partner_id\\'s.**\\n.\\n.\\n.\\nThus to count the total distinct numbers I have used the **COUNT** and **DISTINCT** methods in MySQL\\n.\\n.\\n```SQL\\nSELECT date_id,make_name,COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\n```\\n.\\n.\\nHere I have first used the **DISTINCT method to take only unique values and then using COUNT method I\\'ve counted the total numbewr of distinct values.** \\n.\\n.\\n.\\nThen we are also required to group them. Thus I have done that using the **GROUP BY clause**.\\n```SQL\\nGROUP BY date_id,make_name;\\n```\\n.\\n.\\n.\\n**Complete code is given below:**\\n```SQL\\n# Write your MySQL query statement below\\n\\n# Here I have first used the **DISTINCT method to take only unique values and then using COUNT method I\\'ve counted the total numbewr of distinct values.**\\nSELECT date_id,make_name,COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\n\\nFROM DailySales\\n\\n# Then we are also required to group them. Thus I have done that using the GROUP BY clause.\\nGROUP BY date_id,make_name;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```SQL\\nSELECT date_id,make_name,COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\n```\n```SQL\\nGROUP BY date_id,make_name;\\n```\n```SQL\\n# Write your MySQL query statement below\\n\\n# Here I have first used the **DISTINCT method to take only unique values and then using COUNT method I\\'ve counted the total numbewr of distinct values.**\\nSELECT date_id,make_name,COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\n\\nFROM DailySales\\n\\n# Then we are also required to group them. Thus I have done that using the GROUP BY clause.\\nGROUP BY date_id,make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2444416,
                "title": "easy-solution-faster-than-96-48-mysql",
                "content": "```\\nSELECT date_id, make_name, \\nCOUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners \\nFROM dailysales GROUP BY date_id, make_name;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT date_id, make_name, \\nCOUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners \\nFROM dailysales GROUP BY date_id, make_name;",
                "codeTag": "Unknown"
            },
            {
                "id": 2441258,
                "title": "mysql-distinct-count-and-group-by",
                "content": "```\\nselect date_id,make_name,count(distinct lead_id) as unique_leads,count(distinct partner_id) as unique_partners from DailySales\\ngroup by date_id,make_name;",
                "solutionTags": [],
                "code": "```\\nselect date_id,make_name,count(distinct lead_id) as unique_leads,count(distinct partner_id) as unique_partners from DailySales\\ngroup by date_id,make_name;",
                "codeTag": "Unknown"
            },
            {
                "id": 2439600,
                "title": "mysql-solution",
                "content": "```\\nSELECT \\n    date_id,\\n    make_name,\\n    COUNT(DISTINCT(lead_id)) AS unique_leads,\\n    COUNT(DISTINCT(partner_id)) AS unique_partners\\nFROM\\n     DailySales\\nGROUP BY \\n    date_id, make_name\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    date_id,\\n    make_name,\\n    COUNT(DISTINCT(lead_id)) AS unique_leads,\\n    COUNT(DISTINCT(partner_id)) AS unique_partners\\nFROM\\n     DailySales\\nGROUP BY \\n    date_id, make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2430945,
                "title": "mysql-simple-intitutive-solution-using-distinct-count",
                "content": "```\\nSELECT  date_id, make_name, \\n\\t\\t\\tcount(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners \\nfrom DailySales \\ngroup by date_id, make_name;\\n````\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT  date_id, make_name, \\n\\t\\t\\tcount(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners \\nfrom DailySales \\ngroup by date_id, make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2428783,
                "title": "easy-solution",
                "content": "```\\nselect date_id, make_name, \\ncount(distinct lead_id) as unique_leads, \\ncount(distinct partner_id) as unique_partners\\nfrom dailysales group by date_id, make_name;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect date_id, make_name, \\ncount(distinct lead_id) as unique_leads, \\ncount(distinct partner_id) as unique_partners\\nfrom dailysales group by date_id, make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2426442,
                "title": "simple-mysql-solution-use-of-count-distinct",
                "content": "```\\nselect date_id, make_name, count(distinct(lead_id)) as unique_leads, count(distinct(partner_id)) as unique_partners from DailySales\\ngroup by date_id, make_name;",
                "solutionTags": [],
                "code": "```\\nselect date_id, make_name, count(distinct(lead_id)) as unique_leads, count(distinct(partner_id)) as unique_partners from DailySales\\ngroup by date_id, make_name;",
                "codeTag": "Unknown"
            },
            {
                "id": 2378021,
                "title": "mysql-group-by-count-easy-to-understand",
                "content": "```\\nselect date_id,make_name,count(distinct(lead_id)) as unique_leads,count(distinct(partner_id)) as unique_partners \\nfrom DailySales \\ngroup by date_id,make_name; \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect date_id,make_name,count(distinct(lead_id)) as unique_leads,count(distinct(partner_id)) as unique_partners \\nfrom DailySales \\ngroup by date_id,make_name; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2359099,
                "title": "simple-count-buddy",
                "content": "# ***<<-- upvote***\\n\\n```\\nselect date_id, make_name, count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners from dailysales \\ngroup by date_id,make_name;\\n```",
                "solutionTags": [],
                "code": "```\\nselect date_id, make_name, count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners from dailysales \\ngroup by date_id,make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2319711,
                "title": "mysql-solution-easy-to-understand-group-by-subquery",
                "content": "```\\nSELECT\\n    date_id,\\n    make_name,\\n    COUNT(DISTINCT lead_id) AS unique_leads,\\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM\\n    DailySales\\nGROUP BY\\n    date_id,\\n    make_name;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    date_id,\\n    make_name,\\n    COUNT(DISTINCT lead_id) AS unique_leads,\\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM\\n    DailySales\\nGROUP BY\\n    date_id,\\n    make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2256192,
                "title": "easy-mysql-solution-distinct-count",
                "content": "```\\nselect date_id, make_name,\\ncount(distinct lead_id) as unique_leads,\\ncount(distinct partner_id) as unique_partners\\nfrom DailySales \\ngroup by date_id, make_name\\n\\n```\\n\\n**Please UpVote if it was Helpful :)**\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect date_id, make_name,\\ncount(distinct lead_id) as unique_leads,\\ncount(distinct partner_id) as unique_partners\\nfrom DailySales \\ngroup by date_id, make_name\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2189254,
                "title": "mysql-simple-solution-with-group-by-count",
                "content": "```# Write your MySQL query statement below\\nselect\\ndate_id,\\nmake_name,\\ncount(distinct lead_id) as unique_leads,\\ncount(distinct partner_id) as unique_partners\\n\\nfrom dailysales\\ngroup by date_id, make_name",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```# Write your MySQL query statement below\\nselect\\ndate_id,\\nmake_name,\\ncount(distinct lead_id) as unique_leads,\\ncount(distinct partner_id) as unique_partners\\n\\nfrom dailysales\\ngroup by date_id, make_name",
                "codeTag": "Unknown"
            },
            {
                "id": 2178722,
                "title": "3-lines-code",
                "content": "```\\nSELECT date_id,make_name,count(distinct lead_id) AS unique_leads,count(distinct partner_id) AS unique_partners\\n\\nFROM DailySales \\nGROUP BY date_id,make_name ;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT date_id,make_name,count(distinct lead_id) AS unique_leads,count(distinct partner_id) AS unique_partners\\n\\nFROM DailySales \\nGROUP BY date_id,make_name ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2146451,
                "title": "faster-than-79-23-simple-count-and-group-by",
                "content": "```\\nSELECT date_id, make_name, \\n\\tCOUNT(DISTINCT lead_id) AS unique_leads, \\n\\tCOUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT date_id, make_name, \\n\\tCOUNT(DISTINCT lead_id) AS unique_leads, \\n\\tCOUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2139526,
                "title": "simple-group-by-accepted-solution",
                "content": "select date_id, make_name,count(distinct lead_id) as \\'unique_leads\\',\\ncount(distinct partner_id) as \\'unique_partners\\'\\nfrom DailySales\\ngroup by date_id, make_name\\norder by make_name desc",
                "solutionTags": [],
                "code": "select date_id, make_name,count(distinct lead_id) as \\'unique_leads\\',\\ncount(distinct partner_id) as \\'unique_partners\\'\\nfrom DailySales\\ngroup by date_id, make_name\\norder by make_name desc",
                "codeTag": "Unknown"
            },
            {
                "id": 2098160,
                "title": "sql-easy-query-100",
                "content": "```\\nselect date_id,make_name,\\ncount(distinct(lead_id)) as unique_leads,\\ncount(distinct(partner_id)) as unique_partners\\nfrom DailySales\\ngroup by date_id,make_name;```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect date_id,make_name,\\ncount(distinct(lead_id)) as unique_leads,\\ncount(distinct(partner_id)) as unique_partners\\nfrom DailySales\\ngroup by date_id,make_name;```",
                "codeTag": "Unknown"
            },
            {
                "id": 2064354,
                "title": "simple-mysql-solution",
                "content": "```\\n# Write your MySQL query statement below\\nselect date_id, make_name, count(distinct lead_id) As unique_leads, count(distinct partner_id) as unique_partners\\nfrom DailySales\\ngroup by date_id, make_name\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect date_id, make_name, count(distinct lead_id) As unique_leads, count(distinct partner_id) as unique_partners\\nfrom DailySales\\ngroup by date_id, make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2047747,
                "title": "solution-in-mysql-easy",
                "content": "```\\n# Write your MySQL query statement below\\nselect ds.date_id, ds.make_name, count(distinct(ds.lead_id)) as unique_leads, count(distinct(ds.partner_id)) as unique_partners\\nfrom DailySales ds\\ngroup by ds.date_id, ds.make_name\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect ds.date_id, ds.make_name, count(distinct(ds.lead_id)) as unique_leads, count(distinct(ds.partner_id)) as unique_partners\\nfrom DailySales ds\\ngroup by ds.date_id, ds.make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2028629,
                "title": "simple-sql-solution",
                "content": "```\\nselect \\ndate_id, make_name, count(distinct(lead_id)) as unique_leads, count(distinct(partner_id)) as unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect \\ndate_id, make_name, count(distinct(lead_id)) as unique_leads, count(distinct(partner_id)) as unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2001457,
                "title": "mysql-fast-and-simple-solution",
                "content": "```\\nSelect date_id, make_name, Count(DISTINCT lead_id) as unique_leads, Count(DISTINCT partner_id) as unique_partners\\nFrom DailySales\\nGroup By date_id, make_name\\n```",
                "solutionTags": [],
                "code": "```\\nSelect date_id, make_name, Count(DISTINCT lead_id) as unique_leads, Count(DISTINCT partner_id) as unique_partners\\nFrom DailySales\\nGroup By date_id, make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1974330,
                "title": "easy-to-understand-sql",
                "content": "```\\nselect\\n    date_id,\\n    make_name,\\n    count(distinct lead_id) as unique_leads,\\n    count(distinct partner_id) as unique_partners\\nfrom\\n    dailySales\\ngroup by\\n    make_name, date_id;\\n```\\n\\nIf you have any **doubts**, feel **free to ask**...\\nIf you understand the **concept**. Don\\'t Forget to **upvote** \\uD83D\\uDE0A\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\n    date_id,\\n    make_name,\\n    count(distinct lead_id) as unique_leads,\\n    count(distinct partner_id) as unique_partners\\nfrom\\n    dailySales\\ngroup by\\n    make_name, date_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1960575,
                "title": "mysql-easy-implementation",
                "content": "```\\nSELECT date_id, make_name , COUNT(DISTINCT lead_id) AS unique_leads, COUNT(distinct partner_id)AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT date_id, make_name , COUNT(DISTINCT lead_id) AS unique_leads, COUNT(distinct partner_id)AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1881073,
                "title": "beginner-friendly-sql-solution",
                "content": "```\\n# Write your MySQL query statement below\\nselect\\n    date_id,\\n    make_name,\\n    count(distinct lead_id) as unique_leads,\\n    count(distinct partner_id) as unique_partners\\nfrom DailySales\\ngroup by date_id, make_name\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect\\n    date_id,\\n    make_name,\\n    count(distinct lead_id) as unique_leads,\\n    count(distinct partner_id) as unique_partners\\nfrom DailySales\\ngroup by date_id, make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1670026,
                "title": "best-mysql-sol",
                "content": "select date_id, make_name,\\ncount(distinct lead_id)as unique_leads,\\ncount(distinct partner_id) as unique_partners\\nfrom DailySales\\ngroup by date_id, make_name",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select date_id, make_name,\\ncount(distinct lead_id)as unique_leads,\\ncount(distinct partner_id) as unique_partners\\nfrom DailySales\\ngroup by date_id, make_name",
                "codeTag": "Unknown"
            },
            {
                "id": 1176065,
                "title": "oracle",
                "content": "```\\nselect to_char(date_id, \\'yyyy-mm-dd\\') date_id, make_name, count(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom dailysales\\ngroup by date_id, make_name\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\nselect to_char(date_id, \\'yyyy-mm-dd\\') date_id, make_name, count(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom dailysales\\ngroup by date_id, make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1079948,
                "title": "easy-solution-using-group-by",
                "content": "```\\n# Write your MySQL query statement below\\n\\nselect \\n\\t,date_id\\n\\t,make_name\\n\\t,count(distinct lead_id) as unique_leads\\n\\t,count(distinct partner_id) as unique_partners\\nfrom dailysales \\ngroup by date_id, make_name",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect \\n\\t,date_id\\n\\t,make_name\\n\\t,count(distinct lead_id) as unique_leads\\n\\t,count(distinct partner_id) as unique_partners\\nfrom dailysales \\ngroup by date_id, make_name",
                "codeTag": "Unknown"
            },
            {
                "id": 1035222,
                "title": "mysql-count-distinct",
                "content": "\\n```\\nSELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY 1, 2\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY 1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1006975,
                "title": "mysql-count-distinct",
                "content": "```\\nSELECT date_id, make_name, COUNT( DISTINCT lead_id) AS unique_leads,\\n       COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT date_id, make_name, COUNT( DISTINCT lead_id) AS unique_leads,\\n       COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 983592,
                "title": "simple-mysql-solution",
                "content": "```\\nSELECT\\n    date_id,\\n    make_name,\\n    COUNT(DISTINCT lead_id) AS unique_leads,\\n    COUNT(DISTINCT partner_id) AS unique_partners\\n\\nFROM DailySales\\nGROUP BY date_id, make_name\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    date_id,\\n    make_name,\\n    COUNT(DISTINCT lead_id) AS unique_leads,\\n    COUNT(DISTINCT partner_id) AS unique_partners\\n\\nFROM DailySales\\nGROUP BY date_id, make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 976633,
                "title": "mysql-count-group-by",
                "content": "```\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM dailysales \\nGROUP BY date_id, make_name\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM dailysales \\nGROUP BY date_id, make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 976618,
                "title": "simple-group-by-multiple-attributes",
                "content": "```\\nselect date_id, make_name, count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;\\n",
                "solutionTags": [],
                "code": "```\\nselect date_id, make_name, count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4101070,
                "title": "mysql-solution",
                "content": "# Success--Runtime: 1028 ms, faster than 87.47% of MySQL online submissions for Daily Leads and Partners.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Daily Leads and Partners.***\\n\\n\\n# Write your MySQL query statement below\\nselect date_id,make_name,count(distinct lead_id) as unique_leads,count(distinct partner_id) as unique_partners from DailySales group by date_id,make_name",
                "solutionTags": [],
                "code": "# Success--Runtime: 1028 ms, faster than 87.47% of MySQL online submissions for Daily Leads and Partners.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Daily Leads and Partners.***\\n\\n\\n# Write your MySQL query statement below\\nselect date_id,make_name,count(distinct lead_id) as unique_leads,count(distinct partner_id) as unique_partners from DailySales group by date_id,make_name",
                "codeTag": "Unknown"
            },
            {
                "id": 4099543,
                "title": "group-by-two-columns",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect date_id,make_name ,count(distinct lead_id) as unique_leads,count(distinct partner_id) as unique_partners\\nfrom DailySales\\ngroup by date_id,make_name\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect date_id,make_name ,count(distinct lead_id) as unique_leads,count(distinct partner_id) as unique_partners\\nfrom DailySales\\ngroup by date_id,make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4095028,
                "title": "beginners-friendly-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolve using distinct and group by clause.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we have to group given table by date_id and make_name.\\n\\nThen we can display distinct date_id and make_name and finally count of distinct lead_id and partner_ids.\\n\\nChange names of last two columns to unique_leads and unique_partners.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\nselect distinct date_id, make_name, count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners from dailysales group by date_id,make_name;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\nselect distinct date_id, make_name, count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners from dailysales group by date_id,make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084743,
                "title": "simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT date_id, make_name, COUNT( distinct lead_id) as unique_leads, COUNT(distinct partner_id) as unique_partners\\nFROM dailysales\\nGROUP BY date_id, make_name\\nORDER BY make_name DESC\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT date_id, make_name, COUNT( distinct lead_id) as unique_leads, COUNT(distinct partner_id) as unique_partners\\nFROM dailysales\\nGROUP BY date_id, make_name\\nORDER BY make_name DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4073282,
                "title": "database",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072410,
                "title": "pandas-groupby-nunique",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Groupby \\'date_id\\' and \\'make_name\\' because that is what the output requirement is.\\n2. Find number of unique items in \\'lead_id\\',\\'partner_id\\' cols using nunique()\\n3. Rename cols to match output table and return df \\n\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n\\n    # groupby \\'date_id\\', \\'make_name\\' and \\n    # find number of unique items in \\'lead_id\\', \\'partner_id\\' columns\\n    df = daily_sales.groupby([\\'date_id\\',\\'make_name\\'])[[\\'lead_id\\',\\'partner_id\\']].nunique().reset_index()\\n\\n    # rename cols to match output\\n    df.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n    return df\\n```",
                "solutionTags": [
                    "Python3",
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n\\n    # groupby \\'date_id\\', \\'make_name\\' and \\n    # find number of unique items in \\'lead_id\\', \\'partner_id\\' columns\\n    df = daily_sales.groupby([\\'date_id\\',\\'make_name\\'])[[\\'lead_id\\',\\'partner_id\\']].nunique().reset_index()\\n\\n    # rename cols to match output\\n    df.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n    return df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4072195,
                "title": "two-easy-approaches-beats-90-users",
                "content": "## Solution 1: Complex but better performing\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    # Use the agg function to calculate unique counts directly in one step\\n    result = daily_sales.groupby([\\'date_id\\', \\'make_name\\']).agg(\\n        unique_leads=(\\'lead_id\\', \\'nunique\\'),\\n        unique_partners=(\\'partner_id\\', \\'nunique\\')\\n    ).reset_index()\\n\\n    return result\\n```\\n\\n\\n\\n## Solution 2: Easy to understand but not that optimised\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    #Grouping by \\'date_id\\' and \\'make_name\\' and applying nunique function to get the no. of distinct values\\n    df = daily_sales.groupby(by=[\\'date_id\\',\\'make_name\\']).agg({\\'lead_id\\':\\'nunique\\',\\'partner_id\\':\\'nunique\\'}).reset_index()\\n\\n    #Renaming the columns\\n    df.columns = [\\'date_id\\',\\'make_name\\',\\'unique_leads\\',\\'unique_partners\\']\\n\\n    return df\\n```\\n\\n#### \\uD83D\\uDE0A If you like the solution please upvote!\\uD83D\\uDC4D\\uD83D\\uDE0A",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    # Use the agg function to calculate unique counts directly in one step\\n    result = daily_sales.groupby([\\'date_id\\', \\'make_name\\']).agg(\\n        unique_leads=(\\'lead_id\\', \\'nunique\\'),\\n        unique_partners=(\\'partner_id\\', \\'nunique\\')\\n    ).reset_index()\\n\\n    return result\\n```\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    #Grouping by \\'date_id\\' and \\'make_name\\' and applying nunique function to get the no. of distinct values\\n    df = daily_sales.groupby(by=[\\'date_id\\',\\'make_name\\']).agg({\\'lead_id\\':\\'nunique\\',\\'partner_id\\':\\'nunique\\'}).reset_index()\\n\\n    #Renaming the columns\\n    df.columns = [\\'date_id\\',\\'make_name\\',\\'unique_leads\\',\\'unique_partners\\']\\n\\n    return df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4070543,
                "title": "pandas-groupby-and-agg-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    result = daily_sales.groupby(by = [\\'date_id\\', \\'make_name\\']).agg({\\'lead_id\\':\\'nunique\\', \\'partner_id\\':\\'nunique\\'}).reset_index()\\n\\n    result.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n\\n    return result\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    result = daily_sales.groupby(by = [\\'date_id\\', \\'make_name\\']).agg({\\'lead_id\\':\\'nunique\\', \\'partner_id\\':\\'nunique\\'}).reset_index()\\n\\n    result.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n\\n    return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4048645,
                "title": "beats-96-15-with-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement bel\\nselect date_id,make_name, count(distinct(lead_id)) as unique_leads, count(distinct(partner_id)) as unique_partners from DailySales \\ngroup by date_id,make_name;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement bel\\nselect date_id,make_name, count(distinct(lead_id)) as unique_leads, count(distinct(partner_id)) as unique_partners from DailySales \\ngroup by date_id,make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048512,
                "title": "easy-solution-beginner-friendly",
                "content": "# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect \\n    to_char(date_id, \\'yyyy-mm-dd\\') as date_id,\\n    make_name, \\n    count(distinct lead_id) as unique_leads,\\n    count(distinct partner_id) as unique_partners \\nfrom\\n    dailysales\\ngroup by  \\n    to_char(date_id, \\'yyyy-mm-dd\\'), make_name\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect \\n    to_char(date_id, \\'yyyy-mm-dd\\') as date_id,\\n    make_name, \\n    count(distinct lead_id) as unique_leads,\\n    count(distinct partner_id) as unique_partners \\nfrom\\n    dailysales\\ngroup by  \\n    to_char(date_id, \\'yyyy-mm-dd\\'), make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045725,
                "title": "pandas-groupie-agg",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind unique leads and partners for each pair group of date & name\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1- Group by `date_id` & `make_name`\\n2- Aggregate `lead_id` & `partner_id` by counting unique entries\\n3- Rename `lead_id` to `unique_leads` and `partner_id` to `unique_partners`\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return daily_sales.groupby([\\'date_id\\',\\'make_name\\']).\\\\\\n                agg(unique_leads=(\\'lead_id\\',\\'nunique\\'),\\n                unique_partners=(\\'partner_id\\',\\'nunique\\')).\\\\\\n                reset_index()\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return daily_sales.groupby([\\'date_id\\',\\'make_name\\']).\\\\\\n                agg(unique_leads=(\\'lead_id\\',\\'nunique\\'),\\n                unique_partners=(\\'partner_id\\',\\'nunique\\')).\\\\\\n                reset_index()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4038416,
                "title": "pandas-group-by-with-nunique",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Group by on date id and make name\\n2. Then aggregate using **nunique** function to get the unique counts for both leand and partner id. \\n\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    df=daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg({\\'lead_id\\':\\'nunique\\', \\'partner_id\\':\\'nunique\\'}).reset_index()\\n\\n    df.rename(columns={\\'lead_id\\':\\'unique_leads\\', \\'partner_id\\':\\'unique_partners\\'}, inplace=True)\\n    return df\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    df=daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg({\\'lead_id\\':\\'nunique\\', \\'partner_id\\':\\'nunique\\'}).reset_index()\\n\\n    df.rename(columns={\\'lead_id\\':\\'unique_leads\\', \\'partner_id\\':\\'unique_partners\\'}, inplace=True)\\n    return df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4032438,
                "title": "using-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect date_id,make_name,count(distinct lead_id) as unique_leads,count(distinct partner_id) as unique_partners from dailysales\\ngroup by date_id,make_name\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect date_id,make_name,count(distinct lead_id) as unique_leads,count(distinct partner_id) as unique_partners from dailysales\\ngroup by date_id,make_name\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4029172,
                "title": "easy-solution-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT DATE_ID,MAKE_NAME,COUNT(DISTINCT LEAD_ID) AS unique_leads,COUNT(DISTINCT PARTNER_ID) AS unique_partners FROM DAILYSALES GROUP BY  DATE_ID,MAKE_NAME;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DATE_ID,MAKE_NAME,COUNT(DISTINCT LEAD_ID) AS unique_leads,COUNT(DISTINCT PARTNER_ID) AS unique_partners FROM DAILYSALES GROUP BY  DATE_ID,MAKE_NAME;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4025803,
                "title": "simple-pd-solution",
                "content": "# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    df = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).nunique().reset_index()\\n    df = df.rename(columns={\\'lead_id\\':\\'unique_leads\\',\\'partner_id\\':\\'unique_partners\\'})\\n    return df\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    df = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).nunique().reset_index()\\n    df = df.rename(columns={\\'lead_id\\':\\'unique_leads\\',\\'partner_id\\':\\'unique_partners\\'})\\n    return df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4021150,
                "title": "begineer-friendly-mysql",
                "content": "# Write your MySQL query statement below\\nselect date_id,make_name,count(distinct lead_id) as unique_leads,count(distinct partner_id) as unique_partners from DailySales\\ngroup by date_id,make_name",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# Write your MySQL query statement below\\nselect date_id,make_name,count(distinct lead_id) as unique_leads,count(distinct partner_id) as unique_partners from DailySales\\ngroup by date_id,make_name",
                "codeTag": "Unknown"
            },
            {
                "id": 4019218,
                "title": "pandas-solution-with-aggregation",
                "content": "# Approach\\n1) Group entries by date and make name.\\n.groupby([\\'date_id\\', \\'make_name\\'], as_index=False)\\n\\n2) Aggregate groups - count unique leads and partners using nunique.\\n.agg(\\n            unique_leads = (\\'lead_id\\', \\'nunique\\'),\\n            unique_partners = (\\'partner_id\\', \\'nunique\\')\\n        )\\n\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return daily_sales.groupby([\\'date_id\\', \\'make_name\\'], as_index=False\\n        ).agg(\\n            unique_leads = (\\'lead_id\\', \\'nunique\\'),\\n            unique_partners = (\\'partner_id\\', \\'nunique\\')\\n        )\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return daily_sales.groupby([\\'date_id\\', \\'make_name\\'], as_index=False\\n        ).agg(\\n            unique_leads = (\\'lead_id\\', \\'nunique\\'),\\n            unique_partners = (\\'partner_id\\', \\'nunique\\')\\n        )\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4018040,
                "title": "my-sql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\nSELECT date_id,make_name,count(DISTINCT lead_id) AS unique_leads,\\ncount(DISTINCT partner_id) AS unique_partners FROM DailySales\\nGROUP BY date_id,make_name;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\nSELECT date_id,make_name,count(DISTINCT lead_id) AS unique_leads,\\ncount(DISTINCT partner_id) AS unique_partners FROM DailySales\\nGROUP BY date_id,make_name;",
                "codeTag": "Unknown"
            },
            {
                "id": 4006821,
                "title": "easy-mysql",
                "content": "```\\nSELECT \\n    date_id,\\n    make_name,\\n    COUNT(DISTINCT lead_id) AS unique_leads,\\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM \\n    DailySales\\nGROUP BY\\n    date_id,\\n    make_name\\n```\\n\\n![image](https://assets.leetcode.com/users/images/a208799a-5dd7-4ca3-a44a-284063865548_1693937875.1105998.jpeg)\\n",
                "solutionTags": [],
                "code": "```\\nSELECT \\n    date_id,\\n    make_name,\\n    COUNT(DISTINCT lead_id) AS unique_leads,\\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM \\n    DailySales\\nGROUP BY\\n    date_id,\\n    make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4002429,
                "title": "python3-maximizing-daily-leads-and-partners-insights-pandas-beats-91-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this section, you can briefly describe your initial thoughts or ideas about how to tackle the problem. What are the key concepts or strategies that come to mind? This section provides a high-level overview of your approach.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this section, you can detail your approach to solving the problem. Explain the steps or algorithm you plan to use. Be as clear as possible about the logic and any data structures you intend to employ. This section provides a more in-depth explanation of your solution.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n Describe the computational efficiency of your solution in terms of the input size. For example, if your solution has a linear time complexity, you can express it as O(n).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nExplain how much additional memory or space your solution requires. Is it dependent on the input size, or does it use a constant amount of memory? Express this as O(1) for constant space or O(n) for space that scales with the input size.\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    # Group the daily sales by date_id and make_name, and count distinct lead_id\\'s and partner_id\\'s\\n    grouped = daily_sales.groupby([\\'date_id\\', \\'make_name\\'])[[\\'lead_id\\', \\'partner_id\\']].nunique().reset_index()\\n    \\n    # Rename the columns for clarity\\n    grouped.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n    \\n    return grouped\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Database",
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    # Group the daily sales by date_id and make_name, and count distinct lead_id\\'s and partner_id\\'s\\n    grouped = daily_sales.groupby([\\'date_id\\', \\'make_name\\'])[[\\'lead_id\\', \\'partner_id\\']].nunique().reset_index()\\n    \\n    # Rename the columns for clarity\\n    grouped.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n    \\n    return grouped\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3996090,
                "title": "30days-pandas",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    grouped=daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg({\\'lead_id\\':\\'nunique\\',\\'partner_id\\':\\'nunique\\'}).reset_index()\\n    grouped.columns=[\\'date_id\\',\\'make_name\\',\\'unique_leads\\',\\'unique_partners\\']\\n    return grouped\\n\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    grouped=daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg({\\'lead_id\\':\\'nunique\\',\\'partner_id\\':\\'nunique\\'}).reset_index()\\n    grouped.columns=[\\'date_id\\',\\'make_name\\',\\'unique_leads\\',\\'unique_partners\\']\\n    return grouped\\n\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3990355,
                "title": "1693-daily-leads-and-partners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id)  unique_leads, \\n    COUNT(DISTINCT partner_id) unique_partners \\nFROM \\n    dailysales\\n    GROUP BY date_id, make_name;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id)  unique_leads, \\n    COUNT(DISTINCT partner_id) unique_partners \\nFROM \\n    dailysales\\n    GROUP BY date_id, make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3984999,
                "title": "pandas-easy-solution",
                "content": "\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # Dropping duplicate values\\n    df = daily_sales.drop_duplicates()\\n\\n    # Group by columns to find the unique values\\n    df = df.groupby([\\'date_id\\', \\'make_name\\']).agg(\\n        {\\n            \"lead_id\": \"nunique\",\\n            \"partner_id\": \"nunique\"\\n        }\\n    ).reset_index()\\n\\n    # Renaming columns\\n    df.rename(columns = {\\n        \"lead_id\": \"unique_leads\",\\n        \"partner_id\": \"unique_partners\"\\n    }, inplace = True)\\n\\n\\n    return df\\n    \\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # Dropping duplicate values\\n    df = daily_sales.drop_duplicates()\\n\\n    # Group by columns to find the unique values\\n    df = df.groupby([\\'date_id\\', \\'make_name\\']).agg(\\n        {\\n            \"lead_id\": \"nunique\",\\n            \"partner_id\": \"nunique\"\\n        }\\n    ).reset_index()\\n\\n    # Renaming columns\\n    df.rename(columns = {\\n        \"lead_id\": \"unique_leads\",\\n        \"partner_id\": \"unique_partners\"\\n    }, inplace = True)\\n\\n\\n    return df\\n    \\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3984917,
                "title": "easy-and-simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    df = daily_sales.groupby([\\'date_id\\',\\'make_name\\'])[[\\'lead_id\\',\\'partner_id\\']].nunique().reset_index()\\n    df.rename(columns = {\\'lead_id\\':\\'unique_leads\\',\\'partner_id\\':\\'unique_partners\\'},inplace =True)\\n    return df\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    df = daily_sales.groupby([\\'date_id\\',\\'make_name\\'])[[\\'lead_id\\',\\'partner_id\\']].nunique().reset_index()\\n    df.rename(columns = {\\'lead_id\\':\\'unique_leads\\',\\'partner_id\\':\\'unique_partners\\'},inplace =True)\\n    return df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3984599,
                "title": "pandas-solution",
                "content": "\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return daily_sales.groupby(\\n        [\\'date_id\\',\\'make_name\\']\\n    ).agg(\\n        unique_leads=(\\'lead_id\\',\\'nunique\\'),\\n        unique_partners=(\\'partner_id\\',\\'nunique\\')\\n    ).reset_index()\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return daily_sales.groupby(\\n        [\\'date_id\\',\\'make_name\\']\\n    ).agg(\\n        unique_leads=(\\'lead_id\\',\\'nunique\\'),\\n        unique_partners=(\\'partner_id\\',\\'nunique\\')\\n    ).reset_index()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3984527,
                "title": "mysql-ezpz-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id,make_name\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id,make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3983381,
                "title": "pandas-beats-96-17",
                "content": "# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    a = daily_sales.groupby([\\'date_id\\',\\'make_name\\'])[[\\'lead_id\\',\\'partner_id\\']].nunique().reset_index()\\n    return pd.DataFrame(a.rename(columns={\\'lead_id\\':\\'unique_leads\\',\\'partner_id\\':\\'unique_partners\\'}))\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    a = daily_sales.groupby([\\'date_id\\',\\'make_name\\'])[[\\'lead_id\\',\\'partner_id\\']].nunique().reset_index()\\n    return pd.DataFrame(a.rename(columns={\\'lead_id\\':\\'unique_leads\\',\\'partner_id\\':\\'unique_partners\\'}))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3980021,
                "title": "1693-easy-pandas-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First, group the dataframe based on date_id and make_name columns\\n- Apply the nunique() function on lead_id and partner_id columns to find the unique count.\\n- Rename the columns.\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n\\n    # group the dataframe and find the unique count\\n    df = daily_sales.groupby([\\'date_id\\', \\'make_name\\']).agg({\\'lead_id\\':\\'nunique\\', \\'partner_id\\':\\'nunique\\'}).reset_index()\\n\\n    # rename the columns\\n    df.rename(columns = {\\'lead_id\\':\\'unique_leads\\', \\'partner_id\\':\\'unique_partners\\'}, inplace = True)\\n\\n    # return the dataframe\\n    return df\\n```\\n\\n# Explanation of the parts of code\\n\\n1. groupby() : takes the list of column you want to group with\\n2. agg() : takes a dictionary where the key is the column and the value is the list of functions to apply on it.\\n3. reset_index() : to make the df variable a dataframe instead of Series\\n4. rename() : to rename columns\\n5. inplace = True : to make the changes reflect on the DataFrame\\n\\n# Upvote Plz \\n\\n![upvote.jpg](https://assets.leetcode.com/users/images/c6755a4f-0b81-421c-9718-88c50401e736_1693389544.1304133.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n\\n    # group the dataframe and find the unique count\\n    df = daily_sales.groupby([\\'date_id\\', \\'make_name\\']).agg({\\'lead_id\\':\\'nunique\\', \\'partner_id\\':\\'nunique\\'}).reset_index()\\n\\n    # rename the columns\\n    df.rename(columns = {\\'lead_id\\':\\'unique_leads\\', \\'partner_id\\':\\'unique_partners\\'}, inplace = True)\\n\\n    # return the dataframe\\n    return df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3980012,
                "title": "python3-one-line-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We group by \"date_id\" and \"make_name\"\\n2. We aggregate the unqiue count \\n3. We return the result\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return daily_sales.groupby([\"date_id\", \"make_name\"]).agg(unique_leads=(\"lead_id\", \"nunique\"), unique_partners=(\"partner_id\", \"nunique\")).reset_index()\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return daily_sales.groupby([\"date_id\", \"make_name\"]).agg(unique_leads=(\"lead_id\", \"nunique\"), unique_partners=(\"partner_id\", \"nunique\")).reset_index()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3978852,
                "title": "confused-seeing-multiple-solutions-take-a-look-here",
                "content": "\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    df = daily_sales.groupby([\\'date_id\\',\\'make_name\\'])[[\\'lead_id\\',\\'partner_id\\']].nunique().reset_index()\\n    df.rename(columns = {\\'lead_id\\':\\'unique_leads\\',\\'partner_id\\':\\'unique_partners\\'},inplace =True)\\n    return df\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    df = daily_sales.groupby([\\'date_id\\',\\'make_name\\'])[[\\'lead_id\\',\\'partner_id\\']].nunique().reset_index()\\n    df.rename(columns = {\\'lead_id\\':\\'unique_leads\\',\\'partner_id\\':\\'unique_partners\\'},inplace =True)\\n    return df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3978410,
                "title": "use-agg-in-groupby-in-pandas",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n\\n\\n    df = daily_sales.groupby([\\'date_id\\', \\'make_name\\'], as_index=False).agg(unique_leads = (\\'lead_id\\', \\'nunique\\'),\\n        unique_partners = (\\'partner_id\\', \\'nunique\\'))\\n\\n    return df\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n\\n\\n    df = daily_sales.groupby([\\'date_id\\', \\'make_name\\'], as_index=False).agg(unique_leads = (\\'lead_id\\', \\'nunique\\'),\\n        unique_partners = (\\'partner_id\\', \\'nunique\\'))\\n\\n    return df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3978251,
                "title": "fancy-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    one = daily_sales.groupby([\"date_id\",\"make_name\"]).nunique().reset_index()\\n    return one.rename(columns={\"lead_id\":\"unique_leads\",\"partner_id\":\"unique_partners\"})\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    one = daily_sales.groupby([\"date_id\",\"make_name\"]).nunique().reset_index()\\n    return one.rename(columns={\"lead_id\":\"unique_leads\",\"partner_id\":\"unique_partners\"})\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3977513,
                "title": "beats-98-of-solutions",
                "content": "# Intuition\\nSimple Oneliner\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nMultiple columns aggregation can done by using agg function.\\n\\ntips:\\n1. Always while using more than column pass them in list.\\n2. Use agg function more often for aggregation.\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg(unique_leads=(\\'lead_id\\',\\'nunique\\'),unique_partners=(\\'partner_id\\',\\'nunique\\')).reset_index()\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg(unique_leads=(\\'lead_id\\',\\'nunique\\'),unique_partners=(\\'partner_id\\',\\'nunique\\')).reset_index()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3975663,
                "title": "pandas-chained",
                "content": "# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return (\\n        daily_sales\\n        .groupby([\\'date_id\\', \\'make_name\\'])\\n        .nunique()\\n        .reset_index()\\n        .sort_values([\\'make_name\\', \\'date_id\\'], ascending=False)\\n        .rename(columns={\\'lead_id\\': \\'unique_leads\\', \\'partner_id\\': \\'unique_partners\\'})\\n    )\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return (\\n        daily_sales\\n        .groupby([\\'date_id\\', \\'make_name\\'])\\n        .nunique()\\n        .reset_index()\\n        .sort_values([\\'make_name\\', \\'date_id\\'], ascending=False)\\n        .rename(columns={\\'lead_id\\': \\'unique_leads\\', \\'partner_id\\': \\'unique_partners\\'})\\n    )\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3974382,
                "title": "pandas-easy-beginner-friendly",
                "content": "# Please upvote if you find it useful.\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    daily_sales = daily_sales.groupby([\\'date_id\\', \\'make_name\\']).nunique().reset_index()\\n    daily_sales.rename(columns = {\\'lead_id\\': \\'unique_leads\\', \\'partner_id\\': \\'unique_partners\\'}, inplace=True)\\n    return daily_sales\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    daily_sales = daily_sales.groupby([\\'date_id\\', \\'make_name\\']).nunique().reset_index()\\n    daily_sales.rename(columns = {\\'lead_id\\': \\'unique_leads\\', \\'partner_id\\': \\'unique_partners\\'}, inplace=True)\\n    return daily_sales\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3971912,
                "title": "mysql-simplest-solution",
                "content": "\\n\\n# Code\\n```\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3971766,
                "title": "pandas-solution-using-groupby-and-nunique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse groupby and nunique to find the distinct answers.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Use grouoby on date_id and make_name.\\n- Than use nunique to find the unique records.\\n- Finally use reset_index to restore the original layout\\n- Change the column names to the names expected in the output.\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    df = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).nunique().reset_index()\\n    df.rename(columns={\\'lead_id\\':\\'unique_leads\\',\\'partner_id\\':\\'unique_partners\\'},inplace=True)\\n    return df\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    df = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).nunique().reset_index()\\n    df.rename(columns={\\'lead_id\\':\\'unique_leads\\',\\'partner_id\\':\\'unique_partners\\'},inplace=True)\\n    return df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3970180,
                "title": "pandas-solution-using-groupby-agg",
                "content": "# Approach\\nStep 1: Group by \\'date_id\\' and \\'make_name\\' columns\\n\\nStep 2: Generate aggregated fields with .agg(), using named aggreagation to create new fields (\\'unique_leads\\' and \\'unique_partners\\' to) by applying nunique function to source columns (\\'lead_id\\' and \\'partner_id)\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n#group by date_id and make_name\\n    return daily_sales.groupby([\\'date_id\\',\\'make_name\\'],as_index=False).agg(\\n#Generate \\'unique_\\' columns via nunique function on aggregated fields\\n        unique_leads = (\\'lead_id\\',\\'nunique\\'),\\n        unique_partners = (\\'partner_id\\',\\'nunique\\')\\n    )\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n#group by date_id and make_name\\n    return daily_sales.groupby([\\'date_id\\',\\'make_name\\'],as_index=False).agg(\\n#Generate \\'unique_\\' columns via nunique function on aggregated fields\\n        unique_leads = (\\'lead_id\\',\\'nunique\\'),\\n        unique_partners = (\\'partner_id\\',\\'nunique\\')\\n    )\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3969906,
                "title": "pandas-efficient-solution",
                "content": "\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    result = daily_sales.groupby(by=[\\'date_id\\', \\'make_name\\']\\n    ).agg(\\n        unique_leads = (\\'lead_id\\', \\'nunique\\'),\\n        unique_partners = (\\'partner_id\\', \\'nunique\\')\\n    ).reset_index()\\n    return result[[\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\n    \\'unique_partners\\']]\\n```",
                "solutionTags": [
                    "Python3",
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    result = daily_sales.groupby(by=[\\'date_id\\', \\'make_name\\']\\n    ).agg(\\n        unique_leads = (\\'lead_id\\', \\'nunique\\'),\\n        unique_partners = (\\'partner_id\\', \\'nunique\\')\\n    ).reset_index()\\n    return result[[\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\n    \\'unique_partners\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3969471,
                "title": "group-by-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT date_id,\\nmake_name,\\nCOUNT(distinct lead_id) AS unique_leads,\\nCOUNT(distinct partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT date_id,\\nmake_name,\\nCOUNT(distinct lead_id) AS unique_leads,\\nCOUNT(distinct partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3966406,
                "title": "fast-solution",
                "content": "\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect date_id , make_name , count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners\\nfrom DailySales\\ngroup by date_id , make_name\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect date_id , make_name , count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners\\nfrom DailySales\\ngroup by date_id , make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3964474,
                "title": "pandas-1-line-with-explanation-formatted-for-readability",
                "content": "# Intuition\\n\\nIt is clear that you need to groupby `[\\'date_id\\', \\'make_name\\']` and aggregate. Pandas [aggregate](https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.agg.html) is very powerful and allows renaming, and many predefined function (as long as even custom functions).\\n\\nHere we need to find the number of unique `nunique`.\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(df: pd.DataFrame) -> pd.DataFrame:\\n  return df.groupby([\\'date_id\\', \\'make_name\\']).agg(\\n    unique_leads=pd.NamedAgg(column=\"lead_id\", aggfunc=\"nunique\"),\\n    unique_partners=pd.NamedAgg(column=\"partner_id\", aggfunc=\"nunique\")\\n  ).reset_index()\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(df: pd.DataFrame) -> pd.DataFrame:\\n  return df.groupby([\\'date_id\\', \\'make_name\\']).agg(\\n    unique_leads=pd.NamedAgg(column=\"lead_id\", aggfunc=\"nunique\"),\\n    unique_partners=pd.NamedAgg(column=\"partner_id\", aggfunc=\"nunique\")\\n  ).reset_index()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3962802,
                "title": "easy-and-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n     # Group the daily sales by date_id and make_name, and count distinct lead_id\\'s and partner_id\\'s\\n    grouped = daily_sales.groupby([\\'date_id\\', \\'make_name\\']).agg({\\'lead_id\\': \\'nunique\\', \\'partner_id\\': \\'nunique\\'}).reset_index()\\n    \\n    # Rename the columns for clarity\\n    grouped.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n    \\n    return grouped\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n     # Group the daily sales by date_id and make_name, and count distinct lead_id\\'s and partner_id\\'s\\n    grouped = daily_sales.groupby([\\'date_id\\', \\'make_name\\']).agg({\\'lead_id\\': \\'nunique\\', \\'partner_id\\': \\'nunique\\'}).reset_index()\\n    \\n    # Rename the columns for clarity\\n    grouped.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n    \\n    return grouped\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3960452,
                "title": "pandas-mysql",
                "content": "**Pandas 1:**\\n\\n**When we reset the index, the old index is added as a column, and a new sequential index is used** , reset index is a must or else the `groupby` index is dropped which is required for `date_id` and `make_name` values\\n\\n```Python\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    df = daily_sales.groupby([\\'date_id\\', \\'make_name\\']).nunique().reset_index().rename(columns={\\n        \\'lead_id\\': \\'unique_leads\\',\\n        \\'partner_id\\': \\'unique_partners\\'\\n    })\\n    return df\\n```\\n\\n**Pandas 2:**\\n\\n**We could also use** `agg()`\\n\\n```Python\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return(daily_sales.groupby([\\'date_id\\', \\'make_name\\']).agg(\\n        unique_leads = (\\'lead_id\\', \\'nunique\\'),\\n        unique_partners = (\\'partner_id\\', \\'nunique\\')\\n    ).reset_index()\\n    )\\n```\\n\\n**MySQL:**\\n```SQL\\n# Write your MySQL query statement below\\nselect date_id, make_name, count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners\\nfrom DailySales\\ngroup by date_id, make_name\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "MySQL"
                ],
                "code": "```Python\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    df = daily_sales.groupby([\\'date_id\\', \\'make_name\\']).nunique().reset_index().rename(columns={\\n        \\'lead_id\\': \\'unique_leads\\',\\n        \\'partner_id\\': \\'unique_partners\\'\\n    })\\n    return df\\n```\n```Python\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return(daily_sales.groupby([\\'date_id\\', \\'make_name\\']).agg(\\n        unique_leads = (\\'lead_id\\', \\'nunique\\'),\\n        unique_partners = (\\'partner_id\\', \\'nunique\\')\\n    ).reset_index()\\n    )\\n```\n```SQL\\n# Write your MySQL query statement below\\nselect date_id, make_name, count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners\\nfrom DailySales\\ngroup by date_id, make_name\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3956543,
                "title": "efficient-concise-solution-detailed-stepbystep-approach",
                "content": "\\n# Approach\\nThe code is a Python function that takes a pandas DataFrame called `daily_sales` as input and returns a new DataFrame containing the counts of unique leads and partners for each unique combination of `date_id` and `make_name`.\\n\\nHere\\'s how the solution works step by step:\\n\\n1. `daily_sales.groupby([\\'date_id\\', \\'make_name\\'])`: This groups the `daily_sales` DataFrame by the columns `date_id` and `make_name`. It effectively creates groups based on the unique combinations of these two columns.\\n\\n2. `.nunique()`: After grouping, the `.nunique()` function is applied to each group. This function calculates the number of unique values in each group for each column. In this case, it calculates the number of unique lead IDs (`lead_id`) and partner IDs (`partner_id`) for each combination of `date_id` and `make_name`.\\n\\n3. `.reset_index()`: This function resets the index of the resulting DataFrame, converting the group labels (combination of `date_id` and `make_name`) back into columns, and creating a default integer index.\\n\\n4. `.rename(columns={\\'lead_id\\':\\'unique_leads\\', \\'partner_id\\':\\'unique_partners\\'})`: This renames the columns of the resulting DataFrame to make them more descriptive. It changes the column names from `lead_id` and `partner_id` to `unique_leads` and `unique_partners`, respectively.\\n\\n5. The function returns the final DataFrame with the information about unique leads and partners for each unique combination of `date_id` and `make_name`.\\n\\nThis solution is a concise and efficient way to achieve the desired result using pandas.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nThe time and space complexity of the provided solution depends on the number of rows (`n`) in the input DataFrame and the number of unique combinations of `date_id` and `make_name` (`m`).\\n\\n**- Time complexity:**\\n1. `.groupby([\\'date_id\\', \\'make_name\\'])`: Grouping by two columns requires iterating through all `n` rows of the DataFrame. This step has a time complexity of O(n).\\n2. `.nunique()`: For each group, calculating the number of unique values for `lead_id` and `partner_id` requires iterating through the group\\'s rows, resulting in a time complexity proportional to the number of rows in each group. Since each group can have a different number of rows, the overall time complexity for this step would be the sum of the unique combinations\\' group sizes, which could be up to O(n) in the worst case.\\n3. `.reset_index()`: Resetting the index doesn\\'t add any additional complexity, so it\\'s O(1).\\n4. `.rename(columns={\\'lead_id\\':\\'unique_leads\\', \\'partner_id\\':\\'unique_partners\\'})`: Renaming columns is also an O(1) operation.\\n\\nCombining all these steps, **the overall time complexity of the solution is O(n + m) or O(n), depending on the relationship between `n` and `m`.**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n**- Space complexity:**\\n1. The space complexity of the `.groupby()` operation depends on the number of unique combinations of `date_id` and `make_name`, so it can be up to O(m).\\n2. The `.nunique()` operation creates temporary data structures to store unique values within each group. This would also depend on the number of rows in each group and could be up to O(n) in the worst case.\\n3. The `.reset_index()` operation and renaming columns don\\'t significantly contribute to space complexity, so they are O(1).\\n\\nConsidering these factors, **the overall space complexity of the solution is O(n + m), with the dominant factor being either the number of rows (`n`) or the number of unique combinations (`m`), depending on which one is larger.**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return (\\n        daily_sales\\n        .groupby([\\'date_id\\', \\'make_name\\'])\\n        .nunique()\\n        .reset_index()\\n        .rename(columns={\\'lead_id\\':\\'unique_leads\\', \\'partner_id\\':\\'unique_partners\\'})\\n        )\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return (\\n        daily_sales\\n        .groupby([\\'date_id\\', \\'make_name\\'])\\n        .nunique()\\n        .reset_index()\\n        .rename(columns={\\'lead_id\\':\\'unique_leads\\', \\'partner_id\\':\\'unique_partners\\'})\\n        )\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3955485,
                "title": "simple-solution-using-group-by-and-agg-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    ds_df = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg({\\'lead_id\\': \\'nunique\\', \\'partner_id\\': \\'nunique\\'}).reset_index()\\n    ds_df.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n    return ds_df \\n    \\n\\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    ds_df = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg({\\'lead_id\\': \\'nunique\\', \\'partner_id\\': \\'nunique\\'}).reset_index()\\n    ds_df.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n    return ds_df \\n    \\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3954799,
                "title": "pandas-vs-sql-easiest-comparison-out-there",
                "content": "I have posted this type of comparison solution for all questions in 30 days of Pandas solutions\\n\\nPandas Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    ans=daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg(unique_leads=(\\'lead_id\\',\\'nunique\\'),unique_partners=(\\'partner_id\\',\\'nunique\\')).reset_index()\\n    return ans\\n```\\nSQL Code\\n```\\nselect date_id, make_name, count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners \\nfrom DailySales \\ngroup by date_id, make_name;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    ans=daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg(unique_leads=(\\'lead_id\\',\\'nunique\\'),unique_partners=(\\'partner_id\\',\\'nunique\\')).reset_index()\\n    return ans\\n```\n```\\nselect date_id, make_name, count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners \\nfrom DailySales \\ngroup by date_id, make_name;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3951027,
                "title": "mysql",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT date_id, make_name, count(DISTINCT lead_id) AS unique_leads, count(distinct partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT date_id, make_name, count(DISTINCT lead_id) AS unique_leads, count(distinct partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3948888,
                "title": "solution-with-pandas",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. grouping with `\\'date_id\\',\\'make_name\\'` then aggregating and reindexing\\n\\n```\\nresult = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg({\\n        \\'lead_id\\':\\'nunique\\',\\n        \\'partner_id\\':\\'nunique\\'\\n    }).reset_index()\\n\\n```\\n2. Rename the columns :\\n```\\n# Rename the columns\\n    result.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n\\n```\\n\\n3. return\\n\\n---\\n\\n\\n\\n\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    #grouping and aggregating\\n    result = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg({\\n        \\'lead_id\\':\\'nunique\\',\\n        \\'partner_id\\':\\'nunique\\'\\n    }).reset_index()\\n\\n    # Rename the columns\\n    result.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n    return result\\n\\n```\\n\\n\\uD83C\\uDF1FPlease Upvote if U like the solution \\u26A1\\uD83C\\uDF1F",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nresult = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg({\\n        \\'lead_id\\':\\'nunique\\',\\n        \\'partner_id\\':\\'nunique\\'\\n    }).reset_index()\\n\\n```\n```\\n# Rename the columns\\n    result.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n\\n```\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    #grouping and aggregating\\n    result = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg({\\n        \\'lead_id\\':\\'nunique\\',\\n        \\'partner_id\\':\\'nunique\\'\\n    }).reset_index()\\n\\n    # Rename the columns\\n    result.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n    return result\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3948880,
                "title": "solution-with-pandas",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. grouping with `\\'date_id\\',\\'make_name\\'` then aggregating and reindexing\\n\\n```\\nresult = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg({\\n        \\'lead_id\\':\\'nunique\\',\\n        \\'partner_id\\':\\'nunique\\'\\n    }).reset_index()\\n\\n```\\n2. Rename the columns :\\n```\\n# Rename the columns\\n    result.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n\\n```\\n\\n3. return\\n\\n---\\n\\n\\n\\n\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    #grouping and aggregating\\n    result = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg({\\n        \\'lead_id\\':\\'nunique\\',\\n        \\'partner_id\\':\\'nunique\\'\\n    }).reset_index()\\n\\n    # Rename the columns\\n    result.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n    return result\\n\\n```\\n\\n\\uD83C\\uDF1FPlease Upvote if U like the solution \\u26A1\\uD83C\\uDF1F",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nresult = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg({\\n        \\'lead_id\\':\\'nunique\\',\\n        \\'partner_id\\':\\'nunique\\'\\n    }).reset_index()\\n\\n```\n```\\n# Rename the columns\\n    result.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n\\n```\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    #grouping and aggregating\\n    result = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg({\\n        \\'lead_id\\':\\'nunique\\',\\n        \\'partner_id\\':\\'nunique\\'\\n    }).reset_index()\\n\\n    # Rename the columns\\n    result.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n    return result\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3948879,
                "title": "solution-with-pandas",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. grouping with `\\'date_id\\',\\'make_name\\'` then aggregating and reindexing\\n\\n```\\nresult = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg({\\n        \\'lead_id\\':\\'nunique\\',\\n        \\'partner_id\\':\\'nunique\\'\\n    }).reset_index()\\n\\n```\\n2. Rename the columns :\\n```\\n# Rename the columns\\n    result.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n\\n```\\n\\n3. return\\n\\n---\\n\\n\\n\\n\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    #grouping and aggregating\\n    result = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg({\\n        \\'lead_id\\':\\'nunique\\',\\n        \\'partner_id\\':\\'nunique\\'\\n    }).reset_index()\\n\\n    # Rename the columns\\n    result.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n    return result\\n\\n```\\n\\n\\uD83C\\uDF1FPlease Upvote if U like the solution \\u26A1\\uD83C\\uDF1F",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nresult = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg({\\n        \\'lead_id\\':\\'nunique\\',\\n        \\'partner_id\\':\\'nunique\\'\\n    }).reset_index()\\n\\n```\n```\\n# Rename the columns\\n    result.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n\\n```\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    #grouping and aggregating\\n    result = daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg({\\n        \\'lead_id\\':\\'nunique\\',\\n        \\'partner_id\\':\\'nunique\\'\\n    }).reset_index()\\n\\n    # Rename the columns\\n    result.columns = [\\'date_id\\', \\'make_name\\', \\'unique_leads\\', \\'unique_partners\\']\\n    return result\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3947200,
                "title": "pandas-solution-with-groupby-and-agg-explained",
                "content": "# Intuition\\nUse agg() method to pass functions into it.\\n\\n# Approach\\n**Step 1**.  Group data over 2 columns\\n- We can use standard groupby() method and pass 2 columns into it.\\n- inside agg() method:\\n  \\'*unique_leads=(\\'lead_id\\', \\'nunique\\')*\\':\\n     unique_leads -> name of the column in the final output,\\n     lead_id -> column name from original dataset,\\n     nunique -> name of the function that we\\'d like to use here.  \\n\\n**Step 2**. Select all required columns\\n\\nWe should add \"as_index=False\" into groupby() to add columns that we aggregated over into the final output.\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n  leads = daily_sales.groupby([\\'date_id\\', \\'make_name\\'], as_index=False).agg(\\n    unique_leads=(\\'lead_id\\', \\'nunique\\'),\\n    unique_partners=(\\'partner_id\\', \\'nunique\\'))\\n  return leads\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n  leads = daily_sales.groupby([\\'date_id\\', \\'make_name\\'], as_index=False).agg(\\n    unique_leads=(\\'lead_id\\', \\'nunique\\'),\\n    unique_partners=(\\'partner_id\\', \\'nunique\\'))\\n  return leads\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3946085,
                "title": "pandas-groupby-one-liner",
                "content": "\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n\\n    return daily_sales.groupby(by=[\\'date_id\\',\\'make_name\\'],as_index=False).nunique().rename(columns={\\'lead_id\\':\\'unique_leads\\',\\'partner_id\\':\\'unique_partners\\'})\\n     \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n\\n    return daily_sales.groupby(by=[\\'date_id\\',\\'make_name\\'],as_index=False).nunique().rename(columns={\\'lead_id\\':\\'unique_leads\\',\\'partner_id\\':\\'unique_partners\\'})\\n     \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3946047,
                "title": "pandas-easy-solution",
                "content": "\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    ans=daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg(unique_leads=(\\'lead_id\\',\\'nunique\\'),unique_partners=(\\'partner_id\\',\\'nunique\\')).reset_index()\\n    return ans\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    ans=daily_sales.groupby([\\'date_id\\',\\'make_name\\']).agg(unique_leads=(\\'lead_id\\',\\'nunique\\'),unique_partners=(\\'partner_id\\',\\'nunique\\')).reset_index()\\n    return ans\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3944914,
                "title": "mysql-data-aggregation",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGrouping two columns using group by function.\\n\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect date_id, make_name,count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners\\nfrom dailysales\\ngroup by date_id, make_name;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect date_id, make_name,count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners\\nfrom dailysales\\ngroup by date_id, make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944647,
                "title": "quick-pandas-solution",
                "content": "\\n# Approach\\ngroupby the date and car brand. Then count the unique ids of leads and partners.\\n\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    result = daily_sales.groupby([\"date_id\",\"make_name\"], as_index=False).agg({\"lead_id\": \"nunique\", \"partner_id\": \"nunique\"})\\n    result.rename(columns={\"lead_id\": \"unique_leads\", \"partner_id\": \"unique_partners\"}, inplace=True)\\n    return result\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    result = daily_sales.groupby([\"date_id\",\"make_name\"], as_index=False).agg({\"lead_id\": \"nunique\", \"partner_id\": \"nunique\"})\\n    result.rename(columns={\"lead_id\": \"unique_leads\", \"partner_id\": \"unique_partners\"}, inplace=True)\\n    return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3944587,
                "title": "easy-pandas-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return daily_sales.groupby(\\n        [\\'date_id\\', \\'make_name\\']\\n    ).nunique().reset_index().rename(columns={\\n        \\'lead_id\\': \\'unique_leads\\',\\n        \\'partner_id\\': \\'unique_partners\\',\\n    })\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "MySQL",
                    "MS SQL Server",
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return daily_sales.groupby(\\n        [\\'date_id\\', \\'make_name\\']\\n    ).nunique().reset_index().rename(columns={\\n        \\'lead_id\\': \\'unique_leads\\',\\n        \\'partner_id\\': \\'unique_partners\\',\\n    })\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3943480,
                "title": "easy-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) as unique_leads, COUNT(DISTINCT partner_id) as unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) as unique_leads, COUNT(DISTINCT partner_id) as unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3941575,
                "title": "1693-daily-leads-and-partners",
                "content": "```\\nselect date_id, make_name, count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners \\nfrom DailySales \\ngroup by date_id, make_name;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect date_id, make_name, count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partners \\nfrom DailySales \\ngroup by date_id, make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3940304,
                "title": "pandas-solution-detailed-explanation",
                "content": "## Introduction\\n\\nThe `daily_leads_and_partners` function is a Python function designed to process a DataFrame containing daily sales data and calculate unique lead and partner counts for each combination of date and make_name.\\n#### Parameters\\n\\n- `daily_sales` (pd.DataFrame): A pandas DataFrame containing daily sales data. It is expected to have at least three columns: \"date_id,\" \"make_name,\" \"lead_id,\" and \"partner_id.\"\\n\\n#### Returns\\n\\n- `pd.DataFrame`: A pandas DataFrame with three columns: \"date_id,\" \"make_name,\" \"unique_leads,\" and \"unique_partners.\" This DataFrame represents the count of unique lead and partner IDs for each combination of \"date_id\" and \"make_name.\"\\n\\n## Function Overview\\n\\nThe purpose of the `daily_leads_and_partners` function is to:\\n\\n1. Group the input DataFrame `daily_sales` by \"date_id\" and \"make_name.\"\\n2. Calculate the count of unique lead IDs for each group.\\n3. Calculate the count of unique partner IDs for each group.\\n4. Create a new DataFrame that combines the unique lead and partner counts for each combination of \"date_id\" and \"make_name.\"\\n5. Return the resulting DataFrame.\\n\\n## Example Usage\\n\\n```python\\nimport pandas as pd\\n\\n# Sample DataFrame\\ndata = {\\n    \"date_id\": [\"2023-08-01\", \"2023-08-01\", \"2023-08-02\", \"2023-08-02\"],\\n    \"make_name\": [\"Toyota\", \"Ford\", \"Toyota\", \"Ford\"],\\n    \"lead_id\": [101, 102, 103, 104],\\n    \"partner_id\": [201, 202, 201, 203],\\n}\\n\\ndaily_sales_df = pd.DataFrame(data)\\n\\nresult_df = daily_leads_and_partners(daily_sales_df)\\n\\nprint(result_df)\\n```\\n\\nThis will produce a DataFrame like the following:\\n\\n```\\n     date_id make_name  unique_leads  unique_partners\\n0  2023-08-02      Ford             2                2\\n1  2023-08-02    Toyota             1                1\\n2  2023-08-01      Ford             1                1\\n3  2023-08-01    Toyota             1                1\\n```\\n\\n## Function Details\\n\\nHere are the detailed steps the function takes to achieve its goal:\\n\\n1. **Grouping by Date and Make Name**: The function first groups the `daily_sales` DataFrame by the \"date_id\" and \"make_name\" columns using the `groupby` function. This step creates a DataFrame grouped by these two columns.\\n\\n2. **Counting Unique Leads**: For each group in the grouped DataFrame, it calculates the count of unique lead IDs using the `.nunique()` function on the \"lead_id\" column. This count is stored in the \"unique_leads\" column.\\n\\n3. **Sorting the Result**: The function sorts the resulting DataFrame in descending order based on \"make_name\" and \"date_id\" using the `sort_values` function. \\n\\n4. **Renaming Columns**: The \"lead_id\" column is renamed to \"unique_leads\" using the `rename` function to clarify the purpose of the column.\\n\\n5. **Counting Unique Partners**: Similar to the unique leads calculation, the function also calculates the count of unique partner IDs for each group using the `.nunique()` function on the \"partner_id\" column. This count is not renamed since it retains the original column name.\\n\\n6. **Creating the Final DataFrame**: The function creates a new DataFrame (`unique_lead`) that combines the \"unique_leads\" and \"unique_partners\" columns.\\n\\n7. **Returning the Result**: The function returns the `unique_lead` DataFrame, which contains the counts of unique leads and partners for each combination of \"date_id\" and \"make_name.\"\\n\\n## Conclusion\\n\\nThe `daily_leads_and_partners` function is a useful tool for summarizing daily sales data by calculating the unique lead and partner counts for each date and make_name combination. \\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    # group by date_id and make_name\\n    daily_make_sales = daily_sales.groupby([\"date_id\",\"make_name\"])\\n    # count unique lead_id\\n    unique_lead = (\\n        daily_make_sales[\"lead_id\"]\\n        .nunique()\\n        .reset_index()\\n        .sort_values([\"make_name\",\"date_id\"],ascending = False)\\n        .rename(columns={\"lead_id\":\"unique_leads\"}))\\n    # count unique partner_id\\n    unique_partner = (\\n        daily_make_sales[\"partner_id\"]\\n        .nunique()\\n        .reset_index()\\n        .sort_values([\"make_name\",\"date_id\"],ascending = False))\\n    # create new DataFrame with both answers\\n    unique_lead[\"unique_partners\"] = unique_partner[\"partner_id\"]\\n    return unique_lead\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```python\\nimport pandas as pd\\n\\n# Sample DataFrame\\ndata = {\\n    \"date_id\": [\"2023-08-01\", \"2023-08-01\", \"2023-08-02\", \"2023-08-02\"],\\n    \"make_name\": [\"Toyota\", \"Ford\", \"Toyota\", \"Ford\"],\\n    \"lead_id\": [101, 102, 103, 104],\\n    \"partner_id\": [201, 202, 201, 203],\\n}\\n\\ndaily_sales_df = pd.DataFrame(data)\\n\\nresult_df = daily_leads_and_partners(daily_sales_df)\\n\\nprint(result_df)\\n```\n```\\n     date_id make_name  unique_leads  unique_partners\\n0  2023-08-02      Ford             2                2\\n1  2023-08-02    Toyota             1                1\\n2  2023-08-01      Ford             1                1\\n3  2023-08-01    Toyota             1                1\\n```\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    # group by date_id and make_name\\n    daily_make_sales = daily_sales.groupby([\"date_id\",\"make_name\"])\\n    # count unique lead_id\\n    unique_lead = (\\n        daily_make_sales[\"lead_id\"]\\n        .nunique()\\n        .reset_index()\\n        .sort_values([\"make_name\",\"date_id\"],ascending = False)\\n        .rename(columns={\"lead_id\":\"unique_leads\"}))\\n    # count unique partner_id\\n    unique_partner = (\\n        daily_make_sales[\"partner_id\"]\\n        .nunique()\\n        .reset_index()\\n        .sort_values([\"make_name\",\"date_id\"],ascending = False))\\n    # create new DataFrame with both answers\\n    unique_lead[\"unique_partners\"] = unique_partner[\"partner_id\"]\\n    return unique_lead\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3931315,
                "title": "sql-simple-solution-count-distinct-group-by",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT d.date_id,\\n       d.make_name,\\n       count(distinct d.lead_id)    as unique_leads,\\n       count(distinct d.partner_id) as unique_partners\\nFROM DailySales d\\nGROUP BY d.date_id, d.make_name;\\n```\\n",
                "solutionTags": [
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```\\nSELECT d.date_id,\\n       d.make_name,\\n       count(distinct d.lead_id)    as unique_leads,\\n       count(distinct d.partner_id) as unique_partners\\nFROM DailySales d\\nGROUP BY d.date_id, d.make_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3925173,
                "title": "simple-solution-with-explaination",
                "content": "Selecting columns which we have to return in accordance with like date_id and make_name and then implementing two counts one for  distinct lead_id and second for distinct partner_id and then grouping them in accordance to date_id and make_name.\\n```\\nSelect date_id,make_name, Count(distinct lead_id) as unique_leads, Count(distinct partner_id) as unique_partners from dailysales group by  date_id,make_name\\n```",
                "solutionTags": [],
                "code": "```\\nSelect date_id,make_name, Count(distinct lead_id) as unique_leads, Count(distinct partner_id) as unique_partners from dailysales group by  date_id,make_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924239,
                "title": "pandas-1-line",
                "content": "```\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return daily_sales.groupby(by=[\"date_id\", \"make_name\"], as_index=False).agg(unique_leads=(\"lead_id\", \"nunique\"), unique_partners=(\"partner_id\", \"nunique\"))\\n```",
                "solutionTags": [],
                "code": "```\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return daily_sales.groupby(by=[\"date_id\", \"make_name\"], as_index=False).agg(unique_leads=(\"lead_id\", \"nunique\"), unique_partners=(\"partner_id\", \"nunique\"))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3920864,
                "title": "one-line-pandas-solution-simple",
                "content": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    df = daily_sales.groupby([\\'date_id\\', \\'make_name\\'], as_index=False).agg(unique_leads=(\\'lead_id\\', \\'nunique\\'), unique_partners=(\\'partner_id\\', \\'nunique\\'))\\n    return df\\n```",
                "solutionTags": [],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    df = daily_sales.groupby([\\'date_id\\', \\'make_name\\'], as_index=False).agg(unique_leads=(\\'lead_id\\', \\'nunique\\'), unique_partners=(\\'partner_id\\', \\'nunique\\'))\\n    return df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3920542,
                "title": "pandas-code",
                "content": "\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    result = daily_sales.groupby([\\'date_id\\', \\'make_name\\']).nunique().reset_index()\\n    result.rename(columns={\\'lead_id\\': \\'unique_leads\\', \\'partner_id\\': \\'unique_partners\\'}, inplace = True)\\n    return result\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    result = daily_sales.groupby([\\'date_id\\', \\'make_name\\']).nunique().reset_index()\\n    result.rename(columns={\\'lead_id\\': \\'unique_leads\\', \\'partner_id\\': \\'unique_partners\\'}, inplace = True)\\n    return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3920288,
                "title": "pandas-solution-better-readibility-than-using-rename",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return(daily_sales.groupby([\\'date_id\\', \\'make_name\\']).agg(\\n        unique_leads = (\\'lead_id\\', \\'nunique\\'),\\n        unique_partners = (\\'partner_id\\', \\'nunique\\')\\n    ).reset_index()\\n    )\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    return(daily_sales.groupby([\\'date_id\\', \\'make_name\\']).agg(\\n        unique_leads = (\\'lead_id\\', \\'nunique\\'),\\n        unique_partners = (\\'partner_id\\', \\'nunique\\')\\n    ).reset_index()\\n    )\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3919719,
                "title": "daily-leads-and-partners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    daily_sales=daily_sales.groupby(by=[\"date_id\",\"make_name\"],as_index=False).nunique()\\n    daily_sales.rename(columns={\"lead_id\":\"unique_leads\",\"partner_id\":\"unique_partners\"},inplace=True)\\n    return daily_sales\\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    daily_sales=daily_sales.groupby(by=[\"date_id\",\"make_name\"],as_index=False).nunique()\\n    daily_sales.rename(columns={\"lead_id\":\"unique_leads\",\"partner_id\":\"unique_partners\"},inplace=True)\\n    return daily_sales\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3916560,
                "title": "easy-pandas-solution",
                "content": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    filter_df = daily_sales.groupby([\\'date_id\\', \\'make_name\\'])[[\\'lead_id\\', \\'partner_id\\']].nunique().reset_index()\\n    filter_df.rename(columns = {\\n            \\'lead_id\\' : \\'unique_leads\\', \\n            \\'partner_id\\' : \\'unique_partners\\'\\n        }, inplace = True)\\n\\n    return filter_df \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef daily_leads_and_partners(daily_sales: pd.DataFrame) -> pd.DataFrame:\\n    filter_df = daily_sales.groupby([\\'date_id\\', \\'make_name\\'])[[\\'lead_id\\', \\'partner_id\\']].nunique().reset_index()\\n    filter_df.rename(columns = {\\n            \\'lead_id\\' : \\'unique_leads\\', \\n            \\'partner_id\\' : \\'unique_partners\\'\\n        }, inplace = True)\\n\\n    return filter_df \\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1570849,
                "content": [
                    {
                        "username": "satyadeep0987",
                        "content": "--SQL server  and MySQL\\n\\nselect date_id   , make_name , count(distinct lead_id  ) unique_leads ,\\ncount( distinct partner_id ) unique_partners from DailySales group by date_id   , make_name\\n\\n--Orcle\\n\\nselect to_char(date_id,\\'yyyy-mm-dd\\') date_id  ,\\n make_name , count(distinct lead_id  ) unique_leads ,\\n count( distinct partner_id ) unique_partners \\n from DailySales group by to_char(date_id,\\'yyyy-mm-dd\\')   , make_name"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id, make_name\\n```"
                    },
                    {
                        "username": "algo247",
                        "content": "WITH DAILY_ID AS (SELECT *\\n                  FROM DailySales)\\n\\nSELECT date_id,make_name,count(distinct lead_id) AS \\'Unique_Leads\\' ,count(distinct partner_id) AS \\'Unique_Partners\\'\\nFROM DAILY_ID\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "sumangupta9250",
                        "content": "what is the issue with my code its not running?\\nSELECT \\ndate_id,make_name,\\ncount( DISTINCT lead_id) as unique_leads,\\ncount (DISTINCT partner_id) as unique_partners\\nfrom DailySales;"
                    },
                    {
                        "username": "Vikash_99",
                        "content": "you need to group  it according to date_id and make_name"
                    },
                    {
                        "username": "edithi",
                        "content": "You need to group the DailySales table by the columns \\'date_id\\' and \\'make_name\\'. This can be done using the groupby function in pandas.\\n\\nAfter grouping, you need to calculate the number of unique lead IDs and partner IDs for each group. You can achieve this using the nunique function within the agg function.\\n\\nFinally, create a new DataFrame using the grouped and aggregated data, with columns \\'date_id\\', \\'make_name\\', \\'unique_leads\\', and \\'unique_partners\\'.\\n\\nRemember to sort the result by \\'date_id\\' and feel free to return the new DataFrame as the output of your function."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select  date_id,make_name,  count(distinct lead_id ) unique_leads, count(distinct partner_id ) unique_partners from DailySales\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "b0968760387",
                        "content": "[Oracle] If you can\\'t find any oracle methods, maybe I can help you. :)\\n\\nselect to_char(date_id) date_id, make_name ,\\ncount(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom DailySales\\ngroup by date_id,make_name"
                    },
                    {
                        "username": "TuanMinh03",
                        "content": "MS SQL Server\\n\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select date_id, make_name ,\\ncount(distinct lead_id)  unique_leads ,\\ncount(distinct partner_id)  unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id ASC;"
                    }
                ]
            },
            {
                "id": 1804375,
                "content": [
                    {
                        "username": "satyadeep0987",
                        "content": "--SQL server  and MySQL\\n\\nselect date_id   , make_name , count(distinct lead_id  ) unique_leads ,\\ncount( distinct partner_id ) unique_partners from DailySales group by date_id   , make_name\\n\\n--Orcle\\n\\nselect to_char(date_id,\\'yyyy-mm-dd\\') date_id  ,\\n make_name , count(distinct lead_id  ) unique_leads ,\\n count( distinct partner_id ) unique_partners \\n from DailySales group by to_char(date_id,\\'yyyy-mm-dd\\')   , make_name"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id, make_name\\n```"
                    },
                    {
                        "username": "algo247",
                        "content": "WITH DAILY_ID AS (SELECT *\\n                  FROM DailySales)\\n\\nSELECT date_id,make_name,count(distinct lead_id) AS \\'Unique_Leads\\' ,count(distinct partner_id) AS \\'Unique_Partners\\'\\nFROM DAILY_ID\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "sumangupta9250",
                        "content": "what is the issue with my code its not running?\\nSELECT \\ndate_id,make_name,\\ncount( DISTINCT lead_id) as unique_leads,\\ncount (DISTINCT partner_id) as unique_partners\\nfrom DailySales;"
                    },
                    {
                        "username": "Vikash_99",
                        "content": "you need to group  it according to date_id and make_name"
                    },
                    {
                        "username": "edithi",
                        "content": "You need to group the DailySales table by the columns \\'date_id\\' and \\'make_name\\'. This can be done using the groupby function in pandas.\\n\\nAfter grouping, you need to calculate the number of unique lead IDs and partner IDs for each group. You can achieve this using the nunique function within the agg function.\\n\\nFinally, create a new DataFrame using the grouped and aggregated data, with columns \\'date_id\\', \\'make_name\\', \\'unique_leads\\', and \\'unique_partners\\'.\\n\\nRemember to sort the result by \\'date_id\\' and feel free to return the new DataFrame as the output of your function."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select  date_id,make_name,  count(distinct lead_id ) unique_leads, count(distinct partner_id ) unique_partners from DailySales\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "b0968760387",
                        "content": "[Oracle] If you can\\'t find any oracle methods, maybe I can help you. :)\\n\\nselect to_char(date_id) date_id, make_name ,\\ncount(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom DailySales\\ngroup by date_id,make_name"
                    },
                    {
                        "username": "TuanMinh03",
                        "content": "MS SQL Server\\n\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select date_id, make_name ,\\ncount(distinct lead_id)  unique_leads ,\\ncount(distinct partner_id)  unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id ASC;"
                    }
                ]
            },
            {
                "id": 1576844,
                "content": [
                    {
                        "username": "satyadeep0987",
                        "content": "--SQL server  and MySQL\\n\\nselect date_id   , make_name , count(distinct lead_id  ) unique_leads ,\\ncount( distinct partner_id ) unique_partners from DailySales group by date_id   , make_name\\n\\n--Orcle\\n\\nselect to_char(date_id,\\'yyyy-mm-dd\\') date_id  ,\\n make_name , count(distinct lead_id  ) unique_leads ,\\n count( distinct partner_id ) unique_partners \\n from DailySales group by to_char(date_id,\\'yyyy-mm-dd\\')   , make_name"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id, make_name\\n```"
                    },
                    {
                        "username": "algo247",
                        "content": "WITH DAILY_ID AS (SELECT *\\n                  FROM DailySales)\\n\\nSELECT date_id,make_name,count(distinct lead_id) AS \\'Unique_Leads\\' ,count(distinct partner_id) AS \\'Unique_Partners\\'\\nFROM DAILY_ID\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "sumangupta9250",
                        "content": "what is the issue with my code its not running?\\nSELECT \\ndate_id,make_name,\\ncount( DISTINCT lead_id) as unique_leads,\\ncount (DISTINCT partner_id) as unique_partners\\nfrom DailySales;"
                    },
                    {
                        "username": "Vikash_99",
                        "content": "you need to group  it according to date_id and make_name"
                    },
                    {
                        "username": "edithi",
                        "content": "You need to group the DailySales table by the columns \\'date_id\\' and \\'make_name\\'. This can be done using the groupby function in pandas.\\n\\nAfter grouping, you need to calculate the number of unique lead IDs and partner IDs for each group. You can achieve this using the nunique function within the agg function.\\n\\nFinally, create a new DataFrame using the grouped and aggregated data, with columns \\'date_id\\', \\'make_name\\', \\'unique_leads\\', and \\'unique_partners\\'.\\n\\nRemember to sort the result by \\'date_id\\' and feel free to return the new DataFrame as the output of your function."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select  date_id,make_name,  count(distinct lead_id ) unique_leads, count(distinct partner_id ) unique_partners from DailySales\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "b0968760387",
                        "content": "[Oracle] If you can\\'t find any oracle methods, maybe I can help you. :)\\n\\nselect to_char(date_id) date_id, make_name ,\\ncount(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom DailySales\\ngroup by date_id,make_name"
                    },
                    {
                        "username": "TuanMinh03",
                        "content": "MS SQL Server\\n\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select date_id, make_name ,\\ncount(distinct lead_id)  unique_leads ,\\ncount(distinct partner_id)  unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id ASC;"
                    }
                ]
            },
            {
                "id": 2072988,
                "content": [
                    {
                        "username": "satyadeep0987",
                        "content": "--SQL server  and MySQL\\n\\nselect date_id   , make_name , count(distinct lead_id  ) unique_leads ,\\ncount( distinct partner_id ) unique_partners from DailySales group by date_id   , make_name\\n\\n--Orcle\\n\\nselect to_char(date_id,\\'yyyy-mm-dd\\') date_id  ,\\n make_name , count(distinct lead_id  ) unique_leads ,\\n count( distinct partner_id ) unique_partners \\n from DailySales group by to_char(date_id,\\'yyyy-mm-dd\\')   , make_name"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id, make_name\\n```"
                    },
                    {
                        "username": "algo247",
                        "content": "WITH DAILY_ID AS (SELECT *\\n                  FROM DailySales)\\n\\nSELECT date_id,make_name,count(distinct lead_id) AS \\'Unique_Leads\\' ,count(distinct partner_id) AS \\'Unique_Partners\\'\\nFROM DAILY_ID\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "sumangupta9250",
                        "content": "what is the issue with my code its not running?\\nSELECT \\ndate_id,make_name,\\ncount( DISTINCT lead_id) as unique_leads,\\ncount (DISTINCT partner_id) as unique_partners\\nfrom DailySales;"
                    },
                    {
                        "username": "Vikash_99",
                        "content": "you need to group  it according to date_id and make_name"
                    },
                    {
                        "username": "edithi",
                        "content": "You need to group the DailySales table by the columns \\'date_id\\' and \\'make_name\\'. This can be done using the groupby function in pandas.\\n\\nAfter grouping, you need to calculate the number of unique lead IDs and partner IDs for each group. You can achieve this using the nunique function within the agg function.\\n\\nFinally, create a new DataFrame using the grouped and aggregated data, with columns \\'date_id\\', \\'make_name\\', \\'unique_leads\\', and \\'unique_partners\\'.\\n\\nRemember to sort the result by \\'date_id\\' and feel free to return the new DataFrame as the output of your function."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select  date_id,make_name,  count(distinct lead_id ) unique_leads, count(distinct partner_id ) unique_partners from DailySales\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "b0968760387",
                        "content": "[Oracle] If you can\\'t find any oracle methods, maybe I can help you. :)\\n\\nselect to_char(date_id) date_id, make_name ,\\ncount(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom DailySales\\ngroup by date_id,make_name"
                    },
                    {
                        "username": "TuanMinh03",
                        "content": "MS SQL Server\\n\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select date_id, make_name ,\\ncount(distinct lead_id)  unique_leads ,\\ncount(distinct partner_id)  unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id ASC;"
                    }
                ]
            },
            {
                "id": 2010146,
                "content": [
                    {
                        "username": "satyadeep0987",
                        "content": "--SQL server  and MySQL\\n\\nselect date_id   , make_name , count(distinct lead_id  ) unique_leads ,\\ncount( distinct partner_id ) unique_partners from DailySales group by date_id   , make_name\\n\\n--Orcle\\n\\nselect to_char(date_id,\\'yyyy-mm-dd\\') date_id  ,\\n make_name , count(distinct lead_id  ) unique_leads ,\\n count( distinct partner_id ) unique_partners \\n from DailySales group by to_char(date_id,\\'yyyy-mm-dd\\')   , make_name"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id, make_name\\n```"
                    },
                    {
                        "username": "algo247",
                        "content": "WITH DAILY_ID AS (SELECT *\\n                  FROM DailySales)\\n\\nSELECT date_id,make_name,count(distinct lead_id) AS \\'Unique_Leads\\' ,count(distinct partner_id) AS \\'Unique_Partners\\'\\nFROM DAILY_ID\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "sumangupta9250",
                        "content": "what is the issue with my code its not running?\\nSELECT \\ndate_id,make_name,\\ncount( DISTINCT lead_id) as unique_leads,\\ncount (DISTINCT partner_id) as unique_partners\\nfrom DailySales;"
                    },
                    {
                        "username": "Vikash_99",
                        "content": "you need to group  it according to date_id and make_name"
                    },
                    {
                        "username": "edithi",
                        "content": "You need to group the DailySales table by the columns \\'date_id\\' and \\'make_name\\'. This can be done using the groupby function in pandas.\\n\\nAfter grouping, you need to calculate the number of unique lead IDs and partner IDs for each group. You can achieve this using the nunique function within the agg function.\\n\\nFinally, create a new DataFrame using the grouped and aggregated data, with columns \\'date_id\\', \\'make_name\\', \\'unique_leads\\', and \\'unique_partners\\'.\\n\\nRemember to sort the result by \\'date_id\\' and feel free to return the new DataFrame as the output of your function."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select  date_id,make_name,  count(distinct lead_id ) unique_leads, count(distinct partner_id ) unique_partners from DailySales\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "b0968760387",
                        "content": "[Oracle] If you can\\'t find any oracle methods, maybe I can help you. :)\\n\\nselect to_char(date_id) date_id, make_name ,\\ncount(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom DailySales\\ngroup by date_id,make_name"
                    },
                    {
                        "username": "TuanMinh03",
                        "content": "MS SQL Server\\n\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select date_id, make_name ,\\ncount(distinct lead_id)  unique_leads ,\\ncount(distinct partner_id)  unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id ASC;"
                    }
                ]
            },
            {
                "id": 1864533,
                "content": [
                    {
                        "username": "satyadeep0987",
                        "content": "--SQL server  and MySQL\\n\\nselect date_id   , make_name , count(distinct lead_id  ) unique_leads ,\\ncount( distinct partner_id ) unique_partners from DailySales group by date_id   , make_name\\n\\n--Orcle\\n\\nselect to_char(date_id,\\'yyyy-mm-dd\\') date_id  ,\\n make_name , count(distinct lead_id  ) unique_leads ,\\n count( distinct partner_id ) unique_partners \\n from DailySales group by to_char(date_id,\\'yyyy-mm-dd\\')   , make_name"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id, make_name\\n```"
                    },
                    {
                        "username": "algo247",
                        "content": "WITH DAILY_ID AS (SELECT *\\n                  FROM DailySales)\\n\\nSELECT date_id,make_name,count(distinct lead_id) AS \\'Unique_Leads\\' ,count(distinct partner_id) AS \\'Unique_Partners\\'\\nFROM DAILY_ID\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "sumangupta9250",
                        "content": "what is the issue with my code its not running?\\nSELECT \\ndate_id,make_name,\\ncount( DISTINCT lead_id) as unique_leads,\\ncount (DISTINCT partner_id) as unique_partners\\nfrom DailySales;"
                    },
                    {
                        "username": "Vikash_99",
                        "content": "you need to group  it according to date_id and make_name"
                    },
                    {
                        "username": "edithi",
                        "content": "You need to group the DailySales table by the columns \\'date_id\\' and \\'make_name\\'. This can be done using the groupby function in pandas.\\n\\nAfter grouping, you need to calculate the number of unique lead IDs and partner IDs for each group. You can achieve this using the nunique function within the agg function.\\n\\nFinally, create a new DataFrame using the grouped and aggregated data, with columns \\'date_id\\', \\'make_name\\', \\'unique_leads\\', and \\'unique_partners\\'.\\n\\nRemember to sort the result by \\'date_id\\' and feel free to return the new DataFrame as the output of your function."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select  date_id,make_name,  count(distinct lead_id ) unique_leads, count(distinct partner_id ) unique_partners from DailySales\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "b0968760387",
                        "content": "[Oracle] If you can\\'t find any oracle methods, maybe I can help you. :)\\n\\nselect to_char(date_id) date_id, make_name ,\\ncount(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom DailySales\\ngroup by date_id,make_name"
                    },
                    {
                        "username": "TuanMinh03",
                        "content": "MS SQL Server\\n\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select date_id, make_name ,\\ncount(distinct lead_id)  unique_leads ,\\ncount(distinct partner_id)  unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id ASC;"
                    }
                ]
            },
            {
                "id": 1844497,
                "content": [
                    {
                        "username": "satyadeep0987",
                        "content": "--SQL server  and MySQL\\n\\nselect date_id   , make_name , count(distinct lead_id  ) unique_leads ,\\ncount( distinct partner_id ) unique_partners from DailySales group by date_id   , make_name\\n\\n--Orcle\\n\\nselect to_char(date_id,\\'yyyy-mm-dd\\') date_id  ,\\n make_name , count(distinct lead_id  ) unique_leads ,\\n count( distinct partner_id ) unique_partners \\n from DailySales group by to_char(date_id,\\'yyyy-mm-dd\\')   , make_name"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id, make_name\\n```"
                    },
                    {
                        "username": "algo247",
                        "content": "WITH DAILY_ID AS (SELECT *\\n                  FROM DailySales)\\n\\nSELECT date_id,make_name,count(distinct lead_id) AS \\'Unique_Leads\\' ,count(distinct partner_id) AS \\'Unique_Partners\\'\\nFROM DAILY_ID\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "sumangupta9250",
                        "content": "what is the issue with my code its not running?\\nSELECT \\ndate_id,make_name,\\ncount( DISTINCT lead_id) as unique_leads,\\ncount (DISTINCT partner_id) as unique_partners\\nfrom DailySales;"
                    },
                    {
                        "username": "Vikash_99",
                        "content": "you need to group  it according to date_id and make_name"
                    },
                    {
                        "username": "edithi",
                        "content": "You need to group the DailySales table by the columns \\'date_id\\' and \\'make_name\\'. This can be done using the groupby function in pandas.\\n\\nAfter grouping, you need to calculate the number of unique lead IDs and partner IDs for each group. You can achieve this using the nunique function within the agg function.\\n\\nFinally, create a new DataFrame using the grouped and aggregated data, with columns \\'date_id\\', \\'make_name\\', \\'unique_leads\\', and \\'unique_partners\\'.\\n\\nRemember to sort the result by \\'date_id\\' and feel free to return the new DataFrame as the output of your function."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select  date_id,make_name,  count(distinct lead_id ) unique_leads, count(distinct partner_id ) unique_partners from DailySales\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "b0968760387",
                        "content": "[Oracle] If you can\\'t find any oracle methods, maybe I can help you. :)\\n\\nselect to_char(date_id) date_id, make_name ,\\ncount(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom DailySales\\ngroup by date_id,make_name"
                    },
                    {
                        "username": "TuanMinh03",
                        "content": "MS SQL Server\\n\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select date_id, make_name ,\\ncount(distinct lead_id)  unique_leads ,\\ncount(distinct partner_id)  unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id ASC;"
                    }
                ]
            },
            {
                "id": 1800723,
                "content": [
                    {
                        "username": "satyadeep0987",
                        "content": "--SQL server  and MySQL\\n\\nselect date_id   , make_name , count(distinct lead_id  ) unique_leads ,\\ncount( distinct partner_id ) unique_partners from DailySales group by date_id   , make_name\\n\\n--Orcle\\n\\nselect to_char(date_id,\\'yyyy-mm-dd\\') date_id  ,\\n make_name , count(distinct lead_id  ) unique_leads ,\\n count( distinct partner_id ) unique_partners \\n from DailySales group by to_char(date_id,\\'yyyy-mm-dd\\')   , make_name"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id, make_name\\n```"
                    },
                    {
                        "username": "algo247",
                        "content": "WITH DAILY_ID AS (SELECT *\\n                  FROM DailySales)\\n\\nSELECT date_id,make_name,count(distinct lead_id) AS \\'Unique_Leads\\' ,count(distinct partner_id) AS \\'Unique_Partners\\'\\nFROM DAILY_ID\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "sumangupta9250",
                        "content": "what is the issue with my code its not running?\\nSELECT \\ndate_id,make_name,\\ncount( DISTINCT lead_id) as unique_leads,\\ncount (DISTINCT partner_id) as unique_partners\\nfrom DailySales;"
                    },
                    {
                        "username": "Vikash_99",
                        "content": "you need to group  it according to date_id and make_name"
                    },
                    {
                        "username": "edithi",
                        "content": "You need to group the DailySales table by the columns \\'date_id\\' and \\'make_name\\'. This can be done using the groupby function in pandas.\\n\\nAfter grouping, you need to calculate the number of unique lead IDs and partner IDs for each group. You can achieve this using the nunique function within the agg function.\\n\\nFinally, create a new DataFrame using the grouped and aggregated data, with columns \\'date_id\\', \\'make_name\\', \\'unique_leads\\', and \\'unique_partners\\'.\\n\\nRemember to sort the result by \\'date_id\\' and feel free to return the new DataFrame as the output of your function."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select  date_id,make_name,  count(distinct lead_id ) unique_leads, count(distinct partner_id ) unique_partners from DailySales\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "b0968760387",
                        "content": "[Oracle] If you can\\'t find any oracle methods, maybe I can help you. :)\\n\\nselect to_char(date_id) date_id, make_name ,\\ncount(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom DailySales\\ngroup by date_id,make_name"
                    },
                    {
                        "username": "TuanMinh03",
                        "content": "MS SQL Server\\n\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select date_id, make_name ,\\ncount(distinct lead_id)  unique_leads ,\\ncount(distinct partner_id)  unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id ASC;"
                    }
                ]
            },
            {
                "id": 1792128,
                "content": [
                    {
                        "username": "satyadeep0987",
                        "content": "--SQL server  and MySQL\\n\\nselect date_id   , make_name , count(distinct lead_id  ) unique_leads ,\\ncount( distinct partner_id ) unique_partners from DailySales group by date_id   , make_name\\n\\n--Orcle\\n\\nselect to_char(date_id,\\'yyyy-mm-dd\\') date_id  ,\\n make_name , count(distinct lead_id  ) unique_leads ,\\n count( distinct partner_id ) unique_partners \\n from DailySales group by to_char(date_id,\\'yyyy-mm-dd\\')   , make_name"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id, make_name\\n```"
                    },
                    {
                        "username": "algo247",
                        "content": "WITH DAILY_ID AS (SELECT *\\n                  FROM DailySales)\\n\\nSELECT date_id,make_name,count(distinct lead_id) AS \\'Unique_Leads\\' ,count(distinct partner_id) AS \\'Unique_Partners\\'\\nFROM DAILY_ID\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "sumangupta9250",
                        "content": "what is the issue with my code its not running?\\nSELECT \\ndate_id,make_name,\\ncount( DISTINCT lead_id) as unique_leads,\\ncount (DISTINCT partner_id) as unique_partners\\nfrom DailySales;"
                    },
                    {
                        "username": "Vikash_99",
                        "content": "you need to group  it according to date_id and make_name"
                    },
                    {
                        "username": "edithi",
                        "content": "You need to group the DailySales table by the columns \\'date_id\\' and \\'make_name\\'. This can be done using the groupby function in pandas.\\n\\nAfter grouping, you need to calculate the number of unique lead IDs and partner IDs for each group. You can achieve this using the nunique function within the agg function.\\n\\nFinally, create a new DataFrame using the grouped and aggregated data, with columns \\'date_id\\', \\'make_name\\', \\'unique_leads\\', and \\'unique_partners\\'.\\n\\nRemember to sort the result by \\'date_id\\' and feel free to return the new DataFrame as the output of your function."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select  date_id,make_name,  count(distinct lead_id ) unique_leads, count(distinct partner_id ) unique_partners from DailySales\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "b0968760387",
                        "content": "[Oracle] If you can\\'t find any oracle methods, maybe I can help you. :)\\n\\nselect to_char(date_id) date_id, make_name ,\\ncount(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom DailySales\\ngroup by date_id,make_name"
                    },
                    {
                        "username": "TuanMinh03",
                        "content": "MS SQL Server\\n\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select date_id, make_name ,\\ncount(distinct lead_id)  unique_leads ,\\ncount(distinct partner_id)  unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id ASC;"
                    }
                ]
            },
            {
                "id": 1771105,
                "content": [
                    {
                        "username": "satyadeep0987",
                        "content": "--SQL server  and MySQL\\n\\nselect date_id   , make_name , count(distinct lead_id  ) unique_leads ,\\ncount( distinct partner_id ) unique_partners from DailySales group by date_id   , make_name\\n\\n--Orcle\\n\\nselect to_char(date_id,\\'yyyy-mm-dd\\') date_id  ,\\n make_name , count(distinct lead_id  ) unique_leads ,\\n count( distinct partner_id ) unique_partners \\n from DailySales group by to_char(date_id,\\'yyyy-mm-dd\\')   , make_name"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id, make_name\\n```"
                    },
                    {
                        "username": "algo247",
                        "content": "WITH DAILY_ID AS (SELECT *\\n                  FROM DailySales)\\n\\nSELECT date_id,make_name,count(distinct lead_id) AS \\'Unique_Leads\\' ,count(distinct partner_id) AS \\'Unique_Partners\\'\\nFROM DAILY_ID\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "sumangupta9250",
                        "content": "what is the issue with my code its not running?\\nSELECT \\ndate_id,make_name,\\ncount( DISTINCT lead_id) as unique_leads,\\ncount (DISTINCT partner_id) as unique_partners\\nfrom DailySales;"
                    },
                    {
                        "username": "Vikash_99",
                        "content": "you need to group  it according to date_id and make_name"
                    },
                    {
                        "username": "edithi",
                        "content": "You need to group the DailySales table by the columns \\'date_id\\' and \\'make_name\\'. This can be done using the groupby function in pandas.\\n\\nAfter grouping, you need to calculate the number of unique lead IDs and partner IDs for each group. You can achieve this using the nunique function within the agg function.\\n\\nFinally, create a new DataFrame using the grouped and aggregated data, with columns \\'date_id\\', \\'make_name\\', \\'unique_leads\\', and \\'unique_partners\\'.\\n\\nRemember to sort the result by \\'date_id\\' and feel free to return the new DataFrame as the output of your function."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select  date_id,make_name,  count(distinct lead_id ) unique_leads, count(distinct partner_id ) unique_partners from DailySales\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "b0968760387",
                        "content": "[Oracle] If you can\\'t find any oracle methods, maybe I can help you. :)\\n\\nselect to_char(date_id) date_id, make_name ,\\ncount(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom DailySales\\ngroup by date_id,make_name"
                    },
                    {
                        "username": "TuanMinh03",
                        "content": "MS SQL Server\\n\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select date_id, make_name ,\\ncount(distinct lead_id)  unique_leads ,\\ncount(distinct partner_id)  unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id ASC;"
                    }
                ]
            },
            {
                "id": 1570849,
                "content": [
                    {
                        "username": "satyadeep0987",
                        "content": "--SQL server  and MySQL\\n\\nselect date_id   , make_name , count(distinct lead_id  ) unique_leads ,\\ncount( distinct partner_id ) unique_partners from DailySales group by date_id   , make_name\\n\\n--Orcle\\n\\nselect to_char(date_id,\\'yyyy-mm-dd\\') date_id  ,\\n make_name , count(distinct lead_id  ) unique_leads ,\\n count( distinct partner_id ) unique_partners \\n from DailySales group by to_char(date_id,\\'yyyy-mm-dd\\')   , make_name"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id, make_name\\n```"
                    },
                    {
                        "username": "algo247",
                        "content": "WITH DAILY_ID AS (SELECT *\\n                  FROM DailySales)\\n\\nSELECT date_id,make_name,count(distinct lead_id) AS \\'Unique_Leads\\' ,count(distinct partner_id) AS \\'Unique_Partners\\'\\nFROM DAILY_ID\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "sumangupta9250",
                        "content": "what is the issue with my code its not running?\\nSELECT \\ndate_id,make_name,\\ncount( DISTINCT lead_id) as unique_leads,\\ncount (DISTINCT partner_id) as unique_partners\\nfrom DailySales;"
                    },
                    {
                        "username": "Vikash_99",
                        "content": "you need to group  it according to date_id and make_name"
                    },
                    {
                        "username": "edithi",
                        "content": "You need to group the DailySales table by the columns \\'date_id\\' and \\'make_name\\'. This can be done using the groupby function in pandas.\\n\\nAfter grouping, you need to calculate the number of unique lead IDs and partner IDs for each group. You can achieve this using the nunique function within the agg function.\\n\\nFinally, create a new DataFrame using the grouped and aggregated data, with columns \\'date_id\\', \\'make_name\\', \\'unique_leads\\', and \\'unique_partners\\'.\\n\\nRemember to sort the result by \\'date_id\\' and feel free to return the new DataFrame as the output of your function."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select  date_id,make_name,  count(distinct lead_id ) unique_leads, count(distinct partner_id ) unique_partners from DailySales\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "b0968760387",
                        "content": "[Oracle] If you can\\'t find any oracle methods, maybe I can help you. :)\\n\\nselect to_char(date_id) date_id, make_name ,\\ncount(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom DailySales\\ngroup by date_id,make_name"
                    },
                    {
                        "username": "TuanMinh03",
                        "content": "MS SQL Server\\n\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select date_id, make_name ,\\ncount(distinct lead_id)  unique_leads ,\\ncount(distinct partner_id)  unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id ASC;"
                    }
                ]
            },
            {
                "id": 1804375,
                "content": [
                    {
                        "username": "satyadeep0987",
                        "content": "--SQL server  and MySQL\\n\\nselect date_id   , make_name , count(distinct lead_id  ) unique_leads ,\\ncount( distinct partner_id ) unique_partners from DailySales group by date_id   , make_name\\n\\n--Orcle\\n\\nselect to_char(date_id,\\'yyyy-mm-dd\\') date_id  ,\\n make_name , count(distinct lead_id  ) unique_leads ,\\n count( distinct partner_id ) unique_partners \\n from DailySales group by to_char(date_id,\\'yyyy-mm-dd\\')   , make_name"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id, make_name\\n```"
                    },
                    {
                        "username": "algo247",
                        "content": "WITH DAILY_ID AS (SELECT *\\n                  FROM DailySales)\\n\\nSELECT date_id,make_name,count(distinct lead_id) AS \\'Unique_Leads\\' ,count(distinct partner_id) AS \\'Unique_Partners\\'\\nFROM DAILY_ID\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "sumangupta9250",
                        "content": "what is the issue with my code its not running?\\nSELECT \\ndate_id,make_name,\\ncount( DISTINCT lead_id) as unique_leads,\\ncount (DISTINCT partner_id) as unique_partners\\nfrom DailySales;"
                    },
                    {
                        "username": "Vikash_99",
                        "content": "you need to group  it according to date_id and make_name"
                    },
                    {
                        "username": "edithi",
                        "content": "You need to group the DailySales table by the columns \\'date_id\\' and \\'make_name\\'. This can be done using the groupby function in pandas.\\n\\nAfter grouping, you need to calculate the number of unique lead IDs and partner IDs for each group. You can achieve this using the nunique function within the agg function.\\n\\nFinally, create a new DataFrame using the grouped and aggregated data, with columns \\'date_id\\', \\'make_name\\', \\'unique_leads\\', and \\'unique_partners\\'.\\n\\nRemember to sort the result by \\'date_id\\' and feel free to return the new DataFrame as the output of your function."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select  date_id,make_name,  count(distinct lead_id ) unique_leads, count(distinct partner_id ) unique_partners from DailySales\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "b0968760387",
                        "content": "[Oracle] If you can\\'t find any oracle methods, maybe I can help you. :)\\n\\nselect to_char(date_id) date_id, make_name ,\\ncount(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom DailySales\\ngroup by date_id,make_name"
                    },
                    {
                        "username": "TuanMinh03",
                        "content": "MS SQL Server\\n\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select date_id, make_name ,\\ncount(distinct lead_id)  unique_leads ,\\ncount(distinct partner_id)  unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id ASC;"
                    }
                ]
            },
            {
                "id": 1576844,
                "content": [
                    {
                        "username": "satyadeep0987",
                        "content": "--SQL server  and MySQL\\n\\nselect date_id   , make_name , count(distinct lead_id  ) unique_leads ,\\ncount( distinct partner_id ) unique_partners from DailySales group by date_id   , make_name\\n\\n--Orcle\\n\\nselect to_char(date_id,\\'yyyy-mm-dd\\') date_id  ,\\n make_name , count(distinct lead_id  ) unique_leads ,\\n count( distinct partner_id ) unique_partners \\n from DailySales group by to_char(date_id,\\'yyyy-mm-dd\\')   , make_name"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id, make_name\\n```"
                    },
                    {
                        "username": "algo247",
                        "content": "WITH DAILY_ID AS (SELECT *\\n                  FROM DailySales)\\n\\nSELECT date_id,make_name,count(distinct lead_id) AS \\'Unique_Leads\\' ,count(distinct partner_id) AS \\'Unique_Partners\\'\\nFROM DAILY_ID\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "sumangupta9250",
                        "content": "what is the issue with my code its not running?\\nSELECT \\ndate_id,make_name,\\ncount( DISTINCT lead_id) as unique_leads,\\ncount (DISTINCT partner_id) as unique_partners\\nfrom DailySales;"
                    },
                    {
                        "username": "Vikash_99",
                        "content": "you need to group  it according to date_id and make_name"
                    },
                    {
                        "username": "edithi",
                        "content": "You need to group the DailySales table by the columns \\'date_id\\' and \\'make_name\\'. This can be done using the groupby function in pandas.\\n\\nAfter grouping, you need to calculate the number of unique lead IDs and partner IDs for each group. You can achieve this using the nunique function within the agg function.\\n\\nFinally, create a new DataFrame using the grouped and aggregated data, with columns \\'date_id\\', \\'make_name\\', \\'unique_leads\\', and \\'unique_partners\\'.\\n\\nRemember to sort the result by \\'date_id\\' and feel free to return the new DataFrame as the output of your function."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select  date_id,make_name,  count(distinct lead_id ) unique_leads, count(distinct partner_id ) unique_partners from DailySales\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "b0968760387",
                        "content": "[Oracle] If you can\\'t find any oracle methods, maybe I can help you. :)\\n\\nselect to_char(date_id) date_id, make_name ,\\ncount(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom DailySales\\ngroup by date_id,make_name"
                    },
                    {
                        "username": "TuanMinh03",
                        "content": "MS SQL Server\\n\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select date_id, make_name ,\\ncount(distinct lead_id)  unique_leads ,\\ncount(distinct partner_id)  unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id ASC;"
                    }
                ]
            },
            {
                "id": 2072988,
                "content": [
                    {
                        "username": "satyadeep0987",
                        "content": "--SQL server  and MySQL\\n\\nselect date_id   , make_name , count(distinct lead_id  ) unique_leads ,\\ncount( distinct partner_id ) unique_partners from DailySales group by date_id   , make_name\\n\\n--Orcle\\n\\nselect to_char(date_id,\\'yyyy-mm-dd\\') date_id  ,\\n make_name , count(distinct lead_id  ) unique_leads ,\\n count( distinct partner_id ) unique_partners \\n from DailySales group by to_char(date_id,\\'yyyy-mm-dd\\')   , make_name"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id, make_name\\n```"
                    },
                    {
                        "username": "algo247",
                        "content": "WITH DAILY_ID AS (SELECT *\\n                  FROM DailySales)\\n\\nSELECT date_id,make_name,count(distinct lead_id) AS \\'Unique_Leads\\' ,count(distinct partner_id) AS \\'Unique_Partners\\'\\nFROM DAILY_ID\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "sumangupta9250",
                        "content": "what is the issue with my code its not running?\\nSELECT \\ndate_id,make_name,\\ncount( DISTINCT lead_id) as unique_leads,\\ncount (DISTINCT partner_id) as unique_partners\\nfrom DailySales;"
                    },
                    {
                        "username": "Vikash_99",
                        "content": "you need to group  it according to date_id and make_name"
                    },
                    {
                        "username": "edithi",
                        "content": "You need to group the DailySales table by the columns \\'date_id\\' and \\'make_name\\'. This can be done using the groupby function in pandas.\\n\\nAfter grouping, you need to calculate the number of unique lead IDs and partner IDs for each group. You can achieve this using the nunique function within the agg function.\\n\\nFinally, create a new DataFrame using the grouped and aggregated data, with columns \\'date_id\\', \\'make_name\\', \\'unique_leads\\', and \\'unique_partners\\'.\\n\\nRemember to sort the result by \\'date_id\\' and feel free to return the new DataFrame as the output of your function."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select  date_id,make_name,  count(distinct lead_id ) unique_leads, count(distinct partner_id ) unique_partners from DailySales\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "b0968760387",
                        "content": "[Oracle] If you can\\'t find any oracle methods, maybe I can help you. :)\\n\\nselect to_char(date_id) date_id, make_name ,\\ncount(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom DailySales\\ngroup by date_id,make_name"
                    },
                    {
                        "username": "TuanMinh03",
                        "content": "MS SQL Server\\n\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select date_id, make_name ,\\ncount(distinct lead_id)  unique_leads ,\\ncount(distinct partner_id)  unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id ASC;"
                    }
                ]
            },
            {
                "id": 2010146,
                "content": [
                    {
                        "username": "satyadeep0987",
                        "content": "--SQL server  and MySQL\\n\\nselect date_id   , make_name , count(distinct lead_id  ) unique_leads ,\\ncount( distinct partner_id ) unique_partners from DailySales group by date_id   , make_name\\n\\n--Orcle\\n\\nselect to_char(date_id,\\'yyyy-mm-dd\\') date_id  ,\\n make_name , count(distinct lead_id  ) unique_leads ,\\n count( distinct partner_id ) unique_partners \\n from DailySales group by to_char(date_id,\\'yyyy-mm-dd\\')   , make_name"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id, make_name\\n```"
                    },
                    {
                        "username": "algo247",
                        "content": "WITH DAILY_ID AS (SELECT *\\n                  FROM DailySales)\\n\\nSELECT date_id,make_name,count(distinct lead_id) AS \\'Unique_Leads\\' ,count(distinct partner_id) AS \\'Unique_Partners\\'\\nFROM DAILY_ID\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "sumangupta9250",
                        "content": "what is the issue with my code its not running?\\nSELECT \\ndate_id,make_name,\\ncount( DISTINCT lead_id) as unique_leads,\\ncount (DISTINCT partner_id) as unique_partners\\nfrom DailySales;"
                    },
                    {
                        "username": "Vikash_99",
                        "content": "you need to group  it according to date_id and make_name"
                    },
                    {
                        "username": "edithi",
                        "content": "You need to group the DailySales table by the columns \\'date_id\\' and \\'make_name\\'. This can be done using the groupby function in pandas.\\n\\nAfter grouping, you need to calculate the number of unique lead IDs and partner IDs for each group. You can achieve this using the nunique function within the agg function.\\n\\nFinally, create a new DataFrame using the grouped and aggregated data, with columns \\'date_id\\', \\'make_name\\', \\'unique_leads\\', and \\'unique_partners\\'.\\n\\nRemember to sort the result by \\'date_id\\' and feel free to return the new DataFrame as the output of your function."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select  date_id,make_name,  count(distinct lead_id ) unique_leads, count(distinct partner_id ) unique_partners from DailySales\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "b0968760387",
                        "content": "[Oracle] If you can\\'t find any oracle methods, maybe I can help you. :)\\n\\nselect to_char(date_id) date_id, make_name ,\\ncount(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom DailySales\\ngroup by date_id,make_name"
                    },
                    {
                        "username": "TuanMinh03",
                        "content": "MS SQL Server\\n\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select date_id, make_name ,\\ncount(distinct lead_id)  unique_leads ,\\ncount(distinct partner_id)  unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id ASC;"
                    }
                ]
            },
            {
                "id": 1864533,
                "content": [
                    {
                        "username": "satyadeep0987",
                        "content": "--SQL server  and MySQL\\n\\nselect date_id   , make_name , count(distinct lead_id  ) unique_leads ,\\ncount( distinct partner_id ) unique_partners from DailySales group by date_id   , make_name\\n\\n--Orcle\\n\\nselect to_char(date_id,\\'yyyy-mm-dd\\') date_id  ,\\n make_name , count(distinct lead_id  ) unique_leads ,\\n count( distinct partner_id ) unique_partners \\n from DailySales group by to_char(date_id,\\'yyyy-mm-dd\\')   , make_name"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id, make_name\\n```"
                    },
                    {
                        "username": "algo247",
                        "content": "WITH DAILY_ID AS (SELECT *\\n                  FROM DailySales)\\n\\nSELECT date_id,make_name,count(distinct lead_id) AS \\'Unique_Leads\\' ,count(distinct partner_id) AS \\'Unique_Partners\\'\\nFROM DAILY_ID\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "sumangupta9250",
                        "content": "what is the issue with my code its not running?\\nSELECT \\ndate_id,make_name,\\ncount( DISTINCT lead_id) as unique_leads,\\ncount (DISTINCT partner_id) as unique_partners\\nfrom DailySales;"
                    },
                    {
                        "username": "Vikash_99",
                        "content": "you need to group  it according to date_id and make_name"
                    },
                    {
                        "username": "edithi",
                        "content": "You need to group the DailySales table by the columns \\'date_id\\' and \\'make_name\\'. This can be done using the groupby function in pandas.\\n\\nAfter grouping, you need to calculate the number of unique lead IDs and partner IDs for each group. You can achieve this using the nunique function within the agg function.\\n\\nFinally, create a new DataFrame using the grouped and aggregated data, with columns \\'date_id\\', \\'make_name\\', \\'unique_leads\\', and \\'unique_partners\\'.\\n\\nRemember to sort the result by \\'date_id\\' and feel free to return the new DataFrame as the output of your function."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select  date_id,make_name,  count(distinct lead_id ) unique_leads, count(distinct partner_id ) unique_partners from DailySales\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "b0968760387",
                        "content": "[Oracle] If you can\\'t find any oracle methods, maybe I can help you. :)\\n\\nselect to_char(date_id) date_id, make_name ,\\ncount(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom DailySales\\ngroup by date_id,make_name"
                    },
                    {
                        "username": "TuanMinh03",
                        "content": "MS SQL Server\\n\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select date_id, make_name ,\\ncount(distinct lead_id)  unique_leads ,\\ncount(distinct partner_id)  unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id ASC;"
                    }
                ]
            },
            {
                "id": 1844497,
                "content": [
                    {
                        "username": "satyadeep0987",
                        "content": "--SQL server  and MySQL\\n\\nselect date_id   , make_name , count(distinct lead_id  ) unique_leads ,\\ncount( distinct partner_id ) unique_partners from DailySales group by date_id   , make_name\\n\\n--Orcle\\n\\nselect to_char(date_id,\\'yyyy-mm-dd\\') date_id  ,\\n make_name , count(distinct lead_id  ) unique_leads ,\\n count( distinct partner_id ) unique_partners \\n from DailySales group by to_char(date_id,\\'yyyy-mm-dd\\')   , make_name"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id, make_name\\n```"
                    },
                    {
                        "username": "algo247",
                        "content": "WITH DAILY_ID AS (SELECT *\\n                  FROM DailySales)\\n\\nSELECT date_id,make_name,count(distinct lead_id) AS \\'Unique_Leads\\' ,count(distinct partner_id) AS \\'Unique_Partners\\'\\nFROM DAILY_ID\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "sumangupta9250",
                        "content": "what is the issue with my code its not running?\\nSELECT \\ndate_id,make_name,\\ncount( DISTINCT lead_id) as unique_leads,\\ncount (DISTINCT partner_id) as unique_partners\\nfrom DailySales;"
                    },
                    {
                        "username": "Vikash_99",
                        "content": "you need to group  it according to date_id and make_name"
                    },
                    {
                        "username": "edithi",
                        "content": "You need to group the DailySales table by the columns \\'date_id\\' and \\'make_name\\'. This can be done using the groupby function in pandas.\\n\\nAfter grouping, you need to calculate the number of unique lead IDs and partner IDs for each group. You can achieve this using the nunique function within the agg function.\\n\\nFinally, create a new DataFrame using the grouped and aggregated data, with columns \\'date_id\\', \\'make_name\\', \\'unique_leads\\', and \\'unique_partners\\'.\\n\\nRemember to sort the result by \\'date_id\\' and feel free to return the new DataFrame as the output of your function."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select  date_id,make_name,  count(distinct lead_id ) unique_leads, count(distinct partner_id ) unique_partners from DailySales\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "b0968760387",
                        "content": "[Oracle] If you can\\'t find any oracle methods, maybe I can help you. :)\\n\\nselect to_char(date_id) date_id, make_name ,\\ncount(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom DailySales\\ngroup by date_id,make_name"
                    },
                    {
                        "username": "TuanMinh03",
                        "content": "MS SQL Server\\n\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select date_id, make_name ,\\ncount(distinct lead_id)  unique_leads ,\\ncount(distinct partner_id)  unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id ASC;"
                    }
                ]
            },
            {
                "id": 1800723,
                "content": [
                    {
                        "username": "satyadeep0987",
                        "content": "--SQL server  and MySQL\\n\\nselect date_id   , make_name , count(distinct lead_id  ) unique_leads ,\\ncount( distinct partner_id ) unique_partners from DailySales group by date_id   , make_name\\n\\n--Orcle\\n\\nselect to_char(date_id,\\'yyyy-mm-dd\\') date_id  ,\\n make_name , count(distinct lead_id  ) unique_leads ,\\n count( distinct partner_id ) unique_partners \\n from DailySales group by to_char(date_id,\\'yyyy-mm-dd\\')   , make_name"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id, make_name\\n```"
                    },
                    {
                        "username": "algo247",
                        "content": "WITH DAILY_ID AS (SELECT *\\n                  FROM DailySales)\\n\\nSELECT date_id,make_name,count(distinct lead_id) AS \\'Unique_Leads\\' ,count(distinct partner_id) AS \\'Unique_Partners\\'\\nFROM DAILY_ID\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "sumangupta9250",
                        "content": "what is the issue with my code its not running?\\nSELECT \\ndate_id,make_name,\\ncount( DISTINCT lead_id) as unique_leads,\\ncount (DISTINCT partner_id) as unique_partners\\nfrom DailySales;"
                    },
                    {
                        "username": "Vikash_99",
                        "content": "you need to group  it according to date_id and make_name"
                    },
                    {
                        "username": "edithi",
                        "content": "You need to group the DailySales table by the columns \\'date_id\\' and \\'make_name\\'. This can be done using the groupby function in pandas.\\n\\nAfter grouping, you need to calculate the number of unique lead IDs and partner IDs for each group. You can achieve this using the nunique function within the agg function.\\n\\nFinally, create a new DataFrame using the grouped and aggregated data, with columns \\'date_id\\', \\'make_name\\', \\'unique_leads\\', and \\'unique_partners\\'.\\n\\nRemember to sort the result by \\'date_id\\' and feel free to return the new DataFrame as the output of your function."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select  date_id,make_name,  count(distinct lead_id ) unique_leads, count(distinct partner_id ) unique_partners from DailySales\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "b0968760387",
                        "content": "[Oracle] If you can\\'t find any oracle methods, maybe I can help you. :)\\n\\nselect to_char(date_id) date_id, make_name ,\\ncount(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom DailySales\\ngroup by date_id,make_name"
                    },
                    {
                        "username": "TuanMinh03",
                        "content": "MS SQL Server\\n\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select date_id, make_name ,\\ncount(distinct lead_id)  unique_leads ,\\ncount(distinct partner_id)  unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id ASC;"
                    }
                ]
            },
            {
                "id": 1792128,
                "content": [
                    {
                        "username": "satyadeep0987",
                        "content": "--SQL server  and MySQL\\n\\nselect date_id   , make_name , count(distinct lead_id  ) unique_leads ,\\ncount( distinct partner_id ) unique_partners from DailySales group by date_id   , make_name\\n\\n--Orcle\\n\\nselect to_char(date_id,\\'yyyy-mm-dd\\') date_id  ,\\n make_name , count(distinct lead_id  ) unique_leads ,\\n count( distinct partner_id ) unique_partners \\n from DailySales group by to_char(date_id,\\'yyyy-mm-dd\\')   , make_name"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id, make_name\\n```"
                    },
                    {
                        "username": "algo247",
                        "content": "WITH DAILY_ID AS (SELECT *\\n                  FROM DailySales)\\n\\nSELECT date_id,make_name,count(distinct lead_id) AS \\'Unique_Leads\\' ,count(distinct partner_id) AS \\'Unique_Partners\\'\\nFROM DAILY_ID\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "sumangupta9250",
                        "content": "what is the issue with my code its not running?\\nSELECT \\ndate_id,make_name,\\ncount( DISTINCT lead_id) as unique_leads,\\ncount (DISTINCT partner_id) as unique_partners\\nfrom DailySales;"
                    },
                    {
                        "username": "Vikash_99",
                        "content": "you need to group  it according to date_id and make_name"
                    },
                    {
                        "username": "edithi",
                        "content": "You need to group the DailySales table by the columns \\'date_id\\' and \\'make_name\\'. This can be done using the groupby function in pandas.\\n\\nAfter grouping, you need to calculate the number of unique lead IDs and partner IDs for each group. You can achieve this using the nunique function within the agg function.\\n\\nFinally, create a new DataFrame using the grouped and aggregated data, with columns \\'date_id\\', \\'make_name\\', \\'unique_leads\\', and \\'unique_partners\\'.\\n\\nRemember to sort the result by \\'date_id\\' and feel free to return the new DataFrame as the output of your function."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select  date_id,make_name,  count(distinct lead_id ) unique_leads, count(distinct partner_id ) unique_partners from DailySales\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "b0968760387",
                        "content": "[Oracle] If you can\\'t find any oracle methods, maybe I can help you. :)\\n\\nselect to_char(date_id) date_id, make_name ,\\ncount(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom DailySales\\ngroup by date_id,make_name"
                    },
                    {
                        "username": "TuanMinh03",
                        "content": "MS SQL Server\\n\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select date_id, make_name ,\\ncount(distinct lead_id)  unique_leads ,\\ncount(distinct partner_id)  unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id ASC;"
                    }
                ]
            },
            {
                "id": 1771105,
                "content": [
                    {
                        "username": "satyadeep0987",
                        "content": "--SQL server  and MySQL\\n\\nselect date_id   , make_name , count(distinct lead_id  ) unique_leads ,\\ncount( distinct partner_id ) unique_partners from DailySales group by date_id   , make_name\\n\\n--Orcle\\n\\nselect to_char(date_id,\\'yyyy-mm-dd\\') date_id  ,\\n make_name , count(distinct lead_id  ) unique_leads ,\\n count( distinct partner_id ) unique_partners \\n from DailySales group by to_char(date_id,\\'yyyy-mm-dd\\')   , make_name"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\\nSELECT \\n    date_id, make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners \\nFROM \\n    DailySales \\nGROUP BY \\n    date_id, make_name\\n```"
                    },
                    {
                        "username": "algo247",
                        "content": "WITH DAILY_ID AS (SELECT *\\n                  FROM DailySales)\\n\\nSELECT date_id,make_name,count(distinct lead_id) AS \\'Unique_Leads\\' ,count(distinct partner_id) AS \\'Unique_Partners\\'\\nFROM DAILY_ID\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "sumangupta9250",
                        "content": "what is the issue with my code its not running?\\nSELECT \\ndate_id,make_name,\\ncount( DISTINCT lead_id) as unique_leads,\\ncount (DISTINCT partner_id) as unique_partners\\nfrom DailySales;"
                    },
                    {
                        "username": "Vikash_99",
                        "content": "you need to group  it according to date_id and make_name"
                    },
                    {
                        "username": "edithi",
                        "content": "You need to group the DailySales table by the columns \\'date_id\\' and \\'make_name\\'. This can be done using the groupby function in pandas.\\n\\nAfter grouping, you need to calculate the number of unique lead IDs and partner IDs for each group. You can achieve this using the nunique function within the agg function.\\n\\nFinally, create a new DataFrame using the grouped and aggregated data, with columns \\'date_id\\', \\'make_name\\', \\'unique_leads\\', and \\'unique_partners\\'.\\n\\nRemember to sort the result by \\'date_id\\' and feel free to return the new DataFrame as the output of your function."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select  date_id,make_name,  count(distinct lead_id ) unique_leads, count(distinct partner_id ) unique_partners from DailySales\\nGROUP BY date_id,make_name;"
                    },
                    {
                        "username": "b0968760387",
                        "content": "[Oracle] If you can\\'t find any oracle methods, maybe I can help you. :)\\n\\nselect to_char(date_id) date_id, make_name ,\\ncount(distinct lead_id) unique_leads, count(distinct partner_id) unique_partners\\nfrom DailySales\\ngroup by date_id,make_name"
                    },
                    {
                        "username": "TuanMinh03",
                        "content": "MS SQL Server\\n\\nSELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads, COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name;"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select date_id, make_name ,\\ncount(distinct lead_id)  unique_leads ,\\ncount(distinct partner_id)  unique_partners\\nfrom DailySales\\ngroup by date_id, make_name;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT \\n    date_id, \\n    make_name, \\n    COUNT(DISTINCT lead_id) AS unique_leads, \\n    COUNT(DISTINCT partner_id) AS unique_partners\\nFROM DailySales\\nGROUP BY date_id, make_name\\nORDER BY date_id ASC;"
                    }
                ]
            }
        ]
    },
    {
        "title": "The Score of Students Solving Math Expression",
        "question_content": "<p>You are given a string <code>s</code> that contains digits <code>0-9</code>, addition symbols <code>&#39;+&#39;</code>, and multiplication symbols <code>&#39;*&#39;</code> <strong>only</strong>, representing a <strong>valid</strong> math expression of <strong>single digit numbers</strong> (e.g., <code>3+5*2</code>). This expression was given to <code>n</code> elementary school students. The students were instructed to get the answer of the expression by following this <strong>order of operations</strong>:</p>\n\n<ol>\n\t<li>Compute <strong>multiplication</strong>, reading from <strong>left to right</strong>; Then,</li>\n\t<li>Compute <strong>addition</strong>, reading from <strong>left to right</strong>.</li>\n</ol>\n\n<p>You are given an integer array <code>answers</code> of length <code>n</code>, which are the submitted answers of the students in no particular order. You are asked to grade the <code>answers</code>, by following these <strong>rules</strong>:</p>\n\n<ul>\n\t<li>If an answer <strong>equals</strong> the correct answer of the expression, this student will be rewarded <code>5</code> points;</li>\n\t<li>Otherwise, if the answer <strong>could be interpreted</strong> as if the student applied the operators <strong>in the wrong order</strong> but had <strong>correct arithmetic</strong>, this student will be rewarded <code>2</code> points;</li>\n\t<li>Otherwise, this student will be rewarded <code>0</code> points.</li>\n</ul>\n\n<p>Return <em>the sum of the points of the students</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/17/student_solving_math.png\" style=\"width: 678px; height: 109px;\" />\n<pre>\n<strong>Input:</strong> s = &quot;7+3*1*2&quot;, answers = [20,13,42]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> As illustrated above, the correct answer of the expression is 13, therefore one student is rewarded 5 points: [20,<u><strong>13</strong></u>,42]\nA student might have applied the operators in this wrong order: ((7+3)*1)*2 = 20. Therefore one student is rewarded 2 points: [<u><strong>20</strong></u>,13,42]\nThe points for the students are: [2,5,0]. The sum of the points is 2+5+0=7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;3+5*2&quot;, answers = [13,0,10,13,13,16,16]\n<strong>Output:</strong> 19\n<strong>Explanation:</strong> The correct answer of the expression is 13, therefore three students are rewarded 5 points each: [<strong><u>13</u></strong>,0,10,<strong><u>13</u></strong>,<strong><u>13</u></strong>,16,16]\nA student might have applied the operators in this wrong order: ((3+5)*2 = 16. Therefore two students are rewarded 2 points: [13,0,10,13,13,<strong><u>16</u></strong>,<strong><u>16</u></strong>]\nThe points for the students are: [5,0,0,5,5,2,2]. The sum of the points is 5+0+0+5+5+2+2=19.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;6+0*1&quot;, answers = [12,9,6,4,8,6]\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> The correct answer of the expression is 6.\nIf a student had incorrectly done (6+0)*1, the answer would also be 6.\nBy the rules of grading, the students will still be rewarded 5 points (as they got the correct answer), not 2 points.\nThe points for the students are: [0,0,5,0,0,5]. The sum of the points is 10.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= s.length &lt;= 31</code></li>\n\t<li><code>s</code> represents a valid expression that contains only digits <code>0-9</code>, <code>&#39;+&#39;</code>, and <code>&#39;*&#39;</code> only.</li>\n\t<li>All the integer operands in the expression are in the <strong>inclusive</strong> range <code>[0, 9]</code>.</li>\n\t<li><code>1 &lt;=</code> The count of all operators (<code>&#39;+&#39;</code> and <code>&#39;*&#39;</code>) in the math expression <code>&lt;= 15</code></li>\n\t<li>Test data are generated such that the correct answer of the expression is in the range of <code>[0, 1000]</code>.</li>\n\t<li><code>n == answers.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= answers[i] &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1486306,
                "title": "python-java-explanation-with-pictures-dp",
                "content": "Given an expression, since we no longer need to focus on the correct order, thus **every** operator can be the **last** operator toward the final answer. \\nTake picture of expression `1+2*3+4+5*6*7` below as an example.\\n\\n![image](https://assets.leetcode.com/users/images/dfcb2999-8a9e-4378-8106-767ea6db556e_1632628876.348318.png)\\n\\nGenerally, if we choose an operator `k` (Suppose it is \"+\") to be the last operator, all of the possible answers of this expression come from:\\n**a number `lft` from all possible answers of the left part + a number `rgt` from all possible answers of the right part.** \\n\\n> For `x+y`*`i+j` where we let `*` to be the last operator, suppose the set of all the possible answers for left part `x+y` is {a,  b}, the set of all the possible answers for the right part `i+j` is {m, n}. Thus the result set for this expression is:\\n{a + m, a + n, b + m, b + n}, as described below.\\n\\n![image](https://assets.leetcode.com/users/images/72cf2123-a7ba-4b5e-b44a-3b84e004a238_1632628880.5907993.png)\\n\\nTherefore using DP is a promising method. \\nHere is how we use bottom up DP, start with the base case.\\nThe index stands for the sequence of digits only, like `idx = 3` stands for number `4`. \\nApparently, `res[i][i]` only contains `s[i * 2]`.\\n\\n![image](https://assets.leetcode.com/users/images/63569af0-4480-41bb-a338-ebc17e15725c_1632628884.0200899.png)\\n\\nRecall how we get all possible answers for a certain expression. For `res[0][1]` representing all the results from `1+2`, since there is just one operator, thus `res[0][1]`  contains `1 + 2 = 3`, so on so forth.\\n\\n![image](https://assets.leetcode.com/users/images/92f90c67-81ca-48c2-ac3d-dccbc9056994_1632628887.249303.png)\\n\\nWe can fill the second diagonal, each set only contains one number, since it represents the result of one binary operation like `a+b` or `c*d`.\\n![image](https://assets.leetcode.com/users/images/ba2b389a-d69c-4cde-b49c-8b7cac5e4cfb_1632778666.3532066.png)\\n\\nThen, for `dp[0][2]` representing `1+2*3`, like we discussed before, either of the two operators can be the last operator. \\n- If we take `+` as the last operator, the possible results come from: a number from `dp[0][0]` plus `dp[1][2]`, that is: `a from {1}` + `b from {6}`, which is `{7}`.\\n- If we take `*` as the last operator, the possible results come from: a number from `dp[0][1]` mutiply `dp[2][2]`, that is: `a from {3}` * `b from {3}`, which is `{9}`.\\nTherefore, the final set for `1+2*3` is the union of all subsets, that is `{7, 9}`.\\n\\n![image](https://assets.leetcode.com/users/images/3d2e4143-2fa4-4c28-8c45-ba97c874f8f5_1632778798.699839.png)\\n\\nContinue for `dp[0][3]`.\\n![image](https://assets.leetcode.com/users/images/cf6af14a-2178-40fe-af41-f1bc61cfaabe_1632779013.609042.png)\\n\\n\\nFinally, `res[0][-1]` representing the whole expression contains all possible answers.\\nJust count the number of occurrences for each number in `answer` and plus the correlated points.\\n\\n\\n**Python**\\nMy code is ugly, please refer to others for more concise one.\\n\\n```swift\\ndef scoreOfStudents(self, s: str, A: List[int]) -> int:\\n        c = collections.Counter(A)\\n        n = len(s) // 2 + 1\\n        res = [[set() for _ in range(n)] for j in range(n)]\\n        for i in range(n):\\n            res[i][i].add(int(s[2 * i]))\\n        for dif in range(1, n):\\n            for start in range(n - dif):\\n                end = start + dif\\n                curset = set()\\n                for i in range(start * 2 + 1, end * 2, 2):\\n                    if s[i] == \"+\":\\n                        for a in res[start][i // 2]:\\n                            for b in res[i//2 + 1][end]:\\n                                if a + b <= 1000:\\n                                    curset.add(a + b)\\n                    else:\\n                        for a in res[start][i // 2]:\\n                            for b in res[i//2 + 1][end]:\\n                                if a * b <= 1000:\\n                                    curset.add(a * b)\\n                res[start][end] = curset\\n        ans = 0\\n        crt = eval(s)\\n        for i in res[0][-1]:\\n            if i in c:\\n                if i == crt:\\n                    ans += 5 * c[i]\\n                else:\\n                    ans += 2 * c[i]\\n        return ans\\n```\\n\\n**Java**\\nThe `calculate()` is from [@rexue70](https://leetcode.com/problems/the-score-of-students-solving-math-expression/discuss/1486579/Java-Clean) \\'s answer.\\n\\n```swift\\nimport java.util.Hashtable;\\nclass Solution {\\n    public int calculate(String s) {\\n        int i = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        char operator = \\'+\\';\\n        int num = 0;\\n        while (i < s.length()) {\\n            char ch = s.charAt(i++);\\n            if (ch >= \\'0\\' && ch <= \\'9\\') num = ch - \\'0\\';\\n            if (i >= s.length() || ch == \\'+\\' || ch == \\'*\\') {\\n                if (operator == \\'+\\') stack.push(num);\\n                else if (operator == \\'*\\') stack.push(stack.pop() * num);\\n                operator = ch;\\n                num = 0;\\n            }\\n        }\\n        return stack.stream().mapToInt(Integer::intValue).sum();\\n    }\\n    \\n    public int scoreOfStudents(String s, int[] A) {\\n        int n = (int)(s.length() / 2 + 1);\\n        Set<Integer>[][] res = new Set[n][n];\\n        for (int i = 0; i < n; ++i){\\n            res[i][i] = new HashSet<>();\\n            res[i][i].add(s.charAt(2 * i) - \\'0\\');\\n        }\\n        for (int dif = 1; dif < n; ++dif){\\n            for (int start = 0; start < n - dif; ++start){\\n                int end = start + dif;\\n                res[start][end] = new HashSet<>();\\n                for (int i = start * 2 + 1; i < end * 2; i += 2){\\n                    if (s.charAt(i) - \\'+\\' == 0){\\n                        for (int a : res[start][(int)(i / 2)]){\\n                            for (int b : res[(int)(i / 2 + 1)][end]){\\n                                if (a + b <= 1000) res[start][end].add(a + b);\\n                            }\\n                        }\\n                    } else {\\n                        for (int a : res[start][(int)(i / 2)]){\\n                            for (int b : res[(int)(i / 2 + 1)][end]){\\n                                if (a * b <= 1000) res[start][end].add(a * b);\\n                            }\\n                        }\\n                    }\\n                }              \\n            }\\n        }\\n        \\n        int correct = calculate(s), ans = 0;\\n        for (int a : A){\\n            if (a == correct) ans += 5;\\n            else if (res[0][n - 1].contains(a)) ans += 2;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```swift\\ndef scoreOfStudents(self, s: str, A: List[int]) -> int:\\n        c = collections.Counter(A)\\n        n = len(s) // 2 + 1\\n        res = [[set() for _ in range(n)] for j in range(n)]\\n        for i in range(n):\\n            res[i][i].add(int(s[2 * i]))\\n        for dif in range(1, n):\\n            for start in range(n - dif):\\n                end = start + dif\\n                curset = set()\\n                for i in range(start * 2 + 1, end * 2, 2):\\n                    if s[i] == \"+\":\\n                        for a in res[start][i // 2]:\\n                            for b in res[i//2 + 1][end]:\\n                                if a + b <= 1000:\\n                                    curset.add(a + b)\\n                    else:\\n                        for a in res[start][i // 2]:\\n                            for b in res[i//2 + 1][end]:\\n                                if a * b <= 1000:\\n                                    curset.add(a * b)\\n                res[start][end] = curset\\n        ans = 0\\n        crt = eval(s)\\n        for i in res[0][-1]:\\n            if i in c:\\n                if i == crt:\\n                    ans += 5 * c[i]\\n                else:\\n                    ans += 2 * c[i]\\n        return ans\\n```\n```swift\\nimport java.util.Hashtable;\\nclass Solution {\\n    public int calculate(String s) {\\n        int i = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        char operator = \\'+\\';\\n        int num = 0;\\n        while (i < s.length()) {\\n            char ch = s.charAt(i++);\\n            if (ch >= \\'0\\' && ch <= \\'9\\') num = ch - \\'0\\';\\n            if (i >= s.length() || ch == \\'+\\' || ch == \\'*\\') {\\n                if (operator == \\'+\\') stack.push(num);\\n                else if (operator == \\'*\\') stack.push(stack.pop() * num);\\n                operator = ch;\\n                num = 0;\\n            }\\n        }\\n        return stack.stream().mapToInt(Integer::intValue).sum();\\n    }\\n    \\n    public int scoreOfStudents(String s, int[] A) {\\n        int n = (int)(s.length() / 2 + 1);\\n        Set<Integer>[][] res = new Set[n][n];\\n        for (int i = 0; i < n; ++i){\\n            res[i][i] = new HashSet<>();\\n            res[i][i].add(s.charAt(2 * i) - \\'0\\');\\n        }\\n        for (int dif = 1; dif < n; ++dif){\\n            for (int start = 0; start < n - dif; ++start){\\n                int end = start + dif;\\n                res[start][end] = new HashSet<>();\\n                for (int i = start * 2 + 1; i < end * 2; i += 2){\\n                    if (s.charAt(i) - \\'+\\' == 0){\\n                        for (int a : res[start][(int)(i / 2)]){\\n                            for (int b : res[(int)(i / 2 + 1)][end]){\\n                                if (a + b <= 1000) res[start][end].add(a + b);\\n                            }\\n                        }\\n                    } else {\\n                        for (int a : res[start][(int)(i / 2)]){\\n                            for (int b : res[(int)(i / 2 + 1)][end]){\\n                                if (a * b <= 1000) res[start][end].add(a * b);\\n                            }\\n                        }\\n                    }\\n                }              \\n            }\\n        }\\n        \\n        int correct = calculate(s), ans = 0;\\n        for (int a : A){\\n            if (a == correct) ans += 5;\\n            else if (res[0][n - 1].contains(a)) ans += 2;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486296,
                "title": "python-dp-solution-with-complexity-analysis",
                "content": "# **Explanation**\\n`dp(i, j)` will return all possible result for the substring from `s[i]` to `s[j]`.\\nWe enumerate the last operation `s[m]`, which could be\\n`s[m] = s[i+1], s[i+3] ,..., s[j-1]`\\n\\nThen we dfs-like find out the results for left part and right part.\\nWe calculate the combine result of the whole substring with operation `s[m]`.\\n\\nOne import optimization is that `0 <= answers[i] <= 1000`,\\nso we will drop the result bigger than 1000.\\n<br>\\n\\n# **Complexity Analysis**\\nSorry, I made it wrong at first.\\n\\nRoughly speaking, it\\'s ``O(k^3 * 1000^2)`\\nEnumerating all substrings O(k^2),\\nthen for each substring,\\nthere are O(k) ways to break it into two parts,\\nthen executing the math takes at most 1000^2.\\n(by @HoarseBox)\\n\\n\\nMore precisely,\\n`size_a = min(1000, size(a)!)`\\n`size_b = min(1000, size(b)!)`\\n`k = 15 - size_a - size_b`, where `k > 0`\\n\\nThe total complexity is the sum of\\n`size_a * size_b * k`\\nwhich is about 10 millions.\\n\\nI\\'ll say the constraint of `0 <= answers[i] <= 1000` is boring.\\nThe solution brute forces all possibilities,\\nbut need to pay attention to this constraints to get accepted.\\n\\n**Python**\\n```py\\n    def scoreOfStudents(self, s, answers):\\n\\n        @functools.lru_cache(None)\\n        def dp(i, j):\\n            if i == j:\\n                return {int(s[i])}\\n            res = {}\\n            for m in range(i + 1, j, 2):\\n                for a in dp(i, m - 1):\\n                    for b in dp(m + 1, j):\\n                        cur = a * b if s[m] == \\'*\\' else a + b\\n                        if cur <= 1000:  # opt with 0 <= answers[i] <= 1000\\n                            res[cur] = 2\\n            return res\\n\\n        res = {**dp(0, len(s) - 1), **{eval(s): 5}}\\n        return sum(res.get(a, 0) for a in answers)\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def scoreOfStudents(self, s, answers):\\n\\n        @functools.lru_cache(None)\\n        def dp(i, j):\\n            if i == j:\\n                return {int(s[i])}\\n            res = {}\\n            for m in range(i + 1, j, 2):\\n                for a in dp(i, m - 1):\\n                    for b in dp(m + 1, j):\\n                        cur = a * b if s[m] == \\'*\\' else a + b\\n                        if cur <= 1000:  # opt with 0 <= answers[i] <= 1000\\n                            res[cur] = 2\\n            return res\\n\\n        res = {**dp(0, len(s) - 1), **{eval(s): 5}}\\n        return sum(res.get(a, 0) for a in answers)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1486991,
                "title": "312-burst-balloons",
                "content": "This one could be very hard if you haven\\'t solved similar problems before. \\n\\nThe idea is similar to [312. Burst Balloons](https://leetcode.com/problems/burst-balloons/). The difference is that we need to track all possible answers.\\n\\nWe go left to right, and pick an operator we will execute **last**. Then, we recursively compute all possible answers from the left and right substrings.\\n\\nThe resulting set of answers will be cartesian product/sum of those answers. \\n\\n> Note that we can prune interim answers exceeding 1000. \\n\\nFor example, `\"1+2*3+4\"` yields **11**, 13, 15, and 21 as possible answers:\\n1. `(1)` + `(2*3+4)` = 15 (1 + 14), 11 (1 + 10)\\n\\t- `(2)` * `(3+4)` = 14\\n\\t- `(2*3)` + `(4)` = 10\\n2. `(1+2)` * `(3+4)` = 21\\n3. `(1+2*3)` + `(4)` = 11 (7 + 4), 13 (9 + 4)\\n\\t- `(1)` + `(2*3)` = 7\\n\\t- `(1+2)` * `(3)` = 9\\n\\nWe memoise the results for substrings defined by starting (`st`) and finishing (`fin`, excluding) points in `memo`.\\n\\n**C++**\\n```cpp\\nunordered_set<int> memo[32][32];\\nvoid dfs(string &s, int st, int fin) {\\n    if (memo[st][fin].empty()) {\\n        if (fin - st == 1)\\n            memo[st][fin].insert(s[st] - \\'0\\');\\n        for (int i = st + 1; i < fin; i += 2) {\\n                dfs(s, st, i);\\n                dfs(s, i + 1, fin);\\n                for (int n1 : memo[st][i]) {\\n                    for (int n2 : memo[i + 1][fin]) {\\n                            int n = s[i] == \\'*\\' ? n1 * n2 : n1 + n2;\\n                            if (n <= 1000)\\n                                memo[st][fin].insert(n);\\n                     }\\n                }\\n        }\\n    }\\n}\\nint scoreOfStudents(string s, vector<int>& answers) {\\n    int correct = 0;\\n    for (int i = 1, j = 0; i <= s.size(); i += 2) \\n        if (i == s.size() || s[i] == \\'+\\') {\\n            int mul = 1;\\n            for (; j < i; j += 2)\\n                mul *= s[j] - \\'0\\';\\n            correct += mul;\\n        }\\n    dfs(s, 0, s.size());\\n    return accumulate(begin(answers), end(answers), 0, [&](int sum, int ans){\\n        return sum + (ans == correct ? 5 :  memo[0][s.size()].count(ans) ? 2 : 0);\\n    });\\n}\\n```\\n**Complexity Analysis**\\n##### Time\\nO(o3 p2), where `o` is the number of operations, and `p` - number of possible answers. Based on this problem constraints, we can potentially have up to 15^ 3 * 1000 ^ 2 = 3,375 * 1,000,000, or 3,3B operations, which is too much. With my experiments, OJ will TLE when we approach 100M operations.\\n\\nWhat happens is that our sub-expressions are too small to generate 1,000 possible answers. In the worst case, I found we need to process ~6,000 possible aswers (before trimming it to 1,000). So, in reality, we need to perform like 1M operations instead of 3.3B. Note that this will not hold true if we increase the expression size.\\n\\n> That\\'s why we are using a hash set (instead of a [0 ... 1000] boolean array) to enumerate possible answers.\\n\\n##### Memory\\nO(o2 p) for `memo`.",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nunordered_set<int> memo[32][32];\\nvoid dfs(string &s, int st, int fin) {\\n    if (memo[st][fin].empty()) {\\n        if (fin - st == 1)\\n            memo[st][fin].insert(s[st] - \\'0\\');\\n        for (int i = st + 1; i < fin; i += 2) {\\n                dfs(s, st, i);\\n                dfs(s, i + 1, fin);\\n                for (int n1 : memo[st][i]) {\\n                    for (int n2 : memo[i + 1][fin]) {\\n                            int n = s[i] == \\'*\\' ? n1 * n2 : n1 + n2;\\n                            if (n <= 1000)\\n                                memo[st][fin].insert(n);\\n                     }\\n                }\\n        }\\n    }\\n}\\nint scoreOfStudents(string s, vector<int>& answers) {\\n    int correct = 0;\\n    for (int i = 1, j = 0; i <= s.size(); i += 2) \\n        if (i == s.size() || s[i] == \\'+\\') {\\n            int mul = 1;\\n            for (; j < i; j += 2)\\n                mul *= s[j] - \\'0\\';\\n            correct += mul;\\n        }\\n    dfs(s, 0, s.size());\\n    return accumulate(begin(answers), end(answers), 0, [&](int sum, int ans){\\n        return sum + (ans == correct ? 5 :  memo[0][s.size()].count(ans) ? 2 : 0);\\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1486297,
                "title": "c-simple",
                "content": "**Algorithm**\\n\\n- Generate All Possible Values(valid or invalid) of the expression.\\n\\t - Logic:\\n\\t\\t - Consider eg: (7 + 3\\\\*1*2 + 4), () denotes the function to find all possible values.\\n\\t\\t\\t - Now all possible values can be find recursively, with following recursive calls.\\n\\t\\t\\t - (7) + (3\\\\*1*2+4)\\n\\t\\t\\t - (7 + 3) * (1*2+4)\\n\\t\\t\\t - (7+3\\\\*1)*(2+4)\\n\\t\\t\\t - (7+3\\\\*1*2)+(4)\\n\\n- Find valid value(correct answer) of the expression, as well.\\n- Iterate over the array to assign the score.\\n\\n**Necessary Optimisation**\\n\\n- We only store the values which are less than or equal to 1000.\\n\\t- because answers[i] <= 1000, as given in the problem statement. \\n\\n```\\nclass Solution {\\npublic:\\n    int Max;\\n    int h(int i, int j) {return i*100+j;}\\n    unordered_map<int, vector<int>> dp;\\n    \\n    int getValid(string &s){\\n        long long valid = 0;\\n        stack<long long> st;\\n        st.push({s[0]-\\'0\\'});\\n        for(int i = 1; i<s.length(); ++i){\\n            if(isdigit(s[i])){\\n                if(s[i-1]==\\'*\\'){\\n                    long long mul = 1ll*st.top()*(s[i]-\\'0\\'); \\n                    st.pop();\\n                    st.push(mul);\\n                }\\n                else st.push({s[i]-\\'0\\'});\\n            }\\n            \\n        }\\n        \\n        while(st.size()) { valid += st.top(); st.pop(); }\\n        return valid;\\n    }\\n    \\n    vector<int> dfs(int i, int j, string &s){\\n        \\n        if(i==j) return {(s[i]-\\'0\\')};  \\n        int hash = h(i,j);\\n        if(!dp.count(hash)) \\n        {\\n            unordered_set<int> possible;\\n            for(int k=i; k<=j-2; k+=2){\\n                vector<int> res1 = dfs(i,k,s), res2 = dfs(k+2,j,s);\\n                for(auto &val1 : res1){ \\n                    for(auto &val2 : res2){\\n                        int val = s[k+1]==\\'*\\'? val1*val2 : val1 + val2; \\n                        if(val<=Max)\\n                            possible.insert(val);\\n                    }\\n                }\\n\\n            }\\n\\n            dp[hash] = vector<int>(possible.begin(), possible.end());\\n        }\\n        return dp[hash];\\n        \\n    }\\n\\n    int scoreOfStudents(string s, vector<int>& ans) {\\n        dp.clear(); Max = 1000;\\n        vector<int> possible = dfs(0, s.length()-1, s);\\n        unordered_set<int> can(possible.begin(), possible.end());        \\n        int valid = getValid(s), res =0;\\n        \\n            \\n        for(auto &val : ans){\\n            if(val==valid) res+=5;\\n            else if(can.count(val)) res+=2;\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int Max;\\n    int h(int i, int j) {return i*100+j;}\\n    unordered_map<int, vector<int>> dp;\\n    \\n    int getValid(string &s){\\n        long long valid = 0;\\n        stack<long long> st;\\n        st.push({s[0]-\\'0\\'});\\n        for(int i = 1; i<s.length(); ++i){\\n            if(isdigit(s[i])){\\n                if(s[i-1]==\\'*\\'){\\n                    long long mul = 1ll*st.top()*(s[i]-\\'0\\'); \\n                    st.pop();\\n                    st.push(mul);\\n                }\\n                else st.push({s[i]-\\'0\\'});\\n            }\\n            \\n        }\\n        \\n        while(st.size()) { valid += st.top(); st.pop(); }\\n        return valid;\\n    }\\n    \\n    vector<int> dfs(int i, int j, string &s){\\n        \\n        if(i==j) return {(s[i]-\\'0\\')};  \\n        int hash = h(i,j);\\n        if(!dp.count(hash)) \\n        {\\n            unordered_set<int> possible;\\n            for(int k=i; k<=j-2; k+=2){\\n                vector<int> res1 = dfs(i,k,s), res2 = dfs(k+2,j,s);\\n                for(auto &val1 : res1){ \\n                    for(auto &val2 : res2){\\n                        int val = s[k+1]==\\'*\\'? val1*val2 : val1 + val2; \\n                        if(val<=Max)\\n                            possible.insert(val);\\n                    }\\n                }\\n\\n            }\\n\\n            dp[hash] = vector<int>(possible.begin(), possible.end());\\n        }\\n        return dp[hash];\\n        \\n    }\\n\\n    int scoreOfStudents(string s, vector<int>& ans) {\\n        dp.clear(); Max = 1000;\\n        vector<int> possible = dfs(0, s.length()-1, s);\\n        unordered_set<int> can(possible.begin(), possible.end());        \\n        int valid = getValid(s), res =0;\\n        \\n            \\n        for(auto &val : ans){\\n            if(val==valid) res+=5;\\n            else if(can.count(val)) res+=2;\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486264,
                "title": "dp-solution-with-explanation",
                "content": "We can compute **all possible solutions** (including incorrect order), then check the `answers` array to calculate the total points.\\n\\nLet\\'s say we have `N = s.length() / 2 + 1` (`N <= 16`) numbers. \\nWe can get the possible solutions from `i`-th number to `j`-th number: `set[i][j]` by considering *any of the operators in between as the last operation*:\\n`set[i][j] = union(left +/* right)` for any `left` in `set[i][k]` and any `right` in `set[k + 1][j]`, where `i <= k < j`.\\n\\n**Time complexity**: O(N^3 * 1e6)\\nO(N^3) to fill every `set[i][j]`, each one we have max `1000 * 1000` values. \\n\\n**Java solution:**\\n```\\nclass Solution {\\n    public int scoreOfStudents(String s, int[] answers) {\\n        final int N = s.length() / 2 + 1;\\n        int correct = calculate(s);      \\n        \\n        Set<Integer>[][] sets = new HashSet[N][N];\\n        for (int i = N - 1; i >= 0; i--) {\\n            sets[i][i] = new HashSet<>();\\n            sets[i][i].add(s.charAt(i * 2) - \\'0\\');\\n            for (int j = i + 1; j < N; j++) {\\n                sets[i][j] = new HashSet<>();\\n                for (int k = i; k < j; k++) {\\n                    for (int left : sets[i][k]) {\\n                        for (int right : sets[k + 1][j]) {\\n                            int ans = s.charAt(2 * k + 1) == \\'+\\' ? left + right : left * right;\\n                            if (ans <= 1000) {\\n                                sets[i][j].add(ans);    \\n                            }                            \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int a : answers) {\\n            if (a == correct) {\\n                res += 5;\\n            } else if (sets[0][N - 1].contains(a)) {\\n                res += 2;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n\\t// calculate the correct answer using stack.\\n    private int calculate(String s) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int i = 0;\\n        while (i < s.length()) {\\n            if (s.charAt(i) == \\'+\\') {\\n                i++;\\n            } else if (Character.isDigit(s.charAt(i))) {\\n                stack.offerFirst(s.charAt(i++) - \\'0\\');\\n            } else {\\n\\t\\t\\t\\t// \\'*\\'\\n                i++;\\n                stack.offerFirst(stack.pollFirst() * (s.charAt(i++) - \\'0\\'));\\n            }            \\n        }\\n        int sum = 0;\\n        while (!stack.isEmpty()) {\\n            sum += stack.pollFirst();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int scoreOfStudents(String s, int[] answers) {\\n        final int N = s.length() / 2 + 1;\\n        int correct = calculate(s);      \\n        \\n        Set<Integer>[][] sets = new HashSet[N][N];\\n        for (int i = N - 1; i >= 0; i--) {\\n            sets[i][i] = new HashSet<>();\\n            sets[i][i].add(s.charAt(i * 2) - \\'0\\');\\n            for (int j = i + 1; j < N; j++) {\\n                sets[i][j] = new HashSet<>();\\n                for (int k = i; k < j; k++) {\\n                    for (int left : sets[i][k]) {\\n                        for (int right : sets[k + 1][j]) {\\n                            int ans = s.charAt(2 * k + 1) == \\'+\\' ? left + right : left * right;\\n                            if (ans <= 1000) {\\n                                sets[i][j].add(ans);    \\n                            }                            \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int a : answers) {\\n            if (a == correct) {\\n                res += 5;\\n            } else if (sets[0][N - 1].contains(a)) {\\n                res += 2;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n\\t// calculate the correct answer using stack.\\n    private int calculate(String s) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int i = 0;\\n        while (i < s.length()) {\\n            if (s.charAt(i) == \\'+\\') {\\n                i++;\\n            } else if (Character.isDigit(s.charAt(i))) {\\n                stack.offerFirst(s.charAt(i++) - \\'0\\');\\n            } else {\\n\\t\\t\\t\\t// \\'*\\'\\n                i++;\\n                stack.offerFirst(stack.pollFirst() * (s.charAt(i++) - \\'0\\'));\\n            }            \\n        }\\n        int sum = 0;\\n        while (!stack.isEmpty()) {\\n            sum += stack.pollFirst();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486282,
                "title": "javascript-dp",
                "content": "dp[expression] represent all the possible answers by expression\\nWe split the expression to left part and right part and calculate all the possible answers.\\nWe can prune answers which is larger than 1000 ( got TLE if don\\'t have this).\\n```\\nconst op = {\\n    \\'+\\': ((a, b) => Number(a) + Number(b)),\\n    \\'*\\':((a, b) => a * b),\\n}\\nlet dp = {};\\nconst dfs = (s) => {\\n    \\n    if(s.length == 0) return {};\\n    if(s.length == 1) return { [s[0]] : 1};\\n    const dps = dp[s];\\n    if(dps) return dps;\\n    const res = {};\\n    for(let i = 0; i < s.length - 2; i += 2) {\\n        const l = dfs(s.substr(0, i + 1))\\n        const r = dfs(s.substr(i + 2, s.length - i - 2));\\n        for(let x in l) {\\n            for(let y in r) {\\n                const z = op[s[i + 1]](x, y);\\n                if(z > 1000) continue;\\n                res[z] = 1;\\n            }\\n        }\\n        \\n    }\\n    dp[s] = res;\\n    return res;\\n}\\n\\nvar scoreOfStudents = function(s, answers) {\\n    const correct = eval(s);\\n    dp = {};\\n    const allAns = dfs(s);\\n    let ans = 0;\\n    answers.forEach(x => {\\n        if(  x == correct) ans += 5;\\n        else if(allAns[x]) ans += 2;\\n    })\\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst op = {\\n    \\'+\\': ((a, b) => Number(a) + Number(b)),\\n    \\'*\\':((a, b) => a * b),\\n}\\nlet dp = {};\\nconst dfs = (s) => {\\n    \\n    if(s.length == 0) return {};\\n    if(s.length == 1) return { [s[0]] : 1};\\n    const dps = dp[s];\\n    if(dps) return dps;\\n    const res = {};\\n    for(let i = 0; i < s.length - 2; i += 2) {\\n        const l = dfs(s.substr(0, i + 1))\\n        const r = dfs(s.substr(i + 2, s.length - i - 2));\\n        for(let x in l) {\\n            for(let y in r) {\\n                const z = op[s[i + 1]](x, y);\\n                if(z > 1000) continue;\\n                res[z] = 1;\\n            }\\n        }\\n        \\n    }\\n    dp[s] = res;\\n    return res;\\n}\\n\\nvar scoreOfStudents = function(s, answers) {\\n    const correct = eval(s);\\n    dp = {};\\n    const allAns = dfs(s);\\n    let ans = 0;\\n    answers.forEach(x => {\\n        if(  x == correct) ans += 5;\\n        else if(allAns[x]) ans += 2;\\n    })\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1486645,
                "title": "c-top-down-dp-easy-to-understand",
                "content": "```\\n//dp[l][r] -> stores all distinct possible answers which can be generated from substring [l.....r] of given expression\\nclass Solution {\\npublic:\\n    unordered_set<int> find(int l,int r,string &s,vector<vector<unordered_set<int>>> &dp){\\n        unordered_set<int> temp;\\n        if(l>r) \\n            return temp;\\n        if(!dp[l][r].empty())\\n            return dp[l][r];\\n        \\n        //for a single element i.e an operand , just insert it in the unordered set\\n        if(l==r){\\n            int x=s[l]-\\'0\\';\\n            temp.insert(x);\\n            return temp;\\n        }\\n\\t\\t//We can move two positions ahead in the below for loop as the operands are of single digit.\\n        for(int i=l+1;i<r;i+=2){\\n            //If we encounter a operator, split the string in two parts here and calculate possible answers for left and right part seperately and finally combine them using the current operator\\n            if(!isdigit(s[i])){\\n                char op=s[i];// current operator\\n                unordered_set<int> left =find(l,i-1,s,dp);\\n                unordered_set<int> right=find(i+1,r,s,dp);\\n                for(auto &i:left){\\n                    for(auto &j:right){\\n                        if(op==\\'+\\'){\\n                            int val=i+j;\\n                            //skip the generated values if it is greater than 1000 because it\\'s given in the question the answer lies in the range [0,1000]\\n                            if(val>1000)\\n                                continue;\\n                            temp.insert(val);\\n                        }\\n                        else{\\n                            int val=i*j;\\n                            if(val>1000)\\n                                continue;\\n                            temp.insert(val);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[l][r]=temp;\\n    }\\n    int solve(string &s){\\n        //First of all compute all products \\n      \\n        vector<int> ans; //ans stores values which just needs to be added\\n\\t\\t\\n        int sum=0,product=1;\\n        int i=0;\\n        int n=s.size();\\n        while(i<n){\\n            if(s[i]==\\'+\\'){\\n                ans.push_back(product);\\n                product=1;\\n            }\\n            else if(s[i]!=\\'*\\'){\\n                product=product*(s[i]-\\'0\\');\\n            }\\n            i++;\\n        }\\n        ans.push_back(product);\\n        for(auto &i:ans){\\n            sum+=i;\\n        }\\n        return sum;\\n    }\\n    int scoreOfStudents(string s, vector<int>& ans) {\\n        int n=s.size();\\n        vector<vector<unordered_set<int>>> dp(n,vector<unordered_set<int>>(n));\\n        \\n        unordered_set<int> res=find(0,n-1,s,dp);\\n        \\n        \\n        // solve function calculates actual value of expression according to the order of operations given in question\\n        int actual=solve(s);\\n    \\n        int sum=0;\\n        for(auto &i:ans){\\n            if(i==actual){\\n                sum+=5;\\n            }\\n            else if(res.find(i)!=res.end())\\n                sum+=2;\\n        }\\n        return sum;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//dp[l][r] -> stores all distinct possible answers which can be generated from substring [l.....r] of given expression\\nclass Solution {\\npublic:\\n    unordered_set<int> find(int l,int r,string &s,vector<vector<unordered_set<int>>> &dp){\\n        unordered_set<int> temp;\\n        if(l>r) \\n            return temp;\\n        if(!dp[l][r].empty())\\n            return dp[l][r];\\n        \\n        //for a single element i.e an operand , just insert it in the unordered set\\n        if(l==r){\\n            int x=s[l]-\\'0\\';\\n            temp.insert(x);\\n            return temp;\\n        }\\n\\t\\t//We can move two positions ahead in the below for loop as the operands are of single digit.\\n        for(int i=l+1;i<r;i+=2){\\n            //If we encounter a operator, split the string in two parts here and calculate possible answers for left and right part seperately and finally combine them using the current operator\\n            if(!isdigit(s[i])){\\n                char op=s[i];// current operator\\n                unordered_set<int> left =find(l,i-1,s,dp);\\n                unordered_set<int> right=find(i+1,r,s,dp);\\n                for(auto &i:left){\\n                    for(auto &j:right){\\n                        if(op==\\'+\\'){\\n                            int val=i+j;\\n                            //skip the generated values if it is greater than 1000 because it\\'s given in the question the answer lies in the range [0,1000]\\n                            if(val>1000)\\n                                continue;\\n                            temp.insert(val);\\n                        }\\n                        else{\\n                            int val=i*j;\\n                            if(val>1000)\\n                                continue;\\n                            temp.insert(val);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[l][r]=temp;\\n    }\\n    int solve(string &s){\\n        //First of all compute all products \\n      \\n        vector<int> ans; //ans stores values which just needs to be added\\n\\t\\t\\n        int sum=0,product=1;\\n        int i=0;\\n        int n=s.size();\\n        while(i<n){\\n            if(s[i]==\\'+\\'){\\n                ans.push_back(product);\\n                product=1;\\n            }\\n            else if(s[i]!=\\'*\\'){\\n                product=product*(s[i]-\\'0\\');\\n            }\\n            i++;\\n        }\\n        ans.push_back(product);\\n        for(auto &i:ans){\\n            sum+=i;\\n        }\\n        return sum;\\n    }\\n    int scoreOfStudents(string s, vector<int>& ans) {\\n        int n=s.size();\\n        vector<vector<unordered_set<int>>> dp(n,vector<unordered_set<int>>(n));\\n        \\n        unordered_set<int> res=find(0,n-1,s,dp);\\n        \\n        \\n        // solve function calculates actual value of expression according to the order of operations given in question\\n        int actual=solve(s);\\n    \\n        int sum=0;\\n        for(auto &i:ans){\\n            if(i==actual){\\n                sum+=5;\\n            }\\n            else if(res.find(i)!=res.end())\\n                sum+=2;\\n        }\\n        return sum;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832313,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int Max;\\n    int h(int i, int j) {return i*100+j;}\\n    unordered_map<int, vector<int>> dp;\\n    \\n    int getValid(string &s){\\n        long long valid = 0;\\n        stack<long long> st;\\n        st.push({s[0]-\\'0\\'});\\n        for(int i = 1; i<s.length(); ++i){\\n            if(isdigit(s[i])){\\n                if(s[i-1]==\\'*\\'){\\n                    long long mul = 1ll*st.top()*(s[i]-\\'0\\'); \\n                    st.pop();\\n                    st.push(mul);\\n                }\\n                else st.push({s[i]-\\'0\\'});\\n            }\\n            \\n        }\\n        \\n        while(st.size()) { valid += st.top(); st.pop(); }\\n        return valid;\\n    }\\n    \\n    vector<int> dfs(int i, int j, string &s){\\n        \\n        if(i==j) return {(s[i]-\\'0\\')};  \\n        int hash = h(i,j);\\n        if(!dp.count(hash)) \\n        {\\n            unordered_set<int> possible;\\n            for(int k=i; k<=j-2; k+=2){\\n                vector<int> res1 = dfs(i,k,s), res2 = dfs(k+2,j,s);\\n                for(auto &val1 : res1){ \\n                    for(auto &val2 : res2){\\n                        int val = s[k+1]==\\'*\\'? val1*val2 : val1 + val2; \\n                        if(val<=Max)\\n                            possible.insert(val);\\n                    }\\n                }\\n\\n            }\\n\\n            dp[hash] = vector<int>(possible.begin(), possible.end());\\n        }\\n        return dp[hash];\\n        \\n    }\\n\\n    int scoreOfStudents(string s, vector<int>& ans) {\\n        dp.clear(); Max = 1000;\\n        vector<int> possible = dfs(0, s.length()-1, s);\\n        unordered_set<int> can(possible.begin(), possible.end());        \\n        int valid = getValid(s), res =0;\\n        \\n            \\n        for(auto &val : ans){\\n            if(val==valid) res+=5;\\n            else if(can.count(val)) res+=2;\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int Max;\\n    int h(int i, int j) {return i*100+j;}\\n    unordered_map<int, vector<int>> dp;\\n    \\n    int getValid(string &s){\\n        long long valid = 0;\\n        stack<long long> st;\\n        st.push({s[0]-\\'0\\'});\\n        for(int i = 1; i<s.length(); ++i){\\n            if(isdigit(s[i])){\\n                if(s[i-1]==\\'*\\'){\\n                    long long mul = 1ll*st.top()*(s[i]-\\'0\\'); \\n                    st.pop();\\n                    st.push(mul);\\n                }\\n                else st.push({s[i]-\\'0\\'});\\n            }\\n            \\n        }\\n        \\n        while(st.size()) { valid += st.top(); st.pop(); }\\n        return valid;\\n    }\\n    \\n    vector<int> dfs(int i, int j, string &s){\\n        \\n        if(i==j) return {(s[i]-\\'0\\')};  \\n        int hash = h(i,j);\\n        if(!dp.count(hash)) \\n        {\\n            unordered_set<int> possible;\\n            for(int k=i; k<=j-2; k+=2){\\n                vector<int> res1 = dfs(i,k,s), res2 = dfs(k+2,j,s);\\n                for(auto &val1 : res1){ \\n                    for(auto &val2 : res2){\\n                        int val = s[k+1]==\\'*\\'? val1*val2 : val1 + val2; \\n                        if(val<=Max)\\n                            possible.insert(val);\\n                    }\\n                }\\n\\n            }\\n\\n            dp[hash] = vector<int>(possible.begin(), possible.end());\\n        }\\n        return dp[hash];\\n        \\n    }\\n\\n    int scoreOfStudents(string s, vector<int>& ans) {\\n        dp.clear(); Max = 1000;\\n        vector<int> possible = dfs(0, s.length()-1, s);\\n        unordered_set<int> can(possible.begin(), possible.end());        \\n        int valid = getValid(s), res =0;\\n        \\n            \\n        for(auto &val : ans){\\n            if(val==valid) res+=5;\\n            else if(can.count(val)) res+=2;\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486730,
                "title": "python3-clear-dp-without-recursive",
                "content": "```\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        real = eval(s)\\n        s = list(s)\\n        n  =len(s) // 2 + 1  #num of numbers\\n        dp = [[set() for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            dp[i][i].add(int(s[i * 2]))\\n\\t\\t#start DP\\n\\t\\t#DP[x][y]\\n        for i in range(1, n):   # i for y-x\\n            for j in range(n - i):  # j for x\\n                for k in range(i): # k from x to y\\n                    for a in dp[j][j + k]:\\n                        for b in dp[j + k + 1][j + i]:\\n                            if s[(j + k + 1) * 2 - 1] == \\'+\\':\\n                                if a + b <= 1000:\\n                                    dp[j][j + i].add(a + b)\\n                            else:\\n                                if a * b <= 1000:\\n                                    dp[j][j + i].add(a * b)\\n        \\n        ans = 0\\n        for i in answers:\\n            if i == real:\\n                ans += 5\\n            elif i in dp[0][n - 1]:\\n                ans += 2\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        real = eval(s)\\n        s = list(s)\\n        n  =len(s) // 2 + 1  #num of numbers\\n        dp = [[set() for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            dp[i][i].add(int(s[i * 2]))\\n\\t\\t#start DP\\n\\t\\t#DP[x][y]\\n        for i in range(1, n):   # i for y-x\\n            for j in range(n - i):  # j for x\\n                for k in range(i): # k from x to y\\n                    for a in dp[j][j + k]:\\n                        for b in dp[j + k + 1][j + i]:\\n                            if s[(j + k + 1) * 2 - 1] == \\'+\\':\\n                                if a + b <= 1000:\\n                                    dp[j][j + i].add(a + b)\\n                            else:\\n                                if a * b <= 1000:\\n                                    dp[j][j + i].add(a * b)\\n        \\n        ans = 0\\n        for i in answers:\\n            if i == real:\\n                ans += 5\\n            elif i in dp[0][n - 1]:\\n                ans += 2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486579,
                "title": "java-clean",
                "content": "TBH, I don\\'t like this question, it is very time comsuming..\\nI copy the part answer from https://leetcode.com/problems/basic-calculator-ii/ \\n```\\nclass Solution {\\n    public int scoreOfStudents(String s, int[] answers) {\\n        int N = s.length();\\n        Set<Integer>[][] dp = new Set[N][N];\\n        for (int i = 0; i < N; i += 2)\\n            dp[i][i] = new HashSet<>(Arrays.asList(s.charAt(i) - \\'0\\'));\\n        for (int len = 3; len <= N; len += 2)\\n            for (int start = 0; start + len <= N; start += 2) {\\n                int end = start + len - 1;\\n                dp[start][end] = new HashSet<>();\\n                for (int operator = start + 1; operator < end; operator += 2)\\n                    for (int left : dp[start][operator - 1])\\n                        for (int right : dp[operator + 1][end]) {\\n                            int res = s.charAt(operator) == \\'*\\' ? left * right : left + right;\\n                            if (res <= 1000) dp[start][end].add(res);\\n                        }\\n            }\\n        int correct = calculate(s);\\n        return getScore(answers, correct, dp[0][N - 1]);\\n    }\\n    public int calculate(String s) {\\n        int i = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        char operator = \\'+\\';\\n        int num = 0;\\n        while (i < s.length()) {\\n            char ch = s.charAt(i++);\\n            if (ch >= \\'0\\' && ch <= \\'9\\') num = ch - \\'0\\';\\n            if (i >= s.length() || ch == \\'+\\' || ch == \\'*\\') {\\n                if (operator == \\'+\\') stack.push(num);\\n                else if (operator == \\'*\\') stack.push(stack.pop() * num);\\n                operator = ch;\\n                num = 0;\\n            }\\n        }\\n        return stack.stream().mapToInt(Integer::intValue).sum();\\n    }\\n    private int getScore(int[] answers, int correct, Set<Integer> incorrect) {\\n        int res = 0;\\n        for (int i = 0; i < answers.length; i++)\\n            if (answers[i] == correct) res += 5;\\n            else if (incorrect.contains(answers[i])) res += 2;\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfStudents(String s, int[] answers) {\\n        int N = s.length();\\n        Set<Integer>[][] dp = new Set[N][N];\\n        for (int i = 0; i < N; i += 2)\\n            dp[i][i] = new HashSet<>(Arrays.asList(s.charAt(i) - \\'0\\'));\\n        for (int len = 3; len <= N; len += 2)\\n            for (int start = 0; start + len <= N; start += 2) {\\n                int end = start + len - 1;\\n                dp[start][end] = new HashSet<>();\\n                for (int operator = start + 1; operator < end; operator += 2)\\n                    for (int left : dp[start][operator - 1])\\n                        for (int right : dp[operator + 1][end]) {\\n                            int res = s.charAt(operator) == \\'*\\' ? left * right : left + right;\\n                            if (res <= 1000) dp[start][end].add(res);\\n                        }\\n            }\\n        int correct = calculate(s);\\n        return getScore(answers, correct, dp[0][N - 1]);\\n    }\\n    public int calculate(String s) {\\n        int i = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        char operator = \\'+\\';\\n        int num = 0;\\n        while (i < s.length()) {\\n            char ch = s.charAt(i++);\\n            if (ch >= \\'0\\' && ch <= \\'9\\') num = ch - \\'0\\';\\n            if (i >= s.length() || ch == \\'+\\' || ch == \\'*\\') {\\n                if (operator == \\'+\\') stack.push(num);\\n                else if (operator == \\'*\\') stack.push(stack.pop() * num);\\n                operator = ch;\\n                num = 0;\\n            }\\n        }\\n        return stack.stream().mapToInt(Integer::intValue).sum();\\n    }\\n    private int getScore(int[] answers, int correct, Set<Integer> incorrect) {\\n        int res = 0;\\n        for (int i = 0; i < answers.length; i++)\\n            if (answers[i] == correct) res += 5;\\n            else if (incorrect.contains(answers[i])) res += 2;\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487285,
                "title": "python3-somewhat-dp",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/fa0bb65b4cb428452e2b4192ad53e56393b8fb8d) for solutions of weekly 260. \\n```\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        \\n        @cache\\n        def fn(lo, hi): \\n            \"\"\"Return possible answers of s[lo:hi].\"\"\"\\n            if lo+1 == hi: return {int(s[lo])}\\n            ans = set()\\n            for mid in range(lo+1, hi, 2): \\n                for x in fn(lo, mid): \\n                    for y in fn(mid+1, hi): \\n                        if s[mid] == \"+\" and x + y <= 1000: ans.add(x + y)\\n                        elif s[mid] == \"*\" and x * y <= 1000: ans.add(x * y)\\n            return ans \\n                \\n        target = eval(s)\\n        cand = fn(0, len(s))\\n        ans = 0 \\n        for x in answers: \\n            if x == target: ans += 5\\n            elif x in cand: ans += 2\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        \\n        @cache\\n        def fn(lo, hi): \\n            \"\"\"Return possible answers of s[lo:hi].\"\"\"\\n            if lo+1 == hi: return {int(s[lo])}\\n            ans = set()\\n            for mid in range(lo+1, hi, 2): \\n                for x in fn(lo, mid): \\n                    for y in fn(mid+1, hi): \\n                        if s[mid] == \"+\" and x + y <= 1000: ans.add(x + y)\\n                        elif s[mid] == \"*\" and x * y <= 1000: ans.add(x * y)\\n            return ans \\n                \\n        target = eval(s)\\n        cand = fn(0, len(s))\\n        ans = 0 \\n        for x in answers: \\n            if x == target: ans += 5\\n            elif x in cand: ans += 2\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488096,
                "title": "javascript-interval-dp",
                "content": "**Intuition**\\nThe answer for the interval [i,j] can be calculated based on an operarator at some position k where i<k<j, and its value is \\nvalue(i,k-1) operand[k] value(k+1,j). We are essentially taking the left and right answers, and combining them. However there are multiple potential answers for an interval [i,j], therefore we need to consider every possible combination between the 2 halves. \\n\\n**Code**\\n```\\nvar scoreOfStudents = function(s, answers) {\\n    let correct=s.split(\\'+\\').reduce((a,c)=>a+c.split(\\'*\\').reduce((b,d)=>b*d,1),0),\\n        n=s.length,dp=[...Array(n)].map(d=>[...Array(n)])\\n    let dfs=(i=0,j=n-1)=>{\\n        if(dp[i][j]!==undefined)\\n            return dp[i][j]\\n        if(i===j)\\n            return dp[i][j]=[Number(s[i])]\\n        let ans=new Set()\\n        for(let k=i+1;k<=j-1;k+=2)\\n            for(let a1 of dfs(i,k-1))\\n                for(let a2 of dfs(k+1,j))\\n                    if(s[k]===\\'*\\')\\n                        ans.add(Number(a1)*Number(a2))\\n                    else\\n                        ans.add(Number(a1)+Number(a2))\\n        return dp[i][j]=Array.from(ans).filter(d=>d<=1000)\\n    }\\n    dfs()\\n    dp[0][n-1]=new Set(dp[0][n-1])\\n    return answers.reduce( (a,c)=> a+ (c===correct?5:(dp[0][n-1].has(c)?2:0)) ,0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar scoreOfStudents = function(s, answers) {\\n    let correct=s.split(\\'+\\').reduce((a,c)=>a+c.split(\\'*\\').reduce((b,d)=>b*d,1),0),\\n        n=s.length,dp=[...Array(n)].map(d=>[...Array(n)])\\n    let dfs=(i=0,j=n-1)=>{\\n        if(dp[i][j]!==undefined)\\n            return dp[i][j]\\n        if(i===j)\\n            return dp[i][j]=[Number(s[i])]\\n        let ans=new Set()\\n        for(let k=i+1;k<=j-1;k+=2)\\n            for(let a1 of dfs(i,k-1))\\n                for(let a2 of dfs(k+1,j))\\n                    if(s[k]===\\'*\\')\\n                        ans.add(Number(a1)*Number(a2))\\n                    else\\n                        ans.add(Number(a1)+Number(a2))\\n        return dp[i][j]=Array.from(ans).filter(d=>d<=1000)\\n    }\\n    dfs()\\n    dp[0][n-1]=new Set(dp[0][n-1])\\n    return answers.reduce( (a,c)=> a+ (c===correct?5:(dp[0][n-1].has(c)?2:0)) ,0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1486808,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<unordered_set<int>>> dp;\\n    \\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        int n = s.size();\\n        dp.resize(n, vector<unordered_set<int>>(n));\\n        \\n        unordered_set<int> m =  find(0, n-1, s);\\n        \\n        int real = solve(s);\\n        int sum = 0;\\n        \\n        for(int& x : answers){\\n            if(x == real) sum += 5;\\n            else if(m.find(x) != m.end()) sum += 2;\\n        }\\n        \\n        return sum;\\n        \\n    }\\n    \\n    int solve(string& s){\\n        int p = 1;\\n        vector<int> v;\\n        for(char& c : s){\\n            if(c == \\'+\\'){\\n                v.push_back(p);\\n                p = 1;\\n            }\\n            else if(c != \\'*\\') p *= (c-\\'0\\');\\n        }\\n        for(int& x : v) p += x;\\n        return p;\\n    }\\n    \\n    unordered_set<int> find(int l, int r, string& s){\\n        if(!dp[l][r].empty()) return dp[l][r];\\n        \\n        unordered_set<int> tmp;\\n        if(l == r) {tmp.insert(s[l]-\\'0\\'); return tmp;}\\n        \\n        for(int i = l+1; i < r; i+=2){\\n            char c = s[i];\\n            unordered_set<int> left = find(l, i-1, s);\\n            unordered_set<int> right = find(i+1, r, s);\\n            for(auto& x : left){\\n                for(auto& y : right){\\n                    int val;\\n                    if(c == \\'+\\') val = x+y;\\n                    else val = x*y;\\n                    if(val <= 1000) tmp.insert(val);\\n                }\\n            }\\n        }\\n        return dp[l][r] = tmp;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<unordered_set<int>>> dp;\\n    \\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        int n = s.size();\\n        dp.resize(n, vector<unordered_set<int>>(n));\\n        \\n        unordered_set<int> m =  find(0, n-1, s);\\n        \\n        int real = solve(s);\\n        int sum = 0;\\n        \\n        for(int& x : answers){\\n            if(x == real) sum += 5;\\n            else if(m.find(x) != m.end()) sum += 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2248109,
                "title": "java-solution-recursion-stack",
                "content": "```\\n\\nclass Solution {\\n    \\n    HashMap<String , HashSet<Integer>> cache ;\\n    \\n    public int scoreOfStudents(String s, int[] answers) {\\n        \\n        cache = new HashMap();\\n        HashSet<Integer> total_possible_ans = getPossibleAns(s);\\n        \\n        int correct_ans = getCorrectAns(s);\\n        \\n        int total_score = 0 ;\\n        for(int i=0 ; i<answers.length ; i++){\\n            if(answers[i] == correct_ans){\\n                total_score += 5 ;\\n            }else if(total_possible_ans.contains(answers[i])){\\n                total_score += 2 ;\\n            }\\n        }\\n        \\n        return total_score ;        \\n    }\\n    \\n    \\n    \\n    public HashSet<Integer> getPossibleAns(String s){\\n        \\n        if(cache.containsKey(s)){\\n            return cache.get(s) ;\\n        }\\n        \\n        HashSet<Integer> possible_ans = new HashSet() ;\\n        \\n        for(int i = 0 ; i<s.length() ; i++){\\n            \\n            char cur = s.charAt(i) ;\\n            HashSet<Integer> left = new HashSet() ;\\n            HashSet<Integer> right = new HashSet() ;\\n            \\n            if(cur == \\'+\\' || cur == \\'*\\'){\\n                left = getPossibleAns(s.substring(0 , i));\\n                right = getPossibleAns(s.substring(i+1));\\n            }\\n            \\n            for(Integer l : left){\\n                for(Integer r : right){                    \\n                    if(cur == \\'+\\'){\\n                        if(l+r > 1000) continue ; // skiping for ans that are greater than 1000\\n                        possible_ans.add(l+r);                      \\n                    }else if(cur == \\'*\\'){\\n                        if(l*r > 1000) continue ; // skiping for ans that are greater than 1000\\n                        possible_ans.add(l*r);\\n                    }                    \\n                }\\n            }            \\n        }\\n        \\n        if(possible_ans.isEmpty() && s.length() <= 1){\\n            possible_ans.add(Integer.parseInt(s));\\n        }\\n\\n        cache.put(s , possible_ans);\\n        \\n        return possible_ans ;        \\n    }\\n    \\n    public int getCorrectAns(String s) {\\n        \\n        Stack<Integer> stack = new Stack() ;\\n        \\n        for(int i = 0 ; i<s.length() ; i++){\\n            \\n            // push only integers into stack\\n            if(s.charAt(i) != \\'+\\' && s.charAt(i) != \\'*\\'){\\n                stack.push(Character.getNumericValue(s.charAt(i))) ;\\n            }\\n            \\n            // If operator is \\'*\\' , then take the last element from stack and multiply with next element\\n            // Also push into stack , and then increment i also , to avoid pushing the same next element into stack again\\n            if(s.charAt(i) == \\'*\\'){\\n                int cur = stack.pop();\\n                int next = Character.getNumericValue(s.charAt(i+1)) ;\\n                stack.push(cur * next);\\n                i++ ;\\n            }            \\n        }\\n        \\n        // Now sum all the element in the stack to get result for \\'+\\' operator\\n        int total_sum = stack.pop() ;\\n        \\n        while(!stack.isEmpty()){\\n            total_sum += stack.pop() ;\\n        }\\n        \\n        return total_sum ;\\n    }\\n\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    \\n    HashMap<String , HashSet<Integer>> cache ;\\n    \\n    public int scoreOfStudents(String s, int[] answers) {\\n        \\n        cache = new HashMap();\\n        HashSet<Integer> total_possible_ans = getPossibleAns(s);\\n        \\n        int correct_ans = getCorrectAns(s);\\n        \\n        int total_score = 0 ;\\n        for(int i=0 ; i<answers.length ; i++){\\n            if(answers[i] == correct_ans){\\n                total_score += 5 ;\\n            }else if(total_possible_ans.contains(answers[i])){\\n                total_score += 2 ;\\n            }\\n        }\\n        \\n        return total_score ;        \\n    }\\n    \\n    \\n    \\n    public HashSet<Integer> getPossibleAns(String s){\\n        \\n        if(cache.containsKey(s)){\\n            return cache.get(s) ;\\n        }\\n        \\n        HashSet<Integer> possible_ans = new HashSet() ;\\n        \\n        for(int i = 0 ; i<s.length() ; i++){\\n            \\n            char cur = s.charAt(i) ;\\n            HashSet<Integer> left = new HashSet() ;\\n            HashSet<Integer> right = new HashSet() ;\\n            \\n            if(cur == \\'+\\' || cur == \\'*\\'){\\n                left = getPossibleAns(s.substring(0 , i));\\n                right = getPossibleAns(s.substring(i+1));\\n            }\\n            \\n            for(Integer l : left){\\n                for(Integer r : right){                    \\n                    if(cur == \\'+\\'){\\n                        if(l+r > 1000) continue ; // skiping for ans that are greater than 1000\\n                        possible_ans.add(l+r);                      \\n                    }else if(cur == \\'*\\'){\\n                        if(l*r > 1000) continue ; // skiping for ans that are greater than 1000\\n                        possible_ans.add(l*r);\\n                    }                    \\n                }\\n            }            \\n        }\\n        \\n        if(possible_ans.isEmpty() && s.length() <= 1){\\n            possible_ans.add(Integer.parseInt(s));\\n        }\\n\\n        cache.put(s , possible_ans);\\n        \\n        return possible_ans ;        \\n    }\\n    \\n    public int getCorrectAns(String s) {\\n        \\n        Stack<Integer> stack = new Stack() ;\\n        \\n        for(int i = 0 ; i<s.length() ; i++){\\n            \\n            // push only integers into stack\\n            if(s.charAt(i) != \\'+\\' && s.charAt(i) != \\'*\\'){\\n                stack.push(Character.getNumericValue(s.charAt(i))) ;\\n            }\\n            \\n            // If operator is \\'*\\' , then take the last element from stack and multiply with next element\\n            // Also push into stack , and then increment i also , to avoid pushing the same next element into stack again\\n            if(s.charAt(i) == \\'*\\'){\\n                int cur = stack.pop();\\n                int next = Character.getNumericValue(s.charAt(i+1)) ;\\n                stack.push(cur * next);\\n                i++ ;\\n            }            \\n        }\\n        \\n        // Now sum all the element in the stack to get result for \\'+\\' operator\\n        int total_sum = stack.pop() ;\\n        \\n        while(!stack.isEmpty()){\\n            total_sum += stack.pop() ;\\n        }\\n        \\n        return total_sum ;\\n    }\\n\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045184,
                "title": "dp-solution-bottom-up-similar-to-different-ways-to-add-parentheses",
                "content": "```\\nclass Solution {\\npublic:\\n    int opt(char x)\\n    {\\n        if(x==\\'+\\')\\n            return 1;\\n        else if(x==\\'-\\')\\n            return 0;\\n        return 2;\\n    }\\n    \\n    int cal(int x,int y,int o)\\n    {\\n        if(o==1)\\n            return x+y;\\n        else if(o==0)\\n            return x-y;\\n        return x*y;\\n    }\\n    \\n    int func(string s)\\n    {\\n        int ans=0;\\n        stack<int> st;\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(isdigit(s[i]))\\n            {\\n                if(st.empty())\\n                    st.push(s[i]-\\'0\\');\\n                else if(st.top()==1003)\\n                {\\n                    st.pop();\\n                    int t = st.top();\\n                    st.pop();\\n                    st.push(t*(s[i]-\\'0\\'));\\n                }\\n                else if(st.top()==1002)\\n                {\\n                    st.pop();\\n                    st.push(-(s[i]-\\'0\\'));\\n                }\\n                else\\n                    st.push(s[i]-\\'0\\');\\n            }\\n            else if(s[i]==\\'-\\')\\n                st.push(1002);\\n            else if(s[i]==\\'*\\')\\n                st.push(1003);\\n        }\\n        while(!st.empty())\\n            ans+=st.top(),st.pop();\\n        return ans;\\n    }\\n    \\n    int scoreOfStudents(string el, vector<int>& a) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        int ans = func(el);\\n        int n=el.length();\\n        vector<int> e;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=0;\\n            while(i<n && isdigit(el[i]))\\n                x*=10,x+=el[i]-\\'0\\',i++;\\n            e.push_back(x);\\n            if(i<n)\\n                e.push_back(opt(el[i]));\\n        }\\n        n=e.size();\\n        vector<vector<set<int>>> vec(n/2+1,vector<set<int>>(n/2+1));\\n        unordered_map<int,int> mp;\\n        int val=0;\\n        for(auto i:a)\\n            mp[i]++;\\n        for(int i=0;i<=n/2;i++)\\n        {\\n            for(int j=0,g=i;g<=n/2;g++,j++)\\n            {\\n                if(i==0)\\n                    vec[j][g].insert(e[2*j]);\\n                else\\n                {\\n                    int k=j+1;\\n                    int l=j;\\n                    while(l<g)\\n                    {\\n                        for(auto p:vec[j][l])\\n                        {\\n                            for(auto q:vec[k][g])\\n                            {\\n                                int t=cal(p,q,e[2*l+1]);\\n                                if(t<0 || t>1000)\\n                                    continue;\\n                                vec[j][g].insert(t);\\n                                if(j==0 && g==n/2 && mp[t]>0)\\n                                {\\n                                    if(t==ans)\\n                                        val+=mp[t]*5,mp[t]=0;\\n                                    else if(mp[t]>0)\\n                                        val+=mp[t]*2,mp[t]=0;\\n                                }\\n                            }\\n                        }\\n                        l++,k++;\\n                    }\\n                }\\n            }\\n        }\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int opt(char x)\\n    {\\n        if(x==\\'+\\')\\n            return 1;\\n        else if(x==\\'-\\')\\n            return 0;\\n        return 2;\\n    }\\n    \\n    int cal(int x,int y,int o)\\n    {\\n        if(o==1)\\n            return x+y;\\n        else if(o==0)\\n            return x-y;\\n        return x*y;\\n    }\\n    \\n    int func(string s)\\n    {\\n        int ans=0;\\n        stack<int> st;\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(isdigit(s[i]))\\n            {\\n                if(st.empty())\\n                    st.push(s[i]-\\'0\\');\\n                else if(st.top()==1003)\\n                {\\n                    st.pop();\\n                    int t = st.top();\\n                    st.pop();\\n                    st.push(t*(s[i]-\\'0\\'));\\n                }\\n                else if(st.top()==1002)\\n                {\\n                    st.pop();\\n                    st.push(-(s[i]-\\'0\\'));\\n                }\\n                else\\n                    st.push(s[i]-\\'0\\');\\n            }\\n            else if(s[i]==\\'-\\')\\n                st.push(1002);\\n            else if(s[i]==\\'*\\')\\n                st.push(1003);\\n        }\\n        while(!st.empty())\\n            ans+=st.top(),st.pop();\\n        return ans;\\n    }\\n    \\n    int scoreOfStudents(string el, vector<int>& a) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        int ans = func(el);\\n        int n=el.length();\\n        vector<int> e;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=0;\\n            while(i<n && isdigit(el[i]))\\n                x*=10,x+=el[i]-\\'0\\',i++;\\n            e.push_back(x);\\n            if(i<n)\\n                e.push_back(opt(el[i]));\\n        }\\n        n=e.size();\\n        vector<vector<set<int>>> vec(n/2+1,vector<set<int>>(n/2+1));\\n        unordered_map<int,int> mp;\\n        int val=0;\\n        for(auto i:a)\\n            mp[i]++;\\n        for(int i=0;i<=n/2;i++)\\n        {\\n            for(int j=0,g=i;g<=n/2;g++,j++)\\n            {\\n                if(i==0)\\n                    vec[j][g].insert(e[2*j]);\\n                else\\n                {\\n                    int k=j+1;\\n                    int l=j;\\n                    while(l<g)\\n                    {\\n                        for(auto p:vec[j][l])\\n                        {\\n                            for(auto q:vec[k][g])\\n                            {\\n                                int t=cal(p,q,e[2*l+1]);\\n                                if(t<0 || t>1000)\\n                                    continue;\\n                                vec[j][g].insert(t);\\n                                if(j==0 && g==n/2 && mp[t]>0)\\n                                {\\n                                    if(t==ans)\\n                                        val+=mp[t]*5,mp[t]=0;\\n                                    else if(mp[t]>0)\\n                                        val+=mp[t]*2,mp[t]=0;\\n                                }\\n                            }\\n                        }\\n                        l++,k++;\\n                    }\\n                }\\n            }\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1826521,
                "title": "python3-memoized-solution",
                "content": "Every student answer is guaranteed to be in [0, 1000] so we can omit all answers that exceed this range. We can do this recursively because the remaining ops (+,*\\\\) will only make the answer larger with non-negative ints.\\n\\n```\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        @cache\\n        def dp(i, j):\\n            if j - i == 1:\\n                return set([int(s[i])])\\n            possible = set()\\n            for idx in range(i+1, j, 2):\\n                for a in dp(i, idx):\\n                    for b in dp(idx+1, j):\\n                        val = a*b if s[idx] == \\'*\\' else a+b\\n                        if val <= 1000:\\n                            possible.add(val)\\n            return possible\\n        \\n        correctAnswer = eval(s)\\n        answers = filter(lambda ans: ans in dp(0, len(s)), answers)\\n        return sum([5 if ans == correctAnswer else 2 for ans in answers])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        @cache\\n        def dp(i, j):\\n            if j - i == 1:\\n                return set([int(s[i])])\\n            possible = set()\\n            for idx in range(i+1, j, 2):\\n                for a in dp(i, idx):\\n                    for b in dp(idx+1, j):\\n                        val = a*b if s[idx] == \\'*\\' else a+b\\n                        if val <= 1000:\\n                            possible.add(val)\\n            return possible\\n        \\n        correctAnswer = eval(s)\\n        answers = filter(lambda ans: ans in dp(0, len(s)), answers)\\n        return sum([5 if ans == correctAnswer else 2 for ans in answers])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499554,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int scoreOfStudents(String s, int[] answers) {\\n        int len = s.length();\\n        Set<Integer>[][] set = new HashSet[len][len];\\n        for(int i=0; i<len; i+=2){\\n            set[i][i] = new HashSet();\\n            set[i][i].add(s.charAt(i)-\\'0\\');\\n        }\\n        int correct = 0;\\n        int preDig = 0;\\n        for(int i=0; i<len; i++){\\n            char cur = s.charAt(i);\\n            if(cur == \\'*\\'){\\n                preDig*=s.charAt(++i)-\\'0\\';\\n            }else if(cur == \\'+\\'){\\n                correct+=preDig;\\n            }else\\n                preDig = cur-\\'0\\';\\n        }\\n        correct+=preDig;\\n        for(int dif=2; dif<len; dif+=2){\\n            for(int start=0; start+dif<len; start+=2){\\n                int end = start+dif;\\n                set[start][end] = new HashSet();\\n                for(int idx=start+1; idx<end; idx+=2){\\n                    char op = s.charAt(idx);\\n                    for(int left : set[start][idx-1]){\\n                        for(int right : set[idx+1][end]){\\n                            int res = op == \\'*\\' ? left * right : left + right;\\n                            if (res <= 1000) set[start][end].add(res);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int res = 0;\\n        for(int ans : answers){\\n            if(ans==correct) res+=5;\\n            else if(set[0][len-1].contains(ans))\\n                res+=2;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int scoreOfStudents(String s, int[] answers) {\\n        int len = s.length();\\n        Set<Integer>[][] set = new HashSet[len][len];\\n        for(int i=0; i<len; i+=2){\\n            set[i][i] = new HashSet();\\n            set[i][i].add(s.charAt(i)-\\'0\\');\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1487679,
                "title": "same-as-lc-241-easy-to-understand",
                "content": "Please solve https://leetcode.com/problems/different-ways-to-add-parentheses/ to get the Idea.\\nBasic Idea : Each operator could be the last to get executed and we just have to find all sum combinations.\\nAlso, find the correct sum..\\n\\nFinally we have to just keep updating our answer based on counts (no of students with correct sum * 5 + other possible sums * 2)..\\n\\n```\\nclass Solution {\\n    int ans = 0;\\n    Map<Integer, Integer> map ;\\n    Map<String, Set<Integer>> memo = new HashMap();\\n    public int scoreOfStudents(String s, int[] answers) {\\n        map = new HashMap<>();\\n        for(int num : answers ){\\n           map.put(num, map.getOrDefault(num, 0) +1);\\n        }\\n        //Find all sum\\n        Set<Integer> ret = diffWaysToCompute(s);\\n        //Find valid sum\\n        int validSum = getValidSum(s);\\n        //add to result\\n        ans  += map.getOrDefault(validSum, 0) *5;\\n        map.put(validSum , 0);\\n        \\n        //add to ans all others sum\\n        for(int sum : ret){\\n            ans += map.getOrDefault(sum, 0) * 2;\\n            map.put(sum, 0);\\n        }\\n        return ans;\\n    }\\n    \\n    private Set<Integer> diffWaysToCompute(String s) {\\n        Set<Integer> res =  new HashSet<Integer>();\\n        \\n         int n = s.length();\\n        if(memo.containsKey(s)){\\n            return memo.get(s);\\n        }\\n        for(int i = 0; i < n; i++){\\n            if( s.charAt(i) == \\'+\\' || s.charAt(i) == \\'*\\'){\\n                String left = s.substring(0, i);\\n                String right = s.substring(i+1);\\n                Set<Integer> L =diffWaysToCompute(left);\\n                Set<Integer> R =diffWaysToCompute(right);\\n                for(int x : L){\\n                    for(int y : R){\\n                        int r = 0;\\n                        switch(s.charAt(i)){\\n                            case \\'*\\' :\\n                                r = x * y;\\n                                break;\\n                            case \\'+\\' :\\n                                r = x + y;\\n                                break;\\n                         }\\n                        if(r <=10001)\\n                        res.add(r);\\n                    }\\n                }\\n            }\\n        } \\n        if(res.size() == 0){\\n            res.add(Integer.parseInt(s));\\n        } \\n        memo.put(s, res);\\n        return res;\\n    }\\n    public int getValidSum(String s){\\n        Stack<Integer> st = new Stack();\\n        char [] c = s.toCharArray();\\n        st.push(c[0] - \\'0\\');\\n        int  res = 0;\\n       for(int i =1; i< c.length; i++){\\n           if(c[i] >=\\'0\\' && c[i]<=\\'9\\'){\\n               if(c[i-1] == \\'*\\'){\\n                   int top = st.pop();\\n                   st.push(top * (c[i]- \\'0\\'));\\n               }else{\\n                   st.push(c[i] -\\'0\\');\\n               }\\n           }\\n       }\\n        while(!st.isEmpty()){\\n            res += st.pop();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    Map<Integer, Integer> map ;\\n    Map<String, Set<Integer>> memo = new HashMap();\\n    public int scoreOfStudents(String s, int[] answers) {\\n        map = new HashMap<>();\\n        for(int num : answers ){\\n           map.put(num, map.getOrDefault(num, 0) +1);\\n        }\\n        //Find all sum\\n        Set<Integer> ret = diffWaysToCompute(s);\\n        //Find valid sum\\n        int validSum = getValidSum(s);\\n        //add to result\\n        ans  += map.getOrDefault(validSum, 0) *5;\\n        map.put(validSum , 0);\\n        \\n        //add to ans all others sum\\n        for(int sum : ret){\\n            ans += map.getOrDefault(sum, 0) * 2;\\n            map.put(sum, 0);\\n        }\\n        return ans;\\n    }\\n    \\n    private Set<Integer> diffWaysToCompute(String s) {\\n        Set<Integer> res =  new HashSet<Integer>();\\n        \\n         int n = s.length();\\n        if(memo.containsKey(s)){\\n            return memo.get(s);\\n        }\\n        for(int i = 0; i < n; i++){\\n            if( s.charAt(i) == \\'+\\' || s.charAt(i) == \\'*\\'){\\n                String left = s.substring(0, i);\\n                String right = s.substring(i+1);\\n                Set<Integer> L =diffWaysToCompute(left);\\n                Set<Integer> R =diffWaysToCompute(right);\\n                for(int x : L){\\n                    for(int y : R){\\n                        int r = 0;\\n                        switch(s.charAt(i)){\\n                            case \\'*\\' :\\n                                r = x * y;\\n                                break;\\n                            case \\'+\\' :\\n                                r = x + y;\\n                                break;\\n                         }\\n                        if(r <=10001)\\n                        res.add(r);\\n                    }\\n                }\\n            }\\n        } \\n        if(res.size() == 0){\\n            res.add(Integer.parseInt(s));\\n        } \\n        memo.put(s, res);\\n        return res;\\n    }\\n    public int getValidSum(String s){\\n        Stack<Integer> st = new Stack();\\n        char [] c = s.toCharArray();\\n        st.push(c[0] - \\'0\\');\\n        int  res = 0;\\n       for(int i =1; i< c.length; i++){\\n           if(c[i] >=\\'0\\' && c[i]<=\\'9\\'){\\n               if(c[i-1] == \\'*\\'){\\n                   int top = st.pop();\\n                   st.push(top * (c[i]- \\'0\\'));\\n               }else{\\n                   st.push(c[i] -\\'0\\');\\n               }\\n           }\\n       }\\n        while(!st.isEmpty()){\\n            res += st.pop();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486295,
                "title": "python-divide-and-conquer-explained",
                "content": "**Idea**\\n\\n* Use divide and conquer to recursively split the equation into two smaller equations.\\n\\n* **Guess which operation will be performed last**. Evaluate all possible values from the equation to the left of this operand, and then to the right of the operand. Combine the two with either multiplication or addition.\\n* Store all combined values in a `set` to avoid duplication; since student answers are all `<= 1000`, filter out any \\'too large\\' values as well. Cache all results.\\n\\nThe actual problem isn\\'t that hard; IMO the hardest part is working out what the question is asking. \\'Evaluated using any order of operations\\' really just means: choose any permutation of all the positions of ` + ` or ` * `  operators; apply the operations in that order.\\n\\n**Complexity**\\nLet `n` be the number of operations (so there\\'s `n+1` digits), and `M` be the max value allowed (1000 here). There are `~ n^2` subsegments of operations, and evaluating all values in a subsegment takes `n * M^2` time, for an `O(n^3 M^2)` time algorithm (and a linear term in `|students answers|`).\\n\\n**Python**\\n\\n```python\\nclass Solution:\\n\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        correct_ans = eval(s)\\n        standard_form = []\\n        for x in s:\\n            if x == \\'+\\':\\n                standard_form.append(0)\\n            elif x == \\'*\\':\\n                standard_form.append(1)\\n            else:\\n                standard_form.append(int(x))\\n\\n        @lru_cache(None)\\n        def divide_and_conquer(equation: Tuple[int]) -> Set[int]:\\n            if len(equation) == 1:\\n                return {equation[0]}\\n\\n            if len(equation) == 3:\\n                if equation[1] == 0:  # Add\\n                    return {equation[0] + equation[-1]}\\n                else:  # Multiply\\n                    return {equation[0] * equation[-1]}\\n\\n            my_answers = set()\\n            for split_point in range(1, len(equation), 2):\\n                left_answers = divide_and_conquer(equation[:split_point])\\n                right_answers = divide_and_conquer(equation[split_point + 1:])\\n\\n                if equation[split_point] == 0:  # Add\\n                    my_answers |= {x + y for x in left_answers for y in right_answers if x + y <= 1000}\\n                else:  # Multiply\\n                    my_answers |= {x * y for x in left_answers for y in right_answers if x * y <= 1000}\\n\\n            return my_answers\\n\\n        incorrect_answers = divide_and_conquer(tuple(standard_form))\\n        total_grade = 0\\n        for x in answers:\\n            if x == correct_ans:\\n                total_grade += 5\\n            elif x in incorrect_answers:\\n                total_grade += 2\\n        return total_grade\\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```python\\nclass Solution:\\n\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        correct_ans = eval(s)\\n        standard_form = []\\n        for x in s:\\n            if x == \\'+\\':\\n                standard_form.append(0)\\n            elif x == \\'*\\':\\n                standard_form.append(1)\\n            else:\\n                standard_form.append(int(x))\\n\\n        @lru_cache(None)\\n        def divide_and_conquer(equation: Tuple[int]) -> Set[int]:\\n            if len(equation) == 1:\\n                return {equation[0]}\\n\\n            if len(equation) == 3:\\n                if equation[1] == 0:  # Add\\n                    return {equation[0] + equation[-1]}\\n                else:  # Multiply\\n                    return {equation[0] * equation[-1]}\\n\\n            my_answers = set()\\n            for split_point in range(1, len(equation), 2):\\n                left_answers = divide_and_conquer(equation[:split_point])\\n                right_answers = divide_and_conquer(equation[split_point + 1:])\\n\\n                if equation[split_point] == 0:  # Add\\n                    my_answers |= {x + y for x in left_answers for y in right_answers if x + y <= 1000}\\n                else:  # Multiply\\n                    my_answers |= {x * y for x in left_answers for y in right_answers if x * y <= 1000}\\n\\n            return my_answers\\n\\n        incorrect_answers = divide_and_conquer(tuple(standard_form))\\n        total_grade = 0\\n        for x in answers:\\n            if x == correct_ans:\\n                total_grade += 5\\n            elif x in incorrect_answers:\\n                total_grade += 2\\n        return total_grade\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333996,
                "title": "tle-to-100-speed-at-260ms-java",
                "content": "### Ideas\\nThis problem has to do with **ordering**. If the order does not matter, then we can select which operator to do the last. Hence, we will deploy 2D DP `dp[i][j]` be the set of all possible sums between substring `[i, j]`. It is similar to **Burst Balloon** in that regard. \\n\\n#### Implementation\\nI used DP and purged all `res > 1000` and it got TLE. The TLE case passed in 10ms by itself, but I guess 300 test cases together caused it. \\n\\nChanged it to BitSet fixed it and also got 100% speed at 260ms. It proves that bitset are just much faster for small numbers.\\n\\n#### Other\\nI calculate the correct result with https://en.wikipedia.org/wiki/Shunting_yard_algorithm. The idea is simple. Process operators based on its precedence and associativity. \\n\\n#### Java\\n```Java\\nclass Solution {\\n    public int scoreOfStudents(String s, int[] answers) {\\n        BitSet[][] ok = new BitSet[32][32];\\n        solve(0, s.length()-1, s, ok);\\n        int ans = 0, correct = eval(s);\\n        for (int n : answers){\\n            if (correct == n){\\n                ans += 5;\\n            }else if (ok[0][s.length()-1].get(n)){\\n                ans += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private BitSet solve(int lo, int hi, String s, BitSet[][] memo){\\n        if (memo[lo][hi] != null){ // memo\\n            return memo[lo][hi];\\n        }\\n        BitSet cur = new BitSet();\\n        if (lo == hi){ // base case -> number itself [0 - 9]\\n            cur.set(s.charAt(lo) - \\'0\\');\\n            return memo[lo][hi]=cur;\\n        }\\n        for (int i = lo; i <= hi; i++){\\n            if (s.charAt(i) == \\'+\\' || s.charAt(i) == \\'*\\'){\\n                BitSet l = solve(lo, i-1, s, memo); // left\\n                BitSet r = solve(i+1, hi, s, memo); // right\\n                for (int j = l.nextSetBit(0); j >= 0; j = l.nextSetBit(j+1)){\\n                    for (int k = r.nextSetBit(0); k >= 0; k = r.nextSetBit(k+1)){\\n                        int val = s.charAt(i) == \\'+\\'? j+k:j*k;\\n                        if (val > 1000){\\n                            break;\\n                        }\\n                        cur.set(val);\\n                    }\\n                }\\n            }\\n        }\\n        return memo[lo][hi]=cur;\\n    }\\n\\n    private int eval(String s){\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        Deque<Character> op = new ArrayDeque<>();\\n        for(char ch : s.toCharArray()){\\n            if (ch == \\'+\\' || ch == \\'*\\'){\\n                while(!op.isEmpty() && (ch == \\'+\\' || op.peek() == \\'*\\')){\\n                    char w = op.pop();\\n                    int r = stack.pop(), l = stack.pop();\\n                    stack.push(w == \\'+\\'? l + r : l * r);\\n                }\\n                op.push(ch);\\n            }else{\\n                stack.push(ch-\\'0\\');\\n            }\\n        }\\n        while(!op.isEmpty()){\\n            char w = op.pop();\\n            int r = stack.pop(), l = stack.pop();\\n            stack.push(w == \\'+\\'? l + r : l * r);\\n        }\\n\\n        return stack.pop();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```Java\\nclass Solution {\\n    public int scoreOfStudents(String s, int[] answers) {\\n        BitSet[][] ok = new BitSet[32][32];\\n        solve(0, s.length()-1, s, ok);\\n        int ans = 0, correct = eval(s);\\n        for (int n : answers){\\n            if (correct == n){\\n                ans += 5;\\n            }else if (ok[0][s.length()-1].get(n)){\\n                ans += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private BitSet solve(int lo, int hi, String s, BitSet[][] memo){\\n        if (memo[lo][hi] != null){ // memo\\n            return memo[lo][hi];\\n        }\\n        BitSet cur = new BitSet();\\n        if (lo == hi){ // base case -> number itself [0 - 9]\\n            cur.set(s.charAt(lo) - \\'0\\');\\n            return memo[lo][hi]=cur;\\n        }\\n        for (int i = lo; i <= hi; i++){\\n            if (s.charAt(i) == \\'+\\' || s.charAt(i) == \\'*\\'){\\n                BitSet l = solve(lo, i-1, s, memo); // left\\n                BitSet r = solve(i+1, hi, s, memo); // right\\n                for (int j = l.nextSetBit(0); j >= 0; j = l.nextSetBit(j+1)){\\n                    for (int k = r.nextSetBit(0); k >= 0; k = r.nextSetBit(k+1)){\\n                        int val = s.charAt(i) == \\'+\\'? j+k:j*k;\\n                        if (val > 1000){\\n                            break;\\n                        }\\n                        cur.set(val);\\n                    }\\n                }\\n            }\\n        }\\n        return memo[lo][hi]=cur;\\n    }\\n\\n    private int eval(String s){\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        Deque<Character> op = new ArrayDeque<>();\\n        for(char ch : s.toCharArray()){\\n            if (ch == \\'+\\' || ch == \\'*\\'){\\n                while(!op.isEmpty() && (ch == \\'+\\' || op.peek() == \\'*\\')){\\n                    char w = op.pop();\\n                    int r = stack.pop(), l = stack.pop();\\n                    stack.push(w == \\'+\\'? l + r : l * r);\\n                }\\n                op.push(ch);\\n            }else{\\n                stack.push(ch-\\'0\\');\\n            }\\n        }\\n        while(!op.isEmpty()){\\n            char w = op.pop();\\n            int r = stack.pop(), l = stack.pop();\\n            stack.push(w == \\'+\\'? l + r : l * r);\\n        }\\n\\n        return stack.pop();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153853,
                "title": "python-memoization-of-sets",
                "content": "```\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        dp={}\\n        def f(i,j):\\n            if i==j:return set([int(x[i])])\\n            z=[]\\n            if (i,j) in dp:return dp[i,j]\\n            for k in range(i,j):\\n                a=f(i,k)\\n                b=f(k+1,j)\\n                for q in a:\\n                    for r in b:\\n                        if y[k]==\\'+\\':\\n                            if q+r<=1000:\\n                                z.append(q+r\\n                                    )\\n                        else:\\n                            if q*r<=1000:\\n                                z.append(q*r)\\n            z=set(z)\\n            dp[i,j]=z\\n            return z\\n        st=[]\\n        op=[]\\n        x=[]\\n        y=[]\\n        for i in s:\\n            if i in (\\'+\\',\\'*\\'):\\n                op.append(i)\\n                y.append(i)\\n            else:\\n                x.append(i)\\n                if op and op[-1]==\\'*\\':\\n                    op.pop(-1)\\n                    st.append(int(i)*st.pop(-1))\\n                else:\\n                    st.append(int(i))\\n        correct_ans=sum(st)\\n        z=f(0,len(x)-1)\\n        c=0\\n        for i in answers:\\n            if i==correct_ans:\\n                c+=5\\n            elif i in z:\\n                c+=2\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        dp={}\\n        def f(i,j):\\n            if i==j:return set([int(x[i])])\\n            z=[]\\n            if (i,j) in dp:return dp[i,j]\\n            for k in range(i,j):\\n                a=f(i,k)\\n                b=f(k+1,j)\\n                for q in a:\\n                    for r in b:\\n                        if y[k]==\\'+\\':\\n                            if q+r<=1000:\\n                                z.append(q+r\\n                                    )\\n                        else:\\n                            if q*r<=1000:\\n                                z.append(q*r)\\n            z=set(z)\\n            dp[i,j]=z\\n            return z\\n        st=[]\\n        op=[]\\n        x=[]\\n        y=[]\\n        for i in s:\\n            if i in (\\'+\\',\\'*\\'):\\n                op.append(i)\\n                y.append(i)\\n            else:\\n                x.append(i)\\n                if op and op[-1]==\\'*\\':\\n                    op.pop(-1)\\n                    st.append(int(i)*st.pop(-1))\\n                else:\\n                    st.append(int(i))\\n        correct_ans=sum(st)\\n        z=f(0,len(x)-1)\\n        c=0\\n        for i in answers:\\n            if i==correct_ans:\\n                c+=5\\n            elif i in z:\\n                c+=2\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2134559,
                "title": "dp",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<int> dp[32][32];\\n    \\n    void sol(int i,int j,string &s) \\n    {\\n        if(!dp[i][j].empty()) return ;\\n        \\n        if(i==j)\\n        {\\n            dp[i][j].insert(s[i]-\\'0\\');\\n            return ;\\n        }\\n        \\n        for(int k=i+1;k<=j;k+=2)\\n        {\\n            sol(i,k-1,s);\\n            sol(k+1,j,s);\\n            \\n            for(auto x:dp[i][k-1])\\n                for(auto y:dp[k+1][j])\\n                {\\n                    int val=(s[k]==\\'+\\' ? x+y : x*y);\\n                    if(val<=1000) dp[i][j].insert(val);\\n                }\\n        }\\n    }\\n    \\n    int scoreOfStudents(string s, vector<int>& a) \\n    {\\n        vector<int> v;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(v.size() && v.back()==-1)\\n            {\\n                v.pop_back();\\n                int num=v.back()*(s[i]-\\'0\\');\\n                v.pop_back();\\n                v.push_back(num);\\n            }\\n            else if(s[i]==\\'*\\') v.push_back(-1);\\n            else if(s[i]==\\'+\\') v.push_back(-2);\\n            else v.push_back((s[i]-\\'0\\'));\\n        }\\n        int right=0;\\n        for(int i=0;i<v.size();i+=2)\\n            right+=v[i];\\n        \\n        sol(0,s.length()-1,s);\\n        \\n        int ans=0;\\n        for(int i=0;i<a.size();i++)\\n            if(a[i]==right) ans+=5;\\n            else if(dp[0][s.length()-1].count(a[i])) ans+=2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<int> dp[32][32];\\n    \\n    void sol(int i,int j,string &s) \\n    {\\n        if(!dp[i][j].empty()) return ;\\n        \\n        if(i==j)\\n        {\\n            dp[i][j].insert(s[i]-\\'0\\');\\n            return ;\\n        }\\n        \\n        for(int k=i+1;k<=j;k+=2)\\n        {\\n            sol(i,k-1,s);\\n            sol(k+1,j,s);\\n            \\n            for(auto x:dp[i][k-1])\\n                for(auto y:dp[k+1][j])\\n                {\\n                    int val=(s[k]==\\'+\\' ? x+y : x*y);\\n                    if(val<=1000) dp[i][j].insert(val);\\n                }\\n        }\\n    }\\n    \\n    int scoreOfStudents(string s, vector<int>& a) \\n    {\\n        vector<int> v;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(v.size() && v.back()==-1)\\n            {\\n                v.pop_back();\\n                int num=v.back()*(s[i]-\\'0\\');\\n                v.pop_back();\\n                v.push_back(num);\\n            }\\n            else if(s[i]==\\'*\\') v.push_back(-1);\\n            else if(s[i]==\\'+\\') v.push_back(-2);\\n            else v.push_back((s[i]-\\'0\\'));\\n        }\\n        int right=0;\\n        for(int i=0;i<v.size();i+=2)\\n            right+=v[i];\\n        \\n        sol(0,s.length()-1,s);\\n        \\n        int ans=0;\\n        for(int i=0;i<a.size();i++)\\n            if(a[i]==right) ans+=5;\\n            else if(dp[0][s.length()-1].count(a[i])) ans+=2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705751,
                "title": "java-dfs-memo-solution",
                "content": "~~~java\\n\\nclass Solution {\\n    Map<String, Set<Integer>> memo = new HashMap<>();\\n    \\n    public int scoreOfStudents(String s, int[] answers) {\\n        // 1. calc correct answer\\n        int correctAnswer = getCorrectAnswer(s);\\n        \\n        // 2. dfs + memo to get all possible answers\\n        Set<Integer> allAnswers = getAllAnswers(s);\\n        \\n        // 3. calc scores\\n        return getTotalScore(correctAnswer, allAnswers, answers);\\n    }\\n    \\n    private int getTotalScore(int correctAnswer, Set<Integer> allAnswers, int[] answers) {\\n        int rst = 0;\\n        for (int a : answers) {\\n            if (a == correctAnswer) {\\n                rst += 5;\\n            } else if (allAnswers.contains(a)) {\\n                rst += 2;\\n            }\\n        }\\n        return rst;\\n    }\\n    \\n    private Set<Integer> getAllAnswers(String s) {\\n        Set<Integer> rst = new HashSet<>();\\n        if (s.isEmpty()) {\\n            return rst;\\n        } else if (s.length() == 1) {\\n            rst.add(Integer.parseInt(s));\\n            return rst;\\n        }\\n        \\n        if (memo.containsKey(s)) {\\n            return memo.get(s);\\n        }\\n        \\n        for (int i = 1; i < s.length(); i += 2) {\\n            char sign = s.charAt(i);\\n            Set<Integer> left = getAllAnswers(s.substring(0, i));\\n            Set<Integer> right = getAllAnswers(s.substring(i + 1));\\n            \\n            for (int l : left) {\\n                for (int r : right) {\\n                    int temp = sign == \\'+\\' ? l + r : l * r;\\n                    if (temp <= 1000) {\\n                        rst.add(temp);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        memo.put(s, rst);\\n        return rst;\\n    }\\n    \\n    private int getCorrectAnswer(String s) {\\n        Deque<Integer> nums = new ArrayDeque<>();\\n        Deque<Character> ops = new ArrayDeque<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'+\\' || c == \\'*\\') {\\n                if (!ops.isEmpty() && higherPrecedence(ops.peekFirst(), c)) {\\n                    eval(nums, ops);\\n                }\\n                ops.offerFirst(c);\\n            } else {\\n                int temp = 0;\\n                int j = i;\\n                while (j < s.length() && Character.isDigit(s.charAt(j))) {\\n                    temp = temp * 10 + s.charAt(j) - \\'0\\';\\n                    j++;\\n                }\\n                i = j - 1;\\n                nums.offerFirst(temp);\\n            }\\n        }\\n        \\n        while (!ops.isEmpty()) {\\n            eval(nums, ops);\\n        }\\n        return nums.peekFirst();\\n    }\\n    \\n    private void eval(Deque<Integer> nums, Deque<Character> ops) {\\n        char op = ops.pollFirst();\\n        if (op == \\'+\\') {\\n            nums.offerFirst(nums.pollFirst() + nums.pollFirst());\\n        } else {\\n            nums.offerFirst(nums.pollFirst() * nums.pollFirst());\\n        }\\n    }\\n    \\n    private boolean higherPrecedence(char op1, char op2) {\\n        if (op1 == \\'+\\' && op2 == \\'*\\') {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    Map<String, Set<Integer>> memo = new HashMap<>();\\n    \\n    public int scoreOfStudents(String s, int[] answers) {\\n        // 1. calc correct answer\\n        int correctAnswer = getCorrectAnswer(s);\\n        \\n        // 2. dfs + memo to get all possible answers\\n        Set<Integer> allAnswers = getAllAnswers(s);\\n        \\n        // 3. calc scores\\n        return getTotalScore(correctAnswer, allAnswers, answers);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1491416,
                "title": "java-simple-solution",
                "content": "Recursion with memoization.\\n\\n```\\nclass Solution {\\n    HashSet<?>[][] dp;\\n    public int scoreOfStudents(String s, int[] answers) {\\n        ArrayDeque<Integer> st = new ArrayDeque<>();\\n        int n = s.length(), i = 0;\\n        dp = new HashSet<?>[n][n];\\n        while(i<n) { // correct result calculation\\n            if(s.charAt(i)-\\'0\\' >=0 && s.charAt(i) -\\'9\\' <=0) {\\n                st.push(s.charAt(i)-\\'0\\');\\n                i++;\\n            } else if(s.charAt(i) == \\'*\\') {\\n                int cur = st.pop() * (s.charAt(i+1)-\\'0\\');\\n                i+=2;\\n                st.push(cur);\\n            } else i++;\\n        }\\n        int res = 0, ret = 0;\\n        while(!st.isEmpty())\\n            res += st.pop();\\n        HashSet<Integer> wrong = opts(0, n-1, s);\\n        for(int ans : answers) {\\n            if(ans == res)\\n                ret += 5;\\n            else if(wrong.contains(ans))\\n                ret+=2;\\n        }\\n        return ret;\\n    }\\n    HashSet<Integer> opts(int i, int j, String s) { // recursion through all possible selection of last operation in current window\\n        if(dp[i][j] != null) return (HashSet<Integer>)dp[i][j];\\n        if(i == j) {\\n            HashSet<Integer> res = new HashSet<Integer>();\\n            res.add(s.charAt(i)-\\'0\\');\\n            dp[i][j] = res;\\n            return res;\\n        }\\n        HashSet<Integer> res = new HashSet<Integer>();\\n        for(int x = i+1; x < j; x+=2) {\\n            char op = s.charAt(x);\\n            HashSet<Integer> left = opts(i, x-1, s);\\n            HashSet<Integer> right = opts(x+1, j, s);\\n            if( op == \\'*\\' ) {\\n                for(int l : left)\\n                    for(int r : right)\\n                        if( l * r  <= 1000 ) // important because it leads to unnecessary increase in hashset size then TLE\\n                            res.add( l * r );\\n            } else\\n                for(int l : left)\\n                    for(int r : right)\\n                        if( l + r  <= 1000 )\\n                            res.add( l + r );\\n        }\\n        dp[i][j] = res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashSet<?>[][] dp;\\n    public int scoreOfStudents(String s, int[] answers) {\\n        ArrayDeque<Integer> st = new ArrayDeque<>();\\n        int n = s.length(), i = 0;\\n        dp = new HashSet<?>[n][n];\\n        while(i<n) { // correct result calculation\\n            if(s.charAt(i)-\\'0\\' >=0 && s.charAt(i) -\\'9\\' <=0) {\\n                st.push(s.charAt(i)-\\'0\\');\\n                i++;\\n            } else if(s.charAt(i) == \\'*\\') {\\n                int cur = st.pop() * (s.charAt(i+1)-\\'0\\');\\n                i+=2;\\n                st.push(cur);\\n            } else i++;\\n        }\\n        int res = 0, ret = 0;\\n        while(!st.isEmpty())\\n            res += st.pop();\\n        HashSet<Integer> wrong = opts(0, n-1, s);\\n        for(int ans : answers) {\\n            if(ans == res)\\n                ret += 5;\\n            else if(wrong.contains(ans))\\n                ret+=2;\\n        }\\n        return ret;\\n    }\\n    HashSet<Integer> opts(int i, int j, String s) { // recursion through all possible selection of last operation in current window\\n        if(dp[i][j] != null) return (HashSet<Integer>)dp[i][j];\\n        if(i == j) {\\n            HashSet<Integer> res = new HashSet<Integer>();\\n            res.add(s.charAt(i)-\\'0\\');\\n            dp[i][j] = res;\\n            return res;\\n        }\\n        HashSet<Integer> res = new HashSet<Integer>();\\n        for(int x = i+1; x < j; x+=2) {\\n            char op = s.charAt(x);\\n            HashSet<Integer> left = opts(i, x-1, s);\\n            HashSet<Integer> right = opts(x+1, j, s);\\n            if( op == \\'*\\' ) {\\n                for(int l : left)\\n                    for(int r : right)\\n                        if( l * r  <= 1000 ) // important because it leads to unnecessary increase in hashset size then TLE\\n                            res.add( l * r );\\n            } else\\n                for(int l : left)\\n                    for(int r : right)\\n                        if( l + r  <= 1000 )\\n                            res.add( l + r );\\n        }\\n        dp[i][j] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489669,
                "title": "explanation-and-code-simple-to-understand",
                "content": "We can let `dp[l][r]` be a set wich represents all the possible values we can achieve by potentially messing up the order of operations on the interval l, r. For example, if our string is `3*3+5+5`, then `dp[0][4]` represents all the possible values of `3*3+5`--there are 2 of them, namely `3*3+5=14` and `3*(3+5)=24`.\\n\\nNow, we can just recurse. We can imagine the possible values of `dp[l][i]`, appending the order of operation `s[i + 1]` and then `dp[i + 2][r]`. This is the crux of the memoized solution.\\n```\\nclass Solution {\\npublic:\\n    string str;\\n\\n    int calculate(int l, int r) { //evaluate the expression\\n        stack<int> stack;\\n        int currNumber = 0;\\n        char sign = \\'+\\';\\n        for (int i = l; i <= r + 1; i++) {\\n            char c;\\n            if (i <= r) c = str[i];\\n            else c = \\'+\\';\\n            if (c >= \\'0\\') {\\n                currNumber = c - 48;\\n            } else {\\n                if (sign == \\'+\\') {\\n                    stack.push(currNumber);\\n                } else if (sign == \\'*\\') {\\n                    int a = stack.top();\\n                    stack.pop();\\n                    stack.push(a * currNumber);\\n                }\\n                sign = c;\\n            }\\n        }\\n        int result = 0;\\n        while (!stack.empty()) {\\n            result += stack.top();\\n            stack.pop();\\n        }\\n        return result;\\n    }\\n\\n    set<int> dp[32][32];\\n\\n    void rec(int l, int r) {\\n        if (dp[l][r].size() != 0) {\\n            return;\\n        }\\n        dp[l][r].insert(calculate(l, r));\\n        for (int i = l + 1; i <= r; i += 2) {\\n            rec(l, i - 1);\\n            rec(i + 1, r);\\n            for (int j: dp[l][i - 1]) {\\n                for (int k: dp[i + 1][r]) {\\n                    if (str[i] == \\'+\\') {\\n                        if (j + k <= 1000) dp[l][r].insert(j + k);\\n                    } else {\\n                        if (j * k <= 1000) dp[l][r].insert(j * k);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    int scoreOfStudents(string s, vector<int> &answers) {\\n        str = s;\\n        int cntr = 0;\\n        rec(0, s.length() - 1);\\n        set<int> mySet = dp[0][s.length() - 1];\\n        int ans = calculate(0, s.length() - 1);\\n        for (int i = 0; i < answers.size(); i++) {\\n            if (ans == answers[i]) {\\n                cntr += 3;\\n            }\\n            if (mySet.count(answers[i])) {\\n                cntr += 2;\\n            }\\n        }\\n        return cntr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string str;\\n\\n    int calculate(int l, int r) { //evaluate the expression\\n        stack<int> stack;\\n        int currNumber = 0;\\n        char sign = \\'+\\';\\n        for (int i = l; i <= r + 1; i++) {\\n            char c;\\n            if (i <= r) c = str[i];\\n            else c = \\'+\\';\\n            if (c >= \\'0\\') {\\n                currNumber = c - 48;\\n            } else {\\n                if (sign == \\'+\\') {\\n                    stack.push(currNumber);\\n                } else if (sign == \\'*\\') {\\n                    int a = stack.top();\\n                    stack.pop();\\n                    stack.push(a * currNumber);\\n                }\\n                sign = c;\\n            }\\n        }\\n        int result = 0;\\n        while (!stack.empty()) {\\n            result += stack.top();\\n            stack.pop();\\n        }\\n        return result;\\n    }\\n\\n    set<int> dp[32][32];\\n\\n    void rec(int l, int r) {\\n        if (dp[l][r].size() != 0) {\\n            return;\\n        }\\n        dp[l][r].insert(calculate(l, r));\\n        for (int i = l + 1; i <= r; i += 2) {\\n            rec(l, i - 1);\\n            rec(i + 1, r);\\n            for (int j: dp[l][i - 1]) {\\n                for (int k: dp[i + 1][r]) {\\n                    if (str[i] == \\'+\\') {\\n                        if (j + k <= 1000) dp[l][r].insert(j + k);\\n                    } else {\\n                        if (j * k <= 1000) dp[l][r].insert(j * k);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    int scoreOfStudents(string s, vector<int> &answers) {\\n        str = s;\\n        int cntr = 0;\\n        rec(0, s.length() - 1);\\n        set<int> mySet = dp[0][s.length() - 1];\\n        int ans = calculate(0, s.length() - 1);\\n        for (int i = 0; i < answers.size(); i++) {\\n            if (ans == answers[i]) {\\n                cntr += 3;\\n            }\\n            if (mySet.count(answers[i])) {\\n                cntr += 2;\\n            }\\n        }\\n        return cntr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488066,
                "title": "c-dp-and-a-rant",
                "content": "Well this solution is the same as everyone else\\'s. However, I thought I\\'ll just write down what I was going over when I was trying to solve this, but I didn\\'t solve :( during the contest and after. I recommend reading on this post to understand the solution: https://tinyurl.com/4xvwypee\\n\\nI think the biggest issue I had is not realizing the real complexity of solution of this kind. \\nIf you look below you\\'ll quickly realize it is O(k^3 * n^2) where k <= 15 and n <= 1000 and well that\\'s over a 3,375,000,000 . You can see that k^3 is actually k^3 / 8 so -> 421,875,000 and then you can also add the fact that having 1000 unique numbers isn\\'t as easy all the time and it\\'s harder to gauge but I would remove another factor of 10 at least, so our O(k^3 * n^2) ~= 42,187,500 which fits well into the time limit. \\n\\nWhen approaching this kind of a solution, I felt like I knew that I could divide around the sign, but I didn\\'t feel like that would be enough bruteforcing all the combinations. Certainly not to say there is a problem with the problem xD, I just don\\'t have much experience approaching this type of a question: have a set on the left and right and combine them :| into another set of size 1000 - it just didn\\'t register.\\n\\n```\\nclass Solution {\\npublic:\\n    void getReal(int &real, string &s, vector <int> &a, vector <int> &nums, vector <char> &op) {\\n        int n = s.size();\\n        for (int i = 0; i < n; i += 2) nums[i / 2] = s[i] - \\'0\\';\\n        int cur = nums[0];\\n        for (int i = 1; i < n; i += 2) {\\n            op.push_back(s[i]);\\n            if (s[i] == \\'+\\')  {\\n                real += cur;\\n                cur = nums[i / 2 + 1];\\n            }\\n            else\\n                cur *= nums[i / 2 + 1];\\n        }\\n        real += cur; // finished getting real answer.\\n    }\\n    int scoreOfStudents(string s, vector<int>& a) {\\n        int real = 0; // actual answer stored separately.\\n        int n = s.size();\\n        int m = n / 2 + 1;\\n        vector <int> nums(m); // numbers \\n        vector <char> op; // operations\\n        getReal(real, s, a, nums, op);\\n        // ............................ do actual dp\\n        vector <vector <unordered_set <int>>> dp(m, vector<unordered_set<int>>(m));\\n        for (int i = 0; i < m; i++)\\n            dp[i][i].insert(nums[i]);\\n        for (int i = 1; i < m; i++) {\\n            for (int j = i - 1; j >= 0; j--) {\\n                for (int k = j; k < i; k++) {\\n                    //d[j][i].insert(combs(d[j][k], dp[k + 1][i]));\\n                    if (op[k] == \\'+\\') {\\n                        for (auto &x : dp[j][k])\\n                            for (auto &y : dp[k + 1][i])\\n                                if (x + y <= 1000) \\n                                    dp[j][i].insert(x + y);\\n                    }\\n                    else {\\n                        for (auto &x : dp[j][k])\\n                            for (auto &y : dp[k + 1][i])\\n                                if (x * y <= 1000) \\n                                    dp[j][i].insert(x * y);\\n                    }\\n                }\\n            }\\n        }\\n        // ................................ check answers\\n        int ret = 0;\\n        for (auto &x : a) {\\n            if (x == real) ret += 5;\\n            else if (dp[0][m - 1].find(x) != dp[0][m - 1].end())\\n                ret += 2;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void getReal(int &real, string &s, vector <int> &a, vector <int> &nums, vector <char> &op) {\\n        int n = s.size();\\n        for (int i = 0; i < n; i += 2) nums[i / 2] = s[i] - \\'0\\';\\n        int cur = nums[0];\\n        for (int i = 1; i < n; i += 2) {\\n            op.push_back(s[i]);\\n            if (s[i] == \\'+\\')  {\\n                real += cur;\\n                cur = nums[i / 2 + 1];\\n            }\\n            else\\n                cur *= nums[i / 2 + 1];\\n        }\\n        real += cur; // finished getting real answer.\\n    }\\n    int scoreOfStudents(string s, vector<int>& a) {\\n        int real = 0; // actual answer stored separately.\\n        int n = s.size();\\n        int m = n / 2 + 1;\\n        vector <int> nums(m); // numbers \\n        vector <char> op; // operations\\n        getReal(real, s, a, nums, op);\\n        // ............................ do actual dp\\n        vector <vector <unordered_set <int>>> dp(m, vector<unordered_set<int>>(m));\\n        for (int i = 0; i < m; i++)\\n            dp[i][i].insert(nums[i]);\\n        for (int i = 1; i < m; i++) {\\n            for (int j = i - 1; j >= 0; j--) {\\n                for (int k = j; k < i; k++) {\\n                    //d[j][i].insert(combs(d[j][k], dp[k + 1][i]));\\n                    if (op[k] == \\'+\\') {\\n                        for (auto &x : dp[j][k])\\n                            for (auto &y : dp[k + 1][i])\\n                                if (x + y <= 1000) \\n                                    dp[j][i].insert(x + y);\\n                    }\\n                    else {\\n                        for (auto &x : dp[j][k])\\n                            for (auto &y : dp[k + 1][i])\\n                                if (x * y <= 1000) \\n                                    dp[j][i].insert(x * y);\\n                    }\\n                }\\n            }\\n        }\\n        // ................................ check answers\\n        int ret = 0;\\n        for (auto &x : a) {\\n            if (x == real) ret += 5;\\n            else if (dp[0][m - 1].find(x) != dp[0][m - 1].end())\\n                ret += 2;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488020,
                "title": "c-ugly-code-but-beats-100-with-260-ms-run-time-weird",
                "content": "```\\nint func(const int& lhs, const int& rhs, const char& c) {\\n    if(c==\\'+\\') return lhs+rhs;\\n    return lhs*rhs;\\n}\\n\\n// my shabby calculator\\n\\nint calculate(const string& s){\\n    int n = s.size();\\n    int ans = s[0]-\\'0\\';\\n    int i = 1;\\n    int prev = s[0]-\\'0\\';\\n    while(i<n){\\n        if(s[i]==\\'+\\'){\\n            i++;\\n            ans+= s[i]-\\'0\\';\\n            prev = s[i]-\\'0\\';\\n            i++;\\n        }\\n        else{\\n            i++;\\n            ans-= prev;\\n            ans+= prev*(s[i]-\\'0\\');\\n            prev*= (s[i]-\\'0\\');\\n            i++;\\n        }\\n    }\\n    return ans;\\n}\\n\\n// end of my shabbby calculator\\n\\nclass Solution {\\npublic:\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        int n = s.size();\\n        int n_opr = n/2;\\n        \\n        vector<vector<vector<int>>> dp(n_opr+1,vector<vector<int>>(n_opr+2));\\n        for(int k=1; k<=n_opr+1; k++) dp[0][k].push_back(s[2*(k-1)]-\\'0\\');\\n        \\n        bool count[1001];\\n        \\n        char opr[n_opr+1];\\n        for(int k=1; k<=n_opr; k++) opr[k] = s[2*k-1];\\n        \\n        int result;\\n        for(int l=1; l<=n_opr; l++){\\n            for(int k=1; k<=n_opr-l+1; k++){\\n                memset(count,0,sizeof(count));\\n                for(int i=0; i<l; i++){\\n                    for(int& lhs:dp[i][k]){\\n                        for(int& rhs:dp[l-i-1][k+i+1]){\\n                            result = func(lhs,rhs,opr[k+i]);\\n                            if(result<=1000) count[result] = true;\\n                        }\\n                    }\\n                }\\n                for(int j=0; j<=1000; j++){\\n                    if(count[j]) dp[l][k].push_back(j);\\n                }\\n            }\\n        }\\n        \\n        result = calculate(s);\\n        memset(count,0,sizeof(count));\\n        for(int& elem:dp[n_opr][1]) count[elem] = true;\\n        \\n        int ret = 0;\\n        for(int& ans:answers){\\n            if(count[ans]){\\n                if(ans==result) ret+= 5;\\n                else ret+= 2;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint func(const int& lhs, const int& rhs, const char& c) {\\n    if(c==\\'+\\') return lhs+rhs;\\n    return lhs*rhs;\\n}\\n\\n// my shabby calculator\\n\\nint calculate(const string& s){\\n    int n = s.size();\\n    int ans = s[0]-\\'0\\';\\n    int i = 1;\\n    int prev = s[0]-\\'0\\';\\n    while(i<n){\\n        if(s[i]==\\'+\\'){\\n            i++;\\n            ans+= s[i]-\\'0\\';\\n            prev = s[i]-\\'0\\';\\n            i++;\\n        }\\n        else{\\n            i++;\\n            ans-= prev;\\n            ans+= prev*(s[i]-\\'0\\');\\n            prev*= (s[i]-\\'0\\');\\n            i++;\\n        }\\n    }\\n    return ans;\\n}\\n\\n// end of my shabbby calculator\\n\\nclass Solution {\\npublic:\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        int n = s.size();\\n        int n_opr = n/2;\\n        \\n        vector<vector<vector<int>>> dp(n_opr+1,vector<vector<int>>(n_opr+2));\\n        for(int k=1; k<=n_opr+1; k++) dp[0][k].push_back(s[2*(k-1)]-\\'0\\');\\n        \\n        bool count[1001];\\n        \\n        char opr[n_opr+1];\\n        for(int k=1; k<=n_opr; k++) opr[k] = s[2*k-1];\\n        \\n        int result;\\n        for(int l=1; l<=n_opr; l++){\\n            for(int k=1; k<=n_opr-l+1; k++){\\n                memset(count,0,sizeof(count));\\n                for(int i=0; i<l; i++){\\n                    for(int& lhs:dp[i][k]){\\n                        for(int& rhs:dp[l-i-1][k+i+1]){\\n                            result = func(lhs,rhs,opr[k+i]);\\n                            if(result<=1000) count[result] = true;\\n                        }\\n                    }\\n                }\\n                for(int j=0; j<=1000; j++){\\n                    if(count[j]) dp[l][k].push_back(j);\\n                }\\n            }\\n        }\\n        \\n        result = calculate(s);\\n        memset(count,0,sizeof(count));\\n        for(int& elem:dp[n_opr][1]) count[elem] = true;\\n        \\n        int ret = 0;\\n        for(int& ans:answers){\\n            if(count[ans]){\\n                if(ans==result) ret+= 5;\\n                else ret+= 2;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487968,
                "title": "all-possible-1000",
                "content": "```\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        @lru_cache(None)\\n        def allEval(x):\\n            lo = eval(x)\\n            if lo > 1000:\\n                return set()\\n            ans = set([lo])\\n            if \\'*\\' not in x or \\'+\\' not in x or lo==1000:\\n                return ans\\n            for pos, char in enumerate(x):\\n                if char not in [\\'+\\', \\'*\\']:\\n                    continue\\n                left, right = allEval(x[:pos]), allEval(x[pos+1:])\\n                if char == \\'+\\':\\n                    ans |= {a + b for a in left for b in right if a+b<=1000}\\n                if char == \\'*\\':\\n                    ans |= {a * b for a in left for b in right if a*b<=1000}\\n            return ans\\n        S = allEval(s)\\n        correct = eval(s)\\n        return sum(5 if x==correct else (2 if x in S else 0) for x in answers)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        @lru_cache(None)\\n        def allEval(x):\\n            lo = eval(x)\\n            if lo > 1000:\\n                return set()\\n            ans = set([lo])\\n            if \\'*\\' not in x or \\'+\\' not in x or lo==1000:\\n                return ans\\n            for pos, char in enumerate(x):\\n                if char not in [\\'+\\', \\'*\\']:\\n                    continue\\n                left, right = allEval(x[:pos]), allEval(x[pos+1:])\\n                if char == \\'+\\':\\n                    ans |= {a + b for a in left for b in right if a+b<=1000}\\n                if char == \\'*\\':\\n                    ans |= {a * b for a in left for b in right if a*b<=1000}\\n            return ans\\n        S = allEval(s)\\n        correct = eval(s)\\n        return sum(5 if x==correct else (2 if x in S else 0) for x in answers)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486458,
                "title": "c-dp",
                "content": "1. Calculate all possible solutions with DP, using 2D vector of set;\\n2. Calculate the correct answer using a stack;\\n3. Traverse all the given answers;\\n\\nBelow is my code -- \\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        int l = s.length(), nd = l / 2 + 1, m = answers.size(), ans = 0, correct = 0;\\n        vector<vector<set<int>>> cal(nd, vector<set<int>>(nd));\\n        for (int i = 0; i < nd; i++)\\n            cal[i][i].insert(s[2 * i] - \\'0\\');\\n        for (int i = nd - 1; i >= 0; i--)\\n            for (int j = i + 1; j < nd; j++)\\n            {\\n                for (int k = i + 1; k <= j; k++)\\n                {\\n                    if (s[2 * k - 1] == \\'+\\')\\n                    {\\n                        for (auto jj : cal[i][k - 1])\\n                            for (auto kk : cal[k][j])\\n                            {\\n                                int p = jj + kk;\\n                                if (p <= 1000)\\n                                    cal[i][j].insert(p);\\n                            }\\n                    }\\n                    else\\n                    {\\n                        for (auto jj : cal[i][k - 1])\\n                            for (auto kk : cal[k][j])\\n                            {\\n                                int p = jj * kk;\\n                                if (p <= 1000)\\n                                    cal[i][j].insert(p);\\n                            }\\n                    }\\n                }\\n            }\\n        stack<int> st;\\n        st.push(s[0] - \\'0\\');\\n        for (int i = 1; i < l; i += 2)\\n        {\\n            if (s[i] == \\'+\\')\\n                st.push(s[i + 1] - \\'0\\');\\n            else\\n            {\\n                int t = st.top();\\n                st.pop();\\n                st.push(t * (s[i + 1] - \\'0\\'));\\n            }\\n        }\\n        while (!st.empty())\\n        {\\n            correct += st.top();\\n            st.pop();\\n        }\\n        for (int i = 0; i < m; i++)\\n        {\\n            if (answers[i] == correct)\\n                ans += 5;\\n            else if (cal[0][nd - 1].find(answers[i]) != cal[0][nd - 1].end())\\n                ans += 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        int l = s.length(), nd = l / 2 + 1, m = answers.size(), ans = 0, correct = 0;\\n        vector<vector<set<int>>> cal(nd, vector<set<int>>(nd));\\n        for (int i = 0; i < nd; i++)\\n            cal[i][i].insert(s[2 * i] - \\'0\\');\\n        for (int i = nd - 1; i >= 0; i--)\\n            for (int j = i + 1; j < nd; j++)\\n            {\\n                for (int k = i + 1; k <= j; k++)\\n                {\\n                    if (s[2 * k - 1] == \\'+\\')\\n                    {\\n                        for (auto jj : cal[i][k - 1])\\n                            for (auto kk : cal[k][j])\\n                            {\\n                                int p = jj + kk;\\n                                if (p <= 1000)\\n                                    cal[i][j].insert(p);\\n                            }\\n                    }\\n                    else\\n                    {\\n                        for (auto jj : cal[i][k - 1])\\n                            for (auto kk : cal[k][j])\\n                            {\\n                                int p = jj * kk;\\n                                if (p <= 1000)\\n                                    cal[i][j].insert(p);\\n                            }\\n                    }\\n                }\\n            }\\n        stack<int> st;\\n        st.push(s[0] - \\'0\\');\\n        for (int i = 1; i < l; i += 2)\\n        {\\n            if (s[i] == \\'+\\')\\n                st.push(s[i + 1] - \\'0\\');\\n            else\\n            {\\n                int t = st.top();\\n                st.pop();\\n                st.push(t * (s[i + 1] - \\'0\\'));\\n            }\\n        }\\n        while (!st.empty())\\n        {\\n            correct += st.top();\\n            st.pop();\\n        }\\n        for (int i = 0; i < m; i++)\\n        {\\n            if (answers[i] == correct)\\n                ans += 5;\\n            else if (cal[0][nd - 1].find(answers[i]) != cal[0][nd - 1].end())\\n                ans += 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486287,
                "title": "python-dp",
                "content": "`dp(i, j)` indicates all possible answers produced by applying operators arbitarily on the expression `s[i:j]`.\\n\\n```\\nfrom itertools import product\\nfrom functools import cache\\n\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        trueans = eval(s)\\n        adds = []\\n        \\n        @cache\\n        def dp(i=0, j=len(s)):\\n            if j - i == 1:\\n                return {int(s[i])}\\n            anss = set()\\n            for opi in range(i + 1, j, 2): # try every operator as the final operator applied\\n                op = s[opi]\\n\\t\\t\\t\\t# combine every possible answers from left side & right side pair by pair\\n                for l, r in product(dp(i, opi), dp(opi + 1, j)):\\n                    if op == \"+\":\\n                        v = l + r\\n                    else:\\n                        v = l * r\\n                    if v <= 1000:\\n                        anss.add(v)\\n                    \\n            return woans\\n        anss = dp()\\n        t = [5 if answer == trueans else (2 if answer in anss else 0) for answer in answers]\\n        return sum(t)\\n```\\n\\nTime complexity: `O(n^3*1000^2)`",
                "solutionTags": [],
                "code": "```\\nfrom itertools import product\\nfrom functools import cache\\n\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        trueans = eval(s)\\n        adds = []\\n        \\n        @cache\\n        def dp(i=0, j=len(s)):\\n            if j - i == 1:\\n                return {int(s[i])}\\n            anss = set()\\n            for opi in range(i + 1, j, 2): # try every operator as the final operator applied\\n                op = s[opi]\\n\\t\\t\\t\\t# combine every possible answers from left side & right side pair by pair\\n                for l, r in product(dp(i, opi), dp(opi + 1, j)):\\n                    if op == \"+\":\\n                        v = l + r\\n                    else:\\n                        v = l * r\\n                    if v <= 1000:\\n                        anss.add(v)\\n                    \\n            return woans\\n        anss = dp()\\n        t = [5 if answer == trueans else (2 if answer in anss else 0) for answer in answers]\\n        return sum(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4105212,
                "title": "top-down-dp-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n^2 \\\\cdot 2^{n - 1} + m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n \\\\cdot n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nwhere `n = s.length`, `m = answers.length`\\n\\n# Code\\n``` python3 []\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        add = lambda x, y: x + y\\n        multi = lambda x, y: x * y\\n        \\n        def get_tokens(s):\\n            tokens = []\\n            for char in s:\\n                if char == \\'+\\':\\n                    value = add\\n                elif char == \\'*\\':\\n                    value = multi\\n                else:\\n                    value = int(char)\\n                tokens.append(value)\\n            return tokens\\n        \\n        tokens = get_tokens(s)\\n\\n        def calc(tokens):\\n            stack = []\\n            for elem in tokens:\\n                if stack and stack[-1] is multi:\\n                    _ = stack.pop()\\n                    stack[-1] *= elem\\n                else:\\n                    stack.append(elem)\\n            return sum(\\n                stack[i]\\n                for i in range(0, len(stack), 2)\\n            )\\n        \\n        @cache\\n        def dp(left, right):\\n            if left + 1 == right:\\n                return {tokens[left]}\\n            \\n            result = set()\\n            for middle in range(left + 1, right, 2):\\n                op = tokens[middle]\\n                left_options = dp(left, middle)\\n                right_options = dp(middle + 1, right)\\n                for a in left_options:\\n                    for b in right_options:\\n                        current = op(a, b)\\n                        if current <= 1000:\\n                            result.add(current)\\n            return result\\n        \\n        correct_answer = calc(tokens)\\n        wrong_answers = dp(0, len(tokens))\\n\\n        result = 0\\n        for answer in answers:\\n            if answer == correct_answer:\\n                result += 5\\n            elif answer in wrong_answers:\\n                result += 2\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "``` python3 []\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        add = lambda x, y: x + y\\n        multi = lambda x, y: x * y\\n        \\n        def get_tokens(s):\\n            tokens = []\\n            for char in s:\\n                if char == \\'+\\':\\n                    value = add\\n                elif char == \\'*\\':\\n                    value = multi\\n                else:\\n                    value = int(char)\\n                tokens.append(value)\\n            return tokens\\n        \\n        tokens = get_tokens(s)\\n\\n        def calc(tokens):\\n            stack = []\\n            for elem in tokens:\\n                if stack and stack[-1] is multi:\\n                    _ = stack.pop()\\n                    stack[-1] *= elem\\n                else:\\n                    stack.append(elem)\\n            return sum(\\n                stack[i]\\n                for i in range(0, len(stack), 2)\\n            )\\n        \\n        @cache\\n        def dp(left, right):\\n            if left + 1 == right:\\n                return {tokens[left]}\\n            \\n            result = set()\\n            for middle in range(left + 1, right, 2):\\n                op = tokens[middle]\\n                left_options = dp(left, middle)\\n                right_options = dp(middle + 1, right)\\n                for a in left_options:\\n                    for b in right_options:\\n                        current = op(a, b)\\n                        if current <= 1000:\\n                            result.add(current)\\n            return result\\n        \\n        correct_answer = calc(tokens)\\n        wrong_answers = dp(0, len(tokens))\\n\\n        result = 0\\n        for answer in answers:\\n            if answer == correct_answer:\\n                result += 5\\n            elif answer in wrong_answers:\\n                result += 2\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091238,
                "title": "java-clean",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    HashSet<Integer>[][] dp;\\n\\n    public int scoreOfStudents(String s, int[] answers) {\\n        int correct = evaluateExp(s);\\n        dp = new HashSet[s.length()][s.length()];\\n        HashSet<Integer> set = dfs(0, s.length()-1, s);\\n        int res = 0;\\n        for (int a : answers) {\\n            res += ( (a==correct) ? 5 : set.contains(a) ? 2 : 0 );\\n        }\\n        return res;\\n    }\\n\\n    public HashSet<Integer> dfs(int l, int r, String s) {\\n        if (dp[l][r] != null) {\\n            return dp[l][r];\\n        }\\n\\n        dp[l][r] = new HashSet<>();\\n\\n        if (l == r) {\\n            dp[l][r].add(s.charAt(l)-\\'0\\');\\n            return dp[l][r];\\n        }\\n\\n        for (int i = l+1; i < r; i += 2) {\\n            for (int k : dfs(l, i-1, s)) {\\n                for (int m : dfs(i+1, r, s)) {\\n                    int n = (s.charAt(i) == \\'+\\') ? k+m : k*m;\\n                    if (n <= 1000) {\\n                        dp[l][r].add(n);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[l][r];\\n    }\\n\\n    public int evaluateExp(String s) {\\n        int correct = 0;\\n        int prev = 0;\\n        char op = \\'+\\';\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'+\\' || s.charAt(i) == \\'*\\') {\\n                op = s.charAt(i);\\n                continue;\\n            }\\n            int current = s.charAt(i)-\\'0\\';\\n            if (op == \\'+\\') {\\n                correct += prev;\\n                prev = current;\\n            } else {\\n                prev *= current;\\n            }\\n        }\\n        correct += prev;\\n        return correct;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    HashSet<Integer>[][] dp;\\n\\n    public int scoreOfStudents(String s, int[] answers) {\\n        int correct = evaluateExp(s);\\n        dp = new HashSet[s.length()][s.length()];\\n        HashSet<Integer> set = dfs(0, s.length()-1, s);\\n        int res = 0;\\n        for (int a : answers) {\\n            res += ( (a==correct) ? 5 : set.contains(a) ? 2 : 0 );\\n        }\\n        return res;\\n    }\\n\\n    public HashSet<Integer> dfs(int l, int r, String s) {\\n        if (dp[l][r] != null) {\\n            return dp[l][r];\\n        }\\n\\n        dp[l][r] = new HashSet<>();\\n\\n        if (l == r) {\\n            dp[l][r].add(s.charAt(l)-\\'0\\');\\n            return dp[l][r];\\n        }\\n\\n        for (int i = l+1; i < r; i += 2) {\\n            for (int k : dfs(l, i-1, s)) {\\n                for (int m : dfs(i+1, r, s)) {\\n                    int n = (s.charAt(i) == \\'+\\') ? k+m : k*m;\\n                    if (n <= 1000) {\\n                        dp[l][r].add(n);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[l][r];\\n    }\\n\\n    public int evaluateExp(String s) {\\n        int correct = 0;\\n        int prev = 0;\\n        char op = \\'+\\';\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'+\\' || s.charAt(i) == \\'*\\') {\\n                op = s.charAt(i);\\n                continue;\\n            }\\n            int current = s.charAt(i)-\\'0\\';\\n            if (op == \\'+\\') {\\n                correct += prev;\\n                prev = current;\\n            } else {\\n                prev *= current;\\n            }\\n        }\\n        correct += prev;\\n        return correct;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003051,
                "title": "mcm-matrix-chain-multiplication-the-idea-is-similar-to-312-burst-balloons-c-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMCM(MATRIX CHAIN MULTIPLICATION)||The idea is similar to 312. Burst Balloons\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe provided C++ code implements an expression evaluation and scoring system for mathematical expressions. It uses memoization to optimize recursive calculations. The solve function evaluates the given expression, and the help function recursively computes possible results by placing parentheses at different positions. Memoization is employed to store and reuse the results of subproblems, improving efficiency. The code calculates a real result for the expression and compares it to student answers. It assigns scores based on matching and non-matching student answers, following specific scoring rules. The code returns the total score for the students\\' answers. This approach efficiently evaluates expressions and scores students based on their answer\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity:\\n\\nExpression Evaluation (solve function): The expression is evaluated using a single pass through the input string, which takes O(N) time, where N is the length of the input string.\\n\\nRecursive Evaluation (help function): The recursive evaluation explores all possible combinations of placing parentheses in the expression. In the worst case, it considers all possible pairs of operands for addition and multiplication, leading to a time complexity of O(2^(N/2)), where N is the length of the input string.\\n\\nIterating Through Student Answers: The code iterates through the student answers once, which takes O(K) time, where K is the number of student answers.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n the space complexity is dominated by the memoization cache, which is\\n O(N^2), but the actual space usage may be less due to memoization of overlapping subproblems.\\n# Code\\n```\\n#include <iostream>\\n#include <vector>\\n#include <string>\\n#include <unordered_set>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n unordered_map<string, unordered_set<int>> cache;\\nint solve(string &s){\\n  stack<int>st;\\n  st.push((s[0]-\\'0\\'));\\n  for(int i=1;i<s.size();i++){\\n    if((s[i]-\\'0\\')>=0 &&(s[i]-\\'0\\')<=9 ){\\n      if(s[i-1]==\\'*\\'){\\n        int x=st.top();\\n        st.pop();\\n        st.push(x*(s[i]-\\'0\\'));\\n      }\\n      else{\\n        st.push((s[i]-\\'0\\'));\\n      }\\n    }\\n  }\\n  int sum=0;\\n  while(st.size()>0){\\n    sum=sum+st.top();\\n    st.pop();\\n  }\\n  return sum;\\n}\\n    unordered_set<int> help(int n, int i, int j, string s, vector<int>& sav) {\\n       // cout << \"help(\" << n << \", \" << i << \", \" << j << \")\" << endl;\\nstring key = to_string(i) + \"-\" + to_string(j); // Create a unique key for memoization\\n        if (cache.find(key) != cache.end()) {\\n            return cache[key]; // Return the cached result if available\\n        }\\n        unordered_set<int> save; // Define save inside the function\\n        if (i == j) {\\n          save.insert(s[j]-\\'0\\');\\n            return save;\\n        }\\n        for (int k = i + 1; k < j; k = k + 2) {\\n           \\n            unordered_set<int> left_equation = help(n, i, k-1 , s, sav);\\n            unordered_set<int> right_equation = help(n, k + 1, j, s, sav);\\n          char x = s[k];\\n            if (x == \\'+\\') {\\n                for (auto& left : left_equation) {\\n                    for (auto& right : right_equation) {\\n                      if(1000>=left+right){\\n                        int add = left + right;\\n                      \\n                        save.insert(add);\\n                      }\\n                    }\\n                }\\n            } else {  // Multiply\\n                for (auto& left : left_equation) {\\n                    for (auto& right : right_equation) {\\n                       if(left*right<=1000){\\n                        int mul = left * right;\\n                         \\n                        save.insert(mul);\\n                          }\\n                    }\\n                }\\n            }\\n        }\\n         cache[key] = save;\\n        return save; // Return the updated save set\\n    }\\n\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n      auto real=solve(s);\\n        vector<int> sav;\\n        unordered_set<int> ans = help(s.size(), 0, s.size() - 1, s, sav);\\n\\n        cout << \"Elements in ans set: \";\\n        map<int,int>mp;\\n        // for (auto it = ans.begin(); it != ans.end(); ++it) {\\n        //     cout << *it << \" \";\\n        // }\\n        for(int i=0;i<answers.size();i++){\\n          mp[answers[i]]++;\\n        }\\n        int out=0;\\n      for (auto it = ans.begin(); it != ans.end(); ++it) {\\n    auto found = mp.find(*it); // Check if *it exists in the map mp\\n    if (found != mp.end()) {\\n        if (*it != real) {\\n            out += found->second * 2; // Use the value from the map\\n        } else {\\n            out += found->second * 5; // Use the value from the map\\n        }\\n    }\\n}\\n\\n      \\n\\n        return out; // Change this to return the actual result\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "String",
                    "Dynamic Programming",
                    "Stack",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\n#include <iostream>\\n#include <vector>\\n#include <string>\\n#include <unordered_set>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n unordered_map<string, unordered_set<int>> cache;\\nint solve(string &s){\\n  stack<int>st;\\n  st.push((s[0]-\\'0\\'));\\n  for(int i=1;i<s.size();i++){\\n    if((s[i]-\\'0\\')>=0 &&(s[i]-\\'0\\')<=9 ){\\n      if(s[i-1]==\\'*\\'){\\n        int x=st.top();\\n        st.pop();\\n        st.push(x*(s[i]-\\'0\\'));\\n      }\\n      else{\\n        st.push((s[i]-\\'0\\'));\\n      }\\n    }\\n  }\\n  int sum=0;\\n  while(st.size()>0){\\n    sum=sum+st.top();\\n    st.pop();\\n  }\\n  return sum;\\n}\\n    unordered_set<int> help(int n, int i, int j, string s, vector<int>& sav) {\\n       // cout << \"help(\" << n << \", \" << i << \", \" << j << \")\" << endl;\\nstring key = to_string(i) + \"-\" + to_string(j); // Create a unique key for memoization\\n        if (cache.find(key) != cache.end()) {\\n            return cache[key]; // Return the cached result if available\\n        }\\n        unordered_set<int> save; // Define save inside the function\\n        if (i == j) {\\n          save.insert(s[j]-\\'0\\');\\n            return save;\\n        }\\n        for (int k = i + 1; k < j; k = k + 2) {\\n           \\n            unordered_set<int> left_equation = help(n, i, k-1 , s, sav);\\n            unordered_set<int> right_equation = help(n, k + 1, j, s, sav);\\n          char x = s[k];\\n            if (x == \\'+\\') {\\n                for (auto& left : left_equation) {\\n                    for (auto& right : right_equation) {\\n                      if(1000>=left+right){\\n                        int add = left + right;\\n                      \\n                        save.insert(add);\\n                      }\\n                    }\\n                }\\n            } else {  // Multiply\\n                for (auto& left : left_equation) {\\n                    for (auto& right : right_equation) {\\n                       if(left*right<=1000){\\n                        int mul = left * right;\\n                         \\n                        save.insert(mul);\\n                          }\\n                    }\\n                }\\n            }\\n        }\\n         cache[key] = save;\\n        return save; // Return the updated save set\\n    }\\n\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n      auto real=solve(s);\\n        vector<int> sav;\\n        unordered_set<int> ans = help(s.size(), 0, s.size() - 1, s, sav);\\n\\n        cout << \"Elements in ans set: \";\\n        map<int,int>mp;\\n        // for (auto it = ans.begin(); it != ans.end(); ++it) {\\n        //     cout << *it << \" \";\\n        // }\\n        for(int i=0;i<answers.size();i++){\\n          mp[answers[i]]++;\\n        }\\n        int out=0;\\n      for (auto it = ans.begin(); it != ans.end(); ++it) {\\n    auto found = mp.find(*it); // Check if *it exists in the map mp\\n    if (found != mp.end()) {\\n        if (*it != real) {\\n            out += found->second * 2; // Use the value from the map\\n        } else {\\n            out += found->second * 5; // Use the value from the map\\n        }\\n    }\\n}\\n\\n      \\n\\n        return out; // Change this to return the actual result\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3923523,
                "title": "short-dp-in-python-faster-than-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing the top-down DP to generate all the possible outcomes in the range of `[0, 1000]`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGiven a substring of `s`, we enumerate all possible orders of operators (`+` and `*`), and collect all of their outcomes. The procedure can be speeded up by using memoization that is as simple as adding the `@cache` decorator.\\n\\n# Code\\n```\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        @cache\\n        def valid(l, r):\\n            if l == r - 1:\\n                return {int(s[l])}\\n            res = set()\\n            for i in range(l, r):\\n                if s[i] == \\'*\\':\\n                    res |= set(v * u for v, u in product(valid(l, i), valid(i+1, r)) if v * u <= 1000)        \\n                elif s[i] == \\'+\\':\\n                    res |= set(v + u for v, u in product(valid(l, i), valid(i+1, r)) if v + u <= 1000)\\n            return res\\n\\n        ans = 0\\n        golden = eval(s)\\n        partial_corrects = valid(0, len(s))\\n        for test in answers:\\n            if test == golden:\\n                ans += 5\\n            elif test in partial_corrects:\\n                ans += 2\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        @cache\\n        def valid(l, r):\\n            if l == r - 1:\\n                return {int(s[l])}\\n            res = set()\\n            for i in range(l, r):\\n                if s[i] == \\'*\\':\\n                    res |= set(v * u for v, u in product(valid(l, i), valid(i+1, r)) if v * u <= 1000)        \\n                elif s[i] == \\'+\\':\\n                    res |= set(v + u for v, u in product(valid(l, i), valid(i+1, r)) if v + u <= 1000)\\n            return res\\n\\n        ans = 0\\n        golden = eval(s)\\n        partial_corrects = valid(0, len(s))\\n        for test in answers:\\n            if test == golden:\\n                ans += 5\\n            elif test in partial_corrects:\\n                ans += 2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846836,
                "title": "my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport operator\\nfrom functools import cache\\nfrom itertools import product\\n\\n\\nclass Solution:\\n    def getOperation(self, op, lst1, lst2):\\n        \"\"\"\\n        This function applies the operation to all possible pairs\\n        of numbers in the two lists.\\n        \"\"\"\\n        ops = {\"+\": operator.add, \"*\": operator.mul}  # Operation mapping\\n        return {\\n            result for a, b in product(lst1, lst2) if (result := ops[op](a, b)) <= 1000\\n        }\\n\\n    @cache\\n    def getResults(self, s, start, end):\\n        \"\"\"\\n        This function gets all possible results of the subexpression denoted by the interval [start, end].\\n        It uses recursion and dynamic programming for better efficiency.\\n        \"\"\"\\n        # Base case: if start equals end, it\\'s just a single number\\n        if start == end:\\n            return {int(s[start])}\\n\\n        # Get all possible results\\n        results = set()\\n        for i in range(\\n            start + 1, end, 2\\n        ):  # Choose every possible operator as the final operator\\n            # Use the chosen operator to split the expression into two parts\\n            left_results = self.getResults(s, start, i - 1)\\n            right_results = self.getResults(s, i + 1, end)\\n            # Combine the results of the two parts\\n            results |= self.getOperation(s[i], left_results, right_results)\\n        return results\\n\\n    def scoreOfStudents(self, s: str, answers: list[int]) -> int:\\n        \"\"\"\\n        This function calculates total score answers of students.\\n        \"\"\"\\n        # Correct answer\\n        correct_answer = eval(s)\\n\\n        # All possible results\\n        all_possible_results = self.getResults(s, 0, len(s) - 1)\\n\\n        # Score each student\\'s answer\\n        total_score = 0\\n        for answer in answers:\\n            if answer == correct_answer:\\n                total_score += 5  # 5 points for correct answer\\n            elif answer in all_possible_results:\\n                total_score += 2  # 2 points for valid but incorrect answer\\n\\n        return total_score\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport operator\\nfrom functools import cache\\nfrom itertools import product\\n\\n\\nclass Solution:\\n    def getOperation(self, op, lst1, lst2):\\n        \"\"\"\\n        This function applies the operation to all possible pairs\\n        of numbers in the two lists.\\n        \"\"\"\\n        ops = {\"+\": operator.add, \"*\": operator.mul}  # Operation mapping\\n        return {\\n            result for a, b in product(lst1, lst2) if (result := ops[op](a, b)) <= 1000\\n        }\\n\\n    @cache\\n    def getResults(self, s, start, end):\\n        \"\"\"\\n        This function gets all possible results of the subexpression denoted by the interval [start, end].\\n        It uses recursion and dynamic programming for better efficiency.\\n        \"\"\"\\n        # Base case: if start equals end, it\\'s just a single number\\n        if start == end:\\n            return {int(s[start])}\\n\\n        # Get all possible results\\n        results = set()\\n        for i in range(\\n            start + 1, end, 2\\n        ):  # Choose every possible operator as the final operator\\n            # Use the chosen operator to split the expression into two parts\\n            left_results = self.getResults(s, start, i - 1)\\n            right_results = self.getResults(s, i + 1, end)\\n            # Combine the results of the two parts\\n            results |= self.getOperation(s[i], left_results, right_results)\\n        return results\\n\\n    def scoreOfStudents(self, s: str, answers: list[int]) -> int:\\n        \"\"\"\\n        This function calculates total score answers of students.\\n        \"\"\"\\n        # Correct answer\\n        correct_answer = eval(s)\\n\\n        # All possible results\\n        all_possible_results = self.getResults(s, 0, len(s) - 1)\\n\\n        # Score each student\\'s answer\\n        total_score = 0\\n        for answer in answers:\\n            if answer == correct_answer:\\n                total_score += 5  # 5 points for correct answer\\n            elif answer in all_possible_results:\\n                total_score += 2  # 2 points for valid but incorrect answer\\n\\n        return total_score\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792385,
                "title": "top-down-dp-short-clean",
                "content": "# Intuition\\nSo main challenge is to calculate all possible outcomes (e.g. any valid `(...)` expression). So let\\'s decompose what does that mean\\nLet `f(l,r)` be the set of all possible outcomes of `s[l:r]` (assuming it stars and ends withs a digit). Then all possibilities could be defined as trying to chose any operator inside and put it as \\'last order\\'. Let `s[l:r]==\\'<d_l><op_l+1>...<op_r-1><d_r>`, then we try to choose `<op_i>` from `[<op_l+1>,...,<op_r-1>]` and apply `<op_i>` to all possibilities from left substring `f(s:i-1)` and right substring `f(i+1:r)` (basically a cartesian product); and then combine all possibilities. \\n\\n# Approach\\nImplement the idea from intuition via top-down recursive function. Use `@cache`. Limit all possibile outcomes by `1000` as in statement, since so that possibilites don\\'t grow exponentially. Since all digits and operator are `1-char` string, things are really simplified here - each digit is on odd position, each operator is on even.\\nUse `eval` to get correct answer in scoring. \\n\\n# Complexity\\n- Time complexity: `O(len(s)^3 * C^2)` where `C=1000`\\n- Space complexity: `O(len(s)^2 * C)`\\n\\n# Code\\n```\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        n=len(s)\\n        ops={\\'+\\':operator.add, \\'*\\':operator.mul}\\n        def apply(op,lst1,lst2):\\n            return {y for a,b in product(lst1,lst2) if (y:=op(a,b)) <= 1000}\\n        @cache\\n        def f(l,r):\\n            if r==l: return {int(s[l])}\\n            return reduce(set.union, (apply(ops[s[i]], f(l,i-1), f(i+1,r)) for i in range(l+1,r,2)), set())\\n        ans=eval(s)\\n        return sum(5 if a==ans else 2*(a in f(0,n-1)) for a in answers)\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        n=len(s)\\n        ops={\\'+\\':operator.add, \\'*\\':operator.mul}\\n        def apply(op,lst1,lst2):\\n            return {y for a,b in product(lst1,lst2) if (y:=op(a,b)) <= 1000}\\n        @cache\\n        def f(l,r):\\n            if r==l: return {int(s[l])}\\n            return reduce(set.union, (apply(ops[s[i]], f(l,i-1), f(i+1,r)) for i in range(l+1,r,2)), set())\\n        ans=eval(s)\\n        return sum(5 if a==ans else 2*(a in f(0,n-1)) for a in answers)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772779,
                "title": "easy-to-understand-java-dp-solution-memoization",
                "content": "# Code\\n```\\nclass Solution {\\n    private Set[][] dp;\\n\\n    public int scoreOfStudents(String s, int[] answers) {\\n        int correctAns = evaluate(s);\\n        int len = s.length();\\n        dp = new Set[len][len];\\n        Set<Integer> values = solve(0, len - 1, s.toCharArray());\\n        int sum = 0;\\n        for(int val : answers) {\\n            if(val == correctAns) {\\n                sum += 5;\\n            }\\n            else if(values.contains(val)) {\\n                sum += 2;\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    private Set<Integer> solve(int i, int j, char[] str) {\\n        if(i == j) {\\n            return new HashSet<>(Arrays.asList(str[i] - \\'0\\'));\\n        }\\n        if(dp[i][j] != null) return dp[i][j];\\n        Set<Integer> ans = new HashSet<>();\\n        for(int sign = i + 1; sign <= j; sign += 2) {\\n            Set<Integer> leftVal = solve(i, sign - 1, str);\\n            Set<Integer> rightVal = solve(sign + 1, j, str);\\n            for(int lVal : leftVal) {\\n                for(int rVal : rightVal) {\\n                    int res = str[sign] == \\'*\\' ? lVal * rVal : lVal + rVal;\\n                    if(res <= 1000) {\\n                        ans.add(res);\\n                    }\\n                }   \\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n\\n    private int evaluate(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        char[] str = s.toCharArray();\\n        for(char ch : str) {\\n            if(!st.isEmpty() && Character.getNumericValue(\\'*\\') == st.peek()) {\\n                st.pop();\\n                int num1 = st.pop();\\n                int num2 = ch - \\'0\\';\\n                st.push(num1 * num2);\\n            }\\n            else if(Character.isDigit(ch)){\\n                st.push(ch - \\'0\\');\\n            }\\n            else if(ch == \\'*\\') {\\n                st.push(Character.getNumericValue(\\'*\\'));\\n            }\\n        }\\n        int sum = 0;\\n        while(!st.isEmpty()) {\\n            sum += st.pop();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private Set[][] dp;\\n\\n    public int scoreOfStudents(String s, int[] answers) {\\n        int correctAns = evaluate(s);\\n        int len = s.length();\\n        dp = new Set[len][len];\\n        Set<Integer> values = solve(0, len - 1, s.toCharArray());\\n        int sum = 0;\\n        for(int val : answers) {\\n            if(val == correctAns) {\\n                sum += 5;\\n            }\\n            else if(values.contains(val)) {\\n                sum += 2;\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    private Set<Integer> solve(int i, int j, char[] str) {\\n        if(i == j) {\\n            return new HashSet<>(Arrays.asList(str[i] - \\'0\\'));\\n        }\\n        if(dp[i][j] != null) return dp[i][j];\\n        Set<Integer> ans = new HashSet<>();\\n        for(int sign = i + 1; sign <= j; sign += 2) {\\n            Set<Integer> leftVal = solve(i, sign - 1, str);\\n            Set<Integer> rightVal = solve(sign + 1, j, str);\\n            for(int lVal : leftVal) {\\n                for(int rVal : rightVal) {\\n                    int res = str[sign] == \\'*\\' ? lVal * rVal : lVal + rVal;\\n                    if(res <= 1000) {\\n                        ans.add(res);\\n                    }\\n                }   \\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n\\n    private int evaluate(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        char[] str = s.toCharArray();\\n        for(char ch : str) {\\n            if(!st.isEmpty() && Character.getNumericValue(\\'*\\') == st.peek()) {\\n                st.pop();\\n                int num1 = st.pop();\\n                int num2 = ch - \\'0\\';\\n                st.push(num1 * num2);\\n            }\\n            else if(Character.isDigit(ch)){\\n                st.push(ch - \\'0\\');\\n            }\\n            else if(ch == \\'*\\') {\\n                st.push(Character.getNumericValue(\\'*\\'));\\n            }\\n        }\\n        int sum = 0;\\n        while(!st.isEmpty()) {\\n            sum += st.pop();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443241,
                "title": "python-dp-start-end-max-value-optimization",
                "content": "```\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        mem=[[None for _ in range(len(s)+1)] for _ in range(len(s)+1)]\\n        mx=[max(answers)]\\n        def ev(si,j):\\n            if mem[si][j]!=None:return mem[si][j]\\n            if abs(si-j)==1:\\n                mem[si][j]=set([int(s[si])])\\n                return mem[si][j]\\n            mem[si][j]=set()\\n            for i in range(si,j):\\n                if s[i]==\"*\":\\n                    pr,aft=ev(si,i),ev(i+1,j)\\n                    for p in pr:\\n                        for a in aft:\\n                            if p*a>mx[0]:continue\\n                            mem[si][j].add(p*a)\\n                elif s[i]==\"+\":\\n                    pr,aft=ev(si,i),ev(i+1,j)\\n                    for p in pr:\\n                        for a in aft:mem[si][j].add(p+a)\\n            return mem[si][j]\\n        pts={}\\n        for v in ev(0,len(s)):pts[v]=2\\n        pts[eval(s)]=5\\n        s=0\\n        for x in answers:\\n            if x in pts:s+=pts[x]\\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        mem=[[None for _ in range(len(s)+1)] for _ in range(len(s)+1)]\\n        mx=[max(answers)]\\n        def ev(si,j):\\n            if mem[si][j]!=None:return mem[si][j]\\n            if abs(si-j)==1:\\n                mem[si][j]=set([int(s[si])])\\n                return mem[si][j]\\n            mem[si][j]=set()\\n            for i in range(si,j):\\n                if s[i]==\"*\":\\n                    pr,aft=ev(si,i),ev(i+1,j)\\n                    for p in pr:\\n                        for a in aft:\\n                            if p*a>mx[0]:continue\\n                            mem[si][j].add(p*a)\\n                elif s[i]==\"+\":\\n                    pr,aft=ev(si,i),ev(i+1,j)\\n                    for p in pr:\\n                        for a in aft:mem[si][j].add(p+a)\\n            return mem[si][j]\\n        pts={}\\n        for v in ev(0,len(s)):pts[v]=2\\n        pts[eval(s)]=5\\n        s=0\\n        for x in answers:\\n            if x in pts:s+=pts[x]\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405441,
                "title": "2804-ms-near-tle",
                "content": "```ruby\\ndef score_of_students e, q\\n    a, m, e = eval(e), {}, e.gsub(/\\\\d|\\\\D/).map do\\n        _1[/\\\\d/] ? _1.to_i : _1.to_sym\\n    end\\n    f = -> i, j do\\n        return [e[i]] if j - i == 1\\n        m[(i << 5) | j] ||= (i + 1...j).step(2).flat_map do | k |\\n            x, y, s = f.(i, k), f.(k + 1, j), e[k]\\n            x.product(y).map! { _1[0].send s, _1[1] }\\n        end .filter { _1 <= 1000 } .uniq\\n    end\\n    s = f.(0, e.size).to_set\\n    q.sum { _1 == a ? 5 : (s === _1 ? 2 : 0) }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef score_of_students e, q\\n    a, m, e = eval(e), {}, e.gsub(/\\\\d|\\\\D/).map do\\n        _1[/\\\\d/] ? _1.to_i : _1.to_sym\\n    end\\n    f = -> i, j do\\n        return [e[i]] if j - i == 1\\n        m[(i << 5) | j] ||= (i + 1...j).step(2).flat_map do | k |\\n            x, y, s = f.(i, k), f.(k + 1, j), e[k]\\n            x.product(y).map! { _1[0].send s, _1[1] }\\n        end .filter { _1 <= 1000 } .uniq\\n    end\\n    s = f.(0, e.size).to_set\\n    q.sum { _1 == a ? 5 : (s === _1 ? 2 : 0) }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3246165,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn score_of_students(s: String, answers: Vec<i32>) -> i32 {\\n        use std::collections::HashSet;\\n        fn dfs(s: &[u8], st: usize, fin: usize, memo: &mut Vec<Vec<HashSet<i32>>>) {\\n            if memo[st][fin].is_empty() {\\n                let mut st_fin_set = HashSet::new();\\n                if fin - st == 1 {\\n                    st_fin_set.insert((s[st] - b\\'0\\') as i32);\\n                }\\n                for i in (st + 1..fin).step_by(2) {\\n                    dfs(s, st, i, memo);\\n                    dfs(s, i + 1, fin, memo);\\n                    for &n1 in &memo[st][i] {\\n                        for &n2 in &memo[i + 1][fin] {\\n                            let n = if s[i] == b\\'*\\' { n1 * n2 } else { n1 + n2 };\\n                            if n <= 1000 {\\n                                st_fin_set.insert(n);\\n                            }\\n                        }\\n                    }\\n                }\\n                memo[st][fin] = st_fin_set;\\n            }\\n        }\\n\\n        let s = s.as_bytes();\\n        let mut memo = vec![vec![HashSet::new(); 32]; 32];\\n        let mut correct = 0;\\n        let mut j = 0;\\n        let s_len = s.len();\\n        for i in (1..=s_len).step_by(2) {\\n            if i == s_len || s[i] == b\\'+\\' {\\n                let mut mul = 1;\\n                while j < i {\\n                    mul *= (s[j] - b\\'0\\') as i32;\\n                    j += 2;\\n                }\\n                correct += mul;\\n            }\\n        }\\n        dfs(s, 0, s_len, &mut memo);\\n        let f = |&ans: &i32| -> i32 {\\n            if ans == correct {\\n                5\\n            } else if memo[0][s_len].contains(&ans) {\\n                2\\n            } else {\\n                0\\n            }\\n        };\\n        answers.iter().map(f).sum()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn score_of_students(s: String, answers: Vec<i32>) -> i32 {\\n        use std::collections::HashSet;\\n        fn dfs(s: &[u8], st: usize, fin: usize, memo: &mut Vec<Vec<HashSet<i32>>>) {\\n            if memo[st][fin].is_empty() {\\n                let mut st_fin_set = HashSet::new();\\n                if fin - st == 1 {\\n                    st_fin_set.insert((s[st] - b\\'0\\') as i32);\\n                }\\n                for i in (st + 1..fin).step_by(2) {\\n                    dfs(s, st, i, memo);\\n                    dfs(s, i + 1, fin, memo);\\n                    for &n1 in &memo[st][i] {\\n                        for &n2 in &memo[i + 1][fin] {\\n                            let n = if s[i] == b\\'*\\' { n1 * n2 } else { n1 + n2 };\\n                            if n <= 1000 {\\n                                st_fin_set.insert(n);\\n                            }\\n                        }\\n                    }\\n                }\\n                memo[st][fin] = st_fin_set;\\n            }\\n        }\\n\\n        let s = s.as_bytes();\\n        let mut memo = vec![vec![HashSet::new(); 32]; 32];\\n        let mut correct = 0;\\n        let mut j = 0;\\n        let s_len = s.len();\\n        for i in (1..=s_len).step_by(2) {\\n            if i == s_len || s[i] == b\\'+\\' {\\n                let mut mul = 1;\\n                while j < i {\\n                    mul *= (s[j] - b\\'0\\') as i32;\\n                    j += 2;\\n                }\\n                correct += mul;\\n            }\\n        }\\n        dfs(s, 0, s_len, &mut memo);\\n        let f = |&ans: &i32| -> i32 {\\n            if ans == correct {\\n                5\\n            } else if memo[0][s_len].contains(&ans) {\\n                2\\n            } else {\\n                0\\n            }\\n        };\\n        answers.iter().map(f).sum()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2998710,
                "title": "simple-solution-in-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        int n = s.size();\\n        int realAns = getRealAns(s);\\n\\n        unordered_set<int> dp[n][n];\\n\\n        for(int i=0; i<n; ++i){\\n            if((i%2)==0) dp[i][i].insert(s[i]-\\'0\\');\\n        }\\n\\n        for(int len=3; len<=n; len+=2){\\n            for(int i=0; i<=n-len; ++i){\\n                int j = i + len - 1;\\n                for(int k=i+1; k<j; k+=2){\\n                    merge(s[k], dp[i][k-1], dp[k+1][j], dp[i][j]);\\n                }\\n            }\\n        }\\n\\n        return calculateScore(dp[0][n-1], realAns, answers);\\n    }\\n\\n    int calculateScore(unordered_set<int>& possibleAnswers, int realAns, vector<int>& answers){\\n        int score = 0;\\n        for(auto& i : answers){\\n            if(i == realAns) score += 5;\\n            else if(possibleAnswers.count(i)) score += 2;\\n        }\\n        return score;\\n    }\\n\\n    int getRealAns(string& s){\\n        int ans = 0;\\n        stack<int> st;\\n        stack<char> pending;\\n        for(auto& i : s){\\n            if(i==\\'+\\' or i == \\'*\\') pending.push(i);\\n            else{\\n                int val = i-\\'0\\';\\n                if(!pending.empty() and pending.top() == \\'*\\' and !st.empty()){\\n                    pending.pop();\\n                    int last = st.top(); st.pop();\\n                    st.push(last * val);\\n                }else{\\n                    st.push(val);\\n                }\\n            }\\n        }\\n        while(!st.empty()){ ans += st.top(); st.pop(); }\\n        return ans;\\n    }\\n\\n    void merge(char op, unordered_set<int>& left, unordered_set<int>& right, unordered_set<int>& current){\\n        auto apply = [&](int a, int b){\\n            int ans = 0;\\n            if(op == \\'*\\') ans = a * b;\\n            else ans = a + b;\\n            if(ans <= 1000) current.insert(ans);\\n        };\\n\\n        for(auto& l : left){\\n            for(auto& r : right){\\n                apply(l, r);\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        int n = s.size();\\n        int realAns = getRealAns(s);\\n\\n        unordered_set<int> dp[n][n];\\n\\n        for(int i=0; i<n; ++i){\\n            if((i%2)==0) dp[i][i].insert(s[i]-\\'0\\');\\n        }\\n\\n        for(int len=3; len<=n; len+=2){\\n            for(int i=0; i<=n-len; ++i){\\n                int j = i + len - 1;\\n                for(int k=i+1; k<j; k+=2){\\n                    merge(s[k], dp[i][k-1], dp[k+1][j], dp[i][j]);\\n                }\\n            }\\n        }\\n\\n        return calculateScore(dp[0][n-1], realAns, answers);\\n    }\\n\\n    int calculateScore(unordered_set<int>& possibleAnswers, int realAns, vector<int>& answers){\\n        int score = 0;\\n        for(auto& i : answers){\\n            if(i == realAns) score += 5;\\n            else if(possibleAnswers.count(i)) score += 2;\\n        }\\n        return score;\\n    }\\n\\n    int getRealAns(string& s){\\n        int ans = 0;\\n        stack<int> st;\\n        stack<char> pending;\\n        for(auto& i : s){\\n            if(i==\\'+\\' or i == \\'*\\') pending.push(i);\\n            else{\\n                int val = i-\\'0\\';\\n                if(!pending.empty() and pending.top() == \\'*\\' and !st.empty()){\\n                    pending.pop();\\n                    int last = st.top(); st.pop();\\n                    st.push(last * val);\\n                }else{\\n                    st.push(val);\\n                }\\n            }\\n        }\\n        while(!st.empty()){ ans += st.top(); st.pop(); }\\n        return ans;\\n    }\\n\\n    void merge(char op, unordered_set<int>& left, unordered_set<int>& right, unordered_set<int>& current){\\n        auto apply = [&](int a, int b){\\n            int ans = 0;\\n            if(op == \\'*\\') ans = a * b;\\n            else ans = a + b;\\n            if(ans <= 1000) current.insert(ans);\\n        };\\n\\n        for(auto& l : left){\\n            for(auto& r : right){\\n                apply(l, r);\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834469,
                "title": "swift",
                "content": "```\\nclass Solution {\\n    func scoreOfStudents(_ s: String, _ answers: [Int]) -> Int {\\n        let rightResult = parse(s)\\n        var cache: [String: Set<Int>] = [:]\\n        let cc = Array(s)\\n        let results = computeAll(cc, 0, cc.count - 1, answers.max() ?? 0, &cache)\\n        var score = 0\\n        for a in answers {\\n            if a == rightResult {\\n                score += 5\\n            } else if results.contains(a) {\\n                score += 2\\n            }\\n        }\\n        return score\\n    }\\n\\n    private func parse(_ s: String) -> Int {\\n        let v1 = Unicode.Scalar(\"0\").value\\n        var res = 0\\n        var num = 0\\n        var multResult = 1\\n        for c in s {\\n            switch c {\\n            case \"+\":\\n                res += num * multResult\\n                multResult = 1\\n                num = 0\\n            case \"*\":\\n                multResult *= num\\n                num = 0\\n            default: num = 10 * num + Int(c.unicodeScalars.first!.value - v1)\\n            }\\n        }\\n        return res + num * multResult\\n    }\\n\\n    private func computeAll(_ cc: [Character], _ from: Int, _ to: Int, _ limit: Int, _ cache: inout [String: Set<Int>]) -> Set<Int> {\\n        let v1 = Unicode.Scalar(\"0\").value\\n        let cacheKey = String(cc[from ... to])\\n        if let cc = cache[cacheKey] { return cc }\\n        var res = Set<Int>()\\n        var num = 0\\n        var hasOp = false\\n        for i in from ... to {\\n            switch cc[i] {\\n            case \"+\", \"*\":\\n                hasOp = true\\n                let s1 = computeAll(cc, from, i - 1, limit, &cache)\\n                let s2 = computeAll(cc, i + 1, to, limit, &cache)\\n                let isMult = cc[i] == \"*\"\\n                for n1 in s1 {\\n                    for n2 in s2 {\\n                        let r = isMult ? n1 * n2 : n1 + n2\\n                        if r <= limit { res.insert(r) }\\n                    }\\n                }\\n                if isMult && (s1.isEmpty || s2.isEmpty) && (s1.contains(0) || s2.contains(0)) {\\n                    res.insert(0)\\n                }\\n            default:\\n                if !hasOp {\\n                    num = 10 * num  + Int(cc[i].unicodeScalars.first!.value - v1)\\n                }\\n            }\\n        }\\n        if !hasOp { res.insert(num) }\\n        cache[cacheKey] = res\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func scoreOfStudents(_ s: String, _ answers: [Int]) -> Int {\\n        let rightResult = parse(s)\\n        var cache: [String: Set<Int>] = [:]\\n        let cc = Array(s)\\n        let results = computeAll(cc, 0, cc.count - 1, answers.max() ?? 0, &cache)\\n        var score = 0\\n        for a in answers {\\n            if a == rightResult {\\n                score += 5\\n            } else if results.contains(a) {\\n                score += 2\\n            }\\n        }\\n        return score\\n    }\\n\\n    private func parse(_ s: String) -> Int {\\n        let v1 = Unicode.Scalar(\"0\").value\\n        var res = 0\\n        var num = 0\\n        var multResult = 1\\n        for c in s {\\n            switch c {\\n            case \"+\":\\n                res += num * multResult\\n                multResult = 1\\n                num = 0\\n            case \"*\":\\n                multResult *= num\\n                num = 0\\n            default: num = 10 * num + Int(c.unicodeScalars.first!.value - v1)\\n            }\\n        }\\n        return res + num * multResult\\n    }\\n\\n    private func computeAll(_ cc: [Character], _ from: Int, _ to: Int, _ limit: Int, _ cache: inout [String: Set<Int>]) -> Set<Int> {\\n        let v1 = Unicode.Scalar(\"0\").value\\n        let cacheKey = String(cc[from ... to])\\n        if let cc = cache[cacheKey] { return cc }\\n        var res = Set<Int>()\\n        var num = 0\\n        var hasOp = false\\n        for i in from ... to {\\n            switch cc[i] {\\n            case \"+\", \"*\":\\n                hasOp = true\\n                let s1 = computeAll(cc, from, i - 1, limit, &cache)\\n                let s2 = computeAll(cc, i + 1, to, limit, &cache)\\n                let isMult = cc[i] == \"*\"\\n                for n1 in s1 {\\n                    for n2 in s2 {\\n                        let r = isMult ? n1 * n2 : n1 + n2\\n                        if r <= limit { res.insert(r) }\\n                    }\\n                }\\n                if isMult && (s1.isEmpty || s2.isEmpty) && (s1.contains(0) || s2.contains(0)) {\\n                    res.insert(0)\\n                }\\n            default:\\n                if !hasOp {\\n                    num = 10 * num  + Int(cc[i].unicodeScalars.first!.value - v1)\\n                }\\n            }\\n        }\\n        if !hasOp { res.insert(num) }\\n        cache[cacheKey] = res\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832150,
                "title": "simple-java-beats-84-with-hashset",
                "content": "# Intuition\\nIntution is taken from the problem https://leetcode.com/problems/different-ways-to-add-parentheses/description/\\nand https://leetcode.com/problems/basic-calculator-ii/\\n# Approach\\nWe must use HashSet and HashMap and memoization technique else we will get TLE\\n\\n\\n# Code\\n```\\nclass Solution {\\n    HashMap<String , HashSet<Integer>> cache =new HashMap<>();\\n    public int scoreOfStudents(String s, int[] ans) {\\n        int sign=1;\\n        int i=0;\\n        Stack<Integer>st=new Stack<>();\\n//correct answer of the equation\\n        while(i<s.length()){\\n            char ch=s.charAt(i);\\n            if(ch==\\'+\\'||ch==\\'*\\'){\\n                sign=ch==\\'+\\'?1:-1;\\n                i++;\\n            }\\n            else if( Character.isDigit(ch)){\\n                int num=0;\\n                while(i<s.length() && Character.isDigit(s.charAt(i))){\\n                    num=num*10+s.charAt(i)-\\'0\\';\\n                    i++;\\n                }\\n                if(sign==1)\\n                    st.add(num);\\n                else\\n                    st.add(st.pop()*num);\\n            }\\n        }\\n        int x=0;\\n        while(st.size()>0)\\n            x+=st.pop();\\n    HashSet<Integer>d=recursion(s);//trying to generate all possible answers by placing bractes at different positions\\n   d.remove(x);\\n    int res=0;\\n        for(int z:ans){\\n            if(z==x)\\n                res+=5;\\n            else if(d.contains(z))//set of wrong answers\\n                res+=2;\\n        }\\n        return res;\\n\\n\\n    }\\n//Mehtod to generate all wrong answers\\n    HashSet<Integer> recursion(String a){\\n        if(cache.containsKey(a))//memoization\\n            return cache.get(a);\\n        HashSet<Integer>ans=new HashSet<>();\\n        for(int i=0;i<a.length();i++){\\n            char ch=a.charAt(i);\\n            if(ch==\\'+\\'||ch==\\'*\\'){//once we encounter a sign\\n                HashSet<Integer> s1=recursion(a.substring(0,i));\\n                //we get the number b4 it\\n               HashSet<Integer> s2=recursion(a.substring(i+1));\\n                //and the numbers after it and do recursion on each of them\\n              for(int a1:s1){\\n                  for(int a2:s2)\\n                    {\\n                       \\n                        if(ch==\\'+\\'){\\n                            if(a1+a2>1000)continue;//optimization\\n                            ans.add(a1+a2);\\n                        }\\n                        else{\\n                            if(a1*a2>1000)continue;//optimization\\n                            ans.add(a1*a2);\\n                        }\\n                    }\\n                }\\n\\n            }\\n           \\n        }\\n         if(ans.size()==0 && a.length()<=1)\\n                ans.add(Integer.parseInt(a));\\n           cache.put(a,ans);\\n           return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<String , HashSet<Integer>> cache =new HashMap<>();\\n    public int scoreOfStudents(String s, int[] ans) {\\n        int sign=1;\\n        int i=0;\\n        Stack<Integer>st=new Stack<>();\\n//correct answer of the equation\\n        while(i<s.length()){\\n            char ch=s.charAt(i);\\n            if(ch==\\'+\\'||ch==\\'*\\'){\\n                sign=ch==\\'+\\'?1:-1;\\n                i++;\\n            }\\n            else if( Character.isDigit(ch)){\\n                int num=0;\\n                while(i<s.length() && Character.isDigit(s.charAt(i))){\\n                    num=num*10+s.charAt(i)-\\'0\\';\\n                    i++;\\n                }\\n                if(sign==1)\\n                    st.add(num);\\n                else\\n                    st.add(st.pop()*num);\\n            }\\n        }\\n        int x=0;\\n        while(st.size()>0)\\n            x+=st.pop();\\n    HashSet<Integer>d=recursion(s);//trying to generate all possible answers by placing bractes at different positions\\n   d.remove(x);\\n    int res=0;\\n        for(int z:ans){\\n            if(z==x)\\n                res+=5;\\n            else if(d.contains(z))//set of wrong answers\\n                res+=2;\\n        }\\n        return res;\\n\\n\\n    }\\n//Mehtod to generate all wrong answers\\n    HashSet<Integer> recursion(String a){\\n        if(cache.containsKey(a))//memoization\\n            return cache.get(a);\\n        HashSet<Integer>ans=new HashSet<>();\\n        for(int i=0;i<a.length();i++){\\n            char ch=a.charAt(i);\\n            if(ch==\\'+\\'||ch==\\'*\\'){//once we encounter a sign\\n                HashSet<Integer> s1=recursion(a.substring(0,i));\\n                //we get the number b4 it\\n               HashSet<Integer> s2=recursion(a.substring(i+1));\\n                //and the numbers after it and do recursion on each of them\\n              for(int a1:s1){\\n                  for(int a2:s2)\\n                    {\\n                       \\n                        if(ch==\\'+\\'){\\n                            if(a1+a2>1000)continue;//optimization\\n                            ans.add(a1+a2);\\n                        }\\n                        else{\\n                            if(a1*a2>1000)continue;//optimization\\n                            ans.add(a1*a2);\\n                        }\\n                    }\\n                }\\n\\n            }\\n           \\n        }\\n         if(ans.size()==0 && a.length()<=1)\\n                ans.add(Integer.parseInt(a));\\n           cache.put(a,ans);\\n           return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816330,
                "title": "c-dp-beats-98-25",
                "content": "# Intuition\\nFor a string of length n, we have $$n/2 + 1$$ numbers and n/2 operators. Let\\'s say we have 5 numbers. The goal is to get f(0, 4). The base case is f(x, x). Then we can push the wave from the diagonal to the top right corner.\\n# Approach\\nA dirty hack is to use a boolean array and vector to mimic a unordered_set. Directly using the hashset is slower (beats 92.11%).\\n\\n# Complexity\\n- Time complexity:\\nO(n^3)\\n\\n- Space complexity:\\nO(n^3)\\n\\n# Code\\n```cpp\\nclass Solution {\\n public:\\n  int scoreOfStudents(string s, vector<int>& answers) {\\n    int n = s.length();\\n    int correct = calculate(s);\\n    vector<bool> possible(1001, false);\\n    int opn = n / 2;\\n    vector<vector<vector<int>>> cache(opn + 1, vector<vector<int>>(opn + 1));\\n    vector<char> ops;\\n    for (int i = 1; i < n; i += 2) {\\n      ops.push_back(s[i]);\\n    }\\n    for (int i = 0; i <= opn; i++) {\\n      cache[i][i].push_back(s[i * 2] - \\'0\\');\\n    }\\n\\n    for (int i = 1; i <= opn; i++) {\\n      for (int low = 0, high = i; high <= opn; low++, high++) {\\n        fill(possible.begin(), possible.end(), false);\\n        for (int k = low; k < high; k++) {\\n          char op = ops[k];\\n          auto& leftvec = cache[low][k];\\n          auto& rightvec = cache[k + 1][high];\\n          for (int a : leftvec) {\\n            for (int b : rightvec) {\\n              int t = calculate(a, b, op);\\n              if (t <= 1000) {\\n                possible[t] = true;\\n              }\\n            }\\n          }\\n        }\\n        for (int a = 0; a <= 1000; a++) {\\n          if (possible[a]) {\\n            cache[low][high].push_back(a);\\n          }\\n        }\\n      }\\n    }\\n\\n    auto& possibleSolutions = cache.front().back();\\n    fill(possible.begin(), possible.end(), false);\\n    for (int x : possibleSolutions) {\\n      possible[x] = true;\\n    }\\n    int result = 0;\\n    for (int& x : answers) {\\n      if (x == correct) {\\n        result += 5;\\n      } else if (possible[x]) {\\n        result += 2;\\n      }\\n    }\\n    return result;\\n  }\\n\\n private:\\n  int calculate(string& s) {\\n    int result = 0;\\n    int prev = 0;\\n    for (int i = 0; i < s.length(); i++) {\\n      if (s[i] == \\'*\\') {\\n        i++;\\n        prev *= (s[i] - \\'0\\');\\n      } else if (s[i] == \\'+\\') {\\n        result += prev;\\n      } else {\\n        prev = s[i] - \\'0\\';\\n      }\\n    }\\n    result += prev;\\n    return result;\\n  }\\n\\n  int calculate(int left, int right, char op) {\\n    return op == \\'+\\' ? (left + right) : (left * right);\\n  }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\n public:\\n  int scoreOfStudents(string s, vector<int>& answers) {\\n    int n = s.length();\\n    int correct = calculate(s);\\n    vector<bool> possible(1001, false);\\n    int opn = n / 2;\\n    vector<vector<vector<int>>> cache(opn + 1, vector<vector<int>>(opn + 1));\\n    vector<char> ops;\\n    for (int i = 1; i < n; i += 2) {\\n      ops.push_back(s[i]);\\n    }\\n    for (int i = 0; i <= opn; i++) {\\n      cache[i][i].push_back(s[i * 2] - \\'0\\');\\n    }\\n\\n    for (int i = 1; i <= opn; i++) {\\n      for (int low = 0, high = i; high <= opn; low++, high++) {\\n        fill(possible.begin(), possible.end(), false);\\n        for (int k = low; k < high; k++) {\\n          char op = ops[k];\\n          auto& leftvec = cache[low][k];\\n          auto& rightvec = cache[k + 1][high];\\n          for (int a : leftvec) {\\n            for (int b : rightvec) {\\n              int t = calculate(a, b, op);\\n              if (t <= 1000) {\\n                possible[t] = true;\\n              }\\n            }\\n          }\\n        }\\n        for (int a = 0; a <= 1000; a++) {\\n          if (possible[a]) {\\n            cache[low][high].push_back(a);\\n          }\\n        }\\n      }\\n    }\\n\\n    auto& possibleSolutions = cache.front().back();\\n    fill(possible.begin(), possible.end(), false);\\n    for (int x : possibleSolutions) {\\n      possible[x] = true;\\n    }\\n    int result = 0;\\n    for (int& x : answers) {\\n      if (x == correct) {\\n        result += 5;\\n      } else if (possible[x]) {\\n        result += 2;\\n      }\\n    }\\n    return result;\\n  }\\n\\n private:\\n  int calculate(string& s) {\\n    int result = 0;\\n    int prev = 0;\\n    for (int i = 0; i < s.length(); i++) {\\n      if (s[i] == \\'*\\') {\\n        i++;\\n        prev *= (s[i] - \\'0\\');\\n      } else if (s[i] == \\'+\\') {\\n        result += prev;\\n      } else {\\n        prev = s[i] - \\'0\\';\\n      }\\n    }\\n    result += prev;\\n    return result;\\n  }\\n\\n  int calculate(int left, int right, char op) {\\n    return op == \\'+\\' ? (left + right) : (left * right);\\n  }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700509,
                "title": "python-top-down-dp-use-eval-to-get-correct-answer",
                "content": "```\\nfrom functools import lru_cache\\nfrom itertools import product\\n\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        vals, ops = [], []\\n        for c in s:\\n            if c == \\'*\\' or c == \\'+\\': ops.append(c)\\n            else: vals.append(int(c))\\n        @lru_cache(None)\\n        def dp(left, right):\\n            if left == right: return {vals[left]}\\n            ret = set()\\n            for i in range(left, right):\\n                lv, rv = dp(left, i), dp(i + 1, right)\\n                if ops[i] == \\'+\\': ret |= {l + r for l, r in product(lv, rv) if l + r <= 1000}\\n                else: ret |= {l * r for l, r in product(lv, rv) if l * r <= 1000}\\n            return ret\\n        correct, wrong = eval(s), dp(0, len(vals) - 1)\\n        scores = 0\\n        for v in answers:\\n            if v == correct: scores += 5\\n            elif v in wrong: scores += 2\\n        return scores\\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\nfrom itertools import product\\n\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        vals, ops = [], []\\n        for c in s:\\n            if c == \\'*\\' or c == \\'+\\': ops.append(c)\\n            else: vals.append(int(c))\\n        @lru_cache(None)\\n        def dp(left, right):\\n            if left == right: return {vals[left]}\\n            ret = set()\\n            for i in range(left, right):\\n                lv, rv = dp(left, i), dp(i + 1, right)\\n                if ops[i] == \\'+\\': ret |= {l + r for l, r in product(lv, rv) if l + r <= 1000}\\n                else: ret |= {l * r for l, r in product(lv, rv) if l * r <= 1000}\\n            return ret\\n        correct, wrong = eval(s), dp(0, len(vals) - 1)\\n        scores = 0\\n        for v in answers:\\n            if v == correct: scores += 5\\n            elif v in wrong: scores += 2\\n        return scores\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677303,
                "title": "c-super-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int scoreOfStudents(string s, vector<int>& a) {\\n        int correct_ans = 0, N = s.size();\\n        for(int i = 0; i < N; i += 2) {\\n            int cur = s[i]-\\'0\\';\\n            while(i+1 < N && s[i+1] == \\'*\\') {\\n                cur *= s[i+2]-\\'0\\';\\n                i += 2;\\n            }\\n            correct_ans += cur;\\n        }\\n        unordered_set<int> mem[32][32]{};\\n\\n        auto helper = [&](auto && self, int l, int h) {\\n            if(mem[l][h].size() > 0) return;\\n            if(l == h) {\\n                mem[l][l].insert(s[l]-\\'0\\');\\n                return;\\n            }\\n\\n            for(int i = l; i <= h; i++) {\\n                if(s[i] == \\'*\\' || s[i] == \\'+\\') {\\n                    self(self, l, i-1);\\n                    self(self, i+1, h);\\n                    for(int x : mem[l][i-1]) {\\n                        for(int y : mem[i+1][h]) {\\n                            int res = s[i] == \\'*\\' ? (x*y) : (x+y);\\n                            if(res <= 1000) mem[l][h].insert(res);\\n                        }\\n                    }\\n                }\\n            }\\n        };\\n\\n        helper(helper, 0, N-1);\\n\\n        mem[0][N-1].erase(correct_ans);\\n        return 5*count_if(begin(a), end(a), [&](auto e){return e == correct_ans;}) + 2*count_if(begin(a), end(a), [&](auto e){return mem[0][N-1].find(e) != mem[0][N-1].end();});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfStudents(string s, vector<int>& a) {\\n        int correct_ans = 0, N = s.size();\\n        for(int i = 0; i < N; i += 2) {\\n            int cur = s[i]-\\'0\\';\\n            while(i+1 < N && s[i+1] == \\'*\\') {\\n                cur *= s[i+2]-\\'0\\';\\n                i += 2;\\n            }\\n            correct_ans += cur;\\n        }\\n        unordered_set<int> mem[32][32]{};\\n\\n        auto helper = [&](auto && self, int l, int h) {\\n            if(mem[l][h].size() > 0) return;\\n            if(l == h) {\\n                mem[l][l].insert(s[l]-\\'0\\');\\n                return;\\n            }\\n\\n            for(int i = l; i <= h; i++) {\\n                if(s[i] == \\'*\\' || s[i] == \\'+\\') {\\n                    self(self, l, i-1);\\n                    self(self, i+1, h);\\n                    for(int x : mem[l][i-1]) {\\n                        for(int y : mem[i+1][h]) {\\n                            int res = s[i] == \\'*\\' ? (x*y) : (x+y);\\n                            if(res <= 1000) mem[l][h].insert(res);\\n                        }\\n                    }\\n                }\\n            }\\n        };\\n\\n        helper(helper, 0, N-1);\\n\\n        mem[0][N-1].erase(correct_ans);\\n        return 5*count_if(begin(a), end(a), [&](auto e){return e == correct_ans;}) + 2*count_if(begin(a), end(a), [&](auto e){return mem[0][N-1].find(e) != mem[0][N-1].end();});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675698,
                "title": "python-solution-faster-97",
                "content": "\\tclass Solution:\\n\\t\\tdef scoreOfStudents(self, s: str, A: List[int]) -> int:\\n\\t\\t\\tc = collections.Counter(A)\\n\\t\\t\\tn = len(s) // 2 + 1\\n\\t\\t\\tres = [[set() for _ in range(n)] for j in range(n)]\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tres[i][i].add(int(s[2 * i]))\\n\\t\\t\\tfor dif in range(1, n):\\n\\t\\t\\t\\tfor start in range(n - dif):\\n\\t\\t\\t\\t\\tend = start + dif\\n\\t\\t\\t\\t\\tcurset = set()\\n\\t\\t\\t\\t\\tfor i in range(start * 2 + 1, end * 2, 2):\\n\\t\\t\\t\\t\\t\\tif s[i] == \"+\":\\n\\t\\t\\t\\t\\t\\t\\tfor a in res[start][i // 2]:\\n\\t\\t\\t\\t\\t\\t\\t\\tfor b in res[i//2 + 1][end]:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif a + b <= 1000:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcurset.add(a + b)\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tfor a in res[start][i // 2]:\\n\\t\\t\\t\\t\\t\\t\\t\\tfor b in res[i//2 + 1][end]:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif a * b <= 1000:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcurset.add(a * b)\\n\\t\\t\\t\\t\\tres[start][end] = curset\\n\\t\\t\\tans = 0\\n\\t\\t\\tcrt = eval(s)\\n\\t\\t\\tfor i in res[0][-1]:\\n\\t\\t\\t\\tif i in c:\\n\\t\\t\\t\\t\\tif i == crt:\\n\\t\\t\\t\\t\\t\\tans += 5 * c[i]\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tans += 2 * c[i]\\n\\t\\t\\treturn ans",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef scoreOfStudents(self, s: str, A: List[int]) -> int:\\n\\t\\t\\tc = collections.Counter(A)\\n\\t\\t\\tn = len(s) // 2 + 1\\n\\t\\t\\tres = [[set() for _ in range(n)] for j in range(n)]\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tres[i][i].add(int(s[2 * i]))\\n\\t\\t\\tfor dif in range(1, n):\\n\\t\\t\\t\\tfor start in range(n - dif):\\n\\t\\t\\t\\t\\tend = start + dif\\n\\t\\t\\t\\t\\tcurset = set()\\n\\t\\t\\t\\t\\tfor i in range(start * 2 + 1, end * 2, 2):\\n\\t\\t\\t\\t\\t\\tif s[i] == \"+\":\\n\\t\\t\\t\\t\\t\\t\\tfor a in res[start][i // 2]:\\n\\t\\t\\t\\t\\t\\t\\t\\tfor b in res[i//2 + 1][end]:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif a + b <= 1000:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcurset.add(a + b)\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tfor a in res[start][i // 2]:\\n\\t\\t\\t\\t\\t\\t\\t\\tfor b in res[i//2 + 1][end]:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif a * b <= 1000:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcurset.add(a * b)\\n\\t\\t\\t\\t\\tres[start][end] = curset\\n\\t\\t\\tans = 0\\n\\t\\t\\tcrt = eval(s)\\n\\t\\t\\tfor i in res[0][-1]:\\n\\t\\t\\t\\tif i in c:\\n\\t\\t\\t\\t\\tif i == crt:\\n\\t\\t\\t\\t\\t\\tans += 5 * c[i]\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tans += 2 * c[i]\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 2642323,
                "title": "c-accepted-all-test-cases-step-by-step",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void getReal(int &real, string &s, vector <int> &a, vector <int> &nums, vector <char> &op) {\\n        int n = s.size();\\n        for (int i = 0; i < n; i += 2) nums[i / 2] = s[i] - \\'0\\';\\n        int cur = nums[0];\\n        for (int i = 1; i < n; i += 2) {\\n            op.push_back(s[i]);\\n            if (s[i] == \\'+\\')  {\\n                real += cur;\\n                cur = nums[i / 2 + 1];\\n            }\\n            else\\n                cur *= nums[i / 2 + 1];\\n        }\\n        real += cur; \\n    }\\n    int scoreOfStudents(string s, vector<int>& a) {\\n        int real = 0;\\n        int n = s.size();\\n        int m = n / 2 + 1;\\n        vector <int> nums(m);\\n        vector <char> op;\\n        getReal(real, s, a, nums, op);\\n        vector <vector <unordered_set <int>>> dp(m, vector<unordered_set<int>>(m));\\n        for (int i = 0; i < m; i++)\\n            dp[i][i].insert(nums[i]);\\n        for (int i = 1; i < m; i++) {\\n            for (int j = i - 1; j >= 0; j--) {\\n                for (int k = j; k < i; k++) {\\n                    if (op[k] == \\'+\\') {\\n                        for (auto &x : dp[j][k])\\n                            for (auto &y : dp[k + 1][i])\\n                                if (x + y <= 1000) \\n                                    dp[j][i].insert(x + y);\\n                    }\\n                    else {\\n                        for (auto &x : dp[j][k])\\n                            for (auto &y : dp[k + 1][i])\\n                                if (x * y <= 1000) \\n                                    dp[j][i].insert(x * y);\\n                    }\\n                }\\n            }\\n        }\\n       \\n        int ret = 0;\\n        for (auto &x : a) {\\n            if (x == real) ret += 5;\\n            else if (dp[0][m - 1].find(x) != dp[0][m - 1].end())\\n                ret += 2;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void getReal(int &real, string &s, vector <int> &a, vector <int> &nums, vector <char> &op) {\\n        int n = s.size();\\n        for (int i = 0; i < n; i += 2) nums[i / 2] = s[i] - \\'0\\';\\n        int cur = nums[0];\\n        for (int i = 1; i < n; i += 2) {\\n            op.push_back(s[i]);\\n            if (s[i] == \\'+\\')  {\\n                real += cur;\\n                cur = nums[i / 2 + 1];\\n            }\\n            else\\n                cur *= nums[i / 2 + 1];\\n        }\\n        real += cur; \\n    }\\n    int scoreOfStudents(string s, vector<int>& a) {\\n        int real = 0;\\n        int n = s.size();\\n        int m = n / 2 + 1;\\n        vector <int> nums(m);\\n        vector <char> op;\\n        getReal(real, s, a, nums, op);\\n        vector <vector <unordered_set <int>>> dp(m, vector<unordered_set<int>>(m));\\n        for (int i = 0; i < m; i++)\\n            dp[i][i].insert(nums[i]);\\n        for (int i = 1; i < m; i++) {\\n            for (int j = i - 1; j >= 0; j--) {\\n                for (int k = j; k < i; k++) {\\n                    if (op[k] == \\'+\\') {\\n                        for (auto &x : dp[j][k])\\n                            for (auto &y : dp[k + 1][i])\\n                                if (x + y <= 1000) \\n                                    dp[j][i].insert(x + y);\\n                    }\\n                    else {\\n                        for (auto &x : dp[j][k])\\n                            for (auto &y : dp[k + 1][i])\\n                                if (x * y <= 1000) \\n                                    dp[j][i].insert(x * y);\\n                    }\\n                }\\n            }\\n        }\\n       \\n        int ret = 0;\\n        for (auto &x : a) {\\n            if (x == real) ret += 5;\\n            else if (dp[0][m - 1].find(x) != dp[0][m - 1].end())\\n                ret += 2;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427043,
                "title": "python-dfs-easy-to-understand",
                "content": "Idea: \\n(1) first use stack to get the correct ans;\\n(2) use dfs to get all the possible anses, similar to problem #241. Here we can iterate each operator and regard it as the last operator for the string evaluation, for the left and right parts, we do dfs.  Finally for each val a in left and each val b in right, we put all the vals in a hashmap.\\n\\n```\\ndef scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        s=list(s)\\n        n=len(s)\\n        st=[]\\n        i=0\\n        while i<n:\\n            c=s[i]\\n            if c==\\'*\\' and st:\\n                st[-1]=st[-1]*int(s[i+1])\\n                i+=2\\n            elif c==\\'+\\':\\n                i+=1\\n            else:\\n                st.append(int(c))\\n                i+=1\\n        correct=sum(st)\\n        ## all vals        \\n        m={}\\n        def dfs(st,ed):\\n            ## return the set of vals for exp[st,ed+1]\\n            idx=(st,ed)\\n            if idx in m:\\n                return m[idx]\\n            if 0==ed-st:\\n                m[idx]=set([int(s[st])])\\n                return m[idx]                \\n            if ed-st==2:\\n                if s[st+1]==\\'+\\':\\n                    m[idx]=set([int(s[st])+int(s[ed])])\\n                elif s[st+1]==\\'-\\':\\n                    m[idx]=set([int(s[st])-int(s[ed])])\\n                else:\\n                    m[idx]=set([int(s[st])*int(s[ed])])\\n                return m[idx]\\n            vals=set()\\n            for i in range(st+1,ed):\\n                c=s[i]\\n                if c not in \"+-*\":\\n                    continue\\n                left=dfs(st,i-1)\\n                right=dfs(i+1,ed)\\n                for a in left:\\n                    for b in right:\\n                        if c==\\'+\\' and 0<=a+b<=1000:\\n                            vals.add(a+b)\\n                        elif c==\"-\" and 0<=a-b<=1000:\\n                            vals.add(a-b)\\n                        elif c==\"*\" and 0<=a*b<=1000:\\n                            vals.add(a*b)\\n                m[idx]=vals\\n            return m[idx]\\n        \\n        dfs(0,n-1)   \\n        vals=m[(0,n-1)]\\n        if correct in vals:\\n            vals.remove(correct)\\n        res=0    \\n        for a in answers:\\n            if a ==correct:\\n                res+=5\\n            elif a in vals:\\n                res+=2\\n        return res",
                "solutionTags": [],
                "code": "Idea: \\n(1) first use stack to get the correct ans;\\n(2) use dfs to get all the possible anses, similar to problem #241. Here we can iterate each operator and regard it as the last operator for the string evaluation, for the left and right parts, we do dfs.  Finally for each val a in left and each val b in right, we put all the vals in a hashmap.\\n\\n```\\ndef scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        s=list(s)\\n        n=len(s)\\n        st=[]\\n        i=0\\n        while i<n:\\n            c=s[i]\\n            if c==\\'*\\' and st:\\n                st[-1]=st[-1]*int(s[i+1])\\n                i+=2\\n            elif c==\\'+\\':\\n                i+=1\\n            else:\\n                st.append(int(c))\\n                i+=1\\n        correct=sum(st)\\n        ## all vals        \\n        m={}\\n        def dfs(st,ed):\\n            ## return the set of vals for exp[st,ed+1]\\n            idx=(st,ed)\\n            if idx in m:\\n                return m[idx]\\n            if 0==ed-st:\\n                m[idx]=set([int(s[st])])\\n                return m[idx]                \\n            if ed-st==2:\\n                if s[st+1]==\\'+\\':\\n                    m[idx]=set([int(s[st])+int(s[ed])])\\n                elif s[st+1]==\\'-\\':\\n                    m[idx]=set([int(s[st])-int(s[ed])])\\n                else:\\n                    m[idx]=set([int(s[st])*int(s[ed])])\\n                return m[idx]\\n            vals=set()\\n            for i in range(st+1,ed):\\n                c=s[i]\\n                if c not in \"+-*\":\\n                    continue\\n                left=dfs(st,i-1)\\n                right=dfs(i+1,ed)\\n                for a in left:\\n                    for b in right:\\n                        if c==\\'+\\' and 0<=a+b<=1000:\\n                            vals.add(a+b)\\n                        elif c==\"-\" and 0<=a-b<=1000:\\n                            vals.add(a-b)\\n                        elif c==\"*\" and 0<=a*b<=1000:\\n                            vals.add(a*b)\\n                m[idx]=vals\\n            return m[idx]\\n        \\n        dfs(0,n-1)   \\n        vals=m[(0,n-1)]\\n        if correct in vals:\\n            vals.remove(correct)\\n        res=0    \\n        for a in answers:\\n            if a ==correct:\\n                res+=5\\n            elif a in vals:\\n                res+=2\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2413717,
                "title": "c-dp-simple-ish-clean-ish",
                "content": "This is a problem that\\'s easy to over think (which is exactly what I did until I sat down and wrote a bruteforce solution and added dp/memoisation).\\n\\nI hated that it was full of `s[i]-\\'0\\'` - and wondered if preprocessing the expression would still work? I believe `std::string` permits embeded `\\'\\\\0\\'`s and all the other special characters... and... Hey! it works!! Less ugly code!!\\n\\nHope this helps someone.\\n\\nAll the best!\\n\\n```\\nclass Solution {\\n    int eval(const string& s) {\\n        stack<int> stk; int tmp=\\'+\\';\\n        for (int i=0; i<s.size(); i++)\\n            if (s[i] > 9)\\n                tmp = s[i];\\n            else if (tmp == \\'*\\')\\n                stk.top() *= s[i];\\n            else\\n                stk.push(s[i]);\\n        tmp=0;\\n        while (stk.size()) {\\n            tmp += stk.top(); stk.pop();\\n        }\\n        return tmp;\\n    }\\n    unordered_set<int>& solve(const string& s,unordered_map<string,unordered_set<int>>& dp) {\\n        if (dp.count(s) == 0) {\\n            if (s.size() == 1)\\n                dp[s].insert(s[0]);\\n            else if (s.size() == 3)\\n                dp[s].insert(s[1]==\\'+\\' ? (s[0] + s[2]) : (s[0] * s[2]));\\n            else {\\n                for (int i=1; i<s.size(); i+=2) {\\n                    string lo=s.substr(0,i), hi=s.substr(i+1);\\n                    \\n                    unordered_set<int>& s1 = solve(lo,dp);\\n                    unordered_set<int>& s2 = solve(hi,dp);\\n                    \\n                    for (auto x : s1) {\\n                        for (auto y : s2) {\\n                            int val = s[i]==\\'+\\' ? (x + y) : (x * y);\\n                            if (val <= 1000)\\n                                dp[s].insert(val);\\n                        }\\n                    }\\n                }\\n            }   \\n        }\\n        return dp[s];\\n    }\\npublic:\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        for (auto& ch : s) { if (ch >=\\'0\\') ch -= \\'0\\'; }   // woo!! it works!! \\n        \\n        unordered_map<string,unordered_set<int>> dp;\\n        unordered_set<int>& maybe = solve(s,dp);\\n        \\n        int total=0, correct=eval(s);\\n        \\n        for (auto a : answers)\\n            if (a == correct)\\n                total += 5;\\n            else if (maybe.count(a))\\n                total += 2;\\n        \\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int eval(const string& s) {\\n        stack<int> stk; int tmp=\\'+\\';\\n        for (int i=0; i<s.size(); i++)\\n            if (s[i] > 9)\\n                tmp = s[i];\\n            else if (tmp == \\'*\\')\\n                stk.top() *= s[i];\\n            else\\n                stk.push(s[i]);\\n        tmp=0;\\n        while (stk.size()) {\\n            tmp += stk.top(); stk.pop();\\n        }\\n        return tmp;\\n    }\\n    unordered_set<int>& solve(const string& s,unordered_map<string,unordered_set<int>>& dp) {\\n        if (dp.count(s) == 0) {\\n            if (s.size() == 1)\\n                dp[s].insert(s[0]);\\n            else if (s.size() == 3)\\n                dp[s].insert(s[1]==\\'+\\' ? (s[0] + s[2]) : (s[0] * s[2]));\\n            else {\\n                for (int i=1; i<s.size(); i+=2) {\\n                    string lo=s.substr(0,i), hi=s.substr(i+1);\\n                    \\n                    unordered_set<int>& s1 = solve(lo,dp);\\n                    unordered_set<int>& s2 = solve(hi,dp);\\n                    \\n                    for (auto x : s1) {\\n                        for (auto y : s2) {\\n                            int val = s[i]==\\'+\\' ? (x + y) : (x * y);\\n                            if (val <= 1000)\\n                                dp[s].insert(val);\\n                        }\\n                    }\\n                }\\n            }   \\n        }\\n        return dp[s];\\n    }\\npublic:\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        for (auto& ch : s) { if (ch >=\\'0\\') ch -= \\'0\\'; }   // woo!! it works!! \\n        \\n        unordered_map<string,unordered_set<int>> dp;\\n        unordered_set<int>& maybe = solve(s,dp);\\n        \\n        int total=0, correct=eval(s);\\n        \\n        for (auto a : answers)\\n            if (a == correct)\\n                total += 5;\\n            else if (maybe.count(a))\\n                total += 2;\\n        \\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2350602,
                "title": "python-short-dp-solution-explanation-time-complexity-analysis",
                "content": "The question can be rephrased into finding all the possible results by adding arbitrary brackets to the string `s`. This is a well-known problem, just traverse from `i` to `j` if `k` is an operator, the set of results is that of operation applying for the products of `f(i,k-1)` and `f(k+1,j)`.\\n\\nTime complexy : \\nThere at most 15 numbers in the string s, so there is at most 16 holes to fill the brackets. There is no point to place a bracket  whose sides are in consecutives holes (adding a bracket around a number is useless), so each time, the number of holes is decreased at least by 2. Hence, we can place at most `16/2=8` brackets such that none of those is redundant. There is `2nCn / n+1` ways to distribute `n` brackets (Catalan number). There\\'s at most `15**2` distinct pairs `i, j`, in each pairs we need to traverse from `i` to `j`. So let;s `n` denotes the total numbers in `s` (`n <= 15` ), the total time complexity would be `(n^3 / 6 * nC(n/2) / (n/2+1))` ~ `10M operations` which is more than enough to pass all the test cases. \\n```python\\ndef scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        from operator import add, mul\\n        ops = {\\'+\\': add, \\'*\\': mul}\\n        @functools.lru_cache(None)\\n        def f(i, j):\\n            return {int(s[i])} if i == j else {ops[s[k]](x,y)  for k in range(i+1,j,2) for x in f(i,k-1) for y in f(k+1,j) if ops[s[k]](x,y) <= 1e3}\\n        res = eval(s)\\n        return sum(5 if i == res else (i in f(0, len(s)-1)) * 2 for i in answers)\\n```",
                "solutionTags": [],
                "code": "```python\\ndef scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        from operator import add, mul\\n        ops = {\\'+\\': add, \\'*\\': mul}\\n        @functools.lru_cache(None)\\n        def f(i, j):\\n            return {int(s[i])} if i == j else {ops[s[k]](x,y)  for k in range(i+1,j,2) for x in f(i,k-1) for y in f(k+1,j) if ops[s[k]](x,y) <= 1e3}\\n        res = eval(s)\\n        return sum(5 if i == res else (i in f(0, len(s)-1)) * 2 for i in answers)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2255513,
                "title": "concise-dp-solution-python",
                "content": "```\\nclass Solution:\\n  def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n    n = len(s) // 2 + 1\\n\\n    ans = 0\\n    func = {\\'+\\': operator.add, \\'*\\': operator.mul}\\n    dp = [[set() for j in range(n)] for _ in range(n)]\\n\\n    for i in range(n):\\n      dp[i][i].add(int(s[i * 2]))\\n\\n    for d in range(1, n):\\n      for i in range(n - d):\\n        j = i + d\\n        for k in range(i, j):\\n          op = s[k * 2 + 1]\\n          for a in dp[i][k]:\\n            for b in dp[k + 1][j]:\\n              res = func[op](a, b)\\n              if res <= 1000:\\n                dp[i][j].add(res)\\n\\n    correctAnswer = eval(s)\\n\\n    for answer, freq in Counter(answers).items():\\n      if answer == correctAnswer:\\n        ans += 5 * freq\\n      elif answer in dp[0][n - 1]:\\n        ans += 2 * freq\\n\\n    return ans\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n  def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n    n = len(s) // 2 + 1\\n\\n    ans = 0\\n    func = {\\'+\\': operator.add, \\'*\\': operator.mul}\\n    dp = [[set() for j in range(n)] for _ in range(n)]\\n\\n    for i in range(n):\\n      dp[i][i].add(int(s[i * 2]))\\n\\n    for d in range(1, n):\\n      for i in range(n - d):\\n        j = i + d\\n        for k in range(i, j):\\n          op = s[k * 2 + 1]\\n          for a in dp[i][k]:\\n            for b in dp[k + 1][j]:\\n              res = func[op](a, b)\\n              if res <= 1000:\\n                dp[i][j].add(res)\\n\\n    correctAnswer = eval(s)\\n\\n    for answer, freq in Counter(answers).items():\\n      if answer == correctAnswer:\\n        ans += 5 * freq\\n      elif answer in dp[0][n - 1]:\\n        ans += 2 * freq\\n\\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240811,
                "title": "stack-dp-bottom-up-stack-for-right-evaluation-and-dp-for-all-possible-answers",
                "content": "```\\nclass Solution {\\n    \\n    unordered_set<int> dp[32][32];\\n    \\n    int helper(string s){\\n       stack<int> stack;\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'*\\'){\\n                int temp = stack.top() * (s[i+1]-\\'0\\');\\n                stack.pop();\\n                stack.push(temp);\\n                i++;\\n            }else if(s[i]==\\'+\\'){\\n                \\n            }else if(s[i]>=\\'0\\' && s[i]<=\\'9\\'){\\n                stack.push(s[i]-\\'0\\');\\n            }\\n        }\\n        \\n        int sum = 0;\\n        while(!stack.empty()){\\n            sum += stack.top();\\n            stack.pop();\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    \\n    int solve(string s){\\n        \\n        int n = s.length();\\n        \\n        vector<int> nums;\\n        vector<int> operators;\\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i]!=\\'+\\' && s[i]!=\\'*\\')nums.push_back(s[i]-\\'0\\');\\n            else if(s[i] == \\'+\\')operators.push_back(1);\\n            else operators.push_back(2);\\n        }\\n        \\n        int m = nums.size();\\n        for(int i=0;i<m;i++)dp[i][i].insert(nums[i]);\\n        \\n        \\n        for(int l=1;l<m;l++){\\n            for(int i=0,j=l;j<m;j++,i++){\\n                for(int k=i;k<=j;k++){\\n                    for(int x:dp[i][k]){\\n                        for(int y: dp[k+1][j]){\\n                            int val = operators[k]==1 ? x+y : x*y;\\n                            if(val<=1000)dp[i][j].insert(val);\\n                        }\\n                    }\\n                }\\n            }\\n        }        \\n        return m;\\n    }\\n    \\n    \\npublic:\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        int right = helper(s);\\n        int m = solve(s);\\n        int count=0;\\n        \\n        unordered_set<int> possibleValues = dp[0][m-1];\\n\\n        for(int i=0;i<answers.size();i++){\\n            \\n            if(answers[i]==right)count+=5;\\n            else if(possibleValues.count(answers[i]))count+=2;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    unordered_set<int> dp[32][32];\\n    \\n    int helper(string s){\\n       stack<int> stack;\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'*\\'){\\n                int temp = stack.top() * (s[i+1]-\\'0\\');\\n                stack.pop();\\n                stack.push(temp);\\n                i++;\\n            }else if(s[i]==\\'+\\'){\\n                \\n            }else if(s[i]>=\\'0\\' && s[i]<=\\'9\\'){\\n                stack.push(s[i]-\\'0\\');\\n            }\\n        }\\n        \\n        int sum = 0;\\n        while(!stack.empty()){\\n            sum += stack.top();\\n            stack.pop();\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    \\n    int solve(string s){\\n        \\n        int n = s.length();\\n        \\n        vector<int> nums;\\n        vector<int> operators;\\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i]!=\\'+\\' && s[i]!=\\'*\\')nums.push_back(s[i]-\\'0\\');\\n            else if(s[i] == \\'+\\')operators.push_back(1);\\n            else operators.push_back(2);\\n        }\\n        \\n        int m = nums.size();\\n        for(int i=0;i<m;i++)dp[i][i].insert(nums[i]);\\n        \\n        \\n        for(int l=1;l<m;l++){\\n            for(int i=0,j=l;j<m;j++,i++){\\n                for(int k=i;k<=j;k++){\\n                    for(int x:dp[i][k]){\\n                        for(int y: dp[k+1][j]){\\n                            int val = operators[k]==1 ? x+y : x*y;\\n                            if(val<=1000)dp[i][j].insert(val);\\n                        }\\n                    }\\n                }\\n            }\\n        }        \\n        return m;\\n    }\\n    \\n    \\npublic:\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        int right = helper(s);\\n        int m = solve(s);\\n        int count=0;\\n        \\n        unordered_set<int> possibleValues = dp[0][m-1];\\n\\n        for(int i=0;i<answers.size();i++){\\n            \\n            if(answers[i]==right)count+=5;\\n            else if(possibleValues.count(answers[i]))count+=2;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014434,
                "title": "c-basic-calculator-different-ways-to-add-parenthesis",
                "content": "```cpp\\nclass Solution {\\n    int eval(int a, int b, char op) {\\n        if (op == \\'+\\') {\\n            return a + b;\\n        } else {\\n            return a * b;\\n        }\\n    }\\n    \\n    unordered_map<string_view, unordered_set<int>> mp;\\n    unordered_set<int> potential;\\n    \\n    unordered_set<int>& solve(string_view s) {\\n        if (auto it = mp.find(s); it != mp.end()) {\\n            return it->second;\\n        }\\n        \\n        bool res = true;\\n        int n = 0;\\n        unordered_set<int> ans;\\n        for (int i = 0; i < s.size(); i++) {\\n            char c = s[i];\\n            if (c >= \\'0\\' && c <= \\'9\\') {\\n                n = n * 10 + (c - \\'0\\');\\n            } else {\\n                n = 0;\\n                res = false;\\n                for (int l : solve(s.substr(0, i))) {\\n                    for (int r : solve(s.substr(i + 1))) {\\n                        int res2 = eval(l, r, c);\\n                        if (res2 <= 1000) {\\n                            ans.insert(res2);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if (res) {\\n            ans.insert(n);\\n        }\\n        return mp[s] = ans;\\n    }\\n    \\npublic:\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        int ans = 0, correct = 0;\\n        stack<int> ns, op;\\n        unordered_map<char, int> prec{\\n            {\\'+\\', 1},\\n            {\\'*\\', 2},\\n            {\\'(\\', 0}\\n        };\\n        int n = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            char c = s[i];\\n            if (c >= \\'0\\' && c <= \\'9\\') {\\n                n = n * 10 + (c - \\'0\\');\\n            } else if (c == \\'(\\') {\\n                op.push(c);\\n            } else if (c == \\')\\') {\\n                ns.push(n);\\n                while (op.top() != \\'(\\') {\\n                    int b = ns.top();\\n                    ns.pop();\\n                    int a = ns.top();\\n                    ns.pop();\\n                    ns.push(eval(a, b, op.top()));\\n                    op.pop();\\n                }\\n                op.pop();\\n                n = ns.top();\\n                ns.pop();\\n            } else {\\n                ns.push(n);\\n                n = 0;\\n                int p = prec[c];\\n                while (!op.empty() && prec[op.top()] >= p) {\\n                    int b = ns.top();\\n                    ns.pop();\\n                    int a = ns.top();\\n                    ns.pop();\\n                    ns.push(eval(a, b, op.top()));\\n                    op.pop();\\n                }\\n                op.push(c);\\n            }\\n        }\\n        ns.push(n);\\n        while (!op.empty()) {\\n            int b = ns.top();\\n            ns.pop();\\n            int a = ns.top();\\n            ns.pop();\\n            ns.push(eval(a, b, op.top()));\\n            op.pop();\\n        }\\n        correct = ns.top();\\n        \\n        string_view sv{s.data(), s.size()};\\n        solve(sv);\\n        for (int n2 : mp[sv]) {\\n            potential.insert(n2);\\n        }\\n        \\n        for (int n2 : answers) {\\n            if (n2 == correct) {\\n                ans += 5;\\n            } else if (potential.find(n2) != potential.end()) {\\n                ans += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\n    int eval(int a, int b, char op) {\\n        if (op == \\'+\\') {\\n            return a + b;\\n        } else {\\n            return a * b;\\n        }\\n    }\\n    \\n    unordered_map<string_view, unordered_set<int>> mp;\\n    unordered_set<int> potential;\\n    \\n    unordered_set<int>& solve(string_view s) {\\n        if (auto it = mp.find(s); it != mp.end()) {\\n            return it->second;\\n        }\\n        \\n        bool res = true;\\n        int n = 0;\\n        unordered_set<int> ans;\\n        for (int i = 0; i < s.size(); i++) {\\n            char c = s[i];\\n            if (c >= \\'0\\' && c <= \\'9\\') {\\n                n = n * 10 + (c - \\'0\\');\\n            } else {\\n                n = 0;\\n                res = false;\\n                for (int l : solve(s.substr(0, i))) {\\n                    for (int r : solve(s.substr(i + 1))) {\\n                        int res2 = eval(l, r, c);\\n                        if (res2 <= 1000) {\\n                            ans.insert(res2);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if (res) {\\n            ans.insert(n);\\n        }\\n        return mp[s] = ans;\\n    }\\n    \\npublic:\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        int ans = 0, correct = 0;\\n        stack<int> ns, op;\\n        unordered_map<char, int> prec{\\n            {\\'+\\', 1},\\n            {\\'*\\', 2},\\n            {\\'(\\', 0}\\n        };\\n        int n = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            char c = s[i];\\n            if (c >= \\'0\\' && c <= \\'9\\') {\\n                n = n * 10 + (c - \\'0\\');\\n            } else if (c == \\'(\\') {\\n                op.push(c);\\n            } else if (c == \\')\\') {\\n                ns.push(n);\\n                while (op.top() != \\'(\\') {\\n                    int b = ns.top();\\n                    ns.pop();\\n                    int a = ns.top();\\n                    ns.pop();\\n                    ns.push(eval(a, b, op.top()));\\n                    op.pop();\\n                }\\n                op.pop();\\n                n = ns.top();\\n                ns.pop();\\n            } else {\\n                ns.push(n);\\n                n = 0;\\n                int p = prec[c];\\n                while (!op.empty() && prec[op.top()] >= p) {\\n                    int b = ns.top();\\n                    ns.pop();\\n                    int a = ns.top();\\n                    ns.pop();\\n                    ns.push(eval(a, b, op.top()));\\n                    op.pop();\\n                }\\n                op.push(c);\\n            }\\n        }\\n        ns.push(n);\\n        while (!op.empty()) {\\n            int b = ns.top();\\n            ns.pop();\\n            int a = ns.top();\\n            ns.pop();\\n            ns.push(eval(a, b, op.top()));\\n            op.pop();\\n        }\\n        correct = ns.top();\\n        \\n        string_view sv{s.data(), s.size()};\\n        solve(sv);\\n        for (int n2 : mp[sv]) {\\n            potential.insert(n2);\\n        }\\n        \\n        for (int n2 : answers) {\\n            if (n2 == correct) {\\n                ans += 5;\\n            } else if (potential.find(n2) != potential.end()) {\\n                ans += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008325,
                "title": "python-simple-maths",
                "content": "\\n    def dfs(self, s):\\n        if s.isdigit():\\n            return {int(s)}\\n        \\n        if s in self.dict1:\\n            return self.dict1[s]\\n        \\n        res = set()\\n        \\n        for i in range(len(s)):\\n            if s[i] in [\"+\",\"*\"]:\\n                for left in self.dfs(s[:i]):\\n                    for right in self.dfs(s[i+1:]):\\n                        if s[i] == \"+\" and left + right <= 1000:\\n                            res.add(left+right)\\n                        if s[i] == \"*\" and left*right <= 1000:\\n                            res.add(left*right)\\n                            \\n        self.dict1[s] = res\\n        \\n        return res\\n    \\n    \\n    def scoreOfStudents(self, s, answers):\\n        self.dict1 = {}\\n        \\n        ans, val, total = self.dfs(s), eval(s), 0\\n        \\n        for i in answers:\\n            if i == val:\\n                total += 5\\n            elif i in ans:\\n                total += 2\\n                \\n        return total\\n",
                "solutionTags": [],
                "code": "\\n    def dfs(self, s):\\n        if s.isdigit():\\n            return {int(s)}\\n        \\n        if s in self.dict1:\\n            return self.dict1[s]\\n        \\n        res = set()\\n        \\n        for i in range(len(s)):\\n            if s[i] in [\"+\",\"*\"]:\\n                for left in self.dfs(s[:i]):\\n                    for right in self.dfs(s[i+1:]):\\n                        if s[i] == \"+\" and left + right <= 1000:\\n                            res.add(left+right)\\n                        if s[i] == \"*\" and left*right <= 1000:\\n                            res.add(left*right)\\n                            \\n        self.dict1[s] = res\\n        \\n        return res\\n    \\n    \\n    def scoreOfStudents(self, s, answers):\\n        self.dict1 = {}\\n        \\n        ans, val, total = self.dfs(s), eval(s), 0\\n        \\n        for i in answers:\\n            if i == val:\\n                total += 5\\n            elif i in ans:\\n                total += 2\\n                \\n        return total\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1983320,
                "title": "c-17-bottom-up-dp-in-2d",
                "content": "# DP in 2D, bottom-up.\\nThe incorrect evaluation orders of the expression includes all the differently-structured trees of these k ops and k+1 numbers.\\nLet f[i..j] represent the set of possible results of evaluating the sub-expression s[i..j],\\nthen  we have these cases:\\n*  a) len1: f[i..i] is { digit(s[i]) }.\\n     e.g. \"3\", \"8\"\\n*  b) len3: f[i...i+2] is { digit(s[i]) op digit(s[i+2] }\\n     e.g. \"3*6\", \"1+9\"\\n*  c) len5+: f[i...j] is:\\n       `f[i...k-1] op_k f[k+1...j]`,  for k in i+1 to j-1, s[k] is an op.\\n     e.g. \"1+2*3\", \"1*2*3+4*5\"\\n\\t \\nnote that s[i] and s[j] are digits, where s[k] is an operator.\\n\\n* Because the search space is dense, we\\'ll use the Bottom-Up DP.\\n\\n```\\n// 2019. The Score of Students Solving Math Expression\\nclass Solution {\\n    using IntSet = unordered_set<short>;\\npublic:\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        // idea: DP in 2D, bottom-up.\\n        // the incorrect evaluation order of the expression includes\\n        // all the differently-structured trees of these k ops and k+1 numbers.\\n        // let f[i..j] represent the set of possible results of evaluating the sub-expression\\n        // s[i..j]. then, we have:\\n        //  a) len1: f[i..i] is { digit(s[i]) }.\\n        //      e.g. \"3\", \"8\"\\n        //  b) len3: f[i...i+2] is { digit(s[i]) + or * digit(s[i+2] }\\n        //      e.g. \"3*6\", \"1+9\"\\n        //  c) len5+: f[i...j] is:\\n        //        `f[i...k-1] op_k f[k+1...j]`,  for k in i+1 to j-1, s[k] is an op.\\n        //      e.g. \"1+2*3\", \"1*2*3+4*5\"\\n        // note that s[i] and s[j] are digits, where s[k] is an operator.\\n        // Because the search space is dense, we\\'ll use the Bottom-Up DP.\\n        const int n = s.size();\\n        vector<vector<IntSet>> f(n, vector<IntSet>(n)); // only ~1/4 of cells will populate.\\n        // len1\\n        for (int i = 0; i < n; i += 2) {\\n            f[i][i].insert(toNumber(s[i]));\\n        }\\n        // len3\\n        for (int i = 0; i + 2 < n; i += 2) {\\n            const int j = i + 2;\\n            char op = s[i + 1];\\n            int a = toNumber(s[i]);\\n            int b = toNumber(s[j]);\\n            f[i][j].insert(op == \\'*\\' ? a * b : a + b);\\n        }\\n        // len 5, 7, ... the general case:\\n        // c) len5+: f[i...j] is:\\n        //  `f[i...k-1] op_k f[k+1...j]`,  for k in i+1 to j-1, s[k] is an op.\\n        for (int len = 5; len <= n; len += 2) {\\n            for (int i = 0; i + len - 1 < n; i += 2) {\\n                const int j = i + len - 1;\\n                for (int k = i + 1; k <= j - 1; k += 2) { // s[k] is an op\\n                    combinePossibleResults(f[i][k - 1], f[k + 1][j], s[k], f[i][j]);\\n                }\\n            }\\n        }\\n        auto possibleResults = std::move(f[0][n - 1]);\\n        f.clear();\\n        // print(s, possibleResults);\\n\\n        const int correctResult = computeCorrectResult(s);\\n        // cout << \"the correct result is \" << correctResult << endl;\\n\\n        int scores = 0;\\n        for (auto studentAnswer : answers) {\\n            if (studentAnswer == correctResult) {\\n                scores += 5;\\n            } else if (possibleResults.count(studentAnswer)) {\\n                scores += 2;\\n            }\\n        }\\n\\n        return scores;\\n    }\\n\\n    static void\\n    combinePossibleResults(const IntSet& A, const IntSet& B, char op, IntSet& combined) {\\n        for (const auto x : A) {\\n            for (const auto y : B) {\\n                int res = op == \\'*\\' ? x * y : x + y;\\n                // necessary optimization, otherwise it will Time Limit Exceeded TLE:\\n                // we can do this, because it\\'s guaranteed that answers[i] <= 1000.\\n                if (res <= 1000) {\\n                    combined.insert(res);\\n                }\\n            }\\n        }\\n    }\\n\\n    static inline int toNumber(char c) {\\n        return c - \\'0\\';\\n    }\\n\\n    static void print(const string& expr, const IntSet& possibleResults) {\\n        cout << \"Possible results for computing `\" << expr << \"` is: \" << endl;\\n        for (auto x : possibleResults) {\\n            cout << x << \", \";\\n        }\\n        cout << endl;\\n    }\\n\\n    static inline int computeCorrectResult(const string& expression) {\\n        // the current impl. is a simple one.\\n        // todo: implement the Shunting Yard algorithm, which is general purpose.\\n\\n        // 3 <= s.length <= 31\\n\\n        int result = 0;\\n        // 1*2+3\\n        // 1+2+3\\n        // search for `+` op in the expression\\n        int product = 0;\\n        int numCountForProduct = 0;\\n        for (int i = 1; i < expression.size(); i += 2) {\\n            char op = expression[i];\\n            if (op == \\'+\\') {\\n                if (numCountForProduct == 0) {\\n                    // 1+2+3\\n                    // 1+2*3\\n                    result += (expression[i - 1] - \\'0\\');\\n                } else {\\n                    result += product;\\n                    product = 0;\\n                    numCountForProduct = 0;\\n                }\\n                // if it\\'s the last op, we\\'ll add up the last number\\n                if (i == expression.size() - 2) {\\n                    result += (expression[i + 1] - \\'0\\');\\n                }\\n            } else if (op == \\'*\\') {\\n                if (numCountForProduct == 0) {\\n                    numCountForProduct += 2;\\n                    product = (expression[i - 1] - \\'0\\') * (expression[i + 1] - \\'0\\');\\n                } else {\\n                    ++numCountForProduct;\\n                    product *= (expression[i + 1] - \\'0\\');\\n                }\\n                // if it\\'s the last op, we\\'ll add up the last product\\n                if (i == expression.size() - 2) {\\n                    result += product;\\n                    product = 0;\\n                    numCountForProduct = 0;\\n                }\\n            } else {\\n                assert(false);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n// 2019. The Score of Students Solving Math Expression\\nclass Solution {\\n    using IntSet = unordered_set<short>;\\npublic:\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        // idea: DP in 2D, bottom-up.\\n        // the incorrect evaluation order of the expression includes\\n        // all the differently-structured trees of these k ops and k+1 numbers.\\n        // let f[i..j] represent the set of possible results of evaluating the sub-expression\\n        // s[i..j]. then, we have:\\n        //  a) len1: f[i..i] is { digit(s[i]) }.\\n        //      e.g. \"3\", \"8\"\\n        //  b) len3: f[i...i+2] is { digit(s[i]) + or * digit(s[i+2] }\\n        //      e.g. \"3*6\", \"1+9\"\\n        //  c) len5+: f[i...j] is:\\n        //        `f[i...k-1] op_k f[k+1...j]`,  for k in i+1 to j-1, s[k] is an op.\\n        //      e.g. \"1+2*3\", \"1*2*3+4*5\"\\n        // note that s[i] and s[j] are digits, where s[k] is an operator.\\n        // Because the search space is dense, we\\'ll use the Bottom-Up DP.\\n        const int n = s.size();\\n        vector<vector<IntSet>> f(n, vector<IntSet>(n)); // only ~1/4 of cells will populate.\\n        // len1\\n        for (int i = 0; i < n; i += 2) {\\n            f[i][i].insert(toNumber(s[i]));\\n        }\\n        // len3\\n        for (int i = 0; i + 2 < n; i += 2) {\\n            const int j = i + 2;\\n            char op = s[i + 1];\\n            int a = toNumber(s[i]);\\n            int b = toNumber(s[j]);\\n            f[i][j].insert(op == \\'*\\' ? a * b : a + b);\\n        }\\n        // len 5, 7, ... the general case:\\n        // c) len5+: f[i...j] is:\\n        //  `f[i...k-1] op_k f[k+1...j]`,  for k in i+1 to j-1, s[k] is an op.\\n        for (int len = 5; len <= n; len += 2) {\\n            for (int i = 0; i + len - 1 < n; i += 2) {\\n                const int j = i + len - 1;\\n                for (int k = i + 1; k <= j - 1; k += 2) { // s[k] is an op\\n                    combinePossibleResults(f[i][k - 1], f[k + 1][j], s[k], f[i][j]);\\n                }\\n            }\\n        }\\n        auto possibleResults = std::move(f[0][n - 1]);\\n        f.clear();\\n        // print(s, possibleResults);\\n\\n        const int correctResult = computeCorrectResult(s);\\n        // cout << \"the correct result is \" << correctResult << endl;\\n\\n        int scores = 0;\\n        for (auto studentAnswer : answers) {\\n            if (studentAnswer == correctResult) {\\n                scores += 5;\\n            } else if (possibleResults.count(studentAnswer)) {\\n                scores += 2;\\n            }\\n        }\\n\\n        return scores;\\n    }\\n\\n    static void\\n    combinePossibleResults(const IntSet& A, const IntSet& B, char op, IntSet& combined) {\\n        for (const auto x : A) {\\n            for (const auto y : B) {\\n                int res = op == \\'*\\' ? x * y : x + y;\\n                // necessary optimization, otherwise it will Time Limit Exceeded TLE:\\n                // we can do this, because it\\'s guaranteed that answers[i] <= 1000.\\n                if (res <= 1000) {\\n                    combined.insert(res);\\n                }\\n            }\\n        }\\n    }\\n\\n    static inline int toNumber(char c) {\\n        return c - \\'0\\';\\n    }\\n\\n    static void print(const string& expr, const IntSet& possibleResults) {\\n        cout << \"Possible results for computing `\" << expr << \"` is: \" << endl;\\n        for (auto x : possibleResults) {\\n            cout << x << \", \";\\n        }\\n        cout << endl;\\n    }\\n\\n    static inline int computeCorrectResult(const string& expression) {\\n        // the current impl. is a simple one.\\n        // todo: implement the Shunting Yard algorithm, which is general purpose.\\n\\n        // 3 <= s.length <= 31\\n\\n        int result = 0;\\n        // 1*2+3\\n        // 1+2+3\\n        // search for `+` op in the expression\\n        int product = 0;\\n        int numCountForProduct = 0;\\n        for (int i = 1; i < expression.size(); i += 2) {\\n            char op = expression[i];\\n            if (op == \\'+\\') {\\n                if (numCountForProduct == 0) {\\n                    // 1+2+3\\n                    // 1+2*3\\n                    result += (expression[i - 1] - \\'0\\');\\n                } else {\\n                    result += product;\\n                    product = 0;\\n                    numCountForProduct = 0;\\n                }\\n                // if it\\'s the last op, we\\'ll add up the last number\\n                if (i == expression.size() - 2) {\\n                    result += (expression[i + 1] - \\'0\\');\\n                }\\n            } else if (op == \\'*\\') {\\n                if (numCountForProduct == 0) {\\n                    numCountForProduct += 2;\\n                    product = (expression[i - 1] - \\'0\\') * (expression[i + 1] - \\'0\\');\\n                } else {\\n                    ++numCountForProduct;\\n                    product *= (expression[i + 1] - \\'0\\');\\n                }\\n                // if it\\'s the last op, we\\'ll add up the last product\\n                if (i == expression.size() - 2) {\\n                    result += product;\\n                    product = 0;\\n                    numCountForProduct = 0;\\n                }\\n            } else {\\n                assert(false);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1904838,
                "title": "top-down-dp-with-memo",
                "content": "\\n```\\npublic class Solution {\\n    Dictionary<(int,int), HashSet<int>> memo;\\n    public int ScoreOfStudents(string s, int[] answers) {\\n        memo = new Dictionary<(int,int), HashSet<int>>();\\n        \\n        // get potential interpretations\\n        var choices = Scores(s, 0, s.Length-1);\\n        \\n        // get actual answer\\n        int correct = GetAnswer(s);\\n        \\n        // add point values\\n        int points = 0;\\n        foreach(var a in answers)\\n        {\\n            if(a == correct) points += 5;\\n            else if(choices.Contains(a)) points += 2;\\n        }\\n        return points;\\n    }\\n    \\n    int GetAnswer(string s)\\n    {\\n        var stack = new Stack<int>();\\n        int num = s[0]-\\'0\\';\\n        stack.Push(num);\\n        int index=1;\\n        while(index < s.Length)\\n        {\\n            num = s[index+1]-\\'0\\';\\n            \\n            if(s[index] == \\'*\\')\\n            {\\n                int pop = stack.Pop();\\n                stack.Push(pop * num);\\n            }\\n            else\\n            {\\n                stack.Push(num);\\n            }\\n            index += 2;\\n        }\\n        \\n        int ans = 0;\\n        while(stack.Count > 0) ans += stack.Pop();\\n        \\n        return ans;\\n    }\\n    \\n    HashSet<int> Scores(string s, int start, int end)\\n    {\\n        if(start == end)\\n        {\\n            var set1 = new HashSet<int>();\\n            set1.Add(s[start]-\\'0\\');\\n            return set1;\\n        }\\n        if(memo.TryGetValue((start,end), out HashSet<int> cached))\\n        {\\n            return cached;\\n        }\\n\\n        var results = new HashSet<int>();\\n        for(int i=start;i<=end-2;i+=2)\\n        {\\n            var op = s[i+1];\\n            var left = Scores(s,start,i);\\n            var right = Scores(s,i+2,end);\\n            \\n            foreach(var l in left)\\n            {\\n                foreach(var r in right)\\n                {\\n                    int val = 0;\\n                    if(op == \\'+\\') val = l+r; \\n                    else val = l*r;\\n                    if(val <= 1000) results.Add(val);\\n                }\\n            }\\n        }\\n        \\n        memo.Add((start,end), results);\\n        return results;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    Dictionary<(int,int), HashSet<int>> memo;\\n    public int ScoreOfStudents(string s, int[] answers) {\\n        memo = new Dictionary<(int,int), HashSet<int>>();\\n        \\n        // get potential interpretations\\n        var choices = Scores(s, 0, s.Length-1);\\n        \\n        // get actual answer\\n        int correct = GetAnswer(s);\\n        \\n        // add point values\\n        int points = 0;\\n        foreach(var a in answers)\\n        {\\n            if(a == correct) points += 5;\\n            else if(choices.Contains(a)) points += 2;\\n        }\\n        return points;\\n    }\\n    \\n    int GetAnswer(string s)\\n    {\\n        var stack = new Stack<int>();\\n        int num = s[0]-\\'0\\';\\n        stack.Push(num);\\n        int index=1;\\n        while(index < s.Length)\\n        {\\n            num = s[index+1]-\\'0\\';\\n            \\n            if(s[index] == \\'*\\')\\n            {\\n                int pop = stack.Pop();\\n                stack.Push(pop * num);\\n            }\\n            else\\n            {\\n                stack.Push(num);\\n            }\\n            index += 2;\\n        }\\n        \\n        int ans = 0;\\n        while(stack.Count > 0) ans += stack.Pop();\\n        \\n        return ans;\\n    }\\n    \\n    HashSet<int> Scores(string s, int start, int end)\\n    {\\n        if(start == end)\\n        {\\n            var set1 = new HashSet<int>();\\n            set1.Add(s[start]-\\'0\\');\\n            return set1;\\n        }\\n        if(memo.TryGetValue((start,end), out HashSet<int> cached))\\n        {\\n            return cached;\\n        }\\n\\n        var results = new HashSet<int>();\\n        for(int i=start;i<=end-2;i+=2)\\n        {\\n            var op = s[i+1];\\n            var left = Scores(s,start,i);\\n            var right = Scores(s,i+2,end);\\n            \\n            foreach(var l in left)\\n            {\\n                foreach(var r in right)\\n                {\\n                    int val = 0;\\n                    if(op == \\'+\\') val = l+r; \\n                    else val = l*r;\\n                    if(val <= 1000) results.Add(val);\\n                }\\n            }\\n        }\\n        \\n        memo.Add((start,end), results);\\n        return results;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793904,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, unordered_set<int>*> memo;\\n        \\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        int len = s.size();\\n        int goodAns = solve(s);\\n        unordered_set<int>* partialAns = solve_partial(s, 0, len - 1);\\n        int ans = 0;\\n        for (int i = 0; i < answers.size(); ++i) {\\n            if (answers[i] == goodAns) {\\n                ans += 5;\\n            } else if (partialAns->find(answers[i]) != partialAns->end()) {\\n                ans += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int solve(string& s) {\\n        stack<int> stk;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (stk.empty()) {\\n                stk.push(s[i] - \\'0\\');\\n            } else {\\n                if (s[i] == \\'+\\') {\\n                    stk.push(-1);\\n                } else if (s[i] == \\'*\\') {\\n                    stk.push(-2);\\n                } else {\\n                    int value = (s[i] - \\'0\\');\\n                    while (!stk.empty() && stk.top() == -2) {\\n                        stk.pop();\\n                        value *= stk.top();\\n                        stk.pop();\\n                    }\\n                    stk.push(value);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        while (!stk.empty()) {\\n            ans += stk.top();\\n            stk.pop();\\n            if (!stk.empty()) {\\n                stk.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    unordered_set<int>* solve_partial(string& s, int left, int right) {\\n        if (memo.find(left * 1000 + right) != memo.end()) {\\n            return memo[left * 1000 + right];\\n        }\\n        unordered_set<int>* ret = new unordered_set<int>();\\n        if (left == right) {\\n            ret->insert(s[left] - \\'0\\');\\n            memo[left * 1000 + right] = ret;\\n            return ret;\\n        }\\n        for (int i = left + 1; i < right; i += 2) {\\n            unordered_set<int>* leftAns = solve_partial(s, left, i - 1);\\n            unordered_set<int>* rightAns = solve_partial(s, i + 1, right);\\n            for (auto it1 = leftAns->begin(); it1 != leftAns->end(); ++it1) {\\n                for (auto it2 = rightAns->begin(); it2 != rightAns->end(); ++it2) {\\n                    if (s[i] == \\'+\\') {\\n                        if (*it1 + *it2 <= 1000) {\\n                            ret->insert(*it1 + *it2);\\n                        }\\n                    } else {\\n                        if (*it1 * *it2 <= 1000) {\\n                            ret->insert(*it1 * *it2);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        memo[left * 1000 + right] = ret;\\n        return ret;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, unordered_set<int>*> memo;\\n        \\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        int len = s.size();\\n        int goodAns = solve(s);\\n        unordered_set<int>* partialAns = solve_partial(s, 0, len - 1);\\n        int ans = 0;\\n        for (int i = 0; i < answers.size(); ++i) {\\n            if (answers[i] == goodAns) {\\n                ans += 5;\\n            } else if (partialAns->find(answers[i]) != partialAns->end()) {\\n                ans += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int solve(string& s) {\\n        stack<int> stk;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (stk.empty()) {\\n                stk.push(s[i] - \\'0\\');\\n            } else {\\n                if (s[i] == \\'+\\') {\\n                    stk.push(-1);\\n                } else if (s[i] == \\'*\\') {\\n                    stk.push(-2);\\n                } else {\\n                    int value = (s[i] - \\'0\\');\\n                    while (!stk.empty() && stk.top() == -2) {\\n                        stk.pop();\\n                        value *= stk.top();\\n                        stk.pop();\\n                    }\\n                    stk.push(value);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        while (!stk.empty()) {\\n            ans += stk.top();\\n            stk.pop();\\n            if (!stk.empty()) {\\n                stk.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    unordered_set<int>* solve_partial(string& s, int left, int right) {\\n        if (memo.find(left * 1000 + right) != memo.end()) {\\n            return memo[left * 1000 + right];\\n        }\\n        unordered_set<int>* ret = new unordered_set<int>();\\n        if (left == right) {\\n            ret->insert(s[left] - \\'0\\');\\n            memo[left * 1000 + right] = ret;\\n            return ret;\\n        }\\n        for (int i = left + 1; i < right; i += 2) {\\n            unordered_set<int>* leftAns = solve_partial(s, left, i - 1);\\n            unordered_set<int>* rightAns = solve_partial(s, i + 1, right);\\n            for (auto it1 = leftAns->begin(); it1 != leftAns->end(); ++it1) {\\n                for (auto it2 = rightAns->begin(); it2 != rightAns->end(); ++it2) {\\n                    if (s[i] == \\'+\\') {\\n                        if (*it1 + *it2 <= 1000) {\\n                            ret->insert(*it1 + *it2);\\n                        }\\n                    } else {\\n                        if (*it1 * *it2 <= 1000) {\\n                            ret->insert(*it1 * *it2);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        memo[left * 1000 + right] = ret;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753995,
                "title": "the-score-of-students-solving-math-expression-c",
                "content": "public class Solution {\\n    public int ScoreOfStudents(string s, int[] answers) {\\n        // This is a Recursion Problem or DP problem \\n        // Tried as Calculator II but no luck\\n        // First get the Real answer and that can be calculated as we calculated in Calcultor 2\\n        \\n        var rightAnswer = GetValidAnswer(s);\\n        var mem=new Dictionary<string,HashSet<int>>();\\n        var almostRightAnswers= GetAlmostValidAnswers(s,mem);\\n        //hash.Remove(rightAnswer);// Removing right answer from set\\n        almostRightAnswers.Remove(rightAnswer);\\n        var result=0;\\n       \\n        foreach(var a in answers){\\n            if (almostRightAnswers.Contains(a)){\\n                result+=2;\\n            }else if (a==rightAnswer){\\n                result+=5;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    HashSet<int> GetAlmostValidAnswers(string s,Dictionary<string,HashSet<int>> m){\\n        var set=new HashSet<int>();\\n        if (m.ContainsKey(s)){\\n            return m[s];\\n        }\\n        \\n        // Break Out condition\\n        if (string.IsNullOrEmpty(s)){\\n            return set;\\n        }\\n        if (s.Length==1){\\n            set.Add(Convert.ToInt32(s));\\n            return set;\\n        }\\n        \\n        for(var i=0;i<s.Length;i++){\\n            if (s[i]==\\'+\\' || s[i]==\\'*\\'){\\n                // split\\n                var left=s.Substring(0,i);\\n                var right=s.Substring(i+1);\\n                var leftResults=GetAlmostValidAnswers(left,m);\\n                var rightResults=GetAlmostValidAnswers(right,m);\\n                // Need to calculate left and right operands as per Operator \\n                foreach(var l in leftResults){\\n                    foreach (var r in rightResults){\\n                        if (s[i]==\\'+\\' ){\\n                            var res=l+r;\\n                            if (res<=1000){\\n                                set.Add(res);\\n                            }\\n                        }else{\\n                            var res=l*r;\\n                            if (res<=1000){\\n                                set.Add(res);\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        // At the end we will either get a valid number or list will be empty\\n        // if no operator in equation\\n        m[s]=set;\\n        return set;\\n    }\\n    \\n    \\n    \\n    int GetValidAnswer(string s){\\n        var sign=\\'+\\';\\n        var cur=0;\\n        var stack = new Stack<int>();\\n        foreach ( var c in s ){\\n            if (IsDigit(c)){\\n               cur=cur*10+c-\\'0\\';// all operands are in range 0-9 , no need to iterate further \\n               \\n               if (sign==\\'*\\'){\\n                   stack.Push(stack.Pop()*cur);\\n               }else{\\n                   stack.Push(cur);\\n               }\\n               cur=0;\\n            }else {\\n                if (c==\\'+\\'){\\n                    sign=\\'+\\';\\n                }else if (c==\\'*\\'){\\n                    sign=\\'*\\';\\n                }\\n            }\\n        }\\n    \\n        return stack.Sum(i=>i);\\n    }\\n    \\n    bool IsDigit(char c){\\n        return c>=\\'0\\' && c<=\\'9\\';\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int ScoreOfStudents(string s, int[] answers) {\\n        // This is a Recursion Problem or DP problem \\n        // Tried as Calculator II but no luck\\n        // First get the Real answer and that can be calculated as we calculated in Calcultor 2\\n        \\n        var rightAnswer = GetValidAnswer(s);\\n        var mem=new Dictionary<string,HashSet<int>>();\\n        var almostRightAnswers= GetAlmostValidAnswers(s,mem);\\n        //hash.Remove(rightAnswer);// Removing right answer from set\\n        almostRightAnswers.Remove(rightAnswer);\\n        var result=0;\\n       \\n        foreach(var a in answers){\\n            if (almostRightAnswers.Contains(a)){\\n                result+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1686278,
                "title": "python-dfs-solution-using-memory-set-filter-result-1000-to-avoid-tle",
                "content": "```\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        nums=list(s)\\n        for i in range(len(nums)):\\n            if nums[i].isdigit():\\n                nums[i]=int(nums[i])\\n        \\n        mem={}\\n        def dfs(start,end):\\n            if (start,end) in mem:\\n                return mem[(start,end)]\\n            if start==end:\\n                return set([nums[start]])\\n            res=set()\\n            for i in range(start+1,end,2):\\n                left=dfs(start,i-1)\\n                right=dfs(i+1,end)\\n                for a in left:\\n                    for b in right:\\n                        if nums[i]==\\'+\\':\\n                            if a+b<=1000:\\n                                res.add(a+b)\\n                        else:\\n                            if a*b<=1000:\\n                                res.add(a*b) \\n            mem[(start,end)]=res\\n            return res\\n            \\n        s+=\\'e\\'   \\n        numstack=[]\\n        symstack=[\"+\"]\\n        cur=\\'\\'\\n        for char in list(s):\\n            if char in \"+*e\":\\n                prevsym=symstack.pop()\\n                if prevsym ==\"+\":\\n                    numstack.append(int(cur))\\n                elif prevsym==\\'*\\':\\n                    prenum=numstack.pop()\\n                    numstack.append(prenum*int(cur))\\n                cur=\\'\\'\\n                if char in \\'+*\\':\\n                    symstack.append(char)\\n            else:\\n                cur+=char\\n        v=sum(numstack)\\n        results=dfs(0,len(nums)-1)\\n        score=0\\n        for a in answers:\\n            if a==v:\\n                score+=5\\n            elif a in results:\\n                score+=2\\n            \\n        return score\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        nums=list(s)\\n        for i in range(len(nums)):\\n            if nums[i].isdigit():\\n                nums[i]=int(nums[i])\\n        \\n        mem={}\\n        def dfs(start,end):\\n            if (start,end) in mem:\\n                return mem[(start,end)]\\n            if start==end:\\n                return set([nums[start]])\\n            res=set()\\n            for i in range(start+1,end,2):\\n                left=dfs(start,i-1)\\n                right=dfs(i+1,end)\\n                for a in left:\\n                    for b in right:\\n                        if nums[i]==\\'+\\':\\n                            if a+b<=1000:\\n                                res.add(a+b)\\n                        else:\\n                            if a*b<=1000:\\n                                res.add(a*b) \\n            mem[(start,end)]=res\\n            return res\\n            \\n        s+=\\'e\\'   \\n        numstack=[]\\n        symstack=[\"+\"]\\n        cur=\\'\\'\\n        for char in list(s):\\n            if char in \"+*e\":\\n                prevsym=symstack.pop()\\n                if prevsym ==\"+\":\\n                    numstack.append(int(cur))\\n                elif prevsym==\\'*\\':\\n                    prenum=numstack.pop()\\n                    numstack.append(prenum*int(cur))\\n                cur=\\'\\'\\n                if char in \\'+*\\':\\n                    symstack.append(char)\\n            else:\\n                cur+=char\\n        v=sum(numstack)\\n        results=dfs(0,len(nums)-1)\\n        score=0\\n        for a in answers:\\n            if a==v:\\n                score+=5\\n            elif a in results:\\n                score+=2\\n            \\n        return score\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1629783,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    #define BOP(op) {#op[0], [] (int a, int b) { return a op b; }}\\n    map<char, function<int(int, int)>> ops{BOP(+), BOP(*)};\\n    unordered_map<int, unordered_set<int>> dp;\\n    unordered_set<int> &evalAll(string &s, int l, int r) {\\n        int state = l * s.size() + r;\\n        if (dp.count(state))\\n            return dp[state];\\n        if (l + 1 == r)\\n            return dp[state] = {s[l] - \\'0\\'};\\n        auto &res = dp[state];\\n        for (int i = l + 1; i < r; i += 2) {\\n            auto &left = evalAll(s, l, i), &right = evalAll(s, i + 1, r);\\n            auto &op = ops[s[i]];\\n            for (auto l : left)\\n                for (auto r : right) {\\n                    int val = op(l, r);\\n                    if (val <= 1000)\\n                        res.insert(val);\\n                }\\n        }\\n        return res;\\n    }\\n    \\n    int evalTrue (string &s) {\\n        vector<int> stk{s[0] - \\'0\\'};\\n        for (int i = 2; i < s.size(); i += 2) {\\n            int val = s[i] - \\'0\\';\\n            if (s[i - 1] == \\'*\\') {\\n                val *= stk.back();\\n                stk.pop_back();\\n            }\\n            stk.push_back(val);\\n        }\\n        return accumulate(stk.begin(), stk.end(), 0);\\n    }\\n    \\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        auto &results = evalAll(s, 0, s.size());\\n        int score = 0, true_res = evalTrue(s);\\n        for (auto ans : answers) {\\n            if (results.count(ans))\\n                score += 2;\\n            if (ans == true_res)\\n                score += 3;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define BOP(op) {#op[0], [] (int a, int b) { return a op b; }}\\n    map<char, function<int(int, int)>> ops{BOP(+), BOP(*)};\\n    unordered_map<int, unordered_set<int>> dp;\\n    unordered_set<int> &evalAll(string &s, int l, int r) {\\n        int state = l * s.size() + r;\\n        if (dp.count(state))\\n            return dp[state];\\n        if (l + 1 == r)\\n            return dp[state] = {s[l] - \\'0\\'};\\n        auto &res = dp[state];\\n        for (int i = l + 1; i < r; i += 2) {\\n            auto &left = evalAll(s, l, i), &right = evalAll(s, i + 1, r);\\n            auto &op = ops[s[i]];\\n            for (auto l : left)\\n                for (auto r : right) {\\n                    int val = op(l, r);\\n                    if (val <= 1000)\\n                        res.insert(val);\\n                }\\n        }\\n        return res;\\n    }\\n    \\n    int evalTrue (string &s) {\\n        vector<int> stk{s[0] - \\'0\\'};\\n        for (int i = 2; i < s.size(); i += 2) {\\n            int val = s[i] - \\'0\\';\\n            if (s[i - 1] == \\'*\\') {\\n                val *= stk.back();\\n                stk.pop_back();\\n            }\\n            stk.push_back(val);\\n        }\\n        return accumulate(stk.begin(), stk.end(), 0);\\n    }\\n    \\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        auto &results = evalAll(s, 0, s.size());\\n        int score = 0, true_res = evalTrue(s);\\n        for (auto ans : answers) {\\n            if (results.count(ans))\\n                score += 2;\\n            if (ans == true_res)\\n                score += 3;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620129,
                "title": "dp-solution-c-with-comments",
                "content": "```\\nclass Solution {\\n public:\\n  enum Operation {\\n    kPlus,\\n    kTimes,\\n  };\\n\\n  int scoreOfStudents(const string& s, const vector<int>& answers) {\\n    // It\\'s hacky to cache this state in member variables, we do it just to\\n    // spare having extra parameters in the other methods.\\n    parseNumbersAndOperations(s);\\n    max_answer_ = *max_element(answers.begin(), answers.end());\\n    possible_results_.assign(numbers_.size(),\\n                             vector<set<int>>(numbers_.size()));\\n\\n    const int correct_result = getCorrectResult();\\n    int score_sum = 0;\\n    for (int answer : answers) {\\n      if (answer == correct_result) {\\n        score_sum += 5;\\n      } else if (getPossibleResults(0, (int)(numbers_.size() - 1))\\n                     .count(answer)) {\\n        score_sum += 2;\\n      }\\n    }\\n\\n    return score_sum;\\n  }\\n\\n  void parseNumbersAndOperations(const string& s) {\\n    int num_start = 0;\\n    for (int i = 0; i <= s.size(); i++) {\\n      bool parse_number = false;\\n      if (i == s.size()) {\\n        // Last number, won\\'t be followed by any operation.\\n        parse_number = true;\\n      } else if (s[i] == \\'+\\') {\\n        operations_.push_back(kPlus);\\n        parse_number = true;\\n      } else if (s[i] == \\'*\\') {\\n        operations_.push_back(kTimes);\\n        parse_number = true;\\n      }\\n\\n      if (parse_number) {\\n        numbers_.push_back(stoi(s.substr(num_start, i - num_start)));\\n        num_start = i + 1;\\n      }\\n    }\\n  }\\n\\n  // Let S be the set of possible results of the expression [left, right].\\n  // This returns the set obtained from S by replacing every number bigger than\\n  // `max_answer_` with one single `max_answer_ + 1`. This spares computing all\\n  // possible results by using that sum and multiplication are increasing\\n  // functions.\\n  // The method inserts `max_answer_ + 1` instead of nothing to avoid empty\\n  // sets. E.g. consider computing the possible results of [0] * [] instead of\\n  // [0] * [max_answer + 1].\\n  const set<int>& getPossibleResults(int left, int right) {\\n    if (!possible_results_[left][right].empty()) {\\n      return possible_results_[left][right];\\n    }\\n\\n    const int max_answer_exceeded_token_ = max_answer_ + 1;\\n    if (left == right) {\\n      // Single number.\\n      const int result = numbers_[left] <= max_answer_\\n                             ? numbers_[left]\\n                             : max_answer_exceeded_token_;\\n      possible_results_[left][right] = {result};\\n      return possible_results_[left][right];\\n    }\\n\\n    for (int mid = left; mid < right; mid++) {\\n      const set<int>& possible_lhs_values = getPossibleResults(left, mid);\\n      const set<int>& possible_rhs_values = getPossibleResults(mid + 1, right);\\n      // Iterate over both sets in increasing order.\\n      for (int lhs : possible_lhs_values) {\\n        // We must not early return here if |lhs| > `max_answer_`, because\\n        // multiplying by 0 gives 0 and that\\'s a valid result.\\n        for (int rhs : possible_rhs_values) {\\n          int result = operations_[mid] == kPlus ? lhs + rhs : lhs * rhs;\\n          if (result > max_answer_) {\\n            possible_results_[left][right].insert(max_answer_exceeded_token_);\\n            // Results will be even bigger from now on, stop searching.\\n            break;\\n          }\\n          possible_results_[left][right].insert(result);\\n        }\\n      }\\n    }\\n\\n    return possible_results_[left][right];\\n  }\\n\\n  int getCorrectResult() {\\n    int result = 0;\\n    int product = 1;\\n    for (int i = 0; i < numbers_.size(); i++) {\\n      product *= numbers_[i];\\n      if (i == numbers_.size() - 1 || operations_[i] == kPlus) {\\n        result += product;\\n        product = 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  vector<int> numbers_;\\n  vector<Operation> operations_;\\n  int max_answer_ = -1;\\n  vector<vector<set<int>>> possible_results_;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  enum Operation {\\n    kPlus,\\n    kTimes,\\n  };\\n\\n  int scoreOfStudents(const string& s, const vector<int>& answers) {\\n    // It\\'s hacky to cache this state in member variables, we do it just to\\n    // spare having extra parameters in the other methods.\\n    parseNumbersAndOperations(s);\\n    max_answer_ = *max_element(answers.begin(), answers.end());\\n    possible_results_.assign(numbers_.size(),\\n                             vector<set<int>>(numbers_.size()));\\n\\n    const int correct_result = getCorrectResult();\\n    int score_sum = 0;\\n    for (int answer : answers) {\\n      if (answer == correct_result) {\\n        score_sum += 5;\\n      } else if (getPossibleResults(0, (int)(numbers_.size() - 1))\\n                     .count(answer)) {\\n        score_sum += 2;\\n      }\\n    }\\n\\n    return score_sum;\\n  }\\n\\n  void parseNumbersAndOperations(const string& s) {\\n    int num_start = 0;\\n    for (int i = 0; i <= s.size(); i++) {\\n      bool parse_number = false;\\n      if (i == s.size()) {\\n        // Last number, won\\'t be followed by any operation.\\n        parse_number = true;\\n      } else if (s[i] == \\'+\\') {\\n        operations_.push_back(kPlus);\\n        parse_number = true;\\n      } else if (s[i] == \\'*\\') {\\n        operations_.push_back(kTimes);\\n        parse_number = true;\\n      }\\n\\n      if (parse_number) {\\n        numbers_.push_back(stoi(s.substr(num_start, i - num_start)));\\n        num_start = i + 1;\\n      }\\n    }\\n  }\\n\\n  // Let S be the set of possible results of the expression [left, right].\\n  // This returns the set obtained from S by replacing every number bigger than\\n  // `max_answer_` with one single `max_answer_ + 1`. This spares computing all\\n  // possible results by using that sum and multiplication are increasing\\n  // functions.\\n  // The method inserts `max_answer_ + 1` instead of nothing to avoid empty\\n  // sets. E.g. consider computing the possible results of [0] * [] instead of\\n  // [0] * [max_answer + 1].\\n  const set<int>& getPossibleResults(int left, int right) {\\n    if (!possible_results_[left][right].empty()) {\\n      return possible_results_[left][right];\\n    }\\n\\n    const int max_answer_exceeded_token_ = max_answer_ + 1;\\n    if (left == right) {\\n      // Single number.\\n      const int result = numbers_[left] <= max_answer_\\n                             ? numbers_[left]\\n                             : max_answer_exceeded_token_;\\n      possible_results_[left][right] = {result};\\n      return possible_results_[left][right];\\n    }\\n\\n    for (int mid = left; mid < right; mid++) {\\n      const set<int>& possible_lhs_values = getPossibleResults(left, mid);\\n      const set<int>& possible_rhs_values = getPossibleResults(mid + 1, right);\\n      // Iterate over both sets in increasing order.\\n      for (int lhs : possible_lhs_values) {\\n        // We must not early return here if |lhs| > `max_answer_`, because\\n        // multiplying by 0 gives 0 and that\\'s a valid result.\\n        for (int rhs : possible_rhs_values) {\\n          int result = operations_[mid] == kPlus ? lhs + rhs : lhs * rhs;\\n          if (result > max_answer_) {\\n            possible_results_[left][right].insert(max_answer_exceeded_token_);\\n            // Results will be even bigger from now on, stop searching.\\n            break;\\n          }\\n          possible_results_[left][right].insert(result);\\n        }\\n      }\\n    }\\n\\n    return possible_results_[left][right];\\n  }\\n\\n  int getCorrectResult() {\\n    int result = 0;\\n    int product = 1;\\n    for (int i = 0; i < numbers_.size(); i++) {\\n      product *= numbers_[i];\\n      if (i == numbers_.size() - 1 || operations_[i] == kPlus) {\\n        result += product;\\n        product = 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  vector<int> numbers_;\\n  vector<Operation> operations_;\\n  int max_answer_ = -1;\\n  vector<vector<set<int>>> possible_results_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1608409,
                "title": "java-dp",
                "content": "The input sizes are small enough to track all possible answers .\\n```\\nclass Solution {\\n    HashMap<String, Set<Integer>> map = new HashMap<>();\\n\\n    private int eval(String str) {\\n        int val;\\n        if (!str.contains(\"+\")) {\\n            String[] s = str.split(\"\\\\\\\\*\");\\n            val = Integer.parseInt(s[0]);\\n            for (int i = 1; i < s.length; i++) {\\n                val *= Integer.parseInt(s[i]);\\n            }\\n        } else {\\n            String[] s = str.split(\"\\\\\\\\+\");\\n            val = eval(s[0]);\\n            for (int i = 1; i < s.length; i++) {\\n                val += eval(s[i]);\\n            }\\n        }\\n        return val;\\n    }\\n\\n    public int scoreOfStudents(String s, int[] answers) {\\n        Set<Integer> set = solve(s);\\n        int sum = 0;\\n        int proper = eval(s);\\n        for (int ans : answers) {\\n            if (set.contains(ans)) {\\n                sum += (ans == proper ? 5 : 2);\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    private Set<Integer> solve(String str) {\\n        if (str.length() == 1) {\\n            Set<Integer> set = new HashSet<>();\\n            set.add(Integer.parseInt(str));\\n            return set;\\n        }\\n        if (!map.containsKey(str)) {\\n            Set<Integer> ret = new HashSet<>();\\n            for (int i = 0; i < str.length(); i++) {\\n                if (str.charAt(i) == \\'+\\') {\\n                    Set<Integer> left = solve(str.substring(0, i));\\n                    Set<Integer> right = solve(str.substring(i + 1));\\n                    for (int num : left) {\\n                        for (int val : right) {\\n                            if (num + val <= 1000) {\\n                                ret.add(num + val);\\n                            }\\n                        }\\n                    }\\n                } else if (str.charAt(i) == \\'*\\') {\\n                    Set<Integer> left = solve(str.substring(0, i));\\n                    Set<Integer> right = solve(str.substring(i + 1));\\n                    for (int num : left) {\\n                        for (int val : right) {\\n                            if (num * val <= 1000) {\\n                                ret.add(num * val);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            map.put(str, ret);\\n            return ret;\\n        } else {\\n            return map.get(str);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    HashMap<String, Set<Integer>> map = new HashMap<>();\\n\\n    private int eval(String str) {\\n        int val;\\n        if (!str.contains(\"+\")) {\\n            String[] s = str.split(\"\\\\\\\\*\");\\n            val = Integer.parseInt(s[0]);\\n            for (int i = 1; i < s.length; i++) {\\n                val *= Integer.parseInt(s[i]);\\n            }\\n        } else {\\n            String[] s = str.split(\"\\\\\\\\+\");\\n            val = eval(s[0]);\\n            for (int i = 1; i < s.length; i++) {\\n                val += eval(s[i]);\\n            }\\n        }\\n        return val;\\n    }\\n\\n    public int scoreOfStudents(String s, int[] answers) {\\n        Set<Integer> set = solve(s);\\n        int sum = 0;\\n        int proper = eval(s);\\n        for (int ans : answers) {\\n            if (set.contains(ans)) {\\n                sum += (ans == proper ? 5 : 2);\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    private Set<Integer> solve(String str) {\\n        if (str.length() == 1) {\\n            Set<Integer> set = new HashSet<>();\\n            set.add(Integer.parseInt(str));\\n            return set;\\n        }\\n        if (!map.containsKey(str)) {\\n            Set<Integer> ret = new HashSet<>();\\n            for (int i = 0; i < str.length(); i++) {\\n                if (str.charAt(i) == \\'+\\') {\\n                    Set<Integer> left = solve(str.substring(0, i));\\n                    Set<Integer> right = solve(str.substring(i + 1));\\n                    for (int num : left) {\\n                        for (int val : right) {\\n                            if (num + val <= 1000) {\\n                                ret.add(num + val);\\n                            }\\n                        }\\n                    }\\n                } else if (str.charAt(i) == \\'*\\') {\\n                    Set<Integer> left = solve(str.substring(0, i));\\n                    Set<Integer> right = solve(str.substring(i + 1));\\n                    for (int num : left) {\\n                        for (int val : right) {\\n                            if (num * val <= 1000) {\\n                                ret.add(num * val);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            map.put(str, ret);\\n            return ret;\\n        } else {\\n            return map.get(str);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555386,
                "title": "python-dp-memoization-95-68-faster",
                "content": "```\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        #set of all possible values\\n        possible=set()\\n        n=len(s)\\n        ans=0\\n        #Memoized function to find all possible values be it correct/incorrect\\n        @lru_cache(None)\\n        def dp(i,j):\\n            if (i==j): return {int(s[i])} \\n\\t\\t\\t#returns set of all possible values computed in current iteration\\n            L=set()\\n            for k in range(i+1,j,2):\\n                if s[k]==\\'+\\':\\n                    l1=dp(i,k-1)\\n                    l2=dp(k+1,j)\\n                    for a in l1:\\n                        for b in l2:\\n                            res=a+b\\n                            #an optimization considering given constraints\\n                            if res<=1000:\\n                                L.add(res)\\n                elif s[k]==\\'*\\':\\n                    l1=dp(i,k-1)\\n                    l2=dp(k+1,j)\\n                    for a in l1:\\n                        for b in l2:\\n                            res=a*b\\n                            if res<=1000:\\n                                L.add(res)\\n            return L\\n        for val in dp(0,n-1):\\n            possible.add(val)\\n        #for finding correct value of the expression, you can also use python\\'s inbuilt eval(s) to directly compute\\n        actual=0\\n        prev=1\\n        i=0\\n        while (i<n):\\n            while (i<n and s[i]!=\\'+\\'):\\n                if s[i]==\\'*\\':\\n                    i+=1\\n                    continue\\n                else:\\n                    prev*=int(s[i])\\n                    i+=1\\n            i+=1\\n            actual+=prev\\n            prev=1\\n        for val in answers:\\n            if val==actual:\\n                ans+=5\\n            elif val in possible:\\n                ans+=2\\n        return ans\\n                \\n                \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        #set of all possible values\\n        possible=set()\\n        n=len(s)\\n        ans=0\\n        #Memoized function to find all possible values be it correct/incorrect\\n        @lru_cache(None)\\n        def dp(i,j):\\n            if (i==j): return {int(s[i])} \\n\\t\\t\\t#returns set of all possible values computed in current iteration\\n            L=set()\\n            for k in range(i+1,j,2):\\n                if s[k]==\\'+\\':\\n                    l1=dp(i,k-1)\\n                    l2=dp(k+1,j)\\n                    for a in l1:\\n                        for b in l2:\\n                            res=a+b\\n                            #an optimization considering given constraints\\n                            if res<=1000:\\n                                L.add(res)\\n                elif s[k]==\\'*\\':\\n                    l1=dp(i,k-1)\\n                    l2=dp(k+1,j)\\n                    for a in l1:\\n                        for b in l2:\\n                            res=a*b\\n                            if res<=1000:\\n                                L.add(res)\\n            return L\\n        for val in dp(0,n-1):\\n            possible.add(val)\\n        #for finding correct value of the expression, you can also use python\\'s inbuilt eval(s) to directly compute\\n        actual=0\\n        prev=1\\n        i=0\\n        while (i<n):\\n            while (i<n and s[i]!=\\'+\\'):\\n                if s[i]==\\'*\\':\\n                    i+=1\\n                    continue\\n                else:\\n                    prev*=int(s[i])\\n                    i+=1\\n            i+=1\\n            actual+=prev\\n            prev=1\\n        for val in answers:\\n            if val==actual:\\n                ans+=5\\n            elif val in possible:\\n                ans+=2\\n        return ans\\n                \\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545288,
                "title": "tabulation-dp-faster-than-100-and-memory-less-than-96-25",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> dp;\\n     void diffWaysToCompute(string exp) {\\n        vector<int> numbers;\\n        vector<char> operators;\\n        string temp = \"\";\\n        for(char x : exp){\\n            if(x == \\'+\\' || x == \\'*\\'){\\n                operators.push_back(x);\\n                numbers.push_back(stoi(temp));\\n                temp =\"\";\\n            }\\n            else temp+=x;\\n        }\\n        numbers.push_back(stoi(temp));\\n        bool stored[1001];\\n         dp.resize(numbers.size() , vector<vector<int>>(numbers.size()));\\n        for(int size = 0 ;size<numbers.size();size++){\\n            for(int i = 0 , j = size ; j<numbers.size();i++ ,j++){\\n                memset(stored , false , sizeof(stored));\\n                if(size == 0){\\n                    dp[i][j].push_back({numbers[i]});\\n                }\\n                else if(size == 1){\\n                    if(operators[i] == \\'+\\'){\\n                        dp[i][j].push_back({numbers[i]+numbers[j]});\\n                    }\\n                    else {\\n                        dp[i][j].push_back({numbers[i]*numbers[j]});\\n                    }\\n                }\\n                else{\\n                    for(int k = i;k<j;k++){\\n                        if(operators[k] == \\'+\\')\\n                           for(int x : dp[i][k]){\\n                                for(int y : dp[k+1][j]){\\n                                    if(x+y <= 1000 and !stored[x+y]){\\n                                     dp[i][j].push_back({x+y});\\n                                        stored[x+y] = 1;\\n                                    }\\n                                }       \\n                            }          \\n                        else \\n                            for(int x : dp[i][k]){\\n                                for(int y : dp[k+1][j]){\\n                                    if(x*y <= 1000 and !stored[x*y]){\\n                                        dp[i][j].push_back({x*y});\\n                                        stored[x*y] = 1;\\n                                    }\\n                                }          \\n                            }    \\n                    }\\n                }\\n            }\\n        }\\n    }\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        diffWaysToCompute(s);\\n        bool visited[1001];\\n        memset(visited , 0 , sizeof(visited));\\n        for (int x :dp[0][dp.size()-1] ) if(x<= 1000) visited[x] = 1;\\n        int correct = 0;\\n        for (int i = 1, j = 0; i <= s.size(); i += 2) \\n        if (i == s.size() || s[i] == \\'+\\') {\\n            int mul = 1;\\n            for (; j < i; j += 2)\\n                mul *= s[j] - \\'0\\';\\n            correct += mul;\\n        }\\n        int count = 0;\\n        for(int x : answers){\\n            if (x == correct) \\n                count+=5;\\n            else if(visited[x]) \\n                count+=2;\\n        }\\n        return count;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> dp;\\n     void diffWaysToCompute(string exp) {\\n        vector<int> numbers;\\n        vector<char> operators;\\n        string temp = \"\";\\n        for(char x : exp){\\n            if(x == \\'+\\' || x == \\'*\\'){\\n                operators.push_back(x);\\n                numbers.push_back(stoi(temp));\\n                temp =\"\";\\n            }\\n            else temp+=x;\\n        }\\n        numbers.push_back(stoi(temp));\\n        bool stored[1001];\\n         dp.resize(numbers.size() , vector<vector<int>>(numbers.size()));\\n        for(int size = 0 ;size<numbers.size();size++){\\n            for(int i = 0 , j = size ; j<numbers.size();i++ ,j++){\\n                memset(stored , false , sizeof(stored));\\n                if(size == 0){\\n                    dp[i][j].push_back({numbers[i]});\\n                }\\n                else if(size == 1){\\n                    if(operators[i] == \\'+\\'){\\n                        dp[i][j].push_back({numbers[i]+numbers[j]});\\n                    }\\n                    else {\\n                        dp[i][j].push_back({numbers[i]*numbers[j]});\\n                    }\\n                }\\n                else{\\n                    for(int k = i;k<j;k++){\\n                        if(operators[k] == \\'+\\')\\n                           for(int x : dp[i][k]){\\n                                for(int y : dp[k+1][j]){\\n                                    if(x+y <= 1000 and !stored[x+y]){\\n                                     dp[i][j].push_back({x+y});\\n                                        stored[x+y] = 1;\\n                                    }\\n                                }       \\n                            }          \\n                        else \\n                            for(int x : dp[i][k]){\\n                                for(int y : dp[k+1][j]){\\n                                    if(x*y <= 1000 and !stored[x*y]){\\n                                        dp[i][j].push_back({x*y});\\n                                        stored[x*y] = 1;\\n                                    }\\n                                }          \\n                            }    \\n                    }\\n                }\\n            }\\n        }\\n    }\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        diffWaysToCompute(s);\\n        bool visited[1001];\\n        memset(visited , 0 , sizeof(visited));\\n        for (int x :dp[0][dp.size()-1] ) if(x<= 1000) visited[x] = 1;\\n        int correct = 0;\\n        for (int i = 1, j = 0; i <= s.size(); i += 2) \\n        if (i == s.size() || s[i] == \\'+\\') {\\n            int mul = 1;\\n            for (; j < i; j += 2)\\n                mul *= s[j] - \\'0\\';\\n            correct += mul;\\n        }\\n        int count = 0;\\n        for(int x : answers){\\n            if (x == correct) \\n                count+=5;\\n            else if(visited[x]) \\n                count+=2;\\n        }\\n        return count;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1544505,
                "title": "python-recursion-with-thought-process-when-being-asked-on-interviews",
                "content": "### Recursion + Memoziation\\nYou might think this is a similar problem with implementing calculator at the first glance, but it turned out that the expression is with a couple of limits, only `+` and `*` are supported on single digit, which indicates that the pattern of expression is known and we can quickly get the operators.\\nBesides, there is no restriction forbiding to use `eval`, so we can quickly get the correct answer using `eval`.\\n\\nHowever, we still need know the answers that are calculated based on different orders. Should we preprocess all of answers or calculate for each `anwser` on demand?\\nSince the number of answer is `10**4`, and the maximum length of `s` is `31`, the time complexity of `30 ** 2` is much smaller than `10 **4`. So we should preprocess all of answers, and simply scan the `answer` to sum up the score by checking if the `answer` exists in the results set.\\n\\nBut how we can calculate all of answers with different orders? We can split up the expression by each operator and recusively calcualte the `left` part and `right` part repectively, then combine the result using the operator. If you resolved recursive problems, such as `construct all possible binary tree`, you won\\'t feel strage about this approach.\\nThe base case is that there only is one digit, then simply return the value.\\n\\nFinally use memoziation to store the result for each sub expression to save time.\\nHowever, you would see TLE with this approach, because we can still improve the performance by the limits of the maximum possible `answer` being `1000`. So once the result is more than `1000`, we needn\\'t include it in the result set.\\n\\n```python\\ndef scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        \\n\\t@cache\\n    def helper(i, j):\\n\\t\\tif i == j:\\n\\t\\t\\treturn {int(s[i])}\\n\\t\\tresults = set()\\n\\t\\tfor k in range(i + 1, j, 2):\\n\\t\\t\\tleft = helper(i, k - 1)\\n            right = helper(k + 1, j)\\n            oper = operator.add if s[k] == \\'+\\' else operator.mul\\n            for l in left:\\n\\t\\t\\t\\tfor r in right:\\n\\t\\t\\t\\t\\tans = oper(l, r)\\n                    if ans <= 1000:\\n\\t\\t\\t\\t\\t\\tresults.add(ans)\\n\\t\\treturn results\\n\\n\\tcorrect = eval(s)\\n    results = helper(0, len(s) - 1)\\n    return sum(5 if a == correct else (2 if a in results else 0) for a in answers)\\n```\\n",
                "solutionTags": [],
                "code": "```python\\ndef scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        \\n\\t@cache\\n    def helper(i, j):\\n\\t\\tif i == j:\\n\\t\\t\\treturn {int(s[i])}\\n\\t\\tresults = set()\\n\\t\\tfor k in range(i + 1, j, 2):\\n\\t\\t\\tleft = helper(i, k - 1)\\n            right = helper(k + 1, j)\\n            oper = operator.add if s[k] == \\'+\\' else operator.mul\\n            for l in left:\\n\\t\\t\\t\\tfor r in right:\\n\\t\\t\\t\\t\\tans = oper(l, r)\\n                    if ans <= 1000:\\n\\t\\t\\t\\t\\t\\tresults.add(ans)\\n\\t\\treturn results\\n\\n\\tcorrect = eval(s)\\n    results = helper(0, len(s) - 1)\\n    return sum(5 if a == correct else (2 if a in results else 0) for a in answers)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1504096,
                "title": "just-zoning-dp-but-very-annoyed-that-you-need-to-prune-on-1000-condition-or-tle",
                "content": "```scala\\n  def scoreOfStudents(s: String, answers: Array[Int]): Int = {\\n\\n    type int = Int\\n    val len = s.length\\n\\n    var i = 0\\n\\n    var corr = 0\\n\\n    import scala.collection.mutable.{HashSet, Stack, HashMap}\\n    val stack = new Stack[int]\\n    i = 0\\n    while (i < len) {\\n      val curr = s.charAt(i)\\n      if (curr.isDigit) {\\n        stack push (curr - \\'0\\').toInt\\n        i += 1\\n      } else {\\n        if (curr == \\'+\\') {\\n          i += 1\\n        } else {\\n          val next = (s.charAt(i + 1) - \\'0\\').toInt\\n          stack.push(next * stack.pop())\\n          i += 2\\n        }\\n      }\\n    }\\n\\n    val memo = Array.ofDim[HashSet[int]](len, len)\\n    while (stack.nonEmpty) corr += stack.pop()\\n\\n    def f(start: int, end: int): HashSet[int] = {\\n      if (memo(start)(end) != null) return memo(start)(end)\\n      val res = new HashSet[int]\\n      if (start == end) {\\n        res += (s.charAt(end) - \\'0\\').toInt\\n      } else {\\n        (start + 1 until end).foreach(i => {\\n          if (!s.charAt(i).isDigit) {\\n            val left  = f(start, i - 1)\\n            val right = f(i + 1, end)\\n            for (l <- left) for (r <- right) if (s.charAt(i) == \\'+\\') {\\n              if ((l + r) <= 1000) res += (l + r)\\n            } else {\\n              if ((l * r) <= 1000) res += (l * r)\\n            }\\n          }\\n\\n        })\\n      }\\n      memo(start)(end) = res\\n\\n      res\\n    }\\n\\n    val set = f(0, len - 1)\\n\\n    answers\\n      .map(a => {\\n        if (a == corr) 5 else if (set.contains(a)) 2 else 0\\n      })\\n      .sum\\n\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n  def scoreOfStudents(s: String, answers: Array[Int]): Int = {\\n\\n    type int = Int\\n    val len = s.length\\n\\n    var i = 0\\n\\n    var corr = 0\\n\\n    import scala.collection.mutable.{HashSet, Stack, HashMap}\\n    val stack = new Stack[int]\\n    i = 0\\n    while (i < len) {\\n      val curr = s.charAt(i)\\n      if (curr.isDigit) {\\n        stack push (curr - \\'0\\').toInt\\n        i += 1\\n      } else {\\n        if (curr == \\'+\\') {\\n          i += 1\\n        } else {\\n          val next = (s.charAt(i + 1) - \\'0\\').toInt\\n          stack.push(next * stack.pop())\\n          i += 2\\n        }\\n      }\\n    }\\n\\n    val memo = Array.ofDim[HashSet[int]](len, len)\\n    while (stack.nonEmpty) corr += stack.pop()\\n\\n    def f(start: int, end: int): HashSet[int] = {\\n      if (memo(start)(end) != null) return memo(start)(end)\\n      val res = new HashSet[int]\\n      if (start == end) {\\n        res += (s.charAt(end) - \\'0\\').toInt\\n      } else {\\n        (start + 1 until end).foreach(i => {\\n          if (!s.charAt(i).isDigit) {\\n            val left  = f(start, i - 1)\\n            val right = f(i + 1, end)\\n            for (l <- left) for (r <- right) if (s.charAt(i) == \\'+\\') {\\n              if ((l + r) <= 1000) res += (l + r)\\n            } else {\\n              if ((l * r) <= 1000) res += (l * r)\\n            }\\n          }\\n\\n        })\\n      }\\n      memo(start)(end) = res\\n\\n      res\\n    }\\n\\n    val set = f(0, len - 1)\\n\\n    answers\\n      .map(a => {\\n        if (a == corr) 5 else if (set.contains(a)) 2 else 0\\n      })\\n      .sum\\n\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1493968,
                "title": "readable-java-code",
                "content": "Based on : https://leetcode.com/problems/the-score-of-students-solving-math-expression/discuss/1486306/PythonJava-Explanation-with-pictures-DP\\n\\n```\\nclass Solution {\\n    public int scoreOfStudents(String s, int[] answers) {\\n        StringBuilder numbers = new StringBuilder();\\n        StringBuilder operators = new StringBuilder();\\n        int len = s.length();\\n        \\n        for(int idx = 0;idx<len;idx++){\\n            char ch = s.charAt(idx);\\n            if(ch==\\'+\\'||ch==\\'*\\') operators.append(ch);\\n            else numbers.append(ch);\\n        }\\n        \\n        len = numbers.length();\\n        \\n        HashSet<Integer>[][] dp = new HashSet[len][len]; \\n        for(int row =0;row<len;row++){\\n            for(int col =0;col<len;col++) dp[row][col] = new HashSet();\\n        }\\n        \\n        //dp[start][end] is a HashSet, which stores all the possible values of the    \\n        //expression from index start to end \\n        \\n        for(int gap = 0;gap<len;gap++){ // gap between start and end\\n            for(int start = 0 , end =gap;end<len;start++,end++){\\n                if(gap==0){\\n                    dp[start][end].add(numbers.charAt(start)-\\'0\\');\\n                }else{\\n                    for(int operatorIdx =start;operatorIdx<=end-1;operatorIdx++){\\n                        HashSet<Integer> leftSet = dp[start][operatorIdx];\\n                        HashSet<Integer> rightSet = dp[operatorIdx+1][end];\\n                        char operator = operators.charAt(operatorIdx);\\n                        // cross left and right evaluations and \\n                        // evaluate current expression\\n                        for(int leftEval : leftSet){\\n                            for(int rightEval : rightSet){\\n                                 if(operator==\\'+\\'){\\n                                     int eval = leftEval+rightEval; \\n                                     // answer belongs in [0,1000] (constraints)\\n                                     // pruning it \\n                                     if(eval>1000) continue; \\n                                     dp[start][end].add(eval);\\n                                 }else if(operator==\\'*\\'){\\n                                     int eval = leftEval*rightEval; \\n                                     if(eval>1000) continue; \\n                                     dp[start][end].add(eval);\\n                                 }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // all evaluations are in dp[0][n-1]\\n        HashSet<Integer> evaluations = dp[0][len - 1];\\n        \\n        int correctAns = getCorrectAns(s);\\n        \\n        int totalScore =0;\\n        for(int answer : answers){\\n            if(answer==correctAns) totalScore+=5;\\n            else if(evaluations.contains(answer)) totalScore+=2;\\n        }\\n        \\n        return totalScore;\\n    }\\n    \\n    private int getCorrectAns(String s){ // can be implemented in constant space , look up basic calculator 2\\'s (LeetCode 227) discuss for the same\\n        Stack<Integer> numberStack = new Stack();\\n        Stack<Character> operatorStack = new Stack();\\n        \\n        for(int idx =0 ;idx<s.length();idx++){\\n            char ch = s.charAt(idx);\\n            if(ch==\\'+\\'||ch==\\'*\\'){\\n            while(operatorStack.size()>0&&precedence(operatorStack.peek())>=precedence(ch)){\\n                 char operator = operatorStack.pop();\\n                 int numB = numberStack.pop();\\n                 int numA = numberStack.pop();\\n                 int eval = evaluate(numA,numB,operator);\\n                 numberStack.push(eval);\\n            }\\n                 operatorStack.push(ch);\\n            }else{\\n                 numberStack.push(ch-\\'0\\');\\n            }\\n        }\\n        \\n        while(operatorStack.size()>0){\\n                char operator = operatorStack.pop();\\n                int numB = numberStack.pop();\\n                int numA = numberStack.pop();\\n                int eval = evaluate(numA,numB,operator);\\n                numberStack.push(eval);\\n        }\\n        \\n        return numberStack.pop();\\n    }\\n    \\n    private int precedence(char operator){\\n        if(operator==\\'+\\') return 1;\\n        else return 2;\\n    }\\n    \\n    private int evaluate(int numA , int numB , char operator){\\n        if(operator==\\'+\\') return numA+numB;\\n        return numA*numB;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int scoreOfStudents(String s, int[] answers) {\\n        StringBuilder numbers = new StringBuilder();\\n        StringBuilder operators = new StringBuilder();\\n        int len = s.length();\\n        \\n        for(int idx = 0;idx<len;idx++){\\n            char ch = s.charAt(idx);\\n            if(ch==\\'+\\'||ch==\\'*\\') operators.append(ch);\\n            else numbers.append(ch);\\n        }\\n        \\n        len = numbers.length();\\n        \\n        HashSet<Integer>[][] dp = new HashSet[len][len]; \\n        for(int row =0;row<len;row++){\\n            for(int col =0;col<len;col++) dp[row][col] = new HashSet();\\n        }\\n        \\n        //dp[start][end] is a HashSet, which stores all the possible values of the    \\n        //expression from index start to end \\n        \\n        for(int gap = 0;gap<len;gap++){ // gap between start and end\\n            for(int start = 0 , end =gap;end<len;start++,end++){\\n                if(gap==0){\\n                    dp[start][end].add(numbers.charAt(start)-\\'0\\');\\n                }else{\\n                    for(int operatorIdx =start;operatorIdx<=end-1;operatorIdx++){\\n                        HashSet<Integer> leftSet = dp[start][operatorIdx];\\n                        HashSet<Integer> rightSet = dp[operatorIdx+1][end];\\n                        char operator = operators.charAt(operatorIdx);\\n                        // cross left and right evaluations and \\n                        // evaluate current expression\\n                        for(int leftEval : leftSet){\\n                            for(int rightEval : rightSet){\\n                                 if(operator==\\'+\\'){\\n                                     int eval = leftEval+rightEval; \\n                                     // answer belongs in [0,1000] (constraints)\\n                                     // pruning it \\n                                     if(eval>1000) continue; \\n                                     dp[start][end].add(eval);\\n                                 }else if(operator==\\'*\\'){\\n                                     int eval = leftEval*rightEval; \\n                                     if(eval>1000) continue; \\n                                     dp[start][end].add(eval);\\n                                 }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // all evaluations are in dp[0][n-1]\\n        HashSet<Integer> evaluations = dp[0][len - 1];\\n        \\n        int correctAns = getCorrectAns(s);\\n        \\n        int totalScore =0;\\n        for(int answer : answers){\\n            if(answer==correctAns) totalScore+=5;\\n            else if(evaluations.contains(answer)) totalScore+=2;\\n        }\\n        \\n        return totalScore;\\n    }\\n    \\n    private int getCorrectAns(String s){ // can be implemented in constant space , look up basic calculator 2\\'s (LeetCode 227) discuss for the same\\n        Stack<Integer> numberStack = new Stack();\\n        Stack<Character> operatorStack = new Stack();\\n        \\n        for(int idx =0 ;idx<s.length();idx++){\\n            char ch = s.charAt(idx);\\n            if(ch==\\'+\\'||ch==\\'*\\'){\\n            while(operatorStack.size()>0&&precedence(operatorStack.peek())>=precedence(ch)){\\n                 char operator = operatorStack.pop();\\n                 int numB = numberStack.pop();\\n                 int numA = numberStack.pop();\\n                 int eval = evaluate(numA,numB,operator);\\n                 numberStack.push(eval);\\n            }\\n                 operatorStack.push(ch);\\n            }else{\\n                 numberStack.push(ch-\\'0\\');\\n            }\\n        }\\n        \\n        while(operatorStack.size()>0){\\n                char operator = operatorStack.pop();\\n                int numB = numberStack.pop();\\n                int numA = numberStack.pop();\\n                int eval = evaluate(numA,numB,operator);\\n                numberStack.push(eval);\\n        }\\n        \\n        return numberStack.pop();\\n    }\\n    \\n    private int precedence(char operator){\\n        if(operator==\\'+\\') return 1;\\n        else return 2;\\n    }\\n    \\n    private int evaluate(int numA , int numB , char operator){\\n        if(operator==\\'+\\') return numA+numB;\\n        return numA*numB;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490471,
                "title": "c-solution",
                "content": "Each operator may be the last executed operator. There are `n` decisions (which operator is the last operator). For each last operator, we calculate its left hand operand and right hand operand. Then calculate (`+` or `*`) them.\\n\\n\\n```c++\\nclass Solution {\\n   public:\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        const auto true_ans = calc_true_ans(s);\\n        const auto possible_ans = calc_possible_ans(s);\\n        int total = 0;\\n        for (auto ans : answers) {\\n            if (ans == true_ans) {\\n                total += 5;\\n            } else if (possible_ans.count(ans)) {\\n                total += 2;\\n            }\\n        }\\n        return total;\\n    }\\n\\n    int calc_true_ans(string_view s) {\\n        int partial_ans = s[0] - \\'0\\';\\n        int ans = 0;\\n        for (int i = 2; i < s.size(); i += 2) {\\n            if (s[i - 1] == \\'+\\') {\\n                ans += partial_ans;\\n                partial_ans = s[i] - \\'0\\';\\n            } else {\\n                partial_ans *= s[i] - \\'0\\';\\n            }\\n        }\\n        return ans + partial_ans;\\n    }\\n\\n    unordered_set<int> calc_possible_ans(string_view s) {\\n        const auto n = s.size();\\n        vector dp(n, vector<unordered_set<int>>(n));\\n\\n        // dp[i][j] contains the possible result of s[i:j]\\n        for (int i = n - 1; i >= 0; i -= 2) {\\n            dp[i][i].insert(s[i] - \\'0\\');\\n            for (int j = i + 2; j < n; j += 2) {\\n                for (int k = i + 1; k < j; k += 2) {\\n                    for (auto lhs : dp[i][k - 1]) {\\n                        for (auto rhs : dp[k + 1][j]) {\\n                            const auto r = calc(s[k], lhs, rhs);\\n                            if (r <= 1000) {\\n                                dp[i][j].insert(r);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[0][n - 1];\\n    }\\n\\n    int calc(char c, int lhs, int rhs) {\\n        if (c == \\'+\\') {\\n            return lhs + rhs;\\n        }\\n        return lhs * rhs;\\n    }\\n};\\n```\\n\\nPlease reply me if any question.",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\n   public:\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        const auto true_ans = calc_true_ans(s);\\n        const auto possible_ans = calc_possible_ans(s);\\n        int total = 0;\\n        for (auto ans : answers) {\\n            if (ans == true_ans) {\\n                total += 5;\\n            } else if (possible_ans.count(ans)) {\\n                total += 2;\\n            }\\n        }\\n        return total;\\n    }\\n\\n    int calc_true_ans(string_view s) {\\n        int partial_ans = s[0] - \\'0\\';\\n        int ans = 0;\\n        for (int i = 2; i < s.size(); i += 2) {\\n            if (s[i - 1] == \\'+\\') {\\n                ans += partial_ans;\\n                partial_ans = s[i] - \\'0\\';\\n            } else {\\n                partial_ans *= s[i] - \\'0\\';\\n            }\\n        }\\n        return ans + partial_ans;\\n    }\\n\\n    unordered_set<int> calc_possible_ans(string_view s) {\\n        const auto n = s.size();\\n        vector dp(n, vector<unordered_set<int>>(n));\\n\\n        // dp[i][j] contains the possible result of s[i:j]\\n        for (int i = n - 1; i >= 0; i -= 2) {\\n            dp[i][i].insert(s[i] - \\'0\\');\\n            for (int j = i + 2; j < n; j += 2) {\\n                for (int k = i + 1; k < j; k += 2) {\\n                    for (auto lhs : dp[i][k - 1]) {\\n                        for (auto rhs : dp[k + 1][j]) {\\n                            const auto r = calc(s[k], lhs, rhs);\\n                            if (r <= 1000) {\\n                                dp[i][j].insert(r);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[0][n - 1];\\n    }\\n\\n    int calc(char c, int lhs, int rhs) {\\n        if (c == \\'+\\') {\\n            return lhs + rhs;\\n        }\\n        return lhs * rhs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490101,
                "title": "c-2019-the-score-of-students-solving-math-expression",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        int n = s.size(); \\n        vector<int> stk; \\n        for (int i = 0; i < n; i += 2) {\\n            int x = s[i] - \\'0\\'; \\n            if (i && s[i-1] == \\'*\\') stk.back() *= x; \\n            else stk.push_back(x); \\n        }\\n        int target = accumulate(stk.begin(), stk.end(), 0); \\n        \\n        vector<vector<unordered_set<int>>> dp(n, vector<unordered_set<int>>(n)); \\n        for (int lo = n-1; lo >= 0; lo -= 2) \\n            for (int hi = lo; hi < n; hi += 2) \\n                if (lo == hi) dp[lo][hi] = {s[lo] - \\'0\\'}; \\n                else \\n                    for (int mid = lo+1; mid < hi; mid += 2) \\n                        for (auto& x : dp[lo][mid-1]) \\n                            for (auto& y : dp[mid+1][hi]) \\n                                if (s[mid] == \\'+\\' && x + y <= 1000) dp[lo][hi].insert(x+y); \\n                                else if (s[mid] == \\'*\\' && x * y <= 1000) dp[lo][hi].insert(x*y); \\n        \\n        int ans = 0; \\n        for (auto& x : answers) {\\n            if (x == target) ans += 5; \\n            else if (dp[0][n-1].count(x)) ans += 2; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        int n = s.size(); \\n        vector<int> stk; \\n        for (int i = 0; i < n; i += 2) {\\n            int x = s[i] - \\'0\\'; \\n            if (i && s[i-1] == \\'*\\') stk.back() *= x; \\n            else stk.push_back(x); \\n        }\\n        int target = accumulate(stk.begin(), stk.end(), 0); \\n        \\n        vector<vector<unordered_set<int>>> dp(n, vector<unordered_set<int>>(n)); \\n        for (int lo = n-1; lo >= 0; lo -= 2) \\n            for (int hi = lo; hi < n; hi += 2) \\n                if (lo == hi) dp[lo][hi] = {s[lo] - \\'0\\'}; \\n                else \\n                    for (int mid = lo+1; mid < hi; mid += 2) \\n                        for (auto& x : dp[lo][mid-1]) \\n                            for (auto& y : dp[mid+1][hi]) \\n                                if (s[mid] == \\'+\\' && x + y <= 1000) dp[lo][hi].insert(x+y); \\n                                else if (s[mid] == \\'*\\' && x * y <= 1000) dp[lo][hi].insert(x*y); \\n        \\n        int ans = 0; \\n        for (auto& x : answers) {\\n            if (x == target) ans += 5; \\n            else if (dp[0][n-1].count(x)) ans += 2; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488678,
                "title": "scala-top-down-dp-using-for-comprehension-for-cartesian-product-of-left-right",
                "content": "Scala adaptation of the solution well described here: https://leetcode.com/problems/the-score-of-students-solving-math-expression/discuss/1486991/312.-Burst-Balloons\\n\\n```\\n  def scoreOfStudents(s: String, answers: Array[Int]): Int = {\\n    val correctAnswer = (1 to s.length by 2)\\n      .filter(i => i == s.length || s(i) == \\'+\\')\\n      .foldLeft(0, 0) {\\n        case ((sum, j), i) =>\\n          val localProduct = (j until i by 2).foldLeft(1) {\\n            case (product, k) =>\\n              product * (s(k) - \\'0\\')\\n          }\\n          (sum + localProduct, i + 1)\\n    }._1\\n\\n    val mem = mutable.Map.empty[(Int, Int), Set[Int]]\\n\\n    def dfs(startIdx: Int, endIdx: Int): Set[Int] = {\\n      if (endIdx - startIdx == 1) return Set(s(startIdx) - \\'0\\')\\n      if (mem.contains((startIdx, endIdx))) return mem((startIdx, endIdx))\\n\\n      val results = for {\\n        splitIdx    <- startIdx + 1 until endIdx by 2\\n        leftResult  <- dfs(startIdx, splitIdx)\\n        rightResult <- dfs(splitIdx + 1, endIdx)\\n        result = if (s(splitIdx) == \\'+\\') leftResult + rightResult else leftResult * rightResult\\n        if result <= 1000\\n      } yield result\\n\\n      mem.update((startIdx, endIdx), results.toSet)\\n      mem((startIdx, endIdx))\\n    }\\n\\n    val results = dfs(startIdx = 0, endIdx = s.length)\\n\\t\\n    answers.map { answer =>\\n      if (answer == correctAnswer) 5\\n      else if (results.contains(answer)) 2\\n      else 0\\n    }.sum\\n  }\\n```",
                "solutionTags": [
                    "Scala",
                    "Dynamic Programming"
                ],
                "code": "```\\n  def scoreOfStudents(s: String, answers: Array[Int]): Int = {\\n    val correctAnswer = (1 to s.length by 2)\\n      .filter(i => i == s.length || s(i) == \\'+\\')\\n      .foldLeft(0, 0) {\\n        case ((sum, j), i) =>\\n          val localProduct = (j until i by 2).foldLeft(1) {\\n            case (product, k) =>\\n              product * (s(k) - \\'0\\')\\n          }\\n          (sum + localProduct, i + 1)\\n    }._1\\n\\n    val mem = mutable.Map.empty[(Int, Int), Set[Int]]\\n\\n    def dfs(startIdx: Int, endIdx: Int): Set[Int] = {\\n      if (endIdx - startIdx == 1) return Set(s(startIdx) - \\'0\\')\\n      if (mem.contains((startIdx, endIdx))) return mem((startIdx, endIdx))\\n\\n      val results = for {\\n        splitIdx    <- startIdx + 1 until endIdx by 2\\n        leftResult  <- dfs(startIdx, splitIdx)\\n        rightResult <- dfs(splitIdx + 1, endIdx)\\n        result = if (s(splitIdx) == \\'+\\') leftResult + rightResult else leftResult * rightResult\\n        if result <= 1000\\n      } yield result\\n\\n      mem.update((startIdx, endIdx), results.toSet)\\n      mem((startIdx, endIdx))\\n    }\\n\\n    val results = dfs(startIdx = 0, endIdx = s.length)\\n\\t\\n    answers.map { answer =>\\n      if (answer == correctAnswer) 5\\n      else if (results.contains(answer)) 2\\n      else 0\\n    }.sum\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1487463,
                "title": "is-time-limit-too-restrictive",
                "content": "Wondering whether the time-limit is too restrictive or I am missing some optimization.\\n\\n```\\nunordered_set<int>dp[41][41];\\nclass Solution {\\npublic:\\n    int finalres;\\n    int correct(int i, int j, const string& s) {\\n        for(int k=j;k>=i;k--) {\\n            if(s[k] == \\'+\\') {\\n                return correct(i,k-1, s) + correct(k+1, j, s);\\n            }\\n        }\\n        for(int k=j;k>=i;k--) {\\n            if(s[k] == \\'*\\') {\\n                return correct(i,k-1, s) * correct(k+1, j, s);\\n            }\\n        }\\n        return (s[i] - \\'0\\');\\n    }\\n    \\n    void fdp(const string& s) {\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] != \\'+\\' && s[i] != \\'*\\') {\\n                dp[i][i] = {s[i] - \\'0\\'};\\n            }\\n        }\\n        for(int sz = 2;sz<=s.size();sz++) {\\n            for(int i=0;i<s.size();i++) {\\n                int j = i + sz - 1;\\n                if(j >= s.size()) break;\\n                if(s[j] != \\'+\\' && s[j] != \\'*\\' && s[i] != \\'+\\' && s[i] != \\'*\\') {\\n                    dp[i][j] = {};\\n                    for(int k=i;k<=j;k++){\\n                        if(s[k] == \\'+\\') {\\n                            unordered_set<int> &L = dp[i][k-1];\\n                            unordered_set<int> &R = dp[k+1][j];\\n                            for(auto&x : L) {\\n                                for(auto&y : R) {\\n                                    dp[i][j].insert(x + y);\\n                                }\\n                            }\\n                        }\\n                        if(s[k] == \\'*\\') {\\n                            unordered_set<int> &L = dp[i][k-1];\\n                            unordered_set<int> &R = dp[k+1][j];\\n                            for(auto&x : L) {\\n                                for(auto&y : R) {\\n                                    dp[i][j].insert(x * y);\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        finalres = correct(0, s.size()-1, s);\\n        fdp(s);//dp(0, s.size()-1, s);\\n        int res = 0;\\n        for(int i=0;i<answers.size();i++) {\\n            if(finalres == answers[i]) res+=5;\\n            else if(dp[0][s.size()-1].find(answers[i]) != dp[0][s.size()-1].end()) res +=2;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nunordered_set<int>dp[41][41];\\nclass Solution {\\npublic:\\n    int finalres;\\n    int correct(int i, int j, const string& s) {\\n        for(int k=j;k>=i;k--) {\\n            if(s[k] == \\'+\\') {\\n                return correct(i,k-1, s) + correct(k+1, j, s);\\n            }\\n        }\\n        for(int k=j;k>=i;k--) {\\n            if(s[k] == \\'*\\') {\\n                return correct(i,k-1, s) * correct(k+1, j, s);\\n            }\\n        }\\n        return (s[i] - \\'0\\');\\n    }\\n    \\n    void fdp(const string& s) {\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] != \\'+\\' && s[i] != \\'*\\') {\\n                dp[i][i] = {s[i] - \\'0\\'};\\n            }\\n        }\\n        for(int sz = 2;sz<=s.size();sz++) {\\n            for(int i=0;i<s.size();i++) {\\n                int j = i + sz - 1;\\n                if(j >= s.size()) break;\\n                if(s[j] != \\'+\\' && s[j] != \\'*\\' && s[i] != \\'+\\' && s[i] != \\'*\\') {\\n                    dp[i][j] = {};\\n                    for(int k=i;k<=j;k++){\\n                        if(s[k] == \\'+\\') {\\n                            unordered_set<int> &L = dp[i][k-1];\\n                            unordered_set<int> &R = dp[k+1][j];\\n                            for(auto&x : L) {\\n                                for(auto&y : R) {\\n                                    dp[i][j].insert(x + y);\\n                                }\\n                            }\\n                        }\\n                        if(s[k] == \\'*\\') {\\n                            unordered_set<int> &L = dp[i][k-1];\\n                            unordered_set<int> &R = dp[k+1][j];\\n                            for(auto&x : L) {\\n                                for(auto&y : R) {\\n                                    dp[i][j].insert(x * y);\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        finalres = correct(0, s.size()-1, s);\\n        fdp(s);//dp(0, s.size()-1, s);\\n        int res = 0;\\n        for(int i=0;i<answers.size();i++) {\\n            if(finalres == answers[i]) res+=5;\\n            else if(dp[0][s.size()-1].find(answers[i]) != dp[0][s.size()-1].end()) res +=2;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486752,
                "title": "c-easy-and-clean-dfs",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        int answer = FindCorrectAnswer(s);\\n        int score = 0;\\n        auto possible_answer = dfs(0, N - 1);\\n        for (auto v: answers) {\\n            if (v == answer) score += 5;\\n            else if (possible_answer.count(v)) score += 2;\\n        }        \\n        return score;\\n    }\\n    \\nprivate:\\n    int N;\\n    unordered_map<int, unordered_set<int>> um;\\n    vector<int> operands;\\n    vector<char> ops;\\n    \\n    // inclusive start, end\\n    unordered_set<int> dfs(int start, int end) {\\n        if (start == end) return {operands[start]};\\n        if (start + 1 == end) {\\n            return {Operate(operands[start], operands[start + 1], ops[start])};\\n        }   \\n        if (um.count(start * N + end)) return um[start * N + end];\\n        \\n        unordered_set<int> res;\\n        \\n        for (int mid = start; mid < end; ++mid) {\\n            auto v1s = dfs(start, mid);\\n            auto op = ops[mid];\\n            auto v2s = dfs(mid + 1, end);\\n            for (auto v1: v1s) for (auto v2: v2s) {\\n                auto v = Operate(v1, v2, op);\\n                if (v <= 1000)\\n                res.insert(Operate(v1, v2, op));\\n            }\\n        }\\n        \\n        um[start * N + end] = res;\\n        return res;\\n    }\\n    \\n    int ParseNextNumber(const string &s, int & idx) {\\n        int r = 0;\\n        while (idx < s.size() && s[idx] >= \\'0\\' && s[idx] <= \\'9\\') {\\n            r = r * 10 + s[idx] - \\'0\\';\\n            idx++;\\n        }\\n\\n        return r;\\n    }\\n    \\n    constexpr int Operate(int v1, int v2, char op) {\\n        if (op == \\'*\\') return v1 * v2;\\n        return v1 + v2;\\n    }\\n    \\n    int FindCorrectAnswer(const string &s) {\\n        int idx = 0;\\n        vector<int> remain_operands;\\n        \\n        while (idx < s.size()) {\\n            operands.push_back(ParseNextNumber(s, idx));\\n            remain_operands.push_back(operands.back());\\n            while (idx < s.size() && s[idx] == \\'*\\') {\\n                ops.push_back(s[idx++]);\\n                operands.push_back(ParseNextNumber(s, idx));\\n                remain_operands.back() *= operands.back();\\n            }\\n            if (idx < s.size()) ops.push_back(s[idx++]);\\n        }\\n        int answer = 0;\\n        for (auto opr: remain_operands) answer += opr;\\n        N = operands.size();\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        int answer = FindCorrectAnswer(s);\\n        int score = 0;\\n        auto possible_answer = dfs(0, N - 1);\\n        for (auto v: answers) {\\n            if (v == answer) score += 5;\\n            else if (possible_answer.count(v)) score += 2;\\n        }        \\n        return score;\\n    }\\n    \\nprivate:\\n    int N;\\n    unordered_map<int, unordered_set<int>> um;\\n    vector<int> operands;\\n    vector<char> ops;\\n    \\n    // inclusive start, end\\n    unordered_set<int> dfs(int start, int end) {\\n        if (start == end) return {operands[start]};\\n        if (start + 1 == end) {\\n            return {Operate(operands[start], operands[start + 1], ops[start])};\\n        }   \\n        if (um.count(start * N + end)) return um[start * N + end];\\n        \\n        unordered_set<int> res;\\n        \\n        for (int mid = start; mid < end; ++mid) {\\n            auto v1s = dfs(start, mid);\\n            auto op = ops[mid];\\n            auto v2s = dfs(mid + 1, end);\\n            for (auto v1: v1s) for (auto v2: v2s) {\\n                auto v = Operate(v1, v2, op);\\n                if (v <= 1000)\\n                res.insert(Operate(v1, v2, op));\\n            }\\n        }\\n        \\n        um[start * N + end] = res;\\n        return res;\\n    }\\n    \\n    int ParseNextNumber(const string &s, int & idx) {\\n        int r = 0;\\n        while (idx < s.size() && s[idx] >= \\'0\\' && s[idx] <= \\'9\\') {\\n            r = r * 10 + s[idx] - \\'0\\';\\n            idx++;\\n        }\\n\\n        return r;\\n    }\\n    \\n    constexpr int Operate(int v1, int v2, char op) {\\n        if (op == \\'*\\') return v1 * v2;\\n        return v1 + v2;\\n    }\\n    \\n    int FindCorrectAnswer(const string &s) {\\n        int idx = 0;\\n        vector<int> remain_operands;\\n        \\n        while (idx < s.size()) {\\n            operands.push_back(ParseNextNumber(s, idx));\\n            remain_operands.push_back(operands.back());\\n            while (idx < s.size() && s[idx] == \\'*\\') {\\n                ops.push_back(s[idx++]);\\n                operands.push_back(ParseNextNumber(s, idx));\\n                remain_operands.back() *= operands.back();\\n            }\\n            if (idx < s.size()) ops.push_back(s[idx++]);\\n        }\\n        int answer = 0;\\n        for (auto opr: remain_operands) answer += opr;\\n        N = operands.size();\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486502,
                "title": "topdown-dp-with-c-tle-anybody-has-luck-with-topdown-dp",
                "content": "Not sure why this topdown approach got TLE. Seems same idea with bottom up is OK.\\nWith the result <=1000 optimization, I got more test passed but still got TLE.\\nAlso I doubt we can use the result <= 1000 optimization, except the last step (i.e., the whole expression). An intermediate value of >1000 should be acceptable, because it can be * 0 and then + something. And this something should be getting 2 points.\\n\\nA guess: ```unordered_map<string, unordered_set< int > > memo``` is too expensive, and better use ```vector<vector<unordered_set< int >> memo``` ? Or even change the ```unordered_set to vector< int >(1001)```?? but if s[i,j] == s[i1, j1], then the map approach doesn\\'t need to save two copies, meaning the map approach is even better.\\n\\nSo if this is the reason I got TLE, I don\\'t think this is a good criteria for this problem.\\n\\nHere is my code:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    unordered_set<int> helper(const string& s, unordered_map<string, unordered_set<int>>& memo) {\\n        if (memo[s].size()) return memo[s];\\n        \\n        unordered_set<int> res;\\n        int n = s.size();\\n        if (n==1) {\\n            res.insert(s[0] - \\'0\\');\\n            memo[s] = res;\\n            return res;\\n        }\\n                \\n        for (int i=1; i<n; i+=2) {\\n            auto res1 = helper(s.substr(0, i), memo);\\n            auto res2 = helper(s.substr(i+1), memo);\\n            for (auto it1 = res1.begin(); it1!=res1.end(); ++it1) {\\n                for (auto it2 = res2.begin(); it2!=res2.end(); ++it2) {\\n                    int n1 = *it1;\\n                    int n2 = *it2;\\n                    if (s[i] == \\'+\\') {\\n                        res.insert(n1 + n2);\\n                    } else {\\n                        res.insert(n1 * n2);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        memo[s] = res;\\n        return res;\\n    }\\n    \\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        int right= s[0] - \\'0\\';\\n        int pprev = 0;\\n        for (int i=1; i<s.size(); i+=2) {\\n            if (s[i] == \\'+\\') {\\n                pprev = right;\\n                right += s[i+1] - \\'0\\';\\n            } else {\\n                right = (right - pprev) * (s[i+1] - \\'0\\') + pprev;\\n            }\\n        }\\n        \\n        //cout << right << endl;\\n        \\n        unordered_map<string, unordered_set<int>> memo;\\n        unordered_set<int> aa = helper(s, memo);\\n        \\n        //for (int i : aa) cout << i << \" \"; cout << endl;\\n        \\n        int res = 0;\\n        for (int ans : answers) {\\n            if (ans == right) {\\n                res += 5;\\n            } else if (aa.count(ans)) {\\n                res += 2;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```unordered_map<string, unordered_set< int > > memo```\n```vector<vector<unordered_set< int >> memo```\n```unordered_set to vector< int >(1001)```\n```\\nclass Solution {\\npublic:\\n    \\n    unordered_set<int> helper(const string& s, unordered_map<string, unordered_set<int>>& memo) {\\n        if (memo[s].size()) return memo[s];\\n        \\n        unordered_set<int> res;\\n        int n = s.size();\\n        if (n==1) {\\n            res.insert(s[0] - \\'0\\');\\n            memo[s] = res;\\n            return res;\\n        }\\n                \\n        for (int i=1; i<n; i+=2) {\\n            auto res1 = helper(s.substr(0, i), memo);\\n            auto res2 = helper(s.substr(i+1), memo);\\n            for (auto it1 = res1.begin(); it1!=res1.end(); ++it1) {\\n                for (auto it2 = res2.begin(); it2!=res2.end(); ++it2) {\\n                    int n1 = *it1;\\n                    int n2 = *it2;\\n                    if (s[i] == \\'+\\') {\\n                        res.insert(n1 + n2);\\n                    } else {\\n                        res.insert(n1 * n2);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        memo[s] = res;\\n        return res;\\n    }\\n    \\n    int scoreOfStudents(string s, vector<int>& answers) {\\n        int right= s[0] - \\'0\\';\\n        int pprev = 0;\\n        for (int i=1; i<s.size(); i+=2) {\\n            if (s[i] == \\'+\\') {\\n                pprev = right;\\n                right += s[i+1] - \\'0\\';\\n            } else {\\n                right = (right - pprev) * (s[i+1] - \\'0\\') + pprev;\\n            }\\n        }\\n        \\n        //cout << right << endl;\\n        \\n        unordered_map<string, unordered_set<int>> memo;\\n        unordered_set<int> aa = helper(s, memo);\\n        \\n        //for (int i : aa) cout << i << \" \"; cout << endl;\\n        \\n        int res = 0;\\n        for (int ans : answers) {\\n            if (ans == right) {\\n                res += 5;\\n            } else if (aa.count(ans)) {\\n                res += 2;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1486471,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int scoreOfStudents(String s, int[] answers) {\\n        int len = s.length();\\n        \\n        //cache all possible answer for s[i, j]\\n        Set<Integer>[][] dp = new Set[len][len];\\n        for (int i = 0; i < len; i += 2) {\\n            dp[i][i] = new HashSet<>();\\n            dp[i][i].add(s.charAt(i) - \\'0\\');\\n        }\\n        for (int k = 3; k <= len; k += 2) {\\n            for (int start = 0; start + k <= len; start += 2) {\\n                int end = start + k - 1;\\n                dp[start][end] = new HashSet<>();\\n                \\n                for (int op = start + 1; op < end; op += 2) {\\n                    for (int left : dp[start][op - 1]) {\\n                        for (int right : dp[op + 1][end]) {\\n                            int res = s.charAt(op) == \\'*\\' ? left * right : left + right;\\n                            if (res <= 1000) {\\n                                dp[start][end].add(res);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }        \\n        int correct = getAnswer(s);\\n        return getResult(answers, correct, dp[0][len - 1]);\\n    }\\n    \\n    private int getAnswer(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'*\\') {\\n                stack.push(stack.pop() * (s.charAt(++i) - \\'0\\'));\\n            } else if (c != \\'+\\') {\\n                stack.push(s.charAt(i) - \\'0\\');\\n            }\\n        }\\n        int res = 0;\\n        while (!stack.isEmpty()) {\\n            res += stack.pop();\\n        }\\n        return res;\\n    }\\n    \\n    private int getResult(int[] answers, int correct, Set<Integer> incorrect) {\\n        int res = 0;\\n        for (int i = 0; i < answers.length; i++) {\\n            int ans = answers[i];\\n            if (ans == correct) {\\n                res += 5;\\n            } else if (incorrect.contains(ans)) {\\n                res += 2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfStudents(String s, int[] answers) {\\n        int len = s.length();\\n        \\n        //cache all possible answer for s[i, j]\\n        Set<Integer>[][] dp = new Set[len][len];\\n        for (int i = 0; i < len; i += 2) {\\n            dp[i][i] = new HashSet<>();\\n            dp[i][i].add(s.charAt(i) - \\'0\\');\\n        }\\n        for (int k = 3; k <= len; k += 2) {\\n            for (int start = 0; start + k <= len; start += 2) {\\n                int end = start + k - 1;\\n                dp[start][end] = new HashSet<>();\\n                \\n                for (int op = start + 1; op < end; op += 2) {\\n                    for (int left : dp[start][op - 1]) {\\n                        for (int right : dp[op + 1][end]) {\\n                            int res = s.charAt(op) == \\'*\\' ? left * right : left + right;\\n                            if (res <= 1000) {\\n                                dp[start][end].add(res);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }        \\n        int correct = getAnswer(s);\\n        return getResult(answers, correct, dp[0][len - 1]);\\n    }\\n    \\n    private int getAnswer(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'*\\') {\\n                stack.push(stack.pop() * (s.charAt(++i) - \\'0\\'));\\n            } else if (c != \\'+\\') {\\n                stack.push(s.charAt(i) - \\'0\\');\\n            }\\n        }\\n        int res = 0;\\n        while (!stack.isEmpty()) {\\n            res += stack.pop();\\n        }\\n        return res;\\n    }\\n    \\n    private int getResult(int[] answers, int correct, Set<Integer> incorrect) {\\n        int res = 0;\\n        for (int i = 0; i < answers.length; i++) {\\n            int ans = answers[i];\\n            if (ans == correct) {\\n                res += 5;\\n            } else if (incorrect.contains(ans)) {\\n                res += 2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565719,
                "content": [
                    {
                        "username": "flyfy1",
                        "content": "The problem states 2 kind of ordering:\\n\\n1. Compute multiplication, reading from left to right; Then,\\n2. Compute addition, reading from left to right.\\n\\nSo for this:\\n\\n> \"1+4+4+1*0+2\"\\n\\nwhat could be the possible answers? My understanding is:\\n\\n- correct answer: 11\\n- wrong answers: 2, 20\\n\\nthere shouldn\\'t be other wrong answers, because the opportors are applied left-to-right.\\n\\nWhat\\'s wrong with this understanding?"
                    },
                    {
                        "username": "jm3579",
                        "content": "wrong answers get a score if all elementary operations are calculated correctly (e.g. 1+4, 4+4), regardless of the order. For your case, there are 6 wrong answers in total: {2, 3, 7, 15, 19, 20}\n"
                    },
                    {
                        "username": "indawgwetrust",
                        "content": "There is some ambiguity that could use clarification. Here is an example:\\n\\n        Say we get the input string `\"5+3+2*4+9*2\"`\\n        the right answer is `5+3+(2*4)+(9*2)=34`\\n        if addition is done before multiplication, we get `(5+3+2)*(4+9)*2=720`\\n        but what if we group some other way? it the answer still worth 2 points?\\n        For example: \\n        `((5+3)+(2*(4+9)))*2=68` ?\\n        `(5+3+2)*(4+(9*2))=220` ?\\n        `((5+3)+(2*4)+9)*2=50` ?\\n        `5+((3+2)*4)+(9*2)=43` ?\\n        Are 220, 50, and 43 all also valid? Or are the only two valid answers 720 and 34?\\n\\nThe solution will depend on the way we interpret this requirement:\\n  > applied the operators in the wrong order but had correct arithmetic\\n\\nAll of the answers above use the correct arithmetic, but those that are not correct all apply the operations in what could be called the wrong order. When we \"apply the operations\" in some \"order\", are we defining \"operations\" to mean each individual binary operator that occurs in the input, or does it mean \"all instances of operator T\"?"
                    },
                    {
                        "username": "jm3579",
                        "content": "I worked a lot on this problem. Found a solution with dynamic programming, it runs n^4 time complexity (n is the number of operations in the string). It successfully passes all the test cases.\\nIt\\'s very quick on my pc, still I get \"Time Limit Exceeded\" error at various test cases. I suppose it\\'s more due to load of the server then really the performance of my solution, it\\'s pretty annoying."
                    },
                    {
                        "username": "youniesmm9",
                        "content": "bro why do you casually think that leetcode would accept an n^4 solution?"
                    }
                ]
            },
            {
                "id": 1867152,
                "content": [
                    {
                        "username": "flyfy1",
                        "content": "The problem states 2 kind of ordering:\\n\\n1. Compute multiplication, reading from left to right; Then,\\n2. Compute addition, reading from left to right.\\n\\nSo for this:\\n\\n> \"1+4+4+1*0+2\"\\n\\nwhat could be the possible answers? My understanding is:\\n\\n- correct answer: 11\\n- wrong answers: 2, 20\\n\\nthere shouldn\\'t be other wrong answers, because the opportors are applied left-to-right.\\n\\nWhat\\'s wrong with this understanding?"
                    },
                    {
                        "username": "jm3579",
                        "content": "wrong answers get a score if all elementary operations are calculated correctly (e.g. 1+4, 4+4), regardless of the order. For your case, there are 6 wrong answers in total: {2, 3, 7, 15, 19, 20}\n"
                    },
                    {
                        "username": "indawgwetrust",
                        "content": "There is some ambiguity that could use clarification. Here is an example:\\n\\n        Say we get the input string `\"5+3+2*4+9*2\"`\\n        the right answer is `5+3+(2*4)+(9*2)=34`\\n        if addition is done before multiplication, we get `(5+3+2)*(4+9)*2=720`\\n        but what if we group some other way? it the answer still worth 2 points?\\n        For example: \\n        `((5+3)+(2*(4+9)))*2=68` ?\\n        `(5+3+2)*(4+(9*2))=220` ?\\n        `((5+3)+(2*4)+9)*2=50` ?\\n        `5+((3+2)*4)+(9*2)=43` ?\\n        Are 220, 50, and 43 all also valid? Or are the only two valid answers 720 and 34?\\n\\nThe solution will depend on the way we interpret this requirement:\\n  > applied the operators in the wrong order but had correct arithmetic\\n\\nAll of the answers above use the correct arithmetic, but those that are not correct all apply the operations in what could be called the wrong order. When we \"apply the operations\" in some \"order\", are we defining \"operations\" to mean each individual binary operator that occurs in the input, or does it mean \"all instances of operator T\"?"
                    },
                    {
                        "username": "jm3579",
                        "content": "I worked a lot on this problem. Found a solution with dynamic programming, it runs n^4 time complexity (n is the number of operations in the string). It successfully passes all the test cases.\\nIt\\'s very quick on my pc, still I get \"Time Limit Exceeded\" error at various test cases. I suppose it\\'s more due to load of the server then really the performance of my solution, it\\'s pretty annoying."
                    },
                    {
                        "username": "youniesmm9",
                        "content": "bro why do you casually think that leetcode would accept an n^4 solution?"
                    }
                ]
            },
            {
                "id": 1707562,
                "content": [
                    {
                        "username": "flyfy1",
                        "content": "The problem states 2 kind of ordering:\\n\\n1. Compute multiplication, reading from left to right; Then,\\n2. Compute addition, reading from left to right.\\n\\nSo for this:\\n\\n> \"1+4+4+1*0+2\"\\n\\nwhat could be the possible answers? My understanding is:\\n\\n- correct answer: 11\\n- wrong answers: 2, 20\\n\\nthere shouldn\\'t be other wrong answers, because the opportors are applied left-to-right.\\n\\nWhat\\'s wrong with this understanding?"
                    },
                    {
                        "username": "jm3579",
                        "content": "wrong answers get a score if all elementary operations are calculated correctly (e.g. 1+4, 4+4), regardless of the order. For your case, there are 6 wrong answers in total: {2, 3, 7, 15, 19, 20}\n"
                    },
                    {
                        "username": "indawgwetrust",
                        "content": "There is some ambiguity that could use clarification. Here is an example:\\n\\n        Say we get the input string `\"5+3+2*4+9*2\"`\\n        the right answer is `5+3+(2*4)+(9*2)=34`\\n        if addition is done before multiplication, we get `(5+3+2)*(4+9)*2=720`\\n        but what if we group some other way? it the answer still worth 2 points?\\n        For example: \\n        `((5+3)+(2*(4+9)))*2=68` ?\\n        `(5+3+2)*(4+(9*2))=220` ?\\n        `((5+3)+(2*4)+9)*2=50` ?\\n        `5+((3+2)*4)+(9*2)=43` ?\\n        Are 220, 50, and 43 all also valid? Or are the only two valid answers 720 and 34?\\n\\nThe solution will depend on the way we interpret this requirement:\\n  > applied the operators in the wrong order but had correct arithmetic\\n\\nAll of the answers above use the correct arithmetic, but those that are not correct all apply the operations in what could be called the wrong order. When we \"apply the operations\" in some \"order\", are we defining \"operations\" to mean each individual binary operator that occurs in the input, or does it mean \"all instances of operator T\"?"
                    },
                    {
                        "username": "jm3579",
                        "content": "I worked a lot on this problem. Found a solution with dynamic programming, it runs n^4 time complexity (n is the number of operations in the string). It successfully passes all the test cases.\\nIt\\'s very quick on my pc, still I get \"Time Limit Exceeded\" error at various test cases. I suppose it\\'s more due to load of the server then really the performance of my solution, it\\'s pretty annoying."
                    },
                    {
                        "username": "youniesmm9",
                        "content": "bro why do you casually think that leetcode would accept an n^4 solution?"
                    }
                ]
            }
        ]
    }
]