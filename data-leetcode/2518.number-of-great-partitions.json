[
    {
        "title": "Number of Great Partitions",
        "question_content": "You are given an array nums consisting of positive integers and an integer k.\nPartition the array into two ordered groups such that each element is in exactly one group. A partition is called great if the sum of elements of each group is greater than or equal to k.\nReturn the number of distinct great partitions. Since the answer may be too large, return it modulo 109 + 7.\nTwo partitions are considered distinct if some element nums[i] is in different groups in the two partitions.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3,4], k = 4\nOutput: 6\nExplanation: The great partitions are: ([1,2,3], [4]), ([1,3], [2,4]), ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) and ([4], [1,2,3]).\n\nExample 2:\n\nInput: nums = [3,3,3], k = 4\nOutput: 0\nExplanation: There are no great partitions for this array.\n\nExample 3:\n\nInput: nums = [6,6], k = 2\nOutput: 2\nExplanation: We can either put nums[0] in the first partition or in the second partition.\nThe great partitions will be ([6], [6]) and ([6], [6]).\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length, k <= 1000\n\t1 <= nums[i] <= 109",
        "solutions": [
            {
                "id": 2948009,
                "title": "java-c-python-knapsack-problem",
                "content": "# **Intuition**\\nwe are asked to find the number of arrangement that both have size > k.\\nWe can find out the number of cases that have size <= k,\\nthen that a more regular Knapsack problem.\\n<br>\\n\\n# **Explanation**\\nIf `sum(A) < k + k`,\\ntwo groups can not have enough size at the same time,\\nwe can directly return `0`.\\n\\n\\nSince each integer can be put in either group 1 or group 2,\\nWe have `2 ^ n` possible partition.\\n\\nNow we are calculting the number of cases we need to eliminate.\\n\\nWe can apply Knapsack solution to find out `dp[i]`,\\nwhich indicates the number of cases that we have a group with size `i`.\\n\\nFor case that group 1 has size smaller than `k`,\\n`res -= dp[i]` for `i < k`.\\n\\nFor case that group 1 has size smaller than `k`,\\n`res -= dp[i]` for `i < k`.\\n\\nIn the above,\\nwe duplicatly count the case that both groups have size smaller than `k`,\\nAccording to the Principle of Inclusion and Exclusion,\\nwe need to do `res += dp[i]` for `i` that `sum(A) - i < k`.\\n<br>\\n\\n# **Complexity**\\nTime `O(nk)`\\nSpace `O(k)`\\n<br>\\n\\n**Java**\\n```java\\n    public int countPartitions(int[] A, int k) {\\n        long mod = (long)1e9 + 7, total = 0, res = 1, dp[] = new long[k];\\n        dp[0] = 1;\\n        for (int a : A) {\\n            for (int i = k - 1 - a; i >= 0; --i)\\n                dp[i + a] = (dp[i + a] + dp[i]) % mod;\\n            res = res * 2 % mod;\\n            total += a;\\n        }\\n        for (int i = 0; i < k; ++i) {\\n            res -= total - i < k ? dp[i] : dp[i] * 2;\\n        }\\n        return (int)((res % mod + mod) % mod);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int countPartitions(vector<int>& A, int k) {\\n        long mod = 1e9 + 7, total = 0, res = 1;\\n        vector<long> dp(k);\\n        dp[0] = 1;\\n        for (int& a : A) {\\n            for (int i = k - 1 - a; i >= 0; --i)\\n                dp[i + a] = (dp[i + a] + dp[i]) % mod;\\n            res = res * 2 % mod;\\n            total += a;\\n        }\\n        for (int i = 0; i < k; ++i) {\\n            res -= total - i < k ? dp[i] : dp[i] * 2;\\n        }\\n        return (res % mod + mod) % mod;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def countPartitions(self, A: List[int], k: int) -> int:\\n        if sum(A) < k * 2: return 0\\n        mod = 10**9 + 7\\n        dp = [1] + [0] * (k - 1)\\n        for a in A:\\n            for i in range(k - 1 - a, -1, -1):\\n                dp[i + a] += dp[i]\\n        return (pow(2, len(A), mod) - sum(dp) * 2) % mod\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int countPartitions(int[] A, int k) {\\n        long mod = (long)1e9 + 7, total = 0, res = 1, dp[] = new long[k];\\n        dp[0] = 1;\\n        for (int a : A) {\\n            for (int i = k - 1 - a; i >= 0; --i)\\n                dp[i + a] = (dp[i + a] + dp[i]) % mod;\\n            res = res * 2 % mod;\\n            total += a;\\n        }\\n        for (int i = 0; i < k; ++i) {\\n            res -= total - i < k ? dp[i] : dp[i] * 2;\\n        }\\n        return (int)((res % mod + mod) % mod);\\n    }\\n```\n```cpp\\n    int countPartitions(vector<int>& A, int k) {\\n        long mod = 1e9 + 7, total = 0, res = 1;\\n        vector<long> dp(k);\\n        dp[0] = 1;\\n        for (int& a : A) {\\n            for (int i = k - 1 - a; i >= 0; --i)\\n                dp[i + a] = (dp[i + a] + dp[i]) % mod;\\n            res = res * 2 % mod;\\n            total += a;\\n        }\\n        for (int i = 0; i < k; ++i) {\\n            res -= total - i < k ? dp[i] : dp[i] * 2;\\n        }\\n        return (res % mod + mod) % mod;\\n    }\\n```\n```py\\n    def countPartitions(self, A: List[int], k: int) -> int:\\n        if sum(A) < k * 2: return 0\\n        mod = 10**9 + 7\\n        dp = [1] + [0] * (k - 1)\\n        for a in A:\\n            for i in range(k - 1 - a, -1, -1):\\n                dp[i + a] += dp[i]\\n        return (pow(2, len(A), mod) - sum(dp) * 2) % mod\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2947979,
                "title": "python3-dp-simple-solution-with-steps-and-intuition",
                "content": "#### Intuition\\nNotice in the problem description that k < 1000 while number of subsets of the array can go as high as 2^1000, instead of thinking from the perspextive of iterating through each subset, we should think about how to use this \"k\" to resolve the problem.\\n#### Steps\\n\\n- Define a sub-problem: \\n`Find the total number of subsets in the array with their sums smaller than k.`. \\nThis is a classic DP problem [SubsetSum](https://leetcode.com/discuss/interview-question/1279773/google-interview-question-array-subset-sum-equals-k) with time complexity `O(N * K)`.\\n- For each of the invalid subset, it can be either the first or second of an invalid tuple.\\n- So, let the number of invalid subsets be X, total number of subsets pairs is 2^n, total valid subsets should be `2^n - 2 * X`.\\n\\n *Needs to think about edges cases where all pairs of subsets are invalid (`2 * X > 2^n`).*\\n\\n#### Complexity\\n`O(N * K)`\\n\\n#### Solution\\n```\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [[0] * (k + 1)] + [[-1] * (k + 1) for _ in range(n)]\\n        dp[0][0] = 1\\n        def subsetSumCounts(s, idx):\\n            if s < 0:\\n            \\treturn 0\\n            if dp[idx][s] < 0:\\n                dp[idx][s] = subsetSumCounts(s, idx - 1) + subsetSumCounts(s - nums[idx - 1], idx - 1)\\n            return dp[idx][s]\\n                \\n        invalid_pairs = sum([subsetSumCounts(i, n) for i in range(k)]) * 2\\n        return max(2**n - invalid_pairs, 0) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [[0] * (k + 1)] + [[-1] * (k + 1) for _ in range(n)]\\n        dp[0][0] = 1\\n        def subsetSumCounts(s, idx):\\n            if s < 0:\\n            \\treturn 0\\n            if dp[idx][s] < 0:\\n                dp[idx][s] = subsetSumCounts(s, idx - 1) + subsetSumCounts(s - nums[idx - 1], idx - 1)\\n            return dp[idx][s]\\n                \\n        invalid_pairs = sum([subsetSumCounts(i, n) for i in range(k)]) * 2\\n        return max(2**n - invalid_pairs, 0) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948074,
                "title": "c-dp-o-n-k-complete-explanation",
                "content": "# Intuition\\nMy first thought was to look at what will be the types of partitions we can make.\\n# Approach\\n\\nLet the 2 partitions be called P1 and P2. We can make some observations \\n1. if 2*k > sum(array) then return 0 \\n2. if n == 1 then return 0 (since partitions can not be empty)\\n3. the partition P1 and P2 can be of 3 types\\n\\t(a) ```sum(P1) >= k and sum(P2) >= k```\\n\\t(b) ```sum(P1) < k and sum(P2) > k```\\n\\t(c) ```sum(P1) > k and sum(P2) < k```\\n\\t* note that case (b) and (c) are symmetric\\n4. Instead of counting number of partitions P1 and P2 such that sum(P1) >= k and sum(P2) >= k,\\n\\tlet us instead count the number of partitions P1 and P2 such that sum(P1) < k and sum(P2) > k:\\n\\t\\n    let count of such partitions be X :\\n\\tthen our answer will be - \\n        ```ans = (total ways of partitioning the array in any manner ) - 2*X ( note that we are muliplying by 2 to also count for the case where sum(P1) > k and sum(P2) < k )```\\n\\nSo the problem simply boils down to calculating X, we can use dynamic programming to do this:\\nlet ```dp[i][j]``` indicate the number of segments of the array (from 0 - i index) such that their sum is equal to j:\\nthe transition will be - ```dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]```\\nwe can then simply sum up ```dp[n-1][1] + dp[n-1][2] + dp[n-1][3] + ... dp[n-1][k-1]``` to find X ;\\n\\nthe total ways of paritioning the array ( such that both P1 and P2 are non empty) = ```2^(n) - 2 (the two cases we are substracting are when p1 or p2 is empty)```\\n\\n# Complexity\\n- Time complexity:\\nO(n*k) - To fill the DP Table\\n\\n- Space complexity:\\nO(n*k) - For the DP Table (can be optimized to O(k)) \\n\\n# Code\\n```\\n#define ll long long\\n#define mod 1000000007\\nll mpow(ll a, ll b, ll m)\\n{\\n\\tif (b == 0)\\n\\t\\treturn 1;\\n\\tll x = mpow(a, b / 2, m);\\n\\tx = (x * x) % m;\\n\\tif (b % 2)\\n\\t{\\n\\t\\tx = (x * a) % m;\\n\\t}\\n\\treturn x;\\n}\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        ll totSum =0;\\n        int n = nums.size();\\n        for(auto node : nums) totSum += node;\\n        if((2*k)>totSum) return 0;\\n        sort(nums.begin(),nums.end());\\n        \\n        if(n == 1) return 0;\\n        \\n        vector<vector<ll>> dp(n,vector<ll>(k,0));\\n        \\n        for(int i =0 ;i<n ; i+=1){\\n            for(int j =0; j < k; j+=1){\\n                if(!i && !j){\\n                    dp[i][j] = 1;\\n                    continue;\\n                }\\n                if(i == 0){\\n                    if(j==nums[i]) dp[i][j] = 1;\\n                    continue;\\n                }\\n                if(nums[i]>j) dp[i][j] = dp[i-1][j];\\n                else{\\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]];\\n                    dp[i][j] %= mod;\\n                }\\n            }\\n        }\\n        \\n        ll ways= 0;\\n        for(int i = 1; i< k ; i+=1){\\n            ways += dp[n-1][i];\\n        }\\n        ways %= mod;\\n        ll totWaysOfDividing = mpow(2,n,mod);\\n        totWaysOfDividing -= 2;\\n        totWaysOfDividing -= 2*ways;\\n        totWaysOfDividing = (totWaysOfDividing%mod + mod)%mod;\\n        return totWaysOfDividing;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```sum(P1) >= k and sum(P2) >= k```\n```sum(P1) < k and sum(P2) > k```\n```sum(P1) > k and sum(P2) < k```\n```ans = (total ways of partitioning the array in any manner ) - 2*X ( note that we are muliplying by 2 to also count for the case where sum(P1) > k and sum(P2) < k )```\n```dp[i][j]```\n```dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]```\n```dp[n-1][1] + dp[n-1][2] + dp[n-1][3] + ... dp[n-1][k-1]```\n```2^(n) - 2 (the two cases we are substracting are when p1 or p2 is empty)```\n```\\n#define ll long long\\n#define mod 1000000007\\nll mpow(ll a, ll b, ll m)\\n{\\n\\tif (b == 0)\\n\\t\\treturn 1;\\n\\tll x = mpow(a, b / 2, m);\\n\\tx = (x * x) % m;\\n\\tif (b % 2)\\n\\t{\\n\\t\\tx = (x * a) % m;\\n\\t}\\n\\treturn x;\\n}\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        ll totSum =0;\\n        int n = nums.size();\\n        for(auto node : nums) totSum += node;\\n        if((2*k)>totSum) return 0;\\n        sort(nums.begin(),nums.end());\\n        \\n        if(n == 1) return 0;\\n        \\n        vector<vector<ll>> dp(n,vector<ll>(k,0));\\n        \\n        for(int i =0 ;i<n ; i+=1){\\n            for(int j =0; j < k; j+=1){\\n                if(!i && !j){\\n                    dp[i][j] = 1;\\n                    continue;\\n                }\\n                if(i == 0){\\n                    if(j==nums[i]) dp[i][j] = 1;\\n                    continue;\\n                }\\n                if(nums[i]>j) dp[i][j] = dp[i-1][j];\\n                else{\\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]];\\n                    dp[i][j] %= mod;\\n                }\\n            }\\n        }\\n        \\n        ll ways= 0;\\n        for(int i = 1; i< k ; i+=1){\\n            ways += dp[n-1][i];\\n        }\\n        ways %= mod;\\n        ll totWaysOfDividing = mpow(2,n,mod);\\n        totWaysOfDividing -= 2;\\n        totWaysOfDividing -= 2*ways;\\n        totWaysOfDividing = (totWaysOfDividing%mod + mod)%mod;\\n        return totWaysOfDividing;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972194,
                "title": "clean-code-in-c-with-comments-top-down-dp-with-memoization-maths",
                "content": "```\\n/*\\n           \\n Suppose we partitioned our array into subsets s1 and s2 :-\\n    \\n            Final subsets -> s1 and s2\\n\\n            condition to be satisfied :  s1 >= k and s2 >= k\\n            \\n            s1+s2 >= 2*k\\n            \\n            s1+s2 = sum of array = s\\n            \\n            so sum of array i.e s must be >= 2*k\\n            \\n            Converse of the above condition : s1>=k and s2>=k\\n            \\n            is :\\n            \\n            (1) s1<k and s2<k\\n            (2) s1<k and s2>=k\\n            (3) s1>=k and s2<k\\n            \\n            \\n            Now (1) will never occur because s1+s2>=2*k always \\n            \\n            so we only need to find count in (2) and (3) respectively and we can subtract with             total number of partitions = (2^n) where n is the size of the array.\\n            \\n            Now count in (2) = count in (3)\\n            because since s1+s2 >= 2*k , if one subset has sum <k the other subset will \\n            have sum >=k\\n            \\n            \\n            So just find (2) using subset sum DP \\n            \\n            Final ans= 2^n - count in (2) - count in (3)\\n                     = 2^n - 2*(count in (2))    [as count in (2) = count in (3)]\\n            \\n        \\n*/\\n        \\n#define ll long long\\nll mod=1e9+7;\\nll dp[1001][1001];\\nclass Solution {\\n    int sz,K;\\n    ll solve(int i,ll sum1,vector<int>&v){\\n        \\n        if(sum1>=K){\\n            return 0;\\n        }\\n        if(i==sz){\\n            return sum1<K;\\n        }\\n        if(dp[i][sum1]!=-1)return dp[i][sum1];\\n        \\n        ll ans=((solve(i+1,sum1+v[i],v)%mod)+(solve(i+1,sum1,v)%mod))%mod;\\n        return dp[i][sum1]=ans;\\n    }\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        \\n        ll tot=1;  // total ways of partitioning the array into two partitions\\n        K=k;\\n        sz=nums.size();\\n        ll  sum=0;\\n        for(int i=0;i<sz;i++){\\n            sum+=nums[i];\\n            tot=(tot*2LL)%mod;\\n        }\\n        if(sum<2*k){\\n            return 0;\\n        }\\n        for(int i=0;i<sz;i++){\\n            for(int j=0;j<k;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        ll count=solve(0,0,nums)%mod;\\n        count=count*2LL%mod;   // taking (2) and (3)\\n        ll res=(tot-count+mod)%mod;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n/*\\n           \\n Suppose we partitioned our array into subsets s1 and s2 :-\\n    \\n            Final subsets -> s1 and s2\\n\\n            condition to be satisfied :  s1 >= k and s2 >= k\\n            \\n            s1+s2 >= 2*k\\n            \\n            s1+s2 = sum of array = s\\n            \\n            so sum of array i.e s must be >= 2*k\\n            \\n            Converse of the above condition : s1>=k and s2>=k\\n            \\n            is :\\n            \\n            (1) s1<k and s2<k\\n            (2) s1<k and s2>=k\\n            (3) s1>=k and s2<k\\n            \\n            \\n            Now (1) will never occur because s1+s2>=2*k always \\n            \\n            so we only need to find count in (2) and (3) respectively and we can subtract with             total number of partitions = (2^n) where n is the size of the array.\\n            \\n            Now count in (2) = count in (3)\\n            because since s1+s2 >= 2*k , if one subset has sum <k the other subset will \\n            have sum >=k\\n            \\n            \\n            So just find (2) using subset sum DP \\n            \\n            Final ans= 2^n - count in (2) - count in (3)\\n                     = 2^n - 2*(count in (2))    [as count in (2) = count in (3)]\\n            \\n        \\n*/\\n        \\n#define ll long long\\nll mod=1e9+7;\\nll dp[1001][1001];\\nclass Solution {\\n    int sz,K;\\n    ll solve(int i,ll sum1,vector<int>&v){\\n        \\n        if(sum1>=K){\\n            return 0;\\n        }\\n        if(i==sz){\\n            return sum1<K;\\n        }\\n        if(dp[i][sum1]!=-1)return dp[i][sum1];\\n        \\n        ll ans=((solve(i+1,sum1+v[i],v)%mod)+(solve(i+1,sum1,v)%mod))%mod;\\n        return dp[i][sum1]=ans;\\n    }\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        \\n        ll tot=1;  // total ways of partitioning the array into two partitions\\n        K=k;\\n        sz=nums.size();\\n        ll  sum=0;\\n        for(int i=0;i<sz;i++){\\n            sum+=nums[i];\\n            tot=(tot*2LL)%mod;\\n        }\\n        if(sum<2*k){\\n            return 0;\\n        }\\n        for(int i=0;i<sz;i++){\\n            for(int j=0;j<k;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        ll count=solve(0,0,nums)%mod;\\n        count=count*2LL%mod;   // taking (2) and (3)\\n        ll res=(tot-count+mod)%mod;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948014,
                "title": "dp-o-n-k",
                "content": "**Intuititon** : \\n**1.** If the sum of the array is smaller than 2*k, then it is impossible to find a great partition.\\n**2.** Solve the reverse problem, that is, find the number of partitions where the sum of elements of at least one of the two groups is smaller than k.\\n\\nLets store those invalid ways using dp, can be done in O(N * K) **Knapsack Problem**\\nHence, total valid ways = total ways - 2*(sum of dp)\\n\\nHere, we are multiplying the (sum of dp) with 2 as the invalid ways can be in either partition\\n```\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        int n = nums.size() , ans=1, mod = 1e9+7;\\n        for(int i=0;i<n;i++) ans = (ans*2)%mod; // total number of ways\\n        \\n        vector<int>dp(k,0); // to store the number of ways of partition where sum < k\\n        dp[0] = 1;\\n        long long total_sum = 0;\\n        for(int i=0;i<n;i++){\\n            total_sum+=nums[i];\\n            for(int j=k-1;j>=nums[i];j--){\\n                dp[j] = (dp[j] + dp[j - nums[i]])%mod;\\n            }\\n        }\\n        if(total_sum<2*k) return 0; \\n        int sum_dp = 0;\\n        for(int i=0;i<k;i++){\\n            sum_dp = (sum_dp+dp[i])%mod;\\n        }\\n        ans = (ans-2*sum_dp+mod)%mod; // subtracting the invalid ways\\n        return ans;\\n    }\\n};\\n```\\n\\nUpvote if it helps!!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        int n = nums.size() , ans=1, mod = 1e9+7;\\n        for(int i=0;i<n;i++) ans = (ans*2)%mod; // total number of ways\\n        \\n        vector<int>dp(k,0); // to store the number of ways of partition where sum < k\\n        dp[0] = 1;\\n        long long total_sum = 0;\\n        for(int i=0;i<n;i++){\\n            total_sum+=nums[i];\\n            for(int j=k-1;j>=nums[i];j--){\\n                dp[j] = (dp[j] + dp[j - nums[i]])%mod;\\n            }\\n        }\\n        if(total_sum<2*k) return 0; \\n        int sum_dp = 0;\\n        for(int i=0;i<k;i++){\\n            sum_dp = (sum_dp+dp[i])%mod;\\n        }\\n        ans = (ans-2*sum_dp+mod)%mod; // subtracting the invalid ways\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948637,
                "title": "python3-recursive-iterative",
                "content": "This implementation was following the expinations from [HERE](https://leetcode.com/problems/number-of-great-partitions/discuss/2947979/Python3-DP-Simple-solution-with-steps-and-intuition)\\nThe key idea is **Find the total number of subsets (```invalid_partitions```) in the array with their sums smaller than k**\\nThe result is ```2 ^ n - 2 * invalid_partitions```, where ```2^n``` is the total number of partitions, and ```invalid_partitions``` * **2** because the invalid_partition can be in group1 or group2.\\n\\n**recursive**\\n```python\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        mod = 10**9+7\\n        n = len(nums)\\n        \\n        @cache\\n        def dp(i,cur):\\n            if i==n:\\n                return 1\\n\\n            # do not include the current nums[i]\\n            remove = dp(i+1,cur)\\n            keep = 0\\n\\n            # include the current nums[i]\\n            if cur+nums[i]<k:\\n                keep =  dp(i+1,cur+nums[i])\\n            return remove+keep\\n\\n        invalid_partitions = dp(0,0)\\n        res = pow(2,n) - invalid_partitions*2\\n        return max(res,0) % mod\\n```\\n\\n**iterative**\\n```python\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        mod = 10**9+7\\n        n = len(nums)\\n\\n        dp = [[0]*(k+1) for _ in range(n+1)]\\n        \\n        # same condition as previous one: \\'if i==n: return 1\\'\\n        for i in range(k+1):\\n            dp[n][i] = 1\\n\\n        for i in reversed(range(n)):\\n            for j in reversed(range(k)):\\n\\n            \\t# do not include the current nums[i]\\n                dp[i][j] = dp[i+1][j]\\n\\n                # include the current nums[i]\\n                if j+nums[i]<k:\\n                    dp[i][j] += dp[i+1][j+nums[i]]\\n        \\n        invalid_partitions = dp[0][0]\\n        res = pow(2,n) - invalid_partitions*2\\n        return max(res,0) % mod\\n```",
                "solutionTags": [],
                "code": "```invalid_partitions```\n```2 ^ n - 2 * invalid_partitions```\n```2^n```\n```invalid_partitions```\n```python\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        mod = 10**9+7\\n        n = len(nums)\\n        \\n        @cache\\n        def dp(i,cur):\\n            if i==n:\\n                return 1\\n\\n            # do not include the current nums[i]\\n            remove = dp(i+1,cur)\\n            keep = 0\\n\\n            # include the current nums[i]\\n            if cur+nums[i]<k:\\n                keep =  dp(i+1,cur+nums[i])\\n            return remove+keep\\n\\n        invalid_partitions = dp(0,0)\\n        res = pow(2,n) - invalid_partitions*2\\n        return max(res,0) % mod\\n```\n```python\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        mod = 10**9+7\\n        n = len(nums)\\n\\n        dp = [[0]*(k+1) for _ in range(n+1)]\\n        \\n        # same condition as previous one: \\'if i==n: return 1\\'\\n        for i in range(k+1):\\n            dp[n][i] = 1\\n\\n        for i in reversed(range(n)):\\n            for j in reversed(range(k)):\\n\\n            \\t# do not include the current nums[i]\\n                dp[i][j] = dp[i+1][j]\\n\\n                # include the current nums[i]\\n                if j+nums[i]<k:\\n                    dp[i][j] += dp[i+1][j+nums[i]]\\n        \\n        invalid_partitions = dp[0][0]\\n        res = pow(2,n) - invalid_partitions*2\\n        return max(res,0) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948329,
                "title": "c-knapsack-variation-n-k-memoization-solution-with-comments",
                "content": "\\n# Intution\\nBasic idea is counting subsets with sum>= k but since nums[i]<=1e9 that will take too much time. Since we know k<=1000 we can count subsets with sum<=k.\\n\\nCounting subsets with both partitions having sum>=k is equivalent to counting subsets with ONE OF THE PARTITION with sum<k and subtracting it from total number of subsets(2^n).\\n\\n# Code\\n```\\nclass Solution {\\n    using ll = long long;\\n    const ll MOD = 1e9 + 7;\\n\\n    // Basic Knapsack -> Counts subsets with sum less than k\\n    ll part(ll ind, vector<int>& nums, ll sum, int k, vector<vector<ll>>& dp) {\\n        if (sum >= k) return 0;\\n        if (ind == nums.size()) return 1;\\n        if (dp[ind][sum] != -1) return dp[ind][sum];\\n\\n        ll take = part(ind + 1, nums, sum + nums[ind], k, dp);\\n        ll notTake = part(ind + 1, nums, sum, k, dp);\\n\\n        return dp[ind][sum] = (take % MOD + notTake % MOD) % MOD;\\n    }\\n\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        ll n = nums.size();\\n\\n        // Checking if the sum of array > 2 * k,\\n        // array can never be partitioned if sum is less than 2 * k\\n        ll sum = accumulate(begin(nums), end(nums), 0LL);\\n        if (sum < 2 * k) return 0;\\n\\n        vector<vector<ll>> dp(n, vector<ll>(k + 1, -1));\\n\\n        // Calculating total number of subsets i.e. 2^n\\n        ll totalSubsets = 1;\\n        for (int i = 1; i <= n; i++) {\\n            totalSubsets = (totalSubsets * 2) % MOD;\\n        }\\n\\n        // After calculating the number of partitions with a sum less than k,\\n        // the solution multiplies the result by 2 to account for the fact\\n        // that the same partition can be counted as either the left group or\\n        // the right group.\\n\\n        // For example, ([1,2,3],[4]) & ([4],[1,2,3]) should be counted separately\\n        // BUT the part function only considers ([4],[1,2,3])\\n        ll validSubsets = (totalSubsets - 2 * part(0, nums, 0, k, dp) + MOD) % MOD;\\n        return validSubsets;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    using ll = long long;\\n    const ll MOD = 1e9 + 7;\\n\\n    // Basic Knapsack -> Counts subsets with sum less than k\\n    ll part(ll ind, vector<int>& nums, ll sum, int k, vector<vector<ll>>& dp) {\\n        if (sum >= k) return 0;\\n        if (ind == nums.size()) return 1;\\n        if (dp[ind][sum] != -1) return dp[ind][sum];\\n\\n        ll take = part(ind + 1, nums, sum + nums[ind], k, dp);\\n        ll notTake = part(ind + 1, nums, sum, k, dp);\\n\\n        return dp[ind][sum] = (take % MOD + notTake % MOD) % MOD;\\n    }\\n\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        ll n = nums.size();\\n\\n        // Checking if the sum of array > 2 * k,\\n        // array can never be partitioned if sum is less than 2 * k\\n        ll sum = accumulate(begin(nums), end(nums), 0LL);\\n        if (sum < 2 * k) return 0;\\n\\n        vector<vector<ll>> dp(n, vector<ll>(k + 1, -1));\\n\\n        // Calculating total number of subsets i.e. 2^n\\n        ll totalSubsets = 1;\\n        for (int i = 1; i <= n; i++) {\\n            totalSubsets = (totalSubsets * 2) % MOD;\\n        }\\n\\n        // After calculating the number of partitions with a sum less than k,\\n        // the solution multiplies the result by 2 to account for the fact\\n        // that the same partition can be counted as either the left group or\\n        // the right group.\\n\\n        // For example, ([1,2,3],[4]) & ([4],[1,2,3]) should be counted separately\\n        // BUT the part function only considers ([4],[1,2,3])\\n        ll validSubsets = (totalSubsets - 2 * part(0, nums, 0, k, dp) + MOD) % MOD;\\n        return validSubsets;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951681,
                "title": "double-dp",
                "content": "The basis for this problem is Knapsack 0-1, and the main difficulty here is that the sum could be large. \\n\\n> It will not be very efficient to memoise large sums.\\n\\n`k`, on the other hand, is limited to `1,000`. So, we flip the problem. \\n\\nInstead of counting great partitions, we count partitions that are not so great.\\n\\nTo get the answer, we subtract the number of bad partitions from the number of total partitions.\\n\\n## First DP\\nWe use tabulation (bottom-up DP) to count the number of paritions for arrays with size `[2, 1000]`. \\n\\nNote that we need to only compute it once for all test cases (note that `cnt` is a global array).\\n\\n## Second DP\\nJust to be different from first DP, we use a top-down approach here (and it\\'s easier to read).\\n\\nWe run 0-1 Knapsack, pruning if sum reaches `k`. We memoise for the current element `i` and `sum` using  `dp[1000][1000]`.\\n\\n> Sorting numbers helps DFS prune a bunch of large numbers right away, reducing DFS branching and achieving 23 ms runtime.\\n\\n**C++**\\n```cpp\\nint cnt[1001] = {}, mod = 1000000007;\\nclass Solution {\\npublic:\\nint dp[1000][1000] = {};\\nint dfs(int i, vector<int>& nums, int sum, int k) {\\n    if (sum >= k || i == nums.size())\\n        return sum > 0 && sum < k;\\n    if (dp[i][sum] == 0)\\n        dp[i][sum] = (1 + dfs(i + 1, nums, sum, k) + \\n            dfs(i + 1, nums, sum + nums[i], k)) % mod;\\n    return dp[i][sum] - 1;\\n}\\nint countPartitions(vector<int>& nums, int k) {\\n    if (cnt[2] == 0)\\n        for (int i = 2; i < 1001; ++i)\\n            cnt[i] = 2 * (cnt[i - 1] + 1) % mod;\\n    if (accumulate(begin(nums), end(nums), 0LL) < k * 2)\\n        return 0;\\n    sort(begin(nums), end(nums), greater<int>());\\n    return (mod + cnt[nums.size()] - 2 * dfs(0, nums, 0, k)) % mod;\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint cnt[1001] = {}, mod = 1000000007;\\nclass Solution {\\npublic:\\nint dp[1000][1000] = {};\\nint dfs(int i, vector<int>& nums, int sum, int k) {\\n    if (sum >= k || i == nums.size())\\n        return sum > 0 && sum < k;\\n    if (dp[i][sum] == 0)\\n        dp[i][sum] = (1 + dfs(i + 1, nums, sum, k) + \\n            dfs(i + 1, nums, sum + nums[i], k)) % mod;\\n    return dp[i][sum] - 1;\\n}\\nint countPartitions(vector<int>& nums, int k) {\\n    if (cnt[2] == 0)\\n        for (int i = 2; i < 1001; ++i)\\n            cnt[i] = 2 * (cnt[i - 1] + 1) % mod;\\n    if (accumulate(begin(nums), end(nums), 0LL) < k * 2)\\n        return 0;\\n    sort(begin(nums), end(nums), greater<int>());\\n    return (mod + cnt[nums.size()] - 2 * dfs(0, nums, 0, k)) % mod;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949866,
                "title": "c-dp-memoization-explanation",
                "content": "# Approch\\nIf ```sum(nums[]) < (2 * k)``` then, we can\\'t make the partition.\\nNow, calculating the partitions in which sum of both sequences is greater than k will take more space i.e., ```DP[sizeof nums][total sum of elements]```.\\n\\nThus, we can find the sequences whose sum is less than k and the final answer will be ```all sequences of nums[] - sequences with sum < k```. This is possible because in the 1st step we made ensure that ```sum(nums[]) >= (2 * k)``` which means that if one sequence of partition has ```sum less than k```, other would have ```sum greater than k```. Here less space is required i.e., ```Dp[sizeof nums][k + 1]```.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    const int mod = 1E9 + 7;\\n    ll total = 0;\\n    vector<vector<int>> dp;\\n    ll cal(int i, ll sum, vector<int>& nums, int k) {\\n        if(sum > k) {\\n            return 0;\\n        }\\n        if(i == nums.size()) {\\n            return sum < k ? 1 : 0;\\n        }\\n        if(dp[i][sum] != -1)\\n            return dp[i][sum];\\n        ll take = cal(i + 1, sum + nums[i], nums, k) % mod;\\n        ll nake = cal(i + 1, sum, nums, k) % mod;\\n        return dp[i][sum] = (take + nake) % mod;\\n    }\\n    int countPartitions(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        for(auto it : nums)\\n            total += it;\\n        if(total < (2 * k))\\n            return 0;\\n        dp = vector<vector<int>> (n, vector<int> (k + 1, -1));\\n        ll x = cal(0, 0, nums, k);\\n        x--;           // x also include count of empty sequence i.e., {}\\n        ll y = 2;      // Total number of sequences\\n        for(int i = 2; i <= n; i++) {\\n            y *= 2; y %= mod;\\n        }\\n        y -= 2;        // Subtracting sequences whose partition is not possible i.e., {} and {all elements of nums[]}\\n        ll ans = ((y - ((2 * x) % mod)) + mod) % mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```sum(nums[]) < (2 * k)```\n```DP[sizeof nums][total sum of elements]```\n```all sequences of nums[] - sequences with sum < k```\n```sum(nums[]) >= (2 * k)```\n```sum less than k```\n```sum greater than k```\n```Dp[sizeof nums][k + 1]```\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    const int mod = 1E9 + 7;\\n    ll total = 0;\\n    vector<vector<int>> dp;\\n    ll cal(int i, ll sum, vector<int>& nums, int k) {\\n        if(sum > k) {\\n            return 0;\\n        }\\n        if(i == nums.size()) {\\n            return sum < k ? 1 : 0;\\n        }\\n        if(dp[i][sum] != -1)\\n            return dp[i][sum];\\n        ll take = cal(i + 1, sum + nums[i], nums, k) % mod;\\n        ll nake = cal(i + 1, sum, nums, k) % mod;\\n        return dp[i][sum] = (take + nake) % mod;\\n    }\\n    int countPartitions(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        for(auto it : nums)\\n            total += it;\\n        if(total < (2 * k))\\n            return 0;\\n        dp = vector<vector<int>> (n, vector<int> (k + 1, -1));\\n        ll x = cal(0, 0, nums, k);\\n        x--;           // x also include count of empty sequence i.e., {}\\n        ll y = 2;      // Total number of sequences\\n        for(int i = 2; i <= n; i++) {\\n            y *= 2; y %= mod;\\n        }\\n        y -= 2;        // Subtracting sequences whose partition is not possible i.e., {} and {all elements of nums[]}\\n        ll ans = ((y - ((2 * x) % mod)) + mod) % mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964745,
                "title": "python-dp-o-n-k-video-solution",
                "content": "I have explained this [here](https://youtu.be/CQtLbU8x_vI).\\n\\n**Time:** `O(N.K)`\\n\\n**Space:** `O(N.K)`\\n\\n```\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        \\n        @cache\\n        def dfs(i, cur_sum):\\n            if i==n:\\n                return 1\\n            \\n            skip = dfs(i+1, cur_sum)\\n            include = 0\\n            if nums[i] + cur_sum < k:\\n                include = dfs(i+1, cur_sum + nums[i])\\n                \\n            return skip + include\\n        \\n        less_than_k = 2 * dfs(0,0)\\n        return max(2**n - less_than_k, 0) % (10**9 + 7)\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "I have explained this [here](https://youtu.be/CQtLbU8x_vI).\\n\\n**Time:** `O(N.K)`\\n\\n**Space:** `O(N.K)`\\n\\n```\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        \\n        @cache\\n        def dfs(i, cur_sum):\\n            if i==n:\\n                return 1\\n            \\n            skip = dfs(i+1, cur_sum)\\n            include = 0\\n            if nums[i] + cur_sum < k:\\n                include = dfs(i+1, cur_sum + nums[i])\\n                \\n            return skip + include\\n        \\n        less_than_k = 2 * dfs(0,0)\\n        return max(2**n - less_than_k, 0) % (10**9 + 7)\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2948112,
                "title": "java-o-nk-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each sum, calculate the number of combinations and it can be done by the traditional knapsack DP.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* The major problem is that the sum can up to 10^9 x 1000 which exceeds the memory limitation.\\n* Since the maximum of K is only 1000, we can calculate the number of combinations for sum strickly less than K and then the final answer will be equal to `total_combinations - combinations_for_sum_less_than_K`.\\n* Let dp[i] indicates the number of combinations for sum less than K. We need to multiply it by 2 because its counterpart is invalid as well. Take [1, 2, 3, 4] and K = 4 for example, the group [1, 2] is invalid and so is the group [3, 4].\\n# Complexity\\n- Time complexity: O(NK)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nDP: O(NK)\\nSum of DP: O(K)\\nCalculate 2^N: O(LogN)\\nTotal = O(NK) + O(K) + O(LogN) = O(NK)\\n- Space complexity: O(K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static int mod = (int) 1e9 + 7;\\n    public int countPartitions(int[] nums, int k) {\\n        long sum = 0;\\n        for (int i : nums) sum += i;\\n        if (sum < k * 2) return 0;\\n        int[] dp = new int[k];\\n        dp[0] = 1;\\n        for (int i : nums) {\\n            for (int j = k - 1; i <= j; --j) dp[j] = (dp[j] + dp[j - i]) % mod;\\n        }\\n        int less = 0;\\n        for (int i = 0; i < k; ++i) less = (less + dp[i]) % mod;\\n        return ((pow(nums.length) - (less << 1)) % mod + mod) % mod;\\n    }\\n    private int pow(int n) {\\n        long res = 1, m = 2;\\n        while (0 != n) {\\n            if (1 == (n & 1)) res = res * m % mod;\\n            n >>= 1;\\n            m = m * m % mod;\\n        }\\n        return (int) res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    static int mod = (int) 1e9 + 7;\\n    public int countPartitions(int[] nums, int k) {\\n        long sum = 0;\\n        for (int i : nums) sum += i;\\n        if (sum < k * 2) return 0;\\n        int[] dp = new int[k];\\n        dp[0] = 1;\\n        for (int i : nums) {\\n            for (int j = k - 1; i <= j; --j) dp[j] = (dp[j] + dp[j - i]) % mod;\\n        }\\n        int less = 0;\\n        for (int i = 0; i < k; ++i) less = (less + dp[i]) % mod;\\n        return ((pow(nums.length) - (less << 1)) % mod + mod) % mod;\\n    }\\n    private int pow(int n) {\\n        long res = 1, m = 2;\\n        while (0 != n) {\\n            if (1 == (n & 1)) res = res * m % mod;\\n            n >>= 1;\\n            m = m * m % mod;\\n        }\\n        return (int) res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613119,
                "title": "c-get-all-subset-sum-k",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        long long int sum1 = 0;\\n        for(auto &i: nums){\\n            sum1 += i;\\n        }\\n        if(sum1 < 2*1LL*k || nums.size()<=1)return 0;\\n        int n = nums.size(),i,j;\\n        int mod = 1e9+7;\\n        vector<vector<int>> dp(n+1,vector<int>(k,-1));\\n        for(i = 0; i <= n; i++){\\n            for(j = 0; j < k; j++){\\n                if(i==0){\\n                    dp[i][j] = 0;\\n                }if(j==0){\\n                    dp[i][j] = 1;\\n                }\\n                if(i && j){\\n                    if(j>=nums[i-1]){\\n                        dp[i][j] = (dp[i-1][j]*1LL+dp[i-1][j-nums[i-1]])%mod;\\n                    }else{\\n                        dp[i][j] = dp[i-1][j];\\n                    }\\n                }\\n            }\\n        }\\n        // cout<<\"#\";\\n        int sum = 0, total = 1,a=2;\\n        for(auto &i : dp[n]){\\n            sum = (sum+i)%mod;\\n        }\\n        sum = (sum*1LL*2)%mod;\\n        // cout<<\"#\\\\n\";\\n        while(n){\\n            if(n&1){\\n                total = (total*1LL*a)%mod;\\n            }\\n            a = (a*1LL*a)%mod;\\n            n >>= 1;\\n        }\\n        return ((total-sum)%mod+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        long long int sum1 = 0;\\n        for(auto &i: nums){\\n            sum1 += i;\\n        }\\n        if(sum1 < 2*1LL*k || nums.size()<=1)return 0;\\n        int n = nums.size(),i,j;\\n        int mod = 1e9+7;\\n        vector<vector<int>> dp(n+1,vector<int>(k,-1));\\n        for(i = 0; i <= n; i++){\\n            for(j = 0; j < k; j++){\\n                if(i==0){\\n                    dp[i][j] = 0;\\n                }if(j==0){\\n                    dp[i][j] = 1;\\n                }\\n                if(i && j){\\n                    if(j>=nums[i-1]){\\n                        dp[i][j] = (dp[i-1][j]*1LL+dp[i-1][j-nums[i-1]])%mod;\\n                    }else{\\n                        dp[i][j] = dp[i-1][j];\\n                    }\\n                }\\n            }\\n        }\\n        // cout<<\"#\";\\n        int sum = 0, total = 1,a=2;\\n        for(auto &i : dp[n]){\\n            sum = (sum+i)%mod;\\n        }\\n        sum = (sum*1LL*2)%mod;\\n        // cout<<\"#\\\\n\";\\n        while(n){\\n            if(n&1){\\n                total = (total*1LL*a)%mod;\\n            }\\n            a = (a*1LL*a)%mod;\\n            n >>= 1;\\n        }\\n        return ((total-sum)%mod+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2956361,
                "title": "java-one-of-the-easiest-solution-with-explanation-memorization-striver-s",
                "content": "```\\nstatic int mod = (int) 1e9 + 7;\\n    public static int countPartitions(int[] nums, int k) {\\n        int n = nums.length;\\n        long sum = 0;\\n        for (int it : nums) {\\n            sum += it;\\n        }\\n        if (sum / 2 < k) return 0;\\n\\n        Long[][] dp = new Long[n+1][10001];\\n\\n        long num = solveWrong(nums, 0, k, 0, dp);\\n        long pow = 1;\\n        for (int i = 1; i <= n; i++) {\\n            pow = ((pow % mod) * 2) % mod;\\n        }\\n        long ans = ((pow - ((2 * num) % mod)) + mod) % mod;\\n        return (int) ans;\\n    }\\n\\n    private static long solveWrong(int[] nums, int curSum, int k, int index, Long[][] dp) {\\n        if (index >= nums.length) {\\n            if (curSum < k) return 1;\\n            return 0;\\n        }\\n        if(dp[index][curSum] != null) return dp[index][curSum];\\n\\n        long pick = 0;\\n        if (curSum + nums[index] < k) {\\n            pick = solveWrong(nums, curSum + nums[index], k, index + 1, dp) % mod;\\n        }\\n        long notPick = solveWrong(nums, curSum, k, index + 1, dp) % mod;\\n        return dp[index][curSum] = (pick + notPick) % mod;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nstatic int mod = (int) 1e9 + 7;\\n    public static int countPartitions(int[] nums, int k) {\\n        int n = nums.length;\\n        long sum = 0;\\n        for (int it : nums) {\\n            sum += it;\\n        }\\n        if (sum / 2 < k) return 0;\\n\\n        Long[][] dp = new Long[n+1][10001];\\n\\n        long num = solveWrong(nums, 0, k, 0, dp);\\n        long pow = 1;\\n        for (int i = 1; i <= n; i++) {\\n            pow = ((pow % mod) * 2) % mod;\\n        }\\n        long ans = ((pow - ((2 * num) % mod)) + mod) % mod;\\n        return (int) ans;\\n    }\\n\\n    private static long solveWrong(int[] nums, int curSum, int k, int index, Long[][] dp) {\\n        if (index >= nums.length) {\\n            if (curSum < k) return 1;\\n            return 0;\\n        }\\n        if(dp[index][curSum] != null) return dp[index][curSum];\\n\\n        long pick = 0;\\n        if (curSum + nums[index] < k) {\\n            pick = solveWrong(nums, curSum + nums[index], k, index + 1, dp) % mod;\\n        }\\n        long notPick = solveWrong(nums, curSum, k, index + 1, dp) % mod;\\n        return dp[index][curSum] = (pick + notPick) % mod;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3324075,
                "title": "c-0-1-knapsack-easy-to-understand-short-sweer-code",
                "content": "````\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        long long int sum = 0;\\n        for(auto &i: nums){\\n            sum += i;\\n        }\\n        if(nums.size()==1||sum<2*1LL*k){//if sum<2*k return no of possible ans = 0\\n            return 0;\\n        }\\n        /*find no of possible subsequece whose sum < k */\\n        int i,j,n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<long long int>> dp(n+1,vector<long long int>(k+1,0));\\n        int mod = 1e9+7;\\n        for(i = 0; i <= n; i++){\\n            for(j = 0; j<k;j++){\\n                if(i==0||j==0)dp[i][j] = 0;\\n                if(j==0)dp[i][j] = 1;\\n                if(i>0&&j>0){\\n                    if(j>=nums[i-1]){\\n                        dp[i][j] = (dp[i-1][j-nums[i-1]]+dp[i-1][j])%mod;\\n                    }else{\\n                        dp[i][j] = dp[i-1][j];\\n                    }\\n                }\\n            }\\n        }\\n        sum = 0;\\n        for(i = 0; i < k; i++){\\n            sum = (sum+dp[n][i])%mod;\\n        }/*here if no of tt = subsequence whose sum < k*/\\n        long long int pow = 1,y=2;\\n        k = nums.size();\\n        while(k){\\n            if(k&1){\\n                pow = (pow*y)%mod;\\n            }\\n            y = (y*y)%mod;\\n            k >>= 1;\\n        }\\n        return ((pow-2*sum+mod)%mod);/*return total possible ans - 2*tt */\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        long long int sum = 0;\\n        for(auto &i: nums){\\n            sum += i;\\n        }\\n        if(nums.size()==1||sum<2*1LL*k){//if sum<2*k return no of possible ans = 0\\n            return 0;\\n        }\\n        /*find no of possible subsequece whose sum < k */\\n        int i,j,n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<long long int>> dp(n+1,vector<long long int>(k+1,0));\\n        int mod = 1e9+7;\\n        for(i = 0; i <= n; i++){\\n            for(j = 0; j<k;j++){\\n                if(i==0||j==0)dp[i][j] = 0;\\n                if(j==0)dp[i][j] = 1;\\n                if(i>0&&j>0){\\n                    if(j>=nums[i-1]){\\n                        dp[i][j] = (dp[i-1][j-nums[i-1]]+dp[i-1][j])%mod;\\n                    }else{\\n                        dp[i][j] = dp[i-1][j];\\n                    }\\n                }\\n            }\\n        }\\n        sum = 0;\\n        for(i = 0; i < k; i++){\\n            sum = (sum+dp[n][i])%mod;\\n        }/*here if no of tt = subsequence whose sum < k*/\\n        long long int pow = 1,y=2;\\n        k = nums.size();\\n        while(k){\\n            if(k&1){\\n                pow = (pow*y)%mod;\\n            }\\n            y = (y*y)%mod;\\n            k >>= 1;\\n        }\\n        return ((pow-2*sum+mod)%mod);/*return total possible ans - 2*tt */\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994639,
                "title": "c-java-python-direct-approach-to-solve-a-deformed-01-knapsack-problem",
                "content": "> **I know almost nothing about English, pointing out the mistakes in my article would be much appreciated.**\\n\\n> **In addition, I\\'m too weak, please be critical of my ideas.**\\n\\n> **Vote welcome if this solution helped.**\\n---\\n\\n# Intuition\\n1. Step by step, each number must belong to a group. The sums of two groups will be changed with the change of belonging situation. A natural thought is to record the count of \"until $i$, two groups\\' sum are $x$ and $y$\".\\n2. Notice that $x+y=s$, here $s$ means the prefix sum until $i$. So remove one group is more clear. Define {until $i$, one of group\\'s sum $j$} as the state, it convert to a classical [0/1 knapsack problem](https://en.wikipedia.org/wiki/Knapsack_problem). The problem seems to have been resolved.\\n3. But there is a serious problem: the value range is too large to record.\\n4. Notice $k$ is small, so we can immediately think about recording the states which not greater than $k$, and treat the sum greater than $k$ as $k$. \\n5. But that will cause new question: the record of $k$ contains some illegal state (the sum of another group is less than k). It\\'s hard to eliminate.\\n6. The reason is we selected a group as state randomly, but the symmetry of information is destroyed during the compression process.\\n7. Since we need both two groups are not less than $k$, better modify the state to {until $i$, the smaller group\\'s sum $j$}. The final state will no longer contains illegal states.\\n\\n# Approach\\n\\n1. Define $dp[i][j]$ as the count of **\"until $i$, the smaller group equals to $j$\"**. In particular, $dp[i][k]$ saves the count of $\\\\geq k$. \\n    As a result, in each step we have two choice:\\n    - Add $nums[i]$ into larger group, the smaller group remains unchanged. So directly add $dp[i][j]$ into $dp[i+1][j]$.\\n    - Add $nums[i]$ into smaller group, this operation may lead to two different results:\\n        - Let the smaller group surpass the larger one. In this case we need to add $dp[i][j]$ into $dp[i+1][s-i]$, here $s$ means the prefix sum until $i$.\\n        - The smaller group keep smaller than the lagrer one. In this case we need to add $dp[i][j]$ into $dp[i+1][j+nums[i]]$.\\n\\n    Finally, don\\'t forget all the $j$, $s-j$, $j+nums[i]$ should keep less than $k$, the excess will be treated as $k$.\\n2. **So the transfer equation seems as:**\\n$$dp[i+1][t] = dp[i][j] + dp[i][t], \\\\space where \\\\space t = \\\\{k, s-j, j+nums[i]\\\\}_{min}$$\\n3. Try to optimize the naive implementation:\\n    Easy to find the transfer always occurs between $dp[i][*]$ and $dp[i+1][*]$, so consider to compress two-dimensional array into one-dimensional.\\n    It\\'s a common optimization, we must care about the refresh order to ensure that values will not be updated until used. In this problem, $nums[i]>0$ is always established, so $t>=j$ is always established as well. As a result, refreshing $j$ in descending order works fine.\\n\\n# Complexity\\n- Time complexity: $$O(nk)$$\\n- Space complexity: $$O(k)$$\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        vector<int> dp(k + 1, 0);\\n        dp[0] = 1;\\n        long s = 0;\\n        for (auto x: nums) {\\n            for (int j = min<long>(k, s); j >= 0; --j) {\\n                long t = min<long>(min<long>(k, s - j), j + x);\\n                dp[t] = (dp[t] + dp[j]) % 1000000007;\\n            }\\n            s += x;\\n        }\\n        return dp[k];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int countPartitions(int[] nums, int k) {\\n        int []dp = new int[k+1];\\n        dp[0] = 1;\\n        int s = 0;\\n        for (int x: nums) {\\n            for (int j = Math.min(k, s); j >= 0; --j) {\\n                int t = Math.min(k, Math.min(s - j, j + x));\\n                dp[t] = (dp[t] + dp[j]) % 1000000007;\\n            }\\n            s = Math.min(s + x, 2 * k);\\n        }\\n        return dp[k];\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        dp = [1] + [0] * k\\n        s = 0\\n        for x in nums:\\n            for j in range(min(k, s), -1, -1):\\n                t = min(k, s - j, j + x)\\n                dp[t] = (dp[t] + dp[j]) % 1000000007\\n            s += x\\n        return dp[k]\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        vector<int> dp(k + 1, 0);\\n        dp[0] = 1;\\n        long s = 0;\\n        for (auto x: nums) {\\n            for (int j = min<long>(k, s); j >= 0; --j) {\\n                long t = min<long>(min<long>(k, s - j), j + x);\\n                dp[t] = (dp[t] + dp[j]) % 1000000007;\\n            }\\n            s += x;\\n        }\\n        return dp[k];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int countPartitions(int[] nums, int k) {\\n        int []dp = new int[k+1];\\n        dp[0] = 1;\\n        int s = 0;\\n        for (int x: nums) {\\n            for (int j = Math.min(k, s); j >= 0; --j) {\\n                int t = Math.min(k, Math.min(s - j, j + x));\\n                dp[t] = (dp[t] + dp[j]) % 1000000007;\\n            }\\n            s = Math.min(s + x, 2 * k);\\n        }\\n        return dp[k];\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        dp = [1] + [0] * k\\n        s = 0\\n        for x in nums:\\n            for j in range(min(k, s), -1, -1):\\n                t = min(k, s - j, j + x)\\n                dp[t] = (dp[t] + dp[j]) % 1000000007\\n            s += x\\n        return dp[k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991572,
                "title": "my-4-java-solutions-using-dp-memoization-tabulation-space-optimized",
                "content": "***Recursion + Memoization***\\n**Time Complexity: O(N*K)**\\n**Space Complexity: O(N*K)+O(N)**\\n```\\nclass Solution {\\n    int mod = (int)1e9 + 7;\\n    public int countPartitions(int[] nums, int k) {\\n        long sum = 0;\\n        for(int num : nums) sum += num;\\n        if(sum < 2 * k) return 0;\\n        int n = nums.length;\\n        int[][] memo = new int[n + 1][k + 1];\\n        for(int[] row : memo) Arrays.fill(row, -1);\\n        int notGreatPartitions = countPar(n, k, nums, memo);\\n        int total = (int)(Math.pow(2, n) % mod);\\n        return total - notGreatPartitions + (total < notGreatPartitions ? mod : 0);\\n    }\\n    private int countPar(int index, int k, int[] nums, int[][] memo) {\\n        if(index == 0) return 2;\\n        \\n        if(memo[index][k] != -1) return memo[index][k];\\n        \\n        int pick = k > nums[index - 1] ? countPar(index - 1, k - nums[index - 1], nums, memo) : 0;\\n        int notPick = countPar(index - 1, k, nums, memo);\\n        \\n        return memo[index][k] = (pick + notPick) % mod;\\n    }\\n}\\n```\\n____\\n\\n***Tabulation***\\n**Time Complexity: O(N*K)**\\n**Space Complexity: O(N*K)**\\n```\\nclass Solution {\\n    public int countPartitions(int[] nums, int k) {\\n        int mod = (int)1e9 + 7;\\n        long sum = 0;\\n        for(int num : nums) sum += num;\\n        if(sum < 2 * k) return 0;\\n        int n = nums.length;\\n        int[][] dp = new int[n + 1][k + 1];\\n        \\n        for(int target = 1 ;target <= k ;target++) dp[0][target] = 2;\\n        \\n        for(int index = 1 ;index <= n ;index++) {\\n            for(int target = 1 ;target <= k ;target++) {\\n                int pick = target > nums[index - 1] ? dp[index - 1][target - nums[index - 1]] : 0;\\n                int notPick = dp[index - 1][target];\\n                \\n                dp[index][target] = (pick + notPick) % mod;\\n            }\\n        }\\n        int notGreatPartitions = dp[n][k];\\n        int total = (int)(Math.pow(2, n) % mod);\\n        return total - notGreatPartitions + (total < notGreatPartitions ? mod : 0);\\n    }\\n}\\n```\\n______\\n\\n***Tabulation - Space Optimized***\\n**Time Complexity: O(N*K)**\\n**Space Complexity: O(2*K)**\\n```\\nclass Solution {\\n    public int countPartitions(int[] nums, int k) {\\n        int mod = (int)1e9 + 7;\\n        long sum = 0;\\n        for(int num : nums) sum += num;\\n        if(sum < 2 * k) return 0;\\n        int n = nums.length;\\n        int[] prev = new int[k + 1];\\n        \\n        for(int target = 1 ;target <= k ;target++) prev[target] = 2;\\n        \\n        for(int index = 1 ;index <= n ;index++) {\\n            int[] curr = new int[k + 1];\\n            for(int target = 1 ;target <= k ;target++) {\\n                int pick = target > nums[index - 1] ? prev[target - nums[index - 1]] : 0;\\n                int notPick = prev[target];\\n                \\n                curr[target] = (pick + notPick) % mod;\\n            }\\n            prev = curr;\\n        }\\n        int notGreatPartitions = prev[k];\\n        int total = (int)(Math.pow(2, n) % mod);\\n        return total - notGreatPartitions + (total < notGreatPartitions ? mod : 0);\\n    }\\n}\\n```\\n\\n_______\\n\\n***Tabulation - Single-Array Space Optimization***\\n**Time Complexity: O(N*K)**\\n**Space Complexity: O(K)**\\n```\\nclass Solution {\\n    public int countPartitions(int[] nums, int k) {\\n        int mod = (int)1e9 + 7;\\n        long sum = 0;\\n        for(int num : nums) sum += num;\\n        if(sum < 2 * k) return 0;\\n        int n = nums.length;\\n        int[] dp = new int[k + 1];\\n        \\n        for(int target = 1 ;target <= k ;target++) dp[target] = 2;\\n        \\n        for(int index = 1 ;index <= n ;index++) {\\n            for(int target = k ;target >= 1 ;target--) {\\n                int pick = target > nums[index - 1] ? dp[target - nums[index - 1]] : 0;\\n                int notPick = dp[target];\\n                \\n                dp[target] = (pick + notPick) % mod;\\n            }\\n        }\\n        int notGreatPartitions = dp[k];\\n        int total = (int)(Math.pow(2, n) % mod);\\n        return total - notGreatPartitions + (total < notGreatPartitions ? mod : 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (int)1e9 + 7;\\n    public int countPartitions(int[] nums, int k) {\\n        long sum = 0;\\n        for(int num : nums) sum += num;\\n        if(sum < 2 * k) return 0;\\n        int n = nums.length;\\n        int[][] memo = new int[n + 1][k + 1];\\n        for(int[] row : memo) Arrays.fill(row, -1);\\n        int notGreatPartitions = countPar(n, k, nums, memo);\\n        int total = (int)(Math.pow(2, n) % mod);\\n        return total - notGreatPartitions + (total < notGreatPartitions ? mod : 0);\\n    }\\n    private int countPar(int index, int k, int[] nums, int[][] memo) {\\n        if(index == 0) return 2;\\n        \\n        if(memo[index][k] != -1) return memo[index][k];\\n        \\n        int pick = k > nums[index - 1] ? countPar(index - 1, k - nums[index - 1], nums, memo) : 0;\\n        int notPick = countPar(index - 1, k, nums, memo);\\n        \\n        return memo[index][k] = (pick + notPick) % mod;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int countPartitions(int[] nums, int k) {\\n        int mod = (int)1e9 + 7;\\n        long sum = 0;\\n        for(int num : nums) sum += num;\\n        if(sum < 2 * k) return 0;\\n        int n = nums.length;\\n        int[][] dp = new int[n + 1][k + 1];\\n        \\n        for(int target = 1 ;target <= k ;target++) dp[0][target] = 2;\\n        \\n        for(int index = 1 ;index <= n ;index++) {\\n            for(int target = 1 ;target <= k ;target++) {\\n                int pick = target > nums[index - 1] ? dp[index - 1][target - nums[index - 1]] : 0;\\n                int notPick = dp[index - 1][target];\\n                \\n                dp[index][target] = (pick + notPick) % mod;\\n            }\\n        }\\n        int notGreatPartitions = dp[n][k];\\n        int total = (int)(Math.pow(2, n) % mod);\\n        return total - notGreatPartitions + (total < notGreatPartitions ? mod : 0);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int countPartitions(int[] nums, int k) {\\n        int mod = (int)1e9 + 7;\\n        long sum = 0;\\n        for(int num : nums) sum += num;\\n        if(sum < 2 * k) return 0;\\n        int n = nums.length;\\n        int[] prev = new int[k + 1];\\n        \\n        for(int target = 1 ;target <= k ;target++) prev[target] = 2;\\n        \\n        for(int index = 1 ;index <= n ;index++) {\\n            int[] curr = new int[k + 1];\\n            for(int target = 1 ;target <= k ;target++) {\\n                int pick = target > nums[index - 1] ? prev[target - nums[index - 1]] : 0;\\n                int notPick = prev[target];\\n                \\n                curr[target] = (pick + notPick) % mod;\\n            }\\n            prev = curr;\\n        }\\n        int notGreatPartitions = prev[k];\\n        int total = (int)(Math.pow(2, n) % mod);\\n        return total - notGreatPartitions + (total < notGreatPartitions ? mod : 0);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int countPartitions(int[] nums, int k) {\\n        int mod = (int)1e9 + 7;\\n        long sum = 0;\\n        for(int num : nums) sum += num;\\n        if(sum < 2 * k) return 0;\\n        int n = nums.length;\\n        int[] dp = new int[k + 1];\\n        \\n        for(int target = 1 ;target <= k ;target++) dp[target] = 2;\\n        \\n        for(int index = 1 ;index <= n ;index++) {\\n            for(int target = k ;target >= 1 ;target--) {\\n                int pick = target > nums[index - 1] ? dp[target - nums[index - 1]] : 0;\\n                int notPick = dp[target];\\n                \\n                dp[target] = (pick + notPick) % mod;\\n            }\\n        }\\n        int notGreatPartitions = dp[k];\\n        int total = (int)(Math.pow(2, n) % mod);\\n        return total - notGreatPartitions + (total < notGreatPartitions ? mod : 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972584,
                "title": "c-dp-memoization-simple-logic",
                "content": "```\\n\\n    long long dp[1001][1001];\\n    long long min(long long a,long long b){\\n        if(a<b)return a;\\n        return b;\\n    }\\n    int countPartitions(vector<int>& nums, int k) {\\n        vector<int>a,b;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums,k,0,0,0);\\n    }\\n    \\n    int solve(int st,vector<int>&nums,int &k,long long sm1,long long sm2,long long mnsm){\\n        if(st>=nums.size()){\\n            if(sm1>=k && sm2>=k)return 1;\\n            return 0;\\n        }\\n        if(dp[st][mnsm]!=-1)return dp[st][mnsm];\\n        \\n        long long a1=solve(st+1,nums,k,sm1+nums[st],sm2,min(1000,min(sm1+nums[st],sm2)));\\n        long long a2=solve(st+1,nums,k,sm1,sm2+nums[st],min(1000,min(sm1,sm2+nums[st])));\\n        \\n        return dp[st][mnsm]=(a1+a2)%(1000000007);\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\n    long long dp[1001][1001];\\n    long long min(long long a,long long b){\\n        if(a<b)return a;\\n        return b;\\n    }\\n    int countPartitions(vector<int>& nums, int k) {\\n        vector<int>a,b;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums,k,0,0,0);\\n    }\\n    \\n    int solve(int st,vector<int>&nums,int &k,long long sm1,long long sm2,long long mnsm){\\n        if(st>=nums.size()){\\n            if(sm1>=k && sm2>=k)return 1;\\n            return 0;\\n        }\\n        if(dp[st][mnsm]!=-1)return dp[st][mnsm];\\n        \\n        long long a1=solve(st+1,nums,k,sm1+nums[st],sm2,min(1000,min(sm1+nums[st],sm2)));\\n        long long a2=solve(st+1,nums,k,sm1,sm2+nums[st],min(1000,min(sm1,sm2+nums[st])));\\n        \\n        return dp[st][mnsm]=(a1+a2)%(1000000007);\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2948633,
                "title": "python-knapsack-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt says the number can grow really big, which leads me thinking about DP, and from there goes to Knapsack problem.\\n\\nAnd given the constraint `1 <= nums.length, k <= 1000`, I guess this is a 2 dimensional dp (with 2 loops).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are in total `2^n` combinations, if we can find the ones that do not suffice the condition, the combinations of `total sum < k`, then we can get the result by substraction. (I originally tried to get the `#combinations` that are greater than k, the number would grow too big and TLE).\\n\\nIn this case, the Knapsack\\'s capacity is `k-1` (less than `k`), and we have `n` items. `dp[i][j]` means the total number of combinations at `ith` item given capacity `j`.\\n\\n# Complexity\\n- Time complexity: `O(nk)`\\n\\n- Space complexity: `O(nk)`\\n\\n# Code\\n```\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        M = 10**9+7\\n        s, n = sum(nums), len(nums)\\n        if s < 2*k:\\n            return 0\\n\\n        dp = [[0 for _ in range(k)] for _ in range(n)]\\n        for i, v in enumerate(nums):\\n            for j in range(k):\\n                if i == 0:\\n                    if j - v >= 0:\\n                        dp[i][j] = 2  # one can either put or not put the item\\n                    else:\\n                        dp[i][j] = 1  # can only not put the item\\n                    continue\\n                dp[i][j] = dp[i-1][j]\\n                if j - v >= 0:\\n                    dp[i][j] += dp[i-1][j-v]\\n        return (2**n - 2*dp[n-1][k-1]) % M\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        M = 10**9+7\\n        s, n = sum(nums), len(nums)\\n        if s < 2*k:\\n            return 0\\n\\n        dp = [[0 for _ in range(k)] for _ in range(n)]\\n        for i, v in enumerate(nums):\\n            for j in range(k):\\n                if i == 0:\\n                    if j - v >= 0:\\n                        dp[i][j] = 2  # one can either put or not put the item\\n                    else:\\n                        dp[i][j] = 1  # can only not put the item\\n                    continue\\n                dp[i][j] = dp[i-1][j]\\n                if j - v >= 0:\\n                    dp[i][j] += dp[i-1][j-v]\\n        return (2**n - 2*dp[n-1][k-1]) % M\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948062,
                "title": "c-simple-dp",
                "content": "# Intuition\\n1. The number of ways dividing `nums` to 2 partition is `O(2^n)`, which is huge to try out all possible ways.\\n1. But the number of ways to sum to `k` is manageable, which is `O(1000^2)`.\\n1. The answer is the total number of possible distributions (2 ^ n) - the sum of the number of ways that sums to the value from 0 to k - 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Calculate the total number of ways of dividing `nums` into 2 partitions `2^n`\\n2. Calculate the number of ways that sums to `t`, where 0 < `t` < k - 1, with a dp array\\n3. The answer is `2 ^ n - [sum of (dp[0] ... dp[k - 1) * 2]`\\n\\np.s. Be careful of `mod` operations.\\n\\n# Complexity\\n- Time complexity: O(k^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        long long sum = accumulate(nums.begin(), nums.end(), 0L);\\n        int n = nums.size();\\n        if (n == 1 || sum / 2 < k) {\\n            return 0;\\n        }\\n        const int mod = 1e9 + 7;\\n        sort(nums.begin(), nums.end());\\n        long long all_ways = 1;\\n        for (int i = 0; i < n; i++) {\\n            all_ways = (all_ways * 2) % mod;\\n        }\\n        vector<long long> ways_sum_to_n(k);\\n        ways_sum_to_n[0] = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = k - nums[i] - 1; j >= 0; j--) {\\n                int t = nums[i] + j;\\n                ways_sum_to_n[t] = (ways_sum_to_n[t] + ways_sum_to_n[j]) % mod;\\n            }\\n        }\\n        long long undesired_ways = accumulate(ways_sum_to_n.begin(), ways_sum_to_n.end(), 0LL);\\n        undesired_ways = (undesired_ways * 2) % mod;\\n        return (all_ways - undesired_ways + mod) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        long long sum = accumulate(nums.begin(), nums.end(), 0L);\\n        int n = nums.size();\\n        if (n == 1 || sum / 2 < k) {\\n            return 0;\\n        }\\n        const int mod = 1e9 + 7;\\n        sort(nums.begin(), nums.end());\\n        long long all_ways = 1;\\n        for (int i = 0; i < n; i++) {\\n            all_ways = (all_ways * 2) % mod;\\n        }\\n        vector<long long> ways_sum_to_n(k);\\n        ways_sum_to_n[0] = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = k - nums[i] - 1; j >= 0; j--) {\\n                int t = nums[i] + j;\\n                ways_sum_to_n[t] = (ways_sum_to_n[t] + ways_sum_to_n[j]) % mod;\\n            }\\n        }\\n        long long undesired_ways = accumulate(ways_sum_to_n.begin(), ways_sum_to_n.end(), 0LL);\\n        undesired_ways = (undesired_ways * 2) % mod;\\n        return (all_ways - undesired_ways + mod) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948027,
                "title": "java-dp-recursion-memoization",
                "content": "\"\"\"\\n\\n\\tclass Solution { \\n\\n\\tprivate Long[][] dp;   // to calculate 2^x\\n    private Long[][] dp1;  // for group1\\n    private Long[][] dp2;  // for group2\\n    \\n    private long pow(int x, int k, long mod){\\n        long ans = 1;\\n        if(dp[x][k]!=null) return dp[x][k];\\n        if(k==1) return dp[x][k] =  (long)x;\\n        return dp[x][k] = (x*pow(x,k-1,mod))%mod;\\n        \\n    }\\n    \\n    \\n    // here g1 = sum of first group elements, g2 = sum of second group elements, curr is the index which we are operating on currently.\\n    private long solve(int[] nums, int curr, long g1, long g2, int k){\\n        int n = nums.length;\\n        long m = 1_000_000_007;\\n        \\n        if(curr>=n){                //base case\\n            if(g1>=k && g2>=k){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if(g1>=k && g2>=k){        //if both the groups have sum greater than or equal to k, then we just need to find 2^(remaining);\\n            return pow(2,n-curr,m);\\n        }\\n        \\n        if(g1<=k && dp1[curr][(int)g1]!=null) return dp1[curr][(int)g1];      //if already calculated then return from here\\n        if(g2<=k && dp2[curr][(int)g2]!=null) return dp2[curr][(int)g2];      //if already calculated then return from here\\n        \\n        \\n        //in each step, we have two choices, either the current element goes in the first group or in the second group\\n        long ans =  (solve(nums,curr+1,g1+(long)nums[curr],g2,k) + solve(nums,curr+1,g1,g2+(long)nums[curr],k))%m;\\n        \\n        \\n        if(g1<=k){\\n            dp1[curr][(int)g1] = ans;  //memoization\\n        }\\n        if(g2<=k){\\n            dp2[curr][(int)g2] = ans;  //memoizaton\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    public int countPartitions(int[] nums, int k) {\\n        int n = nums.length;\\n        dp1 = new Long[n+1][k+1]; // for group 1\\n        dp2 = new Long[n+1][k+1]; // for group 2\\n        dp = new Long[n+1][n+1];  // to calculate pow(2,k)\\n        return (int)solve(nums,0,0,0,k);\\n    }\\n\\t}\\n\"\"\"",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution { \\n\\n\\tprivate Long[][] dp;   // to calculate 2^x\\n    private Long[][] dp1;  // for group1\\n    private Long[][] dp2;  // for group2\\n    \\n    private long pow(int x, int k, long mod){\\n        long ans = 1;\\n        if(dp[x][k]!=null) return dp[x][k];\\n        if(k==1) return dp[x][k] =  (long)x;\\n        return dp[x][k] = (x*pow(x,k-1,mod))%mod;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3377047,
                "title": "rust-solution-beats-100",
                "content": "# Intuition\\n\\nTODO\\n\\n# Approach\\n\\nDP\\n\\n# Complexity\\n- Time complexity:\\n    $$\\n    O(n \\\\times k)\\n    $$\\n- Space complexity:\\n    $$\\n    O(k)\\n    $$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn count_partitions(nums: Vec<i32>, k: i32) -> i32 {\\n        let (m,n,k) = (1000000007_u32, nums.len(), k as usize);\\n        if nums.iter().map(|&v| v as usize).sum::<usize>() < k * 2 {0} else {(((0..n).fold(1, |y, _| y * 2 % m) + m * 2 - (1..n).fold((0..k).map(|i| 1 + u32::from((nums[0] as usize) <= i)).collect::<Vec<_>>(),|y, x|(0..k).map(|i| if i >= nums[x] as usize {(y[i] + y[i - nums[x] as usize]) % m} else {y[i]}).collect::<Vec<_>>())[k - 1] * 2)% m) as i32}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_partitions(nums: Vec<i32>, k: i32) -> i32 {\\n        let (m,n,k) = (1000000007_u32, nums.len(), k as usize);\\n        if nums.iter().map(|&v| v as usize).sum::<usize>() < k * 2 {0} else {(((0..n).fold(1, |y, _| y * 2 % m) + m * 2 - (1..n).fold((0..k).map(|i| 1 + u32::from((nums[0] as usize) <= i)).collect::<Vec<_>>(),|y, x|(0..k).map(|i| if i >= nums[x] as usize {(y[i] + y[i - nums[x] as usize]) % m} else {y[i]}).collect::<Vec<_>>())[k - 1] * 2)% m) as i32}\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2952556,
                "title": "c-python-2-solutions-top-down-dp-explained",
                "content": "# Intuition\\nTop Down DP+Memoization\\n\\n# C++ Approach\\nidx stands for aray index, ssum stands for sum of either subset (1st or 2nd depending on flag).\\nflag1 denotes we have sum>=k for subset 1 and flag2 denotes we have sum>=k for subset2.\\nRest things are commented in code.\\n\\n# Complexity\\n- Time complexity:\\nO(n*k)\\n\\n- Space complexity:\\nO(n*k)\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7,n,k;\\n    long long ssum2;\\n    vector <long long> pre_sum;\\n    vector <int> nums;\\n    int memo[1005][1005][2][2];\\n    //what we just want is flag1 && flag2 to be True\\n    int dp(int idx,int ssum,int flag1,int flag2){\\n        if (idx==n) return (flag1 && flag2)?1:0;\\n        if (memo[idx][ssum][flag1][flag2]!=-1) return memo[idx][ssum][flag1][flag2];\\n        long long ans=0;\\n        //got first subset covered\\n        if (flag1){\\n            //got 2nd covered too, now nothing matters which idx goes to which subset\\n                if (flag2) ans+=2*dp(idx+1,ssum,flag1,flag2);\\n                //2nd subset not yet covered\\n                else{\\n                    //if 2nd subset is covered, make ssum 0 coz now flag1 and flag1 is True and we dont care avbout ssum anymore\\n                    if (ssum+nums[idx]>=k) ans+=dp(idx+1,0,flag1,1);\\n                    //if 2nd is not covered ,adding idx to 2nd subset\\n                    else ans+=dp(idx+1,ssum+nums[idx],flag1,flag2);\\n                    //this goes to first subset irrespective of wheather 2nd is covered or not\\n                    ans+=dp(idx+1,ssum,flag1,flag2);\\n                    }\\n            }\\n            //first subset not yet covered\\n            else{\\n                //got first covered\\n                if (ssum+nums[idx]>=k) {\\n                    //sum of 2nd subset till now, calculated using prefix sum array\\n                    ssum2=pre_sum[idx+1]-(ssum+nums[idx]);\\n                    //checking if 2nd is covered too\\n                    if (ssum2>=k) ans+=dp(idx+1,0,1,1);\\n                    //2nd not covered\\n                    else ans+=dp(idx+1,ssum2,1,flag2);\\n                    }\\n                // didnt get first covered yet,adding idx to first subset\\n                else ans+=dp(idx+1,ssum+nums[idx],flag1,flag2);\\n                //this goes to second subset irrespective of wheather first is covered or not\\n                ans+=dp(idx+1,ssum,flag1,flag2);\\n                }\\n            return memo[idx][ssum][flag1][flag2]=ans%mod;\\n    }\\n    int countPartitions(vector<int>& Nums, int K) {\\n        nums=Nums,k=K;\\n        n=nums.size();\\n        pre_sum.resize(n+1,0);\\n        for (int i=0;i<n;i++){\\n            pre_sum[i+1]=pre_sum[i]+nums[i];\\n        }\\n        memset(memo,-1,sizeof(memo));\\n        return dp(0,0,0,0)%mod;\\n    }\\n};\\n```\\n# Python Approach\\nConsider all invalid cases and subtract from total cases.\\nAll such cases are where we have sum of our current subset<k.\\n\\nFor an invalid case if only/exclusively ssum<k or \\ntotal_sum-ssum< k then we can exchange both sets as the other set is having sum>=k and we wont encounter it, so we return 2.\\nIf both ssum<k and total_sum-ssum<k , then we return 1 as there will be some other case with total_sum as ssum.\\n\\n# Python Code\\n```\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        mod=10**9+7\\n        Sum=sum(nums)\\n        @cache\\n        def dp(idx,ssum):\\n            if idx==n:\\n                if ssum<k and Sum-ssum<k: return 1\\n                return 2\\n            ans=0\\n            #take sum\\n            if ssum+nums[idx]<k:\\n                ans+=dp(idx+1,ssum+nums[idx])\\n            #dont take\\n            ans+=dp(idx+1,ssum)\\n            return ans%mod\\n        return (pow(2,n,mod)-dp(0,0))%mod\\n            \\n            \\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7,n,k;\\n    long long ssum2;\\n    vector <long long> pre_sum;\\n    vector <int> nums;\\n    int memo[1005][1005][2][2];\\n    //what we just want is flag1 && flag2 to be True\\n    int dp(int idx,int ssum,int flag1,int flag2){\\n        if (idx==n) return (flag1 && flag2)?1:0;\\n        if (memo[idx][ssum][flag1][flag2]!=-1) return memo[idx][ssum][flag1][flag2];\\n        long long ans=0;\\n        //got first subset covered\\n        if (flag1){\\n            //got 2nd covered too, now nothing matters which idx goes to which subset\\n                if (flag2) ans+=2*dp(idx+1,ssum,flag1,flag2);\\n                //2nd subset not yet covered\\n                else{\\n                    //if 2nd subset is covered, make ssum 0 coz now flag1 and flag1 is True and we dont care avbout ssum anymore\\n                    if (ssum+nums[idx]>=k) ans+=dp(idx+1,0,flag1,1);\\n                    //if 2nd is not covered ,adding idx to 2nd subset\\n                    else ans+=dp(idx+1,ssum+nums[idx],flag1,flag2);\\n                    //this goes to first subset irrespective of wheather 2nd is covered or not\\n                    ans+=dp(idx+1,ssum,flag1,flag2);\\n                    }\\n            }\\n            //first subset not yet covered\\n            else{\\n                //got first covered\\n                if (ssum+nums[idx]>=k) {\\n                    //sum of 2nd subset till now, calculated using prefix sum array\\n                    ssum2=pre_sum[idx+1]-(ssum+nums[idx]);\\n                    //checking if 2nd is covered too\\n                    if (ssum2>=k) ans+=dp(idx+1,0,1,1);\\n                    //2nd not covered\\n                    else ans+=dp(idx+1,ssum2,1,flag2);\\n                    }\\n                // didnt get first covered yet,adding idx to first subset\\n                else ans+=dp(idx+1,ssum+nums[idx],flag1,flag2);\\n                //this goes to second subset irrespective of wheather first is covered or not\\n                ans+=dp(idx+1,ssum,flag1,flag2);\\n                }\\n            return memo[idx][ssum][flag1][flag2]=ans%mod;\\n    }\\n    int countPartitions(vector<int>& Nums, int K) {\\n        nums=Nums,k=K;\\n        n=nums.size();\\n        pre_sum.resize(n+1,0);\\n        for (int i=0;i<n;i++){\\n            pre_sum[i+1]=pre_sum[i]+nums[i];\\n        }\\n        memset(memo,-1,sizeof(memo));\\n        return dp(0,0,0,0)%mod;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        mod=10**9+7\\n        Sum=sum(nums)\\n        @cache\\n        def dp(idx,ssum):\\n            if idx==n:\\n                if ssum<k and Sum-ssum<k: return 1\\n                return 2\\n            ans=0\\n            #take sum\\n            if ssum+nums[idx]<k:\\n                ans+=dp(idx+1,ssum+nums[idx])\\n            #dont take\\n            ans+=dp(idx+1,ssum)\\n            return ans%mod\\n        return (pow(2,n,mod)-dp(0,0))%mod\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949689,
                "title": "easy-short-efficient-clean-code",
                "content": "```c++\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\nll n, mod=1e9+7;\\nvi(vi(ll))dp;\\nll func(const vi(int)&v, ll in, ll sum, const int&k){\\n    if(sum>=k){\\n        return 0;\\n    }\\n    if(in==n){\\n        return 1;\\n    }\\n    ll&ans=dp[in][sum];\\n    if(ans==-1){\\n        ans=(func(v, in+1, sum+v[in], k)+func(v, in+1, sum, k))%mod;\\n    }\\n    return ans;\\n}\\n    int countPartitions(vector<int>&v, int k) {\\n        n=v.size();\\n        if(accumulate(begin(v), end(v), 0LL)<2*k){\\n            return 0;\\n        }\\n        dp.resize(n, vi(ll)(k+1, -1));\\n        ll tot=1;\\n        for(ll i=0;i<n;++i){\\n            tot=(tot*2)%mod;\\n        }\\n        return (tot-(2LL*func(v, 0, 0, k))+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```c++\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\nll n, mod=1e9+7;\\nvi(vi(ll))dp;\\nll func(const vi(int)&v, ll in, ll sum, const int&k){\\n    if(sum>=k){\\n        return 0;\\n    }\\n    if(in==n){\\n        return 1;\\n    }\\n    ll&ans=dp[in][sum];\\n    if(ans==-1){\\n        ans=(func(v, in+1, sum+v[in], k)+func(v, in+1, sum, k))%mod;\\n    }\\n    return ans;\\n}\\n    int countPartitions(vector<int>&v, int k) {\\n        n=v.size();\\n        if(accumulate(begin(v), end(v), 0LL)<2*k){\\n            return 0;\\n        }\\n        dp.resize(n, vi(ll)(k+1, -1));\\n        ll tot=1;\\n        for(ll i=0;i<n;++i){\\n            tot=(tot*2)%mod;\\n        }\\n        return (tot-(2LL*func(v, 0, 0, k))+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948560,
                "title": "c-find-invalid-cases-o-n-k",
                "content": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll mod = 1e9+7;\\n    int countPartitions(vector<int>& nums, int k) {\\n        ll sum = accumulate(nums.begin(), nums.end(), 0LL);\\n        \\n        // initial check, whether there\\'s possible answer\\n        if (2 * k > sum) return 0;\\n        \\n        // count of groups\\' sums, up to k-1\\n        vector<ll> dp(k);\\n        dp[0] = 1;\\n        \\n        for (auto c: nums) {\\n            for (int i = k-1; i >= c; --i) {\\n                dp[i] = (dp[i] + dp[i-c]) % mod;\\n            }\\n        }\\n        \\n        // all groups whose sum is less than k\\n        ll res = 0;\\n        for (int i = 0; i < k; ++i) {\\n            res = (res + dp[i]) % mod;\\n        }\\n        \\n        // count of all partitions\\n        ll total = 1;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            total = (total * 2) % mod;\\n        }\\n        \\n        // as the group with sum less than k could be either be the first or the second, we need to double the count\\n        return (total + 2 * mod - res * 2) % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll mod = 1e9+7;\\n    int countPartitions(vector<int>& nums, int k) {\\n        ll sum = accumulate(nums.begin(), nums.end(), 0LL);\\n        \\n        // initial check, whether there\\'s possible answer\\n        if (2 * k > sum) return 0;\\n        \\n        // count of groups\\' sums, up to k-1\\n        vector<ll> dp(k);\\n        dp[0] = 1;\\n        \\n        for (auto c: nums) {\\n            for (int i = k-1; i >= c; --i) {\\n                dp[i] = (dp[i] + dp[i-c]) % mod;\\n            }\\n        }\\n        \\n        // all groups whose sum is less than k\\n        ll res = 0;\\n        for (int i = 0; i < k; ++i) {\\n            res = (res + dp[i]) % mod;\\n        }\\n        \\n        // count of all partitions\\n        ll total = 1;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            total = (total * 2) % mod;\\n        }\\n        \\n        // as the group with sum less than k could be either be the first or the second, we need to double the count\\n        return (total + 2 * mod - res * 2) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948116,
                "title": "subset-sum-all-except-less-than-k",
                "content": "```\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        M = 10 ** 9 + 7\\n        n = len(nums)\\n        total = sum(nums)\\n        if 2 * k > total:\\n            return 0\\n        dp = [0] * k\\n        dp[0] = 1\\n        for el in nums:\\n            for i in range(k - el - 1, -1, -1):\\n                dp[i + el] += dp[i]\\n        res = 0\\n        for i in range(k):\\n            res += dp[i]\\n        return ((1 << n) - 2 * res) % M\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        M = 10 ** 9 + 7\\n        n = len(nums)\\n        total = sum(nums)\\n        if 2 * k > total:\\n            return 0\\n        dp = [0] * k\\n        dp[0] = 1\\n        for el in nums:\\n            for i in range(k - el - 1, -1, -1):\\n                dp[i + el] += dp[i]\\n        res = 0\\n        for i in range(k):\\n            res += dp[i]\\n        return ((1 << n) - 2 * res) % M\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948087,
                "title": "simple-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be solved recursively; it is good to use caching.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used a recursive function to compute the number of partitions of the first i elements such that the first partition\\'s sum is at least k1 and the second partition\\'s sum is at least k2.\\nThe function takes three arguments: i, k1, and k2.\\nIf the i-th list element is n=nums[i], then among just the first i-1 elements:\\n* either the first sum is at least k1-n and the second sum is at least k2\\n* or the first is at least k1 and the second is at least k2-n.\\n\\nAt each step we add up these two results obtained by recursion. This is similar to a method for computing binomial coefficients, called Pascal\\'s triangle.\\n\\nIf k1-n or k2-n is negative, we can replace it by 0; then there will be fewer items to cache, because we do not need to keep track of negative arguments.\\n\\nThis takes a long time (around 5 seconds) and a lot of memory, but it works, due to the caching, which makes it so that we only compute each value during the recursion exactly once (and there are many overlaps). Otherwise, there would have been up to $2^{1000}$ computations.\\n\\n# Code\\n```\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        p=10**9+7\\n        s=sum(nums)\\n        if s<2*k:\\n            return 0\\n        \\n        @cache\\n        def ct(i, k1, k2):\\n            n=nums[i]\\n            if i==0:\\n                ans=0\\n                if n>=k1 and k2==0:\\n                    ans+=1\\n                if n>=k2 and k1==0:\\n                    ans+=1\\n                return ans\\n            t1=max(k1-n, 0)\\n            t2=max(k2-n, 0)\\n            return (ct(i-1, t1, k2)+ct(i-1, k1, t2))%p\\n        \\n        return ct(len(nums)-1, k, k)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        p=10**9+7\\n        s=sum(nums)\\n        if s<2*k:\\n            return 0\\n        \\n        @cache\\n        def ct(i, k1, k2):\\n            n=nums[i]\\n            if i==0:\\n                ans=0\\n                if n>=k1 and k2==0:\\n                    ans+=1\\n                if n>=k2 and k1==0:\\n                    ans+=1\\n                return ans\\n            t1=max(k1-n, 0)\\n            t2=max(k2-n, 0)\\n            return (ct(i-1, t1, k2)+ct(i-1, k1, t2))%p\\n        \\n        return ct(len(nums)-1, k, k)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948001,
                "title": "knapsack-and-principle-of-inclusion-and-exclusion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = 1000000007;\\n    \\n    public int countPartitions(int[] nums, int k) {     \\n        int n = nums.length;\\n        int[][] dp = new int[n + 1][k + 1];\\n        for (int i = 0; i <= n; i++) dp[i][0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = k; j >= 1; j--) {\\n                dp[i][j] = dp[i - 1][j];\\n                if (j - nums[i - 1] >= 0) {                    \\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - nums[i - 1]]) % mod;\\n                }\\n                \\n            }\\n        }\\n        int sum = 0;\\n        for (int num : nums) {\\n            sum += num;\\n            if (sum >= 2000) {\\n                break;\\n            }\\n        }\\n        long no = 0, total = 1, dupNo = 0;\\n        \\n        for (int j = 0; j < k; j++) {\\n            no = (no + dp[n][j]) % mod;\\n            if (sum - j < k) dupNo = (dupNo + dp[n][j]) % mod;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            total = (total * 2) % mod;\\n        }        \\n        \\n        long res = ((total - 2 * no + dupNo) % mod + mod) % mod;\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    \\n    public int countPartitions(int[] nums, int k) {     \\n        int n = nums.length;\\n        int[][] dp = new int[n + 1][k + 1];\\n        for (int i = 0; i <= n; i++) dp[i][0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = k; j >= 1; j--) {\\n                dp[i][j] = dp[i - 1][j];\\n                if (j - nums[i - 1] >= 0) {                    \\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - nums[i - 1]]) % mod;\\n                }\\n                \\n            }\\n        }\\n        int sum = 0;\\n        for (int num : nums) {\\n            sum += num;\\n            if (sum >= 2000) {\\n                break;\\n            }\\n        }\\n        long no = 0, total = 1, dupNo = 0;\\n        \\n        for (int j = 0; j < k; j++) {\\n            no = (no + dp[n][j]) % mod;\\n            if (sum - j < k) dupNo = (dupNo + dp[n][j]) % mod;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            total = (total * 2) % mod;\\n        }        \\n        \\n        long res = ((total - 2 * no + dupNo) % mod + mod) % mod;\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991685,
                "title": "reverse-thinking-o-n-k",
                "content": "insted of counting good sets we can find sets which have sum less than k(see solve function) then we will subtract twice of it in number  of non empty partation of array having size of n (see pow function)\\n```\\nTIME  : O(N*K)\\nSPACE : O(N*K)\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int n=0;\\n    int m=1e9+7;\\n    int dp[1001][1001];\\n    int solve(int i, int sum, int k,vector<int>&a)\\n    {\\n        if(sum>=k || i==n) return sum>0 && sum<k;// less than && non empty sets only \\n\\t\\t// if u think it will cover the all element set then u r wrong it won\\'t bcz sum will exceed and return 0  \\n\\t\\t// So effectively it count set which have less sum so we can say it either group 1 or group 2 so in total we will form twice the no of these sets \\n        if(dp[i][sum]!=-1) return dp[i][sum];\\n        int ans=0;\\n        ans+=solve(i+1,sum,k,a)%m;\\n        ans+=solve(i+1,sum+a[i],k,a)%m;\\n        return dp[i][sum]=ans%m;\\n    }\\n    long long pow(long long val, int n)\\n    {\\n        if(n==0) return 1;\\n        if(n%2)  return (pow((1ll*val*val)%m,n/2)*val)%m;\\n        else return pow((1ll*val*val)%m, n/2)%m;\\n    }\\n    int countPartitions(vector<int>& a, int k) \\n    {\\n\\t    sort(a.begin(), a.end());\\n        long long sum=0;\\n        for(auto i: a) sum+=i;\\n        if(sum<2*k ||  a1.size()<2) return 0;\\n        memset(dp,-1,sizeof(dp));\\n        n=a.size();\\n        long long total= pow(2,n)-2;// non empty sets ->{ phi } and  {all element set} will form empty groups so subtract as in solve function we are taking only non empty sets\\n        // cout<<total<<endl;\\n        total-=2*solve(0,0,k)%m;\\n        return (total+m)%m;// incase of negative it will save\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nTIME  : O(N*K)\\nSPACE : O(N*K)\\n```\n```\\nclass Solution {\\npublic:\\n    int n=0;\\n    int m=1e9+7;\\n    int dp[1001][1001];\\n    int solve(int i, int sum, int k,vector<int>&a)\\n    {\\n        if(sum>=k || i==n) return sum>0 && sum<k;// less than && non empty sets only \\n\\t\\t// if u think it will cover the all element set then u r wrong it won\\'t bcz sum will exceed and return 0  \\n\\t\\t// So effectively it count set which have less sum so we can say it either group 1 or group 2 so in total we will form twice the no of these sets \\n        if(dp[i][sum]!=-1) return dp[i][sum];\\n        int ans=0;\\n        ans+=solve(i+1,sum,k,a)%m;\\n        ans+=solve(i+1,sum+a[i],k,a)%m;\\n        return dp[i][sum]=ans%m;\\n    }\\n    long long pow(long long val, int n)\\n    {\\n        if(n==0) return 1;\\n        if(n%2)  return (pow((1ll*val*val)%m,n/2)*val)%m;\\n        else return pow((1ll*val*val)%m, n/2)%m;\\n    }\\n    int countPartitions(vector<int>& a, int k) \\n    {\\n\\t    sort(a.begin(), a.end());\\n        long long sum=0;\\n        for(auto i: a) sum+=i;\\n        if(sum<2*k ||  a1.size()<2) return 0;\\n        memset(dp,-1,sizeof(dp));\\n        n=a.size();\\n        long long total= pow(2,n)-2;// non empty sets ->{ phi } and  {all element set} will form empty groups so subtract as in solve function we are taking only non empty sets\\n        // cout<<total<<endl;\\n        total-=2*solve(0,0,k)%m;\\n        return (total+m)%m;// incase of negative it will save\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3988260,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution { \\n\\nprivate Long[][] dp;   \\nprivate Long[][] dp1; \\nprivate Long[][] dp2;  \\n\\nprivate long pow(int x, int k, long mod){\\n    long ans = 1;\\n    if(dp[x][k]!=null) return dp[x][k];\\n    if(k==1) return dp[x][k] =  (long)x;\\n    return dp[x][k] = (x*pow(x,k-1,mod))%mod;\\n    \\n}\\n\\n\\n\\nprivate long solve(int[] nums, int curr, long g1, long g2, int k){\\n    int n = nums.length;\\n    long m = 1_000_000_007;\\n    \\n    if(curr>=n){                \\n        if(g1>=k && g2>=k){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    \\n    if(g1>=k && g2>=k){       \\n        return pow(2,n-curr,m);\\n    }\\n    \\n    if(g1<=k && dp1[curr][(int)g1]!=null) return dp1[curr][(int)g1];     \\n    if(g2<=k && dp2[curr][(int)g2]!=null) return dp2[curr][(int)g2];     \\n    \\n    \\n  \\n    long ans =  (solve(nums,curr+1,g1+(long)nums[curr],g2,k) + solve(nums,curr+1,g1,g2+(long)nums[curr],k))%m;\\n    \\n    \\n    if(g1<=k){\\n        dp1[curr][(int)g1] = ans;  \\n    }\\n    if(g2<=k){\\n        dp2[curr][(int)g2] = ans;  \\n    }\\n    return ans;\\n    \\n}\\n\\npublic int countPartitions(int[] nums, int k) {\\n    int n = nums.length;\\n    dp1 = new Long[n+1][k+1]; \\n    dp2 = new Long[n+1][k+1]; \\n    dp = new Long[n+1][n+1];  \\n    return (int)solve(nums,0,0,0,k);\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution { \\n\\nprivate Long[][] dp;   \\nprivate Long[][] dp1; \\nprivate Long[][] dp2;  \\n\\nprivate long pow(int x, int k, long mod){\\n    long ans = 1;\\n    if(dp[x][k]!=null) return dp[x][k];\\n    if(k==1) return dp[x][k] =  (long)x;\\n    return dp[x][k] = (x*pow(x,k-1,mod))%mod;\\n    \\n}\\n\\n\\n\\nprivate long solve(int[] nums, int curr, long g1, long g2, int k){\\n    int n = nums.length;\\n    long m = 1_000_000_007;\\n    \\n    if(curr>=n){                \\n        if(g1>=k && g2>=k){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    \\n    if(g1>=k && g2>=k){       \\n        return pow(2,n-curr,m);\\n    }\\n    \\n    if(g1<=k && dp1[curr][(int)g1]!=null) return dp1[curr][(int)g1];     \\n    if(g2<=k && dp2[curr][(int)g2]!=null) return dp2[curr][(int)g2];     \\n    \\n    \\n  \\n    long ans =  (solve(nums,curr+1,g1+(long)nums[curr],g2,k) + solve(nums,curr+1,g1,g2+(long)nums[curr],k))%m;\\n    \\n    \\n    if(g1<=k){\\n        dp1[curr][(int)g1] = ans;  \\n    }\\n    if(g2<=k){\\n        dp2[curr][(int)g2] = ans;  \\n    }\\n    return ans;\\n    \\n}\\n\\npublic int countPartitions(int[] nums, int k) {\\n    int n = nums.length;\\n    dp1 = new Long[n+1][k+1]; \\n    dp2 = new Long[n+1][k+1]; \\n    dp = new Long[n+1][n+1];  \\n    return (int)solve(nums,0,0,0,k);\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962747,
                "title": "commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nwe are asked to find the number of arrangement that both have size > k.\\nWe can find out the number of cases that have size <= k,\\nthen that a more regular Knapsack problem.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int mod = 1e9 + 7;  // Modulus value for taking modulo of intermediate and final results\\n\\n// Function to find the total number of subsets in the array with sums smaller than \\'wt\\'\\nint allSubsetSum(vector<int>& nums, int n, int wt, vector<vector<int>>& cache) {\\n    if (wt == 0) return 0;  // If target sum \\'wt\\' is reached, return 0 (no subsets)\\n    if (n == 0) return 1;   // If there are no elements left, return 1 (empty subset)\\n/* \\n\\n\\nif (wt == 0) return 0;: This condition checks whether the target sum wt is reached. If it is, it means that a subset has been found whose sum equals wt. However, in the context of this problem, you\\'re looking for subsets with sums strictly smaller than wt. So, when wt becomes 0, you return 0 to signify that a subset with the desired property hasn\\'t been found.\\n\\nif (n == 0) return 1;: This condition checks whether there are no elements left to consider in the array. If n becomes 0, it means that you\\'ve considered all elements and have reached the end of the array. In the context of counting subsets, an empty set is also considered a valid subset, and it has a sum of 0. Therefore, you return 1 to signify that there\\'s at least one empty subset (with a sum of 0).*/\\n    if (cache[n][wt] != -1) return cache[n][wt];  // If already computed, return from cache\\n\\n    int taken = 0;\\n    int notTaken = allSubsetSum(nums, n - 1, wt, cache);  // Count subsets without including the current element\\n\\n    if (nums[n - 1] < wt) {\\n        taken = allSubsetSum(nums, n - 1, wt - nums[n - 1], cache);  // Count subsets including the current element\\n    }\\n\\n    // Store the result in cache and take modulo to prevent overflow\\n    return cache[n][wt] = (taken + notTaken) % mod;\\n}\\n\\nint countPartitions(vector<int>& nums, int k) {\\n    int n = nums.size();\\n\\n    int totalSum = 0;\\n    for (int value : nums)\\n        totalSum = (totalSum + value) % mod;\\n\\n    if (totalSum / 2 < k)\\n        return 0;  // If the sum of all elements divided by 2 is less than \\'k\\', return 0\\n\\n    vector<vector<int>> cache(n + 2, vector<int>(k + 2, -1));  // Initialize cache with -1\\n\\n    // Calculate the count of all subsets whose sum is less than \\'k\\'\\n    int invalidSubset = allSubsetSum(nums, n, k, cache);\\n\\n    int totalSubset = 1;  // Initialize total number of subsets\\n\\n    // Calculate the total number of subset pairs using the formula (2^n) % mod\\n    for (int i = 1; i <= n; i++) {\\n        totalSubset = (totalSubset * 2) % mod;\\n    }\\n\\n    int greatPartition = totalSubset - 2 * invalidSubset;  // Calculate the count of greater partitions\\n\\n    \\n\\n    return (greatPartition+mod) % mod;  // Return the result modulo \\'mod\\'\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int mod = 1e9 + 7;  // Modulus value for taking modulo of intermediate and final results\\n\\n// Function to find the total number of subsets in the array with sums smaller than \\'wt\\'\\nint allSubsetSum(vector<int>& nums, int n, int wt, vector<vector<int>>& cache) {\\n    if (wt == 0) return 0;  // If target sum \\'wt\\' is reached, return 0 (no subsets)\\n    if (n == 0) return 1;   // If there are no elements left, return 1 (empty subset)\\n/* \\n\\n\\nif (wt == 0) return 0;: This condition checks whether the target sum wt is reached. If it is, it means that a subset has been found whose sum equals wt. However, in the context of this problem, you\\'re looking for subsets with sums strictly smaller than wt. So, when wt becomes 0, you return 0 to signify that a subset with the desired property hasn\\'t been found.\\n\\nif (n == 0) return 1;: This condition checks whether there are no elements left to consider in the array. If n becomes 0, it means that you\\'ve considered all elements and have reached the end of the array. In the context of counting subsets, an empty set is also considered a valid subset, and it has a sum of 0. Therefore, you return 1 to signify that there\\'s at least one empty subset (with a sum of 0).*/\\n    if (cache[n][wt] != -1) return cache[n][wt];  // If already computed, return from cache\\n\\n    int taken = 0;\\n    int notTaken = allSubsetSum(nums, n - 1, wt, cache);  // Count subsets without including the current element\\n\\n    if (nums[n - 1] < wt) {\\n        taken = allSubsetSum(nums, n - 1, wt - nums[n - 1], cache);  // Count subsets including the current element\\n    }\\n\\n    // Store the result in cache and take modulo to prevent overflow\\n    return cache[n][wt] = (taken + notTaken) % mod;\\n}\\n\\nint countPartitions(vector<int>& nums, int k) {\\n    int n = nums.size();\\n\\n    int totalSum = 0;\\n    for (int value : nums)\\n        totalSum = (totalSum + value) % mod;\\n\\n    if (totalSum / 2 < k)\\n        return 0;  // If the sum of all elements divided by 2 is less than \\'k\\', return 0\\n\\n    vector<vector<int>> cache(n + 2, vector<int>(k + 2, -1));  // Initialize cache with -1\\n\\n    // Calculate the count of all subsets whose sum is less than \\'k\\'\\n    int invalidSubset = allSubsetSum(nums, n, k, cache);\\n\\n    int totalSubset = 1;  // Initialize total number of subsets\\n\\n    // Calculate the total number of subset pairs using the formula (2^n) % mod\\n    for (int i = 1; i <= n; i++) {\\n        totalSubset = (totalSubset * 2) % mod;\\n    }\\n\\n    int greatPartition = totalSubset - 2 * invalidSubset;  // Calculate the count of greater partitions\\n\\n    \\n\\n    return (greatPartition+mod) % mod;  // Return the result modulo \\'mod\\'\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944459,
                "title": "easy-memoization-o-n-k",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    long sum = 0;\\n    long mod;\\n\\n    // basic top down dp\\n    long solve(int[] nums, int ind, int k, long[][] dp){\\n        if(ind >= nums.length){\\n            return (k > 0) ? 1 : 0;\\n        }\\n        if(dp[ind][k] != -1){\\n            return dp[ind][k];\\n        }\\n        long take = solve(nums, ind+1, Math.max(0, k-nums[ind]), dp)%mod;\\n        long notake = solve(nums, ind+1, k, dp)%mod;\\n        return dp[ind][k] = (take + notake)%mod;\\n    }\\n\\n    // calculating power with mod\\n    long power(int n){\\n        long ans = 1;\\n        while(n-- > 0){\\n            ans = (ans*2)%mod;\\n        }\\n        return (ans%mod);\\n    }\\n\\n\\n    public int countPartitions(int[] nums, int k) {\\n        mod = (int) 1e9+7;\\n        int n = nums.length;\\n        for(int i : nums){\\n            sum += i;\\n        }\\n        if(sum < 2*k) return 0; // cant divide\\n        long[][] dp = new long[n+1][k+1];\\n        for(long[] i : dp){\\n            Arrays.fill(i, -1);\\n        }\\n        long a = power(n)%mod;\\n        // 2 is multiplied with the solve func because \\n        // solve func is giving us the number of sets which have \\n        // sum less than k, so when we have those sets , surely the \\n        // condition would not be met, but what about the set with remaining elements\\n        // when we take that set we know the other set would still be \\n        // less than k, hence there are 2 sets we find each time\\n        // which does not staisfy the condition\\n        long ans = (a - ((long)2*(solve(nums, 0, k, dp))%mod)%mod + mod)%mod;\\n        return (int) ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    long sum = 0;\\n    long mod;\\n\\n    // basic top down dp\\n    long solve(int[] nums, int ind, int k, long[][] dp){\\n        if(ind >= nums.length){\\n            return (k > 0) ? 1 : 0;\\n        }\\n        if(dp[ind][k] != -1){\\n            return dp[ind][k];\\n        }\\n        long take = solve(nums, ind+1, Math.max(0, k-nums[ind]), dp)%mod;\\n        long notake = solve(nums, ind+1, k, dp)%mod;\\n        return dp[ind][k] = (take + notake)%mod;\\n    }\\n\\n    // calculating power with mod\\n    long power(int n){\\n        long ans = 1;\\n        while(n-- > 0){\\n            ans = (ans*2)%mod;\\n        }\\n        return (ans%mod);\\n    }\\n\\n\\n    public int countPartitions(int[] nums, int k) {\\n        mod = (int) 1e9+7;\\n        int n = nums.length;\\n        for(int i : nums){\\n            sum += i;\\n        }\\n        if(sum < 2*k) return 0; // cant divide\\n        long[][] dp = new long[n+1][k+1];\\n        for(long[] i : dp){\\n            Arrays.fill(i, -1);\\n        }\\n        long a = power(n)%mod;\\n        // 2 is multiplied with the solve func because \\n        // solve func is giving us the number of sets which have \\n        // sum less than k, so when we have those sets , surely the \\n        // condition would not be met, but what about the set with remaining elements\\n        // when we take that set we know the other set would still be \\n        // less than k, hence there are 2 sets we find each time\\n        // which does not staisfy the condition\\n        long ans = (a - ((long)2*(solve(nums, 0, k, dp))%mod)%mod + mod)%mod;\\n        return (int) ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921502,
                "title": "explained-sum-wali-approach-2d-dp",
                "content": "O(N*K)\\n\\nthe idea was to use dp but with some twist of greedy \\njust look at the constraints\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long binpow(long long a,long long b){\\n        if(b==0){\\n            return 1;\\n        }\\n        long long x=binpow(a,b/2);\\n        if(b&1){\\n            return (a*((x*x)%mod))%mod;\\n        }\\n        else{\\n            return (x*x)%mod;\\n        }\\n    }\\n    int mod=1e9+7;\\n    int rec(int ind,int sum,vector<int> &nums,int k,int totsum,vector<vector<int>> &dp){\\n        if(sum>=k){\\n            return 0;\\n        }\\n        if(ind==nums.size()){\\n            return 1;\\n        }\\n        else if(dp[ind][sum]!=-1){\\n            return dp[ind][sum];\\n        }\\n        else{\\n            int p=0,np=0;\\n            p=rec(ind+1,sum+nums[ind],nums,k,totsum,dp)%mod;\\n            np=rec(ind+1,sum,nums,k,totsum,dp)%mod;\\n            return dp[ind][sum]=(p%mod+np%mod)%mod;\\n        }\\n    }\\n    int countPartitions(vector<int>& nums, int k) {\\n        long long s=0;\\n        for(auto it:nums){\\n            s+=it;\\n            s%=mod;\\n        }\\n        int n=nums.size();\\n        if(s<2*k){return 0;}\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        return ((binpow(2,n)-2*rec(0,0,nums,k,s,dp))+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long binpow(long long a,long long b){\\n        if(b==0){\\n            return 1;\\n        }\\n        long long x=binpow(a,b/2);\\n        if(b&1){\\n            return (a*((x*x)%mod))%mod;\\n        }\\n        else{\\n            return (x*x)%mod;\\n        }\\n    }\\n    int mod=1e9+7;\\n    int rec(int ind,int sum,vector<int> &nums,int k,int totsum,vector<vector<int>> &dp){\\n        if(sum>=k){\\n            return 0;\\n        }\\n        if(ind==nums.size()){\\n            return 1;\\n        }\\n        else if(dp[ind][sum]!=-1){\\n            return dp[ind][sum];\\n        }\\n        else{\\n            int p=0,np=0;\\n            p=rec(ind+1,sum+nums[ind],nums,k,totsum,dp)%mod;\\n            np=rec(ind+1,sum,nums,k,totsum,dp)%mod;\\n            return dp[ind][sum]=(p%mod+np%mod)%mod;\\n        }\\n    }\\n    int countPartitions(vector<int>& nums, int k) {\\n        long long s=0;\\n        for(auto it:nums){\\n            s+=it;\\n            s%=mod;\\n        }\\n        int n=nums.size();\\n        if(s<2*k){return 0;}\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        return ((binpow(2,n)-2*rec(0,0,nums,k,s,dp))+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916181,
                "title": "dp-solution-with-detail-explanation-c-java",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn first glance it looks similar to the Partition Equal Subset Sum , that approach may work for sum testcases specially the given example testcases but the main twist arrives when you have very large values , even if you modulo with 1e9 + 7 the value is still large , so you can\\u2019t have enough space to solve the problem in that way.\\n\\nSo solve the problem we need to go the basic fundamentals of problem which is either you can take an element or not. So you have 2 ways for a particular index now for n index array it will be 2^n.\\n\\nNow the question defines that each of the groups sum must me greater or equal k, so\\n\\nsumOfGrp1>=k && sumOfGrp2>=k\\u2026\\u2026\\u2026\\u2026\\u2026.(i)\\n\\nThe rest possible case out of 2^n is\\n\\nsumOfGrp1>=k && sumOfGrp2<k\\u2026\\u2026\\u2026\\u2026\\u2026.(ii)\\n\\nsumOfGrp1<k && sumOfGrp2>=k\\u2026\\u2026\\u2026\\u2026\\u2026.(iii)\\n\\nsumOfGrp1<k && sumOfGrp2<k\\u2026\\u2026\\u2026\\u2026\\u2026.(iv)\\n\\nNow we can eliminate this(iv) easily by checking if twice of k is greater than the total sum of the whole array if yes then no great partitions is possible.\\nSo,we can say\\n\\ni+ii+iii = 2^n\\n\\nNow if you look closely ii and iii are the alter case of each other like a array [1,2,3,5] suppose k = 6 then [{5,2},{1,3}] is (ii)  and [{1,3},{5,2}] (iii)\\n\\nNow we can say that\\ni+2*ii = 2^n\\ni= 2^n- 2*ii \\u2026\\u2026\\u2026.(v)\\nSo, to get our desire answer we just need the answer of the cases when one of group is less than k. This sub problem can solve in way less space(O(n*k)) and it\\u2019s very similar of Partition Equal Subset Sum\\nHere the base case:-\\nAfter considering the  very last element  if  the sum is less then k, it wiil be 1 and other case 0.\\nAnd one edge case need to be consider is that after applying the (v) line if the answer becomes neg you need to add with 1e9+7, because you are modulo it every time it might becomes neg value.\\n\\n# Complexity\\n- Time complexity: O(nk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(nk)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    long long int mod = 1e9+7;\\n    int sol (int i,vector<int>& nums, int k,vector<vector<long long int>>&dp){\\n        if(i==nums.size()){\\n            if(k>0)\\n                return 1;\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        long long int nontake = sol(i+1,nums,k,dp);\\n        long long int take = 0;\\n        if(k-nums[i]>0)\\n            take = sol(i+1,nums,k-nums[i],dp);\\n        return dp[i][k] = (take+nontake)%mod;\\n    }\\n    int countPartitions(vector<int>& nums, int k) {\\n        long long int mod = 1e9 + 7;\\n        long long int total = 0;\\n        for(long long int i:nums)\\n            total= (total + i);\\n        if(2*k>total)\\n            return 0;\\n        long long int n = nums.size();\\n        vector<vector<long long int>>dp(n,vector<long long int>(k+1,-1));\\n        long long int wrong = sol(0,nums,k,dp);\\n        long long int all = 1;\\n        for(int i=1;i<=n;i++)\\n            all = (all*2)%mod;\\n        long long int ans =  all - (2*wrong);\\n\\n        if(ans<0)\\n            ans+=mod;\\n        \\n        return ans%mod;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    static int mod = (int) 1e9 + 7;\\n    long solve (int i, int[] nums, int k, Long[][] dp){\\n        if(i==nums.length){\\n            if(k>0)\\n                return 1;\\n            return 0;\\n        }\\n        if(dp[i][k]!=null)\\n            return dp[i][k];\\n        long nontake = solve(i+1,nums,k,dp);\\n        long take = 0;\\n        if(k-nums[i]>0)\\n            take = solve(i+1,nums,k-nums[i],dp);\\n        return dp[i][k] = (nontake+take)%mod;\\n    }\\n    public int countPartitions(int[] nums, int k) {\\n        long total = 0;\\n        int n = nums.length;\\n        for(int i=0;i<n;i++){\\n            total+=nums[i];\\n        }\\n        if(2*k>total)\\n            return 0;\\n        Long[][] dp = new Long[n][k+1];\\n        \\n        long wrong = solve(0,nums,k,dp);\\n        \\n        long cnt = 1;\\n\\n        for(int i=1;i<=n;i++){\\n            cnt = (cnt*2)%mod;\\n        }\\n\\n        long ans = cnt - (2*wrong);\\n\\n        if(ans<0)\\n            ans+=mod;\\n\\n        return  (int) (ans%mod);\\n\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    long long int mod = 1e9+7;\\n    int sol (int i,vector<int>& nums, int k,vector<vector<long long int>>&dp){\\n        if(i==nums.size()){\\n            if(k>0)\\n                return 1;\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        long long int nontake = sol(i+1,nums,k,dp);\\n        long long int take = 0;\\n        if(k-nums[i]>0)\\n            take = sol(i+1,nums,k-nums[i],dp);\\n        return dp[i][k] = (take+nontake)%mod;\\n    }\\n    int countPartitions(vector<int>& nums, int k) {\\n        long long int mod = 1e9 + 7;\\n        long long int total = 0;\\n        for(long long int i:nums)\\n            total= (total + i);\\n        if(2*k>total)\\n            return 0;\\n        long long int n = nums.size();\\n        vector<vector<long long int>>dp(n,vector<long long int>(k+1,-1));\\n        long long int wrong = sol(0,nums,k,dp);\\n        long long int all = 1;\\n        for(int i=1;i<=n;i++)\\n            all = (all*2)%mod;\\n        long long int ans =  all - (2*wrong);\\n\\n        if(ans<0)\\n            ans+=mod;\\n        \\n        return ans%mod;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    static int mod = (int) 1e9 + 7;\\n    long solve (int i, int[] nums, int k, Long[][] dp){\\n        if(i==nums.length){\\n            if(k>0)\\n                return 1;\\n            return 0;\\n        }\\n        if(dp[i][k]!=null)\\n            return dp[i][k];\\n        long nontake = solve(i+1,nums,k,dp);\\n        long take = 0;\\n        if(k-nums[i]>0)\\n            take = solve(i+1,nums,k-nums[i],dp);\\n        return dp[i][k] = (nontake+take)%mod;\\n    }\\n    public int countPartitions(int[] nums, int k) {\\n        long total = 0;\\n        int n = nums.length;\\n        for(int i=0;i<n;i++){\\n            total+=nums[i];\\n        }\\n        if(2*k>total)\\n            return 0;\\n        Long[][] dp = new Long[n][k+1];\\n        \\n        long wrong = solve(0,nums,k,dp);\\n        \\n        long cnt = 1;\\n\\n        for(int i=1;i<=n;i++){\\n            cnt = (cnt*2)%mod;\\n        }\\n\\n        long ans = cnt - (2*wrong);\\n\\n        if(ans<0)\\n            ans+=mod;\\n\\n        return  (int) (ans%mod);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877338,
                "title": "o-n-k-solution-dp-recursion-solution-cpp-easy-soltuion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = (int)1e9 + 7;\\n\\n    int solve(int index, int currentSum, int totalSum, int targetSum, int n, vector<int>& nums, vector<vector<int>>& memo) {\\n        if (currentSum >= targetSum) {\\n            return memo[index][targetSum] = 0;\\n        }\\n\\n        if (index >= n) {\\n            if (currentSum < targetSum && currentSum != 0) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n\\n        if (memo[index][currentSum] != -1) {\\n            return memo[index][currentSum];\\n        }\\n\\n        int exclude = solve(index + 1, currentSum, totalSum, targetSum, n, nums, memo);\\n        int include = solve(index + 1, currentSum + nums[index], totalSum, targetSum, n, nums, memo);\\n\\n        memo[index][currentSum] = (include + exclude) % mod;\\n        return memo[index][currentSum];\\n    }\\n\\n    int countPartitions(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long totalSum = 0;\\n\\n        for (int num : nums) {\\n            totalSum = (totalSum + num);\\n        }\\n\\n        if (totalSum < 2 * k) {\\n            return 0;\\n        }\\n\\n        vector<vector<int>> memo(n + 1, vector<int>(k + 1, -1));\\n\\n        int res = solve(0, 0, totalSum, k, n, nums, memo);\\n\\n        long long totalways = 2;\\n\\n        for (int i = 1; i < n; i++) {\\n            totalways = (2 * totalways) % mod;\\n        }\\n\\n        totalways -= 2;\\n\\n        int ans = ((totalways % mod) - ((res * 2) % mod));\\n        ans = (ans % mod + mod) % mod;\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = (int)1e9 + 7;\\n\\n    int solve(int index, int currentSum, int totalSum, int targetSum, int n, vector<int>& nums, vector<vector<int>>& memo) {\\n        if (currentSum >= targetSum) {\\n            return memo[index][targetSum] = 0;\\n        }\\n\\n        if (index >= n) {\\n            if (currentSum < targetSum && currentSum != 0) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n\\n        if (memo[index][currentSum] != -1) {\\n            return memo[index][currentSum];\\n        }\\n\\n        int exclude = solve(index + 1, currentSum, totalSum, targetSum, n, nums, memo);\\n        int include = solve(index + 1, currentSum + nums[index], totalSum, targetSum, n, nums, memo);\\n\\n        memo[index][currentSum] = (include + exclude) % mod;\\n        return memo[index][currentSum];\\n    }\\n\\n    int countPartitions(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long totalSum = 0;\\n\\n        for (int num : nums) {\\n            totalSum = (totalSum + num);\\n        }\\n\\n        if (totalSum < 2 * k) {\\n            return 0;\\n        }\\n\\n        vector<vector<int>> memo(n + 1, vector<int>(k + 1, -1));\\n\\n        int res = solve(0, 0, totalSum, k, n, nums, memo);\\n\\n        long long totalways = 2;\\n\\n        for (int i = 1; i < n; i++) {\\n            totalways = (2 * totalways) % mod;\\n        }\\n\\n        totalways -= 2;\\n\\n        int ans = ((totalways % mod) - ((res * 2) % mod));\\n        ans = (ans % mod + mod) % mod;\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664863,
                "title": "using-tabulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long sum = 0;\\n        for(int i = 0;i<n;i++)sum = sum + nums[i];\\n        if(sum<2*k)return 0;\\n\\n        vector<unordered_map<long long,long long>>dp(n);\\n        for(int s = 0;s<n;s++)dp[s][0] = 1;\\n        dp[0][nums[0]] = 1;\\n\\n        for(int i = 1;i<n;i++){\\n            for(int s = 1;s<k;s++){\\n                int notake = (dp[i-1][s]);\\n                int take = 0;\\n                if(nums[i]<=s)take = (dp[i-1][s-nums[i]]);\\n                dp[i][s] = (take + notake)%1000000007;\\n            }\\n        }\\n        long long un = 0;\\n        for(int i = 0;i<k;i++){\\n            un = (un + 2*dp[n-1][i])%1000000007;\\n            un = un%1000000007;\\n        }\\n        cout<<un;\\n        long long total =1;\\n        for(int i = 0;i<n;i++){\\n            total = (total*2)%1000000007;\\n            total = total%1000000007;\\n        }\\n        cout<<\" \"<<total;\\n        long long ans = (total - (un))%1000000007;\\n        if(ans<0) ans+=1000000007;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long sum = 0;\\n        for(int i = 0;i<n;i++)sum = sum + nums[i];\\n        if(sum<2*k)return 0;\\n\\n        vector<unordered_map<long long,long long>>dp(n);\\n        for(int s = 0;s<n;s++)dp[s][0] = 1;\\n        dp[0][nums[0]] = 1;\\n\\n        for(int i = 1;i<n;i++){\\n            for(int s = 1;s<k;s++){\\n                int notake = (dp[i-1][s]);\\n                int take = 0;\\n                if(nums[i]<=s)take = (dp[i-1][s-nums[i]]);\\n                dp[i][s] = (take + notake)%1000000007;\\n            }\\n        }\\n        long long un = 0;\\n        for(int i = 0;i<k;i++){\\n            un = (un + 2*dp[n-1][i])%1000000007;\\n            un = un%1000000007;\\n        }\\n        cout<<un;\\n        long long total =1;\\n        for(int i = 0;i<n;i++){\\n            total = (total*2)%1000000007;\\n            total = total%1000000007;\\n        }\\n        cout<<\" \"<<total;\\n        long long ans = (total - (un))%1000000007;\\n        if(ans<0) ans+=1000000007;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3661260,
                "title": "cpp-knapsack-problem-simple-easy-to-understand-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = (int)(1e9+7);\\n    \\n    int solve(int i,int t,long long &tot,vector<int>&nums,int &k,vector<vector<int>> &dp){\\n        if(i<0){\\n            if(t<k or tot-t<k) return 1;\\n            return 0;\\n        }\\n        if(dp[i][t]!=-1) return dp[i][t]%mod;\\n        \\n        int tk = t+nums[i]<=k?solve(i-1,t+nums[i],tot,nums,k,dp)%mod:0;\\n        int nottk = solve(i-1,t,tot,nums,k,dp)%mod;\\n        \\n        return dp[i][t]=(tk+nottk)%mod;\\n    }\\n    int countPartitions(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long tot = 0;\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        \\n        for(auto it:nums) tot+=it;\\n        if(tot<2*k) return 0;\\n        \\n        int notValid = (2*solve(n-1,0,tot,nums,k,dp))%mod;\\n        int totSub=1;\\n        for(int i=0;i<n;i++)\\n            totSub = (totSub*2)%mod;\\n        \\n        int greatPar = (totSub-notValid)%mod;\\n        if(greatPar<0) greatPar+=mod;\\n        return greatPar;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = (int)(1e9+7);\\n    \\n    int solve(int i,int t,long long &tot,vector<int>&nums,int &k,vector<vector<int>> &dp){\\n        if(i<0){\\n            if(t<k or tot-t<k) return 1;\\n            return 0;\\n        }\\n        if(dp[i][t]!=-1) return dp[i][t]%mod;\\n        \\n        int tk = t+nums[i]<=k?solve(i-1,t+nums[i],tot,nums,k,dp)%mod:0;\\n        int nottk = solve(i-1,t,tot,nums,k,dp)%mod;\\n        \\n        return dp[i][t]=(tk+nottk)%mod;\\n    }\\n    int countPartitions(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long tot = 0;\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        \\n        for(auto it:nums) tot+=it;\\n        if(tot<2*k) return 0;\\n        \\n        int notValid = (2*solve(n-1,0,tot,nums,k,dp))%mod;\\n        int totSub=1;\\n        for(int i=0;i<n;i++)\\n            totSub = (totSub*2)%mod;\\n        \\n        int greatPar = (totSub-notValid)%mod;\\n        if(greatPar<0) greatPar+=mod;\\n        return greatPar;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548125,
                "title": "memoization-in-python-fewer-than-10-lines",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI am lazy so I implement the solution in memoization instead of bottom-up dynamic programming. In this simple 3-D dynamic programming, every state is defined by `(i, s1, s2)`, where i is the current number `nums[i]` to consider, `s1` and `s2` are the current sums of the first and the second arrays. The keys to getting accepted: \\n\\n* `s1` and `s2` are bounded by `k` as `k` can be much smaller than the sums can be made. \\n* Traversing the numbers in the descending order. This reduces the search space greatly. \\n\\n# Code\\n```\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        nums.sort(reverse=True)\\n        \\n        @cache\\n        def dp(i, s1, s2):\\n            if i >= n:\\n                return 1 if s1 >= k and s2 >= k else 0\\n            return (dp(i+1, min(k, s1+nums[i]), s2) + dp(i+1, s1, min(k, s2+nums[i]))) % 1000000007\\n            \\n        return dp(0, 0, 0)        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        nums.sort(reverse=True)\\n        \\n        @cache\\n        def dp(i, s1, s2):\\n            if i >= n:\\n                return 1 if s1 >= k and s2 >= k else 0\\n            return (dp(i+1, min(k, s1+nums[i]), s2) + dp(i+1, s1, min(k, s2+nums[i]))) % 1000000007\\n            \\n        return dp(0, 0, 0)        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374162,
                "title": "o-n-k-solution-in-rust",
                "content": "# Intuition\\n\\nTODO\\n\\n# Approach\\n\\nDP\\n\\n# Complexity\\n- Time complexity:\\n    $$\\n    O(n*k)\\n    $$\\n- Space complexity:\\n    $$\\n    O(n*k)\\n    $$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn count_partitions(nums: Vec<i32>, k: i32) -> i32 {\\n        let m = 1000000007_u32;\\n        let n = nums.len();\\n        let k = k as usize;\\n        if nums.iter().map(|&v| v as usize).sum::<usize>() < k * 2 {\\n            0\\n        } else {\\n            let mut dp = vec![vec![0_u32; k]; n];\\n            for i in 0..k {\\n                dp[0][i] = 1 + u32::from((nums[0] as usize) <= i);\\n            }\\n            for i in 1..n {\\n                for j in 0..k {\\n                    if j >= nums[i] as usize {\\n                        dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - nums[i] as usize]) % m;\\n                    } else {\\n                        dp[i][j] = dp[i - 1][j];\\n                    }\\n                }\\n            }\\n            (((0..n).fold(1, |y, _| y * 2 % m) + m * 2 - dp[n - 1][k - 1] * 2) % m) as i32\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_partitions(nums: Vec<i32>, k: i32) -> i32 {\\n        let m = 1000000007_u32;\\n        let n = nums.len();\\n        let k = k as usize;\\n        if nums.iter().map(|&v| v as usize).sum::<usize>() < k * 2 {\\n            0\\n        } else {\\n            let mut dp = vec![vec![0_u32; k]; n];\\n            for i in 0..k {\\n                dp[0][i] = 1 + u32::from((nums[0] as usize) <= i);\\n            }\\n            for i in 1..n {\\n                for j in 0..k {\\n                    if j >= nums[i] as usize {\\n                        dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - nums[i] as usize]) % m;\\n                    } else {\\n                        dp[i][j] = dp[i - 1][j];\\n                    }\\n                }\\n            }\\n            (((0..n).fold(1, |y, _| y * 2 % m) + m * 2 - dp[n - 1][k - 1] * 2) % m) as i32\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3373844,
                "title": "c",
                "content": "```\\nusing LL = long long ;\\nclass Solution {\\n    LL M = 1e9 + 7 ;\\n    LL myPow(LL a, int b){\\n        if(b == 0)\\n            return 1 ;\\n        if(b % 2)\\n            return a * myPow(a, b-1) % M ;\\n        else\\n            return myPow(a*a % M, b/2) % M;\\n    }\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        int n = nums.size() ;\\n        LL SUM = accumulate(nums.begin(), nums.end(), 0LL) ;\\n        if(SUM < 2*k)\\n            return 0 ;\\n        auto dp = vector<vector<LL>>(n+1, vector<LL>(k+1)) ; //dp[i][s] , 0-(i-1), combination sum = s\\n        dp[0][0] = 1 ;\\n        LL total = 1 ;\\n        total = myPow(2, n) ;\\n\\n        for(int i = 0; i < n; i++){\\n             for(int s = 0; s < k; s++){\\n                 dp[i+1][s] = dp[i][s] ;\\n                 if(s - nums[i] >= 0)\\n                     dp[i+1][s] = (dp[i+1][s] + dp[i][s-nums[i]]) % M ;\\n             }\\n        }\\n        LL sumLessK = 0 ;\\n        for(int i = 0; i < k ; i++)\\n            sumLessK  = (sumLessK + dp[n][i]) % M ;\\n        \\n        sumLessK = (sumLessK * 2) % M ;\\n        \\n        return (total - sumLessK + M) % M ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nusing LL = long long ;\\nclass Solution {\\n    LL M = 1e9 + 7 ;\\n    LL myPow(LL a, int b){\\n        if(b == 0)\\n            return 1 ;\\n        if(b % 2)\\n            return a * myPow(a, b-1) % M ;\\n        else\\n            return myPow(a*a % M, b/2) % M;\\n    }\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        int n = nums.size() ;\\n        LL SUM = accumulate(nums.begin(), nums.end(), 0LL) ;\\n        if(SUM < 2*k)\\n            return 0 ;\\n        auto dp = vector<vector<LL>>(n+1, vector<LL>(k+1)) ; //dp[i][s] , 0-(i-1), combination sum = s\\n        dp[0][0] = 1 ;\\n        LL total = 1 ;\\n        total = myPow(2, n) ;\\n\\n        for(int i = 0; i < n; i++){\\n             for(int s = 0; s < k; s++){\\n                 dp[i+1][s] = dp[i][s] ;\\n                 if(s - nums[i] >= 0)\\n                     dp[i+1][s] = (dp[i+1][s] + dp[i][s-nums[i]]) % M ;\\n             }\\n        }\\n        LL sumLessK = 0 ;\\n        for(int i = 0; i < k ; i++)\\n            sumLessK  = (sumLessK + dp[n][i]) % M ;\\n        \\n        sumLessK = (sumLessK * 2) % M ;\\n        \\n        return (total - sumLessK + M) % M ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371693,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const long long mod = 1e9 + 7;\\n    long long dp[1001][2][1001];\\n    int countPartitions(vector<int>& nums, int k) {\\n        memset(dp, -1, sizeof(dp));\\n        return recur(nums, 0, k, k);\\n    }\\n\\n    long long mpow(long long a, long long b){\\n        if (b == 0) return 1;\\n        long long x = mpow(a, b / 2);\\n        x = (x * x) % mod;\\n        if (b % 2)  x = (x * a) % mod;\\n        return (x+mod)%mod;\\n    }\\n\\n\\n    long long recur(vector<int>& nums, int i, long long k1, long long k2) {\\n        if (i == nums.size()) \\n            return k1 <= 0 && k2 <= 0;\\n        if (k1 <= 0 && k2 <= 0) \\n            return mpow(2, nums.size() - i);\\n        if (dp[i][k1 >= 0][max(k1, k2)] != -1) \\n            return dp[i][k1 >= 0][max(k1, k2)];\\n        long long a = recur(nums, i + 1, k1 - nums[i], k2) ;\\n        long long b = recur(nums, i + 1, k1, k2 - nums[i]) ;\\n        return dp[i][k1 >= 0][max(k1, k2)] = (a + b) % mod;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    const long long mod = 1e9 + 7;\\n    long long dp[1001][2][1001];\\n    int countPartitions(vector<int>& nums, int k) {\\n        memset(dp, -1, sizeof(dp));\\n        return recur(nums, 0, k, k);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3341146,
                "title": "easy-to-understand-c-code-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[1001][1001];\\n    long long min(long long a,long long b){\\n        if(a<b)return a;\\n        return b;\\n    }\\n    int countPartitions(vector<int>& nums, int k) {\\n        vector<int>a,b;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums,k,0,0,0);\\n    }\\n    \\n    int solve(int st,vector<int>&nums,int &k,long long sm1,long long sm2,long long mnsm){\\n        if(st>=nums.size()){\\n            if(sm1>=k && sm2>=k)return 1;\\n            return 0;\\n        }\\n        if(dp[st][mnsm]!=-1)return dp[st][mnsm];\\n        \\n        long long a1=solve(st+1,nums,k,sm1+nums[st],sm2,min(1000,min(sm1+nums[st],sm2)));\\n        long long a2=solve(st+1,nums,k,sm1,sm2+nums[st],min(1000,min(sm1,sm2+nums[st])));\\n        \\n        return dp[st][mnsm]=(a1+a2)%(1000000007);\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[1001][1001];\\n    long long min(long long a,long long b){\\n        if(a<b)return a;\\n        return b;\\n    }\\n    int countPartitions(vector<int>& nums, int k) {\\n        vector<int>a,b;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums,k,0,0,0);\\n    }\\n    \\n    int solve(int st,vector<int>&nums,int &k,long long sm1,long long sm2,long long mnsm){\\n        if(st>=nums.size()){\\n            if(sm1>=k && sm2>=k)return 1;\\n            return 0;\\n        }\\n        if(dp[st][mnsm]!=-1)return dp[st][mnsm];\\n        \\n        long long a1=solve(st+1,nums,k,sm1+nums[st],sm2,min(1000,min(sm1+nums[st],sm2)));\\n        long long a2=solve(st+1,nums,k,sm1,sm2+nums[st],min(1000,min(sm1,sm2+nums[st])));\\n        \\n        return dp[st][mnsm]=(a1+a2)%(1000000007);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305557,
                "title": "c-concise-dp",
                "content": "# Intuition\\ncount the number patition with sum < k\\nthen result = number of all patition (2^n) - num of partition with sum<k\\nalso if  if the sum of partition * 2 >= total, it need to be counted twice.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        long long mod = 1e9+7, sum = accumulate(nums.begin(), nums.end(), 0LL);\\n        vector<long long> pre(k), cur(k);\\n        pre[0] = cur[0] = 1;\\n        for(auto x:nums){\\n            for(int i=0;i<k;i++)\\n                if(x+i<k) cur[x+i] = (cur[x+i] + pre[i]) % mod;\\n            pre = cur;\\n        }\\n        long long res = 1;\\n        for(int i=0;i<nums.size();i++) res = res*2 % mod;\\n        for(int i=0;i<k;i++) res -= pre[i] * (sum - i < k ? 1 : 2); \\n        return (res + k*mod)% mod;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        long long mod = 1e9+7, sum = accumulate(nums.begin(), nums.end(), 0LL);\\n        vector<long long> pre(k), cur(k);\\n        pre[0] = cur[0] = 1;\\n        for(auto x:nums){\\n            for(int i=0;i<k;i++)\\n                if(x+i<k) cur[x+i] = (cur[x+i] + pre[i]) % mod;\\n            pre = cur;\\n        }\\n        long long res = 1;\\n        for(int i=0;i<nums.size();i++) res = res*2 % mod;\\n        for(int i=0;i<k;i++) res -= pre[i] * (sum - i < k ? 1 : 2); \\n        return (res + k*mod)% mod;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100194,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n//from tyagsa\\n#define ll long long\\n#define mod 1000000007\\nll mpow(ll a, ll b, ll m)\\n{\\n\\tif (b == 0)\\n\\t\\treturn 1;\\n\\tll x = mpow(a, b / 2, m);\\n\\tx = (x * x) % m;\\n\\tif (b % 2)\\n\\t{\\n\\t\\tx = (x * a) % m;\\n\\t}\\n\\treturn x;\\n}\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        ll totSum =0;\\n        int n = nums.size();\\n        for(auto node : nums) totSum += node;\\n        if((2*k)>totSum) return 0;\\n        sort(nums.begin(),nums.end());\\n        \\n        if(n == 1) return 0;\\n        \\n        vector<vector<ll>> dp(n,vector<ll>(k,0));\\n        \\n        for(int i =0 ;i<n ; i+=1){\\n            for(int j =0; j < k; j+=1){\\n                if(!i && !j){\\n                    dp[i][j] = 1;\\n                    continue;\\n                }\\n                if(i == 0){\\n                    if(j==nums[i]) dp[i][j] = 1;\\n                    continue;\\n                }\\n                if(nums[i]>j) dp[i][j] = dp[i-1][j];\\n                else{\\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]];\\n                    dp[i][j] %= mod;\\n                }\\n            }\\n        }\\n        \\n        ll ways= 0;\\n        for(int i = 1; i< k ; i+=1){\\n            ways += dp[n-1][i];\\n        }\\n        ways %= mod;\\n        ll totWaysOfDividing = mpow(2,n,mod);\\n        totWaysOfDividing -= 2;\\n        totWaysOfDividing -= 2*ways;\\n        totWaysOfDividing = (totWaysOfDividing%mod + mod)%mod;\\n        return totWaysOfDividing;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//from tyagsa\\n#define ll long long\\n#define mod 1000000007\\nll mpow(ll a, ll b, ll m)\\n{\\n\\tif (b == 0)\\n\\t\\treturn 1;\\n\\tll x = mpow(a, b / 2, m);\\n\\tx = (x * x) % m;\\n\\tif (b % 2)\\n\\t{\\n\\t\\tx = (x * a) % m;\\n\\t}\\n\\treturn x;\\n}\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        ll totSum =0;\\n        int n = nums.size();\\n        for(auto node : nums) totSum += node;\\n        if((2*k)>totSum) return 0;\\n        sort(nums.begin(),nums.end());\\n        \\n        if(n == 1) return 0;\\n        \\n        vector<vector<ll>> dp(n,vector<ll>(k,0));\\n        \\n        for(int i =0 ;i<n ; i+=1){\\n            for(int j =0; j < k; j+=1){\\n                if(!i && !j){\\n                    dp[i][j] = 1;\\n                    continue;\\n                }\\n                if(i == 0){\\n                    if(j==nums[i]) dp[i][j] = 1;\\n                    continue;\\n                }\\n                if(nums[i]>j) dp[i][j] = dp[i-1][j];\\n                else{\\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]];\\n                    dp[i][j] %= mod;\\n                }\\n            }\\n        }\\n        \\n        ll ways= 0;\\n        for(int i = 1; i< k ; i+=1){\\n            ways += dp[n-1][i];\\n        }\\n        ways %= mod;\\n        ll totWaysOfDividing = mpow(2,n,mod);\\n        totWaysOfDividing -= 2;\\n        totWaysOfDividing -= 2*ways;\\n        totWaysOfDividing = (totWaysOfDividing%mod + mod)%mod;\\n        return totWaysOfDividing;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056908,
                "title": "c-math",
                "content": "# Intuition\\n1. If the sum of the array is smaller than 2*k, then it is impossible to find a great partition.\\n2. Solve the reverse problem, that is, find the number of partitions where the sum of elements of at least one of the two groups is smaller than k.\\ndp[i][x]: the total number of combinations has sum equals to x with the largest element has position $j$ in the sorted array before current position $i$ ($j <= i$).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*k)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int MOD = (int)(1E9 + 7);\\n\\n    int powMod(int len) {\\n        int base = 1;\\n        for (int i = 0; i < len; ++i) {\\n            base = base * 1ll * 2 % MOD;\\n        }\\n        return base;\\n    }\\n\\n    int countPartitions(vector<int>& nums, int k) {\\n        long long _sum = 0;\\n        for (int num : nums) {\\n            _sum += num;\\n        }\\n        if (_sum < 2 * k) {\\n            return 0;\\n        }\\n        int len = nums.size();\\n        vector<int> dp(k);\\n        dp[0] = 1;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < len; ++i) {\\n            vector<int> tmp = dp;\\n            for (int j = 0; j < k; ++j) {\\n                if (j - nums[i] >= 0) {\\n                    dp[j] = (dp[j] * 1ll + tmp[j - nums[i]]) % MOD;\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for (int j = 1; j < k; ++j) {\\n            sum = (sum * 1ll + dp[j]) % MOD;\\n        }\\n        \\n        int ori = (powMod(len) * 1ll - 2 + MOD) % MOD;\\n        return (ori * 1ll - sum * 2 + MOD) % MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int MOD = (int)(1E9 + 7);\\n\\n    int powMod(int len) {\\n        int base = 1;\\n        for (int i = 0; i < len; ++i) {\\n            base = base * 1ll * 2 % MOD;\\n        }\\n        return base;\\n    }\\n\\n    int countPartitions(vector<int>& nums, int k) {\\n        long long _sum = 0;\\n        for (int num : nums) {\\n            _sum += num;\\n        }\\n        if (_sum < 2 * k) {\\n            return 0;\\n        }\\n        int len = nums.size();\\n        vector<int> dp(k);\\n        dp[0] = 1;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < len; ++i) {\\n            vector<int> tmp = dp;\\n            for (int j = 0; j < k; ++j) {\\n                if (j - nums[i] >= 0) {\\n                    dp[j] = (dp[j] * 1ll + tmp[j - nums[i]]) % MOD;\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for (int j = 1; j < k; ++j) {\\n            sum = (sum * 1ll + dp[j]) % MOD;\\n        }\\n        \\n        int ori = (powMod(len) * 1ll - 2 + MOD) % MOD;\\n        return (ori * 1ll - sum * 2 + MOD) % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047046,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPartitions(self, nums, k):\\n        n, mod = len(nums), 10**9+7\\n\\n        @lru_cache(None)\\n        def dfs(i,total):\\n            if i == n:\\n                if total < k:\\n                    return 1\\n                else:\\n                    return 0\\n\\n            count = 0\\n\\n            if total + nums[i] < k:\\n                count += dfs(i+1,total+nums[i])\\n                \\n            count += dfs(i+1,total)\\n\\n            return count%mod\\n\\n        return max(0,(pow(2,n) - 2*dfs(0,0)))%mod\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPartitions(self, nums, k):\\n        n, mod = len(nums), 10**9+7\\n\\n        @lru_cache(None)\\n        def dfs(i,total):\\n            if i == n:\\n                if total < k:\\n                    return 1\\n                else:\\n                    return 0\\n\\n            count = 0\\n\\n            if total + nums[i] < k:\\n                count += dfs(i+1,total+nums[i])\\n                \\n            count += dfs(i+1,total)\\n\\n            return count%mod\\n\\n        return max(0,(pow(2,n) - 2*dfs(0,0)))%mod\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036501,
                "title": "racket-dp",
                "content": "# Complexity\\n- Time complexity:\\n$$O(k \\\\cdot n)$$\\n- Space complexity:\\n$$O(k)$$\\n\\n# Code\\n```\\n(define M-O-D 1000000007)\\n(define (mod+ x y) (remainder (+ x y) M-O-D))\\n(define (parts nums k)\\n  (define vals (make-vector k 0))\\n  (vector-set! vals 0 1)\\n  (define (val i) (vector*-ref vals i))\\n  (for* ((num nums) (x (in-range (- k num 1) -1 -1)))\\n    (vector-set! vals (+ x num) (mod+ (val x) (val (+ x num)))))\\n  (define too-small (mod+ 0 (for/sum ((v vals)) v)))\\n  (define all (foldl (lambda (_ x) (mod+ x x)) 1 nums))\\n  (mod+ all (- M-O-D (mod+ too-small  too-small))))\\n\\n(define/contract (count-partitions nums k)\\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\\n  (if (> (* 2 k) (apply + nums)) 0 (parts nums k)))\\n```",
                "solutionTags": [
                    "Racket",
                    "Array",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\n(define M-O-D 1000000007)\\n(define (mod+ x y) (remainder (+ x y) M-O-D))\\n(define (parts nums k)\\n  (define vals (make-vector k 0))\\n  (vector-set! vals 0 1)\\n  (define (val i) (vector*-ref vals i))\\n  (for* ((num nums) (x (in-range (- k num 1) -1 -1)))\\n    (vector-set! vals (+ x num) (mod+ (val x) (val (+ x num)))))\\n  (define too-small (mod+ 0 (for/sum ((v vals)) v)))\\n  (define all (foldl (lambda (_ x) (mod+ x x)) 1 nums))\\n  (mod+ all (- M-O-D (mod+ too-small  too-small))))\\n\\n(define/contract (count-partitions nums k)\\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\\n  (if (> (* 2 k) (apply + nums)) 0 (parts nums k)))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3007835,
                "title": "python3-count-the-non-great-partitions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs k is small(<=1000), we count the non-great partitions, which means to store all subsequence count no more than target. Counting the great partitions will get TLE. All partitions is *2 * (2 * (n - 1) - 1)*.\\n\\n# Code\\n```\\nfrom math import factorial\\n\\nclass Solution:\\n    def countPartitions(self, nums: List[int], target: int) -> int:\\n        s = sum(nums)\\n        if s < 2 * target: return 0\\n        cur = dict()\\n        for v in sorted(nums):\\n            if v >= target: break\\n            nxt = {v : 1}\\n            for k, t in cur.items():\\n                nxt[k] = nxt.get(k, 0) + t\\n                if k + v < target: nxt[k + v] = nxt.get(k + v, 0) + t\\n            cur = nxt\\n        return 2 * (2 ** (len(nums) - 1) - 1 - sum(v for v in cur.values())) % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import factorial\\n\\nclass Solution:\\n    def countPartitions(self, nums: List[int], target: int) -> int:\\n        s = sum(nums)\\n        if s < 2 * target: return 0\\n        cur = dict()\\n        for v in sorted(nums):\\n            if v >= target: break\\n            nxt = {v : 1}\\n            for k, t in cur.items():\\n                nxt[k] = nxt.get(k, 0) + t\\n                if k + v < target: nxt[k + v] = nxt.get(k + v, 0) + t\\n            cur = nxt\\n        return 2 * (2 ** (len(nums) - 1) - 1 - sum(v for v in cur.values())) % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002183,
                "title": "optimal-iterative-c-o-n-k-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {    \\n        long mod = 1e9+7;\\n        long result = 1;\\n        // dp will all pairs sum less than k i.e 0 to k-1\\n        vector<long> dp(k,0);\\n        long total = 0;\\n        dp[0] = 1;\\n        int lessThanK = k-1;\\n        for (auto &n : nums) {\\n            // generate pairs for all sum from 0 to k-1\\n            for (int i = lessThanK-n; i >= 0; i--) {\\n                dp[i+n] = (dp[i+n] + dp[i])%mod;\\n            }\\n            result = result*2 % mod; // collecting all power sets i.e 2^n\\n            total += n;\\n        }\\n        \\n        if (total < 2*k)\\n            return 0;\\n        \\n        // Collect all sets whose sum is less than K\\n        long totalSetsLessThanK = 0;\\n        for (int i = 0; i <= lessThanK; ++i) {\\n            totalSetsLessThanK = (totalSetsLessThanK + dp[i]) % mod;\\n        }\\n        // a set less than k will be part of partition 1 or partition 2, hence we \\n        // multiply by 2 for the same and remove it from power sets\\n        result = (result+mod - (2*totalSetsLessThanK)%mod) % mod;\\n        return (result%mod +mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {    \\n        long mod = 1e9+7;\\n        long result = 1;\\n        // dp will all pairs sum less than k i.e 0 to k-1\\n        vector<long> dp(k,0);\\n        long total = 0;\\n        dp[0] = 1;\\n        int lessThanK = k-1;\\n        for (auto &n : nums) {\\n            // generate pairs for all sum from 0 to k-1\\n            for (int i = lessThanK-n; i >= 0; i--) {\\n                dp[i+n] = (dp[i+n] + dp[i])%mod;\\n            }\\n            result = result*2 % mod; // collecting all power sets i.e 2^n\\n            total += n;\\n        }\\n        \\n        if (total < 2*k)\\n            return 0;\\n        \\n        // Collect all sets whose sum is less than K\\n        long totalSetsLessThanK = 0;\\n        for (int i = 0; i <= lessThanK; ++i) {\\n            totalSetsLessThanK = (totalSetsLessThanK + dp[i]) % mod;\\n        }\\n        // a set less than k will be part of partition 1 or partition 2, hence we \\n        // multiply by 2 for the same and remove it from power sets\\n        result = (result+mod - (2*totalSetsLessThanK)%mod) % mod;\\n        return (result%mod +mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000553,
                "title": "dart-recursion-memo-mod-handling-well-commented-solution",
                "content": "# Intuition\\nKnapsack + Mod Handling\\n\\n# Approach\\nDP\\n\\n# Complexity\\n- Time complexity:\\nO(N*K) + O(N+K) Stack Space\\n\\n- Space complexity:\\nO(N*K)\\n\\n# Code\\n```\\nclass Solution {\\n  int countPartitions(List<int> nums, int k) {\\n    int n = nums.length;\\n    int mod = 1e9.toInt() + 7;\\n\\n    // If the total sum is less than 2k, it must be 0\\n    // U know we are looking for 2 partitions with greater than or equals to k\\n    int total = nums.reduce((value, element) => value + element);\\n    if (total < 2 * k) return 0;\\n\\n    // For 2^n, custom 2^n, coz of large constranit and mod\\n    int possiblePermutationCount = 1;\\n    for (int i = 1; i <= n; i++) {\\n      possiblePermutationCount = ((possiblePermutationCount % mod) * 2) % mod;\\n    }\\n\\n    List<List<int?>> dp = List.generate(\\n      n,\\n      (index) => List.filled(k + 1, null),\\n    );\\n    // Count less than k sum\\n    int f(int i, int sum) {\\n      if (i == n) {\\n        if (sum < k) {\\n          return 1;\\n        }\\n        return 0;\\n      }\\n      if (dp[i][sum] != null) {\\n        return dp[i][sum]!;\\n      }\\n      int pick = 0;\\n      if (nums[i] + sum < k) {\\n        pick = f(i + 1, nums[i] + sum) % mod;\\n      }\\n      int notPick = f(i + 1, sum) % mod;\\n\\n      return dp[i][sum] = (pick + notPick) % mod;\\n    }\\n    // Muliply by 2 coz we gonna take [4][1,2,3,4] and [1,2,3][4]\\n    int res = possiblePermutationCount - (2 * f(0, 0));\\n    // This one is still confusing if the value go negative we should plus mod to get answer\\n    // Kind of mod things, I got the below line from other solution\\n    if(res<0)res+=mod;\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int countPartitions(List<int> nums, int k) {\\n    int n = nums.length;\\n    int mod = 1e9.toInt() + 7;\\n\\n    // If the total sum is less than 2k, it must be 0\\n    // U know we are looking for 2 partitions with greater than or equals to k\\n    int total = nums.reduce((value, element) => value + element);\\n    if (total < 2 * k) return 0;\\n\\n    // For 2^n, custom 2^n, coz of large constranit and mod\\n    int possiblePermutationCount = 1;\\n    for (int i = 1; i <= n; i++) {\\n      possiblePermutationCount = ((possiblePermutationCount % mod) * 2) % mod;\\n    }\\n\\n    List<List<int?>> dp = List.generate(\\n      n,\\n      (index) => List.filled(k + 1, null),\\n    );\\n    // Count less than k sum\\n    int f(int i, int sum) {\\n      if (i == n) {\\n        if (sum < k) {\\n          return 1;\\n        }\\n        return 0;\\n      }\\n      if (dp[i][sum] != null) {\\n        return dp[i][sum]!;\\n      }\\n      int pick = 0;\\n      if (nums[i] + sum < k) {\\n        pick = f(i + 1, nums[i] + sum) % mod;\\n      }\\n      int notPick = f(i + 1, sum) % mod;\\n\\n      return dp[i][sum] = (pick + notPick) % mod;\\n    }\\n    // Muliply by 2 coz we gonna take [4][1,2,3,4] and [1,2,3][4]\\n    int res = possiblePermutationCount - (2 * f(0, 0));\\n    // This one is still confusing if the value go negative we should plus mod to get answer\\n    // Kind of mod things, I got the below line from other solution\\n    if(res<0)res+=mod;\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999217,
                "title": "direct-counting-dp-o-nk",
                "content": "# Approach\\nThis solution does not count complement subsets like other solutions, and instead count the desired subsets directly with a DP recursive function and memoization.\\n\\n```dp(index, curr_sum)``` represents state of deciding for whether or not to add ```index```th number to the first group knowing that the first\\'s group sum is already ```curr_sum```.\\n\\nThe key point here is, we don\\'t need to proceed anymore if we get a sum bigger or equal to ```k```.\\n\\n# Complexity\\n```O(NK)``` Time complexity\\n\\n# Code\\n```\\nfrom itertools import accumulate\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        s = sum(nums)\\n        mod = int(1e9 + 7)\\n        mem = [[-1 for _ in range(k)] for _ in range(n + 1)]\\n        prefix_sum = [0] + list(accumulate(nums))\\n\\n        def dp(index, curr_sum):\\n            if index == n + 1:\\n                return int(curr_sum >= k and (s - curr_sum) >= k)\\n\\n            if mem[index][curr_sum] != -1:\\n                return mem[index][curr_sum]\\n\\n            mem[index][curr_sum] = dp(index + 1, curr_sum)\\n            if curr_sum + nums[index - 1] >= k:\\n                if prefix_sum[index] - (curr_sum + nums[index - 1]) >= k:\\n                     mem[index][curr_sum] += pow(2, (n - index), mod)\\n            else:\\n                mem[index][curr_sum] += dp(index + 1, curr_sum + nums[index - 1])\\n            return mem[index][curr_sum]\\n        return (2 * dp(1, 0)) % mod\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```dp(index, curr_sum)```\n```index```\n```curr_sum```\n```k```\n```O(NK)```\n```\\nfrom itertools import accumulate\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        s = sum(nums)\\n        mod = int(1e9 + 7)\\n        mem = [[-1 for _ in range(k)] for _ in range(n + 1)]\\n        prefix_sum = [0] + list(accumulate(nums))\\n\\n        def dp(index, curr_sum):\\n            if index == n + 1:\\n                return int(curr_sum >= k and (s - curr_sum) >= k)\\n\\n            if mem[index][curr_sum] != -1:\\n                return mem[index][curr_sum]\\n\\n            mem[index][curr_sum] = dp(index + 1, curr_sum)\\n            if curr_sum + nums[index - 1] >= k:\\n                if prefix_sum[index] - (curr_sum + nums[index - 1]) >= k:\\n                     mem[index][curr_sum] += pow(2, (n - index), mod)\\n            else:\\n                mem[index][curr_sum] += dp(index + 1, curr_sum + nums[index - 1])\\n            return mem[index][curr_sum]\\n        return (2 * dp(1, 0)) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995127,
                "title": "c-dp-solution",
                "content": "# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll mod=1e9+7;\\n    ll mypow(ll a,ll b)\\n    {\\n        ll res=1;\\n        while(b)\\n        {\\n            if(b&1)res=(res*a)%mod;\\n            a=(a*a)%mod;\\n            b>>=1;\\n        }\\n        return res;\\n    }\\n\\n    int countPartitions(vector<int>& nums, int k) \\n    {\\n        int n=nums.size();\\n        vector<vector<ll>>f(n,vector<ll>(k+1,0));\\n        ll tot=0;\\n        for(auto &x:nums)tot+=x;\\n        if(tot<2*k)return 0;\\n        f[0][0]=1;\\n        if(nums[0]<k)f[0][nums[0]]=1;\\n        for(int i=1;i<n;i++)\\n            for(int j=0;j<k;j++)\\n            {\\n                f[i][j]=(f[i][j]+f[i-1][j])%mod;\\n                if(j+nums[i]<k)f[i][j+nums[i]]=(f[i][j+nums[i]]+f[i-1][j])%mod;\\n            }\\n        ll revans=0;\\n        for(int i=0;i<k;i++)revans=revans+f[n-1][i];\\n        revans=revans*2%mod;\\n        ll ans=((mypow(2,n)-revans)%mod+mod)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll mod=1e9+7;\\n    ll mypow(ll a,ll b)\\n    {\\n        ll res=1;\\n        while(b)\\n        {\\n            if(b&1)res=(res*a)%mod;\\n            a=(a*a)%mod;\\n            b>>=1;\\n        }\\n        return res;\\n    }\\n\\n    int countPartitions(vector<int>& nums, int k) \\n    {\\n        int n=nums.size();\\n        vector<vector<ll>>f(n,vector<ll>(k+1,0));\\n        ll tot=0;\\n        for(auto &x:nums)tot+=x;\\n        if(tot<2*k)return 0;\\n        f[0][0]=1;\\n        if(nums[0]<k)f[0][nums[0]]=1;\\n        for(int i=1;i<n;i++)\\n            for(int j=0;j<k;j++)\\n            {\\n                f[i][j]=(f[i][j]+f[i-1][j])%mod;\\n                if(j+nums[i]<k)f[i][j+nums[i]]=(f[i][j+nums[i]]+f[i-1][j])%mod;\\n            }\\n        ll revans=0;\\n        for(int i=0;i<k;i++)revans=revans+f[n-1][i];\\n        revans=revans*2%mod;\\n        ll ans=((mypow(2,n)-revans)%mod+mod)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984639,
                "title": "simple-solution-with-comments-o-nk",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBased on the hints: Solve the reverse problem, that is, find the number of partitions where the sum of elements of at least one of the two groups is smaller than k.\\n\\nThen use solution to knpasack problem\\n\\n# Complexity\\n- Time complexity:\\nO(Nk)\\n\\n- Space complexity:\\nO(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        const int mod = 1e9 + 7;\\n        int N = nums.size();\\n        \\n        vector<int> dp(k);\\n        dp[0] = 1;\\n        for (int i = 0; i < N; i++) {\\n            for (int c = k-1; c >= nums[i]; c--) {\\n                dp[c] += dp[c - nums[i]];\\n                dp[c] %= mod;\\n            }\\n        }\\n\\n        long sum = accumulate(nums.begin(), nums.end(), 0l);\\n        \\n        long smaller = 0; // number of partitions where at least one group with sum smaller than k\\n        for (int i = 0; i < k; i++) {\\n            smaller += dp[i];\\n            if (sum - i >= k) { \\n                smaller += dp[i]; \\n                // it can be [i, sum-i] or [sum-i, i] so count twice\\n            }\\n            // else, it will be counted in dp[sum-i]\\n            smaller %= mod;\\n        }\\n        \\n        long exp = 1;\\n        for (int i = 0; i < N; i++) {\\n            exp = exp * 2 % mod;\\n        }\\n        return (exp - smaller + mod) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        const int mod = 1e9 + 7;\\n        int N = nums.size();\\n        \\n        vector<int> dp(k);\\n        dp[0] = 1;\\n        for (int i = 0; i < N; i++) {\\n            for (int c = k-1; c >= nums[i]; c--) {\\n                dp[c] += dp[c - nums[i]];\\n                dp[c] %= mod;\\n            }\\n        }\\n\\n        long sum = accumulate(nums.begin(), nums.end(), 0l);\\n        \\n        long smaller = 0; // number of partitions where at least one group with sum smaller than k\\n        for (int i = 0; i < k; i++) {\\n            smaller += dp[i];\\n            if (sum - i >= k) { \\n                smaller += dp[i]; \\n                // it can be [i, sum-i] or [sum-i, i] so count twice\\n            }\\n            // else, it will be counted in dp[sum-i]\\n            smaller %= mod;\\n        }\\n        \\n        long exp = 1;\\n        for (int i = 0; i < N; i++) {\\n            exp = exp * 2 % mod;\\n        }\\n        return (exp - smaller + mod) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972819,
                "title": "dp-approach-memoization",
                "content": "\\nclass Solution {\\n    const int m=1e9+7;\\npublic:\\n   long long min(long long a,long long b){\\n        if(a<b)return a;\\n        return b;\\n   }\\n    int solve(int i,vector<vector<long long>>&dp,vector<int>&nums,int n,int k,long long sum1,long long sum2,long long v)\\n    {\\n        if(i>=n)\\n        {\\n            if(sum1>=k && sum2>=k)\\n            return 1;    \\n            return 0;\\n        }\\n        if(dp[i][v]!=-1)\\n        return dp[i][v]%m;\\n        long long x=solve(i+1,dp,nums,n,k,sum1+nums[i]%m,sum2,min(1000,min(sum1+nums[i],sum2)));long long y=solve(i+1,dp,nums,n,k,sum1,sum2+nums[i],min(1000,min(sum1,nums[i]+sum2)));\\n        return dp[i][v]=(x+y)%m;\\n    }\\n    int countPartitions(vector<int>& nums, int k) {\\n        long long int n=nums.size();\\n        vector<vector<long long>>dp(1100,vector<long long>(1100,-1)); \\n        long long int c=0;\\n        //sort(nums.begin(),nums.end());\\n        c= solve(0,dp,nums,n,k,0,0,0);\\n     return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    const int m=1e9+7;\\npublic:\\n   long long min(long long a,long long b){\\n        if(a<b)return a;\\n        return b;\\n   }",
                "codeTag": "Java"
            },
            {
                "id": 2972626,
                "title": "swift-solution-dp",
                "content": "# Approach\\nCalculates the number of permutations of A with k as the maximum sum of any partition.\\n\\nSo, we have to subtract the number of permutations of A with k as the minimum sum from the number of permutations of A with k as the maximum sum.\\n\\nFor the first part, we calculate the number of permutations of A with k as the maximum sum using dynamic programming.\\nWe have a dp array, which stores the number of permutations of A with k as the maximum sum and the sum of the partition is i.\\nWe have a res variable, which stores the number of permutations of A with k as the maximum sum.\\n\\nWe have a total variable, which stores the sum of all elements in A.\\nWe iterate over all elements in A, and we iterate over all values of i in reverse order, and we update dp[i + a] = dp[i + a] + dp[i] (mod 1e9 + 7).\\nWe update res = res * 2 (mod 1e9 + 7).\\nWe update total = total + a.\\nWe iterate over all values of i, and we update res = res - (total - i < k ? dp[i] : dp[i] * 2).\\nWe return (res + 1e9 + 7) % 1e9 + 7.\\n\\n# Complexity\\n- Time complexity: O(nk)\\n\\n- Space complexity: O(k)\\n\\n# Code\\n```\\nclass Solution {\\n    func countPartitions(_ A: [Int], _ k: Int) -> Int {\\n        let mod: Int = Int(1e9) + 7\\n        var total: Int = 0, res: Int = 1, dp: [Int] = [Int](repeating: 0, count: k)\\n        dp[0] = 1\\n        for a in A {\\n            for i in stride(from: k - 1 - a, to: -1, by: -1) {\\n                dp[i + a] = (dp[i + a] + dp[i]) % mod\\n            }\\n            res = res * 2 % mod\\n            total += a\\n        }\\n        for i in 0..<k {\\n            res -= total - i < k ? dp[i] : dp[i] * 2\\n        }\\n        return (res % mod + mod) % mod\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    func countPartitions(_ A: [Int], _ k: Int) -> Int {\\n        let mod: Int = Int(1e9) + 7\\n        var total: Int = 0, res: Int = 1, dp: [Int] = [Int](repeating: 0, count: k)\\n        dp[0] = 1\\n        for a in A {\\n            for i in stride(from: k - 1 - a, to: -1, by: -1) {\\n                dp[i + a] = (dp[i + a] + dp[i]) % mod\\n            }\\n            res = res * 2 % mod\\n            total += a\\n        }\\n        for i in 0..<k {\\n            res -= total - i < k ? dp[i] : dp[i] * 2\\n        }\\n        return (res % mod + mod) % mod\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971822,
                "title": "dp-c-solution-with-explanation-o-n-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    #define ll long long\\n    int countPartitions(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        ll sum = 0;\\n        for(auto it: nums)\\n        {\\n            sum+=it;\\n        }\\n        if(2*k>sum)\\n        {\\n            return 0; // if sum is less than 2*k then we can not partition it into two parts with each part having sum at least k\\n        }\\n        if(n==1)\\n        {\\n            return 0;\\n\\n        }\\n        ll way = 1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            way = (way*2)%mod; // total number of way to partition array into two parts\\n\\n        }\\n        \\n        vector<vector<ll>> dp(n,vector<ll>(k,0)); // number of way to partition the array till point i such that sum is j\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<k;j++)\\n            {\\n                if(i==0 && j==0)\\n                {\\n                    dp[i][j] = 1;\\n                }\\n                else\\n                { \\n                    if(i==0)\\n                    {\\n                       if(j==nums[i])\\n                       dp[i][j] = 1;\\n                    }\\n                   else \\n                    {\\n                    dp[i][j] = dp[i-1][j];\\n                    if(j-nums[i]>=0)\\n                    {\\n                        dp[i][j] += dp[i-1][j-nums[i]];\\n                        dp[i][j]%=mod;\\n                    }\\n                    }\\n                }\\n            }\\n        }\\n        ll res = 0;\\n\\n        for(int i=0;i<k;i++)\\n        {\\n            res+=dp[n-1][i]; \\n        }\\n        res%=mod;\\n        //calculating the number of way to partition the array into two part such that both part sum is greater or equal to k. This is done by substracting total number of ways to partition the array into two parts and the number of way to partition the array into two part such that one part has sum less than k.\\n        ll ans = (way - 2*res  + mod)%mod;\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    #define ll long long\\n    int countPartitions(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        ll sum = 0;\\n        for(auto it: nums)\\n        {\\n            sum+=it;\\n        }\\n        if(2*k>sum)\\n        {\\n            return 0; // if sum is less than 2*k then we can not partition it into two parts with each part having sum at least k\\n        }\\n        if(n==1)\\n        {\\n            return 0;\\n\\n        }\\n        ll way = 1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            way = (way*2)%mod; // total number of way to partition array into two parts\\n\\n        }\\n        \\n        vector<vector<ll>> dp(n,vector<ll>(k,0)); // number of way to partition the array till point i such that sum is j\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<k;j++)\\n            {\\n                if(i==0 && j==0)\\n                {\\n                    dp[i][j] = 1;\\n                }\\n                else\\n                { \\n                    if(i==0)\\n                    {\\n                       if(j==nums[i])\\n                       dp[i][j] = 1;\\n                    }\\n                   else \\n                    {\\n                    dp[i][j] = dp[i-1][j];\\n                    if(j-nums[i]>=0)\\n                    {\\n                        dp[i][j] += dp[i-1][j-nums[i]];\\n                        dp[i][j]%=mod;\\n                    }\\n                    }\\n                }\\n            }\\n        }\\n        ll res = 0;\\n\\n        for(int i=0;i<k;i++)\\n        {\\n            res+=dp[n-1][i]; \\n        }\\n        res%=mod;\\n        //calculating the number of way to partition the array into two part such that both part sum is greater or equal to k. This is done by substracting total number of ways to partition the array into two parts and the number of way to partition the array into two part such that one part has sum less than k.\\n        ll ans = (way - 2*res  + mod)%mod;\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971057,
                "title": "quick-intuition-2d-dp-1d-dp",
                "content": "Please correct or improve my understading if it is not correct. It is open to discuss furthur.\\n# Intuition\\nAlways define DP such that it starts from given parameters and reduces to lower numbers. Hence, the lower bound is the stopping condition like if( i == 0 or i==-1) like this.\\nFor ex -> in a knapsack, given params are sack_capacity, weight[], profit[], n(size of the array).\\nthere are many ways we can define our DP states.\\n1. DP[idx][collected_wgt_so_far] \\u2192 max profit by using arr [idx, n) range and already put collected_wgt_so_far in our sack of capacity sack_capacity.\\n```\\nif((collected_wgt_so_far + weight[idx])<=sack_capacity)\\n     include =  DP[idx+1][collected_wgt_so_far + weight[idx]]\\nExclude = DP[i+1][collected_wgt_so_far]\\n\\nDP[idx][collected_wgt_so_far]  = include + exclude;\\n```\\nIn this, recursive call starts from DP[0][0] \\u2026 DP[^][^] \\u2026 ends when  idx == n or collected_wgt_so_far == capacity\\nHere, DP states are going from lower nums to higher nums. So, stopping conditions need to depend on the given nums. Like on arr size or on sack_capacity.\\n\\n2. DP[idx][wgt] \\u2192 max profit by using arr [idx, n) range for sack capacity wgt.\\n```\\nif(wgt >= weight[idx])\\n    include =  DP[idx+1][wgt - weight[idx]]\\nExclude = DP[i+1][wgt]\\n\\nDP[idx][wgt]  = include + exclude;\\n```\\nCall starts from DP[0][sack_capacity] \\u2026 DP[^][v] \\u2026  ends when i == n or sack_capacity == 0.\\nHere, still stopping condition depends on n, which is again user-controllable param. But the first state of DP is increasing and 2nd is decreasing.\\n\\n3. DP[len][wgt] \\u2192 max profit by using arr of length len(from the beginning) with sack capacity wgt.\\n```\\nif(wgt >= weight[idx])\\ninclude =  DP[len-1][wgt - weight[len]]\\nExclude = DP[len - 1][wgt]\\n\\nDP[len][wgt]  = include + exclude;\\n```\\nCall starts from DP[n][sack_capacity] \\u2026 DP[v][v] ends when i == 0 or wgt == 0.\\nHere, our service no more depends on user params, instead, the initial call depends on user inputs. It is okay as the user needs to do the initial call so the user knows their input parameters but our service is more flexible.\\nOne important thing is, Now we are processing from given nums i.e. n, sack_capacity  towards lower nums i.e. when i ==0 or wgt == 0. This is what we always need to target as it is easier to look at and optimize the DP states.\\n\\n\\u2014--------\\n\\nCompare all three and see how clean is the last approach. This cleanliness of DP states emphasizes and shouting us:\\n\\u201Chey look 1st state only depends on its previous iteration values\\u201D\\n i.e. DP[len][] depends on only previous value DP[len-1][]\\n\\u201CHey look again, 2nd state depends on its own value of the previous iteration i.e. DP[prev_iteration == len-1][wgt] and lesser values of previous iterations i.e. DP[prev_iteration == [len-1][wgt-something]\\u201D\\n\\nSo, from 3rd. approach we can say,\\n```\\n2D-DP                                   |||      1D-DP\\nif(wgt >= weight[idx])                  |||     if(wgt >= weight[idx])\\ninclude =  DP[len-1][wgt - weight[len]] |||     include =  DP[wgt - weight[len]\\nExclude = DP[len - 1][wgt]              |||     //Exclude = DP[wgt] it is same what\\n                                        |||     DP[wgt] holding right now. So, we can drop\\n                                       |||     this statement and simply do +=\\n                                       |||\\nDP[len][wgt]  = include + exclude;     |||     DP[wgt] += include\\n```\\n\\n# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    const int M = 1e9+7;\\n    int countPartitions(vector<int>& nums, int k) {\\n        const int n = nums.size();\\n\\n        vector<vector<int>> dp(n+1, vector<int>(k, 1));\\n        int tot_part = 1;\\n        ll tot_sum = 0LL;\\n        //1. find out #bad_partitions\\n        for(int i = 1; i<n+1; ++i){\\n            tot_part = tot_part*2%M;\\n            tot_sum += nums[i-1];\\n            for(int j = 1; j<k; ++j){\\n                if(nums[i-1]<=j) dp[i][j] = (dp[i-1][j] + dp[i-1][j-nums[i-1]])%M;\\n                else dp[i][j] = dp[i-1][j];\\n            }\\n        }\\n\\n        //edge case if total_sum(nums)<2*k then return 0;\\n        if(tot_sum<2*k) return 0;\\n\\n        //2. total_partitions - #bad_partitions(dp[n][k-1]*2)\\n        int ans = (tot_part - dp[n][k-1]*2%M + M)%M;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nif((collected_wgt_so_far + weight[idx])<=sack_capacity)\\n     include =  DP[idx+1][collected_wgt_so_far + weight[idx]]\\nExclude = DP[i+1][collected_wgt_so_far]\\n\\nDP[idx][collected_wgt_so_far]  = include + exclude;\\n```\n```\\nif(wgt >= weight[idx])\\n    include =  DP[idx+1][wgt - weight[idx]]\\nExclude = DP[i+1][wgt]\\n\\nDP[idx][wgt]  = include + exclude;\\n```\n```\\nif(wgt >= weight[idx])\\ninclude =  DP[len-1][wgt - weight[len]]\\nExclude = DP[len - 1][wgt]\\n\\nDP[len][wgt]  = include + exclude;\\n```\n```\\n2D-DP                                   |||      1D-DP\\nif(wgt >= weight[idx])                  |||     if(wgt >= weight[idx])\\ninclude =  DP[len-1][wgt - weight[len]] |||     include =  DP[wgt - weight[len]\\nExclude = DP[len - 1][wgt]              |||     //Exclude = DP[wgt] it is same what\\n                                        |||     DP[wgt] holding right now. So, we can drop\\n                                       |||     this statement and simply do +=\\n                                       |||\\nDP[len][wgt]  = include + exclude;     |||     DP[wgt] += include\\n```\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    const int M = 1e9+7;\\n    int countPartitions(vector<int>& nums, int k) {\\n        const int n = nums.size();\\n\\n        vector<vector<int>> dp(n+1, vector<int>(k, 1));\\n        int tot_part = 1;\\n        ll tot_sum = 0LL;\\n        //1. find out #bad_partitions\\n        for(int i = 1; i<n+1; ++i){\\n            tot_part = tot_part*2%M;\\n            tot_sum += nums[i-1];\\n            for(int j = 1; j<k; ++j){\\n                if(nums[i-1]<=j) dp[i][j] = (dp[i-1][j] + dp[i-1][j-nums[i-1]])%M;\\n                else dp[i][j] = dp[i-1][j];\\n            }\\n        }\\n\\n        //edge case if total_sum(nums)<2*k then return 0;\\n        if(tot_sum<2*k) return 0;\\n\\n        //2. total_partitions - #bad_partitions(dp[n][k-1]*2)\\n        int ans = (tot_part - dp[n][k-1]*2%M + M)%M;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961884,
                "title": "c-dp-o-n-k",
                "content": "# Observation\\n* We have to find a number of ways to partition a array into two subsequence that both of that have sum greater or equal to k\\n* so the first approach which is coming to my mind is to do it by brute force and go for each subsequence and found both have sum greater equal to k or not but it will going to give **TLE**\\n* Here opposite of doing above brute force and finding subsequences with sum k or greater we can find out how many subsequence are there with sum less than k\\n\\n# Process\\n* If the total sum of array is less than 2 * k so ans will be 0\\n* else find out number of sequences with sum 0 to k-1\\n* and ans will be total subsequences - 2 * (squences with sum 0 to k-1)\\n* we are multiplying by 2 becoz the invalid way either in way once we found by selecting squence 0 to k-1 or sum-(0 to k-1) \\n\\n# Complexity\\n- Time complexity: O(N * K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int notPos=0;\\npublic:\\n\\n    int countPartitions(vector<int>& nums, int k) {\\n        vector<int> dp(k,0);\\n        dp[0]=1;\\n        long mod=1e9+7;\\n        long long sum=0;\\n        int n=nums.size();\\n        int ans=1;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            ans=(ans*2)%mod;\\n            for(int j=k-1;j>=nums[i];j--){\\n                dp[j]=(dp[j]+dp[j-nums[i]])%mod;    //find number of times we can found subsequence with sum 0 to k-1 be using nums[i];\\n            }\\n        }\\n        if(2*k>sum){\\n            return 0;\\n        }\\n        long long notPos=0;\\n\\n        for(int i=0;i<k;i++){\\n            notPos=(notPos+dp[i])%mod;\\n        }\\n        return (ans-2*notPos+mod)%mod;\\n    }\\n};\\n//code by sachin\\n```\\n**Upvote if solution was helpful**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int notPos=0;\\npublic:\\n\\n    int countPartitions(vector<int>& nums, int k) {\\n        vector<int> dp(k,0);\\n        dp[0]=1;\\n        long mod=1e9+7;\\n        long long sum=0;\\n        int n=nums.size();\\n        int ans=1;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            ans=(ans*2)%mod;\\n            for(int j=k-1;j>=nums[i];j--){\\n                dp[j]=(dp[j]+dp[j-nums[i]])%mod;    //find number of times we can found subsequence with sum 0 to k-1 be using nums[i];\\n            }\\n        }\\n        if(2*k>sum){\\n            return 0;\\n        }\\n        long long notPos=0;\\n\\n        for(int i=0;i<k;i++){\\n            notPos=(notPos+dp[i])%mod;\\n        }\\n        return (ans-2*notPos+mod)%mod;\\n    }\\n};\\n//code by sachin\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960785,
                "title": "c-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    void add(int& a, int b) {\\n        a += b;\\n        if (a >= mod) {\\n            a -= mod;\\n        }\\n    }\\n    int mul(int a, int b) {\\n        return ((long long) a * b) % mod;\\n    }\\n    int countPartitions(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n + 1, vector<int> (k));\\n        dp[0][0] = 1;\\n        long long total = 0;\\n        for (int i = 0; i < n; i++) {\\n            total += nums[i];\\n            for (int sum = 0; sum < k; sum++) {\\n                add(dp[i + 1][sum], dp[i][sum]);\\n                if (sum + nums[i] < k) {\\n                    add(dp[i + 1][sum + nums[i]], dp[i][sum]);\\n                }\\n            }\\n        }\\n        if (k > total / 2) {\\n            return 0;\\n        }\\n        int rem = 0;\\n        for (int i = 0; i < k; i++) {\\n            add(rem, dp[n][i]);\\n        }\\n        int pw = 1;\\n        for (int i = 0; i < n; i++) {\\n            pw = mul(pw, 2);\\n        }\\n        rem = mul(rem, 2);\\n        pw -= rem;\\n        if (pw < 0) {\\n            pw += mod;\\n        }\\n        return pw;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    void add(int& a, int b) {\\n        a += b;\\n        if (a >= mod) {\\n            a -= mod;\\n        }\\n    }\\n    int mul(int a, int b) {\\n        return ((long long) a * b) % mod;\\n    }\\n    int countPartitions(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n + 1, vector<int> (k));\\n        dp[0][0] = 1;\\n        long long total = 0;\\n        for (int i = 0; i < n; i++) {\\n            total += nums[i];\\n            for (int sum = 0; sum < k; sum++) {\\n                add(dp[i + 1][sum], dp[i][sum]);\\n                if (sum + nums[i] < k) {\\n                    add(dp[i + 1][sum + nums[i]], dp[i][sum]);\\n                }\\n            }\\n        }\\n        if (k > total / 2) {\\n            return 0;\\n        }\\n        int rem = 0;\\n        for (int i = 0; i < k; i++) {\\n            add(rem, dp[n][i]);\\n        }\\n        int pw = 1;\\n        for (int i = 0; i < n; i++) {\\n            pw = mul(pw, 2);\\n        }\\n        rem = mul(rem, 2);\\n        pw -= rem;\\n        if (pw < 0) {\\n            pw += mod;\\n        }\\n        return pw;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960139,
                "title": "simple-c-solution-with-comments",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    #define mod 1000000007\\n\\n    //Function to find (a raise to power b) mod m in logb  time\\n    ll mod_pow(ll a, ll b)\\n    {\\n        if (b == 0) return 1;\\n        ll x = mod_pow(a, b/2);\\n        x = (x * x) % mod;\\n        if (b % 2)\\n            x = (x * a) % mod;\\n        return x;\\n    }\\n\\n    int countPartitions(vector<int>& nums, int k) {\\n        ll totalSum =0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n            totalSum+=nums[i];\\n\\n        //Condition 1:\\n        if((2*k)>totalSum) return 0;\\n\\n        //Condition 2:\\n        if(n == 1) return 0;\\n        \\n        //Count subsets with sum less than k\\n        vector<vector<ll>> dp(n,vector<ll>(k,0));\\n        \\n        for(int i =0 ;i<n ; i++){\\n            for(int j =0; j < k; j++){\\n                if(!i && !j){\\n                    dp[i][j] = 1;\\n                    continue;\\n                }\\n                if(i == 0){\\n                    if(j==nums[i]) dp[i][j] = 1;\\n                    continue;\\n                }\\n                //can not include current element\\n                if(nums[i]>j) dp[i][j] = dp[i-1][j];\\n                else{\\n                    //sum of exclude + include ways\\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]];\\n                    dp[i][j] %= mod;\\n                }\\n            }\\n        }\\n\\n        //find sum of last row of above dp table to get total subsets with sum less than k\\n        ll invalid_ways= 0;\\n        for(int i = 1; i< k ; i++){\\n            invalid_ways += dp[n-1][i];\\n        }\\n        invalid_ways %= mod;\\n        \\n        //get answer using total ways and invalid ways\\n        ll totalWays = mod_pow(2,n);\\n        totalWays -= 2;         // subsets can not be empty as per problem statment\\n        totalWays -= 2*invalid_ways;\\n        totalWays = (totalWays%mod + mod)%mod;\\n        return totalWays;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    #define mod 1000000007\\n\\n    //Function to find (a raise to power b) mod m in logb  time\\n    ll mod_pow(ll a, ll b)\\n    {\\n        if (b == 0) return 1;\\n        ll x = mod_pow(a, b/2);\\n        x = (x * x) % mod;\\n        if (b % 2)\\n            x = (x * a) % mod;\\n        return x;\\n    }\\n\\n    int countPartitions(vector<int>& nums, int k) {\\n        ll totalSum =0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n            totalSum+=nums[i];\\n\\n        //Condition 1:\\n        if((2*k)>totalSum) return 0;\\n\\n        //Condition 2:\\n        if(n == 1) return 0;\\n        \\n        //Count subsets with sum less than k\\n        vector<vector<ll>> dp(n,vector<ll>(k,0));\\n        \\n        for(int i =0 ;i<n ; i++){\\n            for(int j =0; j < k; j++){\\n                if(!i && !j){\\n                    dp[i][j] = 1;\\n                    continue;\\n                }\\n                if(i == 0){\\n                    if(j==nums[i]) dp[i][j] = 1;\\n                    continue;\\n                }\\n                //can not include current element\\n                if(nums[i]>j) dp[i][j] = dp[i-1][j];\\n                else{\\n                    //sum of exclude + include ways\\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]];\\n                    dp[i][j] %= mod;\\n                }\\n            }\\n        }\\n\\n        //find sum of last row of above dp table to get total subsets with sum less than k\\n        ll invalid_ways= 0;\\n        for(int i = 1; i< k ; i++){\\n            invalid_ways += dp[n-1][i];\\n        }\\n        invalid_ways %= mod;\\n        \\n        //get answer using total ways and invalid ways\\n        ll totalWays = mod_pow(2,n);\\n        totalWays -= 2;         // subsets can not be empty as per problem statment\\n        totalWays -= 2*invalid_ways;\\n        totalWays = (totalWays%mod + mod)%mod;\\n        return totalWays;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959871,
                "title": "recursion-memorization",
                "content": "# Complexity\\n- Time complexity: O(N^2)\\n- Space complexity: O(N^2)\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int dp[1001][1005]; const int MOD = 1e9 + 7;\\n    int solve(int i,int k,vector<int> &nums){\\n        if(i == nums.size()) return k > 0;\\n        if(dp[i][k+1] != -1) return dp[i][k+1];\\n\\n        int op1 = solve(i+1,max(k-nums[i],-1),nums);\\n        int op2 = solve(i+1,k,nums);\\n\\n        return dp[i][k+1] = (op1 + op2) % MOD;\\n    }\\n    int countPartitions(vector<int>& nums, int k) {\\n        bool pos = accumulate(nums.begin(),nums.end(),0ll) >= 2*k;\\n        if(!pos) return 0;\\n        memset(dp,-1,sizeof dp);\\n        int invalid = (2*solve(0,k,nums)) % MOD;\\n        ll pw = 1;\\n        for(int i : nums) pw = (pw*2) % MOD;\\n        int ans = pw - invalid;\\n        return ans < 0 ? ans + MOD : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int dp[1001][1005]; const int MOD = 1e9 + 7;\\n    int solve(int i,int k,vector<int> &nums){\\n        if(i == nums.size()) return k > 0;\\n        if(dp[i][k+1] != -1) return dp[i][k+1];\\n\\n        int op1 = solve(i+1,max(k-nums[i],-1),nums);\\n        int op2 = solve(i+1,k,nums);\\n\\n        return dp[i][k+1] = (op1 + op2) % MOD;\\n    }\\n    int countPartitions(vector<int>& nums, int k) {\\n        bool pos = accumulate(nums.begin(),nums.end(),0ll) >= 2*k;\\n        if(!pos) return 0;\\n        memset(dp,-1,sizeof dp);\\n        int invalid = (2*solve(0,k,nums)) % MOD;\\n        ll pw = 1;\\n        for(int i : nums) pw = (pw*2) % MOD;\\n        int ans = pw - invalid;\\n        return ans < 0 ? ans + MOD : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959058,
                "title": "c-java-python3-knapsack",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/005b032a13cf6bbd99dad7507a8288ad640cc9f1) for solutions of weekly 325. \\n\\n**Intuition**\\nWe solve the complement problem of count the cases where a group sum is less than `k`. \\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        const int mod = 1\\'000\\'000\\'007; \\n        long ans = 1, total = 0; \\n        vector<long> dp(k); \\n        dp[0] = 1; \\n        for (auto& x : nums) {\\n            ans = 2*ans % mod; \\n            total += x; \\n            for (int i = k-1-x; i >= 0; --i) \\n                dp[i+x] = (dp[i] + dp[i+x]) % mod; \\n        }\\n        for (auto& x : dp) cout << x << endl; \\n        ans -= 2*accumulate(dp.begin(), dp.end(), 0l); \\n        return total >= 2*k ? (ans % mod + mod) % mod : 0;\\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int countPartitions(int[] nums, int k) {\\n        final int mod = 1_000_000_007; \\n        long ans = 1, total = 0; \\n        long[] dp = new long[k]; \\n        dp[0] = 1; \\n        for (var x : nums) {\\n            ans = 2*ans % mod; \\n            total += x; \\n            for (int i = k-1-x; i >= 0; --i) \\n                dp[i+x] = (dp[i] + dp[i+x]) % mod; \\n        }\\n        ans -= 2*LongStream.of(dp).sum(); \\n        return total >= 2*k ? (int) (ans % mod + mod) % mod : 0; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        mod = 1_000_000_007\\n        if sum(nums) < 2*k: return 0 \\n        dp = [0]*k\\n        dp[0] = 1\\n        for x in nums: \\n            for i in range(k-1-x, -1, -1): \\n                dp[i+x] += dp[i]\\n        return (pow(2, len(nums), mod) - 2*sum(dp)) % mod\\n```\\n**Complexity**\\nTime `O(NK)`\\nSpace `O(K)`",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        const int mod = 1\\'000\\'000\\'007; \\n        long ans = 1, total = 0; \\n        vector<long> dp(k); \\n        dp[0] = 1; \\n        for (auto& x : nums) {\\n            ans = 2*ans % mod; \\n            total += x; \\n            for (int i = k-1-x; i >= 0; --i) \\n                dp[i+x] = (dp[i] + dp[i+x]) % mod; \\n        }\\n        for (auto& x : dp) cout << x << endl; \\n        ans -= 2*accumulate(dp.begin(), dp.end(), 0l); \\n        return total >= 2*k ? (ans % mod + mod) % mod : 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int countPartitions(int[] nums, int k) {\\n        final int mod = 1_000_000_007; \\n        long ans = 1, total = 0; \\n        long[] dp = new long[k]; \\n        dp[0] = 1; \\n        for (var x : nums) {\\n            ans = 2*ans % mod; \\n            total += x; \\n            for (int i = k-1-x; i >= 0; --i) \\n                dp[i+x] = (dp[i] + dp[i+x]) % mod; \\n        }\\n        ans -= 2*LongStream.of(dp).sum(); \\n        return total >= 2*k ? (int) (ans % mod + mod) % mod : 0; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        mod = 1_000_000_007\\n        if sum(nums) < 2*k: return 0 \\n        dp = [0]*k\\n        dp[0] = 1\\n        for x in nums: \\n            for i in range(k-1-x, -1, -1): \\n                dp[i+x] += dp[i]\\n        return (pow(2, len(nums), mod) - 2*sum(dp)) % mod\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2958789,
                "title": "knapsack",
                "content": "Recursion with memoization\\n```\\n\\tint mod = 1e9+7;\\n    int dp[1000][1001]={0};\\n    \\n    int power(int a,int b){\\n        long long ans = 1,prod = a;\\n        while(b){\\n            if(b&1)\\n                ans=(ans*prod)%mod;\\n            b = b>>1;\\n            prod = (prod*prod)%mod;\\n        }\\n        return ans;\\n    }\\n    \\n    //dp[idx][Sum] -> no of subsets from 0 to idx with sum less than or equal to Sum\\n    \\n    int helper(int idx,int sum,vector<int>&nums){\\n        if(idx<0)\\n            return sum>=0;\\n        if(sum<0) return 0;\\n        if(dp[idx][sum]) return dp[idx][sum]-1;\\n        int notake = helper(idx-1,sum,nums);\\n        int take = helper(idx-1,sum-nums[idx],nums);\\n        dp[idx][sum] = 1+(take+notake)%mod;\\n        return dp[idx][sum]-1;\\n    }\\n    \\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        long long sum = 0;\\n        for(auto &it:nums)\\n            sum+=it;\\n        if(sum<2*k) return 0;\\n        int rev = helper(nums.size()-1,k-1,nums);\\n        return (power(2,nums.size())-2*rev+mod)%mod;\\n    }\\n```\\n\\n2d tabular dp\\n```\\n\\tint mod = 1e9+7;\\n    int dp[1000][1001]={0};\\n    \\n    int power(int a,int b){\\n        long long ans = 1,prod = a;\\n        while(b){\\n            if(b&1)\\n                ans=(ans*prod)%mod;\\n            b = b>>1;\\n            prod = (prod*prod)%mod;\\n        }\\n        return ans;\\n    }\\n    \\n    //dp[idx][Sum] -> no of subsets from 0 to idx with sum less than or equal to Sum\\n    \\n    \\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        long long sum = 0;\\n        for(auto &it:nums)\\n            sum+=it;\\n        if(sum<2*k) return 0;\\n        for(int i = 0;i<k;i++)\\n            dp[0][i] = 1;//empty subset sum\\n        for(int sum = nums[0];sum<k;sum++)\\n            dp[0][sum] += 1;//if the first element has value less than k, than we can include it\\n\\t\\t\\t\\n        for(int i = 1;i<nums.size();i++){\\n            for(int sum = 0;sum<k;sum++){\\n                dp[i][sum] = dp[i-1][sum];\\n                if(sum>=nums[i])\\n                    dp[i][sum] = (dp[i][sum] + dp[i-1][sum-nums[i]])%mod;\\n            }\\n        }\\n        \\n        int rev = dp[nums.size()-1][k-1];\\n        return (power(2,nums.size())-2*rev+mod)%mod;\\n    }\\n```\\n\\n1d dp\\n```\\n\\tint mod = 1e9+7;\\n    int dp[1001]={0};\\n    \\n    int power(int a,int b){\\n        long long ans = 1,prod = a;\\n        while(b){\\n            if(b&1)\\n                ans=(ans*prod)%mod;\\n            b = b>>1;\\n            prod = (prod*prod)%mod;\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        long long sum = 0;\\n        for(auto &it:nums)\\n            sum+=it;\\n        if(sum<2*k) return 0;\\n        for(int i = 0;i<k;i++)\\n            dp[i] = 1;//empty subset sum\\n        for(int sum = nums[0];sum<k;sum++)\\n            dp[sum] += 1;//if the first element has value less than k, than we can include it\\n\\t\\t\\t\\n        for(int i = 1;i<nums.size();i++)\\n            for(int sum = k-1;sum>=nums[i];sum--)\\n                dp[sum] = (dp[sum]+dp[sum-nums[i]])%mod;\\n        \\n        int rev = dp[k-1];\\n        return (power(2,nums.size())-2*rev+mod)%mod;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tint mod = 1e9+7;\\n    int dp[1000][1001]={0};\\n    \\n    int power(int a,int b){\\n        long long ans = 1,prod = a;\\n        while(b){\\n            if(b&1)\\n                ans=(ans*prod)%mod;\\n            b = b>>1;\\n            prod = (prod*prod)%mod;\\n        }\\n        return ans;\\n    }\\n    \\n    //dp[idx][Sum] -> no of subsets from 0 to idx with sum less than or equal to Sum\\n    \\n    int helper(int idx,int sum,vector<int>&nums){\\n        if(idx<0)\\n            return sum>=0;\\n        if(sum<0) return 0;\\n        if(dp[idx][sum]) return dp[idx][sum]-1;\\n        int notake = helper(idx-1,sum,nums);\\n        int take = helper(idx-1,sum-nums[idx],nums);\\n        dp[idx][sum] = 1+(take+notake)%mod;\\n        return dp[idx][sum]-1;\\n    }\\n    \\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        long long sum = 0;\\n        for(auto &it:nums)\\n            sum+=it;\\n        if(sum<2*k) return 0;\\n        int rev = helper(nums.size()-1,k-1,nums);\\n        return (power(2,nums.size())-2*rev+mod)%mod;\\n    }\\n```\n```\\n\\tint mod = 1e9+7;\\n    int dp[1000][1001]={0};\\n    \\n    int power(int a,int b){\\n        long long ans = 1,prod = a;\\n        while(b){\\n            if(b&1)\\n                ans=(ans*prod)%mod;\\n            b = b>>1;\\n            prod = (prod*prod)%mod;\\n        }\\n        return ans;\\n    }\\n    \\n    //dp[idx][Sum] -> no of subsets from 0 to idx with sum less than or equal to Sum\\n    \\n    \\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        long long sum = 0;\\n        for(auto &it:nums)\\n            sum+=it;\\n        if(sum<2*k) return 0;\\n        for(int i = 0;i<k;i++)\\n            dp[0][i] = 1;//empty subset sum\\n        for(int sum = nums[0];sum<k;sum++)\\n            dp[0][sum] += 1;//if the first element has value less than k, than we can include it\\n\\t\\t\\t\\n        for(int i = 1;i<nums.size();i++){\\n            for(int sum = 0;sum<k;sum++){\\n                dp[i][sum] = dp[i-1][sum];\\n                if(sum>=nums[i])\\n                    dp[i][sum] = (dp[i][sum] + dp[i-1][sum-nums[i]])%mod;\\n            }\\n        }\\n        \\n        int rev = dp[nums.size()-1][k-1];\\n        return (power(2,nums.size())-2*rev+mod)%mod;\\n    }\\n```\n```\\n\\tint mod = 1e9+7;\\n    int dp[1001]={0};\\n    \\n    int power(int a,int b){\\n        long long ans = 1,prod = a;\\n        while(b){\\n            if(b&1)\\n                ans=(ans*prod)%mod;\\n            b = b>>1;\\n            prod = (prod*prod)%mod;\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        long long sum = 0;\\n        for(auto &it:nums)\\n            sum+=it;\\n        if(sum<2*k) return 0;\\n        for(int i = 0;i<k;i++)\\n            dp[i] = 1;//empty subset sum\\n        for(int sum = nums[0];sum<k;sum++)\\n            dp[sum] += 1;//if the first element has value less than k, than we can include it\\n\\t\\t\\t\\n        for(int i = 1;i<nums.size();i++)\\n            for(int sum = k-1;sum>=nums[i];sum--)\\n                dp[sum] = (dp[sum]+dp[sum-nums[i]])%mod;\\n        \\n        int rev = dp[k-1];\\n        return (power(2,nums.size())-2*rev+mod)%mod;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2957926,
                "title": "python3-find-count-of-invalid-subsets",
                "content": "```\\nTop-Down\\n\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        # we are calculating number of subsets whose sum < k , then it will be invalid partition\\n        # then return total - invalid i.e 2^n - 2*invalid (2*invalid because invalid subset can be\\n        # 1st group or 2nd group).\\n        n = len(nums)\\n        mod = 1_00_00_00_007\\n        @cache\\n        def dp(ind,currSum):\\n            if ind == n:\\n                return 1\\n            notTake = dp(ind + 1,currSum)\\n            take = dp(ind + 1,currSum + nums[ind]) if currSum + nums[ind] < k else 0\\n            return take + notTake\\n        invalidSubsets = dp(0,0)\\n        validSubsets = 2**n - 2*invalidSubsets\\n        return max(0,validSubsets) % mod\\n\\t\\t\\nBottom-Up\\n\\nn = len(nums)\\n        mod = 1_00_00_00_007\\n        dp = [[0 for i in range(k + 1)] for j in range(n)]\\n        for j in range(k + 1):\\n            if j > nums[0]:\\n                dp[0][j] = 2\\n            else:\\n                dp[0][j] = 1\\n        for i in range(1,n):\\n            for j in range(k + 1):\\n                notTake = dp[i - 1][j]\\n                take = dp[i - 1][j - nums[i]] if j - nums[i] > 0 else 0\\n                dp[i][j] = take + notTake\\n        validSubsets = 2**n - 2*dp[n-1][k]\\n        return max(0,validSubsets) % mod\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nTop-Down\\n\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        # we are calculating number of subsets whose sum < k , then it will be invalid partition\\n        # then return total - invalid i.e 2^n - 2*invalid (2*invalid because invalid subset can be\\n        # 1st group or 2nd group).\\n        n = len(nums)\\n        mod = 1_00_00_00_007\\n        @cache\\n        def dp(ind,currSum):\\n            if ind == n:\\n                return 1\\n            notTake = dp(ind + 1,currSum)\\n            take = dp(ind + 1,currSum + nums[ind]) if currSum + nums[ind] < k else 0\\n            return take + notTake\\n        invalidSubsets = dp(0,0)\\n        validSubsets = 2**n - 2*invalidSubsets\\n        return max(0,validSubsets) % mod\\n\\t\\t\\nBottom-Up\\n\\nn = len(nums)\\n        mod = 1_00_00_00_007\\n        dp = [[0 for i in range(k + 1)] for j in range(n)]\\n        for j in range(k + 1):\\n            if j > nums[0]:\\n                dp[0][j] = 2\\n            else:\\n                dp[0][j] = 1\\n        for i in range(1,n):\\n            for j in range(k + 1):\\n                notTake = dp[i - 1][j]\\n                take = dp[i - 1][j - nums[i]] if j - nums[i] > 0 else 0\\n                dp[i][j] = take + notTake\\n        validSubsets = 2**n - 2*dp[n-1][k]\\n        return max(0,validSubsets) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956407,
                "title": "c-1d-or-2d-dp-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nCount the subsets whose \\'elemental sum\\' is smaller than `k`. Remove the partitions that contain these sets.\\n\\nNotice that there could be 2 cases of *non-great* partition: 1 great set and 1 non-great set, or 2 great sets. We should avoid duplicate when counting them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDynamic Programming. Home my comment is illustrative :-)\\n\\n# Complexity\\n- Time complexity: $$O(nk)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(nk)$$ or $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    typedef long long int LLI;\\n    const LLI MOD = 1e9+7;\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        LLI sum = 0;\\n        for (int num : nums) sum += num;\\n\\n        // Compute the number of sets whose \\'sum of elements\\' == j for j in [0, k).\\n        vector<vector<LLI>> f(n+1, vector<LLI>(k));\\n\\n        // Due to the empty set (\\\\Phi) we have:\\n        //   f(i, 0) = 1\\n        //   f(0, j) = 0 when j>0\\n        for (int i=0; i<=n; i++) f[i][0] = 1;\\n        for (int j=1; j<k; j++) f[0][j] = 0;\\n\\n        // f(i, j) = f(i-1, j)            if nums[i-1] is not in the set\\n        //          +f(i-1, j-nums[i-1])  if nums[i-1]<=j and nums[i-1] is in the set\\n        for (int j=1; j<k; j++) {\\n            for (int i=1; i<=n; i++) {\\n                f[i][j] = f[i-1][j];\\n                if (j >= nums[i-1]) {\\n                    f[i][j] += f[i-1][j-nums[i-1]];\\n                }\\n                f[i][j] %= MOD;\\n            }\\n        }\\n\\n        // ans = 2^n - 2 * \\\\sum(f(n, j_less)) - \\\\sum(f(n, j_greater))\\n        //   2^n: The number of all combinations.\\n        //   j_less: The j that satisfies sum-j>=k. These sets can be either the 1st or the 2nd set. We \\n        //           should count them twice.\\n        //   j_greater: The j that satisfies sum-j<k. These sets and their complement sets are all counted.\\n        //              To avoid duplicate we only count them once.\\n        LLI ans = 1;\\n        for (int i=0; i<n; i++) ans = (2 * ans) % MOD;\\n        for (int j=0; j<k; j++) {\\n            if (sum-j >= k) {\\n                ans -= 2 * f[n][j];\\n            } else {\\n                ans -= f[n][j];\\n            }\\n            ans = (ans % MOD + MOD) % MOD;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\nActually we don\\'t have to create the whole matrix. Since `f(n,_)` only depends on `f(n-1,_)`, we just need to keep one array which takes $O(k)$ space. Remember to reverse the iteration order so that we don\\'t override `f(n-1,_)` before using it. The related code can be changed to:\\n```\\nvector<LLI> f(k, 0);\\nf[0] = 1;\\n\\nfor (int i=1; i<=n; i++) {\\n    for (int j=k-1; j>0 && j>=nums[i-1]; j--) {\\n        f[j] = (f[j] + f[j-nums[i-1]]) % MOD;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long int LLI;\\n    const LLI MOD = 1e9+7;\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        LLI sum = 0;\\n        for (int num : nums) sum += num;\\n\\n        // Compute the number of sets whose \\'sum of elements\\' == j for j in [0, k).\\n        vector<vector<LLI>> f(n+1, vector<LLI>(k));\\n\\n        // Due to the empty set (\\\\Phi) we have:\\n        //   f(i, 0) = 1\\n        //   f(0, j) = 0 when j>0\\n        for (int i=0; i<=n; i++) f[i][0] = 1;\\n        for (int j=1; j<k; j++) f[0][j] = 0;\\n\\n        // f(i, j) = f(i-1, j)            if nums[i-1] is not in the set\\n        //          +f(i-1, j-nums[i-1])  if nums[i-1]<=j and nums[i-1] is in the set\\n        for (int j=1; j<k; j++) {\\n            for (int i=1; i<=n; i++) {\\n                f[i][j] = f[i-1][j];\\n                if (j >= nums[i-1]) {\\n                    f[i][j] += f[i-1][j-nums[i-1]];\\n                }\\n                f[i][j] %= MOD;\\n            }\\n        }\\n\\n        // ans = 2^n - 2 * \\\\sum(f(n, j_less)) - \\\\sum(f(n, j_greater))\\n        //   2^n: The number of all combinations.\\n        //   j_less: The j that satisfies sum-j>=k. These sets can be either the 1st or the 2nd set. We \\n        //           should count them twice.\\n        //   j_greater: The j that satisfies sum-j<k. These sets and their complement sets are all counted.\\n        //              To avoid duplicate we only count them once.\\n        LLI ans = 1;\\n        for (int i=0; i<n; i++) ans = (2 * ans) % MOD;\\n        for (int j=0; j<k; j++) {\\n            if (sum-j >= k) {\\n                ans -= 2 * f[n][j];\\n            } else {\\n                ans -= f[n][j];\\n            }\\n            ans = (ans % MOD + MOD) % MOD;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nvector<LLI> f(k, 0);\\nf[0] = 1;\\n\\nfor (int i=1; i<=n; i++) {\\n    for (int j=k-1; j>0 && j>=nums[i-1]; j--) {\\n        f[j] = (f[j] + f[j-nums[i-1]]) % MOD;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955139,
                "title": "most-general-knapsack-solution",
                "content": "# Intuition\\nAt first i was trying to find all valid pairs i.e., pairs whose sum are in `range(k,max(k,sum(nums)-k)]` but this would give TLE(don\\'t know why please comment down if you know the reason behind it.) then, after that i\\'d gone for removing all invalid pairs from total subsets\\ni.e.,\\n`2**n - (subset with sum <k)*2`\\n\\n# Approach\\nUse Knapsack to find subset sums <k and then remove all those pairs from total subsets possible\\n\\n# Complexity\\n- Time complexity: O(n*k)\\n\\n- Space complexity: O(n*k)\\n\\n# Code\\n```\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        # nums = [i%1000000007 for i in nums]\\n        n = len(nums)\\n        subset =[[0 for i in range(k)] for i in range(n + 1)]\\n\\n        for i in range(n + 1):\\n            subset[i][0] = 1\\n\\n\\n        for i in range(1, k):\\n            subset[0][i]= 0\\n\\n\\n        for i in range(1, n + 1):\\n            for j in range(1, k):\\n                if j < nums[i-1]:\\n                    subset[i][j] = subset[i-1][j]\\n                if j >= nums[i-1]:\\n                    subset[i][j] = (subset[i-1][j] +\\n                                    subset[i - 1][j-nums[i-1]])\\n        \\n        ans = 2**n\\n        for i in range(k):\\n            ans -= subset[n][i]*2\\n\\n        return max(ans,0)%1000000007 \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        # nums = [i%1000000007 for i in nums]\\n        n = len(nums)\\n        subset =[[0 for i in range(k)] for i in range(n + 1)]\\n\\n        for i in range(n + 1):\\n            subset[i][0] = 1\\n\\n\\n        for i in range(1, k):\\n            subset[0][i]= 0\\n\\n\\n        for i in range(1, n + 1):\\n            for j in range(1, k):\\n                if j < nums[i-1]:\\n                    subset[i][j] = subset[i-1][j]\\n                if j >= nums[i-1]:\\n                    subset[i][j] = (subset[i-1][j] +\\n                                    subset[i - 1][j-nums[i-1]])\\n        \\n        ans = 2**n\\n        for i in range(k):\\n            ans -= subset[n][i]*2\\n\\n        return max(ans,0)%1000000007 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953865,
                "title": "classic-knapsack-problem-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen seeing the requirements dividing n items into two group both with size larger or equal than k, it should remind you something from knapsack problem. Instead of solving problem with 2 knapsack problems, we could convert it into one knapsack problem by dividing n items into a group with size less than k, which is an invalid way. Then, how many ways we could divide n items into two groups? (remember that each item could have two options, either being place into group 1 or group 2) so we have pow(2,n) permutations to do that. Then we should subtract the invalid ways, the problem I describle as one knapsack problem. Why we need to multiple 2 with the answer of kanpsack problem, because the group could be placed at 1 or 2.\\n\\nThere are some edge cases to notice. \\n- If the sum of n items is less than 2*k, then we have 0 solution to divide this n items into 2 group with size larger or eaqual to k.\\n- To some strong type languages, should be careful with the overflow problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(nk)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n I know there are a better way to use only O(k). But for easy understnding, I use this classic knapsack solution to place my solution.\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPartitions(int[] nums, int k) {\\n        long MOD = 1000_000_007;\\n        int n = nums.length;\\n        long total = 0, ans = 1;\\n        for (int num:nums) {\\n            total += num;\\n            ans = ans * 2 % MOD;// to avoid overflow\\n        }\\n        if (total < 2*k) return 0;\\n        long[][] dp = new long[n+1][k];\\n        for (int i=0;i<=n;i++) dp[i][0] = 1;\\n        for (int i=1;i<=n;i++) {\\n            for (int j=1;j<k;j++) {\\n                if (j - nums[i-1] < 0) {\\n                    dp[i][j] = dp[i-1][j];\\n                } else {\\n                    dp[i][j] = (dp[i-1][j] + dp[i-1][j-nums[i-1]])%MOD;//to avoid overflow\\n                }\\n            }\\n        }\\n        for (int i=0;i<k;i++) {\\n            ans -= dp[n][i] * 2;// the ans could be negative number\\n        }\\n        return (int)((ans%MOD+ MOD)%MOD);//since the ans could be negative number, so we need to add MOD\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPartitions(int[] nums, int k) {\\n        long MOD = 1000_000_007;\\n        int n = nums.length;\\n        long total = 0, ans = 1;\\n        for (int num:nums) {\\n            total += num;\\n            ans = ans * 2 % MOD;// to avoid overflow\\n        }\\n        if (total < 2*k) return 0;\\n        long[][] dp = new long[n+1][k];\\n        for (int i=0;i<=n;i++) dp[i][0] = 1;\\n        for (int i=1;i<=n;i++) {\\n            for (int j=1;j<k;j++) {\\n                if (j - nums[i-1] < 0) {\\n                    dp[i][j] = dp[i-1][j];\\n                } else {\\n                    dp[i][j] = (dp[i-1][j] + dp[i-1][j-nums[i-1]])%MOD;//to avoid overflow\\n                }\\n            }\\n        }\\n        for (int i=0;i<k;i++) {\\n            ans -= dp[n][i] * 2;// the ans could be negative number\\n        }\\n        return (int)((ans%MOD+ MOD)%MOD);//since the ans could be negative number, so we need to add MOD\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953786,
                "title": "c-dynamic-programming-subset-sum-variation-easy-understanding",
                "content": "**Intuition** : \\n* Here , for finding number of ways such that `sum >=k` , we can solve problem in reverse i.e `total ways - sum < k`.\\n*  for `v =  [ 1,2,3,4] , k = 4`, total ways are` 2^4-2 = 14` (length 0 and length = n is not considered). \\n*  sum = 1 --> [1], [2,3,4] ; [2,3,4], [1], sum = 2 --> [2] , [1,3,4] ;[1,3,4], [2], sum = 3 --> [1,2],[3,4] ; [3,4] , [1,2] ; [1,2,4] , [3] ; [3] , [1,2,4]\\n*  answer is 14 - 2 - 2 - 4 = 6.\\n**Approach** :\\n* We can find number of ways to partition array such that sum is k through subset sum problem.\\n* `Total ways = 2^n - 2` (0 and n length not considered).\\n* We will subtract invalid ways i.e `sum = 1 , 2 ... k-1` from total ways i.e `dp[n][i]` where i = 1 to k-1 and since ordered is important we will subtract `2*dp[n][i]` since for [1,2], [3,4] and [3,4] ,[1,2] are considered as different.\\n\\n**Time : O(n*k)\\nSpace : O(n*k)**\\n\\n```\\nclass Solution {\\npublic:\\n    const static int N = 1e3+10, mod = 1e9+7;\\n    int countPartitions(vector<int>& v, int k) {\\n        int n = v.size();\\n        long long dp[n+1][k+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<k+1;j++){\\n                if(i==0) dp[i][j] = 0;\\n                if(j==0) dp[i][j] = 1;\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<k+1;j++){\\n                if(v[i-1]<=j){\\n                    dp[i][j] = (dp[i-1][j-v[i-1]] + dp[i-1][j])%mod;\\n                }\\n                else dp[i][j] = dp[i-1][j];\\n            }\\n        }\\n        // cout<<dp[n][k]<<endl;\\n        long long sum = 0;\\n        for(auto &ele:v) sum += ele;\\n        if(sum<2*k) return 0;\\n        long long ans = 1;\\n        for(int i=0;i<n;i++){\\n            ans = (ans*2)%mod;\\n        }\\n        ans = (ans-2+mod)%mod;\\n        for(int i=1;i<k;i++){\\n            // cout<<dp[n][i]<<endl;\\n            ans = (ans - (2*dp[n][i])%mod+mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const static int N = 1e3+10, mod = 1e9+7;\\n    int countPartitions(vector<int>& v, int k) {\\n        int n = v.size();\\n        long long dp[n+1][k+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<k+1;j++){\\n                if(i==0) dp[i][j] = 0;\\n                if(j==0) dp[i][j] = 1;\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<k+1;j++){\\n                if(v[i-1]<=j){\\n                    dp[i][j] = (dp[i-1][j-v[i-1]] + dp[i-1][j])%mod;\\n                }\\n                else dp[i][j] = dp[i-1][j];\\n            }\\n        }\\n        // cout<<dp[n][k]<<endl;\\n        long long sum = 0;\\n        for(auto &ele:v) sum += ele;\\n        if(sum<2*k) return 0;\\n        long long ans = 1;\\n        for(int i=0;i<n;i++){\\n            ans = (ans*2)%mod;\\n        }\\n        ans = (ans-2+mod)%mod;\\n        for(int i=1;i<k;i++){\\n            // cout<<dp[n][i]<<endl;\\n            ans = (ans - (2*dp[n][i])%mod+mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2953023,
                "title": "python-concise-knapsack-dp-with-rigorous-proof-the-best",
                "content": "# Intuition\\nDenote $$N=$$ *nums* and $$G \\\\cup \\\\bar G = N$$ a partitioning of $$N$$ ($$G\\\\cap\\\\bar G=\\\\empty$$).\\n\\nThis is a Knapsack-style problem, complicated by the requirement that $$\\\\sum G\\\\geqslant k$$ and $$\\\\sum \\\\bar G\\\\geqslant k$$ must simultaneously hold. Well, at least we don\\'t have to deal with value repetitions, since numbers at different indexes are considered distinct (i.e., $$N, G, \\\\bar G$$ are sequences and not sets).\\n\\nThe problem, however, can be inverted into counting groups satisfying $$\\\\sum G < k$$, since once we ensure that $$\\\\sum N \\\\geqslant 2k$$, it follows that $$\\\\sum \\\\bar G = \\\\sum N - \\\\sum G > k$$. Therefore, counts of $$\\\\sum G < k$$ and $$\\\\sum \\\\bar G < k$$ (which are of course equal) are exclusive to one another and can be simply added to derive the total number of *non*-great partitions of $$N$$.\\n\\nIt follows that the number of great partitions is $$2^{|N|} - 2 \\\\left| \\\\sum G < k \\\\right|$$.\\n\\nThe Best!\\n\\n# Approach\\nThe count $$C(n,k) = \\\\left| \\\\sum G(n) < k \\\\right|$$ for groups $$G(n)$$ that are limited to the first $$\\\\langle x_1,\\\\ldots,x_n\\\\rangle$$ numbers of $$N$$ can be calculated as:\\n$$C(n,k) = \\\\begin{cases}\\n1, & \\\\text{if } n=0\\\\\\\\\\nC(n-1,k), & \\\\text{if } n > 0 \\\\wedge x_n \\\\geqslant k\\\\\\\\\\nC(n-1,k)+C(n-1,k-x_n), & \\\\text{if } n > 0 \\\\wedge x_n < k\\\\\\\\\\n\\\\end{cases}.$$\\n\\nThis recurrency derives from considering adding or not adding $$x_n$$ to $$G(n)$$.\\n\\nSince $$C(n,k)$$ relies only on $$C(n-1,k\\'\\\\leqslant k)$$, we can maintain only last two $$C(n,\\\\cdot)$$ rows during DP aggregation. Moreover, if aggregation is implemented from right to left, a single row suffices.\\n\\n# Complexity\\n- Time complexity: $$O(nk)$$\\n- Space complexity: $$O(k)$$\\n\\n# Code\\n```python\\ndef countPartitions(self, nums: list[int], k: int) -> int:\\n    if sum(nums) < 2*k:\\n        return 0\\n\\n    knap_dp, M = [1]*(k+1), round(1e9+7)\\n    for num in nums:\\n        for grp_sum in range(k, num, -1):\\n            knap_dp[grp_sum] = (knap_dp[grp_sum-num] + knap_dp[grp_sum]) % M\\n\\n    return (pow(2, len(nums), M) - 2*knap_dp[k]) % M\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\ndef countPartitions(self, nums: list[int], k: int) -> int:\\n    if sum(nums) < 2*k:\\n        return 0\\n\\n    knap_dp, M = [1]*(k+1), round(1e9+7)\\n    for num in nums:\\n        for grp_sum in range(k, num, -1):\\n            knap_dp[grp_sum] = (knap_dp[grp_sum-num] + knap_dp[grp_sum]) % M\\n\\n    return (pow(2, len(nums), M) - 2*knap_dp[k]) % M\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2952144,
                "title": "cpp-100-bottom-up-dp-with-time-o-nk-space-o-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is too complex to cover the problem directly. Instead, we consider the complement, i.e. counting partitions not great.\\n\\nIn this case, K<=1000, we just need to count possible partitions with sum up to K-1 (i.e. at most 999).\\n\\nOn the other hand, N <=1000,of course, we can define the data as dp[K][N], 1000000 seems ok to avoid TLE. However, we can further improve the space with bottom up approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThings are not so simple. Totally, we have 2^N ways of partitions. If we know X of them with sum less than K. The answer should be 2^N-X-X (partition can be used by the former and the latter.). Either 2^N or X could be too large to fit in a number (as usual, we use 1e9+7 as upper bound). It is possible that, X+X>=2^N. In this case, we fail for every partition and 0 should be the answer. But we lost such clue because of modulo 1e9+7. Fortunatelly, one of the test case cover this situation.\\n\\nWe need to detect failures. Here, we use a little trick may be different from those would be taught in class for some of us. (The major reason I choose this method is that it is not easy to type with ipad.) We want to answer another question \"For every partition with sum no less than K, what is the lower bound of such sum?\" Suppose we know that LO is the lower bound and SUM is the sum of all numbers. As long as SUM-LO<K, we fail for every partition.\\n\\nFortunately, it is not hard. So far, we didn\\'t mention the definition of DP. We define DP[A][B] as: for nums[0, ..., B],number of partitions with sum equals to A.\\n\\nBegin with B=0, we update DP[A] from A=K-1 to A=0, while considering the value of nums[B]. As you may known, DP[A]+=DP[A-nums[B]].\\n\\nWait, what about the supplemental question? We calculate the sum of nums from 0 to B. If nums[B]>=K, {nums[B]} is a candidadate for LO. Else if SUM>=K, from V=K-nums[B] to V=K-1, we just need to find the first V where dp[v]>0. There is a partition with sum equals to nums[B]+V.\\n\\nSo, we have N steps. For each step, two operations with time complexity O(K) would be conducted. Totally, we have O(NK).\\n\\nThe details can be found in the following codes.\\n\\n# Complexity\\n- Time complexity: O(NK) / 3~6ms with the following C++ code\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(K) / ~8MB with the following C++ code\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nlong M=1e9+7;\\nlong dp[1000]={1};\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int n=nums.size(), lo=INT_MAX;\\n        long tot=1, sum=2;\\n        for(int i=n; i; i>>=1) {\\n            if(1&i)\\n                tot=(tot*sum)%M;\\n            sum=(sum*sum)%M;\\n        }\\n        sum=0;\\n        for(int i=1; i<k; dp[i++]=0) {}\\n        for(int i=0, j, t; i<n; ++i) {\\n            sum+=nums[i];\\n            if(nums[i]>=k) {\\n                lo=min(lo, nums[i]);\\n                continue;\\n            }\\n            if(sum>=k) {\\n                for(j=k-nums[i]; j<k && !dp[j]; ++j) {}\\n                lo=min(lo, j+nums[i]);\\n            }\\n            for(j=k-1, t=j-nums[i]; t>=0; --j, --t) {\\n                dp[j]=(dp[j]+dp[t])%M;\\n            }\\n        }\\n        if(sum-lo<k)\\n            return 0;\\n        sum=0;\\n        for(int i=0; i<k; sum+=dp[i++]<<1) {}\\n        sum%=M;\\n        return tot<sum? tot-sum+M:tot-sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nlong M=1e9+7;\\nlong dp[1000]={1};\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int n=nums.size(), lo=INT_MAX;\\n        long tot=1, sum=2;\\n        for(int i=n; i; i>>=1) {\\n            if(1&i)\\n                tot=(tot*sum)%M;\\n            sum=(sum*sum)%M;\\n        }\\n        sum=0;\\n        for(int i=1; i<k; dp[i++]=0) {}\\n        for(int i=0, j, t; i<n; ++i) {\\n            sum+=nums[i];\\n            if(nums[i]>=k) {\\n                lo=min(lo, nums[i]);\\n                continue;\\n            }\\n            if(sum>=k) {\\n                for(j=k-nums[i]; j<k && !dp[j]; ++j) {}\\n                lo=min(lo, j+nums[i]);\\n            }\\n            for(j=k-1, t=j-nums[i]; t>=0; --j, --t) {\\n                dp[j]=(dp[j]+dp[t])%M;\\n            }\\n        }\\n        if(sum-lo<k)\\n            return 0;\\n        sum=0;\\n        for(int i=0; i<k; sum+=dp[i++]<<1) {}\\n        sum%=M;\\n        return tot<sum? tot-sum+M:tot-sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951770,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn count_partitions(nums: Vec<i32>, k: i32) -> i32 {\\n        fn dfs(dp: &mut Vec<Vec<i64>>, nums: &Vec<i64>, k: i64, i: usize, sum: i64) -> i64 {\\n            if sum >= k || i == nums.len() {\\n                return i64::from(sum > 0 && sum < k);\\n            }\\n            if dp[i][sum as usize] == 0 {\\n                dp[i][sum as usize] =\\n                    (1 + dfs(dp, nums, k, i + 1, sum) + dfs(dp, nums, k, i + 1, sum + nums[i])) % 1_000_000_007;\\n            }\\n            dp[i][sum as usize] - 1\\n        }\\n\\n        fn _count_partitions(nums: Vec<i64>, k: i64) -> i64 {\\n            let mut cnt = vec![0; 1001];\\n            let mut dp = vec![vec![0; 1000]; 1000];\\n            if cnt[2] == 0 {\\n                for i in 2..1001 {\\n                    cnt[i] = 2 * (cnt[i - 1] + 1) % 1_000_000_007;\\n                }\\n            }\\n            if nums.iter().sum::<i64>() < k * 2 {\\n                return 0;\\n            }\\n            (1_000_000_007 + cnt[nums.len()] - 2 * dfs(&mut dp, &nums, k, 0, 0)) % 1_000_000_007\\n        }\\n\\n        _count_partitions(nums.iter().map(|&x| i64::from(x)).collect(), i64::from(k)) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_partitions(nums: Vec<i32>, k: i32) -> i32 {\\n        fn dfs(dp: &mut Vec<Vec<i64>>, nums: &Vec<i64>, k: i64, i: usize, sum: i64) -> i64 {\\n            if sum >= k || i == nums.len() {\\n                return i64::from(sum > 0 && sum < k);\\n            }\\n            if dp[i][sum as usize] == 0 {\\n                dp[i][sum as usize] =\\n                    (1 + dfs(dp, nums, k, i + 1, sum) + dfs(dp, nums, k, i + 1, sum + nums[i])) % 1_000_000_007;\\n            }\\n            dp[i][sum as usize] - 1\\n        }\\n\\n        fn _count_partitions(nums: Vec<i64>, k: i64) -> i64 {\\n            let mut cnt = vec![0; 1001];\\n            let mut dp = vec![vec![0; 1000]; 1000];\\n            if cnt[2] == 0 {\\n                for i in 2..1001 {\\n                    cnt[i] = 2 * (cnt[i - 1] + 1) % 1_000_000_007;\\n                }\\n            }\\n            if nums.iter().sum::<i64>() < k * 2 {\\n                return 0;\\n            }\\n            (1_000_000_007 + cnt[nums.len()] - 2 * dfs(&mut dp, &nums, k, 0, 0)) % 1_000_000_007\\n        }\\n\\n        _count_partitions(nums.iter().map(|&x| i64::from(x)).collect(), i64::from(k)) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2951357,
                "title": "python-top-down-dp",
                "content": "```\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        mod = 10**9+7\\n        n = len(nums)\\n        \\n        @cache\\n        def dp(ci, cs):\\n\\n            if ci == len(nums):\\n                if cs < k:\\n                    return 1\\n                else:\\n                    return 0\\n\\n            if cs > k:\\n                return 0\\n\\n            # take\\n            take = dp(ci + 1, cs + nums[ci])\\n\\n            # notake\\n            notake = dp(ci+1, cs)\\n\\n            return (take+notake) % mod\\n\\n\\n        invalid = dp(0,0) #  Find the total number of subsets in the array with their sums smaller than k \\n        \\n        res = pow(2,n) - invalid*2 # pow(2,n) is all combinations\\n        return max(res,0) % mod\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        mod = 10**9+7\\n        n = len(nums)\\n        \\n        @cache\\n        def dp(ci, cs):\\n\\n            if ci == len(nums):\\n                if cs < k:\\n                    return 1\\n                else:\\n                    return 0\\n\\n            if cs > k:\\n                return 0\\n\\n            # take\\n            take = dp(ci + 1, cs + nums[ci])\\n\\n            # notake\\n            notake = dp(ci+1, cs)\\n\\n            return (take+notake) % mod\\n\\n\\n        invalid = dp(0,0) #  Find the total number of subsets in the array with their sums smaller than k \\n        \\n        res = pow(2,n) - invalid*2 # pow(2,n) is all combinations\\n        return max(res,0) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951189,
                "title": "python-1d-dp-solution",
                "content": "```\\ndef countPartitions(self, nums: List[int], k: int) -> int:\\n\\tif k*2>sum(nums):\\n\\t\\treturn 0\\n\\tdp, nums, mod = [1]+[0]*(k-1), sorted(nums), 10**9+7\\n\\tfor n in nums:\\n\\t\\tif n>=k:\\n\\t\\t\\tbreak\\n\\t\\tfor i in range(k-1, n-1, -1):\\n\\t\\t\\tdp[i] += dp[i-n]\\n\\treturn (pow(2, len(nums), mod)-sum(dp)*2) % mod\\n```",
                "solutionTags": [],
                "code": "```\\ndef countPartitions(self, nums: List[int], k: int) -> int:\\n\\tif k*2>sum(nums):\\n\\t\\treturn 0\\n\\tdp, nums, mod = [1]+[0]*(k-1), sorted(nums), 10**9+7\\n\\tfor n in nums:\\n\\t\\tif n>=k:\\n\\t\\t\\tbreak\\n\\t\\tfor i in range(k-1, n-1, -1):\\n\\t\\t\\tdp[i] += dp[i-n]\\n\\treturn (pow(2, len(nums), mod)-sum(dp)*2) % mod\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2950533,
                "title": "python-prefix-sum-top-down-dp-explained-100",
                "content": "At first, sort nums in reverse order\\ndfs(i, L): the number of great partitions of nums[i:] when the current sum of the first partition is L and the current sum of the second partition is sum(nums[:i]) - L\\nIf the current sums of the both partitions are greater than or equal to k, then the remaining elements can be grouped to any(both) partitions.\\n# Code\\n```\\nfrom functools import cache\\nfrom itertools import accumulate\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        nums.sort(reverse = True)\\n        total = sum(nums)\\n        acc = list(accumulate(nums, initial = 0))\\n        n = len(nums)\\n        MOD = 10**9 + 7\\n        @cache\\n        def dfs(i,L):\\n            if L >= k and acc[i] - L >= k: return pow(2, n - i, MOD)\\n            if i == n: return L >= k and (total - L) >= k\\n            return (dfs(i+1, L+nums[i]) + dfs(i+1, L)) % MOD\\n        return dfs(0,0) % MOD\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import cache\\nfrom itertools import accumulate\\nclass Solution:\\n    def countPartitions(self, nums: List[int], k: int) -> int:\\n        nums.sort(reverse = True)\\n        total = sum(nums)\\n        acc = list(accumulate(nums, initial = 0))\\n        n = len(nums)\\n        MOD = 10**9 + 7\\n        @cache\\n        def dfs(i,L):\\n            if L >= k and acc[i] - L >= k: return pow(2, n - i, MOD)\\n            if i == n: return L >= k and (total - L) >= k\\n            return (dfs(i+1, L+nums[i]) + dfs(i+1, L)) % MOD\\n        return dfs(0,0) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949607,
                "title": "c-explained-dp-solution-well-commented",
                "content": "```\\n/*\\nThe answer would be \\nTotal ways of partitioning - (invalid ways to partition into 2 ordered sets)\\n2**n - 2(ways to partition such that sum of a partion is less than k)\\n\\nWe multiply by 2 as we have to make 2 ordered sets so ordering of sets matter\\n\\nAlso first we would have to handle the base case where sum of elements in the array\\nis less than 2*k we return 0\\nOtherwise our formlula can give wrong answer as both generated partitions would have sum\\nless than k but in our formula we assume that only 1 partition among the two have\\nsum less than k\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        long mod=1000000007, i, j, dp[1000][1001], n, ans, sum, total=0;\\n        n=nums.size();\\n        \\n        // Dp[i][j] -> number of subsets having sum as i where j elements are considered\\n        \\n        for(i=0; i<=n; i++){\\n            dp[0][i]=1;\\n        }\\n        \\n        for(i=1; i<k; i++){\\n            dp[i][0]=0;\\n        }\\n        \\n        for(i=0; i<n; i++){\\n            total=total+nums[i];\\n        }\\n        \\n        if(total < 2*k){\\n            return 0;\\n        }\\n        \\n        // we are going till less than k sum value\\n        for(i=1; i<k; i++){\\n            for(j=1; j<=n; j++){\\n                //condition to not go out of bounds\\n                if(i-nums[j-1] >= 0){\\n                    //              inclusion          exclusion\\n                    dp[i][j] = (dp[i-nums[j-1]][j-1] + dp[i][j-1]) % mod;\\n                }else if(i-nums[j-1] < 0){\\n                    dp[i][j] = dp[i][j-1];\\n                }\\n            }\\n        }\\n        \\n        ans=1;\\n        for(i=1; i<=n; i++){\\n            ans = (ans*2)%mod;\\n        }\\n        \\n        for(i=0; i<k; i++){\\n            ans = (ans-((2*dp[i][n])%mod)+mod)%mod;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nThe answer would be \\nTotal ways of partitioning - (invalid ways to partition into 2 ordered sets)\\n2**n - 2(ways to partition such that sum of a partion is less than k)\\n\\nWe multiply by 2 as we have to make 2 ordered sets so ordering of sets matter\\n\\nAlso first we would have to handle the base case where sum of elements in the array\\nis less than 2*k we return 0\\nOtherwise our formlula can give wrong answer as both generated partitions would have sum\\nless than k but in our formula we assume that only 1 partition among the two have\\nsum less than k\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& nums, int k) {\\n        long mod=1000000007, i, j, dp[1000][1001], n, ans, sum, total=0;\\n        n=nums.size();\\n        \\n        // Dp[i][j] -> number of subsets having sum as i where j elements are considered\\n        \\n        for(i=0; i<=n; i++){\\n            dp[0][i]=1;\\n        }\\n        \\n        for(i=1; i<k; i++){\\n            dp[i][0]=0;\\n        }\\n        \\n        for(i=0; i<n; i++){\\n            total=total+nums[i];\\n        }\\n        \\n        if(total < 2*k){\\n            return 0;\\n        }\\n        \\n        // we are going till less than k sum value\\n        for(i=1; i<k; i++){\\n            for(j=1; j<=n; j++){\\n                //condition to not go out of bounds\\n                if(i-nums[j-1] >= 0){\\n                    //              inclusion          exclusion\\n                    dp[i][j] = (dp[i-nums[j-1]][j-1] + dp[i][j-1]) % mod;\\n                }else if(i-nums[j-1] < 0){\\n                    dp[i][j] = dp[i][j-1];\\n                }\\n            }\\n        }\\n        \\n        ans=1;\\n        for(i=1; i<=n; i++){\\n            ans = (ans*2)%mod;\\n        }\\n        \\n        for(i=0; i<k; i++){\\n            ans = (ans-((2*dp[i][n])%mod)+mod)%mod;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949564,
                "title": "c-knapsnack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& A, int k) {\\n        long sum = 0, mod = 1e9+7, ans = 1, dp[1001]= {[0]=1};\\n        for(auto e : A) {\\n            for(int i = k-e-1; i >= 0; i--) dp[i+e] = (dp[i+e]+dp[i])%mod;\\n            sum += e;\\n            ans = (ans*2)%mod;\\n        }\\n        for(int i = 0; i < k; i++) ans = (ans - (sum-i < k ? dp[i] : 2*dp[i])%mod+mod)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int>& A, int k) {\\n        long sum = 0, mod = 1e9+7, ans = 1, dp[1001]= {[0]=1};\\n        for(auto e : A) {\\n            for(int i = k-e-1; i >= 0; i--) dp[i+e] = (dp[i+e]+dp[i])%mod;\\n            sum += e;\\n            ans = (ans*2)%mod;\\n        }\\n        for(int i = 0; i < k; i++) ans = (ans - (sum-i < k ? dp[i] : 2*dp[i])%mod+mod)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1727979,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Can\\'t find any way to solve this problem.\\nMaybe i am too dull.\\nAnyone has any idea that may help me."
                    },
                    {
                        "username": "charonme",
                        "content": "understanding the 0/1 knapsack problem will help"
                    },
                    {
                        "username": "programmingpathshala",
                        "content": "https://youtu.be/Pg2c1a1UtpQ\\nThis video might help you."
                    },
                    {
                        "username": "Finesse",
                        "content": "I solved the problem \"direct\" way (opposite to what the hints suggest). I used dynamic programming. The DP key:\n- the `nums` start index\n- the sum of the 1st group (but not more than `k`)\n- the sum of the 2nd group (but not more than `k`)\n\nAnd the DP value is the number of ways to get to that state.\n\nAt first glance it seems to be `n*k*k` states which is too much, but for a fixed start index, the group sums are interconnected. So the maximum number of states is `n*k*3`.\n\nIf you implemented it top-down as I described, you'll get a memory limit error. It can be circumvented using a simple trick: put `nums[0]` in the 1st group and multiply the final result by 2 (because every partition has a mirrored version).\n\nYou can reduce the memory consumption even further by implementing a bottom-up version of the DP. In this case the start index part of the key is not needed, because to compute all states with index `i`, you need only the states for index `i - 1`, so the previous indices can be forgotten.\n"
                    }
                ]
            },
            {
                "id": 2047192,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Can\\'t find any way to solve this problem.\\nMaybe i am too dull.\\nAnyone has any idea that may help me."
                    },
                    {
                        "username": "charonme",
                        "content": "understanding the 0/1 knapsack problem will help"
                    },
                    {
                        "username": "programmingpathshala",
                        "content": "https://youtu.be/Pg2c1a1UtpQ\\nThis video might help you."
                    },
                    {
                        "username": "Finesse",
                        "content": "I solved the problem \"direct\" way (opposite to what the hints suggest). I used dynamic programming. The DP key:\n- the `nums` start index\n- the sum of the 1st group (but not more than `k`)\n- the sum of the 2nd group (but not more than `k`)\n\nAnd the DP value is the number of ways to get to that state.\n\nAt first glance it seems to be `n*k*k` states which is too much, but for a fixed start index, the group sums are interconnected. So the maximum number of states is `n*k*3`.\n\nIf you implemented it top-down as I described, you'll get a memory limit error. It can be circumvented using a simple trick: put `nums[0]` in the 1st group and multiply the final result by 2 (because every partition has a mirrored version).\n\nYou can reduce the memory consumption even further by implementing a bottom-up version of the DP. In this case the start index part of the key is not needed, because to compute all states with index `i`, you need only the states for index `i - 1`, so the previous indices can be forgotten.\n"
                    }
                ]
            }
        ]
    }
]