[
    {
        "title": "Numbers With Repeated Digits",
        "question_content": "Given an integer n, return the number of positive integers in the range [1, n] that have at least one repeated digit.\n&nbsp;\nExample 1:\nInput: n = 20\nOutput: 1\nExplanation: The only positive number (<= 20) with at least 1 repeated digit is 11.\nExample 2:\nInput: n = 100\nOutput: 10\nExplanation: The positive numbers (<= 100) with atleast 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.\nExample 3:\nInput: n = 1000\nOutput: 262\n&nbsp;\nConstraints:\n\t1 <= n <= 109",
        "solutions": [
            {
                "id": 3544075,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        vector<int> digits{};\\n        int temp = n + 1;\\n        while (temp > 0) {\\n            digits.emplace_back(temp % 10);\\n            temp /= 10;\\n        }\\n        int result = 0;\\n        int len = digits.size();\\n        int curr = 9;\\n        for (int i = 0; i < len - 1; i++) {\\n            result += curr;\\n            curr *= 9 - i;\\n        }\\n        curr /= 9;\\n        vector<bool> seen(10, false);\\n        for (int i = 0; i < len; i++) {\\n            int d = digits[len - i - 1];\\n\\n            for (int j = i == 0 ? 1 : 0; j < d; j++) if (!seen[j]) result += curr;\\n            curr /= 9 - i;\\n\\n            if (seen[d]) break;\\n            seen[d] = true;\\n        }\\n        return n - result;\\n    }\\n};\\n```\\n\\n```Python3 []\\nfrom math import perm\\n\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        digits = list(map(int, str(n + 1)))\\n        nl = len(digits)\\n        res = sum(9 * perm(9, i) for i in range(nl - 1))\\n        s = set()\\n        for i, x in enumerate(digits):\\n            for y in range(i == 0, x):\\n                if y not in s:\\n                    res += perm(9 - i, nl - i - 1)\\n            if x in s:\\n                break\\n            s.add(x)\\n        return n - res\\n```\\n\\n```Java []\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        ArrayList<Integer> L = new ArrayList<Integer>();\\n        for (int x = N + 1; x > 0; x /= 10)\\n            L.add(0, x % 10);\\n\\n        int res = 0, n = L.size();\\n        for (int i = 1; i < n; ++i)\\n            res += 9 * A(9, i - 1);\\n\\n        HashSet<Integer> seen = new HashSet<>();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i > 0 ? 0 : 1; j < L.get(i); ++j)\\n                if (!seen.contains(j))\\n                    res += A(9 - i, n - i - 1);\\n            if (seen.contains(L.get(i))) break;\\n            seen.add(L.get(i));\\n        }\\n        return N - res;\\n    }\\n    public int A(int m, int n) {\\n        return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        vector<int> digits{};\\n        int temp = n + 1;\\n        while (temp > 0) {\\n            digits.emplace_back(temp % 10);\\n            temp /= 10;\\n        }\\n        int result = 0;\\n        int len = digits.size();\\n        int curr = 9;\\n        for (int i = 0; i < len - 1; i++) {\\n            result += curr;\\n            curr *= 9 - i;\\n        }\\n        curr /= 9;\\n        vector<bool> seen(10, false);\\n        for (int i = 0; i < len; i++) {\\n            int d = digits[len - i - 1];\\n\\n            for (int j = i == 0 ? 1 : 0; j < d; j++) if (!seen[j]) result += curr;\\n            curr /= 9 - i;\\n\\n            if (seen[d]) break;\\n            seen[d] = true;\\n        }\\n        return n - result;\\n    }\\n};\\n```\n```Python3 []\\nfrom math import perm\\n\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        digits = list(map(int, str(n + 1)))\\n        nl = len(digits)\\n        res = sum(9 * perm(9, i) for i in range(nl - 1))\\n        s = set()\\n        for i, x in enumerate(digits):\\n            for y in range(i == 0, x):\\n                if y not in s:\\n                    res += perm(9 - i, nl - i - 1)\\n            if x in s:\\n                break\\n            s.add(x)\\n        return n - res\\n```\n```Java []\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        ArrayList<Integer> L = new ArrayList<Integer>();\\n        for (int x = N + 1; x > 0; x /= 10)\\n            L.add(0, x % 10);\\n\\n        int res = 0, n = L.size();\\n        for (int i = 1; i < n; ++i)\\n            res += 9 * A(9, i - 1);\\n\\n        HashSet<Integer> seen = new HashSet<>();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i > 0 ? 0 : 1; j < L.get(i); ++j)\\n                if (!seen.contains(j))\\n                    res += A(9 - i, n - i - 1);\\n            if (seen.contains(L.get(i))) break;\\n            seen.add(L.get(i));\\n        }\\n        return N - res;\\n    }\\n    public int A(int m, int n) {\\n        return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 256725,
                "title": "java-python-count-the-number-without-repeated-digit",
                "content": "# **Intuition**\\nCount `res` the Number Without Repeated Digit\\nThen the number with repeated digits = N - res\\n\\nSimilar as\\n788. Rotated Digits\\n902. Numbers At Most N Given Digit Set\\n\\n\\n# **Explanation**:\\n\\n1. Transform `N + 1` to arrayList\\n2. Count the number with digits < n\\n3. Count the number with same prefix\\n\\nFor example,\\nif `N = 8765`, `L = [8,7,6,6]`,\\nthe number without repeated digit can the the following format:\\n`XXX`\\n`XX`\\n`X`\\n`1XXX ~ 7XXX`\\n`80XX ~ 86XX`\\n`870X ~ 875X`\\n`8760 ~ 8765`\\n\\n\\n# **Time Complexity**:\\nthe number of permutations `A(m,n)` is `O(1)`\\nWe count digit by digit, so it\\'s `O(logN)`\\n\\n<br>\\n\\n**Java:**\\n```java\\n    public int numDupDigitsAtMostN(int N) {\\n        // Transform N + 1 to arrayList\\n        ArrayList<Integer> L = new ArrayList<Integer>();\\n        for (int x = N + 1; x > 0; x /= 10)\\n            L.add(0, x % 10);\\n\\n        // Count the number with digits < N\\n        int res = 0, n = L.size();\\n        for (int i = 1; i < n; ++i)\\n            res += 9 * A(9, i - 1);\\n\\n        // Count the number with same prefix\\n        HashSet<Integer> seen = new HashSet<>();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i > 0 ? 0 : 1; j < L.get(i); ++j)\\n                if (!seen.contains(j))\\n                    res += A(9 - i, n - i - 1);\\n            if (seen.contains(L.get(i))) break;\\n            seen.add(L.get(i));\\n        }\\n        return N - res;\\n    }\\n\\n\\n    public int A(int m, int n) {\\n        return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n    }\\n```\\n**Python3**\\n```py\\n    def numDupDigitsAtMostN(self, N):\\n        L = list(map(int, str(N + 1)))\\n        n = len(L)\\n        res = sum(9 * perm(9, i) for i in range(n - 1))\\n        s = set()\\n        for i, x in enumerate(L):\\n            for y in range(i == 0, x):\\n                if y not in s:\\n                    res += perm(9 - i, n - i - 1)\\n            if x in s: break\\n            s.add(x)\\n        return N - res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```java\\n    public int numDupDigitsAtMostN(int N) {\\n        // Transform N + 1 to arrayList\\n        ArrayList<Integer> L = new ArrayList<Integer>();\\n        for (int x = N + 1; x > 0; x /= 10)\\n            L.add(0, x % 10);\\n\\n        // Count the number with digits < N\\n        int res = 0, n = L.size();\\n        for (int i = 1; i < n; ++i)\\n            res += 9 * A(9, i - 1);\\n\\n        // Count the number with same prefix\\n        HashSet<Integer> seen = new HashSet<>();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i > 0 ? 0 : 1; j < L.get(i); ++j)\\n                if (!seen.contains(j))\\n                    res += A(9 - i, n - i - 1);\\n            if (seen.contains(L.get(i))) break;\\n            seen.add(L.get(i));\\n        }\\n        return N - res;\\n    }\\n\\n\\n    public int A(int m, int n) {\\n        return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n    }\\n```\n```py\\n    def numDupDigitsAtMostN(self, N):\\n        L = list(map(int, str(N + 1)))\\n        n = len(L)\\n        res = sum(9 * perm(9, i) for i in range(n - 1))\\n        s = set()\\n        for i, x in enumerate(L):\\n            for y in range(i == 0, x):\\n                if y not in s:\\n                    res += perm(9 - i, n - i - 1)\\n            if x in s: break\\n            s.add(x)\\n        return N - res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 258212,
                "title": "share-my-o-logn-c-dp-solution-with-proof-and-explanation",
                "content": "---\\n## 1. Problem\\n\\n---\\nGiven a positive integer ```N```, return the number of positive integers less than or equal to ```N``` that have at least 1 repeated digit.\\n\\n**Example 1:**\\n```\\nInput: 20\\nOutput: 1\\nExplanation: The only positive number (<= 20) with at least 1 repeated digit is 11.\\n```\\n\\n**Example 2:**\\n```\\nInput: 100\\nOutput: 10\\nExplanation: The positive numbers (<= 100) with at least 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.\\n```\\n\\n**Example 3:**\\n```\\nInput: 1000\\nOutput: 262\\n```\\n**Note:**\\n* 1 <= N <= 10^9\\n\\n---\\n## 2. Thinking process\\n\\n---\\n#### 2.1 Analysis\\n\\n---\\nThe problem is to return \\n\\n>#### T(N) = the number of positive integers less than or equal to N that have **at least 1 repeated digit**.\\n\\nSuppose\\n\\n>#### S(N) = the number of positive integers less than or equal to N that have **NO repeated digits**.\\n\\nThe answer can be expressed as\\n\\n>#### T(N) = N - S(N).\\n\\nLater, the calculation of S(N) will be focused on.\\n\\n---\\n#### 2.2 Find the rules\\n\\n---\\n\\n- From **1** to **9**, there are **9** positive integers that have **NO repeated digits**.\\n\\n- From **10** to **99**,\\n  - From **10** to **19**, there are **9** positive integers that have **NO repeated digits**. (Only **11** has repeated digits)\\n  - From **20** to **29**, there are **9** positive integers that have **NO repeated digits**. (Only **22** has repeated digits)\\n  - From **30** to **39**, there are **9** positive integers that have **NO repeated digits**. (Only **33** has repeated digits)\\n  - From **40** to **49**, there are **9** positive integers that have **NO repeated digits**. (Only **44** has repeated digits)\\n  - From **50** to **59**, there are **9** positive integers that have **NO repeated digits**. (Only **55** has repeated digits)\\n  - From **60** to **69**, there are **9** positive integers that have **NO repeated digits**. (Only **66** has repeated digits)\\n  - From **70** to **79**, there are **9** positive integers that have **NO repeated digits**. (Only **77** has repeated digits)\\n  - From **80** to **89**, there are **9** positive integers that have **NO repeated digits**. (Only **88** has repeated digits)\\n  - From **90** to **99**, there are **9** positive integers that have **NO repeated digits**. (Only **99** has repeated digits)\\n  there are **9 \\xD7 9 = 81** positive integers that have **NO repeated digits**.  \\n  \\n- From **100** to **999**,\\n  - From **100** to **199**,\\n    - From **100** to **109**, there are **8** positive integers that have **NO repeated digits**. (**100** and **101** have repeated digits)\\n    - From **110** to **119**, there are **0** positive integers that have **NO repeated digits**. (**ALL numbers** have repeated digits because of the prefix **11**)\\n    - From **120** to **129**, there are **8** positive integers that have **NO repeated digits**. (**121** and **122** have repeated digits)\\n    - From **130** to **139**, there are **8** positive integers that have **NO repeated digits**. (**131** and **133** have repeated digits)\\n    - From **140** to **149**, there are **8** positive integers that have **NO repeated digits**. (**141** and **144** have repeated digits)\\n    - From **150** to **159**, there are **8** positive integers that have **NO repeated digits**. (**151** and **155** have repeated digits)\\n    - From **160** to **169**, there are **8** positive integers that have **NO repeated digits**. (**161** and **166** have repeated digits)\\n    - From **170** to **179**, there are **8** positive integers that have **NO repeated digits**. (**171** and **177** have repeated digits)\\n    - From **180** to **189**, there are **8** positive integers that have **NO repeated digits**. (**181** and **188** have repeated digits)\\n    - From **190** to **199**, there are **8** positive integers that have **NO repeated digits**. (**191** and **199** have repeated digits)\\n    there are **9 \\xD7 8 = 72** positive integers that have **NO repeated digits**.\\n  - .....\\n\\nLet\\'s think about all positive integers **from 100 to 199**.\\n \\nThey can be generated by \\n\\n>#### adding a new digit from **0** to **9** to the end of all positive integers from **10** to **19**.\\nIn order to generate a new positive integer that has **NO** repeated digits,\\n- To **10**: **10 has NO repeated digits**. There are **8 choices (0 and 1 can NOT be chosen)**.\\n- To **11**: **11 has repeated digits**. There are **0 choices (0 to 9 can NOT be chosen)**.\\n- To **12**: **12 has NO repeated digits**. There are **8 choices (1 and 2 can NOT be chosen)**.\\n- To **13**: **13 has NO repeated digits**. There are **8 choices (1 and 3 can NOT be chosen)**.\\n- To **14**: **14 has NO repeated digits**. There are  **8 choices (1 and 4 can NOT be chosen)**.\\n- To **15**: **15 has NO repeated digits**. There are  **8 choices (1 and 5 can NOT be chosen)**.\\n- To **16**: **16 has NO repeated digits**. There are  **8 choices (1 and 6 can NOT be chosen)**.\\n- To **17**: **17 has NO repeated digits**. There are  **8 choices (1 and 7 can NOT be chosen)**.\\n- To **18**: **18 has NO repeated digits**. There are  **8 choices (1 and 8 can NOT be chosen)**.\\n- To **19**: **19 has NO repeated digits**. There are  **8 choices (1 and 9 can NOT be chosen)**.\\n\\nAre there rules?\\n\\n---\\n>#### **Rule A:** \\n>#### **A k-digit positive integer with NO repeated digits can ONLY be generated from (k - 1)-digit positive integers with NO repeated digits (k > 1).**\\n\\nProof:\\n\\nIf a (k - 1)-digit positive integer has repeated digits (e.g. **11**), \\nafter adding a digit (**0** to **9**) to its end, the generated k-digit integer (e.g. 110, 111, ..., 119) **STILL has repeated digits**.\\nThat\\'s to say, a k-digit positive integer with **NO** repeated digits can **ONLY** be generated from (k - 1)-digit positive integers with **NO** repeated digits.\\n\\n---\\n\\n>#### **Rule B:** \\n>#### **To generate a k-digit positive integer with NO repeated digits,** \\n>#### **there are (10 - k + 1) digits that can be added to (k - 1)-digit positive integers with NO repeated digits (k > 1).**\\n\\nProof:\\n\\nA (k - 1)-digit positive integer **with NO repeated digits** has **k - 1 distinct digits**.\\nWhen generating a k-digit positive integer **with NO repeated digits** from it, \\nsince **k - 1** digits in **0** to **9** have been **used**, there are **10 - k + 1** choices for the digit to be added.\\n\\n\\n---\\n#### 2.3 Recursion formula\\n\\n---\\nDefinition:\\n\\n>#### **f(i, j, k): The number of i-digit positive integers with NO repeated digits in the interval [j, k]. (i > 0, j \\u2264 k, j and k are i-digit positive integers).**\\n\\n\\nBased on the **Rule A and Rule B in Section 2.2**, the recursion formula is\\n\\n>#### **f(i, j, k) = k - j + 1. i = 1.**\\n>#### **f(i + 1, 10j, 10k + 9) = f(i, j, k) \\xD7 (10 - i). others.**\\n\\n---\\n#### 2.4 Normal case analysis\\n\\n\\n---\\n\\nIn order to illustrate the usage of the recursion formula in Section 2.3, we take a normal case for calculation.\\n\\nIf **N = 26334**,\\n\\nFrom **Section 2.3**,\\n \\n- From **1** to **9**, f(1, 1, 9) = 9.\\n- From **10** to **99**, f(2, 10, 99) = f(1, 1, 9) \\xD7 (10 - 1) = 9 \\xD7 9 = 81.\\n- From **100** to **999**, f(3, 100, 999) = f(2, 10, 99) \\xD7 (10 - 2) = 81 \\xD7 8 = 648.\\n- From **1000** to **9999**, f(4, 1000, 9999) = f(3, 100, 999) \\xD7 (10 - 3) = 648 \\xD7 7 = 4536.\\n\\nIf all values are added together, the sum is\\n\\n>#### **S(9999) = f(1, 1, 9) + f(2, 10, 99) + f(3, 100, 999) + f(4, 1000, 9999) = 9 + 81 + 648 + 4536 = 5274.**\\n\\nNow the number of positive integers **with NO repeated digits less than or equal to 9999** has been calculated, which is the **first part of the whole result**.\\n\\n\\n---\\nHow about the rest?\\n\\nThe rest part is the number of positive integers **with NO repeated digits in interval [10000, 26334]**, which is\\n\\n>#### **P = f(5, 10000, 26334)**.\\n\\nHow can the recursion formula be applied here?\\n\\n---\\nSince our target is to **calculate f(5, 10000, 26334)**, the **calculation series** is\\n\\n>#### **f(1, 1, 2), f(2, 10, 26), f(3, 100, 263), f(4, 1000, 2633), f(5, 10000, 26334).**\\n\\n\\n- From **1** to **2**, **f(1, 1, 2) = 2**.\\n\\n\\n- From **10** to **29**, by applying the recursion formula, **f(2, 10, 29) = f(1, 1, 2) \\xD7 (10 - 1) = 2 \\xD7 9 = 18**.\\n\\n  - From **27 to 29**, there are **3** positive integers **with NO repeated digits**, which means **f(2, 27, 29) = 3**.   \\n\\n  - **f(2, 10, 26) = f(2, 10, 29) - f(2, 27, 29) = 18 - 3 = 15**.\\n  \\n\\n- From **100** to **269**, by applying the recursion formula, **f(3, 100, 269) = f(2, 10, 26) \\xD7 (10 - 2) = 15 \\xD7 8 = 120**.\\n\\n  - From **264 to 269**, there are **5** positive integers **with NO repeated digits** (**except 266**), which means **f(3, 264, 269) = 5**.\\n  \\n  - **f(3, 100, 263) = f(3, 100, 269) - f(3, 264, 269) = 120 - 5 = 115**.\\n  \\n  \\n- From **1000** to **2639**, by applying the recursion formula, **f(4, 1000, 2639) = f(3, 100, 263) \\xD7 (10 - 3) = 115 \\xD7 7 = 805**.\\n\\n  - From **2634 to 2639**, there are **5** positive integers **with NO repeated digits** (**except 2636**), which means **f(4, 2634, 2639) = 5**.\\n  \\n  - **f(4, 1000, 2633) = f(4, 1000, 2639) - f(4, 2634, 2639) = 805 - 5 = 800**. \\n\\n  \\n- From **10000** to **26339**, by applying the recursion formula, **f(4, 10000, 26339) = f(4, 1000, 2633) \\xD7 (10 - 4) = 800 \\xD7 6 = 4800**.\\n\\n  - From **26335 to 26339**, there are **NO** positive integers **with NO repeated digits** (**due to the prefix \"2633\"**), which means **f(5, 26335, 26339) = 0**.\\n  \\n  - **f(5, 10000, 26334) = f(4, 10000, 26339) - f(5, 26335, 26339) = 4800 - 0 = 4800**.\\n\\nThis is the **second part of the whole result**.\\n\\n---\\nThen\\n\\n>#### **S(26334) = S(9999) + f(5, 10000, 26334) = 5274 + 4800 = 10074.**\\n\\n\\nThe final answer is\\n\\n>#### **T(26334) = 26334 - S(26334) = 26334 - 10074 = 16260.**\\n\\n---\\n#### 2.4 Algorithm\\n\\n\\n---\\n**Special case**:\\n- If N < 10, return 0.\\n\\n---\\n**Get digits**:\\n- Initialization:\\n\\n  - Set k = 0. i = N.\\n\\n- Loop: while i > 0, \\n  \\n  - Set k = k + 1. (Now, k is the digit length of N).\\n\\n  - Set i = i / 10. \\n  \\n- Initialization: \\n\\n  - Set j = N.\\n\\n  - Array digit with size = k. (saving all digits in N)\\n  \\n- Loop: iterate i from 0 to k - 1\\n\\n  - Set digit[k - 1 - i] = j mod 10.\\n  \\n  - Set j = j / 10.\\n\\n---\\n**Get first part**:\\n\\n- Initialization: \\n\\n  - Array noDupBase with size = k - 1. \\n  \\n  - Set noDupBaseSum = 0. (calculate first part)\\n\\n- Loop: iterate i from 0 to k - 2.\\n\\n  - If i = 0, noDupBase[i] = 9. Calculate f(1, 1, 9).\\n  \\n  - Else, noDupBase[i] = noDupBase[i - 1] \\xD7 (10 - i). Calculate f(i, 10^(i - 1), 10^i - 1).\\n  \\n  - Set noDupBaseSum = noDupBaseSum + noDupBase[i].\\n\\n---\\n**Get second part**:\\n\\n- Initialization: \\n\\n  - Set boolean value duplicate = false. (prefix duplicate) \\n  \\n  - Array count with size = 10.(record the digits\\' count in prefix). \\n  \\n  - Array noDupRes with size = k. (calculate second part)\\n  \\n- Loop: iterate i from 0 to k - 1.\\n\\n  - If i = 0, noDupBase[i] = 9. Calculate f(1, 1, 9).\\n  \\n  - Else, noDupBase[i] = noDupBase[i - 1] \\xD7 (10 - i).\\n  \\n  - If NOT duplicate\\n  \\n    - Set diff = 0.\\n\\t\\n\\t- Loop: iterate j from digit[i] + 1 to 9\\n\\t\\n\\t  - If count[j] = 0, Set diff = diff + 1.\\n\\t  \\n\\t- Set noDupRes[i] = noDupRes[i] - diff.\\n\\t\\n\\t- Set count[digit[i]] = count[digit[i]] + 1.\\n\\t\\n\\t- If count[digit[i]] > 1, Set duplicate = true.\\n\\n---\\n**Get final answer**:\\n\\t\\n- return N - (noDupBaseSum + noDupRes[k - 1]).\\n\\n\\n---\\n## 4. Complexity Analysis\\n\\n---\\n\\n#### 4.1 Time complexity\\n\\n---\\n\\n>#### The time complexity is **O(logN)**.\\n\\n---\\n\\n#### 4.2 Space complexity\\n\\n---\\n\\n>#### The space complexity is **O(logN)**.\\n\\n---\\n## 5. Code\\n\\n---\\n```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        if(N < 10) return 0;\\n        int k = 0;\\n        for(int i = N; i > 0; i /= 10) k++;\\n        int digit[k] = {0};\\n        for(int i = 0, j = N; i < k; i++, j /= 10) digit[k - 1 - i] = j % 10;\\n        \\n        int noDupBaseSum = 0;\\n        int noDupBase[k - 1] = {0};\\n        for(int i = 0; i < k - 1; i++)\\n        {\\n            noDupBase[i] = i == 0 ? 9 : noDupBase[i - 1] * (10 - i);\\n            noDupBaseSum += noDupBase[i];\\n        }\\n        \\n        int count[10] = {0};\\n        int noDupRes[k] = {0};\\n        bool duplicate = false;\\n        for(int i = 0; i < k; i++)\\n        {\\n            noDupRes[i] = i == 0 ? 9 : noDupRes[i - 1] * (10 - i);\\n            if(!duplicate)\\n            {\\n                int diff = 0;\\n                for(int j = digit[i] + 1; j < 10; j++) diff += count[j] == 0;\\n                noDupRes[i] -= diff;\\n                count[digit[i]]++;\\n                if(count[digit[i]] > 1) duplicate = true;\\n            }\\n        }\\n        return N - (noDupBaseSum + noDupRes[k - 1]);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```N```\n```N```\n```\\nInput: 20\\nOutput: 1\\nExplanation: The only positive number (<= 20) with at least 1 repeated digit is 11.\\n```\n```\\nInput: 100\\nOutput: 10\\nExplanation: The positive numbers (<= 100) with at least 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.\\n```\n```\\nInput: 1000\\nOutput: 262\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256866,
                "title": "python-o-logn-solution-with-clear-explanation",
                "content": "The number of non-repeated digits can be easily calculated with permutaiton. We only need to exclude all the non-repeated digits to get the answer.\\n\\nLet\\'s first consider about the cases where N=10^k\\n**N=10**\\nthe free digits are marked as `*`, so we only need to consider about `*` and `1*`\\n* `*`: obviously all 1-digit numbers are non-repeated, so non-repeated number = 9\\n* `1*`: we only need to consider about `1* <= 10`, so non-repeated number = 1\\n\\nThus, the result for N=10 is:\\n`N - #non_repeat(*) - #non_repeat(1*) = 10 - 9 - 1 = 0`\\n\\n**N=100**\\nthe free digits are marked as `*`, so we only need to consider about `*`, `**`, and `1**`\\n* `*`: obviously all 1-digit numbers are non-repeated, so non-repeated number = 9\\n* `**`: this can be calculated with permutation: leading digit has 9 options(1-9) and the last 1 digit has `10-1` options, thus the total permuation is `9 * permutation(9, 1)=81`. i.e: non-repeated number = 81\\n* `1**`: we only need to consider about `1**<=100`, so non-repeated number =0\\n\\nThus, the result for N=100 is:\\n`N - #non_repeat(*) - #non_repeat(**) - #non_repeat(1**) = 100 - 9 - 81 = 10`\\n\\n**N=1000**\\n`#non_repeat(***) = 9 * permutation(9, 2) = 9 * 9 * 8 = 648`\\nsimilarly, we can get:\\n`N - #non_repeat(*) - #non_repeat(**) - #non_repeat(***) - #non_repeat(1***) = 1000 - 9 - 81 - 648 = 282`\\n\\nNow, let\\'s consider a more general case:\\n**N=12345**\\nactually, we can get the count of non-repeated numbers  by counting all non-repeated numbers in following patterns:\\n\\n```\\n    *\\n   **\\n  ***\\n ****\\n10***\\n11*** (prefix repeated, skip)\\n120**\\n121** (prefix repeated, skip)\\n122** (prefix repeated, skip)\\n1230*\\n1231* (prefix repeated, skip)\\n1232* (prefix repeated, skip)\\n1233* (prefix repeated, skip)\\n12340\\n12341 (prefix repeated, skip)\\n12342\\n12343\\n12344 (prefix repeated, skip)\\n12345\\n```\\n\\nand use N to minus the count we will get the answer.\\n\\nReference implementation:\\n```\\n# given number n, see whether n has repeated number\\ndef has_repeated(n):\\n    str_n = str(n)\\n    return len(set(str_n)) != len(str_n)\\n\\ndef permutation(n, k):\\n    prod = 1\\n    for i in range(k):\\n        prod *= (n-i)\\n    return prod\\n\\n# calculate number of non-repeated n-digit numbers\\n# note: the n-digit number can\\'t start with 0\\n# i.e: n_digit_no_repeat(2) calculates the non-repeated\\n#   numbers in range [10, 99] (inclusive)\\ndef n_digit_no_repeat(n):\\n    if n == 1:\\n        return 9\\n    else:\\n        return  9 * permutation(9, n-1)\\n\\nclass Solution(object):\\n    def numDupDigitsAtMostN(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"        \\n        N_str = str(N)\\n        n_digit = len(N_str)\\n        digits = map(int, N_str)\\n        result = N - 1\\n        prefix = 0\\n        for i in range(1, n_digit):\\n            result -= n_digit_no_repeat(i)\\n        for i in range(n_digit):\\n            # when we fix the most significant digit, it \\n            # can\\'t be zero\\n            start = 0 if i else 1\\n            for j in range(start, digits[i]):\\n                if has_repeated(prefix * 10 + j):\\n                    continue\\n                if i != n_digit-1:\\n                    result -= permutation(10-i-1, n_digit-1-i)\\n                else:\\n                    # optmized from `result -= has_repeated(prefix*10+j)`\\n                    result -= 1\\n            prefix = prefix*10 + digits[i]\\n        return result + has_repeated(N)\\n```",
                "solutionTags": [],
                "code": "```\\n    *\\n   **\\n  ***\\n ****\\n10***\\n11*** (prefix repeated, skip)\\n120**\\n121** (prefix repeated, skip)\\n122** (prefix repeated, skip)\\n1230*\\n1231* (prefix repeated, skip)\\n1232* (prefix repeated, skip)\\n1233* (prefix repeated, skip)\\n12340\\n12341 (prefix repeated, skip)\\n12342\\n12343\\n12344 (prefix repeated, skip)\\n12345\\n```\n```\\n# given number n, see whether n has repeated number\\ndef has_repeated(n):\\n    str_n = str(n)\\n    return len(set(str_n)) != len(str_n)\\n\\ndef permutation(n, k):\\n    prod = 1\\n    for i in range(k):\\n        prod *= (n-i)\\n    return prod\\n\\n# calculate number of non-repeated n-digit numbers\\n# note: the n-digit number can\\'t start with 0\\n# i.e: n_digit_no_repeat(2) calculates the non-repeated\\n#   numbers in range [10, 99] (inclusive)\\ndef n_digit_no_repeat(n):\\n    if n == 1:\\n        return 9\\n    else:\\n        return  9 * permutation(9, n-1)\\n\\nclass Solution(object):\\n    def numDupDigitsAtMostN(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"        \\n        N_str = str(N)\\n        n_digit = len(N_str)\\n        digits = map(int, N_str)\\n        result = N - 1\\n        prefix = 0\\n        for i in range(1, n_digit):\\n            result -= n_digit_no_repeat(i)\\n        for i in range(n_digit):\\n            # when we fix the most significant digit, it \\n            # can\\'t be zero\\n            start = 0 if i else 1\\n            for j in range(start, digits[i]):\\n                if has_repeated(prefix * 10 + j):\\n                    continue\\n                if i != n_digit-1:\\n                    result -= permutation(10-i-1, n_digit-1-i)\\n                else:\\n                    # optmized from `result -= has_repeated(prefix*10+j)`\\n                    result -= 1\\n            prefix = prefix*10 + digits[i]\\n        return result + has_repeated(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 256995,
                "title": "screencast-of-leetcode-weekly-contest-128",
                "content": "https://www.youtube.com/watch?v=yXKBREQbBOg\\n\\nenjoy :)",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=yXKBREQbBOg\\n\\nenjoy :)",
                "codeTag": "Unknown"
            },
            {
                "id": 540044,
                "title": "c-digit-dp-solution",
                "content": "\"\"\"\\n\\n    //dp[pos][tight][start][rep][mask];\\n    int dp[10][2][2][2][1<<10];\\n    vector<int>num;\\n    int solve(int pos,int tight,int start,int rep,int mask)\\n    {\\n        if(pos == num.size())\\n        {\\n            return rep;\\n        }\\n        int &ans= dp[pos][tight][start][rep][mask];\\n        if(ans!=-1)return ans;\\n        \\n        int k = num[pos];\\n        if(tight)k=9;\\n        int res=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            int ns = start||i>0;//number started yet or not\\n            int nt = tight||i<k;//tight for next number\\n            if(ns){\\n                res+=solve(pos+1,nt,ns,rep||(mask&(1<<i)),mask|1<<i);\\n            }\\n            else{\\n                res+=solve(pos+1,nt,0,rep,mask);\\n            }\\n        \\n        }\\n        ans= res;\\n        return res;\\n    }\\n    int numDupDigitsAtMostN(int N) {\\n        while(N){\\n            num.push_back(N%10);\\n            N/=10;\\n        }\\n        reverse(num.begin(),num.end());\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,0,0,0);\\n    }\\n}\\n\"\"\"",
                "solutionTags": [],
                "code": "\"\"\"\\n\\n    //dp[pos][tight][start][rep][mask];\\n    int dp[10][2][2][2][1<<10];\\n    vector<int>num;\\n    int solve(int pos,int tight,int start,int rep,int mask)\\n    {\\n        if(pos == num.size())\\n        {\\n            return rep;\\n        }\\n        int &ans= dp[pos][tight][start][rep][mask];\\n        if(ans!=-1)return ans;\\n        \\n        int k = num[pos];\\n        if(tight)k=9;\\n        int res=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            int ns = start||i>0;//number started yet or not\\n            int nt = tight||i<k;//tight for next number\\n            if(ns){\\n                res+=solve(pos+1,nt,ns,rep||(mask&(1<<i)),mask|1<<i);\\n            }\\n            else{\\n                res+=solve(pos+1,nt,0,rep,mask);\\n            }\\n        \\n        }\\n        ans= res;\\n        return res;\\n    }\\n    int numDupDigitsAtMostN(int N) {\\n        while(N){\\n            num.push_back(N%10);\\n            N/=10;\\n        }\\n        reverse(num.begin(),num.end());\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,0,0,0);\\n    }\\n}\\n\"\"\"",
                "codeTag": "Unknown"
            },
            {
                "id": 1228724,
                "title": "java-clean-solution-with-detailed-explanation",
                "content": "The key to solve this problem is cleverly enumerate all numbers < n without repeated digits. One of the ways is as follow: \\n\\n**Step 1 : count numbers with length smaller than n:**\\n```\\n// return count of numbers with d digits and no repeated digits\\nprivate int totalNoRepeat(int d) {\\n\\tint res = 9;                         // 0-th digit has 9 choices (1, ..., 9)\\n\\t\\n\\t/* 1-st digit has 9 choices         <==>  (0, ..., 9) except 0-th digit\\n\\t   2-st digit has 8 choices         <==>  (0, ..., 9) except 0-th & 1-st digit\\n\\t                              ...\\n\\t   i-th digit has (10- i) choices   <==>  (0, ..., 9) except 0-th & ...&  (i-1)-th digit      */\\n\\t\\n\\tfor (int i = 1; i < d; i++) {\\n\\t\\tres *= (10 - i);                 \\n\\t} \\n\\treturn res;\\n}\\n```\\n**Step 2 : count numbers with length equals to n:**\\n```\\nCase 1 :  n = 3 4 6 5     \\n\\tpivot index i = 0 should < 3                                                <==> {1, 2} \\n\\t\\t\\t\\t\\t1 X X X - 2 X X X    ==>  2 * 9 * 8 * 7\\n    pivot index i = 1 should < 4  and not take values of previous indices       <==> {0, 1, 2} \\n\\t\\t\\t\\t\\t3 0 X X - 3 3 X X    ==>  1 * 3 * 8 * 7 \\n\\tpivot index i = 2 should < 6  and not take values of previous indices       <==> {0, 1, 2, 5} \\n\\t\\t\\t\\t\\t3 4 0 X - 3 4 5 X    ==>  1 * 1 * 4 * 7\\n    pivot index i = 3 should < 5  and not take values of previous indices       <==> {0, 1, 2} \\n\\t\\t\\t\\t\\t3 4 6 0 - 3 4 6 5    ==>  1 * 1 * 1 * 3\\n\\nCase 2 :  n = 3 3 5 3\\n\\tpivot index i = 0 should < 3                                                <==> {1, 2} \\n\\t\\t\\t\\t\\t1 X X X - 2 X X X    ==>  2 * 9 * 8 * 7\\n\\tpivot index i = 1 should < 3  and not take values of previous indices       <==> {0, 1, 2} \\n\\t\\t\\t\\t\\t3 0 X X - 3 2 X X    ==>  1 * 3 * 8 * 7\\n\\tpivot index i = 2  and after should not be consider\\n\\t\\t\\t\\t\\t3 3 X X              ==>  0  the number will contain repeated digits\\n```\\nFrom these two examples, we can see the pattern of choosing digits: \\n```\\n// i := pivot index       \\n// d := i-th digit in the original number n\\n\\ni = 0     <==>  choose from {1, 2, ..., d-1};  After the pivot index i = 0: \\n\\t// 1-st digit has 9 choices         <==>  (0, ..., 9) except  {0-th digit}\\n\\t// 2-nd digit has 8 choices         <==>  (0, ..., 9) except  {0-th, 1-st digit}\\n\\t//                 ...\\n\\ni = 1     <==>  choose from {0, 1, ... , d-1} - {0-th digit};  After the pivot index i = 1: \\n\\t// 2-nd digit has 8 choices         <==>  (0, ..., 9) except  {0-th, 1-st digit}\\n\\t// 3-rd digit has 7 choices         <==>  (0, ..., 9) except  {0-th, 1-st, 2-nd digit}\\n\\t//                 ...\\n\\nThus for j-th digit after the pivot index i,  \\n\\t// j-th digit has (10- j) choices   <==>  (0, ..., 9) except 0-th & ...&  (j-1)-th digit      \\n```\\n\\n**Final solution:** \\n```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int n) {\\n        String str = String.valueOf(n);\\n        int len = str.length();\\n        \\n        // all number with no repeat and length < len\\n        int unique = 0;\\n        for (int i = 1; i < len; i++) {\\n            unique += totalNoRepeat(i);\\n        }\\n        \\n\\t\\t// all number with no repeat and length == len\\n        Set<Integer> set = new HashSet<>();\\n        int i = 0;\\n        for (i = 0; i < len; i++) {\\n            int d = str.charAt(i) - \\'0\\';\\n            \\n            int temp = pivotChoice(set, d, i == 0);\\n            for (int j = i+1; j < len; j++) {\\n                temp *= (10 - j);\\n            }\\n            \\n            unique += temp;\\n            if (!set.add(d)) break;       // no need to continue after seeing repeated digits\\n        }\\n        \\n        if (i == len) unique++;      // the number n itself\\n        \\n        return n - unique;\\n    }\\n    \\n    private int totalNoRepeat(int d) {\\n        int res = 9;\\n        for (int i = 1; i < d; i++) {\\n            res *= (10 - i);\\n        }\\n        return res;\\n    }\\n    \\n    private int pivotChoice(Set<Integer> set, int d, boolean first) {\\n        int res = 0;\\n        int i = (first ? 1 : 0);\\n        \\n        while (i < d) {\\n            if (!set.contains(i++)) res++;\\n        }\\n        \\n        return res;\\n    } \\n    \\n}\\n```\\n\\nThe main function can also be written as following. Here we consider the count of numbers strictly less than (n+1):\\n\\n```\\npublic int numDupDigitsAtMostN(int n) {\\n\\tString str = String.valueOf(n+1);\\n\\tint len = str.length();\\n\\t\\n\\tint unique = 0;\\n\\tfor (int i = 1; i < len; i++) {\\n\\t\\tunique += totalNoRepeat(i);\\n\\t}\\n\\n\\tSet<Integer> set = new HashSet<>();\\n\\tint i = 0;\\n\\tfor (i = 0; i < len; i++) {\\n\\t\\tint d = str.charAt(i) - \\'0\\';\\n\\n\\t\\tint temp = pivotChoice(set, d, i == 0);\\n\\t\\tfor (int j = i+1; j < len; j++) {\\n\\t\\t\\ttemp *= (10 - j);\\n\\t\\t}\\n\\n\\t\\tunique += temp;\\n\\t\\tif (!set.add(d)) break;      \\n\\t}\\n\\treturn n - unique;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// return count of numbers with d digits and no repeated digits\\nprivate int totalNoRepeat(int d) {\\n\\tint res = 9;                         // 0-th digit has 9 choices (1, ..., 9)\\n\\t\\n\\t/* 1-st digit has 9 choices         <==>  (0, ..., 9) except 0-th digit\\n\\t   2-st digit has 8 choices         <==>  (0, ..., 9) except 0-th & 1-st digit\\n\\t                              ...\\n\\t   i-th digit has (10- i) choices   <==>  (0, ..., 9) except 0-th & ...&  (i-1)-th digit      */\\n\\t\\n\\tfor (int i = 1; i < d; i++) {\\n\\t\\tres *= (10 - i);                 \\n\\t} \\n\\treturn res;\\n}\\n```\n```\\nCase 1 :  n = 3 4 6 5     \\n\\tpivot index i = 0 should < 3                                                <==> {1, 2} \\n\\t\\t\\t\\t\\t1 X X X - 2 X X X    ==>  2 * 9 * 8 * 7\\n    pivot index i = 1 should < 4  and not take values of previous indices       <==> {0, 1, 2} \\n\\t\\t\\t\\t\\t3 0 X X - 3 3 X X    ==>  1 * 3 * 8 * 7 \\n\\tpivot index i = 2 should < 6  and not take values of previous indices       <==> {0, 1, 2, 5} \\n\\t\\t\\t\\t\\t3 4 0 X - 3 4 5 X    ==>  1 * 1 * 4 * 7\\n    pivot index i = 3 should < 5  and not take values of previous indices       <==> {0, 1, 2} \\n\\t\\t\\t\\t\\t3 4 6 0 - 3 4 6 5    ==>  1 * 1 * 1 * 3\\n\\nCase 2 :  n = 3 3 5 3\\n\\tpivot index i = 0 should < 3                                                <==> {1, 2} \\n\\t\\t\\t\\t\\t1 X X X - 2 X X X    ==>  2 * 9 * 8 * 7\\n\\tpivot index i = 1 should < 3  and not take values of previous indices       <==> {0, 1, 2} \\n\\t\\t\\t\\t\\t3 0 X X - 3 2 X X    ==>  1 * 3 * 8 * 7\\n\\tpivot index i = 2  and after should not be consider\\n\\t\\t\\t\\t\\t3 3 X X              ==>  0  the number will contain repeated digits\\n```\n```\\n// i := pivot index       \\n// d := i-th digit in the original number n\\n\\ni = 0     <==>  choose from {1, 2, ..., d-1};  After the pivot index i = 0: \\n\\t// 1-st digit has 9 choices         <==>  (0, ..., 9) except  {0-th digit}\\n\\t// 2-nd digit has 8 choices         <==>  (0, ..., 9) except  {0-th, 1-st digit}\\n\\t//                 ...\\n\\ni = 1     <==>  choose from {0, 1, ... , d-1} - {0-th digit};  After the pivot index i = 1: \\n\\t// 2-nd digit has 8 choices         <==>  (0, ..., 9) except  {0-th, 1-st digit}\\n\\t// 3-rd digit has 7 choices         <==>  (0, ..., 9) except  {0-th, 1-st, 2-nd digit}\\n\\t//                 ...\\n\\nThus for j-th digit after the pivot index i,  \\n\\t// j-th digit has (10- j) choices   <==>  (0, ..., 9) except 0-th & ...&  (j-1)-th digit      \\n```\n```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int n) {\\n        String str = String.valueOf(n);\\n        int len = str.length();\\n        \\n        // all number with no repeat and length < len\\n        int unique = 0;\\n        for (int i = 1; i < len; i++) {\\n            unique += totalNoRepeat(i);\\n        }\\n        \\n\\t\\t// all number with no repeat and length == len\\n        Set<Integer> set = new HashSet<>();\\n        int i = 0;\\n        for (i = 0; i < len; i++) {\\n            int d = str.charAt(i) - \\'0\\';\\n            \\n            int temp = pivotChoice(set, d, i == 0);\\n            for (int j = i+1; j < len; j++) {\\n                temp *= (10 - j);\\n            }\\n            \\n            unique += temp;\\n            if (!set.add(d)) break;       // no need to continue after seeing repeated digits\\n        }\\n        \\n        if (i == len) unique++;      // the number n itself\\n        \\n        return n - unique;\\n    }\\n    \\n    private int totalNoRepeat(int d) {\\n        int res = 9;\\n        for (int i = 1; i < d; i++) {\\n            res *= (10 - i);\\n        }\\n        return res;\\n    }\\n    \\n    private int pivotChoice(Set<Integer> set, int d, boolean first) {\\n        int res = 0;\\n        int i = (first ? 1 : 0);\\n        \\n        while (i < d) {\\n            if (!set.contains(i++)) res++;\\n        }\\n        \\n        return res;\\n    } \\n    \\n}\\n```\n```\\npublic int numDupDigitsAtMostN(int n) {\\n\\tString str = String.valueOf(n+1);\\n\\tint len = str.length();\\n\\t\\n\\tint unique = 0;\\n\\tfor (int i = 1; i < len; i++) {\\n\\t\\tunique += totalNoRepeat(i);\\n\\t}\\n\\n\\tSet<Integer> set = new HashSet<>();\\n\\tint i = 0;\\n\\tfor (i = 0; i < len; i++) {\\n\\t\\tint d = str.charAt(i) - \\'0\\';\\n\\n\\t\\tint temp = pivotChoice(set, d, i == 0);\\n\\t\\tfor (int j = i+1; j < len; j++) {\\n\\t\\t\\ttemp *= (10 - j);\\n\\t\\t}\\n\\n\\t\\tunique += temp;\\n\\t\\tif (!set.add(d)) break;      \\n\\t}\\n\\treturn n - unique;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 263000,
                "title": "backtracking-with-c-in-a-few-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniqueDigits = 0;\\n    int numDupDigitsAtMostN(int N) {\\n        backtrack(0,0, N);\\n        return N - uniqueDigits + 1; // +1 as 0 is counted\\n    }\\n    \\n    void backtrack(long cur, int bitmask, int& N){\\n        if(cur > N) return;\\n        else uniqueDigits++;\\n        \\n        for(int digit=0; digit<10; digit++){\\n            if(bitmask == 0 && digit == 0) continue;\\n            if((bitmask & (1<<digit)) > 0) continue; // has repeat digits\\n            backtrack(cur*10 + digit, bitmask | (1<<digit), N);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueDigits = 0;\\n    int numDupDigitsAtMostN(int N) {\\n        backtrack(0,0, N);\\n        return N - uniqueDigits + 1; // +1 as 0 is counted\\n    }\\n    \\n    void backtrack(long cur, int bitmask, int& N){\\n        if(cur > N) return;\\n        else uniqueDigits++;\\n        \\n        for(int digit=0; digit<10; digit++){\\n            if(bitmask == 0 && digit == 0) continue;\\n            if((bitmask & (1<<digit)) > 0) continue; // has repeat digits\\n            backtrack(cur*10 + digit, bitmask | (1<<digit), N);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139778,
                "title": "c-digit-dp-with-bitmask-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n\\n\\tint dp[11][2][2][(1 << 10)];\\n\\n\\n\\tint solve(int pos, bool bound, bool hasRepeated, int mask, string &s) {\\n\\n\\t\\tif (pos == s.length()) {\\n\\t\\t\\treturn hasRepeated ? 1 : 0;\\n\\t\\t}\\n\\n\\t\\tif (dp[pos][bound][hasRepeated][mask] != -1) return dp[pos][bound][hasRepeated][mask];\\n\\n\\t\\tint maxDigit = bound ? s[pos] - \\'0\\' : 9;\\n\\n\\t\\tfor (int digit = 0; digit <= maxDigit; digit++) {\\n\\n\\t\\t\\t/* if this is a leading zero, then hasRepeated for the the current guy (position) will obviously be false  */\\n\\t\\t\\tif (digit == 0 && mask == 0) ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), false, mask, s);\\n\\n\\t\\t\\t/*\\n\\t\\t\\t\\tif this particular has already come earlier in this digit, and it is not a leading zero, then clearly, there is a repitition\\n\\t\\t\\t\\tand we have to pass true in hasRepeated\\n\\t\\t\\t*/\\n\\t\\t\\telse if ((mask & (1 << digit))) ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), true, mask, s);\\n\\n\\t\\t\\t/*\\n\\t\\t\\t\\tif this guy is coming for the first time, then hasRepeated will be whatever was for the previous guy\\n\\t\\t\\t\\tand don\\'t forget to switch on the bit corresponding to this digit in the mask\\n\\t\\t\\t*/\\n\\t\\t\\telse ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), hasRepeated, (mask | (1 << digit)), s);\\n\\n\\t\\t}\\n\\n\\t\\treturn dp[pos][bound][hasRepeated][mask] = ans;\\n\\n\\t}\\n\\n\\tint numDupDigitsAtMostN(int n) {\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\t\\tstring R = to_string(n);\\n\\t\\t// return solve(0, true, false, false, 0, R);\\n\\t\\treturn solve(0, true, false, 0, s);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\tint dp[11][2][2][(1 << 10)];\\n\\n\\n\\tint solve(int pos, bool bound, bool hasRepeated, int mask, string &s) {\\n\\n\\t\\tif (pos == s.length()) {\\n\\t\\t\\treturn hasRepeated ? 1 : 0;\\n\\t\\t}\\n\\n\\t\\tif (dp[pos][bound][hasRepeated][mask] != -1) return dp[pos][bound][hasRepeated][mask];\\n\\n\\t\\tint maxDigit = bound ? s[pos] - \\'0\\' : 9;\\n\\n\\t\\tfor (int digit = 0; digit <= maxDigit; digit++) {\\n\\n\\t\\t\\t/* if this is a leading zero, then hasRepeated for the the current guy (position) will obviously be false  */\\n\\t\\t\\tif (digit == 0 && mask == 0) ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), false, mask, s);\\n\\n\\t\\t\\t/*\\n\\t\\t\\t\\tif this particular has already come earlier in this digit, and it is not a leading zero, then clearly, there is a repitition\\n\\t\\t\\t\\tand we have to pass true in hasRepeated\\n\\t\\t\\t*/\\n\\t\\t\\telse if ((mask & (1 << digit))) ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), true, mask, s);\\n\\n\\t\\t\\t/*\\n\\t\\t\\t\\tif this guy is coming for the first time, then hasRepeated will be whatever was for the previous guy\\n\\t\\t\\t\\tand don\\'t forget to switch on the bit corresponding to this digit in the mask\\n\\t\\t\\t*/\\n\\t\\t\\telse ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), hasRepeated, (mask | (1 << digit)), s);\\n\\n\\t\\t}\\n\\n\\t\\treturn dp[pos][bound][hasRepeated][mask] = ans;\\n\\n\\t}\\n\\n\\tint numDupDigitsAtMostN(int n) {\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\t\\tstring R = to_string(n);\\n\\t\\t// return solve(0, true, false, false, 0, R);\\n\\t\\treturn solve(0, true, false, 0, s);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257241,
                "title": "c-with-alternative-explanation",
                "content": "Really enjoyed working through this problem and pushing myself to better understand permutations because of it, and figured I\\'d post my explanation of this problem here. The basic idea behind this problem is to instead determine how many **invalid** numbers exist from **1-N**, rather than trying to find the valid numbers.\\n\\nTo do this, we can make heavy use of the permutations formula (see [here](https://www.mathplanet.com/education/algebra-2/discrete-mathematics-and-probability/permutations-and-combinations) for a great explination on it) since it gives us the number permutations of unique numbers. We can start by figure out how many digits are in our number, and varying all of the digits in L-1 (L being the number of digits).\\n\\nFor example, with the number 350, we have 3 digits, meaning we can start by finding all **invalid** numbers from 0 to 99 (e.g. the first two digits). To start, let\\'s assuming we only have 1 digit available. In this case, we can\\'t vary any other digits in the number since there are none, and because there is only 1 digit they are all invalid. Thus, since there are 9 total numbers with 1 digit, we have 9 invalid permutations for this digit. Similarly, for 2 digits, we have 1 digit we can vary (e.g. 1x has x that can be varied, 2y has y that can be varied, so on and so forth). Plugging that into our our formula, we have perm(9, 1) which results in 9. Because there are 9 possible digits for the first digit, we can multiply the result by 9 (perm(9, 1) * 9) which gives us 81 invalid digits. Adding that onto our first result of 9, and we get 90 invalid digits for a number range of 1-99 (meaning we have 9 valid digits in that range).\\n\\nAt this point, for the number 350, we know that thare are at least 90 invalid digits from 1-100 as a result (since 100 is valid). Now however we need to count the number of invalid digits from 100-350. This can be done by varying each of the digits in 351 (e.g. N+1), and finding the valid permutations of that as a result. For example:\\n```\\n3XX -> perm(9-0, 3-0-1) -> perm(9, 2)\\nX5X -> perm(9-1, 3-1-1) -> perm(8, 1)\\nXX1 -> perm(9-2, 3-2-1) -> perm(7, 0)\\n```\\nWe then add this number of invalid permutations to our count based on the number we have. However, if we\\'ve previously seen a number in that range, we ignore it. For example, when we get to the 5 in 351, we will only add perm(8, 1)\\'s result 4 times, since the third time has already been accounted for when we went over the 3 in 351. Once we\\'ve done all of this, we can simply subtract our number of invalid numbers from our original number N to get our result.\\n\\nHere is what this process looks like in action:\\n```\\n350 -> 351\\ninvalid digits -> 0\\n\\n1 digit -> X -> perm(9, 0) * 9 -> 9 invalid digits\\n2 digits -> YX -> perm(9, 1) * 9 -> 81 invalid digits\\ninvalid digits -> 90\\n\\n0XX -> invalid so don\\'t count the invalid digits.\\n1XX -> perm(9, 2) -> 72 invalid digits\\n2XX -> perm(9, 2) -> 72 invalid digits\\n3XX -> stop counting invalid numbers for the first digit.\\nX0X -> perm(8, 1) -> 8 invalid digits\\nX1X -> perm(8, 1) -> 8 invalid digits\\nX2X -> perm(8, 1) -> 8 invalid digits\\nX3X -> perm(8, 1) -> 8 invalid digits -> but because we\\'ve already looked at the digit 3 previously we can skip this.\\nX4X -> perm(8, 1) -> 8 invalid digits\\nX5X -> stop counting invalid numbers for the second digit.\\nXX0 -> perm(7, 0) -> 1 invalid digit\\nXX1 -> stop counting invalid numbers for the third and final digit.\\ninvalid digits -> 267\\n\\nresult -> 350 - 267 = 83\\n```\\nAnd the full code looks like this:\\n```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        int invalid = 0;\\n        \\n        // Begin by calculating all of the invalid numbers up to 10^(L-1), where L is the length of our number (e.g. For 350, we would find all invalid numbers between 1 and 99)\\n        int c = floor(log10(N+1))+1;\\n        for (int i = 0;i < c-1;i++) {\\n            invalid += 9 * perm(9, i);\\n        }\\n\\n        // For each digit, calculate the possible invalid permutations that are available up until that digit.\\n        int digits = 0;\\n        for (int i = 0;i < c;i++) {\\n            // Get the left most digit.\\n            int digit = ((N+1) / (int)pow(10, c-i-1)) % 10;\\n            // Count up to the digit. Note that if it\\'s the first digit, we start at 1 to avoid finding permutations when the first digit is a 1 since there are none.\\n            for (int j = (i > 0 ? 0 : 1);j < digit;j++) {\\n                // If we\\'ve had the same digit to the left of it previously, then we don\\'t need to count it again.\\n                // E.g. If our number is 350, when get to 330-339 we\\'ve already considered all possible invalid permutations for that number range and can skip it.\\n                if (((digits >> j) & 1) == 0) {\\n                    invalid += perm(9 - i, c - i - 1);\\n                }\\n            }\\n            // If we end up finding a digit we\\'ve already searched, we can finish here.\\n            if ((digits >> digit) & 1)\\n                break;\\n            digits |= 1 << digit;\\n        }\\n\\n        return N - invalid;\\n    }\\n    \\n    int perm(int m, int n) {\\n        int out = 1;\\n        while (m > 1 && n > 0) {\\n            out *= m;\\n            m--;\\n            n--;\\n        }\\n        return out;\\n    }\\n};\\n```\\nSome trickery I used: **log10(N+1) + 1** counts the number of digits we have for us so we don\\'t have to do another loop over them. We can then also abuse some other mathematics to quickly iterate over this without any additional memory, resulting in a **O(c) memory usage, where c is a constant value (e.g. O(1))**. The runtime of this is going to be **O(L\\xB2) where L is the number of digits** from what I can tell, because our second for loop will iterate over every digital (with a max of 9 being possible), and for each digit will iterate over the range of numbers from 0 to D (D being the digit we are on) which also has a mximum possible value of 9. **My math on the runtime may be off, so please correct me if that\\'s the case, as I would like to know the correct runtime.**\\n\\nAs far as further optimizations on the runtime, I\\'m not sure how possible this is since we ultimately need to make sure we don\\'t double count any of the previously checked digits. Feedback on this explination would be greatly appreciated as well!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n3XX -> perm(9-0, 3-0-1) -> perm(9, 2)\\nX5X -> perm(9-1, 3-1-1) -> perm(8, 1)\\nXX1 -> perm(9-2, 3-2-1) -> perm(7, 0)\\n```\n```\\n350 -> 351\\ninvalid digits -> 0\\n\\n1 digit -> X -> perm(9, 0) * 9 -> 9 invalid digits\\n2 digits -> YX -> perm(9, 1) * 9 -> 81 invalid digits\\ninvalid digits -> 90\\n\\n0XX -> invalid so don\\'t count the invalid digits.\\n1XX -> perm(9, 2) -> 72 invalid digits\\n2XX -> perm(9, 2) -> 72 invalid digits\\n3XX -> stop counting invalid numbers for the first digit.\\nX0X -> perm(8, 1) -> 8 invalid digits\\nX1X -> perm(8, 1) -> 8 invalid digits\\nX2X -> perm(8, 1) -> 8 invalid digits\\nX3X -> perm(8, 1) -> 8 invalid digits -> but because we\\'ve already looked at the digit 3 previously we can skip this.\\nX4X -> perm(8, 1) -> 8 invalid digits\\nX5X -> stop counting invalid numbers for the second digit.\\nXX0 -> perm(7, 0) -> 1 invalid digit\\nXX1 -> stop counting invalid numbers for the third and final digit.\\ninvalid digits -> 267\\n\\nresult -> 350 - 267 = 83\\n```\n```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        int invalid = 0;\\n        \\n        // Begin by calculating all of the invalid numbers up to 10^(L-1), where L is the length of our number (e.g. For 350, we would find all invalid numbers between 1 and 99)\\n        int c = floor(log10(N+1))+1;\\n        for (int i = 0;i < c-1;i++) {\\n            invalid += 9 * perm(9, i);\\n        }\\n\\n        // For each digit, calculate the possible invalid permutations that are available up until that digit.\\n        int digits = 0;\\n        for (int i = 0;i < c;i++) {\\n            // Get the left most digit.\\n            int digit = ((N+1) / (int)pow(10, c-i-1)) % 10;\\n            // Count up to the digit. Note that if it\\'s the first digit, we start at 1 to avoid finding permutations when the first digit is a 1 since there are none.\\n            for (int j = (i > 0 ? 0 : 1);j < digit;j++) {\\n                // If we\\'ve had the same digit to the left of it previously, then we don\\'t need to count it again.\\n                // E.g. If our number is 350, when get to 330-339 we\\'ve already considered all possible invalid permutations for that number range and can skip it.\\n                if (((digits >> j) & 1) == 0) {\\n                    invalid += perm(9 - i, c - i - 1);\\n                }\\n            }\\n            // If we end up finding a digit we\\'ve already searched, we can finish here.\\n            if ((digits >> digit) & 1)\\n                break;\\n            digits |= 1 << digit;\\n        }\\n\\n        return N - invalid;\\n    }\\n    \\n    int perm(int m, int n) {\\n        int out = 1;\\n        while (m > 1 && n > 0) {\\n            out *= m;\\n            m--;\\n            n--;\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521900,
                "title": "c-digit-dp-with-bismasking-recursive-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[11][2][1024][2]; //dp[pos][strictly][s][repeated]\\n    //s value can go upto 1024.\\n    //logic:- if we set all bit from (9...0) it gives approx. 1023 \\n    int solve(string& str, int pos, bool strictly, int s, bool repeated){\\n        if(pos==str.size()){\\n            if(repeated) return 1;\\n            else return 0;\\n        }\\n        if(dp[pos][strictly][s][repeated]!=-1) return dp[pos][strictly][s][repeated];\\n        int cur=0, n=str[pos]-\\'0\\';\\n        if(strictly){\\n            for(int i=0;i<=n;++i){\\n                if(i==0 and s==0) cur+=solve(str,pos+1,false,s,repeated); //leading zero\\n                else if(i==n){\\n                    if(s&(1<<i)) cur+=solve(str,pos+1,true,s,true);\\n                    else cur+=solve(str,pos+1,true,s^(1<<i),repeated);\\n                }else{\\n                    if(s&(1<<i)) cur+=solve(str,pos+1,false,s,true);\\n                    else cur+=solve(str,pos+1,false,s^(1<<i),repeated);\\n                }\\n            }\\n        }else{\\n            for(int i=0;i<=9;++i){\\n                if(i==0 and s==0) cur+=solve(str,pos+1,false,s,repeated); //leading zero\\n                else{\\n                    if(s&(1<<i)) cur+=solve(str,pos+1,false,s,true);\\n                    else cur+=solve(str,pos+1,false,s^(1<<i),repeated);\\n                }\\n            }\\n        }\\n        return dp[pos][strictly][s][repeated] = cur;\\n    }\\n    \\n    \\n    int numDupDigitsAtMostN(int n) {\\n        string str = to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(str,0,true,0,false);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[11][2][1024][2]; //dp[pos][strictly][s][repeated]\\n    //s value can go upto 1024.\\n    //logic:- if we set all bit from (9...0) it gives approx. 1023 \\n    int solve(string& str, int pos, bool strictly, int s, bool repeated){\\n        if(pos==str.size()){\\n            if(repeated) return 1;\\n            else return 0;\\n        }\\n        if(dp[pos][strictly][s][repeated]!=-1) return dp[pos][strictly][s][repeated];\\n        int cur=0, n=str[pos]-\\'0\\';\\n        if(strictly){\\n            for(int i=0;i<=n;++i){\\n                if(i==0 and s==0) cur+=solve(str,pos+1,false,s,repeated); //leading zero\\n                else if(i==n){\\n                    if(s&(1<<i)) cur+=solve(str,pos+1,true,s,true);\\n                    else cur+=solve(str,pos+1,true,s^(1<<i),repeated);\\n                }else{\\n                    if(s&(1<<i)) cur+=solve(str,pos+1,false,s,true);\\n                    else cur+=solve(str,pos+1,false,s^(1<<i),repeated);\\n                }\\n            }\\n        }else{\\n            for(int i=0;i<=9;++i){\\n                if(i==0 and s==0) cur+=solve(str,pos+1,false,s,repeated); //leading zero\\n                else{\\n                    if(s&(1<<i)) cur+=solve(str,pos+1,false,s,true);\\n                    else cur+=solve(str,pos+1,false,s^(1<<i),repeated);\\n                }\\n            }\\n        }\\n        return dp[pos][strictly][s][repeated] = cur;\\n    }\\n    \\n    \\n    int numDupDigitsAtMostN(int n) {\\n        string str = to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(str,0,true,0,false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257281,
                "title": "java-o-1-0ms-beats-all",
                "content": "This is to count the numbers with all distinct digits.\\nWe can separate into two parts... say for N = 6,543,210,\\n\\nwe\\'ll count the distinct one from 1 to 999,999, which would be \\n\\t1-9: 9\\n\\tplus 10-99: 9 * 9 \\n\\tplus 100-999: 9 * 9 * 8\\n\\tplus 1,000 - 9,999: 9 * 9 * 8 * 7\\n\\t...\\n\\t100,000 - 999,999: 9 * 9 * 8 * 7 * 6 * 5.\\n\\t\\nThe above part can be done in one for loop with at most 9 iterations : O (1)\\t\\n\\nThen we add the remaining distinct ones (from 1,000,000 to 6,543,210)\\n\\nFrom 1,000,000 to 5,999,999 : 5 * 9 * 8 * 7 * 6 * 5 * 4\\nthen 6,000,000 to 6,499,999: 5 * 9 * 8 * 7 * 6 * 5\\nthen 6,500,000 to 6,539,999 and so on... 4 * 9 * 8 * 7 * 6 ...\\n\\nThe above part takes at most 81 iterations which is also O(1)\\n\\n```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        if (N<=10)\\n            return 0;\\n        int[] digits = new int[9];\\n        int cursor = 0;\\n        int v = N;\\n        while (v>0){\\n            digits[cursor++] = v%10;\\n            v= v/10;\\n        }\\n        //cursor is digit cnt\\n        return N - countDistinctUpToMsb1(cursor) - countDistinctFromMsb1(digits, cursor);\\n    }\\n    \\n    private int countDistinctUpToMsb1(int digitCnts){\\n        int total = 9;\\n        int last = 9;\\n        int remainingCnt = 9;\\n        for (int i=1;i<digitCnts-1;i++){\\n            last = last * remainingCnt;\\n            total += last;\\n            remainingCnt--;\\n        }\\n        return total;\\n    }\\n    \\n    private int countDistinctFromMsb1(int[] digits, int length){\\n        //eg 1000 - 2345\\n        boolean[] digitUsed = new boolean[10];\\n        int count = 0;\\n        for (int i=0;i<length;i++){\\n            int digit = digits[length-i-1];\\n            count += countDistinct(digitUsed, i, digit, i==0?false:true,length-i-1);\\n            if (digitUsed[digit])\\n                break;\\n            if (i==length-1)\\n                count++;\\n            digitUsed[digit] = true;\\n        }\\n        return count;\\n    }\\n    private int countDistinct(boolean[] digitUsed,int digitUsedCnt, int nextDigit, boolean nextFromZero, int tailingZeros){\\n        int cnt=0;\\n        for (int i=nextFromZero?0:1;i<nextDigit;i++){\\n            if (!digitUsed[i])\\n                cnt++;\\n        }\\n        digitUsedCnt++;\\n        for (int i=0;i<tailingZeros;i++){\\n            cnt *= (10 - digitUsedCnt++);\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        if (N<=10)\\n            return 0;\\n        int[] digits = new int[9];\\n        int cursor = 0;\\n        int v = N;\\n        while (v>0){\\n            digits[cursor++] = v%10;\\n            v= v/10;\\n        }\\n        //cursor is digit cnt\\n        return N - countDistinctUpToMsb1(cursor) - countDistinctFromMsb1(digits, cursor);\\n    }\\n    \\n    private int countDistinctUpToMsb1(int digitCnts){\\n        int total = 9;\\n        int last = 9;\\n        int remainingCnt = 9;\\n        for (int i=1;i<digitCnts-1;i++){\\n            last = last * remainingCnt;\\n            total += last;\\n            remainingCnt--;\\n        }\\n        return total;\\n    }\\n    \\n    private int countDistinctFromMsb1(int[] digits, int length){\\n        //eg 1000 - 2345\\n        boolean[] digitUsed = new boolean[10];\\n        int count = 0;\\n        for (int i=0;i<length;i++){\\n            int digit = digits[length-i-1];\\n            count += countDistinct(digitUsed, i, digit, i==0?false:true,length-i-1);\\n            if (digitUsed[digit])\\n                break;\\n            if (i==length-1)\\n                count++;\\n            digitUsed[digit] = true;\\n        }\\n        return count;\\n    }\\n    private int countDistinct(boolean[] digitUsed,int digitUsedCnt, int nextDigit, boolean nextFromZero, int tailingZeros){\\n        int cnt=0;\\n        for (int i=nextFromZero?0:1;i<nextDigit;i++){\\n            if (!digitUsed[i])\\n                cnt++;\\n        }\\n        digitUsedCnt++;\\n        for (int i=0;i<tailingZeros;i++){\\n            cnt *= (10 - digitUsedCnt++);\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205659,
                "title": "c-digit-dp-bit-masking",
                "content": "**PLEASE UPVOTE IF U FIND MY SOLUTION HELPFUL :)**\\n\\n```\\nclass Solution\\n{\\n    int dp[1<<10][10][2][2];\\n    int helper(string &s,int i,int mask,int lz,int bound)\\n    {\\n        if(i==s.length())return 1;\\n        \\n        if(dp[mask][i][lz][bound]!=-1)\\n            return dp[mask][i][lz][bound];\\n        \\n        int maxx=bound?s[i]-\\'0\\':9;\\n        \\n        int tot=0;\\n        \\n        for(int j=0;j<=maxx;j++)\\n        {\\n            if((mask&(1<<j))&&lz==0)continue;\\n            mask|=(1<<j);\\n            tot+=helper(s,i+1,mask,lz&(j==0),bound&(j==maxx));\\n            mask^=(1<<j);\\n        }\\n        \\n        return dp[mask][i][lz][bound]=tot;\\n    }\\n    public:\\n        int numDupDigitsAtMostN(int n)\\n        {\\n            string s=to_string(n);\\n            memset(dp,-1,sizeof(dp));\\n            int mask=0;\\n            int res=(n+1)-helper(s,0,mask,1,1);\\n            return res;\\n        }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution\\n{\\n    int dp[1<<10][10][2][2];\\n    int helper(string &s,int i,int mask,int lz,int bound)\\n    {\\n        if(i==s.length())return 1;\\n        \\n        if(dp[mask][i][lz][bound]!=-1)\\n            return dp[mask][i][lz][bound];\\n        \\n        int maxx=bound?s[i]-\\'0\\':9;\\n        \\n        int tot=0;\\n        \\n        for(int j=0;j<=maxx;j++)\\n        {\\n            if((mask&(1<<j))&&lz==0)continue;\\n            mask|=(1<<j);\\n            tot+=helper(s,i+1,mask,lz&(j==0),bound&(j==maxx));\\n            mask^=(1<<j);\\n        }\\n        \\n        return dp[mask][i][lz][bound]=tot;\\n    }\\n    public:\\n        int numDupDigitsAtMostN(int n)\\n        {\\n            string s=to_string(n);\\n            memset(dp,-1,sizeof(dp));\\n            int mask=0;\\n            int res=(n+1)-helper(s,0,mask,1,1);\\n            return res;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 259667,
                "title": "c-study-code-from-ranking-no-1-in-weekly-contest-128",
                "content": "March 21, 2019\\nIt is one of weekly contest 128 algorithms. What I like to do is to learn ranking No. 1\\'s code, and then I add some comment to explain the idea to make it easy to follow. The player finished the algorithm using 7 minutes 5 seconds. \\n\\n![image](https://assets.leetcode.com/users/jianminchen/image_1553206027.png)\\n\\n\\nHere are a few tips:\\n1. using one binary number to store all unique digits in the number; mapping is described in the comment\\n2. using & operator to avoid any duplicated digit\\n3. using or to include current digit into the binary number\\n\\n**More detail**\\nEvery number from 0 to 9 can be represented using one bit in a binary number. So all digits in any  integer number can be recorded using one binary number including 10 bits at most. \\n\\n0 is expressed in 0, in binary format, 1 << 0\\n1 is expressed in 10, in binary format, 1 << 1\\n2 is expressed in 100\\n3 is expressed in 1000\\n4 is expressed in 10000\\n5 is expressed in 100000\\n6 is expressed in 1000000\\n7 is expressed in 10000000\\n8 is expressed in 100000000\\n9 is expressed in 1000000000, in binary format, 1 << 9\\n\\n**How to determine current digit is not duplicated**\\n\\nUsing one binary number to express all unique digits in the number, and then using **and &** operator to check uniqueness, and **or | operator** to include current digits. \\n\\nLet us work on one example in the following. \\nChoose a number with unique digits, for example, 123 or 321 or 213. All digits in the number can be expressed using one binary number 1110, so next digit should avoid duplication of those three digits. \\n\\nIf current digit is 4, the exiting digits include {1, 2, 3}, then 1110 & (1 << 4) = 1110 & 10000 = 0, \\nsince there is no duplication of digits. However, any digit from {1, 2, 3}, its binary format number & 1110 > 0.\\n\\nIt is the excellent practice to warm up bit manipulation and learn how to write a solution in less than 10 minutes. Othewise, it is better to use standard depth first search, and use an array instead of a binary number to mark the digit used. I also posted the solution on that: https://leetcode.com/problems/numbers-with-repeated-digits/discuss/259737/C-standard-depth-first-search-with-back-tracking\\n\\nHere is my C# code based on code study. \\n\\t\\t\\t\\t\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1015_number_with_repeated_digits_1\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var result = NumDupDigitsAtMostN(20);\\n        }\\n\\n        public static int n;\\n        public static int uniqueDigitis;\\n\\n        /// <summary>\\n        /// study code on weekly contest 128 rank No. 1 waakaaka\\n        /// https://leetcode.com/contest/weekly-contest-128/ranking\\n        /// </summary>\\n        /// <param name=\"N\"></param>\\n        /// <returns></returns>\\n        public static int NumDupDigitsAtMostN(int N)\\n        {\\n            uniqueDigitis = 0;\\n            n = N;\\n            runDepthFirstSearchLeftToRight(0,0);\\n            return N + 1 - uniqueDigitis; \\n        }\\n\\n        /// <summary>\\n        /// code review March 21, 2019\\n        /// Here are a few tips:\\n        /// 1. using one binary number to store all unique digits in the number; mapping is described in the comment\\n        /// 2. using & operator to avoid any duplicated digit\\n        /// 3. using or to include current digit into the binary number\\n        /// </summary>\\n        /// <param name=\"value\"></param>\\n        /// <param name=\"binaryShift\"></param>\\n        private static void runDepthFirstSearchLeftToRight(long value, int binaryShift)\\n        {\\n            if (value <= n)\\n            {\\n                uniqueDigitis++;\\n            }\\n\\n            if (value * 10 > n)\\n            {\\n                return;\\n            }\\n\\n            for (int digit = 0; digit <= 9; digit++)\\n            {\\n                // no 0 for first digit\\n                if (binaryShift == 0 && digit == 0)\\n                {\\n                    continue;\\n                }\\n\\n                // every number from 0 to 9 is represented using binary number\\n                // 0 is expressed in 0\\n                // 1 is expressed in 10\\n                // 2 is expressed in 100\\n                // 3 is expressed in 1000\\n                // 4 is expressed in 10000\\n                // 5 is expressed in 100000\\n                // 6 is expressed in 1000000\\n                // 7 is expressed in 10000000\\n                // 8 is expressed in 100000000\\n                // 9 is expressed in 1000000000\\n                var currentDigitExpression = 1 << digit; \\n               \\n                // number with unique digits, for example, 123 or 321 or 213. \\n                // all digits in the number can be expressed using one binary number 1110\\n                // so next digit should avoid duplication of those three digits\\n                // if current digit is 4, the exiting digits include {1, 2, 3}, then 1110 & (1 << 4) = 1110 & 10000 = 0, \\n                // since there is no duplication of digits                \\n                // any digit from {1, 2, 3} & 1110 > 0 \\n                if ((binaryShift & currentDigitExpression) > 0)\\n                {\\n                    continue; \\n                }\\n\\n                // using | to include current digit\\n                var nextBinary = binaryShift | currentDigitExpression;\\n                runDepthFirstSearchLeftToRight(value * 10 + digit, nextBinary); \\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1015_number_with_repeated_digits_1\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var result = NumDupDigitsAtMostN(20);\\n        }\\n\\n        public static int n;\\n        public static int uniqueDigitis;\\n\\n        /// <summary>\\n        /// study code on weekly contest 128 rank No. 1 waakaaka\\n        /// https://leetcode.com/contest/weekly-contest-128/ranking\\n        /// </summary>\\n        /// <param name=\"N\"></param>\\n        /// <returns></returns>\\n        public static int NumDupDigitsAtMostN(int N)\\n        {\\n            uniqueDigitis = 0;\\n            n = N;\\n            runDepthFirstSearchLeftToRight(0,0);\\n            return N + 1 - uniqueDigitis; \\n        }\\n\\n        /// <summary>\\n        /// code review March 21, 2019\\n        /// Here are a few tips:\\n        /// 1. using one binary number to store all unique digits in the number; mapping is described in the comment\\n        /// 2. using & operator to avoid any duplicated digit\\n        /// 3. using or to include current digit into the binary number\\n        /// </summary>\\n        /// <param name=\"value\"></param>\\n        /// <param name=\"binaryShift\"></param>\\n        private static void runDepthFirstSearchLeftToRight(long value, int binaryShift)\\n        {\\n            if (value <= n)\\n            {\\n                uniqueDigitis++;\\n            }\\n\\n            if (value * 10 > n)\\n            {\\n                return;\\n            }\\n\\n            for (int digit = 0; digit <= 9; digit++)\\n            {\\n                // no 0 for first digit\\n                if (binaryShift == 0 && digit == 0)\\n                {\\n                    continue;\\n                }\\n\\n                // every number from 0 to 9 is represented using binary number\\n                // 0 is expressed in 0\\n                // 1 is expressed in 10\\n                // 2 is expressed in 100\\n                // 3 is expressed in 1000\\n                // 4 is expressed in 10000\\n                // 5 is expressed in 100000\\n                // 6 is expressed in 1000000\\n                // 7 is expressed in 10000000\\n                // 8 is expressed in 100000000\\n                // 9 is expressed in 1000000000\\n                var currentDigitExpression = 1 << digit; \\n               \\n                // number with unique digits, for example, 123 or 321 or 213. \\n                // all digits in the number can be expressed using one binary number 1110\\n                // so next digit should avoid duplication of those three digits\\n                // if current digit is 4, the exiting digits include {1, 2, 3}, then 1110 & (1 << 4) = 1110 & 10000 = 0, \\n                // since there is no duplication of digits                \\n                // any digit from {1, 2, 3} & 1110 > 0 \\n                if ((binaryShift & currentDigitExpression) > 0)\\n                {\\n                    continue; \\n                }\\n\\n                // using | to include current digit\\n                var nextBinary = binaryShift | currentDigitExpression;\\n                runDepthFirstSearchLeftToRight(value * 10 + digit, nextBinary); \\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027402,
                "title": "c-digit-dp-with-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int anotherdp[15][2];\\n    \\n    int total(string x,int n,bool tight,set<int> &s){\\n        if(n==0){\\n            return 1;\\n        }\\n        if(anotherdp[n][tight]!=-1){\\n            return anotherdp[n][tight];\\n        }\\n        int ub = (tight==1) ? x[x.length()-n]-\\'0\\' : 9;\\n        int res=0;\\n        for(int i=0;i<=ub;i++){\\n            if(s.empty() && i==0) continue;\\n            else if(s.find(i)==s.end()){\\n                s.insert(i);\\n                res+=total(x,n-1,(tight & (i==ub)),s);\\n                s.erase(s.find(i));\\n            }\\n        }\\n        return (anotherdp[n][tight]=res);\\n    }\\n    \\n    int numDupDigitsAtMostN(int N) {\\n        if(N<=10){\\n            return 0;\\n        }\\n        int n = log10(N);\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        dp[1] = 9;\\n        int x=9;\\n        int y=9;\\n        for(int i=2;i<=n;i++){\\n            x*=y;\\n            y--;\\n            dp[i] = x;\\n            dp[i]+=dp[i-1];\\n        }\\n        set<int> s;\\n        s.clear(); \\n        string xx = to_string(N);\\n        memset(anotherdp,-1,sizeof(anotherdp));\\n        int temp = total(xx,xx.length(),1,s);\\n        return N-(dp[n]+temp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int anotherdp[15][2];\\n    \\n    int total(string x,int n,bool tight,set<int> &s){\\n        if(n==0){\\n            return 1;\\n        }\\n        if(anotherdp[n][tight]!=-1){\\n            return anotherdp[n][tight];\\n        }\\n        int ub = (tight==1) ? x[x.length()-n]-\\'0\\' : 9;\\n        int res=0;\\n        for(int i=0;i<=ub;i++){\\n            if(s.empty() && i==0) continue;\\n            else if(s.find(i)==s.end()){\\n                s.insert(i);\\n                res+=total(x,n-1,(tight & (i==ub)),s);\\n                s.erase(s.find(i));\\n            }\\n        }\\n        return (anotherdp[n][tight]=res);\\n    }\\n    \\n    int numDupDigitsAtMostN(int N) {\\n        if(N<=10){\\n            return 0;\\n        }\\n        int n = log10(N);\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        dp[1] = 9;\\n        int x=9;\\n        int y=9;\\n        for(int i=2;i<=n;i++){\\n            x*=y;\\n            y--;\\n            dp[i] = x;\\n            dp[i]+=dp[i-1];\\n        }\\n        set<int> s;\\n        s.clear(); \\n        string xx = to_string(N);\\n        memset(anotherdp,-1,sizeof(anotherdp));\\n        int temp = total(xx,xx.length(),1,s);\\n        return N-(dp[n]+temp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937922,
                "title": "c-digit-dp-simplest-solution-clean-code",
                "content": "# Intuition & Approach\\nRather than finding numbers having repetitions, we can find: `Total numbers - Numbers with all digits unique`.\\nMaintain a bitmask to make sure that we don\\'t re-select a digit which has already been included.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[11][2][1025]; // 1025 -> (1 << 10)\\n    int dfs(int i, int mask, bool tight, string &digits) {\\n        if(i == digits.size()) {\\n            return mask == 0 ? 0 : 1;\\n        }\\n\\n        if(dp[i][tight][mask] != -1) return dp[i][tight][mask];\\n\\n        int limit = 9, res = 0;\\n        if(tight) limit = (digits[i] - \\'0\\');\\n\\n        for(int dig = 0; dig <= limit; dig++) {\\n            // mask = 0 -> No number has been formed yet &\\n            // dig = 0 -> We can\\'t select first digit as 0 \\n            if(mask == 0 && dig == 0) {\\n                res += dfs(i + 1, mask, (tight & (limit == dig)), digits);\\n                continue;\\n            }\\n            // Check if the current digit has already been included\\n            int repeated = mask & (1 << dig);\\n            // If it hasn\\'t, include it and furthur proceed\\n            if(repeated == 0) {\\n                res += dfs(i + 1, mask | (1 << dig), (tight & (limit == dig)), digits);\\n            }\\n        }\\n\\n        return dp[i][tight][mask] = res;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp, -1, sizeof dp);\\n        string x = to_string(n);\\n        return n - dfs(0, 0, true, x);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[11][2][1025]; // 1025 -> (1 << 10)\\n    int dfs(int i, int mask, bool tight, string &digits) {\\n        if(i == digits.size()) {\\n            return mask == 0 ? 0 : 1;\\n        }\\n\\n        if(dp[i][tight][mask] != -1) return dp[i][tight][mask];\\n\\n        int limit = 9, res = 0;\\n        if(tight) limit = (digits[i] - \\'0\\');\\n\\n        for(int dig = 0; dig <= limit; dig++) {\\n            // mask = 0 -> No number has been formed yet &\\n            // dig = 0 -> We can\\'t select first digit as 0 \\n            if(mask == 0 && dig == 0) {\\n                res += dfs(i + 1, mask, (tight & (limit == dig)), digits);\\n                continue;\\n            }\\n            // Check if the current digit has already been included\\n            int repeated = mask & (1 << dig);\\n            // If it hasn\\'t, include it and furthur proceed\\n            if(repeated == 0) {\\n                res += dfs(i + 1, mask | (1 << dig), (tight & (limit == dig)), digits);\\n            }\\n        }\\n\\n        return dp[i][tight][mask] = res;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp, -1, sizeof dp);\\n        string x = to_string(n);\\n        return n - dfs(0, 0, true, x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2226388,
                "title": "digit-dp",
                "content": "I didn\\'t get any soln in discuss that contains digit dp in python so I did this In this soln, to see whether any digit repeated or not, i take a memo , i guess you have used it before if not then see following problem it just contain 1 for integer if it\\'s already taken otherwise 0 and put it in binary form . Ya it\\'s 5 order dp so don\\'t be confused i just used it for memoization. if you don\\'t know more about digit dp, I will highly recommend you to see kartik arora\\'s digit dp video on youtube.\\n[https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/submissions/](http://)\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        dp=[[[[[-1 for tight in range(2)] for i in range(2)] for i in range(2)] for i in range(2**10)] for i in range(10)]\\n        len1 = len(str(n))\\n        def fun(i,check,tight,memo,leading_zero):\\n            if i==len1:\\n                if check==1:\\n                    return 1\\n                return 0\\n            end = 9\\n            if dp[i][memo][check][leading_zero][tight]!=-1:\\n                return dp[i][memo][check][leading_zero][tight]\\n            if tight==1:\\n                end = int(str(n)[i])\\n            res = 0\\n            for j in range(end+1):\\n                if j==0 and leading_zero==1:\\n                    res+=fun(i+1,0,tight&(j==end),memo,1)\\n                    continue\\n                if check==1:\\n                    res+=fun(i+1,1,tight&(j==end),memo|(1<<j),0)\\n                    continue\\n                if memo&(1<<j):\\n                    res+=fun(i+1,1,tight&(j==end),memo,0)\\n                else:\\n                    res+=fun(i+1,0,tight&(j==end),memo|(1<<j),0)\\n            dp[i][memo][check][leading_zero][tight] = res\\n            return res\\n        return fun(0,0,1,0,1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "I didn\\'t get any soln in discuss that contains digit dp in python so I did this In this soln, to see whether any digit repeated or not, i take a memo , i guess you have used it before if not then see following problem it just contain 1 for integer if it\\'s already taken otherwise 0 and put it in binary form . Ya it\\'s 5 order dp so don\\'t be confused i just used it for memoization. if you don\\'t know more about digit dp, I will highly recommend you to see kartik arora\\'s digit dp video on youtube.\\n[https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/submissions/](http://)\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        dp=[[[[[-1 for tight in range(2)] for i in range(2)] for i in range(2)] for i in range(2**10)] for i in range(10)]\\n        len1 = len(str(n))\\n        def fun(i,check,tight,memo,leading_zero):\\n            if i==len1:\\n                if check==1:\\n                    return 1\\n                return 0\\n            end = 9\\n            if dp[i][memo][check][leading_zero][tight]!=-1:\\n                return dp[i][memo][check][leading_zero][tight]\\n            if tight==1:\\n                end = int(str(n)[i])\\n            res = 0\\n            for j in range(end+1):\\n                if j==0 and leading_zero==1:\\n                    res+=fun(i+1,0,tight&(j==end),memo,1)\\n                    continue\\n                if check==1:\\n                    res+=fun(i+1,1,tight&(j==end),memo|(1<<j),0)\\n                    continue\\n                if memo&(1<<j):\\n                    res+=fun(i+1,1,tight&(j==end),memo,0)\\n                else:\\n                    res+=fun(i+1,0,tight&(j==end),memo|(1<<j),0)\\n            dp[i][memo][check][leading_zero][tight] = res\\n            return res\\n        return fun(0,0,1,0,1)",
                "codeTag": "Java"
            },
            {
                "id": 592922,
                "title": "python-well-commented-solution-with-easy-to-follow-recursion",
                "content": "```\\nclass Solution(object):\\n    def numDupDigitsAtMostN(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        memo = {}\\n        def f(digits_of_N, i, digits_used, any_digit):\\n            if i == k:\\n                return 1\\n            \\n            key = (i, digits_used, any_digit)\\n            if key in memo:\\n                return memo[key]\\n            \\n            # For each digit position, we iterate through all possible choices\\n            cnt = 0\\n            # If it\\'s the leading digit, at position 0, we cannot pick 0 as a choice\\n            min_digit = 1 if i == 0 else 0\\n            # We can pick up to and including the digit at the i-th position of N so\\n            # the number stays <= N. However if we\\'ve picked some previous digit less\\n            # than that in N at the same position, then we can pick any digit we want.\\n            # Why? Because if the more significant digit has a smaller number, it doesn\\'t\\n            # matter what number we pick for less sigificant digit positions.\\n            max_digit = 9 if any_digit else digits_of_N[i]\\n            for d in range(min_digit, max_digit + 1):\\n                # Use a bitmask to record if we\\'ve already used a digit. Since we only want\\n                # integers with unique digits, once a digit is used, it cannot be picked again.\\n                if digits_used & (1 << d) != 0:\\n                    continue\\n                # If we picked some digit less than the i-th digit of N, then for the\\n                # digit positions after i we can pick whatever we want, as long as\\n                # the digit picked is unique, and it will be less than N. \\n                cnt += f(digits_of_N, i + 1, digits_used | (1 << d), any_digit or (d < digits_of_N[i]))\\n            \\n            memo[key] = cnt\\n            return cnt\\n        \\n        # Life is easier without having to deal with the single-digit case.\\n        # It\\'s only interesting when we have at least 2 digits.\\n        if N <= 9:\\n            return 0\\n        \\n        # Let k be the number of digits in N\\n        k = len(str(N))\\n        # We break the set of positive integers <= N with at least one duplicate digit into \\n        # two disjoint sets A and B, where:\\n        #   - A is the set of positive integers with k - 1 or less number of digits, with at least 1\\n\\t\\t#       duplicate digit\\n        #   - B is the set of positive integers <= N with exactly k number of digits, with at least 1\\n\\t\\t#      duplicate digit\\n        \\n        # Let\\'s first count the size A.\\n        # Given i in [1.. k - 1], the set of positive integers with i digits and at least 1 duplicate digit\\n\\t\\t# must be:\\n        #    The set of positive integers with i digits - positive integers with only unique digits.\\n        # Well positive integers with i digits is just 9 * 10^(i - 1) -- we have {1, 2 .. 9} as \\n        # possible choices for the leading digit and then {0..9} as possible choices for each of the \\n        # remaining digits. \\n        # And positive integers with i digits and only unique digits must be:\\n        #    9 * 9 * 8 * 7 ... up to i terms\\n        # We have {1..9} as possible choices for the leading digit and then 10 - 1 possible choices\\n        # for the second digit -- whatever leading digit we picked we cannot select that again.\\n        # And having made a choice for the second digit, we\\'d then only have 8 possible choices \\n        # for the 3rd digit and so on, until we have only 1 possible digit choice left.\\n        cnt = 0\\n        for i in range(1, k):\\n            all_possible_ints = 9 * 10**(i-1)\\n            ints_with_unique_digits = 9\\n            nb_choices = 9\\n            for j in range(1, i):\\n                ints_with_unique_digits *= nb_choices\\n                nb_choices -= 1\\n            cnt += all_possible_ints - ints_with_unique_digits\\n            \\n        # Let\\'s then count the size of B. Again it\\'s similar to A.\\n        # For positive integers with exactly k digits <= N. e.g. if N = 12483, then \\n        # we have 12483 - 9999 possible integers with 5 digits. (9999 or below are all\\n        # numbers with less than 5 digits)\\n        all_ints_with_k_digits = N - int(\\'9\\'*(k-1))\\n        # To count the number of positive integers <= N with exactly k unique digits,\\n        # we\\'ll need a bit of recursion. See comments in f()\\n        digits_of_N = [int(d) for d in str(N)]\\n        ints_with_unique_k_digits = f(digits_of_N, 0, 0, False)\\n        cnt += all_ints_with_k_digits - ints_with_unique_k_digits\\n        \\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numDupDigitsAtMostN(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        memo = {}\\n        def f(digits_of_N, i, digits_used, any_digit):\\n            if i == k:\\n                return 1\\n            \\n            key = (i, digits_used, any_digit)\\n            if key in memo:\\n                return memo[key]\\n            \\n            # For each digit position, we iterate through all possible choices\\n            cnt = 0\\n            # If it\\'s the leading digit, at position 0, we cannot pick 0 as a choice\\n            min_digit = 1 if i == 0 else 0\\n            # We can pick up to and including the digit at the i-th position of N so\\n            # the number stays <= N. However if we\\'ve picked some previous digit less\\n            # than that in N at the same position, then we can pick any digit we want.\\n            # Why? Because if the more significant digit has a smaller number, it doesn\\'t\\n            # matter what number we pick for less sigificant digit positions.\\n            max_digit = 9 if any_digit else digits_of_N[i]\\n            for d in range(min_digit, max_digit + 1):\\n                # Use a bitmask to record if we\\'ve already used a digit. Since we only want\\n                # integers with unique digits, once a digit is used, it cannot be picked again.\\n                if digits_used & (1 << d) != 0:\\n                    continue\\n                # If we picked some digit less than the i-th digit of N, then for the\\n                # digit positions after i we can pick whatever we want, as long as\\n                # the digit picked is unique, and it will be less than N. \\n                cnt += f(digits_of_N, i + 1, digits_used | (1 << d), any_digit or (d < digits_of_N[i]))\\n            \\n            memo[key] = cnt\\n            return cnt\\n        \\n        # Life is easier without having to deal with the single-digit case.\\n        # It\\'s only interesting when we have at least 2 digits.\\n        if N <= 9:\\n            return 0\\n        \\n        # Let k be the number of digits in N\\n        k = len(str(N))\\n        # We break the set of positive integers <= N with at least one duplicate digit into \\n        # two disjoint sets A and B, where:\\n        #   - A is the set of positive integers with k - 1 or less number of digits, with at least 1\\n\\t\\t#       duplicate digit\\n        #   - B is the set of positive integers <= N with exactly k number of digits, with at least 1\\n\\t\\t#      duplicate digit\\n        \\n        # Let\\'s first count the size A.\\n        # Given i in [1.. k - 1], the set of positive integers with i digits and at least 1 duplicate digit\\n\\t\\t# must be:\\n        #    The set of positive integers with i digits - positive integers with only unique digits.\\n        # Well positive integers with i digits is just 9 * 10^(i - 1) -- we have {1, 2 .. 9} as \\n        # possible choices for the leading digit and then {0..9} as possible choices for each of the \\n        # remaining digits. \\n        # And positive integers with i digits and only unique digits must be:\\n        #    9 * 9 * 8 * 7 ... up to i terms\\n        # We have {1..9} as possible choices for the leading digit and then 10 - 1 possible choices\\n        # for the second digit -- whatever leading digit we picked we cannot select that again.\\n        # And having made a choice for the second digit, we\\'d then only have 8 possible choices \\n        # for the 3rd digit and so on, until we have only 1 possible digit choice left.\\n        cnt = 0\\n        for i in range(1, k):\\n            all_possible_ints = 9 * 10**(i-1)\\n            ints_with_unique_digits = 9\\n            nb_choices = 9\\n            for j in range(1, i):\\n                ints_with_unique_digits *= nb_choices\\n                nb_choices -= 1\\n            cnt += all_possible_ints - ints_with_unique_digits\\n            \\n        # Let\\'s then count the size of B. Again it\\'s similar to A.\\n        # For positive integers with exactly k digits <= N. e.g. if N = 12483, then \\n        # we have 12483 - 9999 possible integers with 5 digits. (9999 or below are all\\n        # numbers with less than 5 digits)\\n        all_ints_with_k_digits = N - int(\\'9\\'*(k-1))\\n        # To count the number of positive integers <= N with exactly k unique digits,\\n        # we\\'ll need a bit of recursion. See comments in f()\\n        digits_of_N = [int(d) for d in str(N)]\\n        ints_with_unique_k_digits = f(digits_of_N, 0, 0, False)\\n        cnt += all_ints_with_k_digits - ints_with_unique_k_digits\\n        \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 459348,
                "title": "correct-solution-but-exceeded-time-limit",
                "content": "This solution will give correct answer but will exceed time limit:\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        countRepeat = 0\\n        for x in range(1, N+1):\\n            intList = [char for char in str(x)]\\n            if len(str(x)) != len(list(set(intList))):\\n                countRepeat += 1\\n        return countRepeat",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "This solution will give correct answer but will exceed time limit:\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        countRepeat = 0\\n        for x in range(1, N+1):\\n            intList = [char for char in str(x)]\\n            if len(str(x)) != len(list(set(intList))):\\n                countRepeat += 1\\n        return countRepeat",
                "codeTag": "Java"
            },
            {
                "id": 3600079,
                "title": "c-solution-digit-dp-clean-and-concise-bitmask",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dp[10][2][1025][2]; //2^10 = 1024 for bitmask\\n\\n    int count(int idx,bool tight,int bitmask,bool isrepeated,string& num){\\n        if(idx==num.size()){\\n            return (isrepeated&&bitmask)?1:0;\\n        }\\n        if(dp[idx][tight][bitmask][isrepeated]!=-1) return dp[idx][tight][bitmask][isrepeated];\\n        int lo = 0;\\n        int hi = tight?(num[idx]-\\'0\\'):9;\\n        int cnt = 0;\\n        if(!bitmask){\\n            cnt += count(idx+1,false,bitmask,isrepeated,num);\\n        }\\n        for(int i = lo;i<=hi;i++){\\n            if(!bitmask && i==0) continue;\\n            int repeated = bitmask & (1<<i);\\n            if(repeated){\\n                cnt += count(idx+1,tight&&(i==hi),bitmask,true,num);\\n            }\\n            else{\\n                cnt += count(idx+1,tight&&(i==hi),bitmask|(1<<i),isrepeated,num);\\n            }\\n        }\\n        return dp[idx][tight][bitmask][isrepeated] = cnt;\\n    }\\n\\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        string num = to_string(n);\\n        return count(0,true,0,false,num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[10][2][1025][2]; //2^10 = 1024 for bitmask\\n\\n    int count(int idx,bool tight,int bitmask,bool isrepeated,string& num){\\n        if(idx==num.size()){\\n            return (isrepeated&&bitmask)?1:0;\\n        }\\n        if(dp[idx][tight][bitmask][isrepeated]!=-1) return dp[idx][tight][bitmask][isrepeated];\\n        int lo = 0;\\n        int hi = tight?(num[idx]-\\'0\\'):9;\\n        int cnt = 0;\\n        if(!bitmask){\\n            cnt += count(idx+1,false,bitmask,isrepeated,num);\\n        }\\n        for(int i = lo;i<=hi;i++){\\n            if(!bitmask && i==0) continue;\\n            int repeated = bitmask & (1<<i);\\n            if(repeated){\\n                cnt += count(idx+1,tight&&(i==hi),bitmask,true,num);\\n            }\\n            else{\\n                cnt += count(idx+1,tight&&(i==hi),bitmask|(1<<i),isrepeated,num);\\n            }\\n        }\\n        return dp[idx][tight][bitmask][isrepeated] = cnt;\\n    }\\n\\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        string num = to_string(n);\\n        return count(0,true,0,false,num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218805,
                "title": "i-spent-4-hours-on-this-shit-i-hate-my-life",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIts basically just math, Im gonna die \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nlet n be a K digit integer\\nWe will count the total number of non-duplicated integers\\nWe split them up in 2 cases by counting <K digits and K digits\\n\\nFor < K digits\\nI did abit of trial and error for this but the general form that you would get would be for each k number of digits\\n$$9\\\\bullet\\\\sum^{K-3}_{i=0}\\\\Pi^9_{j=9-i}j + 9$$\\n\\nSo how i visualised it was for e.g. we wamt let K = 5 so we want to find all possible non-duplicated integers <10 000 i.e. [1,9 999]\\n\\nFrom 1000 to 9999 we have 10000 - 1000 = 9000 integers \\nwe fix the 1st digit so we have 1XXX then for the 2nd digit we have 9 remaining unique digits so on and so forth. Resulting in 9x8x7 integers\\nNow we permutate the first digit to be between 1 to 9\\nHence from 1000 - 9999 we have 9x9x8x7 non-duplicated integers\\n\\nSimilarly, from 100 - 999 we have 9x9x8\\nfrom 10 - 99 we have 9x9\\nfrom 1 - 9 we have 9\\n\\nNow if we take the sum we get \\n9x9x8x7 9x9x8 + 9x9 + 9\\n\\n\\nFor a fixed length of K digits\\nWe store each leading digit in seen\\nThen we build the integer up by iterating from 0 (if not first digit) and 1(if first digit) up to the leading digit. If any of the digit was seen before then we skip it. We then permutate the remaining digits left. If the leading digit was already seen we can stop as we know it will no longer give us any non-duplicated integers.\\n\\nE.g. if we let n = 13579\\nWe will calculate this in parts as well specifically from \\n1XXXX - 1XXXX\\n10XXX - 12XXX\\n130XX - 134XX\\n1350X - 1356X\\n1357X - 13578\\n(remember last number not inclusive, pretty sure you can tweak the code to include)\\n\\nAt the start we have 10 000, since the leading digit is the first digit and is 1 we skip it. We then store 1 inside seen. Now we have fixed the first digit.\\n\\nFor the second digit, we start building from 0 to 2 so we have 10XXX, 11XXX and 12XXX but since 11XXX is already a duplicate we will skip it. Giving us 2x8x7x6 non-duplicated integers. Now we fix the second digit to be 3\\n\\nFor the third digit we will consider 130XX, 131XX, 132XX, 133XX, 134XX, w can see that 131XX and 133XX already contains duplicates and hence we will skip them. Giving us 3x7x6. Then we fix the third digit to be 5\\n\\nSo on and so forth, resulting in a total of 2x8x7x6 + 3x7x6 + 4x6 + 5\\n\\nNow we take the sum \\n9x9x8x7 9x9x8 + 9x9 + 9 + \\n2x8x7x6 + 3x7x6 + 4x6 + 5 + 1 (to include n=13579) = 6102\\nWe return 13579 - 6102 = 7477 which is the ans\\n  \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nI believe it is $$O(log_{10}n)$$ as we are counting the number of digits\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nI think it is $$O(log_{10}n)$$ as well? as we only store the number of digits in both seen and numList\\n# Code\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        temp = n\\n        numList = []\\n        while temp > 0:\\n            numList.insert(0, temp%10)\\n            temp //=10\\n        digits = len(numList)\\n        totalNum = 0\\n        res = 0\\n        # less than K digits\\n        for j in range(digits-1, 0, -1):\\n            res = 9\\n            for k in range(9, 9-j+1,-1):\\n                res *= k\\n            totalNum += res\\n        #K digits\\n        seen = {}\\n        for i in range(0,digits):\\n            leadingDigit = numList[i]\\n            remainingDigits = len(numList) - i - 1\\n            for j in range(1 if i==0 else 0, leadingDigit):\\n                if j in seen:\\n                    continue\\n                res = 1\\n                for k in range(9-i, 9-i-remainingDigits,-1):\\n                    res *= k\\n                totalNum += res\\n            if leadingDigit in seen:\\n                break\\n            seen[leadingDigit] = 1\\n        seen = {}\\n        for num in numList:\\n            if num in seen:\\n                return n-totalNum\\n            seen[num] = 1\\n        return n-totalNum - 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        temp = n\\n        numList = []\\n        while temp > 0:\\n            numList.insert(0, temp%10)\\n            temp //=10\\n        digits = len(numList)\\n        totalNum = 0\\n        res = 0\\n        # less than K digits\\n        for j in range(digits-1, 0, -1):\\n            res = 9\\n            for k in range(9, 9-j+1,-1):\\n                res *= k\\n            totalNum += res\\n        #K digits\\n        seen = {}\\n        for i in range(0,digits):\\n            leadingDigit = numList[i]\\n            remainingDigits = len(numList) - i - 1\\n            for j in range(1 if i==0 else 0, leadingDigit):\\n                if j in seen:\\n                    continue\\n                res = 1\\n                for k in range(9-i, 9-i-remainingDigits,-1):\\n                    res *= k\\n                totalNum += res\\n            if leadingDigit in seen:\\n                break\\n            seen[leadingDigit] = 1\\n        seen = {}\\n        for num in numList:\\n            if num in seen:\\n                return n-totalNum\\n            seen[num] = 1\\n        return n-totalNum - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507269,
                "title": "c-standard-digit-dp",
                "content": "This is a standard digit DP problem.\\n\\nA few words on digit DP for those who are not so familiar with the concept. The basic idea here is to group the sequences into subsets or sub-problems, then apply regular top-down DP on each sub-problem. Here by \"sequences\" I just mean any integer within the range `[1,n]` , so there are `n` such sequences. They all have length (in terms of number of digits) equal to number of digits in `n`, b/c we will be including leading zeros.\\n\\nObviously in brute-force we can enumerate each sequence and check if it meets the condition, but this will explode in time complexity since `n` is very large. Instead we divide them into subsets. How? A very natural way is to group sequences sharing the same prefix into the same set. For instance, the two sequences `1123` and `1145` can be thought of as belonging to the same subset, since they both starts w/t the prefix `11`. Now the prefix can have different lengths, so we start with the left-most bit i.e. the most significant bit, we use a parameter `pos` to represent the current bit we are at, so `pos` equals to the length of the prefix that we have built so far. In the previous example, we can say the prefix `11` is at position `pos=2`.\\n\\nAn additional variable `tight`, which is boolean, is used to make it more convenient to expand the prefix; when `tight=1` it means the prefix so far exactly matchs the prefix part in `n`, therefore at `pos+1` the digit we can choose are limited to the corresponding digit in `n`. For instance if `n=12345` and we are currently at `pos=3` with `tight=1`, this would indicate the prefix we have built so far is `123`, for the next position, we cannot choose any digit larger than `4`, because if we choose say `1235` then it would have already be out-of-bounds. When `tight=0` we can choose any digit from 0 to 9. \\n\\nThese two variables `pos` and `tight` are standard for any digit DP solution, please refer to better tutorials e.g. [this one](https://codeforces.com/blog/entry/53960) for more detailed explanations. With `pos` and `tight` we are able to build the complete search tree from left to right in a very standard DFS framework e.g.:\\n\\n```\\nint dfs (int pos, int tight, ...) {\\n\\t// return leaf node\\n\\t// memoization\\n\\t\\n\\tint res = 0;\\n\\tint limit = tight==1 ? nums[pos] : 9;\\n\\tfor (int i = 0; i <= limit; ++i) {\\n\\t\\t// do sth.\\n\\t\\tres += dfs(pos+1, newTight, ...);\\n\\t}\\n\\t\\n\\treturn dp[pos][tight][...] = res;\\n}\\n```\\n\\nHere for each node at position = `pos`, we just enumerate all possible digits from 0~9 or from 0 ~ `limit` depending on the `tight` condition. The digit `i` is put into position `pos+1` to expand the prefix and it is hence a child node of the current node. To return the solution of the sub-problem associated with the current node, we just accumulate from the solutions over all of its child sub-trees. This is therefore very standard top-down DP approach.\\n\\nA node in the tree is therefore identifiable by its prefix sequence. But in this way each node is distinct, and there are way too many nodes for memoization to work properly. Therefore we need to apply a further grouping on the prefixes. We define a mapping function `f(p)->state` where `p` is a prefix and `state` is an integer value of limited range. For instance, for LC#233 counting the digit 1 in integers, we can let `state` = number of 1\\'s in the prefix.\\n\\nHere for this problem, notice that if we have two prefixes e.g. `22345***` and `23524***`, they are similar in the sense that they both contain two 2\\'s i.e. they both have repeated digits; moreover, they both have used the same digits `2,3,4,5`, although in different ordering. So these two prefixes (and all the descendant full sequences containing these prefixes) should be grouped into the same sub-problem.\\n\\nConcretely, we actually need to use a 2d state variable, `(rep, mask)`. Here `rep` is a boolean value indicating whether there has already been at least one repeated digit in the prefix built so far, and `mask` is a bit-mask indicating which digits have been used in the prefix. For the previous example the state for the two prefixes should be `rep=1` and `mask=0000111100` indicating the usage of digits `2,3,4,5`. Thefore, the mapping function from prefixes to states are many-to-one, each state now identifies a sub-problem containing many sequences which share similar prefixes. It should be noted that the mapping must be chosen in such a way as to ensure the sub-problems won\\'t overlap. Now we apply memoization on these sub-problems, since the number of these states will be limited, and these values will be shared and re-used throughout the DFS on the search tree.\\n\\nIn summary, the sub-problem (i.e. a specific subset of sequences grouped together) in digit DP is indexed by a set of variables `(pos, tight, state)`. The `dp[pos][tight][state]` value function therefore stores the solution to the corresponding sub-problem, i.e. the original problem but on the sub-set of sequences. When considering the state transitions, since `pos` and `tight` are used just for building the search tree, their transitions are always the same for different problems; in particular:\\n```\\nint new_pos = pos+1;\\nint new_tight = (tight == 1 && i == limit ) ? 1 : 0;\\n```\\nHere we always transition into the child nodes by `pos+1` and compute the correct `tight` variable. The problem-specific aspect lies with the `state` variable and its transitions. Here in this problem, using `(rep, mask)` as the state, the digit DP solution is as follows in C++:\\n\\n```\\nclass Solution {\\n    vector<int> nums;\\n    int s;\\n    // dp[pos][tight][rep][mask]\\n\\t// if rep=1 means the prefix sequence contains at least one repeated digit\\n    int dp[10][2][2][1024];\\npublic:\\n    int dfs(int pos, int tight, int rep, int mask) {\\n\\t\\t// at leaf node exclude the cases where mask==0 i.e. leading zeros\\n\\t\\t// if rep=1 means a sequence with at least one repeated digit has been found, so return 1;\\n        if (pos == s)\\n            return ( mask != 0 && rep ) ? 1 : 0;\\n        \\n\\t\\t// memoization\\n        if (dp[pos][tight][rep][mask] != -1)\\n            return dp[pos][tight][rep][mask];\\n        \\n        int limit = tight == 1 ? nums[pos] : 9;\\n        int res = 0;\\n        for (int i = 0; i <= limit; ++i) {\\n            int newTight = (tight == 1 && i == limit) ? 1 : 0;\\n\\t\\t\\t\\n\\t\\t\\t// if mask==0 means it\\'s all leading zeros, so when i=0 it\\'s still leading zero, not counted;\\n\\t\\t\\t// otherwise set the corresponding bit of i to 1 in newMask\\n            int newMask = (mask == 0 && i == 0) ? mask : mask | 1 << i;\\n\\t\\t\\t\\n\\t\\t\\t// exclude cases of leading zero here as well\\n\\t\\t\\t// for other cases, if rep==1 means there has already been repeated digits, so newRep = 1 also\\n\\t\\t\\t// otherwise, check if i has been set in `mask` by the bitwise AND operation; if so, newRep = 1;\\n            int newRep = (mask == 0 && i == 0) ? 0 : rep | bool(mask & 1 << i);\\n            \\n            res += dfs(pos+1, newTight, newRep, newMask);\\n        }\\n        \\n        return dp[pos][tight][rep][mask] = res;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        while (n > 0) {\\n            nums.push_back(n % 10);\\n            n = n / 10;\\n        }\\n        s = nums.size();\\n        reverse(nums.begin(), nums.end());\\n        memset(dp, -1, sizeof(dp));\\n\\t\\t\\n\\t\\t// the original full problem is represented by an empty prefix\\n\\t\\t// so pos=0\\n\\t\\t// tight=1 b/c the first digit we place in the prefix must be bounded by nums[0] i.e. the msb in n, so it\\'s tight condition is set.\\n\\t\\t// rep=0 and mask=0 b/c in empty prefix there is no repetion, no digit used\\n        return dfs(0, 1, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint dfs (int pos, int tight, ...) {\\n\\t// return leaf node\\n\\t// memoization\\n\\t\\n\\tint res = 0;\\n\\tint limit = tight==1 ? nums[pos] : 9;\\n\\tfor (int i = 0; i <= limit; ++i) {\\n\\t\\t// do sth.\\n\\t\\tres += dfs(pos+1, newTight, ...);\\n\\t}\\n\\t\\n\\treturn dp[pos][tight][...] = res;\\n}\\n```\n```\\nint new_pos = pos+1;\\nint new_tight = (tight == 1 && i == limit ) ? 1 : 0;\\n```\n```\\nclass Solution {\\n    vector<int> nums;\\n    int s;\\n    // dp[pos][tight][rep][mask]\\n\\t// if rep=1 means the prefix sequence contains at least one repeated digit\\n    int dp[10][2][2][1024];\\npublic:\\n    int dfs(int pos, int tight, int rep, int mask) {\\n\\t\\t// at leaf node exclude the cases where mask==0 i.e. leading zeros\\n\\t\\t// if rep=1 means a sequence with at least one repeated digit has been found, so return 1;\\n        if (pos == s)\\n            return ( mask != 0 && rep ) ? 1 : 0;\\n        \\n\\t\\t// memoization\\n        if (dp[pos][tight][rep][mask] != -1)\\n            return dp[pos][tight][rep][mask];\\n        \\n        int limit = tight == 1 ? nums[pos] : 9;\\n        int res = 0;\\n        for (int i = 0; i <= limit; ++i) {\\n            int newTight = (tight == 1 && i == limit) ? 1 : 0;\\n\\t\\t\\t\\n\\t\\t\\t// if mask==0 means it\\'s all leading zeros, so when i=0 it\\'s still leading zero, not counted;\\n\\t\\t\\t// otherwise set the corresponding bit of i to 1 in newMask\\n            int newMask = (mask == 0 && i == 0) ? mask : mask | 1 << i;\\n\\t\\t\\t\\n\\t\\t\\t// exclude cases of leading zero here as well\\n\\t\\t\\t// for other cases, if rep==1 means there has already been repeated digits, so newRep = 1 also\\n\\t\\t\\t// otherwise, check if i has been set in `mask` by the bitwise AND operation; if so, newRep = 1;\\n            int newRep = (mask == 0 && i == 0) ? 0 : rep | bool(mask & 1 << i);\\n            \\n            res += dfs(pos+1, newTight, newRep, newMask);\\n        }\\n        \\n        return dp[pos][tight][rep][mask] = res;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        while (n > 0) {\\n            nums.push_back(n % 10);\\n            n = n / 10;\\n        }\\n        s = nums.size();\\n        reverse(nums.begin(), nums.end());\\n        memset(dp, -1, sizeof(dp));\\n\\t\\t\\n\\t\\t// the original full problem is represented by an empty prefix\\n\\t\\t// so pos=0\\n\\t\\t// tight=1 b/c the first digit we place in the prefix must be bounded by nums[0] i.e. the msb in n, so it\\'s tight condition is set.\\n\\t\\t// rep=0 and mask=0 b/c in empty prefix there is no repetion, no digit used\\n        return dfs(0, 1, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481034,
                "title": "c-digit-dp-total-nonrepeating",
                "content": "* `bound` variable ensures that we dont overshoot the given `n` value at any time.\\n\\n* `mask` check which digits are taken and which are yet to be taken.\\n\\n* `pos` tracks the length of orignal number.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[11][1025][2] ;\\n    string ref ;\\n    int solve(int pos, int mask , int bound){\\n        if(pos >= ref.size()) return (mask != 0) ;\\n        if(dp[pos][mask][bound] != -1) return dp[pos][mask][bound] ;\\n        \\n        int res = 0 , maxi = bound ? (ref[pos]-\\'0\\') : 9 ;\\n        for(int i = 0 ; i <= maxi ; ++i ){\\n            if(mask & (1 << i)) continue ;\\n            int newMask = (!i and !mask) ? mask : mask | (1 << i) ; // dont put leading zeros\\n            \\n            if(bound) res += solve(pos + 1 , newMask , (ref[pos]-\\'0\\') == i) ;\\n            else res += solve(pos + 1 , newMask , 0) ;\\n        }\\n        \\n        return dp[pos][mask][bound] = res ;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp,-1,sizeof(dp)) ;\\n        //answer will be total  positive integers - the ones where no repetition is allowed \\n        ref = to_string(n);\\n        int nonRepeating = solve(0,0,1) ;\\n        return n - nonRepeating ;\\n    }\\n};\\n```\\n\\n\\n* [Refer This Video For Digit Dp Intro](https://www.youtube.com/watch?v=wWfGCIL0AfU)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[11][1025][2] ;\\n    string ref ;\\n    int solve(int pos, int mask , int bound){\\n        if(pos >= ref.size()) return (mask != 0) ;\\n        if(dp[pos][mask][bound] != -1) return dp[pos][mask][bound] ;\\n        \\n        int res = 0 , maxi = bound ? (ref[pos]-\\'0\\') : 9 ;\\n        for(int i = 0 ; i <= maxi ; ++i ){\\n            if(mask & (1 << i)) continue ;\\n            int newMask = (!i and !mask) ? mask : mask | (1 << i) ; // dont put leading zeros\\n            \\n            if(bound) res += solve(pos + 1 , newMask , (ref[pos]-\\'0\\') == i) ;\\n            else res += solve(pos + 1 , newMask , 0) ;\\n        }\\n        \\n        return dp[pos][mask][bound] = res ;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp,-1,sizeof(dp)) ;\\n        //answer will be total  positive integers - the ones where no repetition is allowed \\n        ref = to_string(n);\\n        int nonRepeating = solve(0,0,1) ;\\n        return n - nonRepeating ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428792,
                "title": "c-let-backtracking-do-it-s-work-clean-and-crisp-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(long curr, int mask, int n) {\\n        if(curr > n) return 0;\\n        int ans=1; //since n < 123456789 and all its permutations therefore 1 number always exists\\n        for(int i=0; i<10; i++) {\\n            if(!mask and !i) continue; //leading 0 not allowed\\n            if(mask & (1<<i)) continue; //repetition not allowed\\n            ans+=dfs(curr*10+i,mask+(1<<i),n);\\n        }\\n        return ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        return n+1-dfs(0,0,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(long curr, int mask, int n) {\\n        if(curr > n) return 0;\\n        int ans=1; //since n < 123456789 and all its permutations therefore 1 number always exists\\n        for(int i=0; i<10; i++) {\\n            if(!mask and !i) continue; //leading 0 not allowed\\n            if(mask & (1<<i)) continue; //repetition not allowed\\n            ans+=dfs(curr*10+i,mask+(1<<i),n);\\n        }\\n        return ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        return n+1-dfs(0,0,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014132,
                "title": "c-permutation-with-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    int permutation(int m, int n) {\\n        // m number with len n\\n        // m * (m - 1) * (m - 2) .. * (m - n + 1) \\n        int res = 1;\\n        while (n) {\\n            res *= m;\\n            m--;\\n            n--;\\n        }\\n        return res;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        vector<int> digits; // to store each digit\\n        for (int x = n + 1; x > 0; x /= 10) {\\n            digits.push_back(x % 10);\\n        }\\n        // make it from high to low\\n        // e.g., n=137 => [7, 1, 3] => [1, 3, 7]\\n        reverse(digits.begin(), digits.end());\\n        \\n        // get the # of digits\\n        int size = digits.size();\\n        \\n        // to count the number without duplicates\\n        int res = 0;\\n        \\n        // one digit to (size - 1) digits\\n        // e.g, n=8759 (4 digits), ignore leading 8 here\\n        // so the last 3 digits have 9 * (9 * 8) permutations\\n        // the last 2 digits have 9 * (9) permutations\\n        // the last 1 digits have 9 permutations\\n        for (int i = 1; i < size; i++) {\\n            res += 9 * permutation(9, i - 1);\\n        }\\n        \\n        // consider the leading digit\\n        unordered_set<int> st; // to store the leading fixed one\\n        // for each digit\\n        for (int i = 0; i < size; i++) {\\n            // i = 0 (first digit) e.g., n=8759 | the free will be\\n            // 1xxx, 2xxx, ..., 7xxx\\n            // i > 0 e.g., n=8759 | the free will be\\n            // 80xx, 81xx, ...86xx\\n            for (int j = i > 0 ? 0 : 1; j < digits[i];j++) {\\n                // the current digit should not duplicated with the fixed one\\n                if (st.find(j) != st.end()) continue;\\n                res += permutation(9 - i, size - i - 1);\\n            }\\n            // if the current leading digit duplicate with previous ones => break\\n            if (st.find(digits[i]) != st.end()) break;\\n            // insert the current leading digit to the hash table\\n            st.insert(digits[i]);\\n        }\\n        return n - res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int permutation(int m, int n) {\\n        // m number with len n\\n        // m * (m - 1) * (m - 2) .. * (m - n + 1) \\n        int res = 1;\\n        while (n) {\\n            res *= m;\\n            m--;\\n            n--;\\n        }\\n        return res;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        vector<int> digits; // to store each digit\\n        for (int x = n + 1; x > 0; x /= 10) {\\n            digits.push_back(x % 10);\\n        }\\n        // make it from high to low\\n        // e.g., n=137 => [7, 1, 3] => [1, 3, 7]\\n        reverse(digits.begin(), digits.end());\\n        \\n        // get the # of digits\\n        int size = digits.size();\\n        \\n        // to count the number without duplicates\\n        int res = 0;\\n        \\n        // one digit to (size - 1) digits\\n        // e.g, n=8759 (4 digits), ignore leading 8 here\\n        // so the last 3 digits have 9 * (9 * 8) permutations\\n        // the last 2 digits have 9 * (9) permutations\\n        // the last 1 digits have 9 permutations\\n        for (int i = 1; i < size; i++) {\\n            res += 9 * permutation(9, i - 1);\\n        }\\n        \\n        // consider the leading digit\\n        unordered_set<int> st; // to store the leading fixed one\\n        // for each digit\\n        for (int i = 0; i < size; i++) {\\n            // i = 0 (first digit) e.g., n=8759 | the free will be\\n            // 1xxx, 2xxx, ..., 7xxx\\n            // i > 0 e.g., n=8759 | the free will be\\n            // 80xx, 81xx, ...86xx\\n            for (int j = i > 0 ? 0 : 1; j < digits[i];j++) {\\n                // the current digit should not duplicated with the fixed one\\n                if (st.find(j) != st.end()) continue;\\n                res += permutation(9 - i, size - i - 1);\\n            }\\n            // if the current leading digit duplicate with previous ones => break\\n            if (st.find(digits[i]) != st.end()) break;\\n            // insert the current leading digit to the hash table\\n            st.insert(digits[i]);\\n        }\\n        return n - res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630556,
                "title": "c-digit-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    string num;\\n    int len;\\n    int setKthBit(int n, int k)\\n    {\\n        return ((1 << (k)) | n);\\n    }\\n    bool isKthBitSet(int n, int k)\\n    {\\n        return ( n & (1 << k) );\\n    }\\n\\n    // mask reprsents the set of numbers already in the number //\\n    // like for 1,2,4  maks = 00000001011 // \\n    // we can also use an explicit set but that will be difficult to cache and as we can have only 10 numbers that are 0-9 therefore only 2^11 will be used 2048   \\n    int memo[12][2][5000][2];\\n    // to find the count of numbers with unique digits //\\n    int dp(int n, bool tight, int mask, bool leadingzero){\\n        \\n        // base case //\\n        if(n==0){\\n            int base = 0;\\n            int ub = tight ? num[len-1-n]-\\'0\\' : 9;\\n            for(int i=0; i<=ub; ++i){\\n                if(!isKthBitSet(mask, i))\\n                base += 1;\\n            }   \\n            return base;\\n        }\\n        \\n        if(memo[n][tight][mask][leadingzero]!=-1)\\n            return memo[n][tight][mask][leadingzero];\\n        \\n        // recc //\\n        int res = 0;\\n        int ub = tight ? num[len-1-n]-\\'0\\' : 9;\\n       \\n        \\n        for(int i=0; i<=ub; ++i){\\n            if(i==0){// for leading zero we wont set it in the mask // eg 00035 is actually unique but as there are 3 zeros leading it wont be unique therfore to handle these type of cases//\\n                if(leadingzero)\\n                res += dp(n-1, tight && i==ub, mask, leadingzero);\\n                else{\\n                    if(!isKthBitSet(mask, i))\\n                    res += dp(n-1, tight && i==ub, setKthBit(mask, i), leadingzero);\\n                }   \\n                \\n            }\\n            else{\\n                if(!isKthBitSet(mask, i)){\\n                    res += dp(n-1, tight && i==ub, setKthBit(mask, i), false);\\n                } \\n            }\\n        }\\n        return memo[n][tight][mask][leadingzero] = res;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        \\n        memset(memo, -1, sizeof memo);\\n        \\n        num = to_string(n);\\n        len = num.length();\\n        \\n        int ans = dp(len-1, true, 0, true);\\n        \\n        ans = n+1 - ans ; \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string num;\\n    int len;\\n    int setKthBit(int n, int k)\\n    {\\n        return ((1 << (k)) | n);\\n    }\\n    bool isKthBitSet(int n, int k)\\n    {\\n        return ( n & (1 << k) );\\n    }\\n\\n    // mask reprsents the set of numbers already in the number //\\n    // like for 1,2,4  maks = 00000001011 // \\n    // we can also use an explicit set but that will be difficult to cache and as we can have only 10 numbers that are 0-9 therefore only 2^11 will be used 2048   \\n    int memo[12][2][5000][2];\\n    // to find the count of numbers with unique digits //\\n    int dp(int n, bool tight, int mask, bool leadingzero){\\n        \\n        // base case //\\n        if(n==0){\\n            int base = 0;\\n            int ub = tight ? num[len-1-n]-\\'0\\' : 9;\\n            for(int i=0; i<=ub; ++i){\\n                if(!isKthBitSet(mask, i))\\n                base += 1;\\n            }   \\n            return base;\\n        }\\n        \\n        if(memo[n][tight][mask][leadingzero]!=-1)\\n            return memo[n][tight][mask][leadingzero];\\n        \\n        // recc //\\n        int res = 0;\\n        int ub = tight ? num[len-1-n]-\\'0\\' : 9;\\n       \\n        \\n        for(int i=0; i<=ub; ++i){\\n            if(i==0){// for leading zero we wont set it in the mask // eg 00035 is actually unique but as there are 3 zeros leading it wont be unique therfore to handle these type of cases//\\n                if(leadingzero)\\n                res += dp(n-1, tight && i==ub, mask, leadingzero);\\n                else{\\n                    if(!isKthBitSet(mask, i))\\n                    res += dp(n-1, tight && i==ub, setKthBit(mask, i), leadingzero);\\n                }   \\n                \\n            }\\n            else{\\n                if(!isKthBitSet(mask, i)){\\n                    res += dp(n-1, tight && i==ub, setKthBit(mask, i), false);\\n                } \\n            }\\n        }\\n        return memo[n][tight][mask][leadingzero] = res;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        \\n        memset(memo, -1, sizeof memo);\\n        \\n        num = to_string(n);\\n        len = num.length();\\n        \\n        int ans = dp(len-1, true, 0, true);\\n        \\n        ans = n+1 - ans ; \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018557,
                "title": "python-easy-follow",
                "content": "the basic idea here is computing the non-repeat numbers first and then use N minus the non-repeat numbers.\\nsuppose N is abcde, compute non- repeat numbers smaller than a0000. then compute non-repeat number between a0000 and ab000, and so on.\\n\\n\\'\\'\\'\\n\\n\\tdef numDupDigitsAtMostN(self, N: int) -> int:\\n        def helper(s):\\n            non_repeat = 0\\n            carry = set()\\n            for i in range(len(s)-1):\\n                if s[i] in carry:\\n                    return non_repeat\\n                carry.add(s[i])\\n                tem = int(s[i+1])\\n                for _ in range(int(s[i+1])):\\n                    if str(_) in carry:\\n                          tem -= 1\\n                tem = max(tem, 0)\\n                for j in range(i+2, len(s)):\\n                    tem *= (10-j)\\n                non_repeat += tem\\n            return non_repeat + (s[-1] not in carry)\\n        num = str(N)\\n        non_repeat = 0\\n\\t\\t# compute non- repeat numbers smaller than a0000\\n        for l in range(1, len(num) + 1):\\n            if l == len(num):\\n                 pre, i = int(num[0]) -1, 1\\n            else:\\n                pre, i = 9, 1\\n            while i < l:\\n                pre *= (10 - i)\\n                i += 1\\n            non_repeat += pre        \\n        return N - non_repeat - helper(num)\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "the basic idea here is computing the non-repeat numbers first and then use N minus the non-repeat numbers.\\nsuppose N is abcde, compute non- repeat numbers smaller than a0000. then compute non-repeat number between a0000 and ab000, and so on.\\n\\n\\'\\'\\'\\n\\n\\tdef numDupDigitsAtMostN(self, N: int) -> int:\\n        def helper(s):\\n            non_repeat = 0\\n            carry = set()\\n            for i in range(len(s)-1):\\n                if s[i] in carry:\\n                    return non_repeat\\n                carry.add(s[i])\\n                tem = int(s[i+1])\\n                for _ in range(int(s[i+1])):\\n                    if str(_) in carry:\\n                          tem -= 1\\n                tem = max(tem, 0)\\n                for j in range(i+2, len(s)):\\n                    tem *= (10-j)\\n                non_repeat += tem\\n            return non_repeat + (s[-1] not in carry)\\n        num = str(N)\\n        non_repeat = 0\\n\\t\\t# compute non- repeat numbers smaller than a0000\\n        for l in range(1, len(num) + 1):\\n            if l == len(num):\\n                 pre, i = int(num[0]) -1, 1\\n            else:\\n                pre, i = 9, 1\\n            while i < l:\\n                pre *= (10 - i)\\n                i += 1\\n            non_repeat += pre        \\n        return N - non_repeat - helper(num)\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 560346,
                "title": "python-digit-dp-pattern-for-similar-questions",
                "content": "Theory: https://codeforces.com/blog/entry/53960\\n\\nMore of the same approach:\\n[902. Numbers At Most N Given Digit Set](https://leetcode.com/problems/numbers-at-most-n-given-digit-set/discuss/559624/python-digit-dp)\\n[788. Rotated Digits](https://leetcode.com/problems/rotated-digits/discuss/560601/python-digit-dp)\\n[1397. Find All Good Strings](https://leetcode.com/problems/find-all-good-strings/discuss/560841/Python-Digit-DP)\\n[233. Number of Digit One](https://leetcode.com/problems/number-of-digit-one/discuss/560876/Python-Digit-DP)\\n[357. Count Numbers with Unique Digits](https://leetcode.com/problems/count-numbers-with-unique-digits/discuss/560898/Python-Digit-DP)\\n[600. Non-negative Integers without Consecutive Ones](https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/discuss/584350/Python-Digit-DP-(Pattern-For-Similar-Questions))\\n\\nAt each recursive call (adding digit to less significant position) compute:\\n- isPrefix - if the new number is the prefix of N\\n- isBigger - if the new number will be bigger than N when we reach final position\\n- digits - current digits of the new number\\n- repeated - if there is already a repeated digit\\nOptimization - if there is already a repeated number and the current number cannot be bigger than N when we reach the last position we can add 10 (for 10 digits) to the result and every subresult gets multiplied by 10.\\n```\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        N = list(map(int, str(N)))\\n\\n        @functools.lru_cache(None)\\n        def dp(pos, isPrefix, isBigger, digits, repeated):\\n            if pos == len(N):\\n                return 0\\n            if repeated and not isPrefix and not isBigger:\\n                return 10 + 10 * dp(pos + 1, False, False, digits, True)\\n            result = 0\\n            for i in range(0 if pos > 0 else 1, 10):\\n                _isPrefix = isPrefix and i == N[pos]\\n                _isBigger = isBigger or (isPrefix and i > N[pos])\\n                _repeated = repeated\\n                if (digits >> i) & 1 == 1:\\n                    _repeated = True\\n                if _repeated and not (pos == len(N) - 1 and _isBigger):\\n                    result += 1\\n                _digits = digits | (1 << i)\\n                result += dp(pos + 1, _isPrefix, _isBigger, _digits, _repeated)\\n            return result\\n        return dp(0, True, False, 0, False)\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        N = list(map(int, str(N)))\\n\\n        @functools.lru_cache(None)\\n        def dp(pos, isPrefix, isBigger, digits, repeated):\\n            if pos == len(N):\\n                return 0\\n            if repeated and not isPrefix and not isBigger:\\n                return 10 + 10 * dp(pos + 1, False, False, digits, True)\\n            result = 0\\n            for i in range(0 if pos > 0 else 1, 10):\\n                _isPrefix = isPrefix and i == N[pos]\\n                _isBigger = isBigger or (isPrefix and i > N[pos])\\n                _repeated = repeated\\n                if (digits >> i) & 1 == 1:\\n                    _repeated = True\\n                if _repeated and not (pos == len(N) - 1 and _isBigger):\\n                    result += 1\\n                _digits = digits | (1 << i)\\n                result += dp(pos + 1, _isPrefix, _isBigger, _digits, _repeated)\\n            return result\\n        return dp(0, True, False, 0, False)\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 332462,
                "title": "solution-in-python-3-beats-99",
                "content": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n    \\tT = [9,261,4725,67509,831429,9287109,97654149,994388229]\\n    \\tt = [99,999,9999,99999,999999,9999999,99999999,999999999]\\n    \\tif N < 10:\\n    \\t\\treturn 0\\n    \\tL = len(str(N))\\n    \\tm, n = [1], []\\n    \\tg = 11-L\\n    \\tfor i in range(L):\\n    \\t\\tn.append(int(str(N)[i]))\\n    \\t\\tm.append(g)\\n    \\t\\tg = g*(12-L+i)\\n    \\tS = 0\\n    \\tfor i in range(L):\\n    \\t\\tif len(set(n[:L-i-1])) != len(n)-i-1:\\n    \\t\\t\\tcontinue\\n    \\t\\tk = 0\\n    \\t\\tfor j in range(10):\\n    \\t\\t\\tif j not in n[:L-i-1] and j > n[L-i-1]:\\n    \\t\\t\\t\\tk += 1\\n    \\t\\tS += k*m[i]\\n    \\treturn(T[L-2]-(t[L-2]-N-S))\\n\\t\\n- Python 3\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n    \\tT = [9,261,4725,67509,831429,9287109,97654149,994388229]\\n    \\tt = [99,999,9999,99999,999999,9999999,99999999,999999999]\\n    \\tif N < 10:\\n    \\t\\treturn 0\\n    \\tL = len(str(N))\\n    \\tm, n = [1], []\\n    \\tg = 11-L\\n    \\tfor i in range(L):\\n    \\t\\tn.append(int(str(N)[i]))\\n    \\t\\tm.append(g)\\n    \\t\\tg = g*(12-L+i)\\n    \\tS = 0\\n    \\tfor i in range(L):\\n    \\t\\tif len(set(n[:L-i-1])) != len(n)-i-1:\\n    \\t\\t\\tcontinue\\n    \\t\\tk = 0\\n    \\t\\tfor j in range(10):\\n    \\t\\t\\tif j not in n[:L-i-1] and j > n[L-i-1]:\\n    \\t\\t\\t\\tk += 1\\n    \\t\\tS += k*m[i]\\n    \\treturn(T[L-2]-(t[L-2]-N-S))\\n\\t\\n- Python 3\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 281376,
                "title": "c-share-my-dp-solution-count-the-numbers-without-repeated-digits",
                "content": "```\\n// DP State is current digit index, visited bitmask,\\n// comparison of current number to N, left digits.\\nint dp[11][2048][3][11];\\n\\nint sgn(int val) {\\n    return (0 < val) - (val < 0);\\n}\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> N;\\n    \\n    int genAll(int curDigitIndex, int vis, int cmpN, int len) {\\n       if (len == 0) {\\n          return cmpN <= 0;\\n       }\\n       int &res = dp[curDigitIndex][vis][cmpN + 1][len];\\n       if (res != -1) return res;\\n       res = 0;\\n       for (int i = 0; i <= 9; ++i) {\\n          if (curDigitIndex == 0 && i == 0) continue;\\n          if (vis & (1 << i)) continue;\\n           \\n          int nCmpN = cmpN \\n              ? cmpN \\n              : sgn(i - N[curDigitIndex]);\\n           \\n          res += genAll(\\n              curDigitIndex + 1,\\n              vis | (1 << i),\\n              nCmpN,\\n              len - 1);\\n       }\\n       return res;\\n    }\\n\\n    int numDupDigitsAtMostN(int n) {\\n      memset(dp, -1, sizeof(dp));\\n      int nn = n;\\n      while (nn) {\\n          N.push_back(nn % 10);\\n          nn /= 10;\\n      }\\n      reverse(N.begin(), N.end());\\n\\n      int allNonRep = 0;\\n      for (int i = 1; i <= N.size(); ++i) {\\n          int cmpN = i < N.size() ? -1 : 0;\\n\\t\\t  // generate all numbers with non repeating\\n\\t\\t  // digits with \\'i\\' length\\n          allNonRep += genAll(0, 0, cmpN, i);\\n      }\\n      return n - allNonRep;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// DP State is current digit index, visited bitmask,\\n// comparison of current number to N, left digits.\\nint dp[11][2048][3][11];\\n\\nint sgn(int val) {\\n    return (0 < val) - (val < 0);\\n}\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> N;\\n    \\n    int genAll(int curDigitIndex, int vis, int cmpN, int len) {\\n       if (len == 0) {\\n          return cmpN <= 0;\\n       }\\n       int &res = dp[curDigitIndex][vis][cmpN + 1][len];\\n       if (res != -1) return res;\\n       res = 0;\\n       for (int i = 0; i <= 9; ++i) {\\n          if (curDigitIndex == 0 && i == 0) continue;\\n          if (vis & (1 << i)) continue;\\n           \\n          int nCmpN = cmpN \\n              ? cmpN \\n              : sgn(i - N[curDigitIndex]);\\n           \\n          res += genAll(\\n              curDigitIndex + 1,\\n              vis | (1 << i),\\n              nCmpN,\\n              len - 1);\\n       }\\n       return res;\\n    }\\n\\n    int numDupDigitsAtMostN(int n) {\\n      memset(dp, -1, sizeof(dp));\\n      int nn = n;\\n      while (nn) {\\n          N.push_back(nn % 10);\\n          nn /= 10;\\n      }\\n      reverse(N.begin(), N.end());\\n\\n      int allNonRep = 0;\\n      for (int i = 1; i <= N.size(); ++i) {\\n          int cmpN = i < N.size() ? -1 : 0;\\n\\t\\t  // generate all numbers with non repeating\\n\\t\\t  // digits with \\'i\\' length\\n          allNonRep += genAll(0, 0, cmpN, i);\\n      }\\n      return n - allNonRep;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257332,
                "title": "java-0ms-solution-with-explanations",
                "content": "The idea is simple. Count all numbers that do not have repeating digits and less than or equal to `N`. Substract the count from `N` and return. My initial idea was to permutate 10 digits  in [1..`digsCount`] slots (`digsCount` is a number of digits in `N`) and take into account those results of permutation that are <= `N` only. And this worked, but the submition time was  ~1400ms.\\n\\nAn alternative approach uses similar idea but instead of generating permutations we can count them using \\'number of permutations of n objects taken r at a time\\' formula *P(n,r)=n!/(n\\u2212r)!*. \\nBecause digit 0 cannot be a highest digit (number \\'010\\' does not make sence, there is number \\'10\\' instead), we need to adjust the formula *P\\'(n,r) = (n-1) * P(n - 1,r - 1)=(n-1)(n-1)!/(n\\u2212r)!* In this case *n*  equals to 10, *r* is in [1..`digsCount`). *P\\'(r)=9  9! / (10 \\u2212 r)!*\\n\\nLet\\'s consider number 112.\\n`digsCount` = `getDigits(N, digits)` = 3\\n`digits` = [2, 1, 1]\\n`uniq` = `initPermCount(digsCount)` = *P\\'(1) + P\\'(2)* = 9 * 9! / (10 - 1)! + 9 * 9! / (10 - 2)! = 9 + 9 * 9 = 90\\n\\nNow, for every `i` in (`digsCount`..0] we get all the digits `j` smaller than `digits[i]` and that are not used in the higher digits of `N`. We calculate P(10 - `digsCount` + `i`, `i`). Zero cannot be highest digit, so we skip it (`j = (i == digsCount - 1) ? 1 : 0`). If `digits[i]` was used before  it means the original number `N` is not composed of unique digits only, and at this point we stop calculations.\\n\\n`i` = 2, `digits[i]` = 1, `j` = 1, `used` = [] (skip since `j` is not < `digits[i]`)\\n\\n`i` = 1, `digits[i]` = 1, `j` = 0, `used` = [1]\\nSince two digits are used (0 and 1) we calculate permutation using 10 - 2 digits:\\n`uniq` = `uniq` + P(10 - `digsCount` + `i`, `i`) = 90 + P(10-3+1, 1) = 90 + 8 = 98\\n\\n`i` = 1, `digits[i]` = 1, `j` = 1, `used` = [1] (skip since `j` is not < `digits[i]`)\\n\\nFinish calculations since `digits[i]` is in `used`. Since `digits` contains duplicates we do not increment `uniq`;\\n\\nReturn `N` - `uniq` = 112 - 98 = 14\\n\\n```java\\n    public int numDupDigitsAtMostN(int N) {\\n        int[] digits = new int[10];\\n        int digsCount = getDigits(N, digits);\\n\\n        boolean[] used = new boolean[10];\\n        boolean numUniq = true;\\n        int uniq = initPermCount(digsCount);\\n        for (int i = digsCount - 1; i >= 0; i--) {\\n            for (int j = (i == digsCount - 1) ? 1 : 0; j < digits[i]; j++) {\\n                if (!used[j]) {\\n                    uniq += permCount(digsCount, digsCount - i);\\n                }\\n            }\\n            if (used[digits[i]]) {\\n                numUniq = false;\\n                break;\\n            }\\n            used[digits[i]] = true;\\n        }\\n        if (numUniq) {\\n            uniq++;\\n        }\\n        return N - uniq;\\n    }\\n\\n    private int getDigits(int num, int[] digits) {\\n        int i = 0;\\n        while (num > 0) {\\n            digits[i] = num % 10;\\n            num /= 10;\\n            i++;\\n        }\\n        return i;\\n    }\\n\\n    private int initPermCount(int digsCount) {\\n        int sum = 0;\\n        for (int i = 1; i < digsCount; i++) {\\n            sum += 9 * permCount(i, 1);\\n        }\\n        return sum;\\n    }\\n\\n    private int permCount(int n, int reserved) {\\n        int hi = 10 - reserved, lo = hi - (n - reserved);\\n        int res = 1;\\n        while (hi > lo) {\\n            res *= hi--;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int numDupDigitsAtMostN(int N) {\\n        int[] digits = new int[10];\\n        int digsCount = getDigits(N, digits);\\n\\n        boolean[] used = new boolean[10];\\n        boolean numUniq = true;\\n        int uniq = initPermCount(digsCount);\\n        for (int i = digsCount - 1; i >= 0; i--) {\\n            for (int j = (i == digsCount - 1) ? 1 : 0; j < digits[i]; j++) {\\n                if (!used[j]) {\\n                    uniq += permCount(digsCount, digsCount - i);\\n                }\\n            }\\n            if (used[digits[i]]) {\\n                numUniq = false;\\n                break;\\n            }\\n            used[digits[i]] = true;\\n        }\\n        if (numUniq) {\\n            uniq++;\\n        }\\n        return N - uniq;\\n    }\\n\\n    private int getDigits(int num, int[] digits) {\\n        int i = 0;\\n        while (num > 0) {\\n            digits[i] = num % 10;\\n            num /= 10;\\n            i++;\\n        }\\n        return i;\\n    }\\n\\n    private int initPermCount(int digsCount) {\\n        int sum = 0;\\n        for (int i = 1; i < digsCount; i++) {\\n            sum += 9 * permCount(i, 1);\\n        }\\n        return sum;\\n    }\\n\\n    private int permCount(int n, int reserved) {\\n        int hi = 10 - reserved, lo = hi - (n - reserved);\\n        int res = 1;\\n        while (hi > lo) {\\n            res *= hi--;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3603261,
                "title": "java-easy-to-understand-digit-dp-bit-manipulation",
                "content": "```\\nclass Solution {\\n    Integer[][][][] dp;\\n    private int solve(char[] num, int curDig, boolean isStrict, int bit, boolean repeated) {\\n        if(curDig == num.length) return repeated ? 1 : 0;\\n        if(dp[curDig][isStrict ? 1 : 0][bit][repeated ? 1 : 0] != null) return dp[curDig][isStrict ? 1 : 0][bit][repeated ? 1 : 0];\\n        int end = isStrict ? num[curDig] - \\'0\\' : 9;\\n        int res = 0;\\n        for(int i = 0; i <= end; i++) {\\n            if(bit == 0 && i == 0) \\n                res += solve(num, curDig + 1, isStrict && i == end, bit, repeated);\\n            else\\n                res += solve(num, curDig + 1, isStrict && i == end, bit | (1 << i), repeated | (bit & (1 << i)) != 0);\\n        }\\n        return dp[curDig][isStrict ? 1 : 0][bit][repeated ? 1 : 0] = res;\\n    }\\n    public int numDupDigitsAtMostN(int n) {\\n        char[] num = String.valueOf(n).toCharArray();\\n        dp = new Integer[10][2][1025][2];\\n        return solve(num, 0, true, 0, false);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    Integer[][][][] dp;\\n    private int solve(char[] num, int curDig, boolean isStrict, int bit, boolean repeated) {\\n        if(curDig == num.length) return repeated ? 1 : 0;\\n        if(dp[curDig][isStrict ? 1 : 0][bit][repeated ? 1 : 0] != null) return dp[curDig][isStrict ? 1 : 0][bit][repeated ? 1 : 0];\\n        int end = isStrict ? num[curDig] - \\'0\\' : 9;\\n        int res = 0;\\n        for(int i = 0; i <= end; i++) {\\n            if(bit == 0 && i == 0) \\n                res += solve(num, curDig + 1, isStrict && i == end, bit, repeated);\\n            else\\n                res += solve(num, curDig + 1, isStrict && i == end, bit | (1 << i), repeated | (bit & (1 << i)) != 0);\\n        }\\n        return dp[curDig][isStrict ? 1 : 0][bit][repeated ? 1 : 0] = res;\\n    }\\n    public int numDupDigitsAtMostN(int n) {\\n        char[] num = String.valueOf(n).toCharArray();\\n        dp = new Integer[10][2][1025][2];\\n        return solve(num, 0, true, 0, false);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196829,
                "title": "easy-bitmask-dp-solution",
                "content": "\\n\\n# Code\\n```\\nint dp[10][1<<10][2][10];//index digit_set flag length\\n\\nstring s;\\n\\nint solve(int ind,int mask,bool f,int len)\\n{\\n    if(ind>=len)\\n        return 1;\\n    \\n    auto &p=dp[ind][mask][f][len];\\n\\n    if(p!=-1)\\n        return p;\\n    \\n    p=0;\\n\\n    int maxi=9;\\n\\n    if(f&&len==s.size())\\n        maxi=s[ind]-\\'0\\';\\n    \\n    for(int i=0;i<=maxi;++i)\\n    {\\n        if((mask&(1<<i)))\\n            continue;\\n        if(f)\\n        {\\n            bool c=(i==maxi);\\n            p+=solve(ind+1,mask^(1<<i),c,len);\\n            continue;\\n        }\\n        p+=solve(ind+1,mask^(1<<i),false,len);\\n    }\\n    return p;\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        s=to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        int ans=0;\\n\\n        for(int len=1;len<=s.size();++len)\\n        {\\n            int maxi=9;\\n            if(len==s.size())\\n            {\\n                maxi=s[0]-\\'0\\';\\n                for(int i=1;i<=maxi;++i)\\n                {\\n                    bool f=(i==maxi);\\n                    ans+=solve(1,1<<i,f,len);\\n                }\\n            }\\n            else\\n            {\\n                for(int i=1;i<10;++i)\\n                {\\n                    ans+=solve(1,1<<i,false,len);\\n                }\\n            }\\n        }\\n        ans=n-ans;\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nint dp[10][1<<10][2][10];//index digit_set flag length\\n\\nstring s;\\n\\nint solve(int ind,int mask,bool f,int len)\\n{\\n    if(ind>=len)\\n        return 1;\\n    \\n    auto &p=dp[ind][mask][f][len];\\n\\n    if(p!=-1)\\n        return p;\\n    \\n    p=0;\\n\\n    int maxi=9;\\n\\n    if(f&&len==s.size())\\n        maxi=s[ind]-\\'0\\';\\n    \\n    for(int i=0;i<=maxi;++i)\\n    {\\n        if((mask&(1<<i)))\\n            continue;\\n        if(f)\\n        {\\n            bool c=(i==maxi);\\n            p+=solve(ind+1,mask^(1<<i),c,len);\\n            continue;\\n        }\\n        p+=solve(ind+1,mask^(1<<i),false,len);\\n    }\\n    return p;\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        s=to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        int ans=0;\\n\\n        for(int len=1;len<=s.size();++len)\\n        {\\n            int maxi=9;\\n            if(len==s.size())\\n            {\\n                maxi=s[0]-\\'0\\';\\n                for(int i=1;i<=maxi;++i)\\n                {\\n                    bool f=(i==maxi);\\n                    ans+=solve(1,1<<i,f,len);\\n                }\\n            }\\n            else\\n            {\\n                for(int i=1;i<10;++i)\\n                {\\n                    ans+=solve(1,1<<i,false,len);\\n                }\\n            }\\n        }\\n        ans=n-ans;\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066444,
                "title": "0ms-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea of this solution is to count the number of integers with unique digits from 0 to N, which can be done by considering the different cases for each digit. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by looping through the digits of N, starting from the least significant digit. For each digit, we first calculate the number of integers with unique digits that are smaller than N and have the same number of digits as N. For this, we use a helper function `A(m, n)` which calculates the number of numbers with digits 1, 2, ..., m, where each digit can appear at most once and the total number of digits is n. \\n\\nThen, for the current digit, we loop through all possible digits (skipping 0 if the current digit is the most significant digit) and check if it has already been seen. If yes, we break, as it means that all the remaining digits should be the same as the current digit. Otherwise, we increment the count by the number of integers with unique digits that are smaller than N and have the same number of digits as N. \\n\\nFinally, we subtract the count from N to get the result.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        vector<int> digits;\\n        for (int x = n + 1; x > 0; x /= 10) {\\n            digits.push_back(x % 10);\\n        }\\n        reverse(digits.begin(), digits.end());\\n        int ans = 0, k = digits.size();\\n        for (int i = 1; i < k; ++i) {\\n            ans += 9 * A(9, i - 1);\\n        }\\n        set<int> seen;\\n        for (int i = 0; i < k; ++i) {\\n            for (int j = i > 0 ? 0 : 1; j < digits[i]; ++j) {\\n                if (!seen.count(j)) {\\n                    ans += A(9 - i, k - i - 1);\\n                }\\n            }\\n            if (seen.count(digits[i])) {\\n                break;\\n            }\\n            seen.insert(digits[i]);\\n        }\\n        return n - ans;\\n    }\\n    int A(int m, int n) {\\n        return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        vector<int> digits;\\n        for (int x = n + 1; x > 0; x /= 10) {\\n            digits.push_back(x % 10);\\n        }\\n        reverse(digits.begin(), digits.end());\\n        int ans = 0, k = digits.size();\\n        for (int i = 1; i < k; ++i) {\\n            ans += 9 * A(9, i - 1);\\n        }\\n        set<int> seen;\\n        for (int i = 0; i < k; ++i) {\\n            for (int j = i > 0 ? 0 : 1; j < digits[i]; ++j) {\\n                if (!seen.count(j)) {\\n                    ans += A(9 - i, k - i - 1);\\n                }\\n            }\\n            if (seen.count(digits[i])) {\\n                break;\\n            }\\n            seen.insert(digits[i]);\\n        }\\n        return n - ans;\\n    }\\n    int A(int m, int n) {\\n        return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760545,
                "title": "100-faster-solution-using-math-and-recursion-tc-o-1-c-explained",
                "content": "**Please upvote if you like my solution .**\\n```\\nclass Solution {\\npublic:\\n    // to return factorial starting at st and multiplying till t no of times\\n    int fac(int st,int t){\\n        int ans = 1;\\n        while(t){\\n            ans *= st;\\n            st--;\\n            t--;\\n        }\\n        return ans;\\n    }\\n    // mask will create mask over digits fixed\\n    vector<bool> mask;\\n    // we are counting numbers with 0 duplicate digits\\n    int solve(vector<int> &dig, int ind, int st){\\n        if(ind == dig.size()) return 1;\\n        int ans = 0;\\n        if(ind == 0){\\n            // 0 cannot be used\\n            for(int i=1;i<dig[ind];i++){\\n                if(i < dig[ind]){\\n                    ans += fac(st,dig.size()-1);\\n                }\\n            }\\n            // here we are fixing digit equal to dig[ind] and masking it to use in future\\n            mask[dig[ind]] = 1;\\n            // now calling solve for next index\\n            ans += solve(dig,ind + 1, st);\\n            return ans;\\n        }\\n        // if we are not at first index means we can use 0 now\\n        for(int i=0;i<dig[ind];i++){\\n            if(mask[i]) continue; // see if we have used this digit before than we cannot indclude its contribution\\n            if(i < dig[ind]){\\n                ans += fac(st-1,dig.size()-ind-1);\\n            }\\n        }\\n        // if we have used dig[ind] before than return ans no need to solve for next index \\n        if(mask[dig[ind]]) return ans;\\n        mask[dig[ind]] = 1;\\n        ans += solve(dig,ind + 1,st-1);\\n        return ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        // here we can use 10 digits including 0 but must not start with zero\\n        if(n<=10) return 0;\\n        int nc = n;\\n        vector<int> dig;\\n        while(nc){\\n            dig.push_back(nc%10);\\n            nc /= 10;\\n        }\\n        reverse(dig.begin(), dig.end());\\n        // now we have digits\\n        mask.resize(10,0);\\n        // till number of n digits\\n        vector<int> v(10,0); // this contains numbers that have unique digits in ith digit number\\n        long int a = 9;\\n        for(int i=1;i<10;i++){\\n            v[i] = a;\\n            a = a*(10-i);\\n        }\\n        // Now till we try n digits number \\n        int ans = 0;\\n        for(int i=1;i<dig.size();i++){\\n            ans += v[i];\\n        }\\n        // Now for dig.size digit number we can\\n        ans += solve(dig,0,9);\\n        return n-ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/036658bb-d5e8-4718-aea0-26590569bf1a_1667148845.2003994.png)\\n",
                "solutionTags": [
                    "C",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // to return factorial starting at st and multiplying till t no of times\\n    int fac(int st,int t){\\n        int ans = 1;\\n        while(t){\\n            ans *= st;\\n            st--;\\n            t--;\\n        }\\n        return ans;\\n    }\\n    // mask will create mask over digits fixed\\n    vector<bool> mask;\\n    // we are counting numbers with 0 duplicate digits\\n    int solve(vector<int> &dig, int ind, int st){\\n        if(ind == dig.size()) return 1;\\n        int ans = 0;\\n        if(ind == 0){\\n            // 0 cannot be used\\n            for(int i=1;i<dig[ind];i++){\\n                if(i < dig[ind]){\\n                    ans += fac(st,dig.size()-1);\\n                }\\n            }\\n            // here we are fixing digit equal to dig[ind] and masking it to use in future\\n            mask[dig[ind]] = 1;\\n            // now calling solve for next index\\n            ans += solve(dig,ind + 1, st);\\n            return ans;\\n        }\\n        // if we are not at first index means we can use 0 now\\n        for(int i=0;i<dig[ind];i++){\\n            if(mask[i]) continue; // see if we have used this digit before than we cannot indclude its contribution\\n            if(i < dig[ind]){\\n                ans += fac(st-1,dig.size()-ind-1);\\n            }\\n        }\\n        // if we have used dig[ind] before than return ans no need to solve for next index \\n        if(mask[dig[ind]]) return ans;\\n        mask[dig[ind]] = 1;\\n        ans += solve(dig,ind + 1,st-1);\\n        return ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        // here we can use 10 digits including 0 but must not start with zero\\n        if(n<=10) return 0;\\n        int nc = n;\\n        vector<int> dig;\\n        while(nc){\\n            dig.push_back(nc%10);\\n            nc /= 10;\\n        }\\n        reverse(dig.begin(), dig.end());\\n        // now we have digits\\n        mask.resize(10,0);\\n        // till number of n digits\\n        vector<int> v(10,0); // this contains numbers that have unique digits in ith digit number\\n        long int a = 9;\\n        for(int i=1;i<10;i++){\\n            v[i] = a;\\n            a = a*(10-i);\\n        }\\n        // Now till we try n digits number \\n        int ans = 0;\\n        for(int i=1;i<dig.size();i++){\\n            ans += v[i];\\n        }\\n        // Now for dig.size digit number we can\\n        ans += solve(dig,0,9);\\n        return n-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2449053,
                "title": "c-solution-digit-dp-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int dp[10][1<<10][2][2];\\n    int solve(string &nums,int i=0,int mask=0,bool rep=0,int tight=1){\\n        if(i>=nums.size())\\n            return rep and mask!=0;\\n        if(dp[i][mask][rep][tight]!=-1)\\n            return dp[i][mask][rep][tight];\\n        int ub=tight?(nums[i]-\\'0\\'):9;\\n        int ans=0;\\n        for(int j=0;j<=ub;j++){\\n            if(mask==0 and j==0 )\\n                ans+=solve(nums,i+1,mask,rep,tight&(j==ub));\\n            else if(mask&(1<<j))\\n                ans+=solve(nums,i+1,mask,true,tight&(j==ub));\\n            else\\n                ans+=solve(nums,i+1,mask|(1<<j),rep,tight&(j==ub));\\n        }\\n        return dp[i][mask][rep][tight]=ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string nums=to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(nums);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int dp[10][1<<10][2][2];\\n    int solve(string &nums,int i=0,int mask=0,bool rep=0,int tight=1){\\n        if(i>=nums.size())\\n            return rep and mask!=0;\\n        if(dp[i][mask][rep][tight]!=-1)\\n            return dp[i][mask][rep][tight];\\n        int ub=tight?(nums[i]-\\'0\\'):9;\\n        int ans=0;\\n        for(int j=0;j<=ub;j++){\\n            if(mask==0 and j==0 )\\n                ans+=solve(nums,i+1,mask,rep,tight&(j==ub));\\n            else if(mask&(1<<j))\\n                ans+=solve(nums,i+1,mask,true,tight&(j==ub));\\n            else\\n                ans+=solve(nums,i+1,mask|(1<<j),rep,tight&(j==ub));\\n        }\\n        return dp[i][mask][rep][tight]=ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string nums=to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422861,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        vector<int> V;\\n        int n2 = n;\\n        while(n2){\\n            V.emplace_back(n2%10);\\n            n2/=10;\\n        }\\n        int len = V.size();\\n        \\n        int sum = 0;\\n        for(int i = 0; i < len-1; i++){\\n            sum += 9*A(9,i);\\n        }\\n        \\n        vector<int> dig_visited(10,0);\\n        for(int i = len-1; i >= 0; i--){\\n            int dig = V[i];\\n            int count = 0;\\n            for(int j = 0; j < dig; j++){\\n                if(dig_visited[j]){continue;}\\n                count++;\\n            }\\n            if(i == len-1){count--;}\\n            sum += count*A(10-(len-i), i);\\n            if(dig_visited[dig]){break;}\\n            if(i == 0 && dig_visited[dig] == 0){sum++;}\\n            dig_visited[dig] = 1;\\n        }\\n        \\n        return n - sum;\\n    }\\n    \\n    int A(int num, int len){\\n        int tmp = 1;\\n        for(int i = 0; i < len; i++){tmp *= (num-i);}\\n        return tmp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        vector<int> V;\\n        int n2 = n;\\n        while(n2){\\n            V.emplace_back(n2%10);\\n            n2/=10;\\n        }\\n        int len = V.size();\\n        \\n        int sum = 0;\\n        for(int i = 0; i < len-1; i++){\\n            sum += 9*A(9,i);\\n        }\\n        \\n        vector<int> dig_visited(10,0);\\n        for(int i = len-1; i >= 0; i--){\\n            int dig = V[i];\\n            int count = 0;\\n            for(int j = 0; j < dig; j++){\\n                if(dig_visited[j]){continue;}\\n                count++;\\n            }\\n            if(i == len-1){count--;}\\n            sum += count*A(10-(len-i), i);\\n            if(dig_visited[dig]){break;}\\n            if(i == 0 && dig_visited[dig] == 0){sum++;}\\n            dig_visited[dig] = 1;\\n        }\\n        \\n        return n - sum;\\n    }\\n    \\n    int A(int num, int len){\\n        int tmp = 1;\\n        for(int i = 0; i < len; i++){tmp *= (num-i);}\\n        return tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310889,
                "title": "am-i-the-only-one-who-misunderstand-the-question",
                "content": "I spent over 1 hr debugging couldn\\'t figure out why my answer is wrong for some large numbers. \\n\\nThe question states that have at least one repeated digit. I took that to mean \"101\" is NOT OK because both \"1\" are not glued together, and \"11\" is OK because they are together.\\n\\nI eventually gave up and checked the solution and realized \"101\" is actually OK because \"1\" appears twice. Am I the only person who didn\\'t understand the question? \\n\\nIt is really frustrating.\\n\\n```Java\\nclass Solution {\\n    public int numDupDigitsAtMostN(int n) {\\n        // 983582\\n        // 108318\\n        int ttl = n++;\\n        int ans = 0;\\n        List<Integer> list = new ArrayList<>();\\n        while(n>0){\\n            list.add(n%10);\\n            n/=10;\\n        }\\n        for (int i = 1; i < list.size(); i++){\\n            ans+=9*find(i-1, 9);\\n        }\\n        boolean[] seen = new boolean[10];\\n        for (int i = list.size(), d = 9; i > 0; --i, d--){\\n            int count = i == list.size()? list.get(i-1)-1: list.get(i-1);\\n            for (int j = 0; j < list.get(i-1); j++){\\n                if (seen[j]){\\n                    count--;\\n                }\\n            }\\n            ans += count*find(i-1, d);\\n            if (seen[list.get(i-1)]){\\n                break;\\n            }\\n            seen[list.get(i-1)]=true;\\n        }\\n        return ttl-ans;\\n    }\\n\\n    private int find(int n, int d){\\n        // dCn*n!\\n        // d!/(d-n)/(d-n).../1\\n        int ans = 1;\\n        for (int i = 1; i <= d; i++){\\n            ans *= i;\\n        }\\n        for (int i = n+1; i <= d; i++){\\n            ans /= (i-n);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int numDupDigitsAtMostN(int n) {\\n        // 983582\\n        // 108318\\n        int ttl = n++;\\n        int ans = 0;\\n        List<Integer> list = new ArrayList<>();\\n        while(n>0){\\n            list.add(n%10);\\n            n/=10;\\n        }\\n        for (int i = 1; i < list.size(); i++){\\n            ans+=9*find(i-1, 9);\\n        }\\n        boolean[] seen = new boolean[10];\\n        for (int i = list.size(), d = 9; i > 0; --i, d--){\\n            int count = i == list.size()? list.get(i-1)-1: list.get(i-1);\\n            for (int j = 0; j < list.get(i-1); j++){\\n                if (seen[j]){\\n                    count--;\\n                }\\n            }\\n            ans += count*find(i-1, d);\\n            if (seen[list.get(i-1)]){\\n                break;\\n            }\\n            seen[list.get(i-1)]=true;\\n        }\\n        return ttl-ans;\\n    }\\n\\n    private int find(int n, int d){\\n        // dCn*n!\\n        // d!/(d-n)/(d-n).../1\\n        int ans = 1;\\n        for (int i = 1; i <= d; i++){\\n            ans *= i;\\n        }\\n        for (int i = n+1; i <= d; i++){\\n            ans /= (i-n);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277652,
                "title": "python-permutation-rule-find-the-numbers-without-repeted-digits",
                "content": "\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        \\n        nums = [int(i) for i in str(n+1)] # digits in n+1\\n        d = len(nums) # number of digits in n+1\\n        res = 0 # number of no duplicates\\n        \\n        # count no duplicates for numbers with <d digits\\n        for i in range(1,d):\\n            res += 9 * math.perm(9,i-1)\\n        \\n\\t\\t# count no duplicates for numbers with d digits and smaller than n\\n        for i, x in enumerate(nums):\\n            if i == 0:\\n                digit_range = range(1,x) # first digit can not be 0\\n            else:\\n                digit_range = range(x)\\n                \\n            for y in digit_range:\\n                if y not in nums[:i]:\\n                    res += math.perm(9-i,d-1-i)\\n            if x in nums[:i]: break\\n                \\n        return n - res\\n```\\n        \\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        \\n        nums = [int(i) for i in str(n+1)] # digits in n+1\\n        d = len(nums) # number of digits in n+1\\n        res = 0 # number of no duplicates\\n        \\n        # count no duplicates for numbers with <d digits\\n        for i in range(1,d):\\n            res += 9 * math.perm(9,i-1)\\n        \\n\\t\\t# count no duplicates for numbers with d digits and smaller than n\\n        for i, x in enumerate(nums):\\n            if i == 0:\\n                digit_range = range(1,x) # first digit can not be 0\\n            else:\\n                digit_range = range(x)\\n                \\n            for y in digit_range:\\n                if y not in nums[:i]:\\n                    res += math.perm(9-i,d-1-i)\\n            if x in nums[:i]: break\\n                \\n        return n - res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555833,
                "title": "java-for-if-else-lovers",
                "content": "**Strategy**\\nWe\\'re taking the problem, slice it into smaller bites, solve for the smaller bites, and\\nadd up what we calculate in each slice. \\n\\n**Solution**\\nImagine we have three digits, x, y, and z. There are multiple ways to have a permutation\\nof these digits such that at least one of the digits is repeated. Let\\'s not solve for that.\\nInstead we solve for permutations w/o repeated digits. The idea is for index 0 we have\\nthree digits to choose from, x, y, and z. For index 1 we only have two choices left since\\none choice has already been exhausted when we picked a digit for index 0. It doesn\\'t\\nmatter which digit we choose at what index. What matters is the number of choices we\\nhave at each index.\\n\\n**Example 1**\\nLet\\'s say we\\'re calculating the number of permutations w/o repeated digits and lower\\nthan 1000. Let\\'s slice our problem into smaller problems. We don\\'t care about the\\nvalue of 1000 at this point. We say 1000 is consisting of four digits. We solve the\\noriginal problem for numbers lower than 9 (one 9), lower than 99 (two 9\\'s), and lower\\nthan 999 (three 9\\'s). We know that not all four digit numbers are lower than 1000 so\\nwe won\\'t solve for numbers lower than 9999 (four 9\\'s). We\\'ll take care of four digits\\nnumbers later. Solving for numbers consisting of 9\\'s is easy. Let\\'s explain what happens\\nnext in Example 2.\\n\\n**Example 2**\\nLet\\'s say we\\'re solving for 1,534,634. Plan is to slice it into smaller problems. Let\\'s\\nsay we already solved for numbers up to 999,999 like what we explained in Example 1.\\nFor 1,000,000 to 1,534,634 our smaller problems are solving for 1,499,999 plus solving\\nfor 1,500,000 all the way to 1,534,634. The latter piece will be sliced into smaller \\nproblems as well. Smaller problems from 1,500,000 to 1,534,634 are solving for the \\nfollowings,\\nsolving for 1,529,999 plus\\nsolving for 1,533,999 plus\\nsolving for 1,534,599 plus\\nsolving for 1,534,629 plus\\nsolving for 1,534,634.\\nIn each iteration we keep track of a pointer which is a pivot pointer. All digits \\nbefore pivot represent themselves, so the possibilities for each is always one.\\nThe pivot digit can take any digit up to the value of the pivot digit minus all \\npossibilities that we\\'ve already exhausted.\\nLet\\'s say we\\'re dealing w/ 1,529,999 and pivot is at index 2 meaning starting from\\nleft first digit is 1 and represents itself b/c it\\'s before pivot. Second digit is\\n5 and represents itself for the same reason. Now digit 2 is our pivot digit. We say\\nour possibilities are 0, 1, and 2 so three possibilities but we have already exhausted\\none of our possibilities which is 1 at index 0. So we\\'re left w/ only two possibilities\\nand again 1 and 5 represent themselves and 2 is lower than 5 so the only exhausted\\npossibility is 1. For all those 9\\'s after pivot we say possibilities are 0 to 9 which\\nis 10 possibilities minus the count of exhausted possibilities, so in this case for\\nthe first 9 we have 10-3=7 possibilities, for the second 9 we have 6 possibilities and \\nso on.\\nAdd up all counts from each iteration and we have all permutations w/o repeated digits.\\nSubtract the total count from the original input number and we have all permutations\\nw/ at least one repeated digit.\\n```\\nimport java.util.HashSet;\\n\\nclass Solution {\\n\\tint noRepeatCount = 0;\\n\\n\\tpublic int numDupDigitsAtMostN(int n) {\\n\\t\\tint nStrLength = String.valueOf(n).length();\\n\\t\\tint allNineLength = 0;\\n\\n\\t\\t// Edge cases out of the way.\\n\\t\\tif (n < 0 || nStrLength < 2)\\n\\t\\t\\treturn 0;\\n\\t\\t\\n\\t\\t// If n is all 9\\'s like 99999.\\n\\t\\telse if (Math.pow(10, nStrLength) - 1 == n)\\n\\t\\t\\tallNineLength = nStrLength;\\n\\t\\t\\n\\t\\t// If n is not all 9\\'s we calculate the largest number lower than n consisting of all 9\\'s.\\n\\t\\telse\\n\\t\\t\\tallNineLength = nStrLength - 1;\\n\\n\\t\\t// Calculating all 9\\'s e.g. for 10^6 we calculate for six 9\\'s which is 999,999.\\n\\t\\tfor (int numberOfDigits = 1; numberOfDigits <= allNineLength; numberOfDigits++) {\\n\\t\\t\\tnoRepeatCount += calcNumberOfNoRepeat(numberOfDigits);\\n\\t\\t}\\n\\n\\t\\t// Calculating from all 9\\'s to n e.g. for 10^6 we already calculated up to 999,999 and\\n\\t\\t// we just need to calculate for the rest.\\n\\t\\tif (Math.pow(10, nStrLength) - 1 > n) {\\n\\t\\t\\t\\n\\t\\t\\t// Count of all possible values 0 to 9.\\n\\t\\t\\tint mutations = 10;\\n\\t\\t\\t\\n\\t\\t\\t// HashSet is used only in part of the code. Worst case size() is the number of\\n\\t\\t\\t// mutations. contains() is called nStrLength times worst case in each iteration\\n\\t\\t\\t// w/ no more than nStrLength iterations.\\n\\t\\t\\tHashSet<Integer> hs = new HashSet<>();\\n\\t\\t\\t\\n\\t\\t\\t// We have two pointers each nStrLength hops to travel.\\n\\t\\t\\t// index1 is the pivot index and index2 keeps track of the current digit in n.\\n\\t\\t\\t// Based on index1 we decide what to do w/ digit at index2.\\n\\t\\t\\tfor (int index1 = 0; index1 < nStrLength; index1++) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// In each iteration we count noRepeat numbers. At the end of the iteration\\n\\t\\t\\t\\t// we add local noRepeat count to the total noRepeat count.\\n\\t\\t\\t\\tint noRepeatCountLocal = 0;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Digits visited in each iteration have nothing to do w/ other iterations\\n\\t\\t\\t\\t// so we clear the HashSet before start of each inner iteration.\\n\\t\\t\\t\\ths.clear();\\n\\t\\t\\t\\tfor (int index2 = 0; index2 < nStrLength; index2++) {\\n\\t\\t\\t\\t\\t// Extracting digit at index2.\\n\\t\\t\\t\\t\\tint index2Digit = (int) (n / Math.pow(10, String.valueOf(n).length() - (index2 + 1)) % 10);\\n\\t\\t\\t\\t\\t// index1 is the pivot. Anything before index1 is already taken care of.\\n\\t\\t\\t\\t\\t// This means digits before index1 can only represent themselves, which\\n\\t\\t\\t\\t\\t// means if we see duplicate digits before index1 noRepeatCountLocal\\n\\t\\t\\t\\t\\t// for that entire iteration becomes zero. Remember we\\'re counting numbers\\n\\t\\t\\t\\t\\t// w/o repeated digits.\\n\\t\\t\\t\\t\\tif (index2 < index1) {\\n\\t\\t\\t\\t\\t\\t// This is where we use HashSet. If digit at index2 is already in the\\n\\t\\t\\t\\t\\t\\t// HashSet that means we\\'re dealing w/ a duplicate so noRepeatCountLocal\\n\\t\\t\\t\\t\\t\\t// is set to zero and we\\'re done w/ the iteration.\\n\\t\\t\\t\\t\\t\\tif (hs.contains(index2Digit)) {\\n\\t\\t\\t\\t\\t\\t\\tnoRepeatCountLocal = 0;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t} else\\n\\t\\t\\t\\t\\t\\t\\t// If digit at index2 is not part of the HashSet add it to the HashSet.\\n\\t\\t\\t\\t\\t\\t\\ths.add(index2Digit);\\n\\t\\t\\t\\t\\t// index2 is meeting the pivot digit. The idea is to subtract 1 from the pivot\\n\\t\\t\\t\\t\\t// digit and make a possible big jump depending on the position of index1.\\n\\t\\t\\t\\t\\t// Imagine we\\'re dealing w/ 15,564,465. The idea is to count for 14,xxx,xxx. \\n\\t\\t\\t\\t\\t// We\\'ll replace those x\\'s w/ 9\\'s later in the code. So basically we skip over\\n\\t\\t\\t\\t\\t// 10^7-1 to 1.5*10^7-1.\\n\\t\\t\\t\\t\\t} else if (index2 == index1) {\\n\\t\\t\\t\\t\\t\\t// Special case when both pointers are at index 0 meaning we\\'re dealing w/\\n\\t\\t\\t\\t\\t\\t// the first digit of n, which can\\'t be 0.\\n\\t\\t\\t\\t\\t\\tif (index2 == 0) {\\n\\t\\t\\t\\t\\t\\t\\tnoRepeatCountLocal = index2Digit - 1;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tint inIndex2Range = 0;\\n\\t\\t\\t\\t\\t\\t\\t// Any digit before digit at index2 and larger than digit at index2\\n\\t\\t\\t\\t\\t\\t\\t// has no effect on digit at index2. Imagine digit at index2 is 5 \\n\\t\\t\\t\\t\\t\\t\\t// and digits before that are 8 and 9. Plan is to subtract 1 from 5 and\\n\\t\\t\\t\\t\\t\\t\\t// pad w/ 9\\'s, which gives us 8949999... Knowing that pivot is at 4 and\\n\\t\\t\\t\\t\\t\\t\\t// 8 and 9 represent themselves, digit at index2 can potentially be any\\n\\t\\t\\t\\t\\t\\t\\t// value from 0 to 4, which are all less than 8 and 9. As a result 8 \\n\\t\\t\\t\\t\\t\\t\\t// and 9 have no effect on possible digits at index2. Now if we had 1 \\n\\t\\t\\t\\t\\t\\t\\t// and 2 instead of 8 and 9 then the possible values for digit at index2\\n\\t\\t\\t\\t\\t\\t\\t// would be 0, 3, and 4 since 1 and 2 are already used before index2.\\n\\t\\t\\t\\t\\t\\t\\t// There\\'s a special case though when index2 points to the last digit,\\n\\t\\t\\t\\t\\t\\t\\t// in which we don\\'t subtract 1 and we don\\'t pad with 9\\'s.\\n\\t\\t\\t\\t\\t\\t\\t// After the first if statement we have a count of all exhausted possible\\n\\t\\t\\t\\t\\t\\t\\t// values to subtract from all possible values for digit at index2.\\n\\t\\t\\t\\t\\t\\t\\tfor (int j : hs) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ((index2 < nStrLength - 1 && j <= index2Digit - 1)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t|| (index2 == nStrLength - 1 && j <= index2Digit))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tinIndex2Range++;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tif (index2 == nStrLength - 1)\\n\\t\\t\\t\\t\\t\\t\\t\\tnoRepeatCountLocal = index2Digit + 1 - inIndex2Range;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tnoRepeatCountLocal = index2Digit - inIndex2Range;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t// Working on 9\\'s like in 123,999,999. Possible values for each 9 is 10\\n\\t\\t\\t\\t\\t// for 0 to 9. Actual possible values however are possible values at each\\n\\t\\t\\t\\t\\t// index minus exhausted possible values at that index.\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tnoRepeatCountLocal *= mutations - index2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Inner for is done. Adding whatever we\\'ve calculated to the total count.\\n\\t\\t\\t\\tif (noRepeatCountLocal > 0)\\n\\t\\t\\t\\t\\tnoRepeatCount += noRepeatCountLocal;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Now we have count of permutations w/o repeated digits. Subtracting from n gives\\n\\t\\t// count of permutations <= n w/ at least one repeated digit.\\n\\t\\treturn n - noRepeatCount;\\n\\t}\\n\\n\\t// Helper function to calculate count of permutations w/o repeated digits. Input is the\\n\\t// number of 9\\'s to be accounted for. \\n\\tpublic int calcNumberOfNoRepeat(int numberOfDigits) {\\n\\t\\tint noRepeatCount = 0;\\n\\t\\tint mutations = 9;\\n\\t\\tfor (int i = 0; i < numberOfDigits; i++) {\\n\\t\\t\\tif (i == 0)\\n\\t\\t\\t\\tnoRepeatCount = mutations;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tnoRepeatCount *= mutations--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn noRepeatCount;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Probability and Statistics"
                ],
                "code": "```\\nimport java.util.HashSet;\\n\\nclass Solution {\\n\\tint noRepeatCount = 0;\\n\\n\\tpublic int numDupDigitsAtMostN(int n) {\\n\\t\\tint nStrLength = String.valueOf(n).length();\\n\\t\\tint allNineLength = 0;\\n\\n\\t\\t// Edge cases out of the way.\\n\\t\\tif (n < 0 || nStrLength < 2)\\n\\t\\t\\treturn 0;\\n\\t\\t\\n\\t\\t// If n is all 9\\'s like 99999.\\n\\t\\telse if (Math.pow(10, nStrLength) - 1 == n)\\n\\t\\t\\tallNineLength = nStrLength;\\n\\t\\t\\n\\t\\t// If n is not all 9\\'s we calculate the largest number lower than n consisting of all 9\\'s.\\n\\t\\telse\\n\\t\\t\\tallNineLength = nStrLength - 1;\\n\\n\\t\\t// Calculating all 9\\'s e.g. for 10^6 we calculate for six 9\\'s which is 999,999.\\n\\t\\tfor (int numberOfDigits = 1; numberOfDigits <= allNineLength; numberOfDigits++) {\\n\\t\\t\\tnoRepeatCount += calcNumberOfNoRepeat(numberOfDigits);\\n\\t\\t}\\n\\n\\t\\t// Calculating from all 9\\'s to n e.g. for 10^6 we already calculated up to 999,999 and\\n\\t\\t// we just need to calculate for the rest.\\n\\t\\tif (Math.pow(10, nStrLength) - 1 > n) {\\n\\t\\t\\t\\n\\t\\t\\t// Count of all possible values 0 to 9.\\n\\t\\t\\tint mutations = 10;\\n\\t\\t\\t\\n\\t\\t\\t// HashSet is used only in part of the code. Worst case size() is the number of\\n\\t\\t\\t// mutations. contains() is called nStrLength times worst case in each iteration\\n\\t\\t\\t// w/ no more than nStrLength iterations.\\n\\t\\t\\tHashSet<Integer> hs = new HashSet<>();\\n\\t\\t\\t\\n\\t\\t\\t// We have two pointers each nStrLength hops to travel.\\n\\t\\t\\t// index1 is the pivot index and index2 keeps track of the current digit in n.\\n\\t\\t\\t// Based on index1 we decide what to do w/ digit at index2.\\n\\t\\t\\tfor (int index1 = 0; index1 < nStrLength; index1++) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// In each iteration we count noRepeat numbers. At the end of the iteration\\n\\t\\t\\t\\t// we add local noRepeat count to the total noRepeat count.\\n\\t\\t\\t\\tint noRepeatCountLocal = 0;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Digits visited in each iteration have nothing to do w/ other iterations\\n\\t\\t\\t\\t// so we clear the HashSet before start of each inner iteration.\\n\\t\\t\\t\\ths.clear();\\n\\t\\t\\t\\tfor (int index2 = 0; index2 < nStrLength; index2++) {\\n\\t\\t\\t\\t\\t// Extracting digit at index2.\\n\\t\\t\\t\\t\\tint index2Digit = (int) (n / Math.pow(10, String.valueOf(n).length() - (index2 + 1)) % 10);\\n\\t\\t\\t\\t\\t// index1 is the pivot. Anything before index1 is already taken care of.\\n\\t\\t\\t\\t\\t// This means digits before index1 can only represent themselves, which\\n\\t\\t\\t\\t\\t// means if we see duplicate digits before index1 noRepeatCountLocal\\n\\t\\t\\t\\t\\t// for that entire iteration becomes zero. Remember we\\'re counting numbers\\n\\t\\t\\t\\t\\t// w/o repeated digits.\\n\\t\\t\\t\\t\\tif (index2 < index1) {\\n\\t\\t\\t\\t\\t\\t// This is where we use HashSet. If digit at index2 is already in the\\n\\t\\t\\t\\t\\t\\t// HashSet that means we\\'re dealing w/ a duplicate so noRepeatCountLocal\\n\\t\\t\\t\\t\\t\\t// is set to zero and we\\'re done w/ the iteration.\\n\\t\\t\\t\\t\\t\\tif (hs.contains(index2Digit)) {\\n\\t\\t\\t\\t\\t\\t\\tnoRepeatCountLocal = 0;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t} else\\n\\t\\t\\t\\t\\t\\t\\t// If digit at index2 is not part of the HashSet add it to the HashSet.\\n\\t\\t\\t\\t\\t\\t\\ths.add(index2Digit);\\n\\t\\t\\t\\t\\t// index2 is meeting the pivot digit. The idea is to subtract 1 from the pivot\\n\\t\\t\\t\\t\\t// digit and make a possible big jump depending on the position of index1.\\n\\t\\t\\t\\t\\t// Imagine we\\'re dealing w/ 15,564,465. The idea is to count for 14,xxx,xxx. \\n\\t\\t\\t\\t\\t// We\\'ll replace those x\\'s w/ 9\\'s later in the code. So basically we skip over\\n\\t\\t\\t\\t\\t// 10^7-1 to 1.5*10^7-1.\\n\\t\\t\\t\\t\\t} else if (index2 == index1) {\\n\\t\\t\\t\\t\\t\\t// Special case when both pointers are at index 0 meaning we\\'re dealing w/\\n\\t\\t\\t\\t\\t\\t// the first digit of n, which can\\'t be 0.\\n\\t\\t\\t\\t\\t\\tif (index2 == 0) {\\n\\t\\t\\t\\t\\t\\t\\tnoRepeatCountLocal = index2Digit - 1;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tint inIndex2Range = 0;\\n\\t\\t\\t\\t\\t\\t\\t// Any digit before digit at index2 and larger than digit at index2\\n\\t\\t\\t\\t\\t\\t\\t// has no effect on digit at index2. Imagine digit at index2 is 5 \\n\\t\\t\\t\\t\\t\\t\\t// and digits before that are 8 and 9. Plan is to subtract 1 from 5 and\\n\\t\\t\\t\\t\\t\\t\\t// pad w/ 9\\'s, which gives us 8949999... Knowing that pivot is at 4 and\\n\\t\\t\\t\\t\\t\\t\\t// 8 and 9 represent themselves, digit at index2 can potentially be any\\n\\t\\t\\t\\t\\t\\t\\t// value from 0 to 4, which are all less than 8 and 9. As a result 8 \\n\\t\\t\\t\\t\\t\\t\\t// and 9 have no effect on possible digits at index2. Now if we had 1 \\n\\t\\t\\t\\t\\t\\t\\t// and 2 instead of 8 and 9 then the possible values for digit at index2\\n\\t\\t\\t\\t\\t\\t\\t// would be 0, 3, and 4 since 1 and 2 are already used before index2.\\n\\t\\t\\t\\t\\t\\t\\t// There\\'s a special case though when index2 points to the last digit,\\n\\t\\t\\t\\t\\t\\t\\t// in which we don\\'t subtract 1 and we don\\'t pad with 9\\'s.\\n\\t\\t\\t\\t\\t\\t\\t// After the first if statement we have a count of all exhausted possible\\n\\t\\t\\t\\t\\t\\t\\t// values to subtract from all possible values for digit at index2.\\n\\t\\t\\t\\t\\t\\t\\tfor (int j : hs) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ((index2 < nStrLength - 1 && j <= index2Digit - 1)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t|| (index2 == nStrLength - 1 && j <= index2Digit))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tinIndex2Range++;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tif (index2 == nStrLength - 1)\\n\\t\\t\\t\\t\\t\\t\\t\\tnoRepeatCountLocal = index2Digit + 1 - inIndex2Range;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tnoRepeatCountLocal = index2Digit - inIndex2Range;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t// Working on 9\\'s like in 123,999,999. Possible values for each 9 is 10\\n\\t\\t\\t\\t\\t// for 0 to 9. Actual possible values however are possible values at each\\n\\t\\t\\t\\t\\t// index minus exhausted possible values at that index.\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tnoRepeatCountLocal *= mutations - index2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Inner for is done. Adding whatever we\\'ve calculated to the total count.\\n\\t\\t\\t\\tif (noRepeatCountLocal > 0)\\n\\t\\t\\t\\t\\tnoRepeatCount += noRepeatCountLocal;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Now we have count of permutations w/o repeated digits. Subtracting from n gives\\n\\t\\t// count of permutations <= n w/ at least one repeated digit.\\n\\t\\treturn n - noRepeatCount;\\n\\t}\\n\\n\\t// Helper function to calculate count of permutations w/o repeated digits. Input is the\\n\\t// number of 9\\'s to be accounted for. \\n\\tpublic int calcNumberOfNoRepeat(int numberOfDigits) {\\n\\t\\tint noRepeatCount = 0;\\n\\t\\tint mutations = 9;\\n\\t\\tfor (int i = 0; i < numberOfDigits; i++) {\\n\\t\\t\\tif (i == 0)\\n\\t\\t\\t\\tnoRepeatCount = mutations;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tnoRepeatCount *= mutations--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn noRepeatCount;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406381,
                "title": "python-o-1-time",
                "content": "The idea is to first count the numbers that have distinct digits. There are two cases. (1) Without the limitation of being at most `n`, there are `9*9*8*...(9-k+2)` such numbers with `k` digits. (2) With the limitation `n`, we can count such numbers in ranges. For example, for `n = 3579`, we count the numbers with distinct digits as follows:\\n[1, 10): 1 digit without limitation\\n[10, 100): 2 digits without limitation\\n[100, 1000): 3 digits without limitation\\n[1000, 3000): 4 digits of the form {1,2}???\\n[3000, 3500): 4 digits of the form 3{0,1,2,4}??\\n[3500, 3570): 4 digits of the form 35{0,1,2,4,6}?\\n[3570, 3579): 4 digits of the form 357{0,1,2,3,4,6,8}\\n{3579}: 4 digits of the form 3579\\n\\nSince the complexity is linear in the number of digits of `n`, it is O(1).\\n\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        \\n        print = lambda *args: None\\n        \\n        n2 = min(n, 10**10-1)\\n        m = len(str(n2))\\n        print(f\\'up to {n2} ({m} digits)\\')\\n        \\n        @lru_cache\\n        def num_perms(start:int, count:int) -> int:\\n            if count <= 0:\\n                return 1\\n            elif count == 1:\\n                return start\\n            return start * num_perms(start-1, count-1)\\n        \\n        no_repeats = 0\\n        for k in range(1, m):\\n            no_repeats += 9 * num_perms(9, k-1)\\n        print(f\\'up to length {m-1} no repeat: {no_repeats}\\')\\n            \\n        digits = []\\n        n3 = n2\\n        while n3 > 0:\\n            digits.append(n3 % 10)\\n            n3 //= 10\\n        digits = digits[::-1]\\n        nd = len(digits)\\n        print(digits, nd)\\n        fixed_digits = set()\\n        for i, d in enumerate(digits):\\n            below = range(1,d) if i==0 else range(d)\\n            cand = set(below) - fixed_digits\\n            nc = len(cand)\\n            if i == 0:\\n                no_repeats_i = nc * num_perms(9, nd-i-1)\\n            else:\\n                no_repeats_i = nc * num_perms(10-i-1, nd-i-1)\\n            print(f\\'no repeats fixing {digits[:i]}: {no_repeats_i}, cand={cand}\\')\\n            no_repeats += no_repeats_i\\n            \\n            if d in fixed_digits:\\n                break\\n            fixed_digits.add(d)\\n        if len(fixed_digits) == nd:\\n            no_repeats += 1\\n        print(f\\'total no repeat: {no_repeats}\\')\\n        return n - no_repeats\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        \\n        print = lambda *args: None\\n        \\n        n2 = min(n, 10**10-1)\\n        m = len(str(n2))\\n        print(f\\'up to {n2} ({m} digits)\\')\\n        \\n        @lru_cache\\n        def num_perms(start:int, count:int) -> int:\\n            if count <= 0:\\n                return 1\\n            elif count == 1:\\n                return start\\n            return start * num_perms(start-1, count-1)\\n        \\n        no_repeats = 0\\n        for k in range(1, m):\\n            no_repeats += 9 * num_perms(9, k-1)\\n        print(f\\'up to length {m-1} no repeat: {no_repeats}\\')\\n            \\n        digits = []\\n        n3 = n2\\n        while n3 > 0:\\n            digits.append(n3 % 10)\\n            n3 //= 10\\n        digits = digits[::-1]\\n        nd = len(digits)\\n        print(digits, nd)\\n        fixed_digits = set()\\n        for i, d in enumerate(digits):\\n            below = range(1,d) if i==0 else range(d)\\n            cand = set(below) - fixed_digits\\n            nc = len(cand)\\n            if i == 0:\\n                no_repeats_i = nc * num_perms(9, nd-i-1)\\n            else:\\n                no_repeats_i = nc * num_perms(10-i-1, nd-i-1)\\n            print(f\\'no repeats fixing {digits[:i]}: {no_repeats_i}, cand={cand}\\')\\n            no_repeats += no_repeats_i\\n            \\n            if d in fixed_digits:\\n                break\\n            fixed_digits.add(d)\\n        if len(fixed_digits) == nd:\\n            no_repeats += 1\\n        print(f\\'total no repeat: {no_repeats}\\')\\n        return n - no_repeats\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837204,
                "title": "java-dfs-memo-bit",
                "content": "```\\nclass Solution {\\n    int dp[][][];\\n    public int numDupDigitsAtMostN(int N) {\\n        //at least 1 repeat digit\\n        if(N<=10)return 0;\\n        String s=N+\"\";\\n        int cnt=0;\\n        int first=s.charAt(0)-\\'0\\';\\n        dp=new int[s.length()][1<<10][2];\\n        \\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<dp[0].length;j++){\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        \\n        for(int i=1;i<=first;i++){\\n            if(i==first){\\n                cnt+=dfs(s,1,1<<i,1);\\n            }else{\\n                cnt+=dfs(s,1,1<<i,0);\\n            }\\n        }\\n        cnt+=dfs(s,1,0,0);//0 \\n        return N-cnt;\\n    }\\n    \\n    public int dfs(String s,int index,int bit,int state){\\n        if(index>=s.length())return 1;\\n        if(dp[index][bit][state]!=-1)return dp[index][bit][state];\\n        int digit=s.charAt(index)-\\'0\\';\\n        int res=0;\\n        if(state==1){//smae prefix\\n            for(int i=0;i<=digit;i++){\\n                if((bit&(1<<i))!=0)continue;\\n                if(i==digit){\\n                    res+=dfs(s,index+1,(bit|(1<<i)),1);\\n                }else{\\n                    res+=dfs(s,index+1,(bit|(1<<i)),0);\\n                }\\n            }\\n            \\n        }else{\\n            for(int i=0;i<10;i++){\\n                if((bit&(1<<i))!=0)continue;\\n                if(i==0&&bit==0&&index==s.length()-1)continue;\\n                if(i==0&&bit==0)res+=dfs(s,index+1,0,0);\\n                else res+=dfs(s,index+1,(bit|(1<<i)),0);\\n            }\\n            \\n        }\\n        dp[index][bit][state]=res;\\n        return res;\\n    }\\n\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dp[][][];\\n    public int numDupDigitsAtMostN(int N) {\\n        //at least 1 repeat digit\\n        if(N<=10)return 0;\\n        String s=N+\"\";\\n        int cnt=0;\\n        int first=s.charAt(0)-\\'0\\';\\n        dp=new int[s.length()][1<<10][2];\\n        \\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<dp[0].length;j++){\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        \\n        for(int i=1;i<=first;i++){\\n            if(i==first){\\n                cnt+=dfs(s,1,1<<i,1);\\n            }else{\\n                cnt+=dfs(s,1,1<<i,0);\\n            }\\n        }\\n        cnt+=dfs(s,1,0,0);//0 \\n        return N-cnt;\\n    }\\n    \\n    public int dfs(String s,int index,int bit,int state){\\n        if(index>=s.length())return 1;\\n        if(dp[index][bit][state]!=-1)return dp[index][bit][state];\\n        int digit=s.charAt(index)-\\'0\\';\\n        int res=0;\\n        if(state==1){//smae prefix\\n            for(int i=0;i<=digit;i++){\\n                if((bit&(1<<i))!=0)continue;\\n                if(i==digit){\\n                    res+=dfs(s,index+1,(bit|(1<<i)),1);\\n                }else{\\n                    res+=dfs(s,index+1,(bit|(1<<i)),0);\\n                }\\n            }\\n            \\n        }else{\\n            for(int i=0;i<10;i++){\\n                if((bit&(1<<i))!=0)continue;\\n                if(i==0&&bit==0&&index==s.length()-1)continue;\\n                if(i==0&&bit==0)res+=dfs(s,index+1,0,0);\\n                else res+=dfs(s,index+1,(bit|(1<<i)),0);\\n            }\\n            \\n        }\\n        dp[index][bit][state]=res;\\n        return res;\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 488526,
                "title": "simple-efficient-c-digit-dp-solution-with-comments",
                "content": "**Top Down multi-dimensional DP approach**\\n\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    string s;\\n    int dp[10][2][2][2][1<<10];\\n\\n    ll ff(int pos, bool tight, bool st, bool cnt, int mask) {\\n        // If index reaches the length of the string return whether\\n        // any repetition till now has been found or not?\\n        if (pos == s.size()) return cnt ? 1 : 0;\\n        \\n        // Look in the DP table\\n        if (dp[pos][tight][st][cnt][mask] != -1)\\n            return dp[pos][tight][st][cnt][mask];\\n\\n        ll res = 0;\\n        ll en = tight ? s[pos]-\\'0\\':9;\\n\\n        if (!st) {\\n            // Place 0s, go to the rightmost\\n            res = ff(pos+1, tight&s[pos]==\\'0\\', st, cnt, mask);\\n            for (ll i=1; i<=en; i++) {\\n                // Start the number, st = true\\n                res += ff(pos+1, tight&(i==en), st|(i > 0), cnt, mask|1<<i);\\n            }\\n        }else {\\n            // Number has started\\n            for (ll i=0; i<=en; i++) {\\n                // If number is found repeated, check using bitmask (mask & (1 << i))\\n                // Make the cnt = true, i.e. cnt | mask&(1<<i)\\n                res += ff(pos+1, tight&(i==en), st, cnt|(mask&(1<<i)), mask|1<<i);\\n            }\\n        }\\n\\n        return dp[pos][tight][st][cnt][mask] = res;\\n    }\\n\\n    int numDupDigitsAtMostN(int N) {\\n        s = to_string(N);\\n        memset(dp, -1, sizeof dp);\\n        return ff(0, true, false, false, 0);\\n    }\\n};\\n```\\n\\nRead more about **Digit DP:**\\nhttps://codeforces.com/blog/entry/53960",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    string s;\\n    int dp[10][2][2][2][1<<10];\\n\\n    ll ff(int pos, bool tight, bool st, bool cnt, int mask) {\\n        // If index reaches the length of the string return whether\\n        // any repetition till now has been found or not?\\n        if (pos == s.size()) return cnt ? 1 : 0;\\n        \\n        // Look in the DP table\\n        if (dp[pos][tight][st][cnt][mask] != -1)\\n            return dp[pos][tight][st][cnt][mask];\\n\\n        ll res = 0;\\n        ll en = tight ? s[pos]-\\'0\\':9;\\n\\n        if (!st) {\\n            // Place 0s, go to the rightmost\\n            res = ff(pos+1, tight&s[pos]==\\'0\\', st, cnt, mask);\\n            for (ll i=1; i<=en; i++) {\\n                // Start the number, st = true\\n                res += ff(pos+1, tight&(i==en), st|(i > 0), cnt, mask|1<<i);\\n            }\\n        }else {\\n            // Number has started\\n            for (ll i=0; i<=en; i++) {\\n                // If number is found repeated, check using bitmask (mask & (1 << i))\\n                // Make the cnt = true, i.e. cnt | mask&(1<<i)\\n                res += ff(pos+1, tight&(i==en), st, cnt|(mask&(1<<i)), mask|1<<i);\\n            }\\n        }\\n\\n        return dp[pos][tight][st][cnt][mask] = res;\\n    }\\n\\n    int numDupDigitsAtMostN(int N) {\\n        s = to_string(N);\\n        memset(dp, -1, sizeof dp);\\n        return ff(0, true, false, false, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393486,
                "title": "constant-time-combinatorial-counting",
                "content": "(A similar problem: https://leetcode.com/problems/ones-and-zeroes/)\\n\\nIf you studied probability, it is well known that considering the complement problem: \\'the count of number WITHOUT repeating digit that\\'s less than N\\' is easier to solve. And then we get the answer by subtracting this cnt from N.\\n\\nSo numbers M without repeating digits that\\'s less than N has three types:\\n1. M has the same prefix as N.\\n2. M has the same length but the leading digit is non-zero and strictly less than leaading digit as N.\\n3. M has strictly less digits than N.\\n\\nWe can count type (1)-(2) together, and (3) later.\\ntype 1 and 2 requires us to remember the number of digit that\\'s not used in the prefix but strictly less than the current digit. Let\\'s see an example.\\nSuppose N = 453232\\n\\ntype (1) are of the form 3xxxxx, 2xxxxx, 1xxxxx, the leading digit has 4-1 = 3 choices. Then the xxx part we can use whatever number, but not the choice of our leading digit, so that\\'s 9\\\\*8\\\\*7\\\\*6\\\\*5, which we call perm(9,5).\\ntype (2) are of the form 4yxxxx, 45yxxx, 453yxx, 4532yx, but we can\\'t consider 45323x(?) because we see a repeating digit. so starting from the MSD we\\'ll just count up to the first time we see a repeating digit in N.  Notices that I put \\'y\\' instead of \\'x\\' for the first digit after the prefix. For 4yxxxx, since N = 453232, we can\\'t use y to be greater than 5. so we use 3, 2, or 1, or 0. Notice that we can\\'t use 4, because 4 has appeaered in the prefix. Anyhow, we use an array to store the number of digits available at i-th index that\\'s strictly less than the ith-indes of N and hasn\\'t been used in the prefix so far.\\n\\nFor type (3), we always have 9 choice for MSD, 9 choice for 2nd digit, 8 choice for 3rd digit. Using N=543232 as same exmaple, type (3) would cover 1000-9999, 100-999, 10-99, 0-9. Simple counting problem.\\n\\nNow subtract type (1) +(2)+(3) from N, that\\'s the answer we have. \\n\\n```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        int ans = 0;\\n\\n        String num = Integer.toString(N);\\n        //Convert N to an array of digits for easy proccessing. A[0] stores the most sigifinicant digit.\\n        int[] A = new int[num.length()];\\n        for(int i = 0;i<A.length; i++){\\n            A[i] = num.charAt(i)-\\'0\\';\\n        }\\n        //cnt array stores the number of digit strictly smaller than A[i] and hasn\\'t been used in the prefix. \\n        int[] cnt = new int[A.length];\\n        boolean[] used = new boolean[10];\\n        used[A[0]] = true;\\n        //we require the most significant digit to be non-zero.\\n        cnt[0] = A[0]-1;\\n        //rpt: The first repeating idx, after this idx, no number with the same prefix as N and is smaller than N has no repeating digit. So stop counting.\\n        int rpt = A.length;\\n        \\n        for(int i=1;i<A.length; i++){\\n            for(int j = 0;j<A[i];j++){\\n                if(!used[j]) cnt[i]++;\\n            }\\n            if(used[A[i]]){\\n                rpt=i;\\n                break;\\n            }\\n            used[A[i]] = true;\\n        }\\n        \\n        //count from most significant digit, the number of no repeating number with same prefix and has same length with N. \\n        \\n        for(int i = 0;i<rpt; i++){\\n            int c = cnt[i];\\n            c*=perm(9-i,A.length-i-1);\\n            ans+=c;\\n        }\\n        //if there\\'s repeating idx, count that in.\\n        if(rpt!=A.length) ans+= cnt[rpt]*perm(9-rpt, A.length-rpt-1);\\n        \\n        //Now count the numbers which has length strictly less than N.\\n        for(int i = 1;i<A.length;i++){\\n            ans+= 9*perm(9,A.length-i-1);\\n        }\\n        if(rpt==A.length) ans++;\\n        return N-ans;\\n    }\\n    \\n    public int perm(int n, int k){\\n        int a= 1;\\n        for(int i = 0;i<k;i++){\\n            a*=(n-i);\\n        }\\n        return a;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        int ans = 0;\\n\\n        String num = Integer.toString(N);\\n        //Convert N to an array of digits for easy proccessing. A[0] stores the most sigifinicant digit.\\n        int[] A = new int[num.length()];\\n        for(int i = 0;i<A.length; i++){\\n            A[i] = num.charAt(i)-\\'0\\';\\n        }\\n        //cnt array stores the number of digit strictly smaller than A[i] and hasn\\'t been used in the prefix. \\n        int[] cnt = new int[A.length];\\n        boolean[] used = new boolean[10];\\n        used[A[0]] = true;\\n        //we require the most significant digit to be non-zero.\\n        cnt[0] = A[0]-1;\\n        //rpt: The first repeating idx, after this idx, no number with the same prefix as N and is smaller than N has no repeating digit. So stop counting.\\n        int rpt = A.length;\\n        \\n        for(int i=1;i<A.length; i++){\\n            for(int j = 0;j<A[i];j++){\\n                if(!used[j]) cnt[i]++;\\n            }\\n            if(used[A[i]]){\\n                rpt=i;\\n                break;\\n            }\\n            used[A[i]] = true;\\n        }\\n        \\n        //count from most significant digit, the number of no repeating number with same prefix and has same length with N. \\n        \\n        for(int i = 0;i<rpt; i++){\\n            int c = cnt[i];\\n            c*=perm(9-i,A.length-i-1);\\n            ans+=c;\\n        }\\n        //if there\\'s repeating idx, count that in.\\n        if(rpt!=A.length) ans+= cnt[rpt]*perm(9-rpt, A.length-rpt-1);\\n        \\n        //Now count the numbers which has length strictly less than N.\\n        for(int i = 1;i<A.length;i++){\\n            ans+= 9*perm(9,A.length-i-1);\\n        }\\n        if(rpt==A.length) ans++;\\n        return N-ans;\\n    }\\n    \\n    public int perm(int n, int k){\\n        int a= 1;\\n        for(int i = 0;i<k;i++){\\n            a*=(n-i);\\n        }\\n        return a;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386806,
                "title": "java-digital-dp",
                "content": "```java\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        int[] digits = new int[10];\\n        int pos = 0, temp = N;\\n        while (N > 0) {\\n            digits[pos++] = N % 10;\\n            N /= 10;\\n        }\\n        return temp - dfs(digits, pos - 1, 0, new int[10][1 << 10], true) + 1;\\n    }\\n    \\n    public int dfs(int[] digits, int pos, int pre, int[][] dp, boolean limit) {\\n        if (pos == -1) return 1;\\n        if (!limit && dp[pos][pre] != 0) return dp[pos][pre];\\n        int up = limit ? digits[pos] : 9;\\n        int ans = 0;\\n        for (int i = 0; i <= up; i++) {\\n            if ((pre & (1 << i)) != 0 && (pre != 0 || i != 0)) continue;\\n            if (pre == 0 && i == 0) {\\n                ans += dfs(digits, pos - 1, pre, dp, limit && i == up);\\n            } else {\\n                ans += dfs(digits, pos - 1, pre ^ (1 << i), dp, limit && i == up);\\n            }\\n        }\\n        if (!limit) dp[pos][pre] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        int[] digits = new int[10];\\n        int pos = 0, temp = N;\\n        while (N > 0) {\\n            digits[pos++] = N % 10;\\n            N /= 10;\\n        }\\n        return temp - dfs(digits, pos - 1, 0, new int[10][1 << 10], true) + 1;\\n    }\\n    \\n    public int dfs(int[] digits, int pos, int pre, int[][] dp, boolean limit) {\\n        if (pos == -1) return 1;\\n        if (!limit && dp[pos][pre] != 0) return dp[pos][pre];\\n        int up = limit ? digits[pos] : 9;\\n        int ans = 0;\\n        for (int i = 0; i <= up; i++) {\\n            if ((pre & (1 << i)) != 0 && (pre != 0 || i != 0)) continue;\\n            if (pre == 0 && i == 0) {\\n                ans += dfs(digits, pos - 1, pre, dp, limit && i == up);\\n            } else {\\n                ans += dfs(digits, pos - 1, pre ^ (1 << i), dp, limit && i == up);\\n            }\\n        }\\n        if (!limit) dp[pos][pre] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314745,
                "title": "c-divide-and-conquer",
                "content": "I guess no one want to read this long solution. So I am lazy to add comment\\n```\\nclass Solution {\\npublic:\\n   int numDupDigitsAtMostN(int N) {\\n      vector<int> v = toVec(N);\\n      int n1 = numNoRepeat1(v, {}, 0);\\n      int n2 = numNoRepeat2(v.size() - 1);\\n      cout << N << \" \" << n1 << \" \" << n2 << endl;\\n      return N - n1 - n2;\\n   }\\n\\n   // from 10^pow to N \\n   int numNoRepeat1(vector<int> & v, set<int> used, int i) {\\n      if (i == v.size()) return 1;\\n      int res = 0;\\n      int nCanbeUse = v[i];  // 0,1,2,3,4,...v[0]-1\\n      if (i == 0) nCanbeUse--; //leading digit cannot be 0\\n      for (auto x : used) if (x < v[i]) nCanbeUse--;\\n      res += nCanbeUse * permutation(10 - used.size() - 1, v.size() - i - 1);\\n\\n      //repeated, early return\\n      if(used.count(v[i])) return res;\\n\\n      used.insert(v[i]);\\n      res += numNoRepeat1(v, used, i + 1);\\n      return res;\\n   }\\n\\n   int permutation(int num, int k) {\\n      int prod = 1;\\n      while (k--) prod *= num--;\\n      return prod;\\n   }\\n\\n   // from 0 to 10^pow10 \\n   int numNoRepeat2(int pow10) {\\n      int sum = 0;\\n      while (pow10) {\\n         sum += 9 * permutation(9, pow10 - 1);\\n         pow10--;\\n      }\\n      return sum;\\n   }\\n\\n   vector<int> toVec(int N) {\\n      auto s = to_string(N);\\n      vector<int> v;\\n      for (auto c : s) v.push_back(c - \\'0\\');\\n      return v;\\n   }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   int numDupDigitsAtMostN(int N) {\\n      vector<int> v = toVec(N);\\n      int n1 = numNoRepeat1(v, {}",
                "codeTag": "Java"
            },
            {
                "id": 259737,
                "title": "c-standard-depth-first-search-with-back-tracking",
                "content": "March 21, 2019\\nIt is the hard level algorithm. I like to share the standard depth first search using back tracking technique to solve the problem. What I did is to study weekly contest 128 ranking 13 player\\'s code, and then I wrote one based on my understanding. \\n\\nHere are steps to follow:\\n1. Brute force solution, from rightmost digit, enumerate all the possible digit; \\n2. Go to next digit by moving to left side, skip those used digits. Use one array with size 10 to record used digit from 0 to 9. \\n3. Combine step 1 and step2, the brute force solution time complexity O(10!)\\n4. Do not forget to back tracking\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1015_number_with_repeated_digits_13\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            NumDupDigitsAtMostN(872427638);\\n            Debug.Assert(value == 10); \\n        }\\n\\n        public static int    value = 0; \\n        public static bool[] taken = new bool[10];\\n\\n        /// <summary>\\n        /// March 20, 2019\\n        /// study code based on ranking No. 13, VladaMG98\\n        /// https://leetcode.com/contest/weekly-contest-128/ranking/\\n        /// </summary>\\n        /// <param name=\"N\"></param>\\n        /// <returns></returns>\\n        public static int NumDupDigitsAtMostN(int N)\\n        {            \\n            return N - getAllDifferent(N) + 1; \\n        }\\n\\n        private static int getAllDifferent(int N)\\n        {\\n            value = 0;\\n            for (int i = 0; i < taken.Length; i++)\\n            {\\n                taken[i] = false; \\n            }\\n\\n            recursive(0, 0, N);\\n            return value; \\n        }\\n\\n        /// <summary>\\n        /// Brute force solution\\n        /// Make sure that all numbers in the integer are distinct, less than and equal N.\\n        /// Problem statement:\\n        /// Given a positive integer N, return the number of positive integers less than or \\n        /// equal to N that have at least 1 repeated digit.\\n        /// Start from rightmost digit. \\n        /// </summary>\\n        /// <param name=\"number\"></param>\\n        /// <param name=\"digit\"></param>\\n        /// <param name=\"N\"></param>\\n        private static void recursive(double number, int digit, int N)\\n        {\\n            if (number > N)\\n            {\\n                return; \\n            }\\n\\n            // current number with value number is the one. \\n            value += 1;\\n\\n            // Fix timeout bug\\n            if (number * 10 > N)\\n            {\\n                return;\\n            }\\n\\n            for (int x = 0; x < 10; x++)\\n            {\\n                if (taken[x])\\n                {\\n                    continue; \\n                }\\n\\n                // make sure that the number is positive number\\n                var numberIsZero = digit == 0 && x == 0;\\n                if (numberIsZero)\\n                {\\n                    continue;\\n                }\\n\\n                taken[x] = true;\\n                recursive(number * 10 + x, digit + 1, N);\\n                \\n                // backtracking\\n                taken[x] = false; \\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1015_number_with_repeated_digits_13\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            NumDupDigitsAtMostN(872427638);\\n            Debug.Assert(value == 10); \\n        }\\n\\n        public static int    value = 0; \\n        public static bool[] taken = new bool[10];\\n\\n        /// <summary>\\n        /// March 20, 2019\\n        /// study code based on ranking No. 13, VladaMG98\\n        /// https://leetcode.com/contest/weekly-contest-128/ranking/\\n        /// </summary>\\n        /// <param name=\"N\"></param>\\n        /// <returns></returns>\\n        public static int NumDupDigitsAtMostN(int N)\\n        {            \\n            return N - getAllDifferent(N) + 1; \\n        }\\n\\n        private static int getAllDifferent(int N)\\n        {\\n            value = 0;\\n            for (int i = 0; i < taken.Length; i++)\\n            {\\n                taken[i] = false; \\n            }\\n\\n            recursive(0, 0, N);\\n            return value; \\n        }\\n\\n        /// <summary>\\n        /// Brute force solution\\n        /// Make sure that all numbers in the integer are distinct, less than and equal N.\\n        /// Problem statement:\\n        /// Given a positive integer N, return the number of positive integers less than or \\n        /// equal to N that have at least 1 repeated digit.\\n        /// Start from rightmost digit. \\n        /// </summary>\\n        /// <param name=\"number\"></param>\\n        /// <param name=\"digit\"></param>\\n        /// <param name=\"N\"></param>\\n        private static void recursive(double number, int digit, int N)\\n        {\\n            if (number > N)\\n            {\\n                return; \\n            }\\n\\n            // current number with value number is the one. \\n            value += 1;\\n\\n            // Fix timeout bug\\n            if (number * 10 > N)\\n            {\\n                return;\\n            }\\n\\n            for (int x = 0; x < 10; x++)\\n            {\\n                if (taken[x])\\n                {\\n                    continue; \\n                }\\n\\n                // make sure that the number is positive number\\n                var numberIsZero = digit == 0 && x == 0;\\n                if (numberIsZero)\\n                {\\n                    continue;\\n                }\\n\\n                taken[x] = true;\\n                recursive(number * 10 + x, digit + 1, N);\\n                \\n                // backtracking\\n                taken[x] = false; \\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257561,
                "title": "c-method-using-permutation",
                "content": "```\\nauto __ =[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        //\\u65E2\\u7136\\u8BA1\\u7B97\\u7684\\u662F\\u91CD\\u590D\\u7684\\u4E2A\\u6570\\u6211\\u4EEC\\u53EF\\u4EE5\\u8BA1\\u7B97\\u4E0D\\u91CD\\u590D\\u7684\\u4E2A\\u6570\\uFF0C\\u8FD9\\u5C31\\u662F\\u4E2A\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u95EE\\u9898\\n        //\\u5BF9\\u4E8E\\u8FD9\\u4E2A\\u95EE\\u9898\\u6211\\u4EEC\\u8981\\u5148\\u5199\\u51FA\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u7B97\\u6CD5\\u3002\\n        // second we must define our method upper  boader.\\n        // such that 8999-->(9,0,0,0) \\n        // \\n        int retv  = 0;\\n        vector<int> remain;\\n        for(int n = N+1;n>0;n/=10)\\n        {\\n            remain.insert(remain.begin(),n%10);\\n        }\\n        for(int i =1;i<remain.size();i++)\\n        {\\n            retv+=9*A(9,i-1);\\n        }\\n        // condition ,if this \\u548C\\u524D\\u9762\\u7684\\u4E00\\u6837\\u5219\\u8DF3\\u8FC7\\uFF0C\\u56E0\\u4E3A\\u4E0D\\u80FD\\u6709\\u91CD\\u590D\\u7684\\uFF0C\\u5982\\u679C\\u5B58\\u5728\\u4E24\\u4E2A\\u4E0A\\u754C\\u4E00\\u6837beak \\u6389\\uFF0C\\u56E0\\u4E3A\\u4E0D\\u53EF\\u80FD\\u5728\\u4ECE\\u8FD9\\u91CC\\u51FA\\u73B0\\u4E24\\u4E2A\\u5B8C\\u5168\\u4E0D\\u4E00\\u6837\\u7684\\n        unordered_set<int> sets;\\n        for(int i = 0;i<remain.size();i++)\\n        {\\n            for(int j = i==0?1:0;j<remain[i];j++)\\n            {\\n                if(!sets.count(j))\\n                {\\n                    retv += A(9-i,remain.size()-1-i);\\n                }\\n            }\\n            if(sets.count(remain[i]))\\n                break;\\n            else\\n            {\\n                sets.insert(remain[i]);\\n            }\\n        }\\n        return N-retv;\\n        \\n    }\\n    int A(int n,int m)\\n    {\\n        //means C{n,m}\\n        //How can we deal with this problem, Can you give me a method to do ?\\n        //in this time, wo di it, such that.\\n        //A(n,m) = n*n-1*n-2*..n-m+1 = (n-m+1)*A(n,m-1)\\n        return m == 0?1:(n-m+1)*A(n,m-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nauto __ =[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        //\\u65E2\\u7136\\u8BA1\\u7B97\\u7684\\u662F\\u91CD\\u590D\\u7684\\u4E2A\\u6570\\u6211\\u4EEC\\u53EF\\u4EE5\\u8BA1\\u7B97\\u4E0D\\u91CD\\u590D\\u7684\\u4E2A\\u6570\\uFF0C\\u8FD9\\u5C31\\u662F\\u4E2A\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u95EE\\u9898\\n        //\\u5BF9\\u4E8E\\u8FD9\\u4E2A\\u95EE\\u9898\\u6211\\u4EEC\\u8981\\u5148\\u5199\\u51FA\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u7B97\\u6CD5\\u3002\\n        // second we must define our method upper  boader.\\n        // such that 8999-->(9,0,0,0) \\n        // \\n        int retv  = 0;\\n        vector<int> remain;\\n        for(int n = N+1;n>0;n/=10)\\n        {\\n            remain.insert(remain.begin(),n%10);\\n        }\\n        for(int i =1;i<remain.size();i++)\\n        {\\n            retv+=9*A(9,i-1);\\n        }\\n        // condition ,if this \\u548C\\u524D\\u9762\\u7684\\u4E00\\u6837\\u5219\\u8DF3\\u8FC7\\uFF0C\\u56E0\\u4E3A\\u4E0D\\u80FD\\u6709\\u91CD\\u590D\\u7684\\uFF0C\\u5982\\u679C\\u5B58\\u5728\\u4E24\\u4E2A\\u4E0A\\u754C\\u4E00\\u6837beak \\u6389\\uFF0C\\u56E0\\u4E3A\\u4E0D\\u53EF\\u80FD\\u5728\\u4ECE\\u8FD9\\u91CC\\u51FA\\u73B0\\u4E24\\u4E2A\\u5B8C\\u5168\\u4E0D\\u4E00\\u6837\\u7684\\n        unordered_set<int> sets;\\n        for(int i = 0;i<remain.size();i++)\\n        {\\n            for(int j = i==0?1:0;j<remain[i];j++)\\n            {\\n                if(!sets.count(j))\\n                {\\n                    retv += A(9-i,remain.size()-1-i);\\n                }\\n            }\\n            if(sets.count(remain[i]))\\n                break;\\n            else\\n            {\\n                sets.insert(remain[i]);\\n            }\\n        }\\n        return N-retv;\\n        \\n    }\\n    int A(int n,int m)\\n    {\\n        //means C{n,m}\\n        //How can we deal with this problem, Can you give me a method to do ?\\n        //in this time, wo di it, such that.\\n        //A(n,m) = n*n-1*n-2*..n-m+1 = (n-m+1)*A(n,m-1)\\n        return m == 0?1:(n-m+1)*A(n,m-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257004,
                "title": "math-o-logn",
                "content": "Count the number without repeated digit.\\nwe start with the highest bit of N, if N is 1000,  the highest bit must less than 1, so we start with 0,\\nthe biggest number without repeated dight is 999, the leghth is 3.\\nthe highest bit can be 1~9 ( we count numbers start with 0 later) ,  the second bit can be 0~9, excluding that is the same with the previous bits... and so on.\\nthe total number is 9*(10-1)*(10-2)+count(2,9) ( if the second bit is 0, we consider it as a new number whose lenght is 2)\\n\\n```\\npublic int numDupDigitsAtMostN(int N) {\\n        int n=N;\\n        int count=0;\\n        int[] arr=new int[11];\\n        while (n>0) {\\n            arr[++count]=n%10;\\n            n/=10;\\n        }\\n        int res=count(count, arr[count]-1);\\n        Set<Integer> set=new HashSet<>(10);\\n        set.add(arr[count]);\\n        for (int i = count-1; i >0; i--) {\\n            int maxcur=arr[i], rems=0;\\n            while (maxcur>=0 && set.contains(maxcur))\\n                maxcur--;\\n            if(maxcur<0) break;\\n            set.add(maxcur);\\n            int bit=maxcur-1;\\n            while (bit>=0){\\n                if(!set.contains(bit)) rems++;\\n                bit--;\\n            }\\n            if(maxcur<arr[i]) rems++;\\n            int cnt=rems;\\n            for (int j = 1; j < i; j++) {\\n                cnt*=(10-(count-i)-j);\\n            }\\n            res+=cnt;\\n            if(maxcur<arr[i]) {\\n                set.remove(maxcur);\\n                break;\\n            }\\n            arr[i]=maxcur;\\n        }\\n        if(set.size()==count) res+=1;\\n        return N-res;\\n    }\\n\\t//count the number  without repeated digit and the highest less than num, the lenght is n\\n    public int count(int n, int num){\\n        if(n<1) return 0;\\n        if(n==1) return num;\\n        int count=0, N=n;\\n\\t\\t//the highest bit isn\\'t 0\\n        if(num>0) {\\n            count=num;\\n            while (--n > 0) {\\n                count *= (10 - n);\\n            }\\n        }\\n\\t\\t//if the highest bit is 0\\n        count+=count(N-1, 9);\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numDupDigitsAtMostN(int N) {\\n        int n=N;\\n        int count=0;\\n        int[] arr=new int[11];\\n        while (n>0) {\\n            arr[++count]=n%10;\\n            n/=10;\\n        }\\n        int res=count(count, arr[count]-1);\\n        Set<Integer> set=new HashSet<>(10);\\n        set.add(arr[count]);\\n        for (int i = count-1; i >0; i--) {\\n            int maxcur=arr[i], rems=0;\\n            while (maxcur>=0 && set.contains(maxcur))\\n                maxcur--;\\n            if(maxcur<0) break;\\n            set.add(maxcur);\\n            int bit=maxcur-1;\\n            while (bit>=0){\\n                if(!set.contains(bit)) rems++;\\n                bit--;\\n            }\\n            if(maxcur<arr[i]) rems++;\\n            int cnt=rems;\\n            for (int j = 1; j < i; j++) {\\n                cnt*=(10-(count-i)-j);\\n            }\\n            res+=cnt;\\n            if(maxcur<arr[i]) {\\n                set.remove(maxcur);\\n                break;\\n            }\\n            arr[i]=maxcur;\\n        }\\n        if(set.size()==count) res+=1;\\n        return N-res;\\n    }\\n\\t//count the number  without repeated digit and the highest less than num, the lenght is n\\n    public int count(int n, int num){\\n        if(n<1) return 0;\\n        if(n==1) return num;\\n        int count=0, N=n;\\n\\t\\t//the highest bit isn\\'t 0\\n        if(num>0) {\\n            count=num;\\n            while (--n > 0) {\\n                count *= (10 - n);\\n            }\\n        }\\n\\t\\t//if the highest bit is 0\\n        count+=count(N-1, 9);\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256894,
                "title": "golang-dp",
                "content": "\\ncount(0, dn...d1) = count(0, 9...9) + count(10...0, dn...d1)\\ncount(10...0, dn...d1) = count(10...0, dn0...0-1) + count(dn0...0, dn...d1)\\n\\ndefine dp(s, n), the count for numbers who has n-digits not determined yet and s is its 0-9 indicator for its known digits. (do not care whether its known digits are all 0s)\\ndp(s, n) = sum(s&(1<<i)? 10...0: dp(s|1<<i, n-1) for i in 0...9 )\\n\\nhence:\\ncount(0, 9...9) = sum(countd(n) for n in {1..dn}) and countd(n) = sum(dfs(1<<i, n-1) for i in {1..9})\\ncount(dn0...0, dn...d1) = sum(count(dni0...0, dn(i+1)0...0-1)  for i in {0...d(n-1)-1})\\nkeep track of the 0-9 mask for the processed digits, and if 0-9 mask already 1, then count all the possibles , otherwise solve sub problem.\\n\\nMaybe this is way too unnecessarily complex...... sadly this is how my brain wired....\\n```\\nvar dp map[int]int\\nvar cs = []int{1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000}\\n/* s is a 10-bit map indicating whether 0-9 digits already exist\\ndp[s][n] yield a count for numbers which have at least  n digits number, and some prefix map s\\n*/\\nfunc dfs(s, n int) int {\\n    if n<=0 { return 0; }\\n    k := (s<<4)|n;\\n    if v, ok := dp[k]; ok {\\n        return v\\n    }\\n    c := 0\\n    var i uint\\n    for i=0; i<10; i++ {\\n        if (s&(1<<i)) != 0 {\\n            c += cs[n-1]\\n        } else {\\n            c += dfs(s|(1<<i), n-1)\\n        }\\n    }\\n    dp[k] = c\\n    return c\\n}\\n\\n/* count n digit numbers, between 10...0 to 99...9 */\\nfunc count(n int) int {\\n    if n<=1 { return 0 }\\n    c := 0\\n    var i uint\\n    for i=1; i<10; i++ {\\n        c += dfs(1<<i, n-1)\\n    }\\n    return c\\n}\\n\\nfunc numDupDigitsAtMostN(N int) int {\\n    if dp==nil { dp = make(map[int]int) }\\n    rem := make([]int, 10)\\n    for i:=0; i<10; i++ { rem[i] = N % cs[i] }\\n    d, ds := 0, make([]uint, 16)\\n    for {\\n        ds[d] = uint(N % 10)\\n        d += 1\\n        N /= 10\\n        if N==0 { break }\\n    }\\n    c, s := 0, 0\\n    /* accumulate counts from 0 to 9...9, where 9...9 < N */\\n    for i:=1; i<d; i++ { c += count(i) }\\n    /* from higher digit down, accumulate d(i+1)0..0 to d(i+1)d(i)0..0-1 */\\n    for i:=d-1; i>=0; i-- {\\n        var j uint\\n        if i==d-1 {j=1}\\n        for ; j<ds[i]; j++ {\\n            if ((s&(1<<j)) != 0) {\\n                c += cs[i]\\n            } else {\\n                c += dfs(s|(1<<j), i);\\n            }\\n        }\\n        if (s&(1<<ds[i])) != 0 {\\n            /* all the remaining numbers should be counted */\\n            c += (rem[i]+1)\\n            break\\n        }\\n        s |= (1<<ds[i])\\n    }\\n    return c\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar dp map[int]int\\nvar cs = []int{1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000}\\n/* s is a 10-bit map indicating whether 0-9 digits already exist\\ndp[s][n] yield a count for numbers which have at least  n digits number, and some prefix map s\\n*/\\nfunc dfs(s, n int) int {\\n    if n<=0 { return 0; }\\n    k := (s<<4)|n;\\n    if v, ok := dp[k]; ok {\\n        return v\\n    }\\n    c := 0\\n    var i uint\\n    for i=0; i<10; i++ {\\n        if (s&(1<<i)) != 0 {\\n            c += cs[n-1]\\n        } else {\\n            c += dfs(s|(1<<i), n-1)\\n        }\\n    }\\n    dp[k] = c\\n    return c\\n}\\n\\n/* count n digit numbers, between 10...0 to 99...9 */\\nfunc count(n int) int {\\n    if n<=1 { return 0 }\\n    c := 0\\n    var i uint\\n    for i=1; i<10; i++ {\\n        c += dfs(1<<i, n-1)\\n    }\\n    return c\\n}\\n\\nfunc numDupDigitsAtMostN(N int) int {\\n    if dp==nil { dp = make(map[int]int) }\\n    rem := make([]int, 10)\\n    for i:=0; i<10; i++ { rem[i] = N % cs[i] }\\n    d, ds := 0, make([]uint, 16)\\n    for {\\n        ds[d] = uint(N % 10)\\n        d += 1\\n        N /= 10\\n        if N==0 { break }\\n    }\\n    c, s := 0, 0\\n    /* accumulate counts from 0 to 9...9, where 9...9 < N */\\n    for i:=1; i<d; i++ { c += count(i) }\\n    /* from higher digit down, accumulate d(i+1)0..0 to d(i+1)d(i)0..0-1 */\\n    for i:=d-1; i>=0; i-- {\\n        var j uint\\n        if i==d-1 {j=1}\\n        for ; j<ds[i]; j++ {\\n            if ((s&(1<<j)) != 0) {\\n                c += cs[i]\\n            } else {\\n                c += dfs(s|(1<<j), i);\\n            }\\n        }\\n        if (s&(1<<ds[i])) != 0 {\\n            /* all the remaining numbers should be counted */\\n            c += (rem[i]+1)\\n            break\\n        }\\n        s |= (1<<ds[i])\\n    }\\n    return c\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256880,
                "title": "digit-dp-soln",
                "content": "class Solution {\\npublic:\\n    string num;\\n    int l ;\\n    int dp[11][2][2][1030];\\n    \\n    int d(int N)\\n    {\\n        int c = 0;\\n        while(N)\\n        {\\n            c++;\\n            N /= 10;\\n        }\\n        return c;\\n    }\\n    \\n    int solve(int bit, int tight, int nonz, int mask)\\n    {\\n        if(dp[bit][tight][nonz][mask] != -1)\\n            return dp[bit][tight][nonz][mask];\\n        \\n        if(bit == l)\\n        {\\n            if(nonz)\\n                return dp[bit][tight][nonz][mask] = 1;\\n            else\\n                return dp[bit][tight][nonz][mask] = 0;\\n        }\\n        \\n        int v = num[bit] - \\'0\\';\\n        //cout << v << \\'\\\\n\\';\\n        int cans = 0;\\n        if(tight)\\n        {\\n            for(int i = 0; i <= v; i++)\\n            {\\n                int new_mask = mask;\\n                int new_tight = 0;\\n                int c_bit = ((mask >> i) & 1);\\n                if(nonz || (i != 0))\\n                    new_mask |= (1 << i);\\n                if(i == v)\\n                    new_tight = 1;\\n                if(c_bit == 0)\\n                    cans += solve(bit + 1, new_tight, nonz || (i != 0),new_mask);\\n            }\\n        }\\n        else\\n        {\\n            for(int i = 0; i <= 9; i++)\\n            {\\n                int new_mask = mask;\\n                int c_bit = ((mask >> i) & 1);\\n                if(nonz || (i != 0))\\n                    new_mask |= (1 << i);\\n                if(c_bit == 0)\\n                    cans += solve(bit + 1, 0, nonz || (i != 0), new_mask);\\n            }\\n        }\\n        return dp[bit][tight][nonz][mask] = cans;\\n    }\\n    int numDupDigitsAtMostN(int N) {\\n        int dig = d(N);\\n        num = to_string(N);\\n        l = num.size();\\n        memset(dp, -1, sizeof dp);\\n        return (N - solve(0,1,0,0));\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string num;\\n    int l ;\\n    int dp[11][2][2][1030];\\n    \\n    int d(int N)\\n    {\\n        int c = 0;\\n        while(N)\\n        {\\n            c++;\\n            N /= 10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4076746,
                "title": "c-simple-digit-dp-solution",
                "content": "# Approach\\nWe find the count of numbers having only distinct digits between 1 to n with the help of digit dp, and simply subtract it from n to get the answer.\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n\\n- Space complexity: $$O(log(n)*len(mask))$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dp[11][2][1024][2];\\n\\n    int f(string s, int n, bool tight, int mask, bool leadingZero){\\n        if(n == 0){\\n            return !leadingZero;\\n        }\\n        if(dp[n][tight][mask][leadingZero] != -1){\\n            return dp[n][tight][mask][leadingZero];\\n        }\\n        int answer = 0;\\n        int ub = tight ? s[s.size() - n] - \\'0\\': 9;\\n        for(int i = 0; i <= ub; i++){\\n            if(leadingZero and i == 0) answer += f(s, n - 1, 0, mask, 1);\\n            else{\\n                if((mask & (1 << i)) == 0){\\n                    answer += f(s, n - 1, tight && (i == ub), mask + (1 << i), 0);\\n                }\\n            }\\n        }\\n        return dp[n][tight][mask][leadingZero] = answer;\\n    }\\n\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        memset(dp, -1, sizeof dp);\\n        return n - f(s, s.size(), 1, 0, 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Dynamic Programming",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[11][2][1024][2];\\n\\n    int f(string s, int n, bool tight, int mask, bool leadingZero){\\n        if(n == 0){\\n            return !leadingZero;\\n        }\\n        if(dp[n][tight][mask][leadingZero] != -1){\\n            return dp[n][tight][mask][leadingZero];\\n        }\\n        int answer = 0;\\n        int ub = tight ? s[s.size() - n] - \\'0\\': 9;\\n        for(int i = 0; i <= ub; i++){\\n            if(leadingZero and i == 0) answer += f(s, n - 1, 0, mask, 1);\\n            else{\\n                if((mask & (1 << i)) == 0){\\n                    answer += f(s, n - 1, tight && (i == ub), mask + (1 << i), 0);\\n                }\\n            }\\n        }\\n        return dp[n][tight][mask][leadingZero] = answer;\\n    }\\n\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        memset(dp, -1, sizeof dp);\\n        return n - f(s, s.size(), 1, 0, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050150,
                "title": "my-0ms-c-solution-very-difficult-to-understand-understand-if-you-can",
                "content": "# Intuition\\nIf you are willing to understand how my code works, pleaes comment below. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int G(vector<int>& number, int i, bool flag){ // i=1,2...n, flag is if previous all digits were 0\\n        int n = number.size();\\n        if (i > n) return 0;\\n        int dig = number[i-1];\\n        if (flag){\\n            int ct = 9;\\n            int rem = 9;\\n            for(int j=i+1;j<=n;j++){\\n                ct *= rem;\\n                rem--;\\n            }\\n            ct += G(number, i+1, true);\\n            return ct;\\n        }\\n        else if (i == 1){\\n            //options are 1..dig-1\\n            int op = dig-1;\\n            int ct = op;\\n            int rem = 9;\\n            for(int j = i+1;j<=n;j++){\\n                ct *= rem;\\n                rem--;\\n            }\\n            if (i == n) ct++;\\n            else ct += G(number, i+1,false);\\n            ct += G(number, i+1, true);\\n            return ct;\\n        }\\n\\n\\n\\n\\n\\n        bool available[10]; memset(available, true, sizeof(available));\\n\\n        for(int j=1;j<i;j++){\\n            int tmpDig = number[j-1];\\n            available[tmpDig] = false;\\n        }\\n        int rem = 0;\\n        int ct = 0;\\n        for(int d = 0; d<10;d++){\\n            if (available[d]) rem++;\\n            if (d<dig && available[d]) ct++;\\n        }\\n        for(int j=i+1;j<=n;j++){\\n            ct *= (--rem);\\n        }\\n        if (available[dig] && i == n) ct++;\\n        else if (available[dig]){\\n            ct += G(number, i+1, false);\\n        }\\n        return ct;\\n\\n\\n    }\\n\\n    int numDupDigitsAtMostN(int n) {\\n        string num = to_string(n);\\n        vector<int> number;\\n        for(char c : num){\\n            number.push_back(c-\\'0\\');\\n        }\\n        int res = G(number, 1, false);\\n        cout << res << endl;\\n        cout << n-res << endl;\\n       return n-res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int G(vector<int>& number, int i, bool flag){ // i=1,2...n, flag is if previous all digits were 0\\n        int n = number.size();\\n        if (i > n) return 0;\\n        int dig = number[i-1];\\n        if (flag){\\n            int ct = 9;\\n            int rem = 9;\\n            for(int j=i+1;j<=n;j++){\\n                ct *= rem;\\n                rem--;\\n            }\\n            ct += G(number, i+1, true);\\n            return ct;\\n        }\\n        else if (i == 1){\\n            //options are 1..dig-1\\n            int op = dig-1;\\n            int ct = op;\\n            int rem = 9;\\n            for(int j = i+1;j<=n;j++){\\n                ct *= rem;\\n                rem--;\\n            }\\n            if (i == n) ct++;\\n            else ct += G(number, i+1,false);\\n            ct += G(number, i+1, true);\\n            return ct;\\n        }\\n\\n\\n\\n\\n\\n        bool available[10]; memset(available, true, sizeof(available));\\n\\n        for(int j=1;j<i;j++){\\n            int tmpDig = number[j-1];\\n            available[tmpDig] = false;\\n        }\\n        int rem = 0;\\n        int ct = 0;\\n        for(int d = 0; d<10;d++){\\n            if (available[d]) rem++;\\n            if (d<dig && available[d]) ct++;\\n        }\\n        for(int j=i+1;j<=n;j++){\\n            ct *= (--rem);\\n        }\\n        if (available[dig] && i == n) ct++;\\n        else if (available[dig]){\\n            ct += G(number, i+1, false);\\n        }\\n        return ct;\\n\\n\\n    }\\n\\n    int numDupDigitsAtMostN(int n) {\\n        string num = to_string(n);\\n        vector<int> number;\\n        for(char c : num){\\n            number.push_back(c-\\'0\\');\\n        }\\n        int res = G(number, 1, false);\\n        cout << res << endl;\\n        cout << n-res << endl;\\n       return n-res; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4031069,
                "title": "digit-dp-bitmask-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[10][2][2][1 << 10];\\n\\t//lead variable handles cases where leading values are zero in a number\\n\\t//solve function calculates the total numbers less than equal to n, not having repeating digits\\n    int solve(int ind, int tight, int lead, vector<int> &nums, int mask) {\\n        if(ind == nums.size()) {\\n            return 1;\\n        }\\n        \\n        if(dp[ind][tight][lead][mask] != -1) return dp[ind][tight][lead][mask];\\n        int ub = 9;\\n        if(tight) ub = nums[ind];\\n        int ans = 0;\\n        for(int i = 0;i <= ub;i++) {\\n            if(i == 0 && lead) {\\n                ans += solve(ind+1, 0, 1, nums, mask);\\n            }\\n            else {\\n                if(mask&(1 << i)) {\\n                    ans += solve(ind+1, tight&(i==ub), 0, nums, mask^(1<<i));\\n                }\\n            }\\n        }\\n        return dp[ind][tight][lead][mask]=ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        int num = n;\\n        int mask = (1 << 10)-1;\\n        vector<int> nums;\\n        while(n) {\\n            int d = n%10;\\n            n /= 10;\\n            nums.push_back(d);\\n        }\\n        vector<int> digs(10, 0);\\n        reverse(nums.begin(), nums.end());\\n        memset(dp, -1, sizeof dp);\\n\\t\\t//we subtract 1 to eliminate the all 0\\'s case\\n        int ans = solve(0, 1, 1, nums, mask)-1;\\n        return num-ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10][2][2][1 << 10];\\n\\t//lead variable handles cases where leading values are zero in a number\\n\\t//solve function calculates the total numbers less than equal to n, not having repeating digits\\n    int solve(int ind, int tight, int lead, vector<int> &nums, int mask) {\\n        if(ind == nums.size()) {\\n            return 1;\\n        }\\n        \\n        if(dp[ind][tight][lead][mask] != -1) return dp[ind][tight][lead][mask];\\n        int ub = 9;\\n        if(tight) ub = nums[ind];\\n        int ans = 0;\\n        for(int i = 0;i <= ub;i++) {\\n            if(i == 0 && lead) {\\n                ans += solve(ind+1, 0, 1, nums, mask);\\n            }\\n            else {\\n                if(mask&(1 << i)) {\\n                    ans += solve(ind+1, tight&(i==ub), 0, nums, mask^(1<<i));\\n                }\\n            }\\n        }\\n        return dp[ind][tight][lead][mask]=ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        int num = n;\\n        int mask = (1 << 10)-1;\\n        vector<int> nums;\\n        while(n) {\\n            int d = n%10;\\n            n /= 10;\\n            nums.push_back(d);\\n        }\\n        vector<int> digs(10, 0);\\n        reverse(nums.begin(), nums.end());\\n        memset(dp, -1, sizeof dp);\\n\\t\\t//we subtract 1 to eliminate the all 0\\'s case\\n        int ans = solve(0, 1, 1, nums, mask)-1;\\n        return num-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009695,
                "title": "one-of-the-best-digit-dp-bitmask-question-solution-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[70][2][1025][2][2];\\n    int f(int i,int t,int flag,int flag2,int flag3,string &s){\\n\\n        if(i == s.size() && flag2 == true)return 1;\\n        else if(i == s.size())return 0;\\n        \\n        if(dp[i][t][flag][flag2][flag3]!=-1)return dp[i][t][flag][flag2][flag3];\\n\\n        int ans = 0;\\n        int high = t ? s[i]-\\'0\\' : 9;\\n        int low = 0;\\n        for(int k=low;k<=high;k++){\\n            if(flag3 == false){//we have not yet started \\n                if(k == 0)ans+=f(i+1,t && high == k,flag,flag2,0,s);\\n                else ans+= f(i+1,t && high == k,flag|(1<<k),0,1,s);\\n            }\\n            else if((flag&(1<<k))){//this digit is already taken previously\\n                ans+= f(i+1,t && high == k,flag|(1<<k),1,1,s);//i have taken repeated digit\\n            }\\n            else ans+=f(i+1,t && high == k,flag|(1<<k),flag2,1,s);\\n        }\\n        return dp[i][t][flag][flag2][flag3] = ans;\\n    }\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        \\n        string res = \"\";\\n        while(n>0){\\n            res.push_back(n%10+\\'0\\');\\n            n = n/10;\\n        }\\n        reverse(res.begin(),res.end());\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,1,0,0,0,res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int dp[70][2][1025][2][2];\\n    int f(int i,int t,int flag,int flag2,int flag3,string &s){\\n\\n        if(i == s.size() && flag2 == true)return 1;\\n        else if(i == s.size())return 0;\\n        \\n        if(dp[i][t][flag][flag2][flag3]!=-1)return dp[i][t][flag][flag2][flag3];\\n\\n        int ans = 0;\\n        int high = t ? s[i]-\\'0\\' : 9;\\n        int low = 0;\\n        for(int k=low;k<=high;k++){\\n            if(flag3 == false){//we have not yet started \\n                if(k == 0)ans+=f(i+1,t && high == k,flag,flag2,0,s);\\n                else ans+= f(i+1,t && high == k,flag|(1<<k),0,1,s);\\n            }\\n            else if((flag&(1<<k))){//this digit is already taken previously\\n                ans+= f(i+1,t && high == k,flag|(1<<k),1,1,s);//i have taken repeated digit\\n            }\\n            else ans+=f(i+1,t && high == k,flag|(1<<k),flag2,1,s);\\n        }\\n        return dp[i][t][flag][flag2][flag3] = ans;\\n    }\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        \\n        string res = \"\";\\n        while(n>0){\\n            res.push_back(n%10+\\'0\\');\\n            n = n/10;\\n        }\\n        reverse(res.begin(),res.end());\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,1,0,0,0,res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989118,
                "title": "digit-dp-bitmask-java-solution",
                "content": "# Intuition\\nDigit DP and Bitmask\\n\\n# Approach\\n1. **Dynamic Programming (DP):** Your approach uses dynamic programming to break down the problem into smaller subproblems and avoid redundant computations.\\n\\n2. **Memoization:** You employ memoization to store intermediate results in a 4D array named `dp`. The four dimensions of `dp` are:\\n   - `idx`: The current index in the string representation of `n`.\\n   - `mask`: A bitmask to track which digits have been used so far.\\n   - `flag`: A boolean flag indicating whether a repeated digit has been encountered.\\n   - `tight`: A flag to control whether the current digit should be constrained to be less than or equal to the corresponding digit in `n`.\\n\\n3. **Recursive Helper Function:** The core of your solution is the `helper` function, which recursively explores different digit possibilities at each index of the number.\\n\\n4. **Base Case:** The base case of the recursion is when `idx` reaches the length of the string representation of `n`. In this case, you return the `flag` value, which indicates whether you\\'ve encountered a repeated digit during the recursive exploration.\\n\\n5. **Exploring Digits:** For each digit from 0 to 9, you check if it can be used in the current position based on the following conditions:\\n   - If `i == 0` and `mask == 0`, it means this digit is leading, and you recursively call the `helper` function with `flag` set to 0, indicating no repeated digits.\\n   - If `(mask & (1 << i)) == 0`, it means this digit hasn\\'t been used before, and you recursively call the `helper` function with the `mask` updated to mark this digit as used. You also update `flag` if necessary based on whether it\\'s the last digit (`tight`).\\n   - Otherwise, if this digit has been used before, you update `flag` and continue exploring other digits.\\n\\n6. **Dynamic Programming Memoization:** You store the count of valid combinations at the current state `(idx, mask, flag, tight)` in the `dp` array. Before making a recursive call, you check if the result for that state is already computed and stored in `dp`. If it is, you directly return the memoized result, which avoids redundant computation.\\n\\n7. **Return Result:** Finally, you return the count of valid combinations from the initial state `(0, 0, 0, 1)` where `idx` is 0 (start of the string representation of `n`), `mask` is 0 (no digits used initially), `flag` is 0 (no repeated digits initially), and `tight` is 1 (the current digit is not constrained).\\n\\n# Time Complexity\\n The code explores all possibilities for each digit from 0 to 9 for each position in the string representation of n. Therefore, the time complexity is O(10 * len(num)), where len(num) is the length of the string representation of n. In other words, it\\'s linear in the number of digits in n.\\n\\n# Space Complexity \\nThe space complexity is O(10 * len(num) * 2 * 2) for the dp array, which simplifies to O(len(num)) since the other constants are relatively small.\\n\\n# Code\\n```\\nclass Solution {\\n    Integer[][][][] dp = new Integer[10][1 << 10][2][2];\\n    public int numDupDigitsAtMostN(int n) {\\n        String num = Integer.toString(n);\\n        return helper(num,0,0,0,1);\\n    }\\n    private int helper(String num,int idx,int mask,int flag,int tight){\\n        if(idx == num.length()) return flag;\\n        if(dp[idx][mask][flag][tight] != null) return dp[idx][mask][flag][tight];\\n        int max = tight == 1? num.charAt(idx) - \\'0\\' : 9;\\n        int count = 0;\\n        for (int i = 0; i <= max; i++) {\\n                if(i == 0 && mask == 0) count += helper(num,idx+1,0,0,0);\\n                else if((mask & (1 << i)) == 0) count += helper(num,idx+1,mask | (1<<i),flag,tight == 1 && i == max ? 1:0);\\n                else count += helper(num,idx+1,mask,1,tight==1 && i==max?1:0);\\n            }\\n        return dp[idx][mask][flag][tight] = count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    Integer[][][][] dp = new Integer[10][1 << 10][2][2];\\n    public int numDupDigitsAtMostN(int n) {\\n        String num = Integer.toString(n);\\n        return helper(num,0,0,0,1);\\n    }\\n    private int helper(String num,int idx,int mask,int flag,int tight){\\n        if(idx == num.length()) return flag;\\n        if(dp[idx][mask][flag][tight] != null) return dp[idx][mask][flag][tight];\\n        int max = tight == 1? num.charAt(idx) - \\'0\\' : 9;\\n        int count = 0;\\n        for (int i = 0; i <= max; i++) {\\n                if(i == 0 && mask == 0) count += helper(num,idx+1,0,0,0);\\n                else if((mask & (1 << i)) == 0) count += helper(num,idx+1,mask | (1<<i),flag,tight == 1 && i == max ? 1:0);\\n                else count += helper(num,idx+1,mask,1,tight==1 && i==max?1:0);\\n            }\\n        return dp[idx][mask][flag][tight] = count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985965,
                "title": "math-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        num_list = []\\n        original_n = n\\n        while n > 0:\\n            num_list.append(n % 10)\\n            n = n // 10\\n        num_list.reverse()\\n\\n        digit_num = len(num_list)\\n        # str_n = str(n)\\n        o = len(num_list) - 1\\n        \\n        ans_o = 0\\n        while o > 0:\\n            o_a = 9\\n            for i in range(o-1):\\n                o_a *= (9-i)\\n            ans_o += o_a\\n            o -= 1\\n            \\n        ans = 0\\n        should_break = 0\\n\\n        for i in range(digit_num):\\n            print(i)\\n            # if num_list[i] != 0:\\n            minus_num = 0\\n\\n            for j in range(i):\\n                if num_list[j] < num_list[i]:\\n                    minus_num += 1\\n                elif num_list[j] == num_list[i]:\\n                    should_break = 1\\n\\n            p = 1\\n            for q in range(10-i-1, 10 - digit_num, -1):\\n                p *= q\\n            \\n            if i == 0:\\n                ans += (num_list[i] - 1) * p + ans_o\\n                print(\\'ti\\', ans)\\n\\n            elif i != 0:\\n                ans += (num_list[i] - minus_num) * p\\n                print(\\'to\\', ans)\\n\\n            if should_break:\\n                break\\n\\n        print(ans)\\n\\n        # last_digit + 1 & first_digit zero cases\\n        return original_n - ans - 1 if len(set(num_list))==digit_num else original_n - ans\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        num_list = []\\n        original_n = n\\n        while n > 0:\\n            num_list.append(n % 10)\\n            n = n // 10\\n        num_list.reverse()\\n\\n        digit_num = len(num_list)\\n        # str_n = str(n)\\n        o = len(num_list) - 1\\n        \\n        ans_o = 0\\n        while o > 0:\\n            o_a = 9\\n            for i in range(o-1):\\n                o_a *= (9-i)\\n            ans_o += o_a\\n            o -= 1\\n            \\n        ans = 0\\n        should_break = 0\\n\\n        for i in range(digit_num):\\n            print(i)\\n            # if num_list[i] != 0:\\n            minus_num = 0\\n\\n            for j in range(i):\\n                if num_list[j] < num_list[i]:\\n                    minus_num += 1\\n                elif num_list[j] == num_list[i]:\\n                    should_break = 1\\n\\n            p = 1\\n            for q in range(10-i-1, 10 - digit_num, -1):\\n                p *= q\\n            \\n            if i == 0:\\n                ans += (num_list[i] - 1) * p + ans_o\\n                print(\\'ti\\', ans)\\n\\n            elif i != 0:\\n                ans += (num_list[i] - minus_num) * p\\n                print(\\'to\\', ans)\\n\\n            if should_break:\\n                break\\n\\n        print(ans)\\n\\n        # last_digit + 1 & first_digit zero cases\\n        return original_n - ans - 1 if len(set(num_list))==digit_num else original_n - ans\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975032,
                "title": "c-digit-dp-with-bitmask-beat-90-solution",
                "content": "```\\nclass Solution {\\npublic: \\n    vector<int> val{1,10,100,1000,10000,100000,1000000,10000000,100000000};\\n    int dp[11][4096][2][2];\\n    int solve(int i,int x,int tight,int chk,string &s)\\n    {\\n        if(i==s.size())\\n            return 0;\\n        if(dp[i][x][tight][chk]!=-1)\\n            return dp[i][x][tight][chk];\\n        \\n        int tem=0;\\n        if(chk==1)\\n        {\\n             if(tight==1)\\n            {\\n            int p=s[i]-\\'0\\';\\n                 \\n            for(int k=0;k<=p;k++)\\n            {\\n                if(k==p)\\n                {\\n                    if(k==0)\\n                    {\\n                        tem+=solve(i+1,x,1,1,s);\\n                    }\\n                    else\\n                    {\\n                    int y=1<<k;\\n                    if((x & y)==0)\\n                      tem+=solve(i+1,x | y,1,0,s);\\n                    else\\n                       {\\n                          \\n                        if(i+1==s.size())\\n                            tem+=1;\\n                        else\\n                        {\\n                        string st=s.substr(i+1);\\n                            int a=stoi(st);\\n                            a++;\\n                        tem+=a;\\n                        }\\n                       }\\n                    }\\n                }\\n                else\\n                {\\n                    if(k==0)\\n                    {\\n                        tem+=solve(i+1,x,0,1,s);\\n                    }\\n                    else\\n                    {\\n                    int y=1<<k;\\n                    \\n                    if((x & y)==0)\\n                    tem+=solve(i+1,x | y,0,0,s);\\n                    else\\n                        {\\n                          int a=(int)(s.size())-1-i;\\n                        tem+=val[a];\\n                       }\\n                    }\\n                }\\n            }\\n        }\\n            else\\n            {\\n            for(int k=0;k<=9;k++)\\n            {\\n                    if(k==0)\\n                    {\\n                        tem+=solve(i+1,x,0,1,s);\\n                    }\\n                    else\\n                    {\\n                     int y=1<<k;\\n                    \\n                    if((x & y)==0)\\n                    tem+=solve(i+1,x | y,0,0,s);\\n                    else\\n                        {\\n                          int a=(int)(s.size())-1-i;\\n                        tem+=val[a];\\n                       }\\n                    }\\n            }\\n          }\\n        }\\n        else\\n        {\\n           if(tight==1)\\n          {\\n            int p=s[i]-\\'0\\';\\n            for(int k=0;k<=p;k++)\\n            {\\n                if(k==p)\\n                {\\n                    int y=1<<k;\\n                    if((x & y)==0)\\n                      tem+=solve(i+1,x | y,1,0,s);\\n                    else\\n                      {\\n                           if(i+1==s.size())\\n                            tem+=1;\\n                        else\\n                        {\\n                        string st=s.substr(i+1);\\n                            int a=stoi(st);\\n                            a++;\\n                        tem+=a;\\n                        }\\n                       }\\n                }\\n                else\\n                {\\n                    int y=1<<k;\\n                    \\n                    if((x & y)==0)\\n                    tem+=solve(i+1,x | y,0,0,s);\\n                    else\\n                        {\\n                          int a=(int)(s.size())-1-i;\\n                        tem+=val[a];\\n                       }\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int k=0;k<=9;k++)\\n            {\\n                int y=1<<k;\\n                    \\n                    if((x & y)==0)\\n                    tem+=solve(i+1,x | y,0,0,s);\\n                    else\\n                        {\\n                          int a=(int)(s.size())-1-i;\\n                        tem+=val[a];\\n                       }\\n            }\\n          }\\n        }\\n        return dp[i][x][tight][chk]=tem;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s=to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,1,1,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    vector<int> val{1,10,100,1000,10000,100000,1000000,10000000,100000000};\\n    int dp[11][4096][2][2];\\n    int solve(int i,int x,int tight,int chk,string &s)\\n    {\\n        if(i==s.size())\\n            return 0;\\n        if(dp[i][x][tight][chk]!=-1)\\n            return dp[i][x][tight][chk];\\n        \\n        int tem=0;\\n        if(chk==1)\\n        {\\n             if(tight==1)\\n            {\\n            int p=s[i]-\\'0\\';\\n                 \\n            for(int k=0;k<=p;k++)\\n            {\\n                if(k==p)\\n                {\\n                    if(k==0)\\n                    {\\n                        tem+=solve(i+1,x,1,1,s);\\n                    }\\n                    else\\n                    {\\n                    int y=1<<k;\\n                    if((x & y)==0)\\n                      tem+=solve(i+1,x | y,1,0,s);\\n                    else\\n                       {\\n                          \\n                        if(i+1==s.size())\\n                            tem+=1;\\n                        else\\n                        {\\n                        string st=s.substr(i+1);\\n                            int a=stoi(st);\\n                            a++;\\n                        tem+=a;\\n                        }\\n                       }\\n                    }\\n                }\\n                else\\n                {\\n                    if(k==0)\\n                    {\\n                        tem+=solve(i+1,x,0,1,s);\\n                    }\\n                    else\\n                    {\\n                    int y=1<<k;\\n                    \\n                    if((x & y)==0)\\n                    tem+=solve(i+1,x | y,0,0,s);\\n                    else\\n                        {\\n                          int a=(int)(s.size())-1-i;\\n                        tem+=val[a];\\n                       }\\n                    }\\n                }\\n            }\\n        }\\n            else\\n            {\\n            for(int k=0;k<=9;k++)\\n            {\\n                    if(k==0)\\n                    {\\n                        tem+=solve(i+1,x,0,1,s);\\n                    }\\n                    else\\n                    {\\n                     int y=1<<k;\\n                    \\n                    if((x & y)==0)\\n                    tem+=solve(i+1,x | y,0,0,s);\\n                    else\\n                        {\\n                          int a=(int)(s.size())-1-i;\\n                        tem+=val[a];\\n                       }\\n                    }\\n            }\\n          }\\n        }\\n        else\\n        {\\n           if(tight==1)\\n          {\\n            int p=s[i]-\\'0\\';\\n            for(int k=0;k<=p;k++)\\n            {\\n                if(k==p)\\n                {\\n                    int y=1<<k;\\n                    if((x & y)==0)\\n                      tem+=solve(i+1,x | y,1,0,s);\\n                    else\\n                      {\\n                           if(i+1==s.size())\\n                            tem+=1;\\n                        else\\n                        {\\n                        string st=s.substr(i+1);\\n                            int a=stoi(st);\\n                            a++;\\n                        tem+=a;\\n                        }\\n                       }\\n                }\\n                else\\n                {\\n                    int y=1<<k;\\n                    \\n                    if((x & y)==0)\\n                    tem+=solve(i+1,x | y,0,0,s);\\n                    else\\n                        {\\n                          int a=(int)(s.size())-1-i;\\n                        tem+=val[a];\\n                       }\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int k=0;k<=9;k++)\\n            {\\n                int y=1<<k;\\n                    \\n                    if((x & y)==0)\\n                    tem+=solve(i+1,x | y,0,0,s);\\n                    else\\n                        {\\n                          int a=(int)(s.size())-1-i;\\n                        tem+=val[a];\\n                       }\\n            }\\n          }\\n        }\\n        return dp[i][x][tight][chk]=tem;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s=to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,1,1,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957371,
                "title": "c-digit-dp-bitmasking-clean-and-concise-code",
                "content": "# Approach\\nWe can find count of numbers which have all digits unique using digit dp and bitmasking, hence we will subtract that count from total numbers to get numbers with atleast 1 duplicate digit.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[11][1024][2];\\n    int solve(int pos,int mask,bool tight,string& s)\\n    {\\n        if(pos==s.size())\\n        return (mask!=0)?1:0;\\n        if(dp[pos][mask][tight]!=-1)\\n        return dp[pos][mask][tight];\\n\\n        int up = tight?(s[pos]-\\'0\\'):9;\\n        int ans = 0;\\n        for(int i=0;i<=up;i++)\\n        {\\n            if(mask&(1<<i))\\n            continue;\\n            int newT = tight & (i==up);\\n            int newM = (mask==0 && i==0)?mask:mask|(1<<i);\\n            ans+=solve(pos+1,newM,newT,s);\\n        }\\n        return dp[pos][mask][tight] = ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        string s = to_string(n);\\n        long long tot = n;\\n        return tot-solve(0,0,1,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[11][1024][2];\\n    int solve(int pos,int mask,bool tight,string& s)\\n    {\\n        if(pos==s.size())\\n        return (mask!=0)?1:0;\\n        if(dp[pos][mask][tight]!=-1)\\n        return dp[pos][mask][tight];\\n\\n        int up = tight?(s[pos]-\\'0\\'):9;\\n        int ans = 0;\\n        for(int i=0;i<=up;i++)\\n        {\\n            if(mask&(1<<i))\\n            continue;\\n            int newT = tight & (i==up);\\n            int newM = (mask==0 && i==0)?mask:mask|(1<<i);\\n            ans+=solve(pos+1,newM,newT,s);\\n        }\\n        return dp[pos][mask][tight] = ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        string s = to_string(n);\\n        long long tot = n;\\n        return tot-solve(0,0,1,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947545,
                "title": "kotlin-dp-digit-and-bit-masking",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private fun solve(i: Int, mask: Int, isRepeat: Int, isLast: Int, str: String, dp: Array<Array<Array<Array<Int>>>>): Int{\\n        if(i==str.length){\\n            return isRepeat;\\n        }\\n        if(dp[i][mask][isRepeat][isLast]!=-1){\\n            return dp[i][mask][isRepeat][isLast]\\n        }\\n        val till = if(isLast==1) str[i]-\\'0\\' else 9\\n        var ans= 0\\n        for(j in 0..till){\\n            val newIsLast = if(isLast==1 && j==till) 1 else 0\\n            if(mask==0 && j==0){\\n                ans += solve(i+1, mask, isRepeat, newIsLast, str, dp);\\n            }\\n            else if((mask and (1 shl j )) > 0){\\n                ans += solve(i+1, mask, 1, newIsLast, str, dp);\\n            }\\n            else if((mask and (1 shl j ))==0){\\n                ans += solve(i+1, mask or (1 shl j), isRepeat, newIsLast, str, dp)\\n            }\\n        }\\n        dp[i][mask][isRepeat][isLast] = ans\\n        return ans\\n    }\\n\\n    fun numDupDigitsAtMostN(n: Int): Int {\\n        val dp = Array(10) { Array(1 shl 10) { Array(2) { Array(2) { -1 } } } }\\n        val str = n.toString();\\n        return solve(0,0,0,1,str,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n\\n    private fun solve(i: Int, mask: Int, isRepeat: Int, isLast: Int, str: String, dp: Array<Array<Array<Array<Int>>>>): Int{\\n        if(i==str.length){\\n            return isRepeat;\\n        }\\n        if(dp[i][mask][isRepeat][isLast]!=-1){\\n            return dp[i][mask][isRepeat][isLast]\\n        }\\n        val till = if(isLast==1) str[i]-\\'0\\' else 9\\n        var ans= 0\\n        for(j in 0..till){\\n            val newIsLast = if(isLast==1 && j==till) 1 else 0\\n            if(mask==0 && j==0){\\n                ans += solve(i+1, mask, isRepeat, newIsLast, str, dp);\\n            }\\n            else if((mask and (1 shl j )) > 0){\\n                ans += solve(i+1, mask, 1, newIsLast, str, dp);\\n            }\\n            else if((mask and (1 shl j ))==0){\\n                ans += solve(i+1, mask or (1 shl j), isRepeat, newIsLast, str, dp)\\n            }\\n        }\\n        dp[i][mask][isRepeat][isLast] = ans\\n        return ans\\n    }\\n\\n    fun numDupDigitsAtMostN(n: Int): Int {\\n        val dp = Array(10) { Array(1 shl 10) { Array(2) { Array(2) { -1 } } } }\\n        val str = n.toString();\\n        return solve(0,0,0,1,str,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947392,
                "title": "explained-how-to-approach-digit-dp-and-bitmask-problem-well-commented-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**For Digit DP:** Whenever there is range given and we have to no of integers base on some conditions in the range, you can think of Digit DP as one of the possible solution.\\n\\n**For Bitmasking:** Here we have to take in account of the digit used and the no of unique digits is 10 only that is less than 31, so we can use bitmask(for int, as int has a upper limit of 2^31 - 1).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(12 * 2 * 2 * 10)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(10 * 2 * 2 * (2^10))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // withoutRepeated: [pos][tight][start][mask]\\n    // tight tells if we the so far constructed num has same digits as the given num\\n    // start tells if the num is of zero length or not\\n    // mask is like a bitmap of the digit used so far in the num\\n    int dp[12][2][2][1 << 10];\\n    //  possibleNumbers: [pos][tight][start]\\n    int dp2[12][2][2];\\n    int withoutRepeated(int pos, bool tight, bool st, int mask, string &s){\\n        if(pos == 0)\\n            return 1;\\n        if(dp[pos][tight][st][mask] != -1)\\n            return dp[pos][tight][st][mask];\\n        int limit = tight ? (s[s.size() - pos] - \\'0\\') : 9;\\n        int res = 0;\\n        if(st) // if the num is not yet started then we have the option to skip this digit also\\n            res += withoutRepeated(pos-1, 0, 1, mask, s);\\n        for(int j = 0; j <= 9; j++){\\n            if(st && j == 0) // is the num is of zero length then we will not take 0\\n                continue;\\n            else if(tight && j > limit) // if tight then we cannot take digit more than limit \\n                break; \\n            else if((mask & (1 << j)) == 0) // checking if the digit is being used or not\\n                res += withoutRepeated(pos-1, tight && (j == limit), 0, mask | (1 << j), s);\\n        }\\n        return dp[pos][tight][st][mask] = res;\\n    }\\n    int possibleNumbers(int pos, bool tight, bool st, string t, string &s){\\n        if(pos == 0) // if the t.size() == s.size()\\n            return 1;\\n\\n        if(dp2[pos][tight][st] != -1)\\n            return dp2[pos][tight][st];\\n        int limit = tight ? (s[s.size() - pos] - \\'0\\') : 9;\\n        int res = 0;\\n        for(int j = 0; j <= 9; j++)\\n            if(tight && j > limit) // if tight then we cannot take digit more than limit \\n                break;\\n            else\\n                res += possibleNumbers(pos-1, tight && (j == limit), 0, t + to_string(j), s);\\n        return dp2[pos][tight][st] = res;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        int m = s.size();\\n        memset(dp, -1, sizeof(dp));\\n        memset(dp2, -1, sizeof(dp2));\\n        int res = possibleNumbers(m, 1, 1, \"\", s) - withoutRepeated(m, 1, 1, 0, s);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // withoutRepeated: [pos][tight][start][mask]\\n    // tight tells if we the so far constructed num has same digits as the given num\\n    // start tells if the num is of zero length or not\\n    // mask is like a bitmap of the digit used so far in the num\\n    int dp[12][2][2][1 << 10];\\n    //  possibleNumbers: [pos][tight][start]\\n    int dp2[12][2][2];\\n    int withoutRepeated(int pos, bool tight, bool st, int mask, string &s){\\n        if(pos == 0)\\n            return 1;\\n        if(dp[pos][tight][st][mask] != -1)\\n            return dp[pos][tight][st][mask];\\n        int limit = tight ? (s[s.size() - pos] - \\'0\\') : 9;\\n        int res = 0;\\n        if(st) // if the num is not yet started then we have the option to skip this digit also\\n            res += withoutRepeated(pos-1, 0, 1, mask, s);\\n        for(int j = 0; j <= 9; j++){\\n            if(st && j == 0) // is the num is of zero length then we will not take 0\\n                continue;\\n            else if(tight && j > limit) // if tight then we cannot take digit more than limit \\n                break; \\n            else if((mask & (1 << j)) == 0) // checking if the digit is being used or not\\n                res += withoutRepeated(pos-1, tight && (j == limit), 0, mask | (1 << j), s);\\n        }\\n        return dp[pos][tight][st][mask] = res;\\n    }\\n    int possibleNumbers(int pos, bool tight, bool st, string t, string &s){\\n        if(pos == 0) // if the t.size() == s.size()\\n            return 1;\\n\\n        if(dp2[pos][tight][st] != -1)\\n            return dp2[pos][tight][st];\\n        int limit = tight ? (s[s.size() - pos] - \\'0\\') : 9;\\n        int res = 0;\\n        for(int j = 0; j <= 9; j++)\\n            if(tight && j > limit) // if tight then we cannot take digit more than limit \\n                break;\\n            else\\n                res += possibleNumbers(pos-1, tight && (j == limit), 0, t + to_string(j), s);\\n        return dp2[pos][tight][st] = res;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        int m = s.size();\\n        memset(dp, -1, sizeof(dp));\\n        memset(dp2, -1, sizeof(dp2));\\n        int res = possibleNumbers(m, 1, 1, \"\", s) - withoutRepeated(m, 1, 1, 0, s);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947389,
                "title": "explained-how-to-approach-digit-dp-and-bitmask-problem-well-commented-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**For Digit DP:** Whenever there is range given and we have to no of integers base on some conditions in the range, you can think of Digit DP as one of the possible solution.\\n\\n**For Bitmasking:** Here we have to take in account of the digit used and the no of unique digits is 10 only that is less than 31, so we can use bitmask(for int, as int has a upper limit of 2^31 - 1).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(12 * 2 * 2 * 10)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(10 * 2 * 2 * (2^10))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // withoutRepeated: [pos][tight][start][mask]\\n    // tight tells if we the so far constructed num has same digits as the given num\\n    // start tells if the num is of zero length or not\\n    // mask is like a bitmap of the digit used so far in the num\\n    int dp[12][2][2][1 << 10];\\n    //  possibleNumbers: [pos][tight][start]\\n    int dp2[12][2][2];\\n    int withoutRepeated(int pos, bool tight, bool st, int mask, string &s){\\n        if(pos == 0)\\n            return 1;\\n        if(dp[pos][tight][st][mask] != -1)\\n            return dp[pos][tight][st][mask];\\n        int limit = tight ? (s[s.size() - pos] - \\'0\\') : 9;\\n        int res = 0;\\n        if(st) // if the num is not yet started then we have the option to skip this digit also\\n            res += withoutRepeated(pos-1, 0, 1, mask, s);\\n        for(int j = 0; j <= 9; j++){\\n            if(st && j == 0) // is the num is of zero length then we will not take 0\\n                continue;\\n            else if(tight && j > limit) // if tight then we cannot take digit more than limit \\n                break; \\n            else if((mask & (1 << j)) == 0) // checking if the digit is being used or not\\n                res += withoutRepeated(pos-1, tight && (j == limit), 0, mask | (1 << j), s);\\n        }\\n        return dp[pos][tight][st][mask] = res;\\n    }\\n    int possibleNumbers(int pos, bool tight, bool st, string t, string &s){\\n        if(pos == 0) // if the t.size() == s.size()\\n            return 1;\\n\\n        if(dp2[pos][tight][st] != -1)\\n            return dp2[pos][tight][st];\\n        int limit = tight ? (s[s.size() - pos] - \\'0\\') : 9;\\n        int res = 0;\\n        for(int j = 0; j <= 9; j++)\\n            if(tight && j > limit) // if tight then we cannot take digit more than limit \\n                break;\\n            else\\n                res += possibleNumbers(pos-1, tight && (j == limit), 0, t + to_string(j), s);\\n        return dp2[pos][tight][st] = res;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        int m = s.size();\\n        memset(dp, -1, sizeof(dp));\\n        memset(dp2, -1, sizeof(dp2));\\n        int res = possibleNumbers(m, 1, 1, \"\", s) - withoutRepeated(m, 1, 1, 0, s);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // withoutRepeated: [pos][tight][start][mask]\\n    // tight tells if we the so far constructed num has same digits as the given num\\n    // start tells if the num is of zero length or not\\n    // mask is like a bitmap of the digit used so far in the num\\n    int dp[12][2][2][1 << 10];\\n    //  possibleNumbers: [pos][tight][start]\\n    int dp2[12][2][2];\\n    int withoutRepeated(int pos, bool tight, bool st, int mask, string &s){\\n        if(pos == 0)\\n            return 1;\\n        if(dp[pos][tight][st][mask] != -1)\\n            return dp[pos][tight][st][mask];\\n        int limit = tight ? (s[s.size() - pos] - \\'0\\') : 9;\\n        int res = 0;\\n        if(st) // if the num is not yet started then we have the option to skip this digit also\\n            res += withoutRepeated(pos-1, 0, 1, mask, s);\\n        for(int j = 0; j <= 9; j++){\\n            if(st && j == 0) // is the num is of zero length then we will not take 0\\n                continue;\\n            else if(tight && j > limit) // if tight then we cannot take digit more than limit \\n                break; \\n            else if((mask & (1 << j)) == 0) // checking if the digit is being used or not\\n                res += withoutRepeated(pos-1, tight && (j == limit), 0, mask | (1 << j), s);\\n        }\\n        return dp[pos][tight][st][mask] = res;\\n    }\\n    int possibleNumbers(int pos, bool tight, bool st, string t, string &s){\\n        if(pos == 0) // if the t.size() == s.size()\\n            return 1;\\n\\n        if(dp2[pos][tight][st] != -1)\\n            return dp2[pos][tight][st];\\n        int limit = tight ? (s[s.size() - pos] - \\'0\\') : 9;\\n        int res = 0;\\n        for(int j = 0; j <= 9; j++)\\n            if(tight && j > limit) // if tight then we cannot take digit more than limit \\n                break;\\n            else\\n                res += possibleNumbers(pos-1, tight && (j == limit), 0, t + to_string(j), s);\\n        return dp2[pos][tight][st] = res;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        int m = s.size();\\n        memset(dp, -1, sizeof(dp));\\n        memset(dp2, -1, sizeof(dp2));\\n        int res = possibleNumbers(m, 1, 1, \"\", s) - withoutRepeated(m, 1, 1, 0, s);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940328,
                "title": "c-python-digit-dp-solution-with-explanation",
                "content": "### find how many number without repeated digits\\nfill a number digit by digit.\\ni means we are filling i-th digit.\\nmask is number we used in the number, it is a bitmask, means which number we have used in [0,9].\\nis_limit means the current number is on the upper bound, e.g., n = 234, and digit is 23, we are filling last number -> 23[4].\\nhas_leading0s means digits are all 0s, e.g., 000, and we can fill a valid digit or skip it (fill a 0).\\n\\nfor i-th digit,\\nif has_leading0s is true, we can skip i-th digit, keep has_leading0s\\nor fill a digit in [1,9],\\nif has_leading0s  is true, digit can not be 0\\nif is_limit is true, digit is at most int(s[i]).\\n\\neumerate digit from low to high,\\nif this digit is not repeated, we can fill next digit.\\n\\n\\n### python\\n```python\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        s = str(n)\\n        @cache\\n        def dfs(i, mask, is_limit, has_leading0s):\\n            if i == len(s): return int(not has_leading0s)\\n            sub = 0\\n            if has_leading0s:\\n                sub = dfs(i+1, mask, False, True)\\n            low = 1 if has_leading0s else 0\\n            high = int(s[i]) if is_limit else 9\\n            for d in range(low, high+1):\\n                if mask >> d & 1 == 0:\\n                    sub += dfs(i+1, mask | (1 << d), is_limit and d == high, False)\\n            return sub\\n        \\n        return n - dfs(0, 0, True, True)\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        vector<vector<int>> dp (s.size(), vector<int>(1<<10, -1));\\n        function<int(int, int, bool, bool)> dfs = [&] (int i, int mask, bool is_limit, bool leading0s) {\\n            if (i == s.size()) return (int)!leading0s;\\n            if (!is_limit && !leading0s && dp[i][mask] != -1) return dp[i][mask];\\n            int sub = 0;\\n            if (leading0s) sub = dfs(i+1, mask, false, true);\\n            int low = leading0s? 1:0, high = is_limit? s[i]-\\'0\\': 9;\\n            for (int d = low; d <= high; d+=1) {\\n                if ((mask >> d & 1) == 0) {\\n                    sub += dfs(i+1, mask | (1<<d), is_limit && d == high, false);\\n                }\\n            }\\n            if (!is_limit && !leading0s) dp[i][mask] = sub;\\n            return sub;\\n        };\\n        return n - dfs(0, 0, true, true);\\n    }\\n};\\n```\\n\\n### find how many number at least one repeated digit\\n\\nfill a number digit by digit.\\n\\nhas_repeated means digits we filled has at least one repeated digit.\\n\\n\\n\\n### python\\n```python\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        s = str(n)\\n        @cache\\n        def dfs(i, mask, is_limit, leading0s, has_repeated):\\n            if i == len(s): return int(has_repeated)\\n            sub = 0\\n            if leading0s: sub = dfs(i+1, mask, False, True, False)\\n            low = 1 if leading0s else 0\\n            high = int(s[i]) if is_limit else 9\\n            for d in range(low, high+1):\\n                sub += dfs(i+1, mask | (1 << d), is_limit and d == high, False, has_repeated or mask >> d & 1 == 1)\\n            return sub\\n        return dfs(0, 0, True, True, False)\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        vector<vector<vector<int>>> dp (s.size(), vector<vector<int>>(1<<10, vector<int>(2, -1)));\\n        function<int(int, int, bool, bool, bool)> dfs = [&] (int i, int mask, bool is_limit, bool leading0s, bool has_repeated) {\\n            if (i == s.size()) return (int) has_repeated;\\n            if (!is_limit && !leading0s && dp[i][mask][(int) has_repeated] != -1) return dp[i][mask][(int) has_repeated];\\n            int sub = 0;\\n            if (leading0s) sub = dfs(i+1, mask, false, true, false);\\n            int low = leading0s? 1:0, high = is_limit? s[i] - \\'0\\': 9;\\n            for (int d = low; d <= high; d+=1)\\n                sub += dfs(i+1, mask | (1 << d), is_limit && d == high, false, has_repeated || mask >> d & 1);\\n            if (!is_limit && !leading0s) dp[i][mask][(int) has_repeated] = sub;\\n            return sub;\\n        };\\n        return dfs(0, 0, true, true, false);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        s = str(n)\\n        @cache\\n        def dfs(i, mask, is_limit, has_leading0s):\\n            if i == len(s): return int(not has_leading0s)\\n            sub = 0\\n            if has_leading0s:\\n                sub = dfs(i+1, mask, False, True)\\n            low = 1 if has_leading0s else 0\\n            high = int(s[i]) if is_limit else 9\\n            for d in range(low, high+1):\\n                if mask >> d & 1 == 0:\\n                    sub += dfs(i+1, mask | (1 << d), is_limit and d == high, False)\\n            return sub\\n        \\n        return n - dfs(0, 0, True, True)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        vector<vector<int>> dp (s.size(), vector<int>(1<<10, -1));\\n        function<int(int, int, bool, bool)> dfs = [&] (int i, int mask, bool is_limit, bool leading0s) {\\n            if (i == s.size()) return (int)!leading0s;\\n            if (!is_limit && !leading0s && dp[i][mask] != -1) return dp[i][mask];\\n            int sub = 0;\\n            if (leading0s) sub = dfs(i+1, mask, false, true);\\n            int low = leading0s? 1:0, high = is_limit? s[i]-\\'0\\': 9;\\n            for (int d = low; d <= high; d+=1) {\\n                if ((mask >> d & 1) == 0) {\\n                    sub += dfs(i+1, mask | (1<<d), is_limit && d == high, false);\\n                }\\n            }\\n            if (!is_limit && !leading0s) dp[i][mask] = sub;\\n            return sub;\\n        };\\n        return n - dfs(0, 0, true, true);\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        s = str(n)\\n        @cache\\n        def dfs(i, mask, is_limit, leading0s, has_repeated):\\n            if i == len(s): return int(has_repeated)\\n            sub = 0\\n            if leading0s: sub = dfs(i+1, mask, False, True, False)\\n            low = 1 if leading0s else 0\\n            high = int(s[i]) if is_limit else 9\\n            for d in range(low, high+1):\\n                sub += dfs(i+1, mask | (1 << d), is_limit and d == high, False, has_repeated or mask >> d & 1 == 1)\\n            return sub\\n        return dfs(0, 0, True, True, False)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        vector<vector<vector<int>>> dp (s.size(), vector<vector<int>>(1<<10, vector<int>(2, -1)));\\n        function<int(int, int, bool, bool, bool)> dfs = [&] (int i, int mask, bool is_limit, bool leading0s, bool has_repeated) {\\n            if (i == s.size()) return (int) has_repeated;\\n            if (!is_limit && !leading0s && dp[i][mask][(int) has_repeated] != -1) return dp[i][mask][(int) has_repeated];\\n            int sub = 0;\\n            if (leading0s) sub = dfs(i+1, mask, false, true, false);\\n            int low = leading0s? 1:0, high = is_limit? s[i] - \\'0\\': 9;\\n            for (int d = low; d <= high; d+=1)\\n                sub += dfs(i+1, mask | (1 << d), is_limit && d == high, false, has_repeated || mask >> d & 1);\\n            if (!is_limit && !leading0s) dp[i][mask][(int) has_repeated] = sub;\\n            return sub;\\n        };\\n        return dfs(0, 0, true, true, false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859569,
                "title": "easy-dp-bitmasking-solution-including-edge-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dp[10][2][(1<<11)][2];\\n    int solve(int idx, int edge, int bitmask, int repeated, string num){\\n        if(idx == num.size()){\\n            if(bitmask != 0 && repeated)return 1;\\n            return 0;\\n        }  \\n        if(dp[idx][edge][bitmask][repeated] != -1) return dp[idx][edge][bitmask][repeated];\\n        int max_digit = 9;\\n        if(edge) max_digit = num[idx] - \\'0\\';\\n        int ans = 0;\\n        for(int i = 0; i<=max_digit; i++){\\n            // missed case - when there are leading zeros we can still take zero\\n            if(i == 0){\\n                if(bitmask > 0){\\n                    if((bitmask & 1) == 1){\\n                        ans += solve(idx + 1, edge && (i == num[idx] - \\'0\\'), bitmask|(1<<i), 1, num);\\n                    }\\n                    else{\\n                        ans += solve(idx + 1, edge && (i == num[idx] - \\'0\\'), bitmask|(1<<i), repeated, num);\\n                    }\\n                }\\n                else{\\n                    ans += solve(idx+1, edge && (i == num[idx] - \\'0\\'), 0, repeated, num);\\n                }\\n            }\\n            else {\\n                if((bitmask & (1<<i)) == 0){\\n                    ans += solve(idx + 1, edge && (i == num[idx] - \\'0\\'), bitmask|(1<<i), repeated, num);\\n                }\\n                else{\\n                    ans += solve(idx + 1, edge && (i == num[idx] - \\'0\\'), bitmask|(1<<i), 1, num); \\n                }\\n            }\\n        }   \\n        return dp[idx][edge][bitmask][repeated] = ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        string num = to_string(n);\\n        return solve(0, 1, 0, 0, num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp[10][2][(1<<11)][2];\\n    int solve(int idx, int edge, int bitmask, int repeated, string num){\\n        if(idx == num.size()){\\n            if(bitmask != 0 && repeated)return 1;\\n            return 0;\\n        }  \\n        if(dp[idx][edge][bitmask][repeated] != -1) return dp[idx][edge][bitmask][repeated];\\n        int max_digit = 9;\\n        if(edge) max_digit = num[idx] - \\'0\\';\\n        int ans = 0;\\n        for(int i = 0; i<=max_digit; i++){\\n            // missed case - when there are leading zeros we can still take zero\\n            if(i == 0){\\n                if(bitmask > 0){\\n                    if((bitmask & 1) == 1){\\n                        ans += solve(idx + 1, edge && (i == num[idx] - \\'0\\'), bitmask|(1<<i), 1, num);\\n                    }\\n                    else{\\n                        ans += solve(idx + 1, edge && (i == num[idx] - \\'0\\'), bitmask|(1<<i), repeated, num);\\n                    }\\n                }\\n                else{\\n                    ans += solve(idx+1, edge && (i == num[idx] - \\'0\\'), 0, repeated, num);\\n                }\\n            }\\n            else {\\n                if((bitmask & (1<<i)) == 0){\\n                    ans += solve(idx + 1, edge && (i == num[idx] - \\'0\\'), bitmask|(1<<i), repeated, num);\\n                }\\n                else{\\n                    ans += solve(idx + 1, edge && (i == num[idx] - \\'0\\'), bitmask|(1<<i), 1, num); \\n                }\\n            }\\n        }   \\n        return dp[idx][edge][bitmask][repeated] = ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        string num = to_string(n);\\n        return solve(0, 1, 0, 0, num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856516,
                "title": "1012-numbers-with-repeated-digits",
                "content": "class Solution {\\n public:\\n  int numDupDigitsAtMostN(int n) {\\n    return n - countSpecialNumbers(n);\\n  }\\n\\n private:\\n  // Same as 2376. Count Special Integers\\n  int countSpecialNumbers(int n) {\\n    const int digitSize = log10(n) + 1;\\n    // dp[i][j][k] := # of special integers with current digit i and `usedMask`\\n    // j, where k is 0/1 tight constraint\\n    dp.resize(digitSize + 1, vector<vector<int>>(1 << 10, vector<int>(2, -1)));\\n    return count(to_string(n), 0, 0, true) - 1;  // - 0;\\n  }\\n\\n private:\\n  vector<vector<vector<int>>> dp;\\n\\n  int count(const string& s, int i, int usedMask, bool isTight) {\\n    if (i == s.length())\\n      return 1;\\n    if (dp[i][usedMask][isTight] != -1)\\n      return dp[i][usedMask][isTight];\\n\\n    int res = 0;\\n\\n    const int maxDigit = isTight ? s[i] - \\'0\\' : 9;\\n    for (int d = 0; d <= maxDigit; ++d) {\\n      // `d` is used.\\n      if (usedMask >> d & 1)\\n        continue;\\n      // Use `d` now.\\n      const bool nextIsTight = isTight && (d == maxDigit);\\n      if (usedMask == 0 && d == 0)  // Don\\'t count leading 0s as used.\\n        res += count(s, i + 1, usedMask, nextIsTight);\\n      else\\n        res += count(s, i + 1, usedMask | 1 << d, nextIsTight);\\n    }\\n\\n    return dp[i][usedMask][isTight] = res;\\n  }\\n};\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n public:\\n  int numDupDigitsAtMostN(int n) {\\n    return n - countSpecialNumbers(n);\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 3844878,
                "title": "using-bitmask-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint dp[11][1<<11][2];\\n\\nint fun(int i,int mask,int strict,string&s){\\n    if(i>=s.size()){\\n        if(mask>0) return 1;\\n        return 0;\\n    }\\n\\nif(dp[i][mask][strict]!=-1) return dp[i][mask][strict];\\n    long long ans=0;\\n    if(mask==0){\\n\\n\\n        if(strict==1){\\n            for(int j=0;j<=s[i]-\\'0\\';j++){\\n                if(j==0) ans=(ans+fun(i+1,mask,0,s));\\n                else if(j==s[i]-\\'0\\'){\\n                    int val=(1<<j);\\n                    ans=(ans+fun(i+1,mask|val,1,s));\\n                }\\n                else{\\n                     int val=(1<<j);\\n                    ans=(ans+fun(i+1,mask|val,0,s));\\n                }\\n               \\n                \\n            }\\n        }\\n\\n        else{\\n            for(int j=0;j<=9;j++){\\n                if(j==0) ans=(ans+fun(i+1,mask,0,s));\\n                else{\\n                    int val=(1<<j);\\n                    ans=(ans+fun(i+1,mask|val,0,s));\\n                }\\n               \\n                \\n            }\\n        }\\n\\n    }\\n\\n    else{\\n           if(strict==1){\\n               for(int j=0;j<=s[i]-\\'0\\';j++){\\n                   int val=mask;\\n                   if((val^(1<<j))>=mask){\\n                   if(j==s[i]-\\'0\\'){\\n            ans=(ans+fun(i+1,mask|(1<<j),1,s));         \\n                    }\\n\\n                    else{\\n                    ans=(ans+fun(i+1,mask|(1<<j),0,s));\\n                    }\\n\\n\\n                   }\\n               }\\n           }\\n\\n\\n\\n           else{\\n               for(int j=0;j<=9;j++){\\n                   int val=mask;\\n                   if((val^(1<<j))>=mask){\\n\\n                    ans=(ans+fun(i+1,mask|(1<<j),0,s));\\n                  \\n                   }\\n               }\\n           }\\n\\n    }\\n\\n             return dp[i][mask][strict]=ans;\\n\\n\\n\\n}\\n\\n\\n\\n    \\n    \\n\\n\\n\\n\\n\\n    int numDupDigitsAtMostN(int n) {\\n       memset(dp,-1,sizeof(dp));\\n        string s=\"\";\\n        int val=n;\\n        while(val){\\n            s+=(\\'0\\'+(val%10));\\n            val/=10;\\n        }\\n        reverse(s.begin(),s.end());\\n\\n        val=fun(0,0,1,s);\\n        return n-val;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint dp[11][1<<11][2];\\n\\nint fun(int i,int mask,int strict,string&s){\\n    if(i>=s.size()){\\n        if(mask>0) return 1;\\n        return 0;\\n    }\\n\\nif(dp[i][mask][strict]!=-1) return dp[i][mask][strict];\\n    long long ans=0;\\n    if(mask==0){\\n\\n\\n        if(strict==1){\\n            for(int j=0;j<=s[i]-\\'0\\';j++){\\n                if(j==0) ans=(ans+fun(i+1,mask,0,s));\\n                else if(j==s[i]-\\'0\\'){\\n                    int val=(1<<j);\\n                    ans=(ans+fun(i+1,mask|val,1,s));\\n                }\\n                else{\\n                     int val=(1<<j);\\n                    ans=(ans+fun(i+1,mask|val,0,s));\\n                }\\n               \\n                \\n            }\\n        }\\n\\n        else{\\n            for(int j=0;j<=9;j++){\\n                if(j==0) ans=(ans+fun(i+1,mask,0,s));\\n                else{\\n                    int val=(1<<j);\\n                    ans=(ans+fun(i+1,mask|val,0,s));\\n                }\\n               \\n                \\n            }\\n        }\\n\\n    }\\n\\n    else{\\n           if(strict==1){\\n               for(int j=0;j<=s[i]-\\'0\\';j++){\\n                   int val=mask;\\n                   if((val^(1<<j))>=mask){\\n                   if(j==s[i]-\\'0\\'){\\n            ans=(ans+fun(i+1,mask|(1<<j),1,s));         \\n                    }\\n\\n                    else{\\n                    ans=(ans+fun(i+1,mask|(1<<j),0,s));\\n                    }\\n\\n\\n                   }\\n               }\\n           }\\n\\n\\n\\n           else{\\n               for(int j=0;j<=9;j++){\\n                   int val=mask;\\n                   if((val^(1<<j))>=mask){\\n\\n                    ans=(ans+fun(i+1,mask|(1<<j),0,s));\\n                  \\n                   }\\n               }\\n           }\\n\\n    }\\n\\n             return dp[i][mask][strict]=ans;\\n\\n\\n\\n}\\n\\n\\n\\n    \\n    \\n\\n\\n\\n\\n\\n    int numDupDigitsAtMostN(int n) {\\n       memset(dp,-1,sizeof(dp));\\n        string s=\"\";\\n        int val=n;\\n        while(val){\\n            s+=(\\'0\\'+(val%10));\\n            val/=10;\\n        }\\n        reverse(s.begin(),s.end());\\n\\n        val=fun(0,0,1,s);\\n        return n-val;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788034,
                "title": "a-clean-solution-digit-dp-with-bitmask",
                "content": "This is a classic digit dp problem with a few more constraints. To achieve desired result we can apply following steps:\\n* Count the numbers which don\\'t have repeated digits, This is can be achieved  using a bitmask to check whether we have seen a digit previously or not.\\n* Subtract it from total(n).\\n**Note**\\n*There can be as many Leading zeroes as the number of digits in our number and hence they won\\'t be treated as repeated.*\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[10][1024][2][2];\\n    int solve(string &num, int pos, int mask, bool leading, bool e)\\n    {\\n        if(pos == num.length())\\n            return 1;\\n        \\n        if(dp[pos][mask][leading][e] != -1)\\n            return dp[pos][mask][leading][e];\\n        \\n        int res = 0;\\n        \\n        if(leading)\\n            res += solve(num, pos + 1, mask, true, false);\\n            \\n        \\n        int limit = e ? num[pos] - \\'0\\' : 9;\\n       \\n        for(int digit = leading ? 1 : 0 ; digit <= limit ; digit++)\\n        {\\n            if(mask & (1 << digit))\\n                continue;\\n            \\n            if(e && digit == limit)\\n                res += solve(num, pos + 1, mask | (1 << digit), false, true);\\n            else\\n                res += solve(num, pos + 1, mask | (1 << digit), false, false);\\n        }\\n        \\n        return dp[pos][mask][leading][e] = res;\\n        \\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp, -1, sizeof dp);\\n        \\n        string num = to_string(n);\\n        // plus 1 is done because of leading zeroes.\\n        return n - solve(num, 0, 0, true, true) + 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10][1024][2][2];\\n    int solve(string &num, int pos, int mask, bool leading, bool e)\\n    {\\n        if(pos == num.length())\\n            return 1;\\n        \\n        if(dp[pos][mask][leading][e] != -1)\\n            return dp[pos][mask][leading][e];\\n        \\n        int res = 0;\\n        \\n        if(leading)\\n            res += solve(num, pos + 1, mask, true, false);\\n            \\n        \\n        int limit = e ? num[pos] - \\'0\\' : 9;\\n       \\n        for(int digit = leading ? 1 : 0 ; digit <= limit ; digit++)\\n        {\\n            if(mask & (1 << digit))\\n                continue;\\n            \\n            if(e && digit == limit)\\n                res += solve(num, pos + 1, mask | (1 << digit), false, true);\\n            else\\n                res += solve(num, pos + 1, mask | (1 << digit), false, false);\\n        }\\n        \\n        return dp[pos][mask][leading][e] = res;\\n        \\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp, -1, sizeof dp);\\n        \\n        string num = to_string(n);\\n        // plus 1 is done because of leading zeroes.\\n        return n - solve(num, 0, 0, true, true) + 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656650,
                "title": "digitdp-clean-best-c-code",
                "content": "# Code\\n## Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int dp[11][1 << 10][2][2];\\n    int helper(int ind,int mask,string s,bool is_smaller,bool is_repeated){\\n        if(ind == s.size())\\n            return is_repeated ? 1 : 0;\\n        if(dp[ind][mask][is_smaller][is_repeated] != -1)\\n            return dp[ind][mask][is_smaller][is_repeated];\\n        int ans = 0,end = is_smaller ? 9 : s[ind] - \\'0\\';\\n        for(int i=0;i<=end;i++){\\n           int bitMask = mask;\\n           bool repeat = is_repeated;\\n            if(!is_repeated){\\n                repeat = (mask & (1 << i)) ? true : false;\\n                if(!repeat)\\n                    bitMask = mask | (1 << i);\\n                if(i == 0 && mask == 0)\\n                    bitMask = 0;\\n            }\\n            bool chk = is_smaller ? true : (i != end);\\n            ans += helper(ind+1,bitMask,s,chk,repeat);\\n        }\\n        return dp[ind][mask][is_smaller][is_repeated] = ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,0,s,false,false);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[11][1 << 10][2][2];\\n    int helper(int ind,int mask,string s,bool is_smaller,bool is_repeated){\\n        if(ind == s.size())\\n            return is_repeated ? 1 : 0;\\n        if(dp[ind][mask][is_smaller][is_repeated] != -1)\\n            return dp[ind][mask][is_smaller][is_repeated];\\n        int ans = 0,end = is_smaller ? 9 : s[ind] - \\'0\\';\\n        for(int i=0;i<=end;i++){\\n           int bitMask = mask;\\n           bool repeat = is_repeated;\\n            if(!is_repeated){\\n                repeat = (mask & (1 << i)) ? true : false;\\n                if(!repeat)\\n                    bitMask = mask | (1 << i);\\n                if(i == 0 && mask == 0)\\n                    bitMask = 0;\\n            }\\n            bool chk = is_smaller ? true : (i != end);\\n            ans += helper(ind+1,bitMask,s,chk,repeat);\\n        }\\n        return dp[ind][mask][is_smaller][is_repeated] = ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,0,s,false,false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617057,
                "title": "c-bitmask-digit-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nResult = n - (numbers with no repeated digit)\\nhere n is given in question\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1024*10*10*2)$$ = $$O(2*10^5)$$ \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1024*10*10*2)$$ = $$O(2*10^5)$$ \\n# Code\\n```\\nclass Solution {\\npublic:\\n    // digit + bitmask dp\\n    int dp[1024][2][10];\\n    int solve(string & n,int i,bool small,int mask)\\n    {\\n        if(i == n.length()) return 1;\\n        if(dp[mask][small][i]!=-1)return dp[mask][small][i];\\n        vector<int>dig = {0,1,2,3,4,5,6,7,8,9};\\n        \\n        int end = small==0 ? 9 : (n[i] - \\'0\\');\\n        int res = 0;\\n        // mask == 0, we have to calculate numbers with length 1 to len(n) - 1\\n        if(!mask)\\n        {\\n            res+=solve(n,i+1,0,mask);\\n        }\\n        for(int & d : dig)\\n        {\\n            if(d==0 && !mask) continue;\\n            bool smaller = (small) && (d == end);\\n            int shift = (1<<d);\\n            if(d <= end && !(mask&shift))\\n            {\\n                res+=solve(n,i+1,smaller,mask|shift);\\n            }\\n        }\\n        return dp[mask][small][i] = res;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string num = to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return n + 1 - solve(num,0,1,0);\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    // digit + bitmask dp\\n    int dp[1024][2][10];\\n    int solve(string & n,int i,bool small,int mask)\\n    {\\n        if(i == n.length()) return 1;\\n        if(dp[mask][small][i]!=-1)return dp[mask][small][i];\\n        vector<int>dig = {0,1,2,3,4,5,6,7,8,9}",
                "codeTag": "Java"
            },
            {
                "id": 3614562,
                "title": "hashmap-solution-recursion-backtracking-bitmask-digit-dp-accepetd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n1. HashMap solution --- O(n) //gives TLE.\\n2. Bitmask Dp ----- log(base 10) n.\\n\\n- Space complexity:\\n1. Hash Map  ----- nearly O(1), exact theeta(10).\\n2. Bitmask ------ O(1)\\n\\n# Code\\n```\\n// Hash map solution it gives TLE.. ofcourse it will because it is O(n) approach.\\n// it might be usefull for someone , thinking how to implement the recursion in this problem..\\n// Recursion + backTracking..\\n    int solve(string& num, int n, unordered_map<int, int>&mp, bool leadingZero, bool tight){\\n        if(n == 0){\\n            if(leadingZero) return 0;\\n            else{\\n                for(auto it : mp){\\n                    if(it.second >= 2){ \\n                     return 1;\\n                    }\\n                }\\n            }\\n            return 0;\\n        }\\n\\n        int ub = tight ? (num[num.size() - n] - \\'0\\') : 9;\\n        int ans = 0;\\n        for(int dig = 0; dig <= ub; dig++){\\n            if(dig == 0 && leadingZero == 0)mp[0]++;\\n            else if(dig != 0) mp[dig]++;\\n\\n            ans = ans + solve(num, n-1, mp, leadingZero && (dig == 0), tight && (dig == ub));\\n\\n            if(dig == 0 && leadingZero == 0) mp[0]--;\\n            else if(dig != 0) mp[dig]--;\\n        }\\n\\n        return ans;\\n    }\\n\\n-----------------------------------------------------------------------------------------------------------------------------------\\n// Accepetd solution... Bitmask Dp\\nclass Solution {\\n    int dp[11][1025][2][2];\\n    int solve(string& num, int n, int mask, bool tight, bool rep){\\n        if(n == 0){\\n            if(rep && mask){\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n        if(dp[n][mask][tight][rep] != -1) return dp[n][mask][tight][rep];\\n\\n        int ub = tight ? (num[num.size() - n] - \\'0\\') : 9;\\n        int ans = 0;\\n        if(mask == 0){\\n            ans = ans + solve(num, n-1, mask, 0, rep);\\n        }\\n\\n        for(int dig = 0; dig <= ub; dig++){\\n            if(mask == 0 && dig == 0) continue;\\n            int repeated = mask & (1 << dig); // checking for any repeated digit\\n            if(repeated){\\n                ans = ans + solve(num, n-1, mask, tight && (dig == ub), 1);// if any digit is repeated no need to change the mask ,\\n                                                                           //you can, but mask will be unaffected.\\n            }else{\\n                ans = ans + solve(num, n-1, mask|(1<<dig), tight&&(dig == ub), rep);// if any of digit is not repeated\\n                                                                                        // then you have to set the incoming digits\\'s bit in mask,\\n                                                                                        // so that you can track the digit in future..\\n            } \\n        }\\n\\n        return dp[n][mask][tight][rep] = ans;\\n\\n    }\\n\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        string r = to_string(n);\\n        int sz = r.size();\\n        memset(dp, -1, sizeof dp);\\n\\n        int ans = solve(r, sz, 0, 1, 0);\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n// Hash map solution it gives TLE.. ofcourse it will because it is O(n) approach.\\n// it might be usefull for someone , thinking how to implement the recursion in this problem..\\n// Recursion + backTracking..\\n    int solve(string& num, int n, unordered_map<int, int>&mp, bool leadingZero, bool tight){\\n        if(n == 0){\\n            if(leadingZero) return 0;\\n            else{\\n                for(auto it : mp){\\n                    if(it.second >= 2){ \\n                     return 1;\\n                    }\\n                }\\n            }\\n            return 0;\\n        }\\n\\n        int ub = tight ? (num[num.size() - n] - \\'0\\') : 9;\\n        int ans = 0;\\n        for(int dig = 0; dig <= ub; dig++){\\n            if(dig == 0 && leadingZero == 0)mp[0]++;\\n            else if(dig != 0) mp[dig]++;\\n\\n            ans = ans + solve(num, n-1, mp, leadingZero && (dig == 0), tight && (dig == ub));\\n\\n            if(dig == 0 && leadingZero == 0) mp[0]--;\\n            else if(dig != 0) mp[dig]--;\\n        }\\n\\n        return ans;\\n    }\\n\\n-----------------------------------------------------------------------------------------------------------------------------------\\n// Accepetd solution... Bitmask Dp\\nclass Solution {\\n    int dp[11][1025][2][2];\\n    int solve(string& num, int n, int mask, bool tight, bool rep){\\n        if(n == 0){\\n            if(rep && mask){\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n        if(dp[n][mask][tight][rep] != -1) return dp[n][mask][tight][rep];\\n\\n        int ub = tight ? (num[num.size() - n] - \\'0\\') : 9;\\n        int ans = 0;\\n        if(mask == 0){\\n            ans = ans + solve(num, n-1, mask, 0, rep);\\n        }\\n\\n        for(int dig = 0; dig <= ub; dig++){\\n            if(mask == 0 && dig == 0) continue;\\n            int repeated = mask & (1 << dig); // checking for any repeated digit\\n            if(repeated){\\n                ans = ans + solve(num, n-1, mask, tight && (dig == ub), 1);// if any digit is repeated no need to change the mask ,\\n                                                                           //you can, but mask will be unaffected.\\n            }else{\\n                ans = ans + solve(num, n-1, mask|(1<<dig), tight&&(dig == ub), rep);// if any of digit is not repeated\\n                                                                                        // then you have to set the incoming digits\\'s bit in mask,\\n                                                                                        // so that you can track the digit in future..\\n            } \\n        }\\n\\n        return dp[n][mask][tight][rep] = ans;\\n\\n    }\\n\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        string r = to_string(n);\\n        int sz = r.size();\\n        memset(dp, -1, sizeof dp);\\n\\n        int ans = solve(r, sz, 0, 1, 0);\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605711,
                "title": "easy-dp-python-digit-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        s=str(n)\\n        @cache\\n        def rec(ind,done,h,exists,z):\\n            nonlocal s\\n            if ind==len(s):\\n                if done:\\n                    return 1\\n                return 0\\n            top=int(s[ind]) if h else 9\\n            ans=0\\n            for i in range(top+1):\\n                hh=h and (i==int(s[ind]))\\n                existsnew=exists\\n                donenew=done\\n                if not( i==0 and z) and (exists & 1<<i)!=0:\\n                    donenew=True\\n                elif not (i==0 and z):\\n                    existsnew =exists | 1<<i\\n                zz=z and i==0\\n                ans+=rec(ind+1,donenew,hh,existsnew,zz)\\n            return ans\\n        return rec(0,False,True,0,True)\\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        s=str(n)\\n        @cache\\n        def rec(ind,done,h,exists,z):\\n            nonlocal s\\n            if ind==len(s):\\n                if done:\\n                    return 1\\n                return 0\\n            top=int(s[ind]) if h else 9\\n            ans=0\\n            for i in range(top+1):\\n                hh=h and (i==int(s[ind]))\\n                existsnew=exists\\n                donenew=done\\n                if not( i==0 and z) and (exists & 1<<i)!=0:\\n                    donenew=True\\n                elif not (i==0 and z):\\n                    existsnew =exists | 1<<i\\n                zz=z and i==0\\n                ans+=rec(ind+1,donenew,hh,existsnew,zz)\\n            return ans\\n        return rec(0,False,True,0,True)\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603530,
                "title": "exactly-similar-to-leetcode-2376-count-special-integers",
                "content": "# Approach\\nDo refer my solution for the explaination.\\n\\n*https://leetcode.com/problems/count-special-integers/solutions/3603502/digit-dp-solution-bitmasking-e/*\\n> This question is exactly similar to above given problem. You just have to subtract the answer from n.\\n\\n# Code\\n```Java []\\nclass Solution {\\n    String s; // String representation of the input number\\n    Integer[][][] dp; // Dynamic programming array for memoization\\n\\n    public int numDupDigitsAtMostN(int n) {\\n        s = Integer.toString(n); // Convert the input number to a string\\n        dp = new Integer[s.length()][2][1024]; // Initialize the dp array\\n        int uniqueNos = f(0, true, 0); // Call the recursive function to count special numbers\\n        return n - uniqueNos;\\n    }\\n\\n    public int f(int i, boolean bound, int mask) {\\n        // Base case: If we have processed all digits in the number\\n        if (i == s.length()) {\\n            // If the mask is not zero, it means the number is special\\n            // Return 1 if it\\'s special, otherwise return 0\\n            return mask != 0 ? 1 : 0;\\n        }\\n\\n        // If the result for the current state (i, bound, mask) is already computed, return it\\n        if (dp[i][bound ? 1 : 0][mask] != null) {\\n            return dp[i][bound ? 1 : 0][mask];\\n        }\\n\\n        int maxDig = 9;\\n\\n        // If bound is true, the current digit can\\'t exceed the corresponding digit in the input number\\n        if (bound) {\\n            maxDig = s.charAt(i) - \\'0\\';\\n        }\\n\\n        int ans = 0;\\n\\n        // Iterate from 0 to the maximum possible digit\\n        for (int j = 0; j <= maxDig; j++) {\\n            // If the digit is already used in the mask, skip it\\n            if ((mask & (1 << j)) != 0) continue;\\n\\n            // Calculate the new mask by setting the jth bit to 1\\n            int newMask = (mask == 0 && j == 0) ? mask : (mask | (1 << j));\\n\\n            // Recursive call to process the next digit\\n            // bound && j == s.charAt(i) - \\'0\\' is used to update the bound flag for the next digit\\n            ans += f(i + 1, bound && j == s.charAt(i) - \\'0\\', newMask);\\n        }\\n\\n        // Store the result in the dp array for future use\\n        return dp[i][bound ? 1 : 0][mask] = ans;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    string s; // String representation of the input number\\n    vector<vector<vector<int>>> dp; // Dynamic programming array for memoization\\n\\n    int countSpecialNumbers(int n) {\\n        s = to_string(n); // Convert the input number to a string\\n        dp.resize(s.length(), vector<vector<int>>(2, vector<int>(1024, -1))); // Initialize the dp array\\n        int uniqueNos = f(0, true, 0); // Call the recursive function to count special numbers\\n        return n - uniqueNos;\\n    }\\n\\n    int f(int i, bool bound, int mask) {\\n        // Base case: If we have processed all digits in the number\\n        if (i == s.length()) {\\n            // If the mask is not zero, it means the number is special\\n            // Return 1 if it\\'s special, otherwise return 0\\n            return mask != 0 ? 1 : 0;\\n        }\\n\\n        // If the result for the current state (i, bound, mask) is already computed, return it\\n        if (dp[i][bound ? 1 : 0][mask] != -1) {\\n            return dp[i][bound ? 1 : 0][mask];\\n        }\\n\\n        int maxDig = 9;\\n\\n        // If bound is true, the current digit can\\'t exceed the corresponding digit in the input number\\n        if (bound) {\\n            maxDig = s[i] - \\'0\\';\\n        }\\n\\n        int ans = 0;\\n\\n        // Iterate from 0 to the maximum possible digit\\n        for (int j = 0; j <= maxDig; j++) {\\n            // If the digit is already used in the mask, skip it\\n            if ((mask & (1 << j)) != 0) continue;\\n\\n            // Calculate the new mask by setting the jth bit to 1\\n            int newMask = (mask == 0 && j == 0) ? mask : (mask | (1 << j));\\n\\n            // Recursive call to process the next digit\\n            // bound && j == s[i] - \\'0\\' is used to update the bound flag for the next digit\\n            ans += f(i + 1, bound && j == (s[i] - \\'0\\'), newMask);\\n        }\\n\\n        // Store the result in the dp array for future use\\n        return dp[i][bound ? 1 : 0][mask] = ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```Java []\\nclass Solution {\\n    String s; // String representation of the input number\\n    Integer[][][] dp; // Dynamic programming array for memoization\\n\\n    public int numDupDigitsAtMostN(int n) {\\n        s = Integer.toString(n); // Convert the input number to a string\\n        dp = new Integer[s.length()][2][1024]; // Initialize the dp array\\n        int uniqueNos = f(0, true, 0); // Call the recursive function to count special numbers\\n        return n - uniqueNos;\\n    }\\n\\n    public int f(int i, boolean bound, int mask) {\\n        // Base case: If we have processed all digits in the number\\n        if (i == s.length()) {\\n            // If the mask is not zero, it means the number is special\\n            // Return 1 if it\\'s special, otherwise return 0\\n            return mask != 0 ? 1 : 0;\\n        }\\n\\n        // If the result for the current state (i, bound, mask) is already computed, return it\\n        if (dp[i][bound ? 1 : 0][mask] != null) {\\n            return dp[i][bound ? 1 : 0][mask];\\n        }\\n\\n        int maxDig = 9;\\n\\n        // If bound is true, the current digit can\\'t exceed the corresponding digit in the input number\\n        if (bound) {\\n            maxDig = s.charAt(i) - \\'0\\';\\n        }\\n\\n        int ans = 0;\\n\\n        // Iterate from 0 to the maximum possible digit\\n        for (int j = 0; j <= maxDig; j++) {\\n            // If the digit is already used in the mask, skip it\\n            if ((mask & (1 << j)) != 0) continue;\\n\\n            // Calculate the new mask by setting the jth bit to 1\\n            int newMask = (mask == 0 && j == 0) ? mask : (mask | (1 << j));\\n\\n            // Recursive call to process the next digit\\n            // bound && j == s.charAt(i) - \\'0\\' is used to update the bound flag for the next digit\\n            ans += f(i + 1, bound && j == s.charAt(i) - \\'0\\', newMask);\\n        }\\n\\n        // Store the result in the dp array for future use\\n        return dp[i][bound ? 1 : 0][mask] = ans;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string s; // String representation of the input number\\n    vector<vector<vector<int>>> dp; // Dynamic programming array for memoization\\n\\n    int countSpecialNumbers(int n) {\\n        s = to_string(n); // Convert the input number to a string\\n        dp.resize(s.length(), vector<vector<int>>(2, vector<int>(1024, -1))); // Initialize the dp array\\n        int uniqueNos = f(0, true, 0); // Call the recursive function to count special numbers\\n        return n - uniqueNos;\\n    }\\n\\n    int f(int i, bool bound, int mask) {\\n        // Base case: If we have processed all digits in the number\\n        if (i == s.length()) {\\n            // If the mask is not zero, it means the number is special\\n            // Return 1 if it\\'s special, otherwise return 0\\n            return mask != 0 ? 1 : 0;\\n        }\\n\\n        // If the result for the current state (i, bound, mask) is already computed, return it\\n        if (dp[i][bound ? 1 : 0][mask] != -1) {\\n            return dp[i][bound ? 1 : 0][mask];\\n        }\\n\\n        int maxDig = 9;\\n\\n        // If bound is true, the current digit can\\'t exceed the corresponding digit in the input number\\n        if (bound) {\\n            maxDig = s[i] - \\'0\\';\\n        }\\n\\n        int ans = 0;\\n\\n        // Iterate from 0 to the maximum possible digit\\n        for (int j = 0; j <= maxDig; j++) {\\n            // If the digit is already used in the mask, skip it\\n            if ((mask & (1 << j)) != 0) continue;\\n\\n            // Calculate the new mask by setting the jth bit to 1\\n            int newMask = (mask == 0 && j == 0) ? mask : (mask | (1 << j));\\n\\n            // Recursive call to process the next digit\\n            // bound && j == s[i] - \\'0\\' is used to update the bound flag for the next digit\\n            ans += f(i + 1, bound && j == (s[i] - \\'0\\'), newMask);\\n        }\\n\\n        // Store the result in the dp array for future use\\n        return dp[i][bound ? 1 : 0][mask] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601938,
                "title": "combinactorics",
                "content": "# Intuition\\nThink of the the situation just opposite to the one asked in the problem statement : count the number of numbers in [1,n] that have all distinct digits in the decimal representation.\\n\\n# Approach\\nsuppose i use an array cnt, where cnt[i] = number of numbers in [1,n] that have i digits and all distinct, then ans to the reverse problem would be cnt[1] + cnt[2] + ... + cnt[d-1] + number of numbers with d digits all distinct that are less than or equal to n. So we solve it in two parts part 1 : calculate cnt[i] \\u2200 i and then the second part in the above statement. All the further details are there in the code in the comments along with the implementation.\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        int Cr[11][11];\\n        for(int n=0; n<11; n++)\\n            for(int r=0; r<11; r++)\\n                Cr[n][r] = 0;\\n\\n        Cr[0][0]=1;\\n\\n        for(int n=1; n<11; n++){\\n            Cr[n][0] = 1; Cr[n][n] = 1;\\n            for(int r=1; r<n; r++) \\n                Cr[n][r] = Cr[n-1][r] + Cr[n-1][r-1];\\n        }\\n\\n        int Fact[11];\\n        Fact[0] = 1;\\n        for(int i=1; i<11; i++) \\n            Fact[i] = Fact[i-1] * i;\\n\\n        string s = to_string(n);\\n        int number_of_digits = s.size();\\n\\n        vector<int> cnt(11, 0);\\n        // cnt[i] = number of numbers in [1,n] that have i digits and all distinct\\n        for(int i=1; i<=10; i++)\\n            cnt[i] = Cr[9][i] * Fact[i] + (i-1) * Cr[9][i-1] * Fact[i-1];\\n            // how did i write this equation : \\n            // we place place any digit from [1,9] freely :\\n            // option 1 : we dont place a zero : choose any i digits in [1,9] and then permute them in any order\\n            // option 2 : we put a 0 : (i - 1) places to put the zero , then for the remaining i - 1 digits\\n            // choose any (i - 1) digits from [1,9] then permute them in any order\\n        \\n        int ans = 0;\\n        for(int d=1; d<number_of_digits; d++) \\n            ans += cnt[d];\\n\\n        // cout << ans << endl;\\n        \\n        // now we have to count the number of numbers with \\'number_of_digit\\' digits all distinct that are less than or equal to n\\n\\n        // lets iterate over the first point of difference of the number we make and n\\n\\n        vector<int> freq(10, 0); // it keeps the frequency of all the digits that we have seen untill now\\n        bool flag = true; \\n        for(int pos=0; pos<number_of_digits; pos++){\\n            if(!flag) break;\\n            // [0,pos-1] are the same digits are in n\\n            // at pos we will put a smaller digit than in n \\n            int d = s[pos] - \\'0\\';\\n            // we check for all digits in [start,d] if we can put it at postion pos\\n            // if pos is not zero then start can be zero, because we can place a zero in middle\\n            // if pos is zero then we start checking from 1\\n            int curr = 0;\\n            int start = 0;\\n            if(!pos) start ++;\\n            for(int i=start; i<d; i++) \\n                if(!freq[i]) curr++; // we can only put digits that are have not yet been used\\n            curr *= Cr[10 - pos -1][number_of_digits - pos -1] * Fact[number_of_digits - pos -1];\\n            ans += curr;\\n            freq[d] ++;\\n            if(freq[d] > 1) flag = false;\\n            // cout << curr << endl;\\n        }\\n        if(flag) ans ++;\\n        return n - ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        int Cr[11][11];\\n        for(int n=0; n<11; n++)\\n            for(int r=0; r<11; r++)\\n                Cr[n][r] = 0;\\n\\n        Cr[0][0]=1;\\n\\n        for(int n=1; n<11; n++){\\n            Cr[n][0] = 1; Cr[n][n] = 1;\\n            for(int r=1; r<n; r++) \\n                Cr[n][r] = Cr[n-1][r] + Cr[n-1][r-1];\\n        }\\n\\n        int Fact[11];\\n        Fact[0] = 1;\\n        for(int i=1; i<11; i++) \\n            Fact[i] = Fact[i-1] * i;\\n\\n        string s = to_string(n);\\n        int number_of_digits = s.size();\\n\\n        vector<int> cnt(11, 0);\\n        // cnt[i] = number of numbers in [1,n] that have i digits and all distinct\\n        for(int i=1; i<=10; i++)\\n            cnt[i] = Cr[9][i] * Fact[i] + (i-1) * Cr[9][i-1] * Fact[i-1];\\n            // how did i write this equation : \\n            // we place place any digit from [1,9] freely :\\n            // option 1 : we dont place a zero : choose any i digits in [1,9] and then permute them in any order\\n            // option 2 : we put a 0 : (i - 1) places to put the zero , then for the remaining i - 1 digits\\n            // choose any (i - 1) digits from [1,9] then permute them in any order\\n        \\n        int ans = 0;\\n        for(int d=1; d<number_of_digits; d++) \\n            ans += cnt[d];\\n\\n        // cout << ans << endl;\\n        \\n        // now we have to count the number of numbers with \\'number_of_digit\\' digits all distinct that are less than or equal to n\\n\\n        // lets iterate over the first point of difference of the number we make and n\\n\\n        vector<int> freq(10, 0); // it keeps the frequency of all the digits that we have seen untill now\\n        bool flag = true; \\n        for(int pos=0; pos<number_of_digits; pos++){\\n            if(!flag) break;\\n            // [0,pos-1] are the same digits are in n\\n            // at pos we will put a smaller digit than in n \\n            int d = s[pos] - \\'0\\';\\n            // we check for all digits in [start,d] if we can put it at postion pos\\n            // if pos is not zero then start can be zero, because we can place a zero in middle\\n            // if pos is zero then we start checking from 1\\n            int curr = 0;\\n            int start = 0;\\n            if(!pos) start ++;\\n            for(int i=start; i<d; i++) \\n                if(!freq[i]) curr++; // we can only put digits that are have not yet been used\\n            curr *= Cr[10 - pos -1][number_of_digits - pos -1] * Fact[number_of_digits - pos -1];\\n            ans += curr;\\n            freq[d] ++;\\n            if(freq[d] > 1) flag = false;\\n            // cout << curr << endl;\\n        }\\n        if(flag) ans ++;\\n        return n - ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3599155,
                "title": "beginner-friendly-easy-solution-using-digit-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dp[12][2][1100][2];\\n\\n    void num_to_digi(int n , vector<int> &digit){\\n        while(n>0){\\n            digit.push_back(n%10);\\n            n = n/10;\\n        }\\n        reverse(digit.begin() , digit.end());\\n    }\\n\\n\\n    int f(int idx , bool smaller , int mask , bool repeated , vector<int> &digit){\\n\\n        if(idx==digit.size()){\\n            if(repeated)return 1;\\n            else return 0;\\n        }\\n\\n        if(dp[idx][smaller][mask][repeated]!=-1)return dp[idx][smaller][mask][repeated];\\n        \\n        int cnt = 0;\\n\\n        if(smaller){\\n            for(int i=0 ; i<=digit[idx] ; i++){\\n                //the number has not started yet\\n                if(i==0 && mask==0){\\n                    cnt += f(idx + 1 , false , 0 , false , digit);\\n                }else if(i==digit[idx]){\\n                    // whether ith digit is present in the number or not\\n                    bool present = (mask&(1 << i));\\n                    if(present){\\n                        cnt += f(idx + 1 , true , (mask|(1 << i)) , true , digit);\\n                    }else{\\n                        cnt += f(idx + 1 , true , (mask|(1 << i)) , repeated , digit);\\n                    }\\n                }\\n                else{\\n                    bool present = (mask&(1 << i));\\n                    if(present){\\n                        cnt += f(idx + 1 , false , (mask|(1 << i)) , true , digit);\\n                    }else{\\n                        cnt += f(idx + 1 , false , (mask|(1 << i)) , repeated , digit);\\n                    }\\n                }\\n            }\\n        }else{\\n            for(int i=0 ; i<=9 ; i++){\\n                if(i==0 && mask==0){\\n                    cnt += f(idx + 1 , false , 0 , false , digit);\\n                }else{\\n                    bool present = (mask&(1 << i));\\n                    if(present){\\n                        cnt += f(idx + 1 , false , (mask|(1 << i)) , true , digit);\\n                    }else{\\n                        cnt += f(idx + 1 , false , (mask|(1 << i)) , repeated , digit);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[idx][smaller][mask][repeated] = cnt;\\n\\n    }\\n\\n\\n    int numDupDigitsAtMostN(int n) {\\n\\n        vector<int>digit;\\n        num_to_digi(n , digit);\\n        int ans = 0;\\n\\n        for(int i=0 ; i<12 ; i++){\\n            for(int j=0 ; j<2 ; j++){\\n                for(int k=0 ; k<1100 ; k++){\\n                    for(int m=0 ; m<2 ; m++){\\n                        dp[i][j][k][m] = -1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0 ; i<=digit[0] ; i++){\\n           if(i==0){\\n               ans += f(1 , false , 0 , false , digit);\\n           }else{\\n            if(i==digit[0]){\\n                ans += f(1 , true , (0|(1 << i)) , false , digit);\\n            }else{\\n                ans += f(1 , false , (0|(1 << i)) , false , digit);\\n            }\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[12][2][1100][2];\\n\\n    void num_to_digi(int n , vector<int> &digit){\\n        while(n>0){\\n            digit.push_back(n%10);\\n            n = n/10;\\n        }\\n        reverse(digit.begin() , digit.end());\\n    }\\n\\n\\n    int f(int idx , bool smaller , int mask , bool repeated , vector<int> &digit){\\n\\n        if(idx==digit.size()){\\n            if(repeated)return 1;\\n            else return 0;\\n        }\\n\\n        if(dp[idx][smaller][mask][repeated]!=-1)return dp[idx][smaller][mask][repeated];\\n        \\n        int cnt = 0;\\n\\n        if(smaller){\\n            for(int i=0 ; i<=digit[idx] ; i++){\\n                //the number has not started yet\\n                if(i==0 && mask==0){\\n                    cnt += f(idx + 1 , false , 0 , false , digit);\\n                }else if(i==digit[idx]){\\n                    // whether ith digit is present in the number or not\\n                    bool present = (mask&(1 << i));\\n                    if(present){\\n                        cnt += f(idx + 1 , true , (mask|(1 << i)) , true , digit);\\n                    }else{\\n                        cnt += f(idx + 1 , true , (mask|(1 << i)) , repeated , digit);\\n                    }\\n                }\\n                else{\\n                    bool present = (mask&(1 << i));\\n                    if(present){\\n                        cnt += f(idx + 1 , false , (mask|(1 << i)) , true , digit);\\n                    }else{\\n                        cnt += f(idx + 1 , false , (mask|(1 << i)) , repeated , digit);\\n                    }\\n                }\\n            }\\n        }else{\\n            for(int i=0 ; i<=9 ; i++){\\n                if(i==0 && mask==0){\\n                    cnt += f(idx + 1 , false , 0 , false , digit);\\n                }else{\\n                    bool present = (mask&(1 << i));\\n                    if(present){\\n                        cnt += f(idx + 1 , false , (mask|(1 << i)) , true , digit);\\n                    }else{\\n                        cnt += f(idx + 1 , false , (mask|(1 << i)) , repeated , digit);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[idx][smaller][mask][repeated] = cnt;\\n\\n    }\\n\\n\\n    int numDupDigitsAtMostN(int n) {\\n\\n        vector<int>digit;\\n        num_to_digi(n , digit);\\n        int ans = 0;\\n\\n        for(int i=0 ; i<12 ; i++){\\n            for(int j=0 ; j<2 ; j++){\\n                for(int k=0 ; k<1100 ; k++){\\n                    for(int m=0 ; m<2 ; m++){\\n                        dp[i][j][k][m] = -1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0 ; i<=digit[0] ; i++){\\n           if(i==0){\\n               ans += f(1 , false , 0 , false , digit);\\n           }else{\\n            if(i==digit[0]){\\n                ans += f(1 , true , (0|(1 << i)) , false , digit);\\n            }else{\\n                ans += f(1 , false , (0|(1 << i)) , false , digit);\\n            }\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596525,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n_digits)\\n * Space Complexity: O(n_digits)\\n * where `n_digits` is the number of the digits of the integer `n`\\n */\\nclass Solution {\\n private:\\n  static constexpr int digits = 10;\\n  static constexpr char zero = \\'0\\';\\n  static constexpr int n_masks = 1 << digits;\\n  static constexpr int unmemorized = -1;\\n  \\n public:\\n  int numDupDigitsAtMostN(const int n) {\\n    return n - no_duplicates(n);\\n  }\\n  \\n private:\\n  int no_duplicates(const int num) {\\n    const string number(to_string(num));\\n    const int n_digits = static_cast<int>(number.size());\\n    vector<vector<int>> memo(n_digits, vector<int>(n_masks, unmemorized));\\n    return dfs(number, 0, 0, true, false, memo);\\n  }\\n  \\n  /**\\n   * return the number of the integers which don\\'t contain any duplicate digits,\\n   *        starting from the `index`\\'th digit\\n   *\\n   * @param index: the index of the current digit\\n   * @param mask: the bit mask indicating the previous digits before the `index`\\'th digits\\n   * @param has_constraints: if it\\'s true, the current digit (`index`\\'th digit) cannot exceed `number[index]`\\n   *                         if not, the current digit can reach `9`\\n   * @param started: if it\\'s true, the current number is greater than `0`\\n   *                 if not, the current number is `0`\\n   */\\n  int dfs(const string &number,\\n          const int index,\\n          const int mask,\\n          const bool has_constraints,\\n          const bool started,\\n          vector<vector<int>> &memo) {\\n    const int n_digits = static_cast<int>(number.size());\\n    if (index == n_digits) {\\n      return started ? 1 : 0;\\n    }\\n    \\n    int ret = !has_constraints && started ? memo[index][mask] : unmemorized;\\n    if (ret != unmemorized) {\\n      return ret;\\n    }\\n    \\n    ret = 0;\\n    const int digit = number[index] - zero;\\n    const int end_digit = has_constraints ? digit + 1 : digits;\\n    for (int d = 0; d < end_digit; ++d) {\\n      if (((mask >> d) & 0b1) == 0b0) {\\n        const int next_started = started || d != 0;\\n        const int next_mask = next_started ? (mask | (1 << d)) : 0;\\n        ret += dfs(number, index + 1, next_mask, (has_constraints && d == digit), next_started, memo);\\n      }\\n    }\\n    \\n    if (!has_constraints && started) {\\n      memo[index][mask] = ret;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n_digits)\\n * Space Complexity: O(n_digits)\\n * where `n_digits` is the number of the digits of the integer `n`\\n */\\nclass Solution {\\n private:\\n  static constexpr int digits = 10;\\n  static constexpr char zero = \\'0\\';\\n  static constexpr int n_masks = 1 << digits;\\n  static constexpr int unmemorized = -1;\\n  \\n public:\\n  int numDupDigitsAtMostN(const int n) {\\n    return n - no_duplicates(n);\\n  }\\n  \\n private:\\n  int no_duplicates(const int num) {\\n    const string number(to_string(num));\\n    const int n_digits = static_cast<int>(number.size());\\n    vector<vector<int>> memo(n_digits, vector<int>(n_masks, unmemorized));\\n    return dfs(number, 0, 0, true, false, memo);\\n  }\\n  \\n  /**\\n   * return the number of the integers which don\\'t contain any duplicate digits,\\n   *        starting from the `index`\\'th digit\\n   *\\n   * @param index: the index of the current digit\\n   * @param mask: the bit mask indicating the previous digits before the `index`\\'th digits\\n   * @param has_constraints: if it\\'s true, the current digit (`index`\\'th digit) cannot exceed `number[index]`\\n   *                         if not, the current digit can reach `9`\\n   * @param started: if it\\'s true, the current number is greater than `0`\\n   *                 if not, the current number is `0`\\n   */\\n  int dfs(const string &number,\\n          const int index,\\n          const int mask,\\n          const bool has_constraints,\\n          const bool started,\\n          vector<vector<int>> &memo) {\\n    const int n_digits = static_cast<int>(number.size());\\n    if (index == n_digits) {\\n      return started ? 1 : 0;\\n    }\\n    \\n    int ret = !has_constraints && started ? memo[index][mask] : unmemorized;\\n    if (ret != unmemorized) {\\n      return ret;\\n    }\\n    \\n    ret = 0;\\n    const int digit = number[index] - zero;\\n    const int end_digit = has_constraints ? digit + 1 : digits;\\n    for (int d = 0; d < end_digit; ++d) {\\n      if (((mask >> d) & 0b1) == 0b0) {\\n        const int next_started = started || d != 0;\\n        const int next_mask = next_started ? (mask | (1 << d)) : 0;\\n        ret += dfs(number, index + 1, next_mask, (has_constraints && d == digit), next_started, memo);\\n      }\\n    }\\n    \\n    if (!has_constraints && started) {\\n      memo[index][mask] = ret;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582582,
                "title": "my-clean-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int n) {\\n        String str = String.valueOf(n);\\n        int len = str.length();\\n        \\n        // all number with no repeat and length < len\\n        int unique = 0;\\n        for (int i = 1; i < len; i++) {\\n            unique += totalNoRepeat(i);\\n        }\\n        \\n\\t\\t// all number with no repeat and length == len\\n        Set<Integer> set = new HashSet<>();\\n        int i = 0;\\n        for (i = 0; i < len; i++) {\\n            int d = str.charAt(i) - \\'0\\';\\n            \\n            int temp = pivotChoice(set, d, i == 0);\\n            for (int j = i+1; j < len; j++) {\\n                temp *= (10 - j);\\n            }\\n            \\n            unique += temp;\\n            if (!set.add(d)) break;       // no need to continue after seeing repeated digits\\n        }\\n        \\n        if (i == len) unique++;      // the number n itself\\n        \\n        return n - unique;\\n    }\\n    \\n    private int totalNoRepeat(int d) {\\n        int res = 9;\\n        for (int i = 1; i < d; i++) {\\n            res *= (10 - i);\\n        }\\n        return res;\\n    }\\n    \\n    private int pivotChoice(Set<Integer> set, int d, boolean first) {\\n        int res = 0;\\n        int i = (first ? 1 : 0);\\n        \\n        while (i < d) {\\n            if (!set.contains(i++)) res++;\\n        }\\n        \\n        return res;\\n    } \\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int n) {\\n        String str = String.valueOf(n);\\n        int len = str.length();\\n        \\n        // all number with no repeat and length < len\\n        int unique = 0;\\n        for (int i = 1; i < len; i++) {\\n            unique += totalNoRepeat(i);\\n        }\\n        \\n\\t\\t// all number with no repeat and length == len\\n        Set<Integer> set = new HashSet<>();\\n        int i = 0;\\n        for (i = 0; i < len; i++) {\\n            int d = str.charAt(i) - \\'0\\';\\n            \\n            int temp = pivotChoice(set, d, i == 0);\\n            for (int j = i+1; j < len; j++) {\\n                temp *= (10 - j);\\n            }\\n            \\n            unique += temp;\\n            if (!set.add(d)) break;       // no need to continue after seeing repeated digits\\n        }\\n        \\n        if (i == len) unique++;      // the number n itself\\n        \\n        return n - unique;\\n    }\\n    \\n    private int totalNoRepeat(int d) {\\n        int res = 9;\\n        for (int i = 1; i < d; i++) {\\n            res *= (10 - i);\\n        }\\n        return res;\\n    }\\n    \\n    private int pivotChoice(Set<Integer> set, int d, boolean first) {\\n        int res = 0;\\n        int i = (first ? 1 : 0);\\n        \\n        while (i < d) {\\n            if (!set.contains(i++)) res++;\\n        }\\n        \\n        return res;\\n    } \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485031,
                "title": "c-3d-digit-dp-using-bitmasking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fn(vector<vector<vector<int>>> &dp, string &s, int i,int bound,int bit)\\n    {\\n        if(i==s.size())\\n        {\\n            if(bit!=0)\\n             return 1;\\n             return 0;\\n        }\\n\\n        if( dp[i][bound][bit]!=-1)\\n        return dp[i][bound][bit];\\n        int maxdigit;\\n        if(bound)\\n        maxdigit = s[i]-\\'0\\';\\n        else\\n        maxdigit = 9;\\n        int ans = 0;\\n        for(int j=0;j<=maxdigit;j++)\\n        {\\n             \\n            if((bit&(1<<j))!=0){\\n              continue;\\n            }\\n            else if(bit==0 && j==0)\\n            {\\n                ans+=fn(dp,s,i+1,bound&&(maxdigit==j),0);\\n            }\\n            else\\n            ans+=fn(dp,s,i+1,bound&&(maxdigit==j),(bit|(1<<j)));\\n        }\\n     \\n        return dp[i][bound][bit] = ans;\\n        \\n\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        vector<vector<vector<int>>> dp(s.size()+1,vector<vector<int>>(3,vector<int>(pow(2,10)+1,-1)));\\n        return n-fn(dp,s,0,1,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fn(vector<vector<vector<int>>> &dp, string &s, int i,int bound,int bit)\\n    {\\n        if(i==s.size())\\n        {\\n            if(bit!=0)\\n             return 1;\\n             return 0;\\n        }\\n\\n        if( dp[i][bound][bit]!=-1)\\n        return dp[i][bound][bit];\\n        int maxdigit;\\n        if(bound)\\n        maxdigit = s[i]-\\'0\\';\\n        else\\n        maxdigit = 9;\\n        int ans = 0;\\n        for(int j=0;j<=maxdigit;j++)\\n        {\\n             \\n            if((bit&(1<<j))!=0){\\n              continue;\\n            }\\n            else if(bit==0 && j==0)\\n            {\\n                ans+=fn(dp,s,i+1,bound&&(maxdigit==j),0);\\n            }\\n            else\\n            ans+=fn(dp,s,i+1,bound&&(maxdigit==j),(bit|(1<<j)));\\n        }\\n     \\n        return dp[i][bound][bit] = ans;\\n        \\n\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        vector<vector<vector<int>>> dp(s.size()+1,vector<vector<int>>(3,vector<int>(pow(2,10)+1,-1)));\\n        return n-fn(dp,s,0,1,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398749,
                "title": "c",
                "content": "```\\nclass Solution {\\n    int countSpecialNumbers(int n) {\\n        string s = to_string(n) ;\\n        int len = s.size() ;\\n        int specialNum = 0 ;\\n        for(int i = 1 ; i <= len-1; i++)\\n            specialNum += 9 * permu(9, i-1) ;\\n        \\n        vector<bool>used(10) ;\\n        dfs(s, 0, used, specialNum) ;\\n        return specialNum ;\\n    }\\n    void dfs(const string& s, int cur, vector<bool>& used, int& specialNum ){\\n        if(cur == s.size()){\\n            specialNum++ ;\\n            return ;\\n        }\\n        \\n        for(int d = 0; d <= 9; d++){\\n            if(cur == 0 && d == 0)\\n                continue ;\\n            if(used[d])\\n                continue ;\\n            if(d < s[cur] - \\'0\\'){\\n                specialNum += permu(10-(cur+1), s.size()-(cur+1)) ;\\n            }\\n            else if(d == s[cur] -\\'0\\'){\\n                used[d] = true ;\\n                dfs(s, cur+1, used, specialNum) ;\\n                used[d] = false ;\\n            }\\n            else\\n                break ;\\n        }\\n    }\\n                \\n    int permu(int m, int n){\\n        if(n == 0)\\n            return 1 ;\\n        int ret = 1 ;\\n        for(int i = 0; i < n; i++)\\n            ret *= (m-i) ;\\n        return ret ;\\n    }    \\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        return n - countSpecialNumbers(n) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int countSpecialNumbers(int n) {\\n        string s = to_string(n) ;\\n        int len = s.size() ;\\n        int specialNum = 0 ;\\n        for(int i = 1 ; i <= len-1; i++)\\n            specialNum += 9 * permu(9, i-1) ;\\n        \\n        vector<bool>used(10) ;\\n        dfs(s, 0, used, specialNum) ;\\n        return specialNum ;\\n    }\\n    void dfs(const string& s, int cur, vector<bool>& used, int& specialNum ){\\n        if(cur == s.size()){\\n            specialNum++ ;\\n            return ;\\n        }\\n        \\n        for(int d = 0; d <= 9; d++){\\n            if(cur == 0 && d == 0)\\n                continue ;\\n            if(used[d])\\n                continue ;\\n            if(d < s[cur] - \\'0\\'){\\n                specialNum += permu(10-(cur+1), s.size()-(cur+1)) ;\\n            }\\n            else if(d == s[cur] -\\'0\\'){\\n                used[d] = true ;\\n                dfs(s, cur+1, used, specialNum) ;\\n                used[d] = false ;\\n            }\\n            else\\n                break ;\\n        }\\n    }\\n                \\n    int permu(int m, int n){\\n        if(n == 0)\\n            return 1 ;\\n        int ret = 1 ;\\n        for(int i = 0; i < n; i++)\\n            ret *= (m-i) ;\\n        return ret ;\\n    }    \\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        return n - countSpecialNumbers(n) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339775,
                "title": "recursion-counting-digits-until-decimal-digit-then-fixing-digit-and-starting-over",
                "content": "# Intuition\\n\\nDisclaimer: I just added comments to Lee\\'s solution, if you like the code please consider upvoting him: https://leetcode.com/problems/numbers-with-repeated-digits/solutions/256725/java-python-count-the-number-without-repeated-digit/\\n\\n# Approach\\n- Mathematics\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(n))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n![image.png](https://assets.leetcode.com/users/images/52092e6f-ca6a-4c52-85fd-7708f263bf9d_1679748770.4206126.png)\\n\\n```java\\nclass Solution {\\n\\n  public int numDupDigitsAtMostN(int N) {\\n      // Example: N = 1000\\n      // Transform N + 1 to arrayList\\n      ArrayList<Integer> L = new ArrayList<Integer>();\\n      for (int x = N + 1; x > 0; x /= 10)\\n          L.add(0, x % 10); // Convert N+1 to a list of digits, L = [1, 0, 0, 1]\\n\\n      // Count the number of non-duplicate digits numbers < N\\n      int res = 0, n = L.size();\\n      for (int i = 1; i < n; ++i)\\n          res += 9 * A(9, i - 1); // Calculate permutations with non-duplicate digits, res = 738 //(9 + 9*9 + 9*9*8)\\n                                  // the usual permutation is 10+10*9+10*9*8.. but we use 9 on the left to exclude\\n                                  // leading zeros\\n\\n      // Count the number of non-duplicate digits numbers with the same prefix\\n      HashSet<Integer> seen = new HashSet<>();\\n      for (int i = 0; i < n; ++i) {\\n          for (int j = i > 0 ? 0 : 1; j < L.get(i); ++j) {  // j=i>0?0:1 is because the leftmost digit cannot\\n                                                            // start with 0, otherwise there would be numbers with\\n                                                            // leading zeroes.\\n              // We must avoid ranges that have digits equal to the ones we fixed to the left.\\n              if (!seen.contains(j)) {\\n                  // Add permutations for this prefix\\n                  res += A(9 - i, n - i - 1); // As j=1=L.get(0) on the for, we neve enter the if in the example\\n              }\\n          }\\n          // if N=ABCD.. after processing (1~A-1)XXX, then we will process A(1~B-1)XXX and so on, but if at some\\n          // point a X is equal to any of the numbers precossed to the left we must stop as ALL NUMBERS will have\\n          // at least 2 duplicated numbers\\n          if (seen.contains(L.get(i))) break;\\n          // after processing 0 (or 1) to A-1 (or B-1 or so on) we are fixxing A (or B or..) to the left, so we\\n          // add it also to seen.\\n          seen.add(L.get(i));\\n      }\\n      // Return N - number of non-duplicate digits numbers to get the count of numbers with duplicate digits\\n      // N - res = 1000 - 738 = 262 (262 numbers have at least one repeated digit)\\n      return N - res;\\n  }\\n\\n  // Calculate permutations: A(m, n) = m! / (m-n)!\\n  public int A(int m, int n) {\\n      return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n  }\\n}\\n```\\nThis is my version of the code. Same idea different details\\n```java\\nclass Solution {\\n    public int numDupDigitsAtMostN(int n) {\\n        ArrayList<Integer> l=new ArrayList<>();\\n        for(int i=n+1;i>0;i/=10) l.add(i%10);\\n        // All the possible numbers. We will remove the numbers\\n        // with unique digits\\n        int r=n;\\n        // Remove all the numbers with unique digits with size\\n        // \\'l.size()-1\\'. The leftmost digit only has 9 candidates\\n        // as we avoid leading zeros\\n        for(int i=1;i<l.size();i++) r-=9*perm(9,i-1);\\n        Set<Integer> fixed=new HashSet<>();\\n        for(int i=l.size()-1;i>-1;i--) {\\n            int curr=l.get(i);\\n            for(int j=i==l.size()-1?1:0;j<curr;j++) {\\n                // if j has been used (fixed) we cannot use it\\n                if(fixed.contains(j)) continue;\\n                // 10 - 1 - fixed.size() //(10 - the digit j -\\n                // already used/fixed didits)// premuted in i\\n                // spaces\\n                r-=perm(9-fixed.size(),i);\\n            }\\n            // if the i-th has already been fixed lets stop, as\\n            // all digits from now on will be duplicated\\n            if(fixed.contains(curr)) break;\\n            // lets fix the i-th digit on the left\\n            fixed.add(curr);\\n        }\\n        return r;\\n    }\\n    // Permutation of A digits in B spaces\\n    int perm(int a, int b) {\\n        int r=1;\\n        for(int i=0;i<b;i++) r*=a--;\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n\\n  public int numDupDigitsAtMostN(int N) {\\n      // Example: N = 1000\\n      // Transform N + 1 to arrayList\\n      ArrayList<Integer> L = new ArrayList<Integer>();\\n      for (int x = N + 1; x > 0; x /= 10)\\n          L.add(0, x % 10); // Convert N+1 to a list of digits, L = [1, 0, 0, 1]\\n\\n      // Count the number of non-duplicate digits numbers < N\\n      int res = 0, n = L.size();\\n      for (int i = 1; i < n; ++i)\\n          res += 9 * A(9, i - 1); // Calculate permutations with non-duplicate digits, res = 738 //(9 + 9*9 + 9*9*8)\\n                                  // the usual permutation is 10+10*9+10*9*8.. but we use 9 on the left to exclude\\n                                  // leading zeros\\n\\n      // Count the number of non-duplicate digits numbers with the same prefix\\n      HashSet<Integer> seen = new HashSet<>();\\n      for (int i = 0; i < n; ++i) {\\n          for (int j = i > 0 ? 0 : 1; j < L.get(i); ++j) {  // j=i>0?0:1 is because the leftmost digit cannot\\n                                                            // start with 0, otherwise there would be numbers with\\n                                                            // leading zeroes.\\n              // We must avoid ranges that have digits equal to the ones we fixed to the left.\\n              if (!seen.contains(j)) {\\n                  // Add permutations for this prefix\\n                  res += A(9 - i, n - i - 1); // As j=1=L.get(0) on the for, we neve enter the if in the example\\n              }\\n          }\\n          // if N=ABCD.. after processing (1~A-1)XXX, then we will process A(1~B-1)XXX and so on, but if at some\\n          // point a X is equal to any of the numbers precossed to the left we must stop as ALL NUMBERS will have\\n          // at least 2 duplicated numbers\\n          if (seen.contains(L.get(i))) break;\\n          // after processing 0 (or 1) to A-1 (or B-1 or so on) we are fixxing A (or B or..) to the left, so we\\n          // add it also to seen.\\n          seen.add(L.get(i));\\n      }\\n      // Return N - number of non-duplicate digits numbers to get the count of numbers with duplicate digits\\n      // N - res = 1000 - 738 = 262 (262 numbers have at least one repeated digit)\\n      return N - res;\\n  }\\n\\n  // Calculate permutations: A(m, n) = m! / (m-n)!\\n  public int A(int m, int n) {\\n      return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n  }\\n}\\n```\n```java\\nclass Solution {\\n    public int numDupDigitsAtMostN(int n) {\\n        ArrayList<Integer> l=new ArrayList<>();\\n        for(int i=n+1;i>0;i/=10) l.add(i%10);\\n        // All the possible numbers. We will remove the numbers\\n        // with unique digits\\n        int r=n;\\n        // Remove all the numbers with unique digits with size\\n        // \\'l.size()-1\\'. The leftmost digit only has 9 candidates\\n        // as we avoid leading zeros\\n        for(int i=1;i<l.size();i++) r-=9*perm(9,i-1);\\n        Set<Integer> fixed=new HashSet<>();\\n        for(int i=l.size()-1;i>-1;i--) {\\n            int curr=l.get(i);\\n            for(int j=i==l.size()-1?1:0;j<curr;j++) {\\n                // if j has been used (fixed) we cannot use it\\n                if(fixed.contains(j)) continue;\\n                // 10 - 1 - fixed.size() //(10 - the digit j -\\n                // already used/fixed didits)// premuted in i\\n                // spaces\\n                r-=perm(9-fixed.size(),i);\\n            }\\n            // if the i-th has already been fixed lets stop, as\\n            // all digits from now on will be duplicated\\n            if(fixed.contains(curr)) break;\\n            // lets fix the i-th digit on the left\\n            fixed.add(curr);\\n        }\\n        return r;\\n    }\\n    // Permutation of A digits in B spaces\\n    int perm(int a, int b) {\\n        int r=1;\\n        for(int i=0;i<b;i++) r*=a--;\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331923,
                "title": "rust-solution",
                "content": "\\n```\\nimpl Solution {\\n    pub fn num_dup_digits_at_most_n(n: i32) -> i32 {\\n        n - Self::num_not_dup_digits_at_most_n(n)\\n    }\\n\\n    fn num_not_dup_digits_at_most_n(n: i32) -> i32 {\\n        let mut n = n;\\n        let mut digits = Vec::new();\\n\\n        while n > 0 {\\n            digits.push(n % 10);\\n            n /= 10;\\n        }\\n\\n        let k = digits.len();\\n\\n        let mut used: [i32; 10] = [0; 10];\\n        let mut total = 0;\\n\\n        for i in 1..k {\\n            total += 9 * Self::permutation(9, i as i32 - 1);\\n        }\\n\\n        for i in 0..k {\\n            let i = k - 1 - i;\\n            let num = digits[i];\\n\\n            for j in (if i == k - 1 { 1 } else { 0 })..num {\\n                if used[j as usize] != 0 {\\n                    continue;\\n                }\\n                total += Self::permutation((10 - k + i) as i32, i as i32);\\n            }\\n\\n            used[num as usize] += 1;\\n            if used[num as usize] > 1 {\\n                break;\\n            }\\n\\n            if i == 0 {\\n                total += 1;\\n            }\\n        }\\n\\n        total\\n    }\\n\\n    fn permutation(n: i32, k: i32) -> i32 {\\n        Self::factorial(n) / Self::factorial(n - k)\\n    }\\n\\n    fn factorial(n: i32) -> i32 {\\n        match n {\\n            0 | 1 => 1,\\n            n @ _ => n * Self::factorial(n - 1),\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_dup_digits_at_most_n(n: i32) -> i32 {\\n        n - Self::num_not_dup_digits_at_most_n(n)\\n    }\\n\\n    fn num_not_dup_digits_at_most_n(n: i32) -> i32 {\\n        let mut n = n;\\n        let mut digits = Vec::new();\\n\\n        while n > 0 {\\n            digits.push(n % 10);\\n            n /= 10;\\n        }\\n\\n        let k = digits.len();\\n\\n        let mut used: [i32; 10] = [0; 10];\\n        let mut total = 0;\\n\\n        for i in 1..k {\\n            total += 9 * Self::permutation(9, i as i32 - 1);\\n        }\\n\\n        for i in 0..k {\\n            let i = k - 1 - i;\\n            let num = digits[i];\\n\\n            for j in (if i == k - 1 { 1 } else { 0 })..num {\\n                if used[j as usize] != 0 {\\n                    continue;\\n                }\\n                total += Self::permutation((10 - k + i) as i32, i as i32);\\n            }\\n\\n            used[num as usize] += 1;\\n            if used[num as usize] > 1 {\\n                break;\\n            }\\n\\n            if i == 0 {\\n                total += 1;\\n            }\\n        }\\n\\n        total\\n    }\\n\\n    fn permutation(n: i32, k: i32) -> i32 {\\n        Self::factorial(n) / Self::factorial(n - k)\\n    }\\n\\n    fn factorial(n: i32) -> i32 {\\n        match n {\\n            0 | 1 => 1,\\n            n @ _ => n * Self::factorial(n - 1),\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3216731,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        // Transform N + 1 to arrayList\\n        ArrayList<Integer> L = new ArrayList<Integer>();\\n        for (int x = N + 1; x > 0; x /= 10)\\n            L.add(0, x % 10);\\n\\n        // Count the number with digits < N\\n        int res = 0, n = L.size();\\n        for (int i = 1; i < n; ++i)\\n            res += 9 * A(9, i - 1);\\n\\n        // Count the number with same prefix\\n        HashSet<Integer> seen = new HashSet<>();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i > 0 ? 0 : 1; j < L.get(i); ++j)\\n                if (!seen.contains(j))\\n                    res += A(9 - i, n - i - 1);\\n            if (seen.contains(L.get(i))) break;\\n            seen.add(L.get(i));\\n        }\\n        return N - res;\\n    }\\n\\n\\n    public int A(int m, int n) {\\n        return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        // Transform N + 1 to arrayList\\n        ArrayList<Integer> L = new ArrayList<Integer>();\\n        for (int x = N + 1; x > 0; x /= 10)\\n            L.add(0, x % 10);\\n\\n        // Count the number with digits < N\\n        int res = 0, n = L.size();\\n        for (int i = 1; i < n; ++i)\\n            res += 9 * A(9, i - 1);\\n\\n        // Count the number with same prefix\\n        HashSet<Integer> seen = new HashSet<>();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i > 0 ? 0 : 1; j < L.get(i); ++j)\\n                if (!seen.contains(j))\\n                    res += A(9 - i, n - i - 1);\\n            if (seen.contains(L.get(i))) break;\\n            seen.add(L.get(i));\\n        }\\n        return N - res;\\n    }\\n\\n\\n    public int A(int m, int n) {\\n        return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165129,
                "title": "digit-dp-count-with-no-repetition-and-return-remaining",
                "content": "```\\nclass Solution:\\n    def count(self, num, i, n, tight, used):\\n        if i >= n:\\n            return 1\\n        key = (i, tight, used)\\n        if key in self.cache:\\n            return self.cache[key]\\n        maxd = 9\\n        if tight:\\n            maxd = int(num[i])\\n        res = 0\\n        for d in range(maxd + 1):\\n            if not used & (1 << d):\\n                newused = used | (1 << d)\\n                if used == 0 and d == 0:\\n                    newused = used\\n                res += self.count(num, i + 1, n, tight and d == maxd, newused)\\n        self.cache[key] = res\\n        return res\\n    \\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        self.cache = {}\\n        num = str(n)\\n        return n - self.count(num, 0, len(num), True, 0) + 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def count(self, num, i, n, tight, used):\\n        if i >= n:\\n            return 1\\n        key = (i, tight, used)\\n        if key in self.cache:\\n            return self.cache[key]\\n        maxd = 9\\n        if tight:\\n            maxd = int(num[i])\\n        res = 0\\n        for d in range(maxd + 1):\\n            if not used & (1 << d):\\n                newused = used | (1 << d)\\n                if used == 0 and d == 0:\\n                    newused = used\\n                res += self.count(num, i + 1, n, tight and d == maxd, newused)\\n        self.cache[key] = res\\n        return res\\n    \\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        self.cache = {}\\n        num = str(n)\\n        return n - self.count(num, 0, len(num), True, 0) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160997,
                "title": "easy-digit-dp-solution-with-c",
                "content": "# Intuition\\n\\nThe idea of this solution is to count the number of integers with unique digits from 0 to N, Then substruct the number from n.\\n\\n# Approach\\nWe can use Digit dp with 4 parameters, The first one is the number of the index, and the 2nd one is the tight variable(It will save us exceeding the given number range), the 3rd one keeps track of the leading zero and the 4th one will keep track the numbers that have been used.\\n\\nsuppose we have 2 indexes. If we use 0 in the 2nd index then we will have 9 numbers to put in the 1st index,(1-->9). And if we use 1 in the 2nd index, then we will also have 9 numbers to put in the 1st index.(0,2-->9). \\nIf you go through the code , the approach will become more clear to you.\\n\\n \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[12][2][2][10];\\n\\n    int calc(string& s, int ind, int tight, int parbo, set<int>&v) {\\n        if (ind == 0) {\\n            if (parbo == 1) {\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        int n = v.size();\\n        if (dp[ind][tight][parbo][n] != -1)return dp[ind][tight][parbo][n];\\n        // Check the upper Bound\\n        int ub = tight == 1 ? (s[s.size() - ind] - \\'0\\') : 9;\\n        int ans = 0;\\n        // Filling index with leading zeroes.\\n        if (parbo == 1) {\\n            ans += calc(s, ind - 1, (tight & (0 == ub)), 1, v);\\n        }\\n        // the zero i put will not be a leading zero if a have put a number (1-->9) before this index\\n        else if (v.find(0) == v.end()) {// checking if i have used 0 before\\n            v.insert(0);\\n            ans += calc(s, ind - 1, (tight & (0 == ub)), 0, v);\\n            v.erase(v.find(0));\\n        }\\n        for (int i = 1; i <= ub; i++) {\\n            if (v.find(i) == v.end()) {\\n                v.insert(i);\\n                ans += calc(s, ind - 1, (tight & (i == ub)), 0, v);\\n                v.erase(v.find(i));\\n            }\\n        }\\n        return dp[ind][tight][parbo][n] =  ans;\\n    }\\n\\n    int numDupDigitsAtMostN(int n) {\\n        string S = to_string(n);\\n        set<int>v;\\n        memset(dp, -1, sizeof(dp));\\n        int ans = calc(S, S.size(), 1, 1, v);\\n        return n - ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[12][2][2][10];\\n\\n    int calc(string& s, int ind, int tight, int parbo, set<int>&v) {\\n        if (ind == 0) {\\n            if (parbo == 1) {\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        int n = v.size();\\n        if (dp[ind][tight][parbo][n] != -1)return dp[ind][tight][parbo][n];\\n        // Check the upper Bound\\n        int ub = tight == 1 ? (s[s.size() - ind] - \\'0\\') : 9;\\n        int ans = 0;\\n        // Filling index with leading zeroes.\\n        if (parbo == 1) {\\n            ans += calc(s, ind - 1, (tight & (0 == ub)), 1, v);\\n        }\\n        // the zero i put will not be a leading zero if a have put a number (1-->9) before this index\\n        else if (v.find(0) == v.end()) {// checking if i have used 0 before\\n            v.insert(0);\\n            ans += calc(s, ind - 1, (tight & (0 == ub)), 0, v);\\n            v.erase(v.find(0));\\n        }\\n        for (int i = 1; i <= ub; i++) {\\n            if (v.find(i) == v.end()) {\\n                v.insert(i);\\n                ans += calc(s, ind - 1, (tight & (i == ub)), 0, v);\\n                v.erase(v.find(i));\\n            }\\n        }\\n        return dp[ind][tight][parbo][n] =  ans;\\n    }\\n\\n    int numDupDigitsAtMostN(int n) {\\n        string S = to_string(n);\\n        set<int>v;\\n        memset(dp, -1, sizeof(dp));\\n        int ans = calc(S, S.size(), 1, 1, v);\\n        return n - ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063291,
                "title": "simple-python-solution-but-time-limit-exceed",
                "content": "class Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        count=0\\n        for i in range(1,n+1):\\n            temp=str(i)\\n            d={}\\n            for i in temp:\\n                if i in d:\\n                    count+=1\\n                    break\\n                else:\\n                    d[i]=1\\n       return count",
                "solutionTags": [
                    "Python",
                    "Combinatorics"
                ],
                "code": "class Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        count=0\\n        for i in range(1,n+1):\\n            temp=str(i)\\n            d={}",
                "codeTag": "Java"
            },
            {
                "id": 3029660,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn num_dup_digits_at_most_n(n: i32) -> i32 {\\n        fn _a(m: i32, n: i32) -> i32 {\\n            if n == 0 {\\n                1\\n            } else {\\n                _a(m, n - 1) * (m - n + 1)\\n            }\\n        }\\n\\n        let mut digits = Vec::new();\\n        let mut x = n + 1;\\n        while x > 0 {\\n            digits.insert(0, x % 10);\\n            x /= 10;\\n        }\\n\\n        let mut res = 0;\\n        let len = digits.len();\\n        for i in 1..len {\\n            res += 9 * _a(9, i as i32 - 1);\\n        }\\n\\n        let mut seen = std::collections::HashSet::new();\\n        for (i, &digit) in digits.iter().enumerate().take(len) {\\n            for j in i32::from(i == 0)..digit {\\n                if !seen.contains(&j) {\\n                    res += _a(9 - i as i32, len as i32 - i as i32 - 1);\\n                }\\n            }\\n            if seen.contains(&digit) {\\n                break;\\n            }\\n            seen.insert(digit);\\n        }\\n        n - res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_dup_digits_at_most_n(n: i32) -> i32 {\\n        fn _a(m: i32, n: i32) -> i32 {\\n            if n == 0 {\\n                1\\n            } else {\\n                _a(m, n - 1) * (m - n + 1)\\n            }\\n        }\\n\\n        let mut digits = Vec::new();\\n        let mut x = n + 1;\\n        while x > 0 {\\n            digits.insert(0, x % 10);\\n            x /= 10;\\n        }\\n\\n        let mut res = 0;\\n        let len = digits.len();\\n        for i in 1..len {\\n            res += 9 * _a(9, i as i32 - 1);\\n        }\\n\\n        let mut seen = std::collections::HashSet::new();\\n        for (i, &digit) in digits.iter().enumerate().take(len) {\\n            for j in i32::from(i == 0)..digit {\\n                if !seen.contains(&j) {\\n                    res += _a(9 - i as i32, len as i32 - i as i32 - 1);\\n                }\\n            }\\n            if seen.contains(&digit) {\\n                break;\\n            }\\n            seen.insert(digit);\\n        }\\n        n - res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2994696,
                "title": "python3-concise-solution-beats-99",
                "content": "# Code\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n    \\tT = [9,261,4725,67509,831429,9287109,97654149,994388229]\\n    \\tt = [99,999,9999,99999,999999,9999999,99999999,999999999]\\n    \\tif N < 10:\\n    \\t\\treturn 0\\n    \\tL = len(str(N))\\n    \\tm, n = [1], []\\n    \\tg = 11-L\\n    \\tfor i in range(L):\\n    \\t\\tn.append(int(str(N)[i]))\\n    \\t\\tm.append(g)\\n    \\t\\tg = g*(12-L+i)\\n    \\tS = 0\\n    \\tfor i in range(L):\\n    \\t\\tif len(set(n[:L-i-1])) != len(n)-i-1: continue\\n    \\t\\tk = 0\\n    \\t\\tfor j in range(10):\\n    \\t\\t\\tif j not in n[:L-i-1] and j > n[L-i-1]: k += 1\\n    \\t\\tS += k*m[i]\\n    \\treturn(T[L-2]-(t[L-2]-N-S))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n    \\tT = [9,261,4725,67509,831429,9287109,97654149,994388229]\\n    \\tt = [99,999,9999,99999,999999,9999999,99999999,999999999]\\n    \\tif N < 10:\\n    \\t\\treturn 0\\n    \\tL = len(str(N))\\n    \\tm, n = [1], []\\n    \\tg = 11-L\\n    \\tfor i in range(L):\\n    \\t\\tn.append(int(str(N)[i]))\\n    \\t\\tm.append(g)\\n    \\t\\tg = g*(12-L+i)\\n    \\tS = 0\\n    \\tfor i in range(L):\\n    \\t\\tif len(set(n[:L-i-1])) != len(n)-i-1: continue\\n    \\t\\tk = 0\\n    \\t\\tfor j in range(10):\\n    \\t\\t\\tif j not in n[:L-i-1] and j > n[L-i-1]: k += 1\\n    \\t\\tS += k*m[i]\\n    \\treturn(T[L-2]-(t[L-2]-N-S))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942870,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\n\\n\\nvar numDupDigitsAtMostN = function(N) {\\n  let digits = toDigits(N);\\n  let len = digits.length;\\n  //console.log(digits);\\n\\n  let d = 0;\\n\\n  //1 to 10^{len-1}-1\\n  for (let r = 1; r < len; r++) {\\n    let dr = countDiff(r);\\n    d += dr;\\n  }\\n\\n  //10^len to N-1\\n  for (let i = 0; i < len; i++) {\\n    let di = countDiff1(digits, i);\\n    d += di;\\n  }\\n\\n  //N\\n  if (isDuplicated(digits, len) == false) d++;\\n\\n  return N - d;\\n};\\n\\nfunction countDiff(r) {\\n  //print range\\n  let start = [1];\\n  for (let j = 1; j < r; j++) start.push(0);\\n  let end = [];\\n  for (let j = 0; j < r; j++) end.push(9);\\n  //console.log(`scan ${start} to ${end}`);\\n\\n  //first digit starts from 1\\n  let d = 9 * permutation(r - 1, 9);\\n  //console.log(`\\\\tr=${r} d=${d}`);\\n\\n  return d;\\n}\\n\\nfunction countDiff1(digits, i) {\\n  //print range\\n  let start = digits.slice(0, i + 1);\\n  start[i] = i == 0 ? 1 : 0;\\n  for (let j = i + 1; j < digits.length; j++) start.push(0);\\n  let end = digits.slice(0, i + 1);\\n  end[i] = end[i] - 1;\\n  for (let j = i + 1; j < digits.length; j++) end.push(9);\\n  //console.log(`scan2 from ${start} to ${end}`);\\n\\n  if (start[i] > end[i]) return 0;\\n\\n  //duplicated\\n  if (isDuplicated(digits, i)) return 0;\\n\\n  let remainingDigits = getRemainingDigits(digits, i);\\n\\n  //keep di\\n  let r = digits.length - 1 - i; //remaining len\\n  let n = 10 - i - 1; //remaining digits 0-9\\n  let d = remainingDigits * permutation(r, n);\\n  //console.log(`\\\\tr=${r} n=${n} d=${d}`);\\n\\n  return d;\\n}\\n\\nfunction getRemainingDigits(digits, i) {\\n  let used = getUsedDigits(digits, i);\\n\\n  let start = i == 0 ? 1 : 0;\\n  let end = digits[i] - 1;\\n\\n  let x = [];\\n  for (let i = start; i <= end; i++) {\\n    if (!used.has(i)) x.push(i);\\n  }\\n\\n  return x.length;\\n}\\n\\nfunction getUsedDigits(digits, i) {\\n  let map = new Map();\\n\\n  for (let j = 0; j < i; j++) {\\n    let d = digits[j];\\n\\n    //duplicated\\n    if (!map.has(d)) map.set(d, 1);\\n  }\\n\\n  return map;\\n}\\n\\nfunction isDuplicated(digits, i) {\\n  let map = new Map();\\n\\n  for (let j = 0; j < i; j++) {\\n    let d = digits[j];\\n\\n    //duplicated\\n    if (map.has(d)) return true;\\n\\n    map.set(d, 1);\\n  }\\n\\n  return false;\\n}\\n\\nfunction toDigits(n) {\\n  let a = new Array();\\n\\n  while (n > 0) {\\n    let d = n % 10;\\n    a.push(d);\\n\\n    n = Math.floor(n / 10);\\n  }\\n\\n  a.reverse();\\n\\n  return a;\\n}\\n\\nfunction permutation(r, n) {\\n  if (r == 0) return 1;\\n\\n  let p = 1;\\n  for (let i = 0; i < r; i++) {\\n    p *= n - i;\\n  }\\n\\n  return p;\\n}\\n\\nconsole.log(numDupDigitsAtMostN(1000));\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\n\\n\\nvar numDupDigitsAtMostN = function(N) {\\n  let digits = toDigits(N);\\n  let len = digits.length;\\n  //console.log(digits);\\n\\n  let d = 0;\\n\\n  //1 to 10^{len-1}-1\\n  for (let r = 1; r < len; r++) {\\n    let dr = countDiff(r);\\n    d += dr;\\n  }\\n\\n  //10^len to N-1\\n  for (let i = 0; i < len; i++) {\\n    let di = countDiff1(digits, i);\\n    d += di;\\n  }\\n\\n  //N\\n  if (isDuplicated(digits, len) == false) d++;\\n\\n  return N - d;\\n};\\n\\nfunction countDiff(r) {\\n  //print range\\n  let start = [1];\\n  for (let j = 1; j < r; j++) start.push(0);\\n  let end = [];\\n  for (let j = 0; j < r; j++) end.push(9);\\n  //console.log(`scan ${start} to ${end}`);\\n\\n  //first digit starts from 1\\n  let d = 9 * permutation(r - 1, 9);\\n  //console.log(`\\\\tr=${r} d=${d}`);\\n\\n  return d;\\n}\\n\\nfunction countDiff1(digits, i) {\\n  //print range\\n  let start = digits.slice(0, i + 1);\\n  start[i] = i == 0 ? 1 : 0;\\n  for (let j = i + 1; j < digits.length; j++) start.push(0);\\n  let end = digits.slice(0, i + 1);\\n  end[i] = end[i] - 1;\\n  for (let j = i + 1; j < digits.length; j++) end.push(9);\\n  //console.log(`scan2 from ${start} to ${end}`);\\n\\n  if (start[i] > end[i]) return 0;\\n\\n  //duplicated\\n  if (isDuplicated(digits, i)) return 0;\\n\\n  let remainingDigits = getRemainingDigits(digits, i);\\n\\n  //keep di\\n  let r = digits.length - 1 - i; //remaining len\\n  let n = 10 - i - 1; //remaining digits 0-9\\n  let d = remainingDigits * permutation(r, n);\\n  //console.log(`\\\\tr=${r} n=${n} d=${d}`);\\n\\n  return d;\\n}\\n\\nfunction getRemainingDigits(digits, i) {\\n  let used = getUsedDigits(digits, i);\\n\\n  let start = i == 0 ? 1 : 0;\\n  let end = digits[i] - 1;\\n\\n  let x = [];\\n  for (let i = start; i <= end; i++) {\\n    if (!used.has(i)) x.push(i);\\n  }\\n\\n  return x.length;\\n}\\n\\nfunction getUsedDigits(digits, i) {\\n  let map = new Map();\\n\\n  for (let j = 0; j < i; j++) {\\n    let d = digits[j];\\n\\n    //duplicated\\n    if (!map.has(d)) map.set(d, 1);\\n  }\\n\\n  return map;\\n}\\n\\nfunction isDuplicated(digits, i) {\\n  let map = new Map();\\n\\n  for (let j = 0; j < i; j++) {\\n    let d = digits[j];\\n\\n    //duplicated\\n    if (map.has(d)) return true;\\n\\n    map.set(d, 1);\\n  }\\n\\n  return false;\\n}\\n\\nfunction toDigits(n) {\\n  let a = new Array();\\n\\n  while (n > 0) {\\n    let d = n % 10;\\n    a.push(d);\\n\\n    n = Math.floor(n / 10);\\n  }\\n\\n  a.reverse();\\n\\n  return a;\\n}\\n\\nfunction permutation(r, n) {\\n  if (r == 0) return 1;\\n\\n  let p = 1;\\n  for (let i = 0; i < r; i++) {\\n    p *= n - i;\\n  }\\n\\n  return p;\\n}\\n\\nconsole.log(numDupDigitsAtMostN(1000));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2919057,
                "title": "digit-dp-using-bitmask-recursive-memoization-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[10][2050][2][12];\\n    int solve(string &s, int dig, int mask, int IsTight, int digit)\\n    {\\n        int ub = 9, ans = 0;\\n        if(dp[dig][mask][IsTight][digit] != -1)return dp[dig][mask][IsTight][digit];\\n        if(dig == s.size())\\n        {\\n            int cnt = 0;\\n            for(int i=0;i<=9;i++)if(mask & (1 << i))cnt++;\\n            if(digit == 11 || cnt == s.size()-digit)return dp[dig][mask][IsTight][digit] = 0;\\n            return dp[dig][mask][IsTight][digit] = 1;\\n        }\\n        if(IsTight)ub = s[dig]-\\'0\\';\\n        if(digit == 11)\\n        {\\n            ans += solve(s, dig+1, mask, 0, 11);\\n            for(int i=1;i<ub;i++)ans += solve(s, dig + 1,mask | (1 << i),0,dig);\\n            if(!IsTight)ans += solve(s, dig + 1, mask | (1 << ub),0,dig);\\n            else  ans += solve(s, dig + 1, mask | (1 << ub),1,dig);\\n        }\\n        else\\n        {\\n            for(int i=0;i<ub;i++)ans += solve(s, dig + 1,mask | (1 << i),0,digit);\\n            if(!IsTight)ans += solve(s, dig + 1, mask | (1 << ub),0,digit);\\n            else  ans += solve(s, dig + 1, mask | (1 << ub),1,digit);\\n        }\\n        return dp[dig][mask][IsTight][digit] = ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        memset(dp, -1 , sizeof(dp));\\n        // reverse(s.begin(),s.end());\\n        if(n <= 10)return 0;\\n        return solve(s, 0, 0, 1, 11);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10][2050][2][12];\\n    int solve(string &s, int dig, int mask, int IsTight, int digit)\\n    {\\n        int ub = 9, ans = 0;\\n        if(dp[dig][mask][IsTight][digit] != -1)return dp[dig][mask][IsTight][digit];\\n        if(dig == s.size())\\n        {\\n            int cnt = 0;\\n            for(int i=0;i<=9;i++)if(mask & (1 << i))cnt++;\\n            if(digit == 11 || cnt == s.size()-digit)return dp[dig][mask][IsTight][digit] = 0;\\n            return dp[dig][mask][IsTight][digit] = 1;\\n        }\\n        if(IsTight)ub = s[dig]-\\'0\\';\\n        if(digit == 11)\\n        {\\n            ans += solve(s, dig+1, mask, 0, 11);\\n            for(int i=1;i<ub;i++)ans += solve(s, dig + 1,mask | (1 << i),0,dig);\\n            if(!IsTight)ans += solve(s, dig + 1, mask | (1 << ub),0,dig);\\n            else  ans += solve(s, dig + 1, mask | (1 << ub),1,dig);\\n        }\\n        else\\n        {\\n            for(int i=0;i<ub;i++)ans += solve(s, dig + 1,mask | (1 << i),0,digit);\\n            if(!IsTight)ans += solve(s, dig + 1, mask | (1 << ub),0,digit);\\n            else  ans += solve(s, dig + 1, mask | (1 << ub),1,digit);\\n        }\\n        return dp[dig][mask][IsTight][digit] = ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        memset(dp, -1 , sizeof(dp));\\n        // reverse(s.begin(),s.end());\\n        if(n <= 10)return 0;\\n        return solve(s, 0, 0, 1, 11);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907178,
                "title": "python-solution-count-numbers-with-non-repeating-digits",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        limit, s = list(map(int, str(N + 1))), set()\\n        n, res = len(limit), sum(9 * perm(9, i) for i in range(len(limit) - 1))\\n        for i, x in enumerate(limit):\\n            for y in range(i == 0, x):\\n                if y not in s:\\n                    res += perm(9 - i, n - i - 1)\\n            if x in s: \\n                break\\n            s.add(x)\\n        return N - res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        limit, s = list(map(int, str(N + 1))), set()\\n        n, res = len(limit), sum(9 * perm(9, i) for i in range(len(limit) - 1))\\n        for i, x in enumerate(limit):\\n            for y in range(i == 0, x):\\n                if y not in s:\\n                    res += perm(9 - i, n - i - 1)\\n            if x in s: \\n                break\\n            s.add(x)\\n        return N - res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884796,
                "title": "python-simple-digit-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n):\\n        ans = [int(i) for i in str(n)]\\n        \\n        @lru_cache(None)\\n        def dp(pos,tight,mask):\\n            if pos == len(ans):\\n                return 1\\n\\n            total = 0\\n\\n            upperlimit = ans[pos] if tight else 9\\n\\n            for d in range(upperlimit+1):\\n                if mask&(1<<d):\\n                    continue\\n\\n                new_tight = tight and d == upperlimit\\n                new_mask = mask if mask == 0 and d == 0 else mask|(1<<d)\\n\\n                total += dp(pos+1,new_tight,new_mask)\\n\\n            return total\\n\\n        return n - (dp(0,True,0) - 1)\\n\\n\\n\\n\\n                \\n\\n\\n\\n\\n\\n\\n\\n            \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n):\\n        ans = [int(i) for i in str(n)]\\n        \\n        @lru_cache(None)\\n        def dp(pos,tight,mask):\\n            if pos == len(ans):\\n                return 1\\n\\n            total = 0\\n\\n            upperlimit = ans[pos] if tight else 9\\n\\n            for d in range(upperlimit+1):\\n                if mask&(1<<d):\\n                    continue\\n\\n                new_tight = tight and d == upperlimit\\n                new_mask = mask if mask == 0 and d == 0 else mask|(1<<d)\\n\\n                total += dp(pos+1,new_tight,new_mask)\\n\\n            return total\\n\\n        return n - (dp(0,True,0) - 1)\\n\\n\\n\\n\\n                \\n\\n\\n\\n\\n\\n\\n\\n            \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821335,
                "title": "numbers-with-repeated-digits",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        vector<int> V;\\n        int n2 = n;\\n        while(n2){\\n            V.emplace_back(n2%10);\\n            n2/=10;\\n        }\\n        int len = V.size();\\n        \\n        int sum = 0;\\n        for(int i = 0; i < len-1; i++){\\n            sum += 9*A(9,i);\\n        }\\n        \\n        vector<int> dig_visited(10,0);\\n        for(int i = len-1; i >= 0; i--){\\n            int dig = V[i];\\n            int count = 0;\\n            for(int j = 0; j < dig; j++){\\n                if(dig_visited[j]){continue;}\\n                count++;\\n            }\\n            if(i == len-1){count--;}\\n            sum += count*A(10-(len-i), i);\\n            if(dig_visited[dig]){break;}\\n            if(i == 0 && dig_visited[dig] == 0){sum++;}\\n            dig_visited[dig] = 1;\\n        }\\n        \\n        return n - sum;\\n    }\\n    \\n    int A(int num, int len){\\n        int tmp = 1;\\n        for(int i = 0; i < len; i++){tmp *= (num-i);}\\n        return tmp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        vector<int> V;\\n        int n2 = n;\\n        while(n2){\\n            V.emplace_back(n2%10);\\n            n2/=10;\\n        }\\n        int len = V.size();\\n        \\n        int sum = 0;\\n        for(int i = 0; i < len-1; i++){\\n            sum += 9*A(9,i);\\n        }\\n        \\n        vector<int> dig_visited(10,0);\\n        for(int i = len-1; i >= 0; i--){\\n            int dig = V[i];\\n            int count = 0;\\n            for(int j = 0; j < dig; j++){\\n                if(dig_visited[j]){continue;}\\n                count++;\\n            }\\n            if(i == len-1){count--;}\\n            sum += count*A(10-(len-i), i);\\n            if(dig_visited[dig]){break;}\\n            if(i == 0 && dig_visited[dig] == 0){sum++;}\\n            dig_visited[dig] = 1;\\n        }\\n        \\n        return n - sum;\\n    }\\n    \\n    int A(int num, int len){\\n        int tmp = 1;\\n        for(int i = 0; i < len; i++){tmp *= (num-i);}\\n        return tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787947,
                "title": "c-100-concept-find-numbers-from-1-to-n-which-are-having-non-repeating-digits",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount **non-repeater** the Number Without Repeated Digit\\nThen the number with repeated digits = N - **non-repeater**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn comments I have explained whole code with examples.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g.$$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n        vector<int> prefix;   //it will store all possible permutation of those numbers which have non-repeation digit\\n    \\npublic:\\n    Solution(){\\n        prefix.push_back(0); //for zero length digit -> possible cases = 0 \\n        prefix.push_back(9);\\n        int prev=9;\\n        int cnt=9;\\n        while(cnt>0){\\n            prefix.push_back(prefix.back()+(cnt*prev));    // 9 + 9*9 + 9*9*8 + 9*9*8*7 + .... 9*9*8*7*6*5*4*3*2*1 \\n            prev*=cnt;\\n            cnt--;\\n        }\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        //find no repeatation numbers count and then subtract it with n;\\n        vector<int> hash;\\n        int temp=n;\\n        while(temp>0){\\n            hash.push_back(temp%10);\\n            temp=temp/10;\\n        }\\n        reverse(hash.begin(),hash.end());  \\n        int len=hash.size();\\n        \\n        int non_repeater=this->prefix[len-1]; // total possible cases upto given length -1 digits eg: 1000 -> 4 digits so we find upto 3 digits possible cases upto 999\\n        \\n        unordered_set<int> ap; //those number which are already present in n;\\n        \\n        //for remaining cases which are of length equals to n number\\'s digits eg: n=700 then remaining are 100 to 699 all are of 3 digit\\n        \\n        \\n        //eg: n=746 -> i=0 it will cnt -> 100 to 699 cases , then i=1  pos[0]=7->fixed & cnt-> 0 to 39 , then i=2 pos[0]=7 & pos[1]=4-> fixed & cnt->0 to 5\\n        for(int i=0;i<hash.size();i++){\\n            if(ap.size()<i){   //eg n=9999 so if i=2 therefore pos[0]=9 & pos[1]=9 are fixed and both are same so after that all cases are having repeation bcz of pos[0]&pos[1] \\n                break;\\n            }\\n            int j=0;\\n            // in first position zero is not inluded\\n            if(i==0){\\n                j=1;\\n            }\\n            int cnt=0;\\n            for(;j<hash[i];j++){\\n                if(ap.find(j)==ap.end()){\\n                    cnt++;\\n                }\\n            }\\n            \\n            int st=9-ap.size(); // those which are present in n & are now fixed like in above eg are not included\\n            for(int k=i+1;k<hash.size() && st>0;k++){\\n                cnt*=st;\\n                st--;\\n            }\\n            ap.insert(hash[i]); \\n            non_repeater+=cnt;\\n        }\\n        \\n        return n-non_repeater-(ap.size()==len); //the given number itself is checked here\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n        vector<int> prefix;   //it will store all possible permutation of those numbers which have non-repeation digit\\n    \\npublic:\\n    Solution(){\\n        prefix.push_back(0); //for zero length digit -> possible cases = 0 \\n        prefix.push_back(9);\\n        int prev=9;\\n        int cnt=9;\\n        while(cnt>0){\\n            prefix.push_back(prefix.back()+(cnt*prev));    // 9 + 9*9 + 9*9*8 + 9*9*8*7 + .... 9*9*8*7*6*5*4*3*2*1 \\n            prev*=cnt;\\n            cnt--;\\n        }\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        //find no repeatation numbers count and then subtract it with n;\\n        vector<int> hash;\\n        int temp=n;\\n        while(temp>0){\\n            hash.push_back(temp%10);\\n            temp=temp/10;\\n        }\\n        reverse(hash.begin(),hash.end());  \\n        int len=hash.size();\\n        \\n        int non_repeater=this->prefix[len-1]; // total possible cases upto given length -1 digits eg: 1000 -> 4 digits so we find upto 3 digits possible cases upto 999\\n        \\n        unordered_set<int> ap; //those number which are already present in n;\\n        \\n        //for remaining cases which are of length equals to n number\\'s digits eg: n=700 then remaining are 100 to 699 all are of 3 digit\\n        \\n        \\n        //eg: n=746 -> i=0 it will cnt -> 100 to 699 cases , then i=1  pos[0]=7->fixed & cnt-> 0 to 39 , then i=2 pos[0]=7 & pos[1]=4-> fixed & cnt->0 to 5\\n        for(int i=0;i<hash.size();i++){\\n            if(ap.size()<i){   //eg n=9999 so if i=2 therefore pos[0]=9 & pos[1]=9 are fixed and both are same so after that all cases are having repeation bcz of pos[0]&pos[1] \\n                break;\\n            }\\n            int j=0;\\n            // in first position zero is not inluded\\n            if(i==0){\\n                j=1;\\n            }\\n            int cnt=0;\\n            for(;j<hash[i];j++){\\n                if(ap.find(j)==ap.end()){\\n                    cnt++;\\n                }\\n            }\\n            \\n            int st=9-ap.size(); // those which are present in n & are now fixed like in above eg are not included\\n            for(int k=i+1;k<hash.size() && st>0;k++){\\n                cnt*=st;\\n                st--;\\n            }\\n            ap.insert(hash[i]); \\n            non_repeater+=cnt;\\n        }\\n        \\n        return n-non_repeater-(ap.size()==len); //the given number itself is checked here\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2688925,
                "title": "digit-dp-python-time-o-m-space-o-m",
                "content": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        A = list(map(int, str(n)))\\n        N = len(A)\\n        \\n        @cache\\n        def dp(pos, tight, mask, hasDup):\\n            if pos >= N:\\n                if hasDup:\\n                    return 1\\n                return 0\\n            \\n            upperLimit = A[pos] if tight else 9\\n            ans = 0\\n            for d in range(upperLimit + 1):\\n                tight2 = tight and d == upperLimit\\n                \\n                # mask represents the used digits:\\n                # 0000000000 <-- mask\\n                # 9876543210 <-- represented numbers\\n                \\n                # if mask is 0, it means that we haven\\'t included any digit yet,\\n                # and we if d == 0 we don\\'t want to include it, because it would result in a leading zero.\\n                mask2 = mask if mask == 0 and d == 0 else mask | (1 << d)\\n                hasDup2 = hasDup or (mask & (1 << d))\\n                ans += dp(pos + 1, tight2, mask2, hasDup2)\\n            return ans\\n            \\n        return dp(0, True, 0, False)\\n        # Time: O(m) where m is the number of digits of n.\\n        #         The other parameters of function dp are constant (2 * 2 ** 10 = 2000),\\n        #         therefore can be ignored\\n        # Space: O(m)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        A = list(map(int, str(n)))\\n        N = len(A)\\n        \\n        @cache\\n        def dp(pos, tight, mask, hasDup):\\n            if pos >= N:\\n                if hasDup:\\n                    return 1\\n                return 0\\n            \\n            upperLimit = A[pos] if tight else 9\\n            ans = 0\\n            for d in range(upperLimit + 1):\\n                tight2 = tight and d == upperLimit\\n                \\n                # mask represents the used digits:\\n                # 0000000000 <-- mask\\n                # 9876543210 <-- represented numbers\\n                \\n                # if mask is 0, it means that we haven\\'t included any digit yet,\\n                # and we if d == 0 we don\\'t want to include it, because it would result in a leading zero.\\n                mask2 = mask if mask == 0 and d == 0 else mask | (1 << d)\\n                hasDup2 = hasDup or (mask & (1 << d))\\n                ans += dp(pos + 1, tight2, mask2, hasDup2)\\n            return ans\\n            \\n        return dp(0, True, 0, False)\\n        # Time: O(m) where m is the number of digits of n.\\n        #         The other parameters of function dp are constant (2 * 2 ** 10 = 2000),\\n        #         therefore can be ignored\\n        # Space: O(m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683084,
                "title": "c",
                "content": "(```) class Solution {\\npublic:\\n    int dfs(long curr, int mask, int n)\\n    {\\n        if(curr > n)\\n        {\\n            return 0;\\n        }\\n        \\n        int ans = 1;\\n        \\n        for(int i=0; i<10; i++)\\n        {\\n            if(i == 0 && mask == 0)\\n            {\\n                continue;\\n            }\\n            \\n            if(mask & (1 << i))\\n            {\\n                continue;\\n            }\\n            \\n            ans += dfs(curr*10+i, mask+ (1<<i), n);\\n        }\\n        \\n        return ans;\\n       \\n    }\\n    \\n    int numDupDigitsAtMostN(int n)\\n    {\\n        return n+1 - dfs(0,0,n);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dfs(long curr, int mask, int n)\\n    {\\n        if(curr > n)\\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2548368,
                "title": "digit-dp-bitmasking-beginner-friendly",
                "content": "```\\nclass Solution {\\n    string s;\\n    int m;\\npublic:\\n    int dp[10][1<<10][2][2];\\n    int f(int pos,int mask,int leadingZeros,int bound){\\n        \\n        if(pos==m)return 1;\\n        if(dp[pos][mask][leadingZeros][bound]!=-1)\\n            return dp[pos][mask][leadingZeros][bound];\\n        int maxdigit=bound?s[pos]-\\'0\\':9;\\n        int ans=0;\\n        if(leadingZeros)\\n            ans+=f(pos+1,mask,1,0);\\n        \\n        for(int digit=0;digit<=maxdigit;digit++)\\n        {   \\n            if(leadingZeros && digit==0)continue;\\n            if(mask&(1<<digit)){\\n                ans+=f(pos+1,mask^(1<<digit),0,bound&(digit==maxdigit));\\n            }\\n            \\n        }\\n        return dp[pos][mask][leadingZeros][bound]=ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        this->s=to_string(n);\\n        this->m=s.size();\\n        int mask=(1<<10)-1;\\n        memset(dp,-1,sizeof dp);\\n        int ans=f(0,mask,1,1)-1;\\n        return n-ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    string s;\\n    int m;\\npublic:\\n    int dp[10][1<<10][2][2];\\n    int f(int pos,int mask,int leadingZeros,int bound){\\n        \\n        if(pos==m)return 1;\\n        if(dp[pos][mask][leadingZeros][bound]!=-1)\\n            return dp[pos][mask][leadingZeros][bound];\\n        int maxdigit=bound?s[pos]-\\'0\\':9;\\n        int ans=0;\\n        if(leadingZeros)\\n            ans+=f(pos+1,mask,1,0);\\n        \\n        for(int digit=0;digit<=maxdigit;digit++)\\n        {   \\n            if(leadingZeros && digit==0)continue;\\n            if(mask&(1<<digit)){\\n                ans+=f(pos+1,mask^(1<<digit),0,bound&(digit==maxdigit));\\n            }\\n            \\n        }\\n        return dp[pos][mask][leadingZeros][bound]=ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        this->s=to_string(n);\\n        this->m=s.size();\\n        int mask=(1<<10)-1;\\n        memset(dp,-1,sizeof dp);\\n        int ans=f(0,mask,1,1)-1;\\n        return n-ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545019,
                "title": "simplified-digit-dp",
                "content": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n// typedef unsigned long long ll;\\ntypedef long long ll;\\ntypedef pair<int, int> pi;\\n#define forn(i, n) for(int i = 0;i < n;i++)\\n#define forn2(i, s, e) for(int i = s;i < e;i++)\\n#define pb push_back\\ntypedef vector<int> vi;\\ntypedef vector<vector<int>> vvi;\\ntypedef vector<ll> vl;\\ntypedef pair<double, double> pd;\\ntypedef vector<vector<ll>> vvl;\\ntypedef vector<bool> vb;\\ntypedef vector<string> vs;\\ntypedef pair<int, pi>ppi;\\nint mod = 1e6 + 3;\\ntemplate<typename T>\\n \\n\\nvoid printvec(T& data){\\n    forn(i, data.size()){\\n        cout << data[i] << \" \";\\n    }\\n    cout << endl;\\n}\\n\\nint dp[10][2][(1 << 10) + 1][2][2];\\n\\nclass Solution {\\npublic:\\n    string s;\\n    int n;\\n    int solve(int pos, int tight, int mask, int repeated, int st){\\n        if(pos >= n) return repeated;\\n        if(dp[pos][tight][mask][repeated][st] != -1) return dp[pos][tight][mask][repeated][st];\\n        // int output = 0;\\n        int ub = tight == 1 ? s[pos] - \\'0\\' : 9;\\n        int output = 0;\\n        if(st == 0){     \\n            //you can avoid to start\\n            output = solve(pos+1, 0, mask, repeated, 0);\\n            \\n            //either you can start no\\n            forn2(i, 1, ub+1){\\n                //you cannot put a zero currently\\n                output += solve(pos+1, tight & (i == ub), mask | (1 << i), repeated, 1);\\n            }\\n        }\\n        else{\\n            //sequence is started\\n            forn(i, ub+1){\\n                bool occured = (mask & (1 << i));\\n                output += solve(pos+1, tight & (i == ub), mask | (1 << i), repeated || occured, st);\\n            }\\n        }\\n        return dp[pos][tight][mask][repeated][st] = output;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n_) {\\n        s = to_string(n_);\\n        n = s.size();\\n        memset(dp, -1, sizeof(dp));\\n        int output = solve(0, 1, 0, 0, 0);\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n// typedef unsigned long long ll;\\ntypedef long long ll;\\ntypedef pair<int, int> pi;\\n#define forn(i, n) for(int i = 0;i < n;i++)\\n#define forn2(i, s, e) for(int i = s;i < e;i++)\\n#define pb push_back\\ntypedef vector<int> vi;\\ntypedef vector<vector<int>> vvi;\\ntypedef vector<ll> vl;\\ntypedef pair<double, double> pd;\\ntypedef vector<vector<ll>> vvl;\\ntypedef vector<bool> vb;\\ntypedef vector<string> vs;\\ntypedef pair<int, pi>ppi;\\nint mod = 1e6 + 3;\\ntemplate<typename T>\\n \\n\\nvoid printvec(T& data){\\n    forn(i, data.size()){\\n        cout << data[i] << \" \";\\n    }\\n    cout << endl;\\n}\\n\\nint dp[10][2][(1 << 10) + 1][2][2];\\n\\nclass Solution {\\npublic:\\n    string s;\\n    int n;\\n    int solve(int pos, int tight, int mask, int repeated, int st){\\n        if(pos >= n) return repeated;\\n        if(dp[pos][tight][mask][repeated][st] != -1) return dp[pos][tight][mask][repeated][st];\\n        // int output = 0;\\n        int ub = tight == 1 ? s[pos] - \\'0\\' : 9;\\n        int output = 0;\\n        if(st == 0){     \\n            //you can avoid to start\\n            output = solve(pos+1, 0, mask, repeated, 0);\\n            \\n            //either you can start no\\n            forn2(i, 1, ub+1){\\n                //you cannot put a zero currently\\n                output += solve(pos+1, tight & (i == ub), mask | (1 << i), repeated, 1);\\n            }\\n        }\\n        else{\\n            //sequence is started\\n            forn(i, ub+1){\\n                bool occured = (mask & (1 << i));\\n                output += solve(pos+1, tight & (i == ub), mask | (1 << i), repeated || occured, st);\\n            }\\n        }\\n        return dp[pos][tight][mask][repeated][st] = output;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n_) {\\n        s = to_string(n_);\\n        n = s.size();\\n        memset(dp, -1, sizeof(dp));\\n        int output = solve(0, 1, 0, 0, 0);\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2516633,
                "title": "python-help-needed-to-optimise-this",
                "content": "Hi, \\n\\nI have come up with a solution to this problem in a partially optimsed way but I need some help with \\nthe counter logic. I understand the last part of my code is sub-optimal but looking for ideas/inspiration that can make this work. \\n\\nPS: It works fine but exceeds the time limit. \\n\\nAny comments/feedback are welcome and appriciated :)\\n\\nThanks.\\n\\nUpdate: Came up with another solution where I count the numbers with unique digits and subtract the count from n. Still exceding the time limit. \\n\\nWould appricate any help! Thank you :)\\n\\nSolution # 1:\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        \\n        if n < 11:\\n            return 0\\n        \\n        count = 0\\n        \\n        for i in range(11,n+1):\\n            ds = Counter()\\n            \\n            # count each digit of number and store in hashmap\\n            while i > 0:\\n                digit = i%10\\n                ds[digit] += 1\\n                i //=10\\n            \\n            \\n            #for each digit if val of digit >=2 they have atleast one repeating digit\\n            # This logic is wrong since it will increment count for every digit \\n            # will run into problems after 100\\n            # if i say any val in dict >=2 add 1 to internal counter \\n            # if there is value for an internal count add 1 to total count \\n            \\n            internal_count = 0\\n            for key, val in ds.items():\\n                if val >= 2:\\n                    internal_count += 1\\n            \\n            if internal_count:\\n                count += 1\\n        \\n        \\n        return count \\n\\n```\\n\\nSolution # 2:\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        \\n        # lets find out numbers with no repeated digits\\n        # I want to subtract the count of numbers with unique digits from n \\n        \\n        def repeated(num: int) -> int:\\n            \\n            seen = []\\n            \\n            while num > 0:\\n                digit = num%10\\n                if digit in seen:\\n                    return 0\\n                seen.append(digit)\\n                num //= 10\\n            \\n            return 1\\n                \\n        count = 0\\n        \\n        for i in range(1,n+1):\\n            \\n            count += repeated(i)\\n        \\n        return n-count\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        \\n        if n < 11:\\n            return 0\\n        \\n        count = 0\\n        \\n        for i in range(11,n+1):\\n            ds = Counter()\\n            \\n            # count each digit of number and store in hashmap\\n            while i > 0:\\n                digit = i%10\\n                ds[digit] += 1\\n                i //=10\\n            \\n            \\n            #for each digit if val of digit >=2 they have atleast one repeating digit\\n            # This logic is wrong since it will increment count for every digit \\n            # will run into problems after 100\\n            # if i say any val in dict >=2 add 1 to internal counter \\n            # if there is value for an internal count add 1 to total count \\n            \\n            internal_count = 0\\n            for key, val in ds.items():\\n                if val >= 2:\\n                    internal_count += 1\\n            \\n            if internal_count:\\n                count += 1\\n        \\n        \\n        return count \\n\\n```\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        \\n        # lets find out numbers with no repeated digits\\n        # I want to subtract the count of numbers with unique digits from n \\n        \\n        def repeated(num: int) -> int:\\n            \\n            seen = []\\n            \\n            while num > 0:\\n                digit = num%10\\n                if digit in seen:\\n                    return 0\\n                seen.append(digit)\\n                num //= 10\\n            \\n            return 1\\n                \\n        count = 0\\n        \\n        for i in range(1,n+1):\\n            \\n            count += repeated(i)\\n        \\n        return n-count\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506921,
                "title": "java-quick-solution-with-math",
                "content": "We can turn the problem into \"Numbers with no repeated digits\", which is much easier to find.\\n\\nLet us denote the number of integers with no repeated digits ranging from `a` to `b` as `N(a,b)`, where  **`a` is inclusive but `b` is not**. When we want to find `N(10, 100)`, we know that the tens can be `1,2,...,9`, and ones can be `0,1,...,9` but should be different from the tens. Hence, `N(10, 100)=9 * 9 =9 * P(9, 1)`.\\n\\nNow try `N(100, 1000)`, hundreds can be `1,2,...,9` (remember that top place cannot be 0), tens can be `0,1,...,9` but should be different from the hundreds, and ones can be `0,1,...,9` but should be different from both hundreds and tens. Therefore, `N(100,1000)=9*9*8=9*P(9,2)`.\\n\\nFollowing this rule we can deal with the problem. Take 3456 as example.\\n`N(0, 3456)=N(0,10)+N(10,100)+N(100,1000)+N(1000,3000)+N(3000, 3400)+N(3400,3450)+N(3450,3456)`.\\n\\n`N(0,10)`, `N(10,100)`, and `N(100,1000)` can be pre-calculated. Let\\'s focus on subsequent terms.\\nIt is easy to find `N(1000, 3000)=2*P(9,3)`, then `N(3000,3400)=3*8*7=3*P(8,2)`, where the first `3` indicates that hundreds can be `0,1,2,3`, but `3` has been taken so the number of remained options is 3; likewise, tens can be `0,1,2,4,...,9`, and one of them has been taken by hundreds.\\n\\nSee another example: `2220`. `N(2000, 2220)=N(2000, 2200)+N(2200,2220)`. We don\\'t have to calculate `N(2200, 2220)` because numbers in this range definitely have two `2`s, so the result must be 0.\\n\\n```java\\npublic int numDupDigitsAtMostN(int n) {\\n\\t// pre = [0, N(0,10), N(10,100), N(100, 1000), ...] \\n\\tint[] pre = {0, 0, 9, 252, 4464, 62784, 763920, 8455680, 88367040}, digits = new int[9];\\n\\tint ans = 0, len = 0, t = n;   // [len] is the number of digits\\n\\n\\tfor (; t > 0; t /= 10, len++) {\\n\\t\\tans += pre[len];\\n\\t\\tdigits[len] = t % 10;\\n\\t}\\n\\n\\tans += n - Math.pow(10, len - 1) + 1;\\n\\n\\t// operate digit by digit\\n\\tint[] map = new int[10];\\n\\tboolean alreadyRepeated = false;\\n\\tfor (int i = 0; i < len && !alreadyRepeated; i++) {\\n\\t\\tint digit = digits[len - i - 1], s = i == 0 ? 1 : 0, options = digit - s;\\n\\t\\tfor (int j = 0; j < digit; j++) if (map[j] > 0) options--;\\n\\t\\tif (i == len - 1 && map[digit] == 0) options++;\\n\\n\\t\\t// subtract the number of no-repeated-number integers\\n\\t\\tif (options > 0) ans -= options * P(10 - i - 1, len - i - 1);\\n\\n\\t\\t// put the digit into the map;\\n\\t\\tif (++map[digit] > 1) alreadyRepeated = true;\\n\\t}\\n\\n\\treturn ans;\\n}\\n\\n// P(n, r) = n * (n - 1) * ... * (n - r + 1)\\n// example: P(5, 2) = 5 * 4\\npublic int P(int n, int r) {\\n\\tint ans = 1;\\n\\tfor (int i = n; i > n - r; i--) ans *= i;\\n\\treturn ans;\\n}\\n```\\n\\nTime complexity: `O(len(n)^2)=O(1)`, where `len(n)` is the number of digits of `n`. Because `len(n) < 9`, and `9` is a constant, so the time complexity is `O(1)`.\\n\\n---\\n\\nSomebody may say using `pre` array is cheating. The following is the version without `pre` array.\\n```java\\npublic int numDupDigitsAtMostN(int n) {\\n\\tint[] digits = new int[9];\\n\\tint ans = n, len = 0, t = n;   // [len] is the number of digits\\n\\n\\tfor (; t > 0; t /= 10, len++) digits[len] = t % 10;\\n\\tfor (int i = 1; i < len; i++) ans -= 9 * P(9, len - i - 1) ;\\n\\n\\t// operate digit by digit\\n\\tint[] map = new int[10];\\n\\tfor (int i = 0; i < len; i++) {\\n\\t\\tint digit = digits[len - i - 1], s = i == 0 ? 1 : 0, options = digit - s;\\n\\t\\tfor (int j = 0; j < digit; j++) if (map[j] > 0) options--;\\n\\t\\tif (i == len - 1 && map[digit] == 0) options++;\\n\\n\\t\\t// subtract the number of no-repeated-number integers\\n\\t\\tif (options > 0) ans -= options * P(10 - i - 1, len - i - 1);\\n\\n\\t\\t// put the digit to the map;\\n\\t\\tif (++map[digit] > 1) break;\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int numDupDigitsAtMostN(int n) {\\n\\t// pre = [0, N(0,10), N(10,100), N(100, 1000), ...] \\n\\tint[] pre = {0, 0, 9, 252, 4464, 62784, 763920, 8455680, 88367040}, digits = new int[9];\\n\\tint ans = 0, len = 0, t = n;   // [len] is the number of digits\\n\\n\\tfor (; t > 0; t /= 10, len++) {\\n\\t\\tans += pre[len];\\n\\t\\tdigits[len] = t % 10;\\n\\t}\\n\\n\\tans += n - Math.pow(10, len - 1) + 1;\\n\\n\\t// operate digit by digit\\n\\tint[] map = new int[10];\\n\\tboolean alreadyRepeated = false;\\n\\tfor (int i = 0; i < len && !alreadyRepeated; i++) {\\n\\t\\tint digit = digits[len - i - 1], s = i == 0 ? 1 : 0, options = digit - s;\\n\\t\\tfor (int j = 0; j < digit; j++) if (map[j] > 0) options--;\\n\\t\\tif (i == len - 1 && map[digit] == 0) options++;\\n\\n\\t\\t// subtract the number of no-repeated-number integers\\n\\t\\tif (options > 0) ans -= options * P(10 - i - 1, len - i - 1);\\n\\n\\t\\t// put the digit into the map;\\n\\t\\tif (++map[digit] > 1) alreadyRepeated = true;\\n\\t}\\n\\n\\treturn ans;\\n}\\n\\n// P(n, r) = n * (n - 1) * ... * (n - r + 1)\\n// example: P(5, 2) = 5 * 4\\npublic int P(int n, int r) {\\n\\tint ans = 1;\\n\\tfor (int i = n; i > n - r; i--) ans *= i;\\n\\treturn ans;\\n}\\n```\n```java\\npublic int numDupDigitsAtMostN(int n) {\\n\\tint[] digits = new int[9];\\n\\tint ans = n, len = 0, t = n;   // [len] is the number of digits\\n\\n\\tfor (; t > 0; t /= 10, len++) digits[len] = t % 10;\\n\\tfor (int i = 1; i < len; i++) ans -= 9 * P(9, len - i - 1) ;\\n\\n\\t// operate digit by digit\\n\\tint[] map = new int[10];\\n\\tfor (int i = 0; i < len; i++) {\\n\\t\\tint digit = digits[len - i - 1], s = i == 0 ? 1 : 0, options = digit - s;\\n\\t\\tfor (int j = 0; j < digit; j++) if (map[j] > 0) options--;\\n\\t\\tif (i == len - 1 && map[digit] == 0) options++;\\n\\n\\t\\t// subtract the number of no-repeated-number integers\\n\\t\\tif (options > 0) ans -= options * P(10 - i - 1, len - i - 1);\\n\\n\\t\\t// put the digit to the map;\\n\\t\\tif (++map[digit] > 1) break;\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2452657,
                "title": "c-solution-with-digit-dp-and-bitmasking-just-one-line-code-change-in-2376-count-special-integer",
                "content": "```\\nclass Solution {\\n    \\n    // Exactly same as 2376. Count Special Intgers. just one line change at the end\\n    \\n    // max pos or digit in a number = 11\\n    // tight = either 1 or 0\\n    // mask = 1024\\n    // dp[pos][tight][mask]\\n    \\n    int dp[11][2][1024];\\n    \\n    int helper(string &str, int pos, int tight, int mask){\\n        // base case - if you reach at end digit of number\\n        if(pos == str.size()){\\n            return mask != 0;\\n        }\\n        \\n        // if already calculated then return its value from dp table\\n        if(dp[pos][tight][mask] != -1){\\n            return dp[pos][tight][mask];\\n        }\\n        \\n\\t\\t// \"ans\" will store the count of all integers having distinct digits \\n        int ans = 0;\\n        \\n        // if tight case\\n        if(tight == 1){\\n            \\n            // digit can take only value from 0 to str[pos]-\\'0\\', so loop over them\\n            for(int i=0; i<= str[pos]-\\'0\\'; i++){\\n                \\n                // if digit got repeated in same number, \\n\\t\\t\\t\\t// ex - 131, here 1 and 1 is got repeated,\\n                // so don\\'t consider it, simply continue\\n                if(mask & (1<<i)) continue;\\n                \\n                // create new mask for next position of digit in number\\n                int newMask = (mask == 0 && i == 0 ? mask : (mask | (1<<i)));\\n                \\n                // tight case for next digit also\\n                if(i == str[pos]-\\'0\\'){\\n                    ans = ans + helper(str, pos+1, 1, newMask);\\n                }\\n                // non-tight case for next digits\\n                else{\\n                    ans = ans + helper(str, pos+1, 0, newMask);\\n                }\\n            }\\n        }\\n        \\n        // non tight case for next positions of digits in number\\n        else{\\n            \\n            // digit can take any value from 0 to 9, so loop over them\\n            for(int i=0; i<=9; i++){\\n                \\n                // if digit got repeated in same number, \\n\\t\\t\\t\\t// ex - 131, here 1 and 1 is got repeated,\\n                // so don\\'t consider it, simply continue\\n                if(mask & (1<<i)) continue;\\n                \\n                 // create new mask for next position of digit in number\\n                int  newMask = (mask == 0 && i == 0 ? mask : (mask | (1<<i)));\\n                \\n                ans = ans + helper(str, pos+1, 0, newMask);\\n            }\\n        }\\n\\t\\t// store it into dp table and return\\n        return dp[pos][tight][mask] = ans;\\n    }\\n    \\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        string str = to_string(n);\\n        memset(dp, -1, sizeof(dp));\\n        int res = helper(str, 0, 1, 0);\\n        // at the end return total number minus numbers having distinct digits\\n\\t\\t// it will give all numbers having repeated digits\\n        return n - res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // Exactly same as 2376. Count Special Intgers. just one line change at the end\\n    \\n    // max pos or digit in a number = 11\\n    // tight = either 1 or 0\\n    // mask = 1024\\n    // dp[pos][tight][mask]\\n    \\n    int dp[11][2][1024];\\n    \\n    int helper(string &str, int pos, int tight, int mask){\\n        // base case - if you reach at end digit of number\\n        if(pos == str.size()){\\n            return mask != 0;\\n        }\\n        \\n        // if already calculated then return its value from dp table\\n        if(dp[pos][tight][mask] != -1){\\n            return dp[pos][tight][mask];\\n        }\\n        \\n\\t\\t// \"ans\" will store the count of all integers having distinct digits \\n        int ans = 0;\\n        \\n        // if tight case\\n        if(tight == 1){\\n            \\n            // digit can take only value from 0 to str[pos]-\\'0\\', so loop over them\\n            for(int i=0; i<= str[pos]-\\'0\\'; i++){\\n                \\n                // if digit got repeated in same number, \\n\\t\\t\\t\\t// ex - 131, here 1 and 1 is got repeated,\\n                // so don\\'t consider it, simply continue\\n                if(mask & (1<<i)) continue;\\n                \\n                // create new mask for next position of digit in number\\n                int newMask = (mask == 0 && i == 0 ? mask : (mask | (1<<i)));\\n                \\n                // tight case for next digit also\\n                if(i == str[pos]-\\'0\\'){\\n                    ans = ans + helper(str, pos+1, 1, newMask);\\n                }\\n                // non-tight case for next digits\\n                else{\\n                    ans = ans + helper(str, pos+1, 0, newMask);\\n                }\\n            }\\n        }\\n        \\n        // non tight case for next positions of digits in number\\n        else{\\n            \\n            // digit can take any value from 0 to 9, so loop over them\\n            for(int i=0; i<=9; i++){\\n                \\n                // if digit got repeated in same number, \\n\\t\\t\\t\\t// ex - 131, here 1 and 1 is got repeated,\\n                // so don\\'t consider it, simply continue\\n                if(mask & (1<<i)) continue;\\n                \\n                 // create new mask for next position of digit in number\\n                int  newMask = (mask == 0 && i == 0 ? mask : (mask | (1<<i)));\\n                \\n                ans = ans + helper(str, pos+1, 0, newMask);\\n            }\\n        }\\n\\t\\t// store it into dp table and return\\n        return dp[pos][tight][mask] = ans;\\n    }\\n    \\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        string str = to_string(n);\\n        memset(dp, -1, sizeof(dp));\\n        int res = helper(str, 0, 1, 0);\\n        // at the end return total number minus numbers having distinct digits\\n\\t\\t// it will give all numbers having repeated digits\\n        return n - res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448898,
                "title": "need-help-to-optimise-this-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    typedef long long ll;\\n    #define vi vector<int>\\n    #define REP(i,a,b) for(int i=a;i<b;i++)\\n    \\n    #define umap unordered_map\\n    \\n    ll recurr(string&R,int N,bool leading,bool tight,vi&vis,umap<string,ll>&dp){\\n        \\n        if(N==0)\\n            return 1;\\n        \\n        string key = to_string(N) + \\'#\\' + to_string(leading) + \\'#\\' + to_string(tight);\\n        \\n        for(auto ele:vis){\\n            key += to_string(ele) + \\'#\\';\\n        }\\n        \\n        if(dp.count(key)!=0)\\n            return dp[key];\\n        \\n        int ub = 9;\\n        if(tight)\\n            ub = R[ R.size()-N ]-\\'0\\';\\n        \\n        ll ans =0;\\n        int i;\\n        REP(i,0,ub+1){\\n            \\n            if(!leading)\\n            {\\n                if(i==0){\\n                    \\n                    ans += recurr(R,N-1,false,tight&&(i==ub),vis,dp);\\n                \\n                }\\n                else{\\n                    \\n                    vis[i] = R.size() - N +1;\\n                    \\n                    ans += recurr(R,N-1,true,tight&&(i==ub),vis,dp);\\n                    \\n                    vis[i]=-1;\\n                    \\n                    \\n                }\\n                \\n            }\\n            else{\\n                \\n                if(vis[i]==-1){\\n                    \\n                    vis[i] = R.size() - N +1;\\n                    ans += recurr(R,N-1,true,tight&&(i==ub),vis,dp);\\n                    vis[i] = -1;\\n                    \\n                }\\n                \\n                \\n                \\n            }\\n            \\n        }\\n        \\n        return dp[key] = ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        string R = to_string(n);\\n        vector<int>vis(11,-1);\\n        umap<string,ll>dp;\\n        return n - recurr(R,R.size(),false,true,vis,dp) +1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    typedef long long ll;\\n    #define vi vector<int>\\n    #define REP(i,a,b) for(int i=a;i<b;i++)\\n    \\n    #define umap unordered_map\\n    \\n    ll recurr(string&R,int N,bool leading,bool tight,vi&vis,umap<string,ll>&dp){\\n        \\n        if(N==0)\\n            return 1;\\n        \\n        string key = to_string(N) + \\'#\\' + to_string(leading) + \\'#\\' + to_string(tight);\\n        \\n        for(auto ele:vis){\\n            key += to_string(ele) + \\'#\\';\\n        }\\n        \\n        if(dp.count(key)!=0)\\n            return dp[key];\\n        \\n        int ub = 9;\\n        if(tight)\\n            ub = R[ R.size()-N ]-\\'0\\';\\n        \\n        ll ans =0;\\n        int i;\\n        REP(i,0,ub+1){\\n            \\n            if(!leading)\\n            {\\n                if(i==0){\\n                    \\n                    ans += recurr(R,N-1,false,tight&&(i==ub),vis,dp);\\n                \\n                }\\n                else{\\n                    \\n                    vis[i] = R.size() - N +1;\\n                    \\n                    ans += recurr(R,N-1,true,tight&&(i==ub),vis,dp);\\n                    \\n                    vis[i]=-1;\\n                    \\n                    \\n                }\\n                \\n            }\\n            else{\\n                \\n                if(vis[i]==-1){\\n                    \\n                    vis[i] = R.size() - N +1;\\n                    ans += recurr(R,N-1,true,tight&&(i==ub),vis,dp);\\n                    vis[i] = -1;\\n                    \\n                }\\n                \\n                \\n                \\n            }\\n            \\n        }\\n        \\n        return dp[key] = ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        string R = to_string(n);\\n        vector<int>vis(11,-1);\\n        umap<string,ll>dp;\\n        return n - recurr(R,R.size(),false,true,vis,dp) +1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433382,
                "title": "javascript-digit-dp",
                "content": "**Solution: Digit DP**\\n\\nMemoize each `dp(i, mask, state, hasRepeat)`, where\\n*   `i = the ith digit`\\n*   `mask = bitmask which indicates which digit we have already used`\\n*   `state = indicates whether the current number is tracking smaller, equal, or greater than n `\\n\\t*    `0 = smaller`\\n\\t*    `1 = equal`\\n\\t*    `2 = greater`  \\n\\n*  `hasRepeat = whether we have a repeated digit `\\n\\nIf `hasRepeat` is true (1), count it as 1 way.\\nFor each state, count the total number of ways after appending each digit (`0 - 9`).\\n\\n`state`:\\n*   If `digit < n[index]`, update state to `0` (smaller) if state is currently `1` (equal). \\n*   If `digit === n[index]`, keep state the same.\\n*   If `digit > n[index]`, update state to `2` (greater) if state is currently `1` (equal).\\n\\n`d = number of digits in n`\\nTime Complexity: `O(d * 2^10 * 3 * 2 * 10)` 488ms\\n  `d * 2^10 * 3 * 2` = the number of different states we can have\\n  `10` = at each state we have `10` options for digits `0-9`\\nSpace Complexity: `O(d * 2^10 * 3 * 2)` 62MB\\n```\\nvar numDupDigitsAtMostN = function(n) {\\n  let str = n.toString(), size = str.length, memo = new Map();\\n  return dp(0, 0, 1, 0);\\n  \\n  function dp(i, mask, state, hasRepeat) {\\n    if (i === size) return state < 2 && hasRepeat ? 1 : 0;\\n    let key = `${i},${mask},${state},${hasRepeat}`;\\n    if (memo.has(key)) return memo.get(key);\\n    \\n    let ans = hasRepeat;\\n    for (let digit = 0; digit <= 9; digit++) {\\n      if (i === 0 && digit === 0) continue;\\n      let newMask = mask | (1 << digit), repeat = hasRepeat || (mask === newMask ? 1 : 0);\\n      if (digit < Number(str[i])) {\\n        ans += dp(i + 1, newMask, state === 1 ? 0 : state, repeat);\\n      } else if (digit === Number(str[i])) {\\n        ans += dp(i + 1, newMask, state, repeat);\\n      } else {\\n        ans += dp(i + 1, newMask, state === 1 ? 2 : state, repeat);\\n      }\\n    }\\n    memo.set(key, ans);\\n    return ans;\\n  }  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numDupDigitsAtMostN = function(n) {\\n  let str = n.toString(), size = str.length, memo = new Map();\\n  return dp(0, 0, 1, 0);\\n  \\n  function dp(i, mask, state, hasRepeat) {\\n    if (i === size) return state < 2 && hasRepeat ? 1 : 0;\\n    let key = `${i},${mask},${state},${hasRepeat}`;\\n    if (memo.has(key)) return memo.get(key);\\n    \\n    let ans = hasRepeat;\\n    for (let digit = 0; digit <= 9; digit++) {\\n      if (i === 0 && digit === 0) continue;\\n      let newMask = mask | (1 << digit), repeat = hasRepeat || (mask === newMask ? 1 : 0);\\n      if (digit < Number(str[i])) {\\n        ans += dp(i + 1, newMask, state === 1 ? 0 : state, repeat);\\n      } else if (digit === Number(str[i])) {\\n        ans += dp(i + 1, newMask, state, repeat);\\n      } else {\\n        ans += dp(i + 1, newMask, state === 1 ? 2 : state, repeat);\\n      }\\n    }\\n    memo.set(key, ans);\\n    return ans;\\n  }  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2431077,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\n    private:\\n        int permutations(int n, int r){\\n            int ans = 1;\\n            for (int i=(n-r+1); i <= n; ++i){\\n                ans *= i;\\n            }\\n            return ans;\\n        }\\n        unordered_map<int, int> numberToCount(int number, int number_of_digits){\\n            unordered_map<int, int> count;\\n            for (int i=1; i<= number_of_digits; ++i){\\n                int digit = number % 10;\\n                ++count[digit];\\n                number = number / 10;\\n            }\\n            return count;\\n        }\\n        vector<int> uniqueChoices(unordered_map<int, int> & count, int digit, bool first){\\n            --count[digit];\\n            vector<int> ans;\\n            for (auto it=count.begin(); it!=count.end(); ++it){\\n                if (it->second>1){\\n                    return ans;\\n                }\\n            }\\n            for (int i=first; i < digit; ++i){\\n                if (count[i]==0){\\n                    ans.push_back(i);\\n                }\\n            }\\n            return ans;\\n        }\\n        bool isRepeated(unordered_map<int, int> & count){\\n            for (auto it=count.begin(); it!=count.end(); ++it){\\n                if (it->second>1){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        int number_of_digits = int(floor(log10(n))) + 1;\\n        long ans = 0;\\n        for (int i=1; i < number_of_digits; ++i){\\n            if (i<=10){\\n                // all possible choices - all unique choices\\n                ans += long(9 * pow(10, i-1) - 9 * permutations(9, i-1));                \\n            }else{\\n                // this condition is not going to happen\\n                ans += long(9 * pow(10, i-1));\\n            }\\n        }\\n        unordered_map<int, int> count =  numberToCount(n, number_of_digits);\\n\\n        // check the number itself\\n        if(isRepeated(count))\\n            ans += 1;\\n\\n        int number = n;\\n        // evaluate the possibilities\\n        // when we choose smaller numbers on all digits one by one\\n        for (int i=1; i<= number_of_digits; ++i){\\n            int digit = number % 10;\\n            vector<int> choices = uniqueChoices(count, digit, i==number_of_digits);\\n            int nb_choices;\\n            // the first digit from left to right\\n            if(i==number_of_digits) \\n                nb_choices = digit-1;\\n            else // other digits\\n                nb_choices = digit;\\n            // all possible choices - all unique choices\\n            ans += long(nb_choices * pow(10, i-1) - choices.size() * permutations(10-(number_of_digits-i+1),i-1));\\n            number = number / 10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n        int permutations(int n, int r){\\n            int ans = 1;\\n            for (int i=(n-r+1); i <= n; ++i){\\n                ans *= i;\\n            }\\n            return ans;\\n        }\\n        unordered_map<int, int> numberToCount(int number, int number_of_digits){\\n            unordered_map<int, int> count;\\n            for (int i=1; i<= number_of_digits; ++i){\\n                int digit = number % 10;\\n                ++count[digit];\\n                number = number / 10;\\n            }\\n            return count;\\n        }\\n        vector<int> uniqueChoices(unordered_map<int, int> & count, int digit, bool first){\\n            --count[digit];\\n            vector<int> ans;\\n            for (auto it=count.begin(); it!=count.end(); ++it){\\n                if (it->second>1){\\n                    return ans;\\n                }\\n            }\\n            for (int i=first; i < digit; ++i){\\n                if (count[i]==0){\\n                    ans.push_back(i);\\n                }\\n            }\\n            return ans;\\n        }\\n        bool isRepeated(unordered_map<int, int> & count){\\n            for (auto it=count.begin(); it!=count.end(); ++it){\\n                if (it->second>1){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        int number_of_digits = int(floor(log10(n))) + 1;\\n        long ans = 0;\\n        for (int i=1; i < number_of_digits; ++i){\\n            if (i<=10){\\n                // all possible choices - all unique choices\\n                ans += long(9 * pow(10, i-1) - 9 * permutations(9, i-1));                \\n            }else{\\n                // this condition is not going to happen\\n                ans += long(9 * pow(10, i-1));\\n            }\\n        }\\n        unordered_map<int, int> count =  numberToCount(n, number_of_digits);\\n\\n        // check the number itself\\n        if(isRepeated(count))\\n            ans += 1;\\n\\n        int number = n;\\n        // evaluate the possibilities\\n        // when we choose smaller numbers on all digits one by one\\n        for (int i=1; i<= number_of_digits; ++i){\\n            int digit = number % 10;\\n            vector<int> choices = uniqueChoices(count, digit, i==number_of_digits);\\n            int nb_choices;\\n            // the first digit from left to right\\n            if(i==number_of_digits) \\n                nb_choices = digit-1;\\n            else // other digits\\n                nb_choices = digit;\\n            // all possible choices - all unique choices\\n            ans += long(nb_choices * pow(10, i-1) - choices.size() * permutations(10-(number_of_digits-i+1),i-1));\\n            number = number / 10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430193,
                "title": "digit-dp-solution-c",
                "content": "```\\nclass Solution\\n{\\n\\n    int dp[11][2][2][1024];\\n\\n    int countNumbers(string &str, int pos = 0, int tight = 1, int repeated = 0, int mask = 0)\\n    {\\n        if (pos == str.length())\\n            return ((mask != 0) and (repeated != 0));\\n        \\n        \\n        if(dp[pos][tight][repeated][mask] != -1)\\n            return dp[pos][tight][repeated][mask];\\n      \\n        int count = 0;\\n        if (tight)\\n        {\\n            for (int digit = 0; digit <= str[pos] - \\'0\\'; digit++)\\n            {\\n                int newRepeated = repeated or (((mask == 0 and digit == 0) ? 0 : ((mask & (1 << digit)) != 0)));\\n                int newMask = ((mask == 0 and digit == 0) ? 0 : (mask | (1 << digit)));\\n\\n                if (digit == str[pos] - \\'0\\')\\n                    count += countNumbers(str, pos + 1, 1, newRepeated, newMask);\\n                else\\n                    count += countNumbers(str, pos + 1, 0, newRepeated, newMask);\\n            }\\n        }\\n        else\\n        {\\n            for (int digit = 0; digit <= 9; digit++)\\n            {\\n                int newRepeated = repeated or (((mask == 0 and digit == 0) ? 0 : ((mask & (1 << digit)) != 0)));\\n                int newMask = ((mask == 0 and digit == 0) ? 0 : (mask | (1 << digit)));\\n\\n                count += countNumbers(str, pos + 1, 0, newRepeated, newMask);\\n            }\\n        }\\n\\n        return dp[pos][tight][repeated][mask] = count;\\n    }\\n\\n    public:\\n        int numDupDigitsAtMostN(int n)\\n        {\\n            string str = to_string(n);\\n            memset(dp, -1, sizeof(dp));\\n            return countNumbers(str);\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n\\n    int dp[11][2][2][1024];\\n\\n    int countNumbers(string &str, int pos = 0, int tight = 1, int repeated = 0, int mask = 0)\\n    {\\n        if (pos == str.length())\\n            return ((mask != 0) and (repeated != 0));\\n        \\n        \\n        if(dp[pos][tight][repeated][mask] != -1)\\n            return dp[pos][tight][repeated][mask];\\n      \\n        int count = 0;\\n        if (tight)\\n        {\\n            for (int digit = 0; digit <= str[pos] - \\'0\\'; digit++)\\n            {\\n                int newRepeated = repeated or (((mask == 0 and digit == 0) ? 0 : ((mask & (1 << digit)) != 0)));\\n                int newMask = ((mask == 0 and digit == 0) ? 0 : (mask | (1 << digit)));\\n\\n                if (digit == str[pos] - \\'0\\')\\n                    count += countNumbers(str, pos + 1, 1, newRepeated, newMask);\\n                else\\n                    count += countNumbers(str, pos + 1, 0, newRepeated, newMask);\\n            }\\n        }\\n        else\\n        {\\n            for (int digit = 0; digit <= 9; digit++)\\n            {\\n                int newRepeated = repeated or (((mask == 0 and digit == 0) ? 0 : ((mask & (1 << digit)) != 0)));\\n                int newMask = ((mask == 0 and digit == 0) ? 0 : (mask | (1 << digit)));\\n\\n                count += countNumbers(str, pos + 1, 0, newRepeated, newMask);\\n            }\\n        }\\n\\n        return dp[pos][tight][repeated][mask] = count;\\n    }\\n\\n    public:\\n        int numDupDigitsAtMostN(int n)\\n        {\\n            string str = to_string(n);\\n            memset(dp, -1, sizeof(dp));\\n            return countNumbers(str);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425530,
                "title": "100-javascript-solution",
                "content": "```\\nconst permutation = (n,r) => {\\n    let nonRepeatingNumbers = 1;\\n    for(let i=0;i<r;i++){\\n        nonRepeatingNumbers *= n;\\n        n--;\\n    }\\n    return nonRepeatingNumbers;\\n}\\n\\nvar numDupDigitsAtMostN = function(n) {\\n    let count = 0;\\n    const numDigits = [];\\n    \\n    let temp = n+1;\\n    while(temp!==0){\\n        const num = temp%10;\\n        numDigits.unshift(num);\\n        temp = parseInt(temp/10);\\n    }\\n\\n    for(let i=0;i<numDigits.length-1;i++){\\n        count+=9*permutation(9,i);\\n    }\\n\\n    const mySet = new Set();\\n    for(let i=0;i<numDigits.length;i++){\\n        for(let j=i===0?1:0; j<numDigits[i];j++){\\n            if(mySet.has(j)) continue;\\n            count += permutation(10-(i+1),numDigits.length-(i+1)); \\n        }\\n        if(mySet.has(numDigits[i])) break;\\n        mySet.add(numDigits[i]);\\n\\n    }\\n    \\n    return n-count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nconst permutation = (n,r) => {\\n    let nonRepeatingNumbers = 1;\\n    for(let i=0;i<r;i++){\\n        nonRepeatingNumbers *= n;\\n        n--;\\n    }\\n    return nonRepeatingNumbers;\\n}\\n\\nvar numDupDigitsAtMostN = function(n) {\\n    let count = 0;\\n    const numDigits = [];\\n    \\n    let temp = n+1;\\n    while(temp!==0){\\n        const num = temp%10;\\n        numDigits.unshift(num);\\n        temp = parseInt(temp/10);\\n    }\\n\\n    for(let i=0;i<numDigits.length-1;i++){\\n        count+=9*permutation(9,i);\\n    }\\n\\n    const mySet = new Set();\\n    for(let i=0;i<numDigits.length;i++){\\n        for(let j=i===0?1:0; j<numDigits[i];j++){\\n            if(mySet.has(j)) continue;\\n            count += permutation(10-(i+1),numDigits.length-(i+1)); \\n        }\\n        if(mySet.has(numDigits[i])) break;\\n        mySet.add(numDigits[i]);\\n\\n    }\\n    \\n    return n-count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2423455,
                "title": "c-math-combinatorics",
                "content": "```\\nclass Solution {\\n    vector<int> getarray(int n) {\\n        vector<int> a;\\n        while(n != 0) {\\n            a.push_back(n%10);\\n            n /= 10;\\n        }\\n        reverse(a.rbegin(), a.rend());\\n        return a;\\n    }\\n    \\n    int npr(int n, int r) {\\n        int ans = 1;\\n        for(int i = 1; i <= n; i++)\\n            ans *= i;\\n        for(int i = 1; i <= n-r; i++)\\n            ans /= i;\\n        return ans;\\n    }\\n    \\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        if(n <= 10)\\n            return 0;\\n        \\n        vector<int> a = getarray(n);\\n        int len = a.size();\\n        \\n        // the approach is too count the numbers with distinct digit\\n\\n        // counting possibilities of 1 to len-1 digit number\\n        // 0-9, 10-99, 100-999, 1000-9999, ............        \\n        int ans = 0;\\n        for(int i = 1; i < len; i++) \\n            ans += 9 * npr(10-1, i-1);\\n            \\n        // for len digit number which are less than n\\n        vector<bool> used(10);\\n        for(int i = 0; i < len; i++) {\\n            for(int j = i==0?1:0; j < a[i]; j++) {\\n                if(used[j]) continue;\\n                ans += npr(10-i-1, len-i-1);\\n            }\\n            if(used[a[i]]) \\n                break;\\n            used[a[i]] = true;\\n        }\\n        \\n        vector<bool> dup(10);\\n        bool flag = false;\\n        for(int i = 0; i < len; i++) {\\n            if(dup[a[i]]) {\\n                flag = true;\\n                break;\\n            }\\n            dup[a[i]] = true;\\n        }\\n        \\n        if(!flag) ans += 1;\\n                \\n        return n - ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> getarray(int n) {\\n        vector<int> a;\\n        while(n != 0) {\\n            a.push_back(n%10);\\n            n /= 10;\\n        }\\n        reverse(a.rbegin(), a.rend());\\n        return a;\\n    }\\n    \\n    int npr(int n, int r) {\\n        int ans = 1;\\n        for(int i = 1; i <= n; i++)\\n            ans *= i;\\n        for(int i = 1; i <= n-r; i++)\\n            ans /= i;\\n        return ans;\\n    }\\n    \\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        if(n <= 10)\\n            return 0;\\n        \\n        vector<int> a = getarray(n);\\n        int len = a.size();\\n        \\n        // the approach is too count the numbers with distinct digit\\n\\n        // counting possibilities of 1 to len-1 digit number\\n        // 0-9, 10-99, 100-999, 1000-9999, ............        \\n        int ans = 0;\\n        for(int i = 1; i < len; i++) \\n            ans += 9 * npr(10-1, i-1);\\n            \\n        // for len digit number which are less than n\\n        vector<bool> used(10);\\n        for(int i = 0; i < len; i++) {\\n            for(int j = i==0?1:0; j < a[i]; j++) {\\n                if(used[j]) continue;\\n                ans += npr(10-i-1, len-i-1);\\n            }\\n            if(used[a[i]]) \\n                break;\\n            used[a[i]] = true;\\n        }\\n        \\n        vector<bool> dup(10);\\n        bool flag = false;\\n        for(int i = 0; i < len; i++) {\\n            if(dup[a[i]]) {\\n                flag = true;\\n                break;\\n            }\\n            dup[a[i]] = true;\\n        }\\n        \\n        if(!flag) ans += 1;\\n                \\n        return n - ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422782,
                "title": "javascript-dfs-bitmask-2833ms",
                "content": "```\\nconst numDupDigitsAtMostN = (N) => countNumberWithoutRepeatedDigit(N);\\n\\nlet res, n;\\nconst countNumberWithoutRepeatedDigit = (N) => {\\n    n = N;\\n    res = 0;\\n    dfs(0, 1023);\\n    return N - (res - 1);\\n};\\n\\nconst checkIthBit = (x, i) => x & (1 << i);\\n\\nconst dfs = (cur, rem) => {\\n    if (cur > n) return;\\n    res++;\\n    for (let i = cur == 0 ? 1 : 0; i < 10; i++) {\\n        if (checkIthBit(rem, i)) {\\n            dfs(cur * 10 + i, rem ^ (1 << i))\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nconst numDupDigitsAtMostN = (N) => countNumberWithoutRepeatedDigit(N);\\n\\nlet res, n;\\nconst countNumberWithoutRepeatedDigit = (N) => {\\n    n = N;\\n    res = 0;\\n    dfs(0, 1023);\\n    return N - (res - 1);\\n};\\n\\nconst checkIthBit = (x, i) => x & (1 << i);\\n\\nconst dfs = (cur, rem) => {\\n    if (cur > n) return;\\n    res++;\\n    for (let i = cur == 0 ? 1 : 0; i < 10; i++) {\\n        if (checkIthBit(rem, i)) {\\n            dfs(cur * 10 + i, rem ^ (1 << i))\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422690,
                "title": "c-simple-greedy-precomputation-approach-o-log10-n-tc-nearly-constant-tc",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        vector<ll> dp(10);\\n        ll g=n;\\n        for(int i=1;i<=9;i++)\\n        {\\n            int z=9;\\n            if(i==1)\\n            {\\n                dp[i]=9;\\n            }\\n            else \\n            {\\n                ll k=i;\\n                --k;\\n                dp[i]=9;\\n                while(k--)\\n                {\\n                    dp[i]*=(z);\\n                    z--;\\n                }\\n            }\\n        }\\n        ll z=log10(n)+1;\\n \\n        ll ans=0;\\n        \\n        for(ll i=1;i<=z-1;i++)\\n        {\\n            ans+=dp[i];\\n        }\\n        vector<ll> digit;\\n        while(n)\\n        {\\n            digit.push_back(n%10);\\n            n/=10;\\n        }\\n        reverse(digit.begin(),digit.end());\\n        set<ll> st;\\n        bool ok=true;\\n        int j;\\n        for(ll i=0;i<z-1;i++)\\n        {\\n            ll k=digit[i]-1;\\n            if(k==0&&i==0)\\n            {\\n                st.insert(1);\\n                continue;\\n            }\\n            ll zz=1;\\n\\n            ll mul=0;\\n            for(ll m=0;m<=k;m++)\\n            {\\n                if(st.find(m)==st.end())\\n                mul++;\\n            }\\n            if(i==0)\\n            {\\n                mul--;\\n            }\\n            ll c=10-i-1;\\n\\n            for(ll j=i+1;j<z;j++)\\n            {\\n                zz*=c;\\n                c--;\\n            }\\n            zz*=mul;\\n            ans+=zz;\\n            if(st.find(digit[i])!=st.end())\\n            {\\n                ok=false;\\n                j=i;\\n                break;\\n            }\\n            st.insert(digit[i]);\\n        }\\n        if(ok)\\n        {\\n            ll f=digit[z-1];\\n            ll c=0;\\n            for(ll i=0;i<=f;i++)\\n            {\\n                if(st.find(i)==st.end())\\n                c++;\\n            }\\n            ans+=c;\\n            \\n            if(z==1)\\n            { \\n                ans--;\\n            }\\n        }\\n        return g-ans;   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        vector<ll> dp(10);\\n        ll g=n;\\n        for(int i=1;i<=9;i++)\\n        {\\n            int z=9;\\n            if(i==1)\\n            {\\n                dp[i]=9;\\n            }\\n            else \\n            {\\n                ll k=i;\\n                --k;\\n                dp[i]=9;\\n                while(k--)\\n                {\\n                    dp[i]*=(z);\\n                    z--;\\n                }\\n            }\\n        }\\n        ll z=log10(n)+1;\\n \\n        ll ans=0;\\n        \\n        for(ll i=1;i<=z-1;i++)\\n        {\\n            ans+=dp[i];\\n        }\\n        vector<ll> digit;\\n        while(n)\\n        {\\n            digit.push_back(n%10);\\n            n/=10;\\n        }\\n        reverse(digit.begin(),digit.end());\\n        set<ll> st;\\n        bool ok=true;\\n        int j;\\n        for(ll i=0;i<z-1;i++)\\n        {\\n            ll k=digit[i]-1;\\n            if(k==0&&i==0)\\n            {\\n                st.insert(1);\\n                continue;\\n            }\\n            ll zz=1;\\n\\n            ll mul=0;\\n            for(ll m=0;m<=k;m++)\\n            {\\n                if(st.find(m)==st.end())\\n                mul++;\\n            }\\n            if(i==0)\\n            {\\n                mul--;\\n            }\\n            ll c=10-i-1;\\n\\n            for(ll j=i+1;j<z;j++)\\n            {\\n                zz*=c;\\n                c--;\\n            }\\n            zz*=mul;\\n            ans+=zz;\\n            if(st.find(digit[i])!=st.end())\\n            {\\n                ok=false;\\n                j=i;\\n                break;\\n            }\\n            st.insert(digit[i]);\\n        }\\n        if(ok)\\n        {\\n            ll f=digit[z-1];\\n            ll c=0;\\n            for(ll i=0;i<=f;i++)\\n            {\\n                if(st.find(i)==st.end())\\n                c++;\\n            }\\n            ans+=c;\\n            \\n            if(z==1)\\n            { \\n                ans--;\\n            }\\n        }\\n        return g-ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418330,
                "title": "need-help-converting-recursion-code-to-dp-code",
                "content": "Hello, could anyone please help me on how to identify DP states and memoize this solution ? Thanks.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int target;\\n    \\n    int solve(int cur, int mask, int num, int len)\\n    {\\n        if(num > target)\\n            return 0;\\n        if(cur==len){\\n            return 1;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<10;i++)\\n        {\\n            // for all 10 digits\\n            if(cur==0 && i==0)\\n                continue;\\n            if(mask & (1<<i))\\n                continue;\\n            ans+=solve(cur+1, mask | (1<<i), num*10+i, len);\\n        }\\n        return ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        int full_len=to_string(n).size();\\n        int uniq=0;\\n        target=n;\\n        for(int i=1;i<=full_len;i++)\\n        {\\n            int x=solve(0,0,0,i);\\n            uniq+=x;\\n        }\\n        return n-uniq;\\n    }\\n};\\n```\\n\\nI also tried out another recursive solution\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int target;\\n    unordered_map<int, unordered_map<int,int> >dp;\\n    int sum=0;\\n    int solve(string &num, int cur, int mask, int bound, int lz, int len)\\n    {\\n\\n        if(cur==len){\\n            return 1;\\n        }\\n\\n        int upper_bound=(bound)? num[cur]-\\'0\\': 9;\\n        \\n        int ans=0;\\n        for(int i=0;i<=upper_bound;i++)\\n        {\\n            if(i==0 && lz==1)\\n            {\\n                ans+=solve(num, cur+1, mask, 0, lz, len);\\n            }\\n            else if(!(mask & (1<<i)))\\n                ans+=solve(num, cur+1, mask | (1<<i), bound & (i==upper_bound), lz & (i==0), len);\\n        }\\n        return ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        string num=to_string(n);\\n        int full_len=num.size();\\n        int uniq=0;\\n        target=n;\\n        dp.clear();\\n        sum=solve(num, 0,0,1,1,full_len);    \\n        return n-sum+1;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int target;\\n    \\n    int solve(int cur, int mask, int num, int len)\\n    {\\n        if(num > target)\\n            return 0;\\n        if(cur==len){\\n            return 1;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<10;i++)\\n        {\\n            // for all 10 digits\\n            if(cur==0 && i==0)\\n                continue;\\n            if(mask & (1<<i))\\n                continue;\\n            ans+=solve(cur+1, mask | (1<<i), num*10+i, len);\\n        }\\n        return ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        int full_len=to_string(n).size();\\n        int uniq=0;\\n        target=n;\\n        for(int i=1;i<=full_len;i++)\\n        {\\n            int x=solve(0,0,0,i);\\n            uniq+=x;\\n        }\\n        return n-uniq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155741,
                "title": "digit-dp-with-bitmasking-c",
                "content": "\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\tlong long int dp[11][2][2][(1<<10)];\\n\\t\\tint f(int idx,bool flag,bool repeat,int mask,string &s){\\n\\n\\t\\t\\tif(idx==s.size()){\\n\\t\\t\\t\\treturn repeat;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(dp[idx][flag][repeat][mask]!=-1) return dp[idx][flag][repeat][mask];\\n\\n\\t\\t\\tint limit = s[idx]-\\'0\\';\\n\\t\\t\\tif(flag) limit = 9;\\n\\n\\t\\t\\tint ans=0;\\n\\n\\t\\t\\tfor(int digit=0;digit<=limit;digit++){\\n\\n\\n\\n\\t\\t\\t\\t if(digit < (s[idx]-\\'0\\')){\\n\\n\\t\\t\\t\\t\\t\\tif(digit==0 and mask==0){\\n\\t\\t\\t\\t\\t\\t\\t ans+=f(idx+1,true,false,mask,s);\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\telse if(mask&(1<<digit)){\\n\\t\\t\\t\\t\\t\\t\\tans+=f(idx+1,true,true,mask,s);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\tans+=f(idx+1,true,repeat,mask | (1<<digit),s);\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tif(digit==0 and mask==0){\\n\\t\\t\\t\\t\\t\\tans+=f(idx+1,flag,false,mask,s);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\telse if(mask&(1<<digit)){\\n\\t\\t\\t\\t\\t\\t\\tans+=f(idx+1,flag,true,mask,s);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\tans+=f(idx+1,flag,repeat,mask | (1<<digit),s);\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[idx][flag][repeat][mask]=ans;\\n\\t\\t}\\n\\t\\tint numDupDigitsAtMostN(int n) {\\n\\n\\t\\t\\tstring r = to_string(n);\\n\\t\\t\\tmemset(dp,-1,sizeof dp);\\n\\n\\n\\n\\t\\t\\treturn f(0,false,false,0,r);\\n\\t\\t}\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\tlong long int dp[11][2][2][(1<<10)];\\n\\t\\tint f(int idx,bool flag,bool repeat,int mask,string &s){\\n\\n\\t\\t\\tif(idx==s.size()){\\n\\t\\t\\t\\treturn repeat;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1962444,
                "title": "python-solution-with-explanation",
                "content": "We can count how many numbers that are smaller than` n` and have unique numbers in it. Then we do a subtraction to get non-unique number count.\\n\\n```\\ndef numDupDigitsAtMostN(self, n: int) -> int:\\n        n0 = n\\n        n_list = []\\n        while n0>0:\\n            n_list = [n0%10] + n_list\\n            n0 = n0//10\\n\\n        l = len(n_list)\\n        unique = 0\\n        used = set()\\n        x = n_list[0]\\n        # part 1, calculates how many unique numbers are of length l\\n        # part 1a, for the leftmost digit, it cannot be 0. \\n        # Example: 23456 -> x???? \\n        # x can be from x=1 to x=(2-1)=1 -> x can only be 1\\n        # ???? can be any unique number with possible numbers being 8, and it can start with 0\\n\\t\\t# multiply the available x and ???? we get the count of unique numbers which are smaller than 20000.\\n        ans = (n_list[0] - 1 - unique) * self.uniqueNumberStartingWith0(l-1, 9-1)\\n        used.add(n_list[0])\\n        \\n        # part 1b, for the rest digits, it can be any number smaller than the given one. We check each digit gradually. \\n        # Example: 23456 -> 2x???. How many unique numbers y are there which satisfies 20000<=y<23000?\\n        # x can be from x=0 to x=3 and deduct any used digits (here it\\'ll be 2) -> x can be 0 or 1\\n        # ?? can be any unique number with possible numbers being (9-length of (2)-1), and it can start with 0\\n\\t\\t# Example: 23456 -> 23x?? -> How many unique numbers y are there which satisfies 23000<=y<23400?\\n        # 0<=x<4 and deduct any used digits (here it\\'ll be 2 and 3) -> x can be 0 or 1 \\n        # ?? can be any unique number with possible numbers being (9-length of (23)-1), and it can start with 0\\n\\t\\t# Example: 23456 -> 234x? -> How many unique numbers y are there which satisfies 23400<=y<23450?\\n        # 0<=x<5 and deduct any used digits (here it\\'ll be 2, 3, and 4) -> x can be 0 or 1 \\n        # ? can be any unique number with possible numbers being (9-length of (234)-1), and it can start with 0\\n\\t\\t# Example: 23456 -> 2345x -> How many unique numbers y are there which satisfies 23450<=y<23456?\\n        # 0<=x<6 and deduct any used digits (here it\\'ll be 2, 3, and 4, 5) -> x can be 0 or 1 \\n        for i in range(1, l):\\n            x = n_list[i]\\n            unique = 0\\n            for j in used:\\n                if j<x:\\n                    unique += 1\\n            ans += max(x - unique, 0) * self.uniqueNumberStartingWith0(l-i-1, 9-i-1)\\n            if x in used:\\n                break\\n            used.add(x)\\n            \\n        # calculates how many unique numbers are of length 1 , ..., to (l-1)\\n        for i in range(1,l):\\n            ans += self.uniqueNumberNotStartingWith0(i, 9)\\n        \\n        # if the number itself is unique, then subtract it from the total; otherwise, do not subtract\\n        return n-self.isUnique(n_list)-ans \\n        \\n    def isUnique(self, n: list[int]) -> int:\\n        # this function determines if a number itself is unique\\n        used = set()\\n        for i in n:\\n            if i in used:\\n                return 0\\n            else:\\n                used.add(i)\\n        return 1\\n        \\n    def uniqueNumberNotStartingWith0(self, digit: int, possible_digit: int) -> int:\\n        # this function calculates how many unique numbers are there which does not start from 0, given the length of number being digit, and the possible_digit representing how many digits can be used here\\n        ans = 1\\n        step = 0\\n        while digit>0:\\n            ans *= possible_digit\\n            if step==0:\\n                pass\\n            else:\\n                possible_digit -= 1\\n            digit -= 1\\n            step += 1\\n        return ans\\n        \\n    def uniqueNumberStartingWith0(self, digit: int, possible_digit: int) -> int:\\n        # this function calculates how many unique numbers are there which does can start from 0\\n        ans = 1\\n        while digit>0:\\n            ans *= possible_digit+1\\n            possible_digit -= 1\\n            digit -= 1\\n        return ans```",
                "solutionTags": [],
                "code": "```\\ndef numDupDigitsAtMostN(self, n: int) -> int:\\n        n0 = n\\n        n_list = []\\n        while n0>0:\\n            n_list = [n0%10] + n_list\\n            n0 = n0//10\\n\\n        l = len(n_list)\\n        unique = 0\\n        used = set()\\n        x = n_list[0]\\n        # part 1, calculates how many unique numbers are of length l\\n        # part 1a, for the leftmost digit, it cannot be 0. \\n        # Example: 23456 -> x???? \\n        # x can be from x=1 to x=(2-1)=1 -> x can only be 1\\n        # ???? can be any unique number with possible numbers being 8, and it can start with 0\\n\\t\\t# multiply the available x and ???? we get the count of unique numbers which are smaller than 20000.\\n        ans = (n_list[0] - 1 - unique) * self.uniqueNumberStartingWith0(l-1, 9-1)\\n        used.add(n_list[0])\\n        \\n        # part 1b, for the rest digits, it can be any number smaller than the given one. We check each digit gradually. \\n        # Example: 23456 -> 2x???. How many unique numbers y are there which satisfies 20000<=y<23000?\\n        # x can be from x=0 to x=3 and deduct any used digits (here it\\'ll be 2) -> x can be 0 or 1\\n        # ?? can be any unique number with possible numbers being (9-length of (2)-1), and it can start with 0\\n\\t\\t# Example: 23456 -> 23x?? -> How many unique numbers y are there which satisfies 23000<=y<23400?\\n        # 0<=x<4 and deduct any used digits (here it\\'ll be 2 and 3) -> x can be 0 or 1 \\n        # ?? can be any unique number with possible numbers being (9-length of (23)-1), and it can start with 0\\n\\t\\t# Example: 23456 -> 234x? -> How many unique numbers y are there which satisfies 23400<=y<23450?\\n        # 0<=x<5 and deduct any used digits (here it\\'ll be 2, 3, and 4) -> x can be 0 or 1 \\n        # ? can be any unique number with possible numbers being (9-length of (234)-1), and it can start with 0\\n\\t\\t# Example: 23456 -> 2345x -> How many unique numbers y are there which satisfies 23450<=y<23456?\\n        # 0<=x<6 and deduct any used digits (here it\\'ll be 2, 3, and 4, 5) -> x can be 0 or 1 \\n        for i in range(1, l):\\n            x = n_list[i]\\n            unique = 0\\n            for j in used:\\n                if j<x:\\n                    unique += 1\\n            ans += max(x - unique, 0) * self.uniqueNumberStartingWith0(l-i-1, 9-i-1)\\n            if x in used:\\n                break\\n            used.add(x)\\n            \\n        # calculates how many unique numbers are of length 1 , ..., to (l-1)\\n        for i in range(1,l):\\n            ans += self.uniqueNumberNotStartingWith0(i, 9)\\n        \\n        # if the number itself is unique, then subtract it from the total; otherwise, do not subtract\\n        return n-self.isUnique(n_list)-ans \\n        \\n    def isUnique(self, n: list[int]) -> int:\\n        # this function determines if a number itself is unique\\n        used = set()\\n        for i in n:\\n            if i in used:\\n                return 0\\n            else:\\n                used.add(i)\\n        return 1\\n        \\n    def uniqueNumberNotStartingWith0(self, digit: int, possible_digit: int) -> int:\\n        # this function calculates how many unique numbers are there which does not start from 0, given the length of number being digit, and the possible_digit representing how many digits can be used here\\n        ans = 1\\n        step = 0\\n        while digit>0:\\n            ans *= possible_digit\\n            if step==0:\\n                pass\\n            else:\\n                possible_digit -= 1\\n            digit -= 1\\n            step += 1\\n        return ans\\n        \\n    def uniqueNumberStartingWith0(self, digit: int, possible_digit: int) -> int:\\n        # this function calculates how many unique numbers are there which does can start from 0\\n        ans = 1\\n        while digit>0:\\n            ans *= possible_digit+1\\n            possible_digit -= 1\\n            digit -= 1\\n        return ans```",
                "codeTag": "Python3"
            },
            {
                "id": 1880228,
                "title": "digit-dp-bitsmask-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[12][2][2][1<<11];\\n    int solve(string s,int n,int tight,int st,long long m)\\n    {\\n        if(n==0 && !st)\\n            return 0;\\n        if(n==0)\\n            return 1;\\n        if(dp[n][tight][st][m]!=-1)return dp[n][tight][st][m];\\n        int ans=0;\\n        int ub=tight ? s[s.length()-n]-\\'0\\' : 9;\\n        \\n        for(int i=0;i<=ub;i++)\\n        {\\n            if(!st)\\n            {\\n                if(i==0)\\n                    ans+=solve(s,n-1,(tight&(i==ub)),st,m);\\n                else\\n                {\\n                    // m=m|(1<<i);\\n                    ans+=solve(s,n-1,(tight&(i==ub)),1,m | (1<<i));\\n                    // m=m&(~(1<<i));\\n                }\\n                \\n            }\\n            else\\n            {\\n                if(!(m&(1<<i)))\\n                {\\n                    // m=m|(1<<i);\\n                    ans+=solve(s,n-1,(tight&(i==ub)),st,m | (1<<i));\\n                    // m=m&(~(1<<i));\\n                }\\n            }\\n            \\n            \\n        }\\n        return dp[n][tight][st][m]=ans;\\n        return ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        long long m=0;\\n        \\n        string s=to_string(n);\\n        memset(dp,-1,sizeof dp);\\n        return n-solve(s,s.length(),1,0,m);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[12][2][2][1<<11];\\n    int solve(string s,int n,int tight,int st,long long m)\\n    {\\n        if(n==0 && !st)\\n            return 0;\\n        if(n==0)\\n            return 1;\\n        if(dp[n][tight][st][m]!=-1)return dp[n][tight][st][m];\\n        int ans=0;\\n        int ub=tight ? s[s.length()-n]-\\'0\\' : 9;\\n        \\n        for(int i=0;i<=ub;i++)\\n        {\\n            if(!st)\\n            {\\n                if(i==0)\\n                    ans+=solve(s,n-1,(tight&(i==ub)),st,m);\\n                else\\n                {\\n                    // m=m|(1<<i);\\n                    ans+=solve(s,n-1,(tight&(i==ub)),1,m | (1<<i));\\n                    // m=m&(~(1<<i));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1817215,
                "title": "c-2d-digit-dp",
                "content": "We are just treating numbers with restriction specially.\\n```\\nclass Solution {\\n    vector<vector<int>> dp;\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        dp = vector(10,vector(1024,-1));\\n        int last = 0;\\n        string s = to_string(n);\\n        int len = s.size();\\n        bool flag = false; // if edge number are satisfy the condition\\n        int result=0;\\n        bool valid=false; // no leading zero for numbers with restriction.\\n        for(int i=0;i<len;++i)\\n        {\\n            int limit = s[i]-\\'0\\';\\n            for(int j=0;j<limit;++j)\\n            {\\n                int tvalid = valid || j >0;\\n                if((tvalid && isSet(last,j)) || flag)\\n                {\\n                    int dLeft = s.size()-i -1;\\n                    result += pow(10,dLeft);\\n                }\\n                else if(tvalid)\\n                {\\n                    int mask = setBit(last,j);\\n                    result+=digit_dp(s,i+1,mask,tvalid);\\n                }\\n                else\\n                    result+=digit_dp(s,i+1,0,tvalid);\\n            }\\n            if(isSet(last,limit))\\n                flag = true;\\n            valid = true;\\n            last = setBit(last,limit);\\n        }\\n        return result+flag;\\n    }\\n    int digit_dp(string s,int pos,int last,bool valid) // valid = valid number not starting with zero\\n    {\\n        if(pos==s.size())\\n            return 0;\\n        if(dp[pos][last]!=-1)\\n            return dp[pos][last];\\n        int sum=0;\\n        for(int i=0;i<10;++i)\\n        {\\n            int tvalid = valid || i>0;\\n            if(tvalid && isSet(last,i)) // satisfy the condition, calculate count\\n            {\\n                int dLeft = s.size()-pos -1;\\n                sum += pow(10,dLeft);\\n            }\\n            else if(tvalid)\\n            {\\n                int mask = setBit(last,i);\\n                sum+=digit_dp(s,pos+1,mask,tvalid);\\n            }\\n            else // not a valid number till now\\n                 sum+=digit_dp(s,pos+1,0,tvalid);\\n        }\\n        return dp[pos][last] = sum;\\n    }\\n    bool isSet(int number, int bit)\\n    {\\n        return number & (1<<bit);\\n    }\\n    int setBit(int number, int bit)\\n    {\\n        return number | (1<<bit);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> dp;\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        dp = vector(10,vector(1024,-1));\\n        int last = 0;\\n        string s = to_string(n);\\n        int len = s.size();\\n        bool flag = false; // if edge number are satisfy the condition\\n        int result=0;\\n        bool valid=false; // no leading zero for numbers with restriction.\\n        for(int i=0;i<len;++i)\\n        {\\n            int limit = s[i]-\\'0\\';\\n            for(int j=0;j<limit;++j)\\n            {\\n                int tvalid = valid || j >0;\\n                if((tvalid && isSet(last,j)) || flag)\\n                {\\n                    int dLeft = s.size()-i -1;\\n                    result += pow(10,dLeft);\\n                }\\n                else if(tvalid)\\n                {\\n                    int mask = setBit(last,j);\\n                    result+=digit_dp(s,i+1,mask,tvalid);\\n                }\\n                else\\n                    result+=digit_dp(s,i+1,0,tvalid);\\n            }\\n            if(isSet(last,limit))\\n                flag = true;\\n            valid = true;\\n            last = setBit(last,limit);\\n        }\\n        return result+flag;\\n    }\\n    int digit_dp(string s,int pos,int last,bool valid) // valid = valid number not starting with zero\\n    {\\n        if(pos==s.size())\\n            return 0;\\n        if(dp[pos][last]!=-1)\\n            return dp[pos][last];\\n        int sum=0;\\n        for(int i=0;i<10;++i)\\n        {\\n            int tvalid = valid || i>0;\\n            if(tvalid && isSet(last,i)) // satisfy the condition, calculate count\\n            {\\n                int dLeft = s.size()-pos -1;\\n                sum += pow(10,dLeft);\\n            }\\n            else if(tvalid)\\n            {\\n                int mask = setBit(last,i);\\n                sum+=digit_dp(s,pos+1,mask,tvalid);\\n            }\\n            else // not a valid number till now\\n                 sum+=digit_dp(s,pos+1,0,tvalid);\\n        }\\n        return dp[pos][last] = sum;\\n    }\\n    bool isSet(int number, int bit)\\n    {\\n        return number & (1<<bit);\\n    }\\n    int setBit(int number, int bit)\\n    {\\n        return number | (1<<bit);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741000,
                "title": "c-top-down-bitmask-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int DP[10][1 << 10][2][2];\\n\\n    int solve(const int idx, const int bm, const bool val, const bool onBorder, const bool doubleDigits, const string& S) {\\n        if (idx == int(S.length()))\\n            return doubleDigits;\\n        if (!onBorder && DP[idx][bm][val][doubleDigits] != -1)\\n            return DP[idx][bm][val][doubleDigits];\\n        int tot = 0;\\n        int until = onBorder ? (S[idx] - \\'0\\') : 9;\\n        for (int i = 0; i <= until; i++) {\\n            int nxtBm = bm;\\n            if (val || i > 0)\\n                nxtBm |= (1 << i);\\n            tot += solve(idx + 1, nxtBm, val || (i > 0), onBorder && i == until, doubleDigits || (bm & (1 << i)), S);\\n        }\\n        if (!onBorder)\\n            return DP[idx][bm][val][doubleDigits] = tot;\\n        return tot;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        memset(DP, -1, sizeof(DP));\\n        return solve(0, 0, 0, 1, 0, to_string(n));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int DP[10][1 << 10][2][2];\\n\\n    int solve(const int idx, const int bm, const bool val, const bool onBorder, const bool doubleDigits, const string& S) {\\n        if (idx == int(S.length()))\\n            return doubleDigits;\\n        if (!onBorder && DP[idx][bm][val][doubleDigits] != -1)\\n            return DP[idx][bm][val][doubleDigits];\\n        int tot = 0;\\n        int until = onBorder ? (S[idx] - \\'0\\') : 9;\\n        for (int i = 0; i <= until; i++) {\\n            int nxtBm = bm;\\n            if (val || i > 0)\\n                nxtBm |= (1 << i);\\n            tot += solve(idx + 1, nxtBm, val || (i > 0), onBorder && i == until, doubleDigits || (bm & (1 << i)), S);\\n        }\\n        if (!onBorder)\\n            return DP[idx][bm][val][doubleDigits] = tot;\\n        return tot;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        memset(DP, -1, sizeof(DP));\\n        return solve(0, 0, 0, 1, 0, to_string(n));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658861,
                "title": "c-math-based-solution-with-o-len-digits-n-time-and-o-1-space",
                "content": "When dealing with combinatorials, if you are looking for the number of possibilities with at least 1 of something (in this case, repeats), it can sometimes be easier to find the opposite (where there are no repeats) and then subtract that from the total number of possibilities.\\n\\n```\\n// Uncomment to increase debuggability (which increases run time)\\n//#define DEBUG\\n\\n#ifdef DEBUG\\n# define PRINT  printf\\n# define ASSERT assert\\n#else\\n# define PRINT\\n# define ASSERT\\n#endif\\n\\nstatic inline int numberOfDigits(int n)\\n{\\n    int count = 0;\\n    \\n    while(n > 0) {\\n        n /= 10;\\n        count++;\\n    }\\n    \\n    return count;\\n}\\n\\nint numDupDigitsAtMostN(int n){\\n    const int origN = n;\\n    const int origNumDigits = numberOfDigits(n);\\n    \\n    bool highUsed[10] = { false };\\n    // Count of numbers with NO repeated digits\\n    int count = 0;\\n    int multiple = 1;\\n    \\n    for (int i = 1; i < origNumDigits; i++) {\\n        multiple *= 10;\\n    }\\n    const int origMultiple = multiple;\\n    \\n    // test number = [1..(highDigit-1)]...\\n    if ((n / multiple) > 1) {\\n        int add = (n / multiple) - 1; // All digits below highDigit except 0\\n        for (int numUsed = 1; numUsed < origNumDigits; numUsed++) {\\n\\t\\t    // 10 is for all digits 0 to 9\\n\\t\\t\\t// numUsed is the number of those digits already used to generate the test number\\n            add *= 10 - numUsed;\\n        }\\n        count += add;\\n    }\\n    \\n    PRINT(\"1: %d\\\\n\", count);\\n    \\n    // test number = [prevHighDigit]...[highDigit][0..(nextHighDigit-1)]...\\n    for (int numDigits = origNumDigits; numDigits > 0; numDigits--) {\\n        const int highDigit = n / multiple;\\n        const int highN = highDigit * multiple;\\n        \\n        // Prepare for next loop\\n        n -= highN;\\n        multiple /= 10;\\n    \\n        if (highUsed[highDigit] == true) {\\n\\t\\t    // If our highDigit was already used before, then all non-repeating solutions were counted\\n\\t\\t\\t// in previous loop iterations already\\n            break;\\n        } else if (numDigits == 1) {\\n\\t\\t    // The last digit in the number allows us to not repeat using all highDigits, so add one\\n            count++;\\n        } else {\\n            const int nextHighDigit = n / multiple;\\n            int numOptions = 0;\\n            int numUsed = 0;\\n                \\n            highUsed[highDigit] = true;\\n\\n            for (int i = 0; i < 10; i++) {\\n                if (highUsed[i] == false) {\\n                    if (i < nextHighDigit) {\\n                        numOptions++;\\n                    }\\n                } else {\\n                    numUsed++;\\n                }\\n            }\\n            if (numOptions > 0) {\\n                int add = numOptions;\\n\\n                numUsed++;\\n                for (; numUsed < origNumDigits; numUsed++) {\\n                    add *= 10 - numUsed;\\n                }\\n                count += add;\\n            }\\n        }\\n\\n        PRINT(\"2: %d\\\\n\", count);\\n    }\\n    \\n    n = origN;\\n    multiple = origMultiple;\\n    \\n    // test number = 0...0[1..9]...\\n    for (int numDigits = origNumDigits; numDigits > 0; numDigits--) {\\n        const int highDigit = n / multiple;\\n        const int highN = highDigit * multiple;\\n                \\n        if (numDigits > 1) {\\n            int add = 9; // All digits except 0\\n            for (int numUsed = 1; numUsed < (numDigits - 1); numUsed++) {\\n                add *= 10 - numUsed;\\n            }\\n            count += add;\\n        }\\n        \\n        PRINT(\"3: %d\\\\n\", count);\\n        \\n        // Prepare for next loop\\n        n -= highN;\\n        multiple /= 10;\\n    }\\n    \\n    PRINT(\"%d vs %d\\\\n\", origN, count);\\n    ASSERT(origN >= count);\\n    return (origN - count);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Uncomment to increase debuggability (which increases run time)\\n//#define DEBUG\\n\\n#ifdef DEBUG\\n# define PRINT  printf\\n# define ASSERT assert\\n#else\\n# define PRINT\\n# define ASSERT\\n#endif\\n\\nstatic inline int numberOfDigits(int n)\\n{\\n    int count = 0;\\n    \\n    while(n > 0) {\\n        n /= 10;\\n        count++;\\n    }\\n    \\n    return count;\\n}\\n\\nint numDupDigitsAtMostN(int n){\\n    const int origN = n;\\n    const int origNumDigits = numberOfDigits(n);\\n    \\n    bool highUsed[10] = { false };\\n    // Count of numbers with NO repeated digits\\n    int count = 0;\\n    int multiple = 1;\\n    \\n    for (int i = 1; i < origNumDigits; i++) {\\n        multiple *= 10;\\n    }\\n    const int origMultiple = multiple;\\n    \\n    // test number = [1..(highDigit-1)]...\\n    if ((n / multiple) > 1) {\\n        int add = (n / multiple) - 1; // All digits below highDigit except 0\\n        for (int numUsed = 1; numUsed < origNumDigits; numUsed++) {\\n\\t\\t    // 10 is for all digits 0 to 9\\n\\t\\t\\t// numUsed is the number of those digits already used to generate the test number\\n            add *= 10 - numUsed;\\n        }\\n        count += add;\\n    }\\n    \\n    PRINT(\"1: %d\\\\n\", count);\\n    \\n    // test number = [prevHighDigit]...[highDigit][0..(nextHighDigit-1)]...\\n    for (int numDigits = origNumDigits; numDigits > 0; numDigits--) {\\n        const int highDigit = n / multiple;\\n        const int highN = highDigit * multiple;\\n        \\n        // Prepare for next loop\\n        n -= highN;\\n        multiple /= 10;\\n    \\n        if (highUsed[highDigit] == true) {\\n\\t\\t    // If our highDigit was already used before, then all non-repeating solutions were counted\\n\\t\\t\\t// in previous loop iterations already\\n            break;\\n        } else if (numDigits == 1) {\\n\\t\\t    // The last digit in the number allows us to not repeat using all highDigits, so add one\\n            count++;\\n        } else {\\n            const int nextHighDigit = n / multiple;\\n            int numOptions = 0;\\n            int numUsed = 0;\\n                \\n            highUsed[highDigit] = true;\\n\\n            for (int i = 0; i < 10; i++) {\\n                if (highUsed[i] == false) {\\n                    if (i < nextHighDigit) {\\n                        numOptions++;\\n                    }\\n                } else {\\n                    numUsed++;\\n                }\\n            }\\n            if (numOptions > 0) {\\n                int add = numOptions;\\n\\n                numUsed++;\\n                for (; numUsed < origNumDigits; numUsed++) {\\n                    add *= 10 - numUsed;\\n                }\\n                count += add;\\n            }\\n        }\\n\\n        PRINT(\"2: %d\\\\n\", count);\\n    }\\n    \\n    n = origN;\\n    multiple = origMultiple;\\n    \\n    // test number = 0...0[1..9]...\\n    for (int numDigits = origNumDigits; numDigits > 0; numDigits--) {\\n        const int highDigit = n / multiple;\\n        const int highN = highDigit * multiple;\\n                \\n        if (numDigits > 1) {\\n            int add = 9; // All digits except 0\\n            for (int numUsed = 1; numUsed < (numDigits - 1); numUsed++) {\\n                add *= 10 - numUsed;\\n            }\\n            count += add;\\n        }\\n        \\n        PRINT(\"3: %d\\\\n\", count);\\n        \\n        // Prepare for next loop\\n        n -= highN;\\n        multiple /= 10;\\n    }\\n    \\n    PRINT(\"%d vs %d\\\\n\", origN, count);\\n    ASSERT(origN >= count);\\n    return (origN - count);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1601626,
                "title": "help",
                "content": "class Solution(object):\\n    def numDupDigitsAtMostN(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        def check(n):\\n            if len(set(str(n))) == len(str(n)):\\n                return 0 \\n            else:\\n                return 1\\n        Count=0\\n        list_nums=[];\\n        for N in range(n+1):\\n            Count+=check(N)\\n        \\n    \\n            \\n        return Count\\n\\t\\t\\n\\t\\tSo this works, but for really big numbers it is slow and the time limit is exceeeded. Anyone has a fix for my code ?\\n\\t\\tcheers",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def numDupDigitsAtMostN(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        def check(n):\\n            if len(set(str(n))) == len(str(n)):\\n                return 0 \\n            else:\\n                return 1\\n        Count=0\\n        list_nums=[];\\n        for N in range(n+1):\\n            Count+=check(N)\\n        \\n    \\n            \\n        return Count\\n\\t\\t\\n\\t\\tSo this works, but for really big numbers it is slow and the time limit is exceeeded. Anyone has a fix for my code ?\\n\\t\\tcheers",
                "codeTag": "Java"
            },
            {
                "id": 1544355,
                "title": "c-solution-0ms-o-lgn-with-explanation",
                "content": "We can simply count the number of numbers with repeated digits.\\n\\nConsider numbers within range of [*a* *10^(*x* + 1),  *a* *10^(*x* + 1)+10^*x* - 1], the number of numbers without repeated digits is A_{10}^*x*. However, in the case where there are preceding 0s (for example, 120 might actually be 0120), the preceding 0s will not count as repeating digits. Therefore, the number must be specially counted when *a=0*. \\nLet *f(i)* be the count of repeating numbers in a range [*a* * 10^(i+1), *a* * 10^(i+1) + 10^i - 1] where *a>0*. Let *g(i)* be the count of numbers in [0, 10^i - 1]. Then we can solve *f(i), g(i)* with *g(i)* = *g(i-1) +9 * f(i-1)* and *f(i) = 10^i - A_9^i*. \\n\\nTake a random number 42430 for example. We first count the repeating numbers in [1, 10000], which is *g(4)*. Then in [10001, 40000], which is 3 * *f(4)*.\\nNext, count the repeating numbers in [40001, 42000]. Note that because 4 is already used, every thousand has only A_8^3 non-repeating numbers, and the count of non-repeating number is 2 * (1000 - A_8^3).\\nThen, count range [42001, 42400]. Because 2 is less than 3, all numbers 422xx will have repeated digits. The total count will be 3 * (100 - A_7^2) + 100. Notice that 4 is repeated now, every number since will have repeated digits.\\n\\n```\\nclass Solution {\\npublic:\\n    int comb[9][9];\\n    int numDupDigitsAtMostN(int n) {\\n        if (n <= 10) return 0;\\n        int f[8], g[9], power[8];\\n        // f: 1, 28, 496...\\n        // g: 0, 10, 262, ...\\n        // power: 10, 100, 1000, ...\\n        int product = 1;\\n        int total = 1;\\n        for (int i = 0; i < 8; i++)\\n        {\\n            product *= 9 - i;\\n            total *= 10;\\n            power[i] = total;\\n            f[i] = total - product;\\n        }\\n        g[0] = 1;\\n        for (int i = 1; i < 9; i++) \\n            g[i] = 9 * f[i - 1] + g[i - 1];\\n        g[0] = 0;\\n        if (n == 1000000000) return g[8];\\n        int ans = 0;\\n        vector<int> digits;\\n        for (int i = 7; i >= 0; i--)\\n        {\\n            if (n == power[i]) return g[i];\\n            if (n < power[i]) continue;\\n            ans += g[i];\\n\\n            bool has[10];\\n            for (int i = 0; i < 10; i++) has[i] = false;\\n            while (n > 0)\\n            {\\n                digits.push_back(n % 10); n /= 10;\\n            }\\n            int d = digits.back();\\n            digits.pop_back();\\n            has[d] = true;\\n            ans += f[i] * (d - 1);\\n            \\n            int j = i - 1;\\n            if (j < 0)  // two digits\\n            {\\n                if (digits[0] >= d) ans++;\\n            }\\n            while (j >= 0)\\n            {\\n                d = digits.back();\\n                digits.pop_back();\\n                for (int k = 0; k < d; k++)\\n                    ans += has[k]? power[j]: power[j] - A(j + 1, 9 - i + j);\\n                if (j == 0 && !has[d]) \\n                {\\n                    ans--;\\n                    has[d] = true;\\n                    for (int k = 0; k <= digits.back(); k++)\\n                        ans += has[k]? 1: 0;\\n                    break;\\n                }\\n                if (has[d])\\n                {\\n                    // add all as repeated\\n                    int p = 1;\\n                    for (int dd: digits)\\n                    {\\n                        ans += dd * p; p *= 10;\\n                    }\\n                    break;\\n                }\\n                has[d] = true;        \\n                j--;\\n            }\\n            break;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n    \\n    int A(int x, int y)\\n    {\\n        // x <= y;\\n        if (comb[x][y] != 0) return comb[x][y];\\n        int product = 1;\\n        for (int i = 0; i < x; i++)\\n            product *= y - i;\\n        comb[x][y] = product;\\n        return product;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int comb[9][9];\\n    int numDupDigitsAtMostN(int n) {\\n        if (n <= 10) return 0;\\n        int f[8], g[9], power[8];\\n        // f: 1, 28, 496...\\n        // g: 0, 10, 262, ...\\n        // power: 10, 100, 1000, ...\\n        int product = 1;\\n        int total = 1;\\n        for (int i = 0; i < 8; i++)\\n        {\\n            product *= 9 - i;\\n            total *= 10;\\n            power[i] = total;\\n            f[i] = total - product;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1442782,
                "title": "javascript-digits-traversal",
                "content": "```\\nvar numDupDigitsAtMostN = function(n) {\\n    n = n.toString();\\n    \\n    let count = 0, set = new Set(), distinctDigits;\\n\\n    let ways = 9;\\n    \\n    // Numbers with digits less then N\\n\\n    for (let i = 0; i < n.length - 1; i++) {\\n        count += ways;\\n        ways *= (9 - i);\\n    }\\n\\n    const permutation = (total, selectCount) => {\\n        let nCr = 1;\\n        for (let i = 0; i < selectCount; i++)\\n            nCr *= (total - i);\\n\\n        return nCr;\\n    }\\n    \\n    for (let i = 0; i < n.length; i++) {\\n        distinctDigits = 0;\\n        for (let j = (i === 0) ? 1 : 0; j < n.charCodeAt(i) - \"0\".charCodeAt(0); j++) {\\n            if (!set.has(`${j}`))\\n                distinctDigits++;\\n        }\\n        count += distinctDigits * permutation(9 - set.size, n.length - 1 - i);;\\n\\n        if (set.has(n[i]))\\n            break;\\n\\n        set.add(n[i]);\\n    }\\n\\n    count += (set.size === n.length);\\n\\n    return Number(n) - count;\\n};",
                "solutionTags": [],
                "code": "```\\nvar numDupDigitsAtMostN = function(n) {\\n    n = n.toString();\\n    \\n    let count = 0, set = new Set(), distinctDigits;\\n\\n    let ways = 9;\\n    \\n    // Numbers with digits less then N\\n\\n    for (let i = 0; i < n.length - 1; i++) {\\n        count += ways;\\n        ways *= (9 - i);\\n    }\\n\\n    const permutation = (total, selectCount) => {\\n        let nCr = 1;\\n        for (let i = 0; i < selectCount; i++)\\n            nCr *= (total - i);\\n\\n        return nCr;\\n    }\\n    \\n    for (let i = 0; i < n.length; i++) {\\n        distinctDigits = 0;\\n        for (let j = (i === 0) ? 1 : 0; j < n.charCodeAt(i) - \"0\".charCodeAt(0); j++) {\\n            if (!set.has(`${j}`))\\n                distinctDigits++;\\n        }\\n        count += distinctDigits * permutation(9 - set.size, n.length - 1 - i);;\\n\\n        if (set.has(n[i]))\\n            break;\\n\\n        set.add(n[i]);\\n    }\\n\\n    count += (set.size === n.length);\\n\\n    return Number(n) - count;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1440444,
                "title": "c-solution-dp-combinations",
                "content": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n         vector<int> number;\\n         for(int i=n; i>0; i/=10) number.push_back(i%10);\\n         reverse(number.begin(),number.end());\\n         int len=number.size();\\n         vector<int> dp(len,0);\\n         int tot=0;\\n         for(int i=0; i<len-1; i++) {\\n               dp[i]=i==0?9:dp[i-1]*(10-i);\\n               tot+=dp[i];\\n         }\\n         vector<int> cnt(10,0);\\n         dp.clear();\\n         dp.resize(len,0);\\n         bool same=0;\\n         for(int i=0; i<len; i++) {\\n               dp[i]=i==0?9:dp[i-1]*(10-i);\\n               int diff=0;\\n               if(!same) {\\n                  for(int digit=number[i]+1; digit<10; digit++) diff+=(cnt[digit]==0);\\n                  dp[i]-=diff;\\n                  cnt[number[i]]++;\\n                  if(cnt[number[i]]>1) same=1;\\n               }\\n         }\\n        return n-(tot+dp[len-1]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n         vector<int> number;\\n         for(int i=n; i>0; i/=10) number.push_back(i%10);\\n         reverse(number.begin(),number.end());\\n         int len=number.size();\\n         vector<int> dp(len,0);\\n         int tot=0;\\n         for(int i=0; i<len-1; i++) {\\n               dp[i]=i==0?9:dp[i-1]*(10-i);\\n               tot+=dp[i];\\n         }\\n         vector<int> cnt(10,0);\\n         dp.clear();\\n         dp.resize(len,0);\\n         bool same=0;\\n         for(int i=0; i<len; i++) {\\n               dp[i]=i==0?9:dp[i-1]*(10-i);\\n               int diff=0;\\n               if(!same) {\\n                  for(int digit=number[i]+1; digit<10; digit++) diff+=(cnt[digit]==0);\\n                  dp[i]-=diff;\\n                  cnt[number[i]]++;\\n                  if(cnt[number[i]]>1) same=1;\\n               }\\n         }\\n        return n-(tot+dp[len-1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439792,
                "title": "python-33ms-o-len-digit-n-solution-dp-and-descent",
                "content": "We have follow observation, if we want to count all numbers with repeated digits with i digits:\\n1. all count *cnt = 9 * (10 ** (i - 1)* numbers;\\n2. dp[k] can form by two part:(1) (i - 1) digits numbers with repeated numbers append 0-9 in the end, dp[i - 1] * 10; (2) (i - 1) digits numbers without repeated numbers,  so we can choose one from these (i - 1) different digits,(cnt - dp[i - 1]) * (i -1);\\n3. All repeated digits sperate equally in numbers starting with 1-9.\\n\\nThen, if we want to count specific number 3779, we have follow ideas:\\nWe first count all numbers have less digits, ans = sum(dp[0:4]) = 261;then process the number from high to low digits, 1*** = 2***=...=9***= dp[4] / 9 = 496, ans += 2 * 496=1253;\\nthe we process 30**, 31**,...36**, notice 33** all 100 numbers meet condition,  so all other 30**..,39** have (496 - 100) / 9 = 44, ans += 100 + 44 * 6 = 1617; then we process 370*, 371*,...376*, notice 373* and 377* all 20 numbers meet condition, so all other 370*, ...379* have (44 - 20)/8=3, ans += 10 + 3 * 6=1645; then we have reapeated digits in prefix, so all left 3770-3779 all meet condition, ans += 10 = 1655\\n\\n```\\nfrom math import log10\\n\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        m = int(log10(n)) + 1\\n        if m == 1: return 0\\n        dp = [0] * (m + 1)\\n        dp[2] = 9\\n        cnt = 90\\n        for i in range(3, m + 1):\\n            dp[i] = dp[i - 1] * 10 + (cnt - dp[i - 1]) * (i - 1)\\n            cnt *= 10\\n        ans = sum(dp[:-1])\\n        init, t = dp[-1], 10 ** (m - 1)\\n        prefix = []\\n        for i, v in enumerate(str(n)):\\n            v = ord(v) - ord(\\'0\\')\\n            if not prefix:\\n                prefix.append(v)\\n                init //= 9\\n                ans += (v - 1) * init\\n            else:\\n                same = 0\\n                for k in range(v):\\n                    if k in prefix: same += 1\\n                ans += same * t\\n                init = (init - len(prefix) * t) // (10 - len(prefix))\\n                if v - same > 0: ans += init * (v - same)\\n                if v in prefix:\\n                    ans += 1\\n                    if str(n)[i + 1:]: ans += int(str(n)[i + 1:])\\n                    break\\n                prefix.append(v)\\n            t //= 10\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import log10\\n\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        m = int(log10(n)) + 1\\n        if m == 1: return 0\\n        dp = [0] * (m + 1)\\n        dp[2] = 9\\n        cnt = 90\\n        for i in range(3, m + 1):\\n            dp[i] = dp[i - 1] * 10 + (cnt - dp[i - 1]) * (i - 1)\\n            cnt *= 10\\n        ans = sum(dp[:-1])\\n        init, t = dp[-1], 10 ** (m - 1)\\n        prefix = []\\n        for i, v in enumerate(str(n)):\\n            v = ord(v) - ord(\\'0\\')\\n            if not prefix:\\n                prefix.append(v)\\n                init //= 9\\n                ans += (v - 1) * init\\n            else:\\n                same = 0\\n                for k in range(v):\\n                    if k in prefix: same += 1\\n                ans += same * t\\n                init = (init - len(prefix) * t) // (10 - len(prefix))\\n                if v - same > 0: ans += init * (v - same)\\n                if v in prefix:\\n                    ans += 1\\n                    if str(n)[i + 1:]: ans += int(str(n)[i + 1:])\\n                    break\\n                prefix.append(v)\\n            t //= 10\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412851,
                "title": "digit-dp-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[11][2][5000];\\n    int fnd(int i, bool tight, int used, string& n)\\n    {\\n        if(i==n.length())\\n            return 1;\\n        \\n        if(dp[i][tight][used]!=-1)\\n            return dp[i][tight][used];\\n        \\n        int ub= tight? n[i]-\\'0\\':10,ans=0;\\n        \\n        for(int j=0;j<ub;j++)\\n        {\\n            if(used==0 && j==0)\\n            {\\n                ans+=fnd(i+1,false,used,n);\\n                continue;\\n            }\\n            \\n            if(used&(1<<j))\\n                continue;\\n            \\n            ans+=fnd(i+1,false,used|(1<<j),n);\\n        }\\n        \\n        if(tight && (used&(1<<ub))==0)\\n            ans+=fnd(i+1,true,used|(1<<ub),n);\\n        \\n        return dp[i][tight][used]=ans;\\n        \\n    }\\n    \\n    int numDupDigitsAtMostN(int num) {\\n        string n=to_string(num);\\n        memset(dp,-1,sizeof(dp));\\n        return num-fnd(0,true,0,n)+1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[11][2][5000];\\n    int fnd(int i, bool tight, int used, string& n)\\n    {\\n        if(i==n.length())\\n            return 1;\\n        \\n        if(dp[i][tight][used]!=-1)\\n            return dp[i][tight][used];\\n        \\n        int ub= tight? n[i]-\\'0\\':10,ans=0;\\n        \\n        for(int j=0;j<ub;j++)\\n        {\\n            if(used==0 && j==0)\\n            {\\n                ans+=fnd(i+1,false,used,n);\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1388486,
                "title": "python-logarithmic-recursion",
                "content": "```\\nimport operator as op\\nfrom functools import reduce\\n\\ndef generate(num):\\n    if len(num) == 1:\\n        return int(num) + 1\\n    \\n    ans = (int(num[0]) - 1) * reduce(op.mul, [9 - i for i in range(len(num) - 1)])\\n    pool = set([int(num[0])])\\n    \\n    for i in range(1, len(num)):\\n        res = 1\\n        for j in range(i + 1, len(num)):\\n            res *= (10 - j)\\n\\n        ans += res * len(set([i for i in range(int(num[i]))]).difference(pool))\\n        if int(num[i]) in pool:\\n            break\\n        pool.add(int(num[i]))\\n        \\n    return ans + int(isUnique(num)) + generate(\\'9\\' * (len(num) - 1))\\n\\ndef isUnique(num):\\n    marked = [-1 for i in range(10)]\\n    num = int(num)\\n    while num:\\n        d = num % 10\\n        if marked[d] != -1:\\n            return False\\n        marked[d] = 1\\n        num //= 10\\n    \\n    return True\\n\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        return n - (generate(str(n)) - 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nimport operator as op\\nfrom functools import reduce\\n\\ndef generate(num):\\n    if len(num) == 1:\\n        return int(num) + 1\\n    \\n    ans = (int(num[0]) - 1) * reduce(op.mul, [9 - i for i in range(len(num) - 1)])\\n    pool = set([int(num[0])])\\n    \\n    for i in range(1, len(num)):\\n        res = 1\\n        for j in range(i + 1, len(num)):\\n            res *= (10 - j)\\n\\n        ans += res * len(set([i for i in range(int(num[i]))]).difference(pool))\\n        if int(num[i]) in pool:\\n            break\\n        pool.add(int(num[i]))\\n        \\n    return ans + int(isUnique(num)) + generate(\\'9\\' * (len(num) - 1))\\n\\ndef isUnique(num):\\n    marked = [-1 for i in range(10)]\\n    num = int(num)\\n    while num:\\n        d = num % 10\\n        if marked[d] != -1:\\n            return False\\n        marked[d] = 1\\n        num //= 10\\n    \\n    return True\\n\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        return n - (generate(str(n)) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381869,
                "title": "test-cases-passed-tle-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        int sum=0,i,j,k;\\n        for(i=1;i<=n;i++)\\n        {\\n            string s=to_string(i);\\n            int sz=s.size();\\n            set<char> st;\\n            for(j=0;j<sz;j++)\\n                st.insert(s[j]);\\n            if(st.size()<sz)\\n                sum++;\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        int sum=0,i,j,k;\\n        for(i=1;i<=n;i++)\\n        {\\n            string s=to_string(i);\\n            int sz=s.size();\\n            set<char> st;\\n            for(j=0;j<sz;j++)\\n                st.insert(s[j]);\\n            if(st.size()<sz)\\n                sum++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1367853,
                "title": "c-commented-solution-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int permutation(int m,int n){\\n        if(n==0)return 1;\\n        return (m-n+1)*permutation(m,n-1);\\n    }\\n    int numDupDigitsAtMostN(int N) {\\n        vector<int>num;\\n        int number=N;\\n        N=N+1;\\n        while(N>0){                // storing all digits \\n            num.push_back(N%10);\\n            N=N/10;\\n        }\\n        reverse(num.begin(),num.end());    \\n        int n=num.size();\\n        int res=0;\\n        for(int i=0;i<n-1;i++){         //calculate all numbers which have less digits than in N\\n            res+=9*permutation(9,i);\\n        }\\n        unordered_set<int>seen;\\n/*calculate number which have same disits as N and not contain any two digits same ans less than N */\\n        for(int i=0;i<n;i++){  \\n            for(int j=i>0?0:1;j<num[i];j++){  //check for which is less than current digit in N \\n                if(seen.find(j)==seen.end()){  //check if it has not visited yet\\n                    res+=permutation(9-i,n-i-1);\\n                }\\n            }\\n            if(seen.find(num[i])!=seen.end()) break;  //if a number is repeated in N itself no more number possible which are less and not contain duplicate\\n            seen.insert(num[i]);   //mark as seen current digit\\n        }\\n        return number-res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int permutation(int m,int n){\\n        if(n==0)return 1;\\n        return (m-n+1)*permutation(m,n-1);\\n    }\\n    int numDupDigitsAtMostN(int N) {\\n        vector<int>num;\\n        int number=N;\\n        N=N+1;\\n        while(N>0){                // storing all digits \\n            num.push_back(N%10);\\n            N=N/10;\\n        }\\n        reverse(num.begin(),num.end());    \\n        int n=num.size();\\n        int res=0;\\n        for(int i=0;i<n-1;i++){         //calculate all numbers which have less digits than in N\\n            res+=9*permutation(9,i);\\n        }\\n        unordered_set<int>seen;\\n/*calculate number which have same disits as N and not contain any two digits same ans less than N */\\n        for(int i=0;i<n;i++){  \\n            for(int j=i>0?0:1;j<num[i];j++){  //check for which is less than current digit in N \\n                if(seen.find(j)==seen.end()){  //check if it has not visited yet\\n                    res+=permutation(9-i,n-i-1);\\n                }\\n            }\\n            if(seen.find(num[i])!=seen.end()) break;  //if a number is repeated in N itself no more number possible which are less and not contain duplicate\\n            seen.insert(num[i]);   //mark as seen current digit\\n        }\\n        return number-res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365853,
                "title": "c-faster-than-100",
                "content": "class Solution {\\npublic:\\n    int dp[12][11];\\n    int dp1[12][12][3];\\n    int solve(int vis[],int ind,int max){\\n        if(dp[ind][max]!=-1){\\n            return dp[ind][max];\\n        }\\n        if(ind>max){\\n             return 1;\\n        }\\n        int  res=0;\\n        for(int i=0;i<=9;i++){\\n            if(vis[i]==0){\\n                vis[i]=1;\\n                res+=solve(vis,ind+1,max);\\n                 vis[i]=0;\\n            }\\n        }\\n        return  dp[ind][max]=res;\\n        \\n    }\\n    int solve1(vector<int>&v,int vis[],int ind,int max,bool isTrue){\\n        if(dp1[ind][max][isTrue]!=-1){\\n            return dp1[ind][max][isTrue];\\n        }\\n       if(ind>max){\\n             return 1;\\n        }\\n        int end=9;\\n        if(isTrue){\\n            end=v[ind-1];\\n        }\\n        int res=0;\\n        for(int i=0;i<=end;i++){\\n            if(vis[i]==0){\\n                vis[i]=1;\\n                res+=solve1(v,vis,ind+1,max,(isTrue)&(v[ind-1]==i));\\n                vis[i]=0;\\n            }\\n        }\\n        return dp1[ind][max][isTrue]= res;\\n        \\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp,-1,sizeof dp);\\n        memset(dp1,-1,sizeof dp1);\\n        int xn=n;\\n        int count=0;\\n        vector<int>v;\\n        while(xn!=0){\\n            v.push_back(xn%10);\\n            xn/=10;\\n            count++;\\n        }\\n     \\n        reverse(v.begin(),v.end());\\n        int res=0;\\n        int vis[10];\\n        memset(vis,0,sizeof vis);\\n        for(int i=1;i<count;i++){\\n            for(int j=1;j<=9;j++){\\n                memset(vis,0,sizeof vis);\\n                vis[j]=1;\\n                res+=solve(vis,2,i);\\n                vis[j]=0;\\n              \\n            }\\n        }\\n        \\n         for(int j=1;j<=v[0];j++){\\n             memset(vis,0,sizeof vis);\\n             vis[j]=1;\\n             \\n            res+=solve1(v,vis,2,count,true&(j==v[0]));\\n           \\n         }\\n             \\n\\n        return n-(res);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[12][11];\\n    int dp1[12][12][3];\\n    int solve(int vis[],int ind,int max){\\n        if(dp[ind][max]!=-1){\\n            return dp[ind][max];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1332533,
                "title": "c-solution-faster-than-100",
                "content": "```\\n// Check if N is without repeated digits.\\nint isRepeated(const vector<int> &num){\\n    const int size = static_cast<int>(num.size());\\n    vector<int> digit(10, 0);\\n    for (int i=0; i<size; ++i) {\\n        if (digit[num[i]] > 0) {return true;}\\n        ++digit[num[i]];\\n    }\\n    return false;\\n}\\n\\nint numDupDigitsAtMostN(int n) {\\n    if (n == 0) {return 0;}\\n    \\n    // Int -> int vector\\n    const int N = n;\\n    int size = 0;\\n    vector<int> num;\\n    while (n != 0) {\\n        num.push_back(n % 10);\\n        n /= 10;\\n        ++ size;\\n    }\\n    reverse(num.begin(), num.end());\\n    \\n    // Calculate the number of 1 ~ (size - 1) digits without repeated digits.\\n    int noRepeated = 0;\\n    for (int i=1; i<=size-1; ++i) {\\n        int remain = 9;\\n        int count = 9;\\n        for (int j=2; j<=i; ++j) {\\n            count *= remain--;\\n        }\\n        noRepeated += count;\\n    }\\n    \\n    // Calculate the number of size digits without repeated digits.\\n    for (int i=0; i<size; ++i) {\\n        // Initialization of remain\\n        int remain;\\n        i == 0 ? remain = num[i] - 1 : remain = num[i];\\n        \\n        // If prefix is the number with repaeted digits, the loop break\\n        vector<int> prefix(i);\\n        copy(num.begin(), num.begin() + i, prefix.begin());\\n        if (isRepeated(prefix)) {break;}\\n        \\n        // Delete choosen numbers from remain\\n        for (int j=0; j<i; ++j) {\\n            if (num[j] <= num[i] - 1) {--remain;}\\n        }\\n        \\n        // Count\\n        int count = remain;\\n        for (int j=i+1; j<size; ++j) {\\n            count *= (10 - j);\\n        }\\n        noRepeated += count;\\n    }\\n    \\n    // Check if N is the number without repeated digits.\\n    isRepeated(num) ? 1 : ++noRepeated;\\n    \\n    return N - noRepeated;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Check if N is without repeated digits.\\nint isRepeated(const vector<int> &num){\\n    const int size = static_cast<int>(num.size());\\n    vector<int> digit(10, 0);\\n    for (int i=0; i<size; ++i) {\\n        if (digit[num[i]] > 0) {return true;}\\n        ++digit[num[i]];\\n    }\\n    return false;\\n}\\n\\nint numDupDigitsAtMostN(int n) {\\n    if (n == 0) {return 0;}\\n    \\n    // Int -> int vector\\n    const int N = n;\\n    int size = 0;\\n    vector<int> num;\\n    while (n != 0) {\\n        num.push_back(n % 10);\\n        n /= 10;\\n        ++ size;\\n    }\\n    reverse(num.begin(), num.end());\\n    \\n    // Calculate the number of 1 ~ (size - 1) digits without repeated digits.\\n    int noRepeated = 0;\\n    for (int i=1; i<=size-1; ++i) {\\n        int remain = 9;\\n        int count = 9;\\n        for (int j=2; j<=i; ++j) {\\n            count *= remain--;\\n        }\\n        noRepeated += count;\\n    }\\n    \\n    // Calculate the number of size digits without repeated digits.\\n    for (int i=0; i<size; ++i) {\\n        // Initialization of remain\\n        int remain;\\n        i == 0 ? remain = num[i] - 1 : remain = num[i];\\n        \\n        // If prefix is the number with repaeted digits, the loop break\\n        vector<int> prefix(i);\\n        copy(num.begin(), num.begin() + i, prefix.begin());\\n        if (isRepeated(prefix)) {break;}\\n        \\n        // Delete choosen numbers from remain\\n        for (int j=0; j<i; ++j) {\\n            if (num[j] <= num[i] - 1) {--remain;}\\n        }\\n        \\n        // Count\\n        int count = remain;\\n        for (int j=i+1; j<size; ++j) {\\n            count *= (10 - j);\\n        }\\n        noRepeated += count;\\n    }\\n    \\n    // Check if N is the number without repeated digits.\\n    isRepeated(num) ? 1 : ++noRepeated;\\n    \\n    return N - noRepeated;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1248941,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        if(N<11)return 0;\\n        string s=to_string(N);\\n        int n=s.size();\\n        int ans=0;\\n        vector<bool>used(10,false);\\n        for(int i=0;i<s[0]-\\'0\\';i++)\\n        {\\n            int keep=ans;\\n            used[i]=true;\\n            ans+=helper(s.substr(1),10,used);\\n            used[i]=false;\\n        }\\n        used[s[0]-\\'0\\']=true;\\n        ans+=helper(s.substr(1),s[0]-\\'0\\',used);\\n        return N-ans;\\n    }\\n    int helper(string s,int limit,vector<bool> used)\\n    {\\n        int n=s.size();\\n        int size=0;\\n        for(auto x:used)if(x==true)size++;\\n        if(n==1&&limit==10)return 10-size;\\n        if(n==1&&limit!=10)\\n        {\\n            int res=0;\\n            for(int i=s[0]-\\'0\\';i>=0;i--)if(used[i]==false)res++;\\n            return res;\\n        }\\n        if(limit==10)\\n        {\\n            int res=1;\\n            if(size==1&&used[0]==true)\\n            {\\n                res=9;\\n                for(int i=0;i<n-1;i++)res*=(10-size-i);\\n                res+=helper(s.substr(1),10,used);\\n                return res;\\n            }\\n            for(int i=0;i<n;i++)res*=(10-size-i);\\n            return res;\\n        }\\n        int res=0;\\n        for(int i=0;i<s[0]-\\'0\\';i++)\\n        {\\n            if(used[i]==true)continue;\\n            used[i]=true;\\n            res+=helper(s.substr(1),10,used);\\n            used[i]=false;\\n        }\\n        if(used[s[0]-\\'0\\']==true)return res;\\n        used[s[0]-\\'0\\']=true;\\n        res+=helper(s.substr(1),s[0]-\\'0\\',used);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        if(N<11)return 0;\\n        string s=to_string(N);\\n        int n=s.size();\\n        int ans=0;\\n        vector<bool>used(10,false);\\n        for(int i=0;i<s[0]-\\'0\\';i++)\\n        {\\n            int keep=ans;\\n            used[i]=true;\\n            ans+=helper(s.substr(1),10,used);\\n            used[i]=false;\\n        }\\n        used[s[0]-\\'0\\']=true;\\n        ans+=helper(s.substr(1),s[0]-\\'0\\',used);\\n        return N-ans;\\n    }\\n    int helper(string s,int limit,vector<bool> used)\\n    {\\n        int n=s.size();\\n        int size=0;\\n        for(auto x:used)if(x==true)size++;\\n        if(n==1&&limit==10)return 10-size;\\n        if(n==1&&limit!=10)\\n        {\\n            int res=0;\\n            for(int i=s[0]-\\'0\\';i>=0;i--)if(used[i]==false)res++;\\n            return res;\\n        }\\n        if(limit==10)\\n        {\\n            int res=1;\\n            if(size==1&&used[0]==true)\\n            {\\n                res=9;\\n                for(int i=0;i<n-1;i++)res*=(10-size-i);\\n                res+=helper(s.substr(1),10,used);\\n                return res;\\n            }\\n            for(int i=0;i<n;i++)res*=(10-size-i);\\n            return res;\\n        }\\n        int res=0;\\n        for(int i=0;i<s[0]-\\'0\\';i++)\\n        {\\n            if(used[i]==true)continue;\\n            used[i]=true;\\n            res+=helper(s.substr(1),10,used);\\n            used[i]=false;\\n        }\\n        if(used[s[0]-\\'0\\']==true)return res;\\n        used[s[0]-\\'0\\']=true;\\n        res+=helper(s.substr(1),s[0]-\\'0\\',used);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248246,
                "title": "swift-dp",
                "content": "```swift\\nclass Solution {\\n    private var memo = [Int:Int]()\\n    private var upperBound = [Int]()\\n    \\n    func numDupDigitsAtMostN(_ n: Int) -> Int {\\n        \\n        self.upperBound = caculateUpperBound(of: n)\\n        self.memo = [:]\\n        \\n        return n - dfs(self.upperBound.count - 1, 0, 0,0) + 1\\n    }\\n    \\n    private func caculateUpperBound(of num: Int) -> [Int] {\\n        var ans = [Int]()\\n        var n = num\\n        while n > 0 {\\n            ans.append(n % 10)\\n            n /= 10\\n        }\\n        return ans\\n    }\\n    \\n    private func dfs(_ curPos: Int, _ preNum: Int, _ targetMax: Int, _ usedDigits: Int) -> Int {\\n        guard curPos >= 0 else {\\n            return 1\\n        }\\n        let key =  (usedDigits << 32) | curPos\\n        if preNum < targetMax && preNum != 0 {\\n            guard nil == self.memo[key] else {\\n                return self.memo[key]!\\n            }\\n        }\\n        let upperLimit = preNum < targetMax ? 9 : self.upperBound[curPos]\\n        var ret = 0\\n        for num in 0...upperLimit {\\n            //\\u4FDD\\u8BC1\\u6CA1\\u6709\\u4F7F\\u7528\\u8FC7\\n            if usedDigits & (1 << num) == 0 {\\n                ret += dfs(curPos - 1, preNum * 10 + num, targetMax * 10 + self.upperBound[curPos], preNum + num == 0 ? 0 : (usedDigits | (1 << num)) )\\n            }\\n        }\\n        if preNum < targetMax && preNum != 0 {\\n            self.memo[key] = ret\\n        }\\n        return ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming"
                ],
                "code": "```swift\\nclass Solution {\\n    private var memo = [Int:Int]()\\n    private var upperBound = [Int]()\\n    \\n    func numDupDigitsAtMostN(_ n: Int) -> Int {\\n        \\n        self.upperBound = caculateUpperBound(of: n)\\n        self.memo = [:]\\n        \\n        return n - dfs(self.upperBound.count - 1, 0, 0,0) + 1\\n    }\\n    \\n    private func caculateUpperBound(of num: Int) -> [Int] {\\n        var ans = [Int]()\\n        var n = num\\n        while n > 0 {\\n            ans.append(n % 10)\\n            n /= 10\\n        }\\n        return ans\\n    }\\n    \\n    private func dfs(_ curPos: Int, _ preNum: Int, _ targetMax: Int, _ usedDigits: Int) -> Int {\\n        guard curPos >= 0 else {\\n            return 1\\n        }\\n        let key =  (usedDigits << 32) | curPos\\n        if preNum < targetMax && preNum != 0 {\\n            guard nil == self.memo[key] else {\\n                return self.memo[key]!\\n            }\\n        }\\n        let upperLimit = preNum < targetMax ? 9 : self.upperBound[curPos]\\n        var ret = 0\\n        for num in 0...upperLimit {\\n            //\\u4FDD\\u8BC1\\u6CA1\\u6709\\u4F7F\\u7528\\u8FC7\\n            if usedDigits & (1 << num) == 0 {\\n                ret += dfs(curPos - 1, preNum * 10 + num, targetMax * 10 + self.upperBound[curPos], preNum + num == 0 ? 0 : (usedDigits | (1 << num)) )\\n            }\\n        }\\n        if preNum < targetMax && preNum != 0 {\\n            self.memo[key] = ret\\n        }\\n        return ret\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233695,
                "title": "digit-dp-and-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[10][2][2][1025];\\n    int recursive(vector<int> &vec,int idx,int mask,int tight,int flag)\\n    {\\n        if(idx==vec.size())\\n        {\\n            //cout<<mask<<endl;\\n            return 1;\\n        }\\n        if(dp[idx][tight][flag][mask]!=-1)\\n            return dp[idx][tight][flag][mask];\\n        int var=0;\\n        if(tight==1)\\n        {\\n            for(int i=0;i<=vec[idx];i++)\\n            {\\n                if(i==vec[idx])\\n                {\\n                    if((mask&1<<i)==0)\\n                    {\\n                         if(flag==0&&i==0)\\n                             var+=recursive(vec,idx+1,mask,1,flag);\\n                         else\\n                             var+=recursive(vec,idx+1,mask|1<<i,1,flag|1);\\n                    }\\n                }\\n                else\\n                {\\n                    if((mask&1<<i)==0)\\n                    {\\n                         if(flag==0&&i==0)\\n                             var+=recursive(vec,idx+1,mask,0,flag);\\n                         else\\n                             var+=recursive(vec,idx+1,mask|1<<i,0,flag|1);\\n                    }\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<=9;i++)\\n            {\\n                if((mask&1<<i)==0)\\n                {\\n                    if(flag==0&&i==0)\\n                        var+=recursive(vec,idx+1,mask,0,flag);\\n                    else\\n                        var+=recursive(vec,idx+1,mask|1<<i,0,flag|1);\\n                }\\n            }\\n        }\\n        \\n        \\n        return dp[idx][tight][flag][mask]=var;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<int> vec;\\n        int var=n;\\n        while(n)\\n        {\\n            vec.push_back(n%10);\\n            n/=10;\\n        }\\n        reverse(vec.begin(),vec.end());\\n        /*for(int i=0;i<vec.size();i++)\\n            cout<<vec[i]<<\" \";*/\\n        //cout<<(1<<0)<<endl;\\n        int ans=recursive(vec,0,0,1,0);\\n        //cout<<ans<<endl;\\n        return var-ans+1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[10][2][2][1025];\\n    int recursive(vector<int> &vec,int idx,int mask,int tight,int flag)\\n    {\\n        if(idx==vec.size())\\n        {\\n            //cout<<mask<<endl;\\n            return 1;\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 1220443,
                "title": "faster-than-98-python3-solution",
                "content": "First idea: we will count numbers from [1;n] where all digit are different. If we get **S**, then we return **n-S** as the answer.\\nWe start with finding number nd such as 10^nd<=n<10^(nd+1). First digit of n will be **fd=n//(10^nd)**.\\nAll numbers from [1;n] with different digits consist of three parts.\\n1. Those that have **nd** or less digits - **uptod**(nd) function computes that.\\n2. Those that have first digit from [1;fd-1] range, and after that come other **nd** digits. For each starting digit, there are **ndig(nd,1)** of them.\\n3. Those that start from **fd** and after that have other **nd** digits - that set is computed with **zupto** call.\\n\\nFunction **ndig** calculates, how many combination of **nd** digits there are, if **nused** digits are already used (thus prohibited).\\nFunction **uptod** calculates, how many numbers that have **nd** digits or less, consist of all different digits.\\nFunction **zupto** calculates, how many (zero-padded) numbers with **nd** digits, not greater than **n**, there can be, if **used** set is prohibited,\\n\\n```\\nfrom math import factorial as fac\\n\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        def ndig(nd,nused):\\n            navail = 10-nused\\n            if nd>navail:\\n                return 0\\n            return fac(navail)//fac(navail-nd)\\n        def uptod(nd):\\n            if nd==1:\\n                return 9\\n            #assert(nd>1)\\n            return uptod(nd-1)+9*ndig(nd-1,1)\\n        def zupto(nd,n,used):\\n            if nd==1:\\n                return sum(1 for d in range(n+1) if d not in used)\\n            #assert(nd>1)\\n            #assert(n<10**nd)\\n            f1 = 10**(nd-1)\\n            fd = n//f1\\n            S = 0\\n            for d in range(fd):\\n                if d not in used:\\n                    S += ndig(nd-1,len(used)+1)\\n            if fd not in used:\\n                used.add(fd)\\n                S += zupto(nd-1,n%f1,used)\\n                used.remove(fd)\\n            return S\\n        \\n        if n<=10:\\n            return 0\\n        \\n        pow10 = 10\\n        nd = 0\\n        while pow10<=n:\\n            pow10 *= 10\\n            nd += 1\\n        pow10 //= 10\\n        print(pow10,nd)\\n        assert(len(str(n))==nd+1)\\n        S = uptod(nd)\\n        fd = n//pow10\\n        S += (fd-1)*ndig(nd,1)\\n        used = {fd}\\n        S += zupto(nd,n%pow10,used)\\n        return n-S\\n```    \\n",
                "solutionTags": [],
                "code": "```\\nfrom math import factorial as fac\\n\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        def ndig(nd,nused):\\n            navail = 10-nused\\n            if nd>navail:\\n                return 0\\n            return fac(navail)//fac(navail-nd)\\n        def uptod(nd):\\n            if nd==1:\\n                return 9\\n            #assert(nd>1)\\n            return uptod(nd-1)+9*ndig(nd-1,1)\\n        def zupto(nd,n,used):\\n            if nd==1:\\n                return sum(1 for d in range(n+1) if d not in used)\\n            #assert(nd>1)\\n            #assert(n<10**nd)\\n            f1 = 10**(nd-1)\\n            fd = n//f1\\n            S = 0\\n            for d in range(fd):\\n                if d not in used:\\n                    S += ndig(nd-1,len(used)+1)\\n            if fd not in used:\\n                used.add(fd)\\n                S += zupto(nd-1,n%f1,used)\\n                used.remove(fd)\\n            return S\\n        \\n        if n<=10:\\n            return 0\\n        \\n        pow10 = 10\\n        nd = 0\\n        while pow10<=n:\\n            pow10 *= 10\\n            nd += 1\\n        pow10 //= 10\\n        print(pow10,nd)\\n        assert(len(str(n))==nd+1)\\n        S = uptod(nd)\\n        fd = n//pow10\\n        S += (fd-1)*ndig(nd,1)\\n        used = {fd}\\n        S += zupto(nd,n%pow10,used)\\n        return n-S\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195635,
                "title": "32ms-python-solution-n-no-of-non-repeated-digit-integer-approach",
                "content": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        if N <= 10:\\n            return 0\\n        \\n        lst = list(str(N))\\n        l = len(lst)\\n\\t\\t# Create memo for no. of non repeated digits for cases, 10, 100, 1000...\\n\\t\\t# Calculation: 9 x 9 x 8 x .....\\n        memo = { 1: 0, \\n                 2: 9, \\n                 3: 81, \\n                 4: 648, \\n                 5: 4536,\\n                 6: 27216, \\n                 7: 136080, \\n                 8: 544320,\\n                 9: 1632960,\\n                 10: 3265920}\\n        \\n        prev = []\\n        \\n        nrpc = 0\\n        for i in range(l):\\n            nrpc += memo[i+1]        \\n        \\n        nrpc += ((int(lst[0])-1) * int(memo[i+2]/9))\\n        prev.append(int(lst[0]))\\n        not_repeat = True\\n        \\n        for i in range(1, l):\\n            if not_repeat:\\n                if lst[i] != \\'0\\' and i != l-1:\\n                    c = 9-i\\n                    r = l-1-i\\n                    if lst[i] == \\'1\\' and 0 not in prev:\\n                        nrpc = nrpc + self.pMu(c,r)\\n                    else:\\n                        nrpc = nrpc + (self.noChoice(prev, int(lst[i])-1)) * self.pMu(c,r)\\n                elif lst[i] == \\'0\\' and i != l-1:\\n                    pass\\n                else:\\n                    nrpc = nrpc + self.noChoice(prev, int(lst[i]))\\n                \\n            if int(lst[i]) in prev:\\n                not_repeat = False\\n                \\n            prev.append(int(lst[i]))\\n        \\n        \\n        return N-nrpc\\n    \\n    def pMu(self, c: int, r: int) -> int:\\n        res = 1\\n        while r != 0:\\n            res = res * c\\n            c -=1\\n            r -=1\\n        return res\\n    \\n    def noChoice(self, prev: List[int], n: int) -> int:\\n        #print(prev)\\n        tmp = list(range(0,n+1))\\n        nChoice = n+1\\n        for no in tmp:\\n            if no in prev:\\n                nChoice -= 1\\n        return nChoice\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        if N <= 10:\\n            return 0\\n        \\n        lst = list(str(N))\\n        l = len(lst)\\n\\t\\t# Create memo for no. of non repeated digits for cases, 10, 100, 1000...\\n\\t\\t# Calculation: 9 x 9 x 8 x .....\\n        memo = { 1: 0, \\n                 2: 9, \\n                 3: 81, \\n                 4: 648, \\n                 5: 4536,\\n                 6: 27216, \\n                 7: 136080, \\n                 8: 544320,\\n                 9: 1632960,\\n                 10: 3265920}\\n        \\n        prev = []\\n        \\n        nrpc = 0\\n        for i in range(l):\\n            nrpc += memo[i+1]        \\n        \\n        nrpc += ((int(lst[0])-1) * int(memo[i+2]/9))\\n        prev.append(int(lst[0]))\\n        not_repeat = True\\n        \\n        for i in range(1, l):\\n            if not_repeat:\\n                if lst[i] != \\'0\\' and i != l-1:\\n                    c = 9-i\\n                    r = l-1-i\\n                    if lst[i] == \\'1\\' and 0 not in prev:\\n                        nrpc = nrpc + self.pMu(c,r)\\n                    else:\\n                        nrpc = nrpc + (self.noChoice(prev, int(lst[i])-1)) * self.pMu(c,r)\\n                elif lst[i] == \\'0\\' and i != l-1:\\n                    pass\\n                else:\\n                    nrpc = nrpc + self.noChoice(prev, int(lst[i]))\\n                \\n            if int(lst[i]) in prev:\\n                not_repeat = False\\n                \\n            prev.append(int(lst[i]))\\n        \\n        \\n        return N-nrpc\\n    \\n    def pMu(self, c: int, r: int) -> int:\\n        res = 1\\n        while r != 0:\\n            res = res * c\\n            c -=1\\n            r -=1\\n        return res\\n    \\n    def noChoice(self, prev: List[int], n: int) -> int:\\n        #print(prev)\\n        tmp = list(range(0,n+1))\\n        nChoice = n+1\\n        for no in tmp:\\n            if no in prev:\\n                nChoice -= 1\\n        return nChoice\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165501,
                "title": "javascript-time-limit-exceede",
                "content": "/**\\n * @param {number} N\\n * @return {number}\\n */\\nfunction detect_duplicate(N){\\n    let myFunc = num => Number(num);\\n    var intArr = Array.from(String(N), myFunc);\\n    for (var i = 0; i < intArr.length; i++) {\\n        for (var j = i; j < intArr.length; j++) {\\n            if( i !== j && intArr[i] === intArr[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n\\nvar numDupDigitsAtMostN = function(N) {\\n    result=0;\\n    for (var i = 10; i <= N; i++) {\\n        if(detect_duplicate(i)){\\n            result++;\\n        }\\n    }\\n    return result;\\n};\\n\\nHow can i improve this code?\\nI already used filter function. but got same result.",
                "solutionTags": [],
                "code": "/**\\n * @param {number} N\\n * @return {number}\\n */\\nfunction detect_duplicate(N){\\n    let myFunc = num => Number(num);\\n    var intArr = Array.from(String(N), myFunc);\\n    for (var i = 0; i < intArr.length; i++) {\\n        for (var j = i; j < intArr.length; j++) {\\n            if( i !== j && intArr[i] === intArr[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n\\nvar numDupDigitsAtMostN = function(N) {\\n    result=0;\\n    for (var i = 10; i <= N; i++) {\\n        if(detect_duplicate(i)){\\n            result++;\\n        }\\n    }\\n    return result;\\n};\\n\\nHow can i improve this code?\\nI already used filter function. but got same result.",
                "codeTag": "Unknown"
            },
            {
                "id": 1163551,
                "title": "python-3-time-limit-exceeded",
                "content": "class Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        \\n        repeated_number_checks = set() #To store and check if any number is repeating\\n        temp=0     #using for storing the number after division\\n        y=0        #to use copy of iterated number\\n        count = 0\\n        \\n        if(N < 100):\\n            for x in range(1,N+1):\\n                if(x % 11 == 0):\\n                    count = count+1\\n        else:\\n            for x in range(0,N+1):\\n                y=x\\n                repeated_number_checks.clear()\\n                while(y>0):\\n                    temp =y%10\\n                    if(temp in repeated_number_checks):\\n                        count=count+1\\n                        break\\n                    else:\\n                        repeated_number_checks.add(temp)\\n                        y=int(y/10)\\n        return(count)\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        \\n        repeated_number_checks = set() #To store and check if any number is repeating\\n        temp=0     #using for storing the number after division\\n        y=0        #to use copy of iterated number\\n        count = 0\\n        \\n        if(N < 100):\\n            for x in range(1,N+1):\\n                if(x % 11 == 0):\\n                    count = count+1\\n        else:\\n            for x in range(0,N+1):\\n                y=x\\n                repeated_number_checks.clear()\\n                while(y>0):\\n                    temp =y%10\\n                    if(temp in repeated_number_checks):\\n                        count=count+1\\n                        break\\n                    else:\\n                        repeated_number_checks.add(temp)\\n                        y=int(y/10)\\n        return(count)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1156601,
                "title": "a-c-solution",
                "content": "We can solve this problem by count numbers with unique digits.\\nFor a given number `N+1={A_1 A_2 A_3 A_4 ... A_L}`, we can set:\\n`base={1, 9, 9*8, 9*8*7, ..., 9*8*7*6*5*4*3*2*1}`\\n`sum={9, 9+9*9, 9+9*9+9*9*8, ...}`\\nThe variable `no_rep` can be divided into these parts:\\n1. `(A_1 - 1)*base[L-1] + 9*base[L-2] + 9*base[L-3] + ... + 9*base[1] + 9*base[0]`, which is same as `(A_1 - 1)*base[L-1] + sum[L-2]`.\\n2. `(A_2 - |B2|)*base[L-1]/base[1]`, which `|B2|` means the number of digits unequal to `A_1` from `0` to `A_2 - 1`.\\n3. The rest can be done in the same manner. And the last part can be `(A_L - |B_L|)*1`.\\n\\nIn this process, if we meet a digit `A_j` which is equal to `A_i (i<j)`, we can stop next steps.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        if(N<10) return 0;\\n        vector<long> base={1},sum={9};\\n        for(int i=9;i>0;i--){\\n            base.push_back(base.back()*i);\\n            sum.push_back(sum.back()+9*base.back());\\n        }\\n        string s=to_string(N+1);\\n        int len=s.size();\\n        int vis[10]={0};\\n        long no_rep=(s[0]-\\'0\\'-1)*base[len-1]+sum[len-2];\\n        vis[s[0]-\\'0\\']=1;\\n        for(int i=1;i<len;i++){\\n            int cnt=0;\\n            for(int j=0;j<s[i]-\\'0\\';j++)\\n                if(vis[j]==0) ++cnt;\\n            no_rep+=cnt*base[len-1]/base[i];\\n            if(vis[s[i]-\\'0\\']!=0) break;\\n            vis[s[i]-\\'0\\']=1;\\n        }\\n        return N-no_rep;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        if(N<10) return 0;\\n        vector<long> base={1},sum={9};\\n        for(int i=9;i>0;i--){\\n            base.push_back(base.back()*i);\\n            sum.push_back(sum.back()+9*base.back());\\n        }\\n        string s=to_string(N+1);\\n        int len=s.size();\\n        int vis[10]={0};\\n        long no_rep=(s[0]-\\'0\\'-1)*base[len-1]+sum[len-2];\\n        vis[s[0]-\\'0\\']=1;\\n        for(int i=1;i<len;i++){\\n            int cnt=0;\\n            for(int j=0;j<s[i]-\\'0\\';j++)\\n                if(vis[j]==0) ++cnt;\\n            no_rep+=cnt*base[len-1]/base[i];\\n            if(vis[s[i]-\\'0\\']!=0) break;\\n            vis[s[i]-\\'0\\']=1;\\n        }\\n        return N-no_rep;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138631,
                "title": "unsure-what-i-m-doing-wrong-python",
                "content": "```\\nclass Solution(object):\\n    def numDupDigitsAtMostN(self, N):\\n\\n        \"123 --> [12] [23]\"\\n        \"1234 --> [12] [23] [34]\"\\n        \\n        repeatedDigits = 0\\n        \\n        for num in range(1, N + 1):\\n            strNum = str(num)\\n            numLen = len(strNum)\\n            \\n            strPairs = []\\n            \\n            for pairIndex in range(0, numLen - 1):\\n                strPairs.append(strNum[pairIndex:pairIndex + 2])\\n                \\n            print(strPairs)\\n                \\n            for pair in strPairs:\\n                print(pair)\\n                if pair[0] == pair[1]:\\n                    repeatedDigits += 1\\n\\t\\t\\t\\t\\tbreak\\n                \\n        return repeatedDigits\\n```\\n\\nLooking through other solutions it seems as though this problem is much more complicated than I thought it\\'d be. Maybe I misread the question but I seem to be missing numbers? This should check every integer up to N (inclusive) for matching twos but I can\\'t seem to figure it out.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numDupDigitsAtMostN(self, N):\\n\\n        \"123 --> [12] [23]\"\\n        \"1234 --> [12] [23] [34]\"\\n        \\n        repeatedDigits = 0\\n        \\n        for num in range(1, N + 1):\\n            strNum = str(num)\\n            numLen = len(strNum)\\n            \\n            strPairs = []\\n            \\n            for pairIndex in range(0, numLen - 1):\\n                strPairs.append(strNum[pairIndex:pairIndex + 2])\\n                \\n            print(strPairs)\\n                \\n            for pair in strPairs:\\n                print(pair)\\n                if pair[0] == pair[1]:\\n                    repeatedDigits += 1\\n\\t\\t\\t\\t\\tbreak\\n                \\n        return repeatedDigits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090260,
                "title": "c-o-logn-2-2-1-10-dummy-dp-solution-using-digit-dp-template-with-bitmask",
                "content": "Using basic digit DP template as the base of this solution. If you are not familiar with digit DP template, you can refer to LC357 https://leetcode.com/problems/count-numbers-with-unique-digits\\nor LC233 https://leetcode.com/problems/number-of-digit-one There are introduction to this technique that could solve this kind of \"digit count\" problem without using brain.\\n\\nThis solution uses limit, leadingZero label\\n\\nThe creative part of this solution is the bitMask to track the previous usage of numbers and a repeated label. The size of this bitMask is 1 << 10 since there are at most 10 numbers from 0 to 9. \\nso once we meet a number that has been in the bitMask, we toggle the repeated label to true. We only count the final state with repeated label = true.\\n\\nThen this problem becomes damn simple.\\n\\n```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        string n = to_string(N);\\n        vector<vector<vector<vector<int>>>> memo(n.size(), vector<vector<vector<int>>>(2, vector<vector<int>>(2, vector<int>(1 << 10, -1))));\\n        return dp(n, 0, 1, 1, 0, 0, memo);\\n    }\\n\\n    int dp(string& n, int idx, int limit, int leadingZero, int prevMask, int repeated, vector<vector<vector<vector<int>>>>& memo) {\\n        if (idx == n.size()) {\\n            return repeated == 1 ? 1 : 0;\\n        }\\n        if (memo[idx][limit][repeated][prevMask] != -1) {\\n            return memo[idx][limit][repeated][prevMask];\\n        }\\n        int upper = (limit == 1 ? n[idx] - \\'0\\' : 9);\\n        int sum = 0;\\n        for (int i = 0; i <= upper; i++) {\\n            bool rp = false;\\n            for (int j = 0; j <= upper; j++) {\\n                if (((1 << j) | prevMask) == prevMask && i == j) {\\n                    rp = true;\\n                    break;\\n                }\\n            }\\n            int zero = leadingZero == 1 && i == 0 ? 1 : 0;\\n            int new_prev = prevMask;\\n            if (zero != 1) {\\n                new_prev |= 1 << i;\\n            }\\n            sum += dp(n, idx + 1, limit == 1 && i == upper ? 1 : 0,\\n\\n                zero\\n\\n                , new_prev, repeated == 1 || rp ? 1 : 0, memo);\\n        }\\n        return memo[idx][limit][repeated][prevMask] = sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        string n = to_string(N);\\n        vector<vector<vector<vector<int>>>> memo(n.size(), vector<vector<vector<int>>>(2, vector<vector<int>>(2, vector<int>(1 << 10, -1))));\\n        return dp(n, 0, 1, 1, 0, 0, memo);\\n    }\\n\\n    int dp(string& n, int idx, int limit, int leadingZero, int prevMask, int repeated, vector<vector<vector<vector<int>>>>& memo) {\\n        if (idx == n.size()) {\\n            return repeated == 1 ? 1 : 0;\\n        }\\n        if (memo[idx][limit][repeated][prevMask] != -1) {\\n            return memo[idx][limit][repeated][prevMask];\\n        }\\n        int upper = (limit == 1 ? n[idx] - \\'0\\' : 9);\\n        int sum = 0;\\n        for (int i = 0; i <= upper; i++) {\\n            bool rp = false;\\n            for (int j = 0; j <= upper; j++) {\\n                if (((1 << j) | prevMask) == prevMask && i == j) {\\n                    rp = true;\\n                    break;\\n                }\\n            }\\n            int zero = leadingZero == 1 && i == 0 ? 1 : 0;\\n            int new_prev = prevMask;\\n            if (zero != 1) {\\n                new_prev |= 1 << i;\\n            }\\n            sum += dp(n, idx + 1, limit == 1 && i == upper ? 1 : 0,\\n\\n                zero\\n\\n                , new_prev, repeated == 1 || rp ? 1 : 0, memo);\\n        }\\n        return memo[idx][limit][repeated][prevMask] = sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073568,
                "title": "python-28ms-faster-than-85-81-probability-approach",
                "content": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        \\n        if N<=10:\\n            return 0\\n    \\n        Nd = len(str(N))\\n\\n        # Put the digits in a dictionary\\n        D = {i:int(v) for i,v in enumerate(str(N)[::-1])}            \\n        \\n        # Number of digits smaller or equal than the first digit\\n        Nsm={0:0}\\n        for v in list(D.values())[1:]:\\n            if v<= D[0]:\\n                Nsm[0]+=1\\n                \\n        # Number of digits smaller than the n-th digit\\n        for n in range(1,Nd-1):\\n            Nsm[n]=0\\n            for v in list(D.values())[n+1:]:\\n                if v<D[n]:\\n                    Nsm[n]+=1\\n\\n                    \\n        # Find unique numbers up to Nd\\n        c = 9\\n        total_sm = c\\n        for i in range(2,Nd):\\n            c *= (10-i+1)\\n            total_sm += c\\n\\n            \\n        # Counter for each digit\\n        cnt = {}\\n\\n        # Treat highest digit separately\\n        hi_cnt = D[Nd-1]-1\\n        for i in range(1,Nd):\\n            hi_cnt *= (10-i)            \\n        cnt[Nd-1] = hi_cnt\\n        \\n        # Digits between highest and lowest digit\\n        fmid = {}\\n        for i in range(1,Nd-1):\\n            f=1\\n            for d in range(1,i+1):\\n                f*=(10-Nd+d)\\n                \\n            # Need to account for not allowed values in case of duplicate digits\\n            fmid[i]=1\\n            if i<Nd-2:\\n                for k in range(i+1,Nd-1):\\n                    for m in range(k+1,Nd):\\n                        if D[k]==D[m]:\\n                            fmid[i] = 0\\n                            break\\n\\n            cnt[i] = fmid[i]*f*(D[i]-Nsm[i])\\n                        \\n            \\n        # Treat Lowest digit separately as well\\n        uf=1\\n        for d in range(1,Nd-1):\\n            for k in range(d+1,Nd):\\n                if D[d]==D[k]:\\n                    uf=0\\n                    break\\n        cnt[0] = uf*(D[0]+1 - Nsm[0])\\n        \\n        \\n        total_count = total_sm # Unique digits for numbers with lower #digits\\n        for d in range(Nd):\\n            total_count += cnt[d]\\n                        \\n        return N-total_count\\n    \\n ######################################################           \\n            \\n            \\n            \\n            \\n# \"Manual\" recursive way up to five digits, shows the pattern that is programmed above\\n#         if(Nd==2):\\n#             count = 9 + (D[1]-1)*9 + D[0]+1 - Nsm[0]\\n#         if(Nd==3):           \\n#             U0 = D[0]+1-Nsm[0] if D[1]!=D[2] else 0\\n#             count1 = 90\\n#             count2 = (D[2]-1)*9*8 + 8*(D[1]-Nsm[1])\\n#             count = count1 + count2 + U0\\n#         if(Nd==4):\\n#             U0 = D[0]+1-Nsm[0] if (D[1]!=D[2] and D[2]!=D[3]) else 0\\n#             U1 = 7*(D[1]-Nsm[1]) if D[2]!=D[3] else 0\\n            \\n#             count1 = 90\\n#             count2 = 8*9*8+8*9\\n#             count3 = (D[3]-1)*9*8*7 + 8*7*(D[2]-Nsm[2]) + U1 + U0\\n#             count = count1 + count2 + count3\\n#         if(Nd==5):\\n#             U0 = D[0]+1-Nsm[0] if (D[1]!=D[2] and D[1]!=D[3]  and D[1]!=D[4] and D[2]!=D[3] and D[2]!=D[4] and D[3]!=D[4]) else 0\\n#             U1 = 6*(D[1]-Nsm[1]) if (D[2]!=D[3] and D[2]!=D[4] and D[3]!=D[4]) else 0\\n#             U2 = 7*6*(D[2]-Nsm[2]) if D[3]!=D[4] else 0\\n            \\n#             count1 = 90\\n#             count2 = 8*9*8+8*9\\n#             count3 = 8*9*8*7 + 8*7*9\\n#             count = count1 + count2 + count3 + (D[4]-1)*9*8*7*6 + 8*7*6*(D[3]-Nsm[3]) + U2  + U1 + U0\\n#         else:\\n#             count=0\\n\\n#         return N-count\\n    \\n\\n# Brain-dead way, too slow\\n#         count = 0        \\n#         for i in range(10,N+1):\\n#             digits = list(str(i))\\n#             if len(digits) != len(set(digits)):\\n#                 count=count+1\\n\\n#         return count\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        \\n        if N<=10:\\n            return 0\\n    \\n        Nd = len(str(N))\\n\\n        # Put the digits in a dictionary\\n        D = {i:int(v) for i,v in enumerate(str(N)[::-1])}            \\n        \\n        # Number of digits smaller or equal than the first digit\\n        Nsm={0:0}\\n        for v in list(D.values())[1:]:\\n            if v<= D[0]:\\n                Nsm[0]+=1\\n                \\n        # Number of digits smaller than the n-th digit\\n        for n in range(1,Nd-1):\\n            Nsm[n]=0\\n            for v in list(D.values())[n+1:]:\\n                if v<D[n]:\\n                    Nsm[n]+=1\\n\\n                    \\n        # Find unique numbers up to Nd\\n        c = 9\\n        total_sm = c\\n        for i in range(2,Nd):\\n            c *= (10-i+1)\\n            total_sm += c\\n\\n            \\n        # Counter for each digit\\n        cnt = {}\\n\\n        # Treat highest digit separately\\n        hi_cnt = D[Nd-1]-1\\n        for i in range(1,Nd):\\n            hi_cnt *= (10-i)            \\n        cnt[Nd-1] = hi_cnt\\n        \\n        # Digits between highest and lowest digit\\n        fmid = {}\\n        for i in range(1,Nd-1):\\n            f=1\\n            for d in range(1,i+1):\\n                f*=(10-Nd+d)\\n                \\n            # Need to account for not allowed values in case of duplicate digits\\n            fmid[i]=1\\n            if i<Nd-2:\\n                for k in range(i+1,Nd-1):\\n                    for m in range(k+1,Nd):\\n                        if D[k]==D[m]:\\n                            fmid[i] = 0\\n                            break\\n\\n            cnt[i] = fmid[i]*f*(D[i]-Nsm[i])\\n                        \\n            \\n        # Treat Lowest digit separately as well\\n        uf=1\\n        for d in range(1,Nd-1):\\n            for k in range(d+1,Nd):\\n                if D[d]==D[k]:\\n                    uf=0\\n                    break\\n        cnt[0] = uf*(D[0]+1 - Nsm[0])\\n        \\n        \\n        total_count = total_sm # Unique digits for numbers with lower #digits\\n        for d in range(Nd):\\n            total_count += cnt[d]\\n                        \\n        return N-total_count\\n    \\n ######################################################           \\n            \\n            \\n            \\n            \\n# \"Manual\" recursive way up to five digits, shows the pattern that is programmed above\\n#         if(Nd==2):\\n#             count = 9 + (D[1]-1)*9 + D[0]+1 - Nsm[0]\\n#         if(Nd==3):           \\n#             U0 = D[0]+1-Nsm[0] if D[1]!=D[2] else 0\\n#             count1 = 90\\n#             count2 = (D[2]-1)*9*8 + 8*(D[1]-Nsm[1])\\n#             count = count1 + count2 + U0\\n#         if(Nd==4):\\n#             U0 = D[0]+1-Nsm[0] if (D[1]!=D[2] and D[2]!=D[3]) else 0\\n#             U1 = 7*(D[1]-Nsm[1]) if D[2]!=D[3] else 0\\n            \\n#             count1 = 90\\n#             count2 = 8*9*8+8*9\\n#             count3 = (D[3]-1)*9*8*7 + 8*7*(D[2]-Nsm[2]) + U1 + U0\\n#             count = count1 + count2 + count3\\n#         if(Nd==5):\\n#             U0 = D[0]+1-Nsm[0] if (D[1]!=D[2] and D[1]!=D[3]  and D[1]!=D[4] and D[2]!=D[3] and D[2]!=D[4] and D[3]!=D[4]) else 0\\n#             U1 = 6*(D[1]-Nsm[1]) if (D[2]!=D[3] and D[2]!=D[4] and D[3]!=D[4]) else 0\\n#             U2 = 7*6*(D[2]-Nsm[2]) if D[3]!=D[4] else 0\\n            \\n#             count1 = 90\\n#             count2 = 8*9*8+8*9\\n#             count3 = 8*9*8*7 + 8*7*9\\n#             count = count1 + count2 + count3 + (D[4]-1)*9*8*7*6 + 8*7*6*(D[3]-Nsm[3]) + U2  + U1 + U0\\n#         else:\\n#             count=0\\n\\n#         return N-count\\n    \\n\\n# Brain-dead way, too slow\\n#         count = 0        \\n#         for i in range(10,N+1):\\n#             digits = list(str(i))\\n#             if len(digits) != len(set(digits)):\\n#                 count=count+1\\n\\n#         return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980483,
                "title": "p23-5",
                "content": "Inclusio and exclusion\\nN- (all numbers from 1 to N which have no repating digits)\\nUse combinations\\nDebug exampl \\n335\\n1234\\n225\\nSay for above 335, when we have formed all numbers starting from less than 3(1,2,3)\\nthen we come to second 3, now again form all numbers(3x., x=0,1,2) now as soon as 33 is fixed, no new can be",
                "solutionTags": [],
                "code": "Inclusio and exclusion\\nN- (all numbers from 1 to N which have no repating digits)\\nUse combinations\\nDebug exampl \\n335\\n1234\\n225\\nSay for above 335, when we have formed all numbers starting from less than 3(1,2,3)\\nthen we come to second 3, now again form all numbers(3x., x=0,1,2) now as soon as 33 is fixed, no new can be",
                "codeTag": "Unknown"
            },
            {
                "id": 968620,
                "title": "count-numbers-with-unique-digits",
                "content": "Subtract from N possible numbers the count of numbers with unique digits.\\nThe code below will have explanation without loss of generailty to a number in\\nform of: ```abcd``` \\n```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        int len = 1, tens = 1;\\n\\t\\t//len(abcd)=4,tens(abcd)=1000\\n        for(int i = N; i > 9; i/=10, ++len){\\n            tens *= 10;\\n        }\\n        int ans = N;\\n\\t\\t//count unique(p)+unique(pq)+unique(pqr)\\n        for(int i = len-1; i > 0; --i){\\n            int cnt = 9, j = 9;\\n            for(int k = i-1; k > 0; --k, --j){\\n                cnt *= j;\\n            }\\n            ans -= cnt;\\n        }\\n\\t\\t//count unique(pqrs) where pqrs <= abcd\\n        //for a given prefix with unique digits, count all possible suffixes\\n        var pfx = new HashSet<Integer>();\\n        for(int i = N, l = len; tens > 0;i %= tens, tens /= 10, --l){\\n            //cnt represents the cnt of possible digits extending the prefix\\n            int cnt = i/tens-(i==N?1:0);//choice because first digit has no zero, but subsequents could have\\n            //pfx digits below current digit cannot be reused\\n            for(var j : pfx) cnt = Math.max(0,cnt-(j < i/tens ? 1 : 0));\\n            //initial subsequent digit range\\n            int j = Math.max(0,9-pfx.size());\\n            for(int k = l-1; k > 0; --k, --j){//pick choices for suffix\\n                cnt *= Math.max(0,j);\\n            }\\n            ans -= cnt;\\n            if (pfx.contains(i/tens)) break;//true if prefix has duplicate digit, no more solutions with this prefix\\n            pfx.add(i/tens);//extend the prefix, it still has unique digits\\n        }\\n        ans -= pfx.size() == len ? 1 : 0;//check if N itself has unique digits\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```abcd```\n```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        int len = 1, tens = 1;\\n\\t\\t//len(abcd)=4,tens(abcd)=1000\\n        for(int i = N; i > 9; i/=10, ++len){\\n            tens *= 10;\\n        }\\n        int ans = N;\\n\\t\\t//count unique(p)+unique(pq)+unique(pqr)\\n        for(int i = len-1; i > 0; --i){\\n            int cnt = 9, j = 9;\\n            for(int k = i-1; k > 0; --k, --j){\\n                cnt *= j;\\n            }\\n            ans -= cnt;\\n        }\\n\\t\\t//count unique(pqrs) where pqrs <= abcd\\n        //for a given prefix with unique digits, count all possible suffixes\\n        var pfx = new HashSet<Integer>();\\n        for(int i = N, l = len; tens > 0;i %= tens, tens /= 10, --l){\\n            //cnt represents the cnt of possible digits extending the prefix\\n            int cnt = i/tens-(i==N?1:0);//choice because first digit has no zero, but subsequents could have\\n            //pfx digits below current digit cannot be reused\\n            for(var j : pfx) cnt = Math.max(0,cnt-(j < i/tens ? 1 : 0));\\n            //initial subsequent digit range\\n            int j = Math.max(0,9-pfx.size());\\n            for(int k = l-1; k > 0; --k, --j){//pick choices for suffix\\n                cnt *= Math.max(0,j);\\n            }\\n            ans -= cnt;\\n            if (pfx.contains(i/tens)) break;//true if prefix has duplicate digit, no more solutions with this prefix\\n            pfx.add(i/tens);//extend the prefix, it still has unique digits\\n        }\\n        ans -= pfx.size() == len ? 1 : 0;//check if N itself has unique digits\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951416,
                "title": "js-solution-using-combinatorics",
                "content": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar numDupDigitsAtMostN = function(N) {\\n    \\n    let num = [];\\n    let n = N;\\n    while(N>0){\\n        num.unshift(N%10);\\n        N = Math.floor(N/10);\\n    }\\n    \\n    let digits = num.length;\\n    console.log(digits);\\n    let base = 0;\\n    let fac = 9;\\n    \\n    // Unique numbers of digits less than the number\\'s digits\\n    for(let d=9,i=1;i<digits;d--,i++){\\n        \\n        base+=fac;\\n        fac*=d;\\n        \\n    }\\n    \\n    \\n    // digits to the left of current digit (c) which are less than c\\n    let findOffSet = (arr,i)=>{\\n        \\n        let offSet = 0;\\n        arr.forEach((e)=>{\\n            \\n            offSet+=+(e<i);\\n        });\\n        \\n        return offSet;\\n    }\\n    \\n    let ans = base;\\n    base = 0;\\n    fac = 1;\\n    \\n    for(let i=num.length-1,d=10-digits+1;i>=0;i--,d++){\\n        \\n        let mySet = new Set(num.slice(0,i));\\n        \\n        // if the prefix has unique digits then proceed further otherwise skip iteration\\n        if(mySet.size == num.slice(0,i).length){\\n            \\n            let offSet = findOffSet(new Set(num.slice(0,i)), num[i]);\\n        \\n\\t\\t   if(i==0) // For leftMost Digit, remove digit \\'0\\' from the set of possible answers\\n               base = base+fac*(num[i]-1);\\n           else\\n            base = base+fac*(num[i]-offSet);     \\n        }\\n       \\n        \\n        \\n       fac*=d;\\n        \\n    }\\n    \\n    ans+=base;\\n    ans+=+((new Set(num)).size == num.length)   //whether the number N has unique digits\\n    return n-ans;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Combinatorics"
                ],
                "code": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar numDupDigitsAtMostN = function(N) {\\n    \\n    let num = [];\\n    let n = N;\\n    while(N>0){\\n        num.unshift(N%10);\\n        N = Math.floor(N/10);\\n    }\\n    \\n    let digits = num.length;\\n    console.log(digits);\\n    let base = 0;\\n    let fac = 9;\\n    \\n    // Unique numbers of digits less than the number\\'s digits\\n    for(let d=9,i=1;i<digits;d--,i++){\\n        \\n        base+=fac;\\n        fac*=d;\\n        \\n    }\\n    \\n    \\n    // digits to the left of current digit (c) which are less than c\\n    let findOffSet = (arr,i)=>{\\n        \\n        let offSet = 0;\\n        arr.forEach((e)=>{\\n            \\n            offSet+=+(e<i);\\n        });\\n        \\n        return offSet;\\n    }\\n    \\n    let ans = base;\\n    base = 0;\\n    fac = 1;\\n    \\n    for(let i=num.length-1,d=10-digits+1;i>=0;i--,d++){\\n        \\n        let mySet = new Set(num.slice(0,i));\\n        \\n        // if the prefix has unique digits then proceed further otherwise skip iteration\\n        if(mySet.size == num.slice(0,i).length){\\n            \\n            let offSet = findOffSet(new Set(num.slice(0,i)), num[i]);\\n        \\n\\t\\t   if(i==0) // For leftMost Digit, remove digit \\'0\\' from the set of possible answers\\n               base = base+fac*(num[i]-1);\\n           else\\n            base = base+fac*(num[i]-offSet);     \\n        }\\n       \\n        \\n        \\n       fac*=d;\\n        \\n    }\\n    \\n    ans+=base;\\n    ans+=+((new Set(num)).size == num.length)   //whether the number N has unique digits\\n    return n-ans;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866309,
                "title": "no-repeated-digit-two-situation-explanation",
                "content": "```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        // -> total numbers of no-repeated digits\\n        // N+1\\n        // eg. 8765 -> N+1 = 8766\\n        List<Integer> array = new ArrayList<>();\\n        for (int x=N+1; x>0; x/=10){\\n            array.add(x%10);\\n        }\\n        Collections.reverse(array);\\n        // 1. no-repeated numbers with less digits with N+1\\n        // XXX: 9*9*8\\n        // XX:  9*9\\n        // X:   9\\n        int res = 0;\\n        int n = array.size();\\n        for (int i=1; i<n; i++){ // i is the digits number\\n            res += 9*A(9,i-1);\\n        }\\n        // 2. no-repeated numbers(smaller than N+1) with same digits with N+1\\n        // (1~7)XXX: 9*8*7\\n        // 8(0~6)XX: 8*7\\n        // 87(0-5)X: 7\\n        // 876(0-5): 1\\n        Set<Integer> seen = new HashSet<>();\\n        for (int i=0; i<n; i++){\\n            int j = i==0?1:0;\\n            for (; j<array.get(i); j++){\\n                if (!seen.contains(j)){\\n                    res += A(9-i, n-i-1);\\n                }\\n            }\\n            if (!seen.add(array.get(i))){\\n                break;\\n            }\\n        }\\n        return N-res;\\n    }\\n    \\n    private int A(int n, int m){\\n        // n*(n-1)*...*(n-m+1)\\n        if (m==0) return 1;\\n        return A(n, m-1)*(n-m+1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        // -> total numbers of no-repeated digits\\n        // N+1\\n        // eg. 8765 -> N+1 = 8766\\n        List<Integer> array = new ArrayList<>();\\n        for (int x=N+1; x>0; x/=10){\\n            array.add(x%10);\\n        }\\n        Collections.reverse(array);\\n        // 1. no-repeated numbers with less digits with N+1\\n        // XXX: 9*9*8\\n        // XX:  9*9\\n        // X:   9\\n        int res = 0;\\n        int n = array.size();\\n        for (int i=1; i<n; i++){ // i is the digits number\\n            res += 9*A(9,i-1);\\n        }\\n        // 2. no-repeated numbers(smaller than N+1) with same digits with N+1\\n        // (1~7)XXX: 9*8*7\\n        // 8(0~6)XX: 8*7\\n        // 87(0-5)X: 7\\n        // 876(0-5): 1\\n        Set<Integer> seen = new HashSet<>();\\n        for (int i=0; i<n; i++){\\n            int j = i==0?1:0;\\n            for (; j<array.get(i); j++){\\n                if (!seen.contains(j)){\\n                    res += A(9-i, n-i-1);\\n                }\\n            }\\n            if (!seen.add(array.get(i))){\\n                break;\\n            }\\n        }\\n        return N-res;\\n    }\\n    \\n    private int A(int n, int m){\\n        // n*(n-1)*...*(n-m+1)\\n        if (m==0) return 1;\\n        return A(n, m-1)*(n-m+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841556,
                "title": "python-a-messy-bitmask-solution",
                "content": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        a = list(map(int, list(str(N))))\\n        b = sorted(a)\\n        a_is_distinct = True\\n        for i in range(1, len(b)):\\n            if b[i] == b[i - 1]:\\n                a_is_distinct = False\\n        def num_less_distinct(i, taken): #taken is a bitmask\\n            #there are 3 ways to build a number that is less than num:\\n            #1. copy first number a[i], then call num_less(i + 1)\\n            #2. choose first number from {0, .., a[i] - 1}, then free to choose the rest (9 - i) * (8 - i)*...()\\n            #3. #digits less than i\\n            if i == len(a):\\n                return 1 if a_is_distinct else 0\\n            res = 0\\n            \\n            #1\\n            if taken & (1 << a[i]):\\n                x = 0\\n            else:\\n                x = num_less_distinct(i + 1, taken + (1 << a[i]))\\n            #2\\n            first = 0\\n            for j in range(1 if i == 0 else 0, a[i]):\\n                if not (taken & (1 << j)):\\n                    first += 1\\n            y = first\\n            for j in range(i + 1, len(a)):\\n                y *= (10 - j)\\n            return x + y\\n        z = 0\\n        for k in range(1, len(a)):\\n            #k digits\\n            first = 9\\n            for i in range(1, k):\\n                first *= (10 - i)\\n            z += first\\n        return N - num_less_distinct(0, 0) - z\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        a = list(map(int, list(str(N))))\\n        b = sorted(a)\\n        a_is_distinct = True\\n        for i in range(1, len(b)):\\n            if b[i] == b[i - 1]:\\n                a_is_distinct = False\\n        def num_less_distinct(i, taken): #taken is a bitmask\\n            #there are 3 ways to build a number that is less than num:\\n            #1. copy first number a[i], then call num_less(i + 1)\\n            #2. choose first number from {0, .., a[i] - 1}, then free to choose the rest (9 - i) * (8 - i)*...()\\n            #3. #digits less than i\\n            if i == len(a):\\n                return 1 if a_is_distinct else 0\\n            res = 0\\n            \\n            #1\\n            if taken & (1 << a[i]):\\n                x = 0\\n            else:\\n                x = num_less_distinct(i + 1, taken + (1 << a[i]))\\n            #2\\n            first = 0\\n            for j in range(1 if i == 0 else 0, a[i]):\\n                if not (taken & (1 << j)):\\n                    first += 1\\n            y = first\\n            for j in range(i + 1, len(a)):\\n                y *= (10 - j)\\n            return x + y\\n        z = 0\\n        for k in range(1, len(a)):\\n            #k digits\\n            first = 9\\n            for i in range(1, k):\\n                first *= (10 - i)\\n            z += first\\n        return N - num_less_distinct(0, 0) - z\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825501,
                "title": "c-digit-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int n;\\n    vector<int> v;\\n    int dp[11][1025][2][2];\\n    \\n    int util(int i, int mask, int works, int less, int start){\\n        if(i>=n){\\n            if(works) return 1;\\n            else return 0;\\n        }\\n        if(dp[i][mask][works][less]!=-1) return dp[i][mask][works][less];\\n        int lim=less?9:v[i], ans=0;\\n        if(start){\\n            for(int dig=0; dig<=lim; dig++)\\n                ans+=util(i+1, mask|(1<<dig), works|((mask>>dig)&1), less|(dig<v[i]), 1);\\n        }\\n        else{\\n            for(int dig=1; dig<=lim; dig++)\\n                ans+=util(i+1, mask|(1<<dig), works|((mask>>dig)&1), less|(dig<v[i]), 1);\\n            ans+=util(i+1, mask, works, 1, 0);\\n        }\\n        return dp[i][mask][works][less]=ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int N) {\\n        while(N){\\n            v.push_back(N%10);\\n            N/=10;\\n        }\\n        reverse(v.begin(), v.end());\\n        n=v.size();\\n        memset(dp, -1, sizeof(dp));\\n        return util(0, 0, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int n;\\n    vector<int> v;\\n    int dp[11][1025][2][2];\\n    \\n    int util(int i, int mask, int works, int less, int start){\\n        if(i>=n){\\n            if(works) return 1;\\n            else return 0;\\n        }\\n        if(dp[i][mask][works][less]!=-1) return dp[i][mask][works][less];\\n        int lim=less?9:v[i], ans=0;\\n        if(start){\\n            for(int dig=0; dig<=lim; dig++)\\n                ans+=util(i+1, mask|(1<<dig), works|((mask>>dig)&1), less|(dig<v[i]), 1);\\n        }\\n        else{\\n            for(int dig=1; dig<=lim; dig++)\\n                ans+=util(i+1, mask|(1<<dig), works|((mask>>dig)&1), less|(dig<v[i]), 1);\\n            ans+=util(i+1, mask, works, 1, 0);\\n        }\\n        return dp[i][mask][works][less]=ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int N) {\\n        while(N){\\n            v.push_back(N%10);\\n            N/=10;\\n        }\\n        reverse(v.begin(), v.end());\\n        n=v.size();\\n        memset(dp, -1, sizeof(dp));\\n        return util(0, 0, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 739623,
                "title": "c-o-logn",
                "content": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        if(N < 10) return 0;\\n        int k = 0;\\n        for(int i = N; i > 0; i /= 10) k++;\\n        vector<int> digit(k, 0); \\n        for(int i = 0, j = N; i < k; i++, j /= 10) digit[k - 1 - i] = j % 10;\\n        \\n        int noDupBaseSum = 0;\\n        vector<int> noDupBase(k - 1, 0); \\n        for(int i = 0; i < k - 1; i++)\\n        {\\n            noDupBase[i] = i == 0 ? 9 : noDupBase[i - 1] * (10 - i);\\n            noDupBaseSum += noDupBase[i];\\n        }\\n        \\n        int count[10] = {0};\\n        vector<int> noDupRes(k, 0); \\n        \\n        bool duplicate = false;\\n        for(int i = 0; i < k; i++)\\n        {\\n            noDupRes[i] = i == 0 ? 9 : noDupRes[i - 1] * (10 - i);\\n            if(!duplicate)\\n            {\\n                int diff = 0;\\n                for(int j = digit[i] + 1; j < 10; j++) diff += count[j] == 0;\\n                noDupRes[i] -= diff;\\n                count[digit[i]]++;\\n                if(count[digit[i]] > 1) duplicate = true;\\n            }\\n        }\\n        return N - (noDupBaseSum + noDupRes[k - 1]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        if(N < 10) return 0;\\n        int k = 0;\\n        for(int i = N; i > 0; i /= 10) k++;\\n        vector<int> digit(k, 0); \\n        for(int i = 0, j = N; i < k; i++, j /= 10) digit[k - 1 - i] = j % 10;\\n        \\n        int noDupBaseSum = 0;\\n        vector<int> noDupBase(k - 1, 0); \\n        for(int i = 0; i < k - 1; i++)\\n        {\\n            noDupBase[i] = i == 0 ? 9 : noDupBase[i - 1] * (10 - i);\\n            noDupBaseSum += noDupBase[i];\\n        }\\n        \\n        int count[10] = {0};\\n        vector<int> noDupRes(k, 0); \\n        \\n        bool duplicate = false;\\n        for(int i = 0; i < k; i++)\\n        {\\n            noDupRes[i] = i == 0 ? 9 : noDupRes[i - 1] * (10 - i);\\n            if(!duplicate)\\n            {\\n                int diff = 0;\\n                for(int j = digit[i] + 1; j < 10; j++) diff += count[j] == 0;\\n                noDupRes[i] -= diff;\\n                count[digit[i]]++;\\n                if(count[digit[i]] > 1) duplicate = true;\\n            }\\n        }\\n        return N - (noDupBaseSum + noDupRes[k - 1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706450,
                "title": "c-dfs",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint count=0;\\n\\t\\tint permu(int M, int N)\\n\\t\\t{\\n\\t\\t\\tint res=1;\\n\\t\\t\\tfor(int i=0;i<N;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tres*=M;\\n\\t\\t\\t\\tM--; \\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tvoid dfs(vector<int>& num, vector<int>& digit, int cur)\\n\\t\\t{\\n\\t\\t\\tif(cur>=num.size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=0;i<=9;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i==0 && cur==0) continue;\\n\\t\\t\\t\\tif(i<num[cur])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(digit[i]==1) continue;\\n\\t\\t\\t\\t\\tint av=0;\\n\\t\\t\\t\\t\\tfor(auto& x:digit)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(x==0)\\n\\t\\t\\t\\t\\t\\t\\tav++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcount+=permu(av-1,num.size()-cur-1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(digit[i]==1) continue;\\n\\t\\t\\t\\t\\tif(i==num[cur])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdigit[i]=1;\\n\\t\\t\\t\\t\\t\\tdfs(num,digit,cur+1);\\n\\t\\t\\t\\t\\t\\tdigit[i]=0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint numDupDigitsAtMostN(int N) {\\n\\t\\t\\tif(N<=10) return 0;\\n\\t\\t\\tvector<int> num;\\n\\t\\t\\tint n=N;\\n\\t\\t\\twhile(n>0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnum.push_back(n%10);\\n\\t\\t\\t\\tn/=10;\\n\\t\\t\\t}\\n\\t\\t\\treverse(num.begin(),num.end());\\n\\n\\t\\t\\tint len=num.size();\\n\\t\\t\\tfor(int i=1;i<len-1;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount+=9*permu(9,i);\\n\\t\\t\\t}\\n\\t\\t\\tcount+=9;\\n\\t\\t\\tvector<int> digit(10);\\n\\t\\t\\tdfs(num,digit,0);\\n\\t\\t\\treturn N-count; \\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint count=0;\\n\\t\\tint permu(int M, int N)\\n\\t\\t{\\n\\t\\t\\tint res=1;\\n\\t\\t\\tfor(int i=0;i<N;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tres*=M;\\n\\t\\t\\t\\tM--; \\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 705053,
                "title": "python-solution",
                "content": "```python\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        # N -> total numbers less than or equal to N\\n        # We will calculate the integers with all different digits (which are less than/equal to N)\\n        # Then the answer would be: N - nums_with_different_digits\\n        \\n        # Calculate the number of digits in N\\n        NN, dd = N, 0\\n        nums = [] # store the digits\\n        while(NN):\\n            dd += 1\\n            nums.append(NN % 10)\\n            NN //= 10\\n        nums.reverse()\\n        \\n        \\n        # numbers with less digits than that of N\\n        numbers = 0\\n        for i in range(dd-1):\\n            numbers += 9 * (math.factorial(9) // math.factorial(9-i))\\n        \\n        \\n        # find the N-digit numbers (all-different)\\n        already_visited_digits = set()\\n        \\n        def fac2(n, k):\\n            return math.factorial(n) // math.factorial(n-k)\\n        \\n        for i,n in enumerate(nums):\\n            k = 0\\n            for j in range((1 if i==0 else 0), (n+1 if i==dd-1 else n)):\\n                if(j in already_visited_digits):\\n                    continue\\n                k += 1\\n            numbers += k * fac2(10-i-1, dd-i-1)\\n            if n in already_visited_digits:\\n                # All the numbers with this prefix will have at least one common digit\\n                break\\n            already_visited_digits.add(n)\\n            \\n        return N - numbers\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        # N -> total numbers less than or equal to N\\n        # We will calculate the integers with all different digits (which are less than/equal to N)\\n        # Then the answer would be: N - nums_with_different_digits\\n        \\n        # Calculate the number of digits in N\\n        NN, dd = N, 0\\n        nums = [] # store the digits\\n        while(NN):\\n            dd += 1\\n            nums.append(NN % 10)\\n            NN //= 10\\n        nums.reverse()\\n        \\n        \\n        # numbers with less digits than that of N\\n        numbers = 0\\n        for i in range(dd-1):\\n            numbers += 9 * (math.factorial(9) // math.factorial(9-i))\\n        \\n        \\n        # find the N-digit numbers (all-different)\\n        already_visited_digits = set()\\n        \\n        def fac2(n, k):\\n            return math.factorial(n) // math.factorial(n-k)\\n        \\n        for i,n in enumerate(nums):\\n            k = 0\\n            for j in range((1 if i==0 else 0), (n+1 if i==dd-1 else n)):\\n                if(j in already_visited_digits):\\n                    continue\\n                k += 1\\n            numbers += k * fac2(10-i-1, dd-i-1)\\n            if n in already_visited_digits:\\n                # All the numbers with this prefix will have at least one common digit\\n                break\\n            already_visited_digits.add(n)\\n            \\n        return N - numbers\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 690339,
                "title": "digit-dp-solution-5d-dp-time-o-2-2-2-1024-10",
                "content": "# Time complexity - O(2 * 2 * 2 * 1024 * 10)\\n# DP- STATES:\\n* ***st*** - keep track of leading zeros so that we dont count them\\n* ***i*** - current position\\n* ***tight*** - upper limit of value to be put in the ith palce\\n* ***repeated*** - True if we found repeating element\\n* ***element*** - A mask stores value from 0-9. Set ith bit if it is found.\\n\\n```python\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        A = [i for i in str(N)]\\n        dp = [[[[[-1 for i in range(2)] for j in range(2)] for k in range(2)] for l in range((1<<10) + 1)] for m in range(10)]\\n        \\n        def digits(S,i,tight,repeated,element,st):\\n            if i == len(S):\\n                return repeated\\n            if dp[i][element][repeated][tight][st] != -1: return dp[i][element][repeated][tight][st]\\n            res = 0\\n            if tight == 1:\\n                till = ord(S[i]) - ord(\\'0\\')\\n                for j in range(till + 1):\\n                    nst = j != 0 or st > 0\\n                    nrepeated = True if (((element & (1 << j)) > 0) and st > 0) else repeated\\n                    nelement = (element | (1 << j)) if nst else element\\n                    if j == till:\\n                        res += digits(S, i+1, 1,nrepeated,nelement,nst)\\n                    else:\\n                        res += digits(S, i+1, 0, nrepeated,nelement,nst)\\n            else:\\n                for j in range(10):\\n                    nst = j != 0 or st > 0\\n                    nrepeated = True if (((element & (1 << j)) > 0) and st > 0) else repeated\\n                    nelement = (element | (1 << j)) if nst else element\\n                    res += digits(S, i+1, 0,nrepeated,nelement,nst)\\n            dp[i][element][repeated][tight][st] = res\\n            return dp[i][element][repeated][tight][st]\\n        ans = digits(A,0,1,False,0,0)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        A = [i for i in str(N)]\\n        dp = [[[[[-1 for i in range(2)] for j in range(2)] for k in range(2)] for l in range((1<<10) + 1)] for m in range(10)]\\n        \\n        def digits(S,i,tight,repeated,element,st):\\n            if i == len(S):\\n                return repeated\\n            if dp[i][element][repeated][tight][st] != -1: return dp[i][element][repeated][tight][st]\\n            res = 0\\n            if tight == 1:\\n                till = ord(S[i]) - ord(\\'0\\')\\n                for j in range(till + 1):\\n                    nst = j != 0 or st > 0\\n                    nrepeated = True if (((element & (1 << j)) > 0) and st > 0) else repeated\\n                    nelement = (element | (1 << j)) if nst else element\\n                    if j == till:\\n                        res += digits(S, i+1, 1,nrepeated,nelement,nst)\\n                    else:\\n                        res += digits(S, i+1, 0, nrepeated,nelement,nst)\\n            else:\\n                for j in range(10):\\n                    nst = j != 0 or st > 0\\n                    nrepeated = True if (((element & (1 << j)) > 0) and st > 0) else repeated\\n                    nelement = (element | (1 << j)) if nst else element\\n                    res += digits(S, i+1, 0,nrepeated,nelement,nst)\\n            dp[i][element][repeated][tight][st] = res\\n            return dp[i][element][repeated][tight][st]\\n        ans = digits(A,0,1,False,0,0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 664081,
                "title": "c-o-log-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(int s,int re){\\n        if(re==0) return 1;\\n        return (s-re+1)*fun(s,re-1);\\n    }\\n    int numDupDigitsAtMostN(int N) {\\n        int ans=0,dig=0;\\n        for(int i=N+1;i>0;i/=10){\\n            dig++;\\n        }\\n        for(int i=1;i<dig;i++){\\n            ans+=9*fun(9,i-1);\\n        }\\n        //cout<<ans;\\n        vector<int> vec;\\n        int t=N+1;\\n        while(t){\\n            vec.push_back(t%10);\\n            t/=10;\\n        }\\n        reverse(vec.begin(),vec.end());\\n        set<int> st;\\n        for(int i=0;i<vec.size();i++){\\n            //cout<<vec[i]<<\" \";\\n            for(int j=((i>0) ? 0 : 1) ;j<vec[i];j++){\\n                if(st.find(j)==st.end()){\\n                    //cout<<vec[i]<<\" \"<<j<<endl;\\n                ans+=fun(9-i,vec.size()-1-i);}\\n            }\\n            if(st.find(vec[i])!=st.end()){\\n                break;\\n            }\\n            st.insert(vec[i]);\\n        }\\n        return N-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(int s,int re){\\n        if(re==0) return 1;\\n        return (s-re+1)*fun(s,re-1);\\n    }\\n    int numDupDigitsAtMostN(int N) {\\n        int ans=0,dig=0;\\n        for(int i=N+1;i>0;i/=10){\\n            dig++;\\n        }\\n        for(int i=1;i<dig;i++){\\n            ans+=9*fun(9,i-1);\\n        }\\n        //cout<<ans;\\n        vector<int> vec;\\n        int t=N+1;\\n        while(t){\\n            vec.push_back(t%10);\\n            t/=10;\\n        }\\n        reverse(vec.begin(),vec.end());\\n        set<int> st;\\n        for(int i=0;i<vec.size();i++){\\n            //cout<<vec[i]<<\" \";\\n            for(int j=((i>0) ? 0 : 1) ;j<vec[i];j++){\\n                if(st.find(j)==st.end()){\\n                    //cout<<vec[i]<<\" \"<<j<<endl;\\n                ans+=fun(9-i,vec.size()-1-i);}\\n            }\\n            if(st.find(vec[i])!=st.end()){\\n                break;\\n            }\\n            st.insert(vec[i]);\\n        }\\n        return N-ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 648838,
                "title": "c-recursive-100-speed-and-memory-beat",
                "content": "Caculate all permutations less or equal to number N, then substract it from N is the right answer.\\ncurSum returns the permutations number with begin available option with start, digits number with len, whether all formers are zero with allZero.\\n\\n```\\nclass Solution {\\nprivate:\\n    int curSum(int start, int len, bool allZero) {\\n        if (len == 1) {\\n            if (allZero) {\\n                return 9;\\n            } else {\\n                return start;\\n            }\\n        }\\n        if (allZero) {\\n            return curSum(10, len-1, true) + 9 * curSum(9, len-1, false);\\n        } else {\\n            return start * curSum(start - 1, len-1, false);\\n        }\\n    }\\n    \\n    int helper(unordered_set<int> used, string s) {\\n       if (s.size() == 1) {\\n            int temp = 0;\\n            for (int i = 0; i < 10; i++) {\\n                if (used.find(i) == used.end()) {\\n                    if (i < s[0] - \\'0\\')\\n                        temp++;\\n                }\\n            }\\n            return temp;\\n        }\\n\\n        int len = s.size(), top = s[0] - \\'0\\';\\n        int curNums = 0;\\n        for (int i = 0; i < top; i++) {\\n            if (used.find(i) == used.end()) {\\n                curNums += curSum(9 - used.size(), len - 1, false);\\n            }\\n        }\\n\\n        string nextStr = s.substr(1);\\n        if (nextStr.size() == 0 || (used.find(top) != used.end())) {\\n            return curNums;\\n        }\\n        used.insert(top);\\n        curNums += helper(used, nextStr);\\n        return curNums;\\n    }\\n    \\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        string s = to_string(N);\\n        int cnt[10] = {0};\\n        bool repeat = false;\\n        for (auto c: s) {\\n            if (cnt[c - \\'0\\']) {\\n                repeat = true;\\n                break;\\n            }\\n            cnt[c - \\'0\\']++;\\n        }\\n        unordered_set<int> used;\\n        int len = s.size(), top = s[0] - \\'0\\';\\n        if (len == 1) {\\n            return 0;\\n        }\\n        int curNums = 0;\\n        for (int i = 0; i < top; i++) {\\n            curNums += curSum(9, len - 1, i == 0);\\n        }\\n        used.insert(top);\\n        curNums += helper(used, s.substr(1));\\n        return N - curNums - (repeat == false? 1 : 0);\\n    }\\n};\\n\\n\\n/*\\n\\n100:\\n    \\n    [0,1], {}\\n    0: 10*9\\n    1: xx, \\n\\n123:\\n    [0,1], {}\\n    0: 10 * 9\\n    1: xx {1}\\n        [0, 2]\\n        10: 8\\n        12: 2\\n\\n2234:\\n    [0, 1, 2], {}\\n    0: 10 * 9 * 8 {0}\\n    1: 9 * 8 * 7  {1}\\n    2: xxx {2}\\n        [0, 1]    {2}\\n        20: 8*7   {2,0}\\n        21: 8*7   {2,1}\\n        22: 0     {2}\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int curSum(int start, int len, bool allZero) {\\n        if (len == 1) {\\n            if (allZero) {\\n                return 9;\\n            } else {\\n                return start;\\n            }\\n        }\\n        if (allZero) {\\n            return curSum(10, len-1, true) + 9 * curSum(9, len-1, false);\\n        } else {\\n            return start * curSum(start - 1, len-1, false);\\n        }\\n    }\\n    \\n    int helper(unordered_set<int> used, string s) {\\n       if (s.size() == 1) {\\n            int temp = 0;\\n            for (int i = 0; i < 10; i++) {\\n                if (used.find(i) == used.end()) {\\n                    if (i < s[0] - \\'0\\')\\n                        temp++;\\n                }\\n            }\\n            return temp;\\n        }\\n\\n        int len = s.size(), top = s[0] - \\'0\\';\\n        int curNums = 0;\\n        for (int i = 0; i < top; i++) {\\n            if (used.find(i) == used.end()) {\\n                curNums += curSum(9 - used.size(), len - 1, false);\\n            }\\n        }\\n\\n        string nextStr = s.substr(1);\\n        if (nextStr.size() == 0 || (used.find(top) != used.end())) {\\n            return curNums;\\n        }\\n        used.insert(top);\\n        curNums += helper(used, nextStr);\\n        return curNums;\\n    }\\n    \\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        string s = to_string(N);\\n        int cnt[10] = {0};\\n        bool repeat = false;\\n        for (auto c: s) {\\n            if (cnt[c - \\'0\\']) {\\n                repeat = true;\\n                break;\\n            }\\n            cnt[c - \\'0\\']++;\\n        }\\n        unordered_set<int> used;\\n        int len = s.size(), top = s[0] - \\'0\\';\\n        if (len == 1) {\\n            return 0;\\n        }\\n        int curNums = 0;\\n        for (int i = 0; i < top; i++) {\\n            curNums += curSum(9, len - 1, i == 0);\\n        }\\n        used.insert(top);\\n        curNums += helper(used, s.substr(1));\\n        return N - curNums - (repeat == false? 1 : 0);\\n    }\\n};\\n\\n\\n/*\\n\\n100:\\n    \\n    [0,1], {}\\n    0: 10*9\\n    1: xx, \\n\\n123:\\n    [0,1], {}\\n    0: 10 * 9\\n    1: xx {1}\\n        [0, 2]\\n        10: 8\\n        12: 2\\n\\n2234:\\n    [0, 1, 2], {}\\n    0: 10 * 9 * 8 {0}\\n    1: 9 * 8 * 7  {1}\\n    2: xxx {2}\\n        [0, 1]    {2}\\n        20: 8*7   {2,0}\\n        21: 8*7   {2,1}\\n        22: 0     {2}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645759,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int dp[10][1<<10][2][2];\\n    string no;\\n    int n;\\n    int kil(int idx, int digits, int isRepeated, int isSmall){\\n        if(idx == n){\\n            if(isRepeated)\\n                return 1;\\n            return 0;\\n        }\\n\\n        if(dp[idx][digits][isRepeated][isSmall] != -1)\\n            return dp[idx][digits][isRepeated][isSmall];\\n\\n        dp[idx][digits][isRepeated][isSmall] = 0;\\n\\n        if(isSmall){\\n            for(int i=0;i<=9;i++){\\n                int ndigits = (digits | (1<<i));\\n                int repeat = ((digits & (1<<i)) || isRepeated);\\n                dp[idx][digits][isRepeated][isSmall] += kil(idx+1, ndigits, repeat, isSmall);\\n            }\\n        }else{\\n            int upper = no[idx]-\\'0\\';\\n            for(int i=upper;i>=0;i--){\\n                int ndigits = (digits | (1<<i));\\n                int repeat = ((digits & (1<<i)) || isRepeated);\\n                dp[idx][digits][isRepeated][isSmall] += kil(idx+1, ndigits, repeat, (i == upper) ? 0 : 1);\\n            }\\n        }\\n        return dp[idx][digits][isRepeated][isSmall];\\n    }\\n    int numDupDigitsAtMostN(int N) {\\n        while(N){\\n            no += N%10 + \\'0\\';\\n            N /= 10;\\n        }\\n        reverse(no.begin(), no.end());\\n        int ans  = 0;\\n        for(int len=2;len<=no.size();len++){\\n            memset(dp, -1, sizeof dp);\\n            n = len;\\n            if(len == no.size()){\\n                for(int i=no[0]-\\'0\\';i>0;i--){\\n                    int ndigits = (1<<i);\\n                    ans += kil(1, ndigits, 0, (i == no[0]-\\'0\\') ? 0 : 1);\\n                }\\n            }else{\\n                for(int i=9;i>0;i--){\\n                    int ndigits = (1<<i);\\n                    ans += kil(1, ndigits, 0, 1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[10][1<<10][2][2];\\n    string no;\\n    int n;\\n    int kil(int idx, int digits, int isRepeated, int isSmall){\\n        if(idx == n){\\n            if(isRepeated)\\n                return 1;\\n            return 0;\\n        }\\n\\n        if(dp[idx][digits][isRepeated][isSmall] != -1)\\n            return dp[idx][digits][isRepeated][isSmall];\\n\\n        dp[idx][digits][isRepeated][isSmall] = 0;\\n\\n        if(isSmall){\\n            for(int i=0;i<=9;i++){\\n                int ndigits = (digits | (1<<i));\\n                int repeat = ((digits & (1<<i)) || isRepeated);\\n                dp[idx][digits][isRepeated][isSmall] += kil(idx+1, ndigits, repeat, isSmall);\\n            }\\n        }else{\\n            int upper = no[idx]-\\'0\\';\\n            for(int i=upper;i>=0;i--){\\n                int ndigits = (digits | (1<<i));\\n                int repeat = ((digits & (1<<i)) || isRepeated);\\n                dp[idx][digits][isRepeated][isSmall] += kil(idx+1, ndigits, repeat, (i == upper) ? 0 : 1);\\n            }\\n        }\\n        return dp[idx][digits][isRepeated][isSmall];\\n    }\\n    int numDupDigitsAtMostN(int N) {\\n        while(N){\\n            no += N%10 + \\'0\\';\\n            N /= 10;\\n        }\\n        reverse(no.begin(), no.end());\\n        int ans  = 0;\\n        for(int len=2;len<=no.size();len++){\\n            memset(dp, -1, sizeof dp);\\n            n = len;\\n            if(len == no.size()){\\n                for(int i=no[0]-\\'0\\';i>0;i--){\\n                    int ndigits = (1<<i);\\n                    ans += kil(1, ndigits, 0, (i == no[0]-\\'0\\') ? 0 : 1);\\n                }\\n            }else{\\n                for(int i=9;i>0;i--){\\n                    int ndigits = (1<<i);\\n                    ans += kil(1, ndigits, 0, 1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 619284,
                "title": "scala-dfs-with-memorization-o-2048lgn-with-digit-state",
                "content": "```\\nobject Solution {\\n  def numDupDigitsAtMostN(N: Int): Int = {\\n    val str: String = N.toString\\n    val len: Int = str.length\\n    var ans: Int = 0\\n    val memo = Array.fill(len, 1 << 10, 2)(-1)\\n    for {\\n      i <- 1 to (str(0) - \\'0\\')\\n    } {\\n      if(i < str(0) - \\'0\\') {\\n        ans += helper(1, len, 0, str, (1 << i), memo)\\n      }\\n      else if(i == str(0) - \\'0\\') {\\n        ans += helper(1, len, 1, str, (1 << i), memo)\\n      }\\n    }\\n    var nei: Int = 0\\n    for {\\n      k <- len - 1 to 1 by -1 if k > 0\\n    } {\\n      nei += A(9, k) + (k - 1) * A(9, k - 1)\\n    }\\n    N - ans - nei\\n  }\\n\\n  def A(n: Int, m: Int): Int = {\\n    if(m > n) return 0\\n    var ans: Int = 1\\n    var i: Int = n\\n    while(i >= (n - m + 1)) {\\n      ans *= i\\n      i -= 1\\n    }\\n    return ans\\n  }\\n\\n  def helper(ind: Int, len: Int, rb: Int, str: String, state: Int, memo: Array[Array[Array[Int]]]): Int = {\\n    if(ind >= len) return 1\\n    if(memo(ind)(state)(rb) > 0) return memo(ind)(state)(rb)\\n    val upper: Int = (if(rb == 1){str(ind) - \\'0\\'}else {9})\\n    var ret: Int = 0\\n    for {\\n      i <- 0 to upper\\n    } {\\n      if((state & (1 << i)) == 0) {\\n        ret += helper(ind + 1, len, (if(rb == 1 && i == upper) {1} else {0}), str, (state | (1 << i)), memo)\\n      }\\n    }\\n    memo(ind)(state)(rb) = ret\\n    return ret\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n  def numDupDigitsAtMostN(N: Int): Int = {\\n    val str: String = N.toString\\n    val len: Int = str.length\\n    var ans: Int = 0\\n    val memo = Array.fill(len, 1 << 10, 2)(-1)\\n    for {\\n      i <- 1 to (str(0) - \\'0\\')\\n    } {\\n      if(i < str(0) - \\'0\\') {\\n        ans += helper(1, len, 0, str, (1 << i), memo)\\n      }\\n      else if(i == str(0) - \\'0\\') {\\n        ans += helper(1, len, 1, str, (1 << i), memo)\\n      }\\n    }\\n    var nei: Int = 0\\n    for {\\n      k <- len - 1 to 1 by -1 if k > 0\\n    } {\\n      nei += A(9, k) + (k - 1) * A(9, k - 1)\\n    }\\n    N - ans - nei\\n  }\\n\\n  def A(n: Int, m: Int): Int = {\\n    if(m > n) return 0\\n    var ans: Int = 1\\n    var i: Int = n\\n    while(i >= (n - m + 1)) {\\n      ans *= i\\n      i -= 1\\n    }\\n    return ans\\n  }\\n\\n  def helper(ind: Int, len: Int, rb: Int, str: String, state: Int, memo: Array[Array[Array[Int]]]): Int = {\\n    if(ind >= len) return 1\\n    if(memo(ind)(state)(rb) > 0) return memo(ind)(state)(rb)\\n    val upper: Int = (if(rb == 1){str(ind) - \\'0\\'}else {9})\\n    var ret: Int = 0\\n    for {\\n      i <- 0 to upper\\n    } {\\n      if((state & (1 << i)) == 0) {\\n        ret += helper(ind + 1, len, (if(rb == 1 && i == upper) {1} else {0}), str, (state | (1 << i)), memo)\\n      }\\n    }\\n    memo(ind)(state)(rb) = ret\\n    return ret\\n  }\\n}\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1566855,
                "content": [
                    {
                        "username": "mengpq",
                        "content": "https://youtu.be/_Zxsa37aVeo\\n\\n1012: O(log(N))\\n1013: constants time\\n1014: O(N * log(sum)) where sum is the total weight.\\n1015: O(L) where L is the number of digit of N."
                    },
                    {
                        "username": "igbgotiz",
                        "content": "Can someone clarify what this question means by \"repeated digits\"?\\n\\nFor example, the number 101 has the digit \"1\" repeated twice, so it has repeated digits.\\n\\nBut in the question examples, all examples of qualifying numbers have consecutive repeated digits, so I was wondering if anyone could clarify."
                    },
                    {
                        "username": "abednego",
                        "content": "Does the number 101 have repeated digits? All of the examples have the digits repeating consecutively."
                    },
                    {
                        "username": "tonghuikang",
                        "content": "https://stackoverflow.com/a/13249899 offers a solution, a simple modification is sufficient to provide the answer to the last question.\\n\\nWhat are the rules regarding copying code? Where can you copy code from? How does leetcode detect plagiarism?"
                    },
                    {
                        "username": "sohelH",
                        "content": "My first submission got time limit exceeded for the input 896089023. When I tested my code with this input in the editor, it was producing the output in 220 ms."
                    }
                ]
            },
            {
                "id": 1569459,
                "content": [
                    {
                        "username": "mengpq",
                        "content": "https://youtu.be/_Zxsa37aVeo\\n\\n1012: O(log(N))\\n1013: constants time\\n1014: O(N * log(sum)) where sum is the total weight.\\n1015: O(L) where L is the number of digit of N."
                    },
                    {
                        "username": "igbgotiz",
                        "content": "Can someone clarify what this question means by \"repeated digits\"?\\n\\nFor example, the number 101 has the digit \"1\" repeated twice, so it has repeated digits.\\n\\nBut in the question examples, all examples of qualifying numbers have consecutive repeated digits, so I was wondering if anyone could clarify."
                    },
                    {
                        "username": "abednego",
                        "content": "Does the number 101 have repeated digits? All of the examples have the digits repeating consecutively."
                    },
                    {
                        "username": "tonghuikang",
                        "content": "https://stackoverflow.com/a/13249899 offers a solution, a simple modification is sufficient to provide the answer to the last question.\\n\\nWhat are the rules regarding copying code? Where can you copy code from? How does leetcode detect plagiarism?"
                    },
                    {
                        "username": "sohelH",
                        "content": "My first submission got time limit exceeded for the input 896089023. When I tested my code with this input in the editor, it was producing the output in 220 ms."
                    }
                ]
            },
            {
                "id": 1573235,
                "content": [
                    {
                        "username": "mengpq",
                        "content": "https://youtu.be/_Zxsa37aVeo\\n\\n1012: O(log(N))\\n1013: constants time\\n1014: O(N * log(sum)) where sum is the total weight.\\n1015: O(L) where L is the number of digit of N."
                    },
                    {
                        "username": "igbgotiz",
                        "content": "Can someone clarify what this question means by \"repeated digits\"?\\n\\nFor example, the number 101 has the digit \"1\" repeated twice, so it has repeated digits.\\n\\nBut in the question examples, all examples of qualifying numbers have consecutive repeated digits, so I was wondering if anyone could clarify."
                    },
                    {
                        "username": "abednego",
                        "content": "Does the number 101 have repeated digits? All of the examples have the digits repeating consecutively."
                    },
                    {
                        "username": "tonghuikang",
                        "content": "https://stackoverflow.com/a/13249899 offers a solution, a simple modification is sufficient to provide the answer to the last question.\\n\\nWhat are the rules regarding copying code? Where can you copy code from? How does leetcode detect plagiarism?"
                    },
                    {
                        "username": "sohelH",
                        "content": "My first submission got time limit exceeded for the input 896089023. When I tested my code with this input in the editor, it was producing the output in 220 ms."
                    }
                ]
            },
            {
                "id": 1569457,
                "content": [
                    {
                        "username": "mengpq",
                        "content": "https://youtu.be/_Zxsa37aVeo\\n\\n1012: O(log(N))\\n1013: constants time\\n1014: O(N * log(sum)) where sum is the total weight.\\n1015: O(L) where L is the number of digit of N."
                    },
                    {
                        "username": "igbgotiz",
                        "content": "Can someone clarify what this question means by \"repeated digits\"?\\n\\nFor example, the number 101 has the digit \"1\" repeated twice, so it has repeated digits.\\n\\nBut in the question examples, all examples of qualifying numbers have consecutive repeated digits, so I was wondering if anyone could clarify."
                    },
                    {
                        "username": "abednego",
                        "content": "Does the number 101 have repeated digits? All of the examples have the digits repeating consecutively."
                    },
                    {
                        "username": "tonghuikang",
                        "content": "https://stackoverflow.com/a/13249899 offers a solution, a simple modification is sufficient to provide the answer to the last question.\\n\\nWhat are the rules regarding copying code? Where can you copy code from? How does leetcode detect plagiarism?"
                    },
                    {
                        "username": "sohelH",
                        "content": "My first submission got time limit exceeded for the input 896089023. When I tested my code with this input in the editor, it was producing the output in 220 ms."
                    }
                ]
            },
            {
                "id": 1572531,
                "content": [
                    {
                        "username": "mengpq",
                        "content": "https://youtu.be/_Zxsa37aVeo\\n\\n1012: O(log(N))\\n1013: constants time\\n1014: O(N * log(sum)) where sum is the total weight.\\n1015: O(L) where L is the number of digit of N."
                    },
                    {
                        "username": "igbgotiz",
                        "content": "Can someone clarify what this question means by \"repeated digits\"?\\n\\nFor example, the number 101 has the digit \"1\" repeated twice, so it has repeated digits.\\n\\nBut in the question examples, all examples of qualifying numbers have consecutive repeated digits, so I was wondering if anyone could clarify."
                    },
                    {
                        "username": "abednego",
                        "content": "Does the number 101 have repeated digits? All of the examples have the digits repeating consecutively."
                    },
                    {
                        "username": "tonghuikang",
                        "content": "https://stackoverflow.com/a/13249899 offers a solution, a simple modification is sufficient to provide the answer to the last question.\\n\\nWhat are the rules regarding copying code? Where can you copy code from? How does leetcode detect plagiarism?"
                    },
                    {
                        "username": "sohelH",
                        "content": "My first submission got time limit exceeded for the input 896089023. When I tested my code with this input in the editor, it was producing the output in 220 ms."
                    }
                ]
            }
        ]
    }
]