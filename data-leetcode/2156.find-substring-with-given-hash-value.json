[
    {
        "title": "Find Substring With Given Hash Value",
        "question_content": "The hash of a 0-indexed string s of length k, given integers p and m, is computed using the following function:\n\n\thash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m.\n\nWhere val(s[i]) represents the index of s[i] in the alphabet from val('a') = 1 to val('z') = 26.\nYou are given a string s and the integers power, modulo, k, and hashValue. Return sub, the first substring of s of length k such that hash(sub, power, modulo) == hashValue.\nThe test cases will be generated such that an answer always exists.\nA substring is a contiguous non-empty sequence of characters within a string.\n&nbsp;\nExample 1:\n\nInput: s = \"leetcode\", power = 7, modulo = 20, k = 2, hashValue = 0\nOutput: \"ee\"\nExplanation: The hash of \"ee\" can be computed to be hash(\"ee\", 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0. \n\"ee\" is the first substring of length 2 with hashValue 0. Hence, we return \"ee\".\n\nExample 2:\n\nInput: s = \"fbxzaad\", power = 31, modulo = 100, k = 3, hashValue = 32\nOutput: \"fbx\"\nExplanation: The hash of \"fbx\" can be computed to be hash(\"fbx\", 31, 100) = (6 * 1 + 2 * 31 + 24 * 312) mod 100 = 23132 mod 100 = 32. \nThe hash of \"bxz\" can be computed to be hash(\"bxz\", 31, 100) = (2 * 1 + 24 * 31 + 26 * 312) mod 100 = 25732 mod 100 = 32. \n\"fbx\" is the first substring of length 3 with hashValue 32. Hence, we return \"fbx\".\nNote that \"bxz\" also has a hash of 32 but it appears later than \"fbx\".\n\n&nbsp;\nConstraints:\n\n\t1 <= k <= s.length <= 2 * 104\n\t1 <= power, modulo <= 109\n\t0 <= hashValue < modulo\n\ts consists of lowercase English letters only.\n\tThe test cases are generated such that an answer always exists.",
        "solutions": [
            {
                "id": 1730321,
                "title": "java-c-python-sliding-window-rolling-hash",
                "content": "# **Intuition**\\nGood time to learn rolling hash.\\nwhat\\'s hash?\\nThe definition `hash(s, p, m)` in the description is the hash of string `s` based on `p`.\\n\\nwhat\\'s rolling hash?\\nThe hash of substring is a sliding window.\\nSo the basis of rolling hash is sliding window.\\n\\n\\n# **Explanation**\\nCalculate the rolling hash backward.\\nIn this process, we slide a window of size `k` from the end to the begin.\\n\\nFirstly calculate the substring hash of the last `k` characters,\\nthen we add one previous backward and drop the last characters.\\n\\nWhy traverse from end instead of front?\\nBecause `cur` is reminder by mod `m`,\\n`cur = cur * p` works easier.\\n`cur = cur / p` doesn\\'r work easily.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public String subStrHash(String s, int p, int m, int k, int hashValue) {\\n        long cur = 0, pk = 1;\\n        int res = 0, n = s.length();\\n        for (int i = n - 1; i >= 0; --i) {\\n            cur = (cur * p + s.charAt(i) - \\'a\\' + 1) % m;\\n            if (i + k >= n)\\n                pk = pk * p % m;\\n            else\\n                cur = (cur - (s.charAt(i + k) - \\'a\\' + 1) * pk % m + m) % m;\\n            if (cur == hashValue)\\n                res = i;\\n        }\\n        return s.substring(res, res + k);\\n    }\\n```\\n**C++**\\n```cpp\\n    string subStrHash(string s, int p, int m, int k, int hashValue) {\\n        long long cur = 0, res = 0, pk = 1, n = s.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            cur = (cur * p + s[i] - \\'a\\' + 1) % m;\\n            if (i + k >= n)\\n                pk = pk * p % m;\\n            else\\n                cur = (cur - (s[i + k] - \\'a\\' + 1) * pk % m + m) % m;\\n            if (cur == hashValue)\\n                res = i;\\n        }\\n        return s.substr(res, k);\\n    }\\n```\\n**Python**\\n```py\\n    def subStrHash(self, s, p, m, k, hashValue):\\n        def val(c):\\n            return ord(c) - ord(\\'a\\') + 1\\n            \\n        res = n = len(s)\\n        pk = pow(p,k,m)\\n        cur = 0\\n\\n        for i in xrange(n - 1, -1, -1):\\n            cur = (cur * p + val(s[i])) % m\\n            if i + k < n:\\n                cur = (cur - val(s[i + k]) * pk) % m\\n            if cur == hashValue:\\n                res = i\\n        return s[res: res + k]\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```java\\n    public String subStrHash(String s, int p, int m, int k, int hashValue) {\\n        long cur = 0, pk = 1;\\n        int res = 0, n = s.length();\\n        for (int i = n - 1; i >= 0; --i) {\\n            cur = (cur * p + s.charAt(i) - \\'a\\' + 1) % m;\\n            if (i + k >= n)\\n                pk = pk * p % m;\\n            else\\n                cur = (cur - (s.charAt(i + k) - \\'a\\' + 1) * pk % m + m) % m;\\n            if (cur == hashValue)\\n                res = i;\\n        }\\n        return s.substring(res, res + k);\\n    }\\n```\n```cpp\\n    string subStrHash(string s, int p, int m, int k, int hashValue) {\\n        long long cur = 0, res = 0, pk = 1, n = s.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            cur = (cur * p + s[i] - \\'a\\' + 1) % m;\\n            if (i + k >= n)\\n                pk = pk * p % m;\\n            else\\n                cur = (cur - (s[i + k] - \\'a\\' + 1) * pk % m + m) % m;\\n            if (cur == hashValue)\\n                res = i;\\n        }\\n        return s.substr(res, k);\\n    }\\n```\n```py\\n    def subStrHash(self, s, p, m, k, hashValue):\\n        def val(c):\\n            return ord(c) - ord(\\'a\\') + 1\\n            \\n        res = n = len(s)\\n        pk = pow(p,k,m)\\n        cur = 0\\n\\n        for i in xrange(n - 1, -1, -1):\\n            cur = (cur * p + val(s[i])) % m\\n            if i + k < n:\\n                cur = (cur - val(s[i + k]) * pk) % m\\n            if cur == hashValue:\\n                res = i\\n        return s[res: res + k]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1730114,
                "title": "c-rolling-hash-o-n-time",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Rolling Hash\\n\\nIn Rabin-Karp algorithm, the hash function is \"reversed\" `hash(s, p, m) = (val(s[0]) * p^(k-1) + val(s[1]) * p^(k-2) + ... + val(s[k-1]) * p^0) mod m`.\\n\\nDuring the contest, I felt that if I generate the hash from left to right, I need to do division and it might cause trouble with modulo.\\n\\nTo be safe, I reversed the string and calculated the hashes using the Rabin-Karp algorithm.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/find-substring-with-given-hash-value/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N) which can be reduced to `O(1)` if we really calculate from right to left\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int p, int mod, int k, int target) {\\n        long h = 0, N = s.size(), pp = 1; // `pp` = p^k\\n        vector<long> hash(N);\\n        string r(rbegin(s), rend(s));\\n        for (int i = 0; i < N; ++i) {\\n            if (i < k) pp = pp * p % mod;\\n            h = (h * p + (r[i] - \\'a\\' + 1)) % mod; // push r[i] into the window\\n            if (i - k >= 0) { // pop r[i-k] out of the window\\n                h = (h - (r[i - k] - \\'a\\' + 1) * pp % mod + mod) % mod;\\n            }\\n            if (i >= k - 1) hash[i] = h;\\n        }\\n        reverse(begin(hash), end(hash));\\n        for (int i = 0; i < N; ++i) {\\n            if (hash[i] == target) return s.substr(i, k); // hash[i] is the hash of `s[i .. (i+k-1)]`\\n        }\\n        return \"\";\\n    }\\n};\\n```\\n\\n### FAQ\\n\\n**1. Why could division + modulo be problematic?**\\n\\nBecause when we do division to a modulo-ed number, we might get the wrong answer.\\n\\nAssume `mod = 100`, a hash `h`\\'s real value is `123` and we want to divide it by `3`. So the expected result should be `41`. But in fact we need to do `123 % 100 / 3` which incorrectly returns `7`.\\n\\n**2. Why do we need division if we calculate from left to right?**\\n\\nAssume `s = \"abcd\", k = 3`.\\n\\nIf we calculate from left to right, `hash(\"abc\") = a * p^0 + b * p^1 + c * p^2`. To get `hash(\"bcd\")`, we need to subtract `a` then divide by `p` then add `d * p^2`. Here comes the division.\\n\\nIf we calculate from right to left, we can leverage the Rabin-Karp algorithm which only requires multiplication. We get `hash(\"dcb\") = d * p^2 + c * p^1 + b * p^0` first. To get `hash(\"abc\")`, we just need to multiply by `p` then add `a` then subtract `d * p^3`.",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/find-substring-with-given-hash-value/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N) which can be reduced to `O(1)` if we really calculate from right to left\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int p, int mod, int k, int target) {\\n        long h = 0, N = s.size(), pp = 1; // `pp` = p^k\\n        vector<long> hash(N);\\n        string r(rbegin(s), rend(s));\\n        for (int i = 0; i < N; ++i) {\\n            if (i < k) pp = pp * p % mod;\\n            h = (h * p + (r[i] - \\'a\\' + 1)) % mod; // push r[i] into the window\\n            if (i - k >= 0) { // pop r[i-k] out of the window\\n                h = (h - (r[i - k] - \\'a\\' + 1) * pp % mod + mod) % mod;\\n            }\\n            if (i >= k - 1) hash[i] = h;\\n        }\\n        reverse(begin(hash), end(hash));\\n        for (int i = 0; i < N; ++i) {\\n            if (hash[i] == target) return s.substr(i, k); // hash[i] is the hash of `s[i .. (i+k-1)]`\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730118,
                "title": "reversed-rabin-karp-vs-inverse-modulo",
                "content": "Computing hash for each substring will result in O(nk) complexity - too slow.\\n\\nRolling hash (Rabin-Karp algorithm) works for sub-strings of the same size, and computes `hash` for the next string in O(1):\\n- Add `i + 1` character: multiply `hash` by `power` and add `val(s[i + 1])`.\\n\\t- This is because \\n\\t\\t- `s[1] * p^k + s[2] * p^(k-1) + s[3]  * p^(k-2) ... + s[k - 1] * p + s[k]` \\n\\t- can be written as \\n\\t\\t- `(...((s[1] * p + s[2]) * p + s[3]) * p ... + s[k - 1]) * p + s[k]`\\n- Remove `i + 1 - k` character: subtract `val(s[i + 1 - k]) * power ^ k` from `hash`.\\n\\nGotchas:\\n1. The value of `a` is `1`, not `0`.\\n2. The `hashValue` is computed by rolling the hash right-to-left, so we need to do the same.\\n3. We need to roll all the way to zero because we need to return the first matching string from the left.\\n4. Make sure we do not go negative when subtracting (add `mod` and make sure the subtracted value is less than `mod`).\\n\\n> Why can\\'t we go left-to-right, and use inverse modulo to do the division? The reason is that inverse modulo may not exist for a given power and modulo. See approach 2 below.\\n\\n**C++**\\n```cpp\\nstring subStrHash(string s, int power, int mod, int k, int hashValue) {\\n    long long hash = 0, res = 0, power_k = 1;\\n    auto val = [&](int i){ return s[i] - \\'`\\'; };\\n    for (int i = s.size() - 1; i >= 0; --i) {\\n        hash = (hash * power + val(i)) % mod;\\n        if (i < s.size() - k)\\n            hash = (mod + hash - power_k * val(i + k) % mod) % mod;\\n        else\\n            power_k = power_k * power % mod;\\n        if (hash == hashValue)\\n            res = i;        \\n    }\\n    return s.substr(res, k);\\n}\\n```\\n**Python 3**\\n```python\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, mod: int, k: int, hashValue: int) -> str:\\n        val = lambda ch : ord(ch) - ord(\"a\") + 1\\n        hash, res, power_k = 0, 0, pow(power, k, mod)\\n        for i in reversed(range(len(s))):\\n            hash = (hash * power + val(s[i])) % mod\\n            if i < len(s) - k:\\n                hash = (mod + hash - power_k * val(s[i + k]) % mod) % mod\\n            res = i if hash == hashValue else res\\n        return s[res:res + k]\\n```\\n\\n#### Approach 2: Inverse Modulo\\nBecause inverse modulo only exists if `gcd(power, mod) == 1`, we need to fall back to the right-to-left solution for some test cases.\\n\\nEven with this fallback, the solution below is 50% faster than the one above. Perhaps there are many test cases where the first substring is close to the left.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, mod: int, k: int, hashValue: int) -> str:\\n        val = lambda ch : ord(ch) - ord(\"a\") + 1\\n        hash, res, pow_k, pow_k_1 = 0, 0, pow(power, k, mod), pow(power, k - 1, mod)\\n        if gcd(power, mod) == 1:\\n            inverse = pow(power, -1, mod)\\n            for i in range(len(s)):\\n                if (i >= k):\\n                    hash = (mod + hash - val(s[i - k])) % mod\\n                hash = (hash * inverse + val(s[i]) * pow_k_1) % mod\\n                if i + 1 >= k and hash == hashValue:\\n                    return s[i + 1 - k : i + 1]            \\n        else:\\n            for i in reversed(range(len(s))):\\n                hash = (hash * power + val(s[i])) % mod\\n                if i < len(s) - k:\\n                    hash = (mod + hash - pow_k * val(s[i + k]) % mod) % mod\\n                res = i if hash == hashValue else res\\n            return s[res:res + k]\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```cpp\\nstring subStrHash(string s, int power, int mod, int k, int hashValue) {\\n    long long hash = 0, res = 0, power_k = 1;\\n    auto val = [&](int i){ return s[i] - \\'`\\'; };\\n    for (int i = s.size() - 1; i >= 0; --i) {\\n        hash = (hash * power + val(i)) % mod;\\n        if (i < s.size() - k)\\n            hash = (mod + hash - power_k * val(i + k) % mod) % mod;\\n        else\\n            power_k = power_k * power % mod;\\n        if (hash == hashValue)\\n            res = i;        \\n    }\\n    return s.substr(res, k);\\n}\\n```\n```python\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, mod: int, k: int, hashValue: int) -> str:\\n        val = lambda ch : ord(ch) - ord(\"a\") + 1\\n        hash, res, power_k = 0, 0, pow(power, k, mod)\\n        for i in reversed(range(len(s))):\\n            hash = (hash * power + val(s[i])) % mod\\n            if i < len(s) - k:\\n                hash = (mod + hash - power_k * val(s[i + k]) % mod) % mod\\n            res = i if hash == hashValue else res\\n        return s[res:res + k]\\n```\n```python\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, mod: int, k: int, hashValue: int) -> str:\\n        val = lambda ch : ord(ch) - ord(\"a\") + 1\\n        hash, res, pow_k, pow_k_1 = 0, 0, pow(power, k, mod), pow(power, k - 1, mod)\\n        if gcd(power, mod) == 1:\\n            inverse = pow(power, -1, mod)\\n            for i in range(len(s)):\\n                if (i >= k):\\n                    hash = (mod + hash - val(s[i - k])) % mod\\n                hash = (hash * inverse + val(s[i]) * pow_k_1) % mod\\n                if i + 1 >= k and hash == hashValue:\\n                    return s[i + 1 - k : i + 1]            \\n        else:\\n            for i in reversed(range(len(s))):\\n                hash = (hash * power + val(s[i])) % mod\\n                if i < len(s) - k:\\n                    hash = (mod + hash - pow_k * val(s[i + k]) % mod) % mod\\n                res = i if hash == hashValue else res\\n            return s[res:res + k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731062,
                "title": "c-sliding-window-traverse-string-from-back-o-n-time",
                "content": "\\nIn this question we traverse string from end instead on front.\\n**Front approach problem :-**\\nFor example take \"abcde\" we first have a window of \"abc \" then we add d in this and remove a from the window . \\nIntial window a*p^0 +b*p^1 + c*p^2\\nthen we remove a*p^0 then we have to **divide**  **sum** by power \\nb*p^0 + c*p^1 and add d*p^3\\nfinal b*p^0 +c*p^1 + d*p^2\\nBut on dividing **sum=sum/power not works easily**\\n**end approach  :-**\\ninitial window from end :- c*p^0 +d*p^1 + e*p^2\\nwe remove e*p^2 and we have to **multiply** window by power\\n c*p^1 +d*p^2\\n now adding \\na*p^0 + c*p^1 +d*p^2\\n**In this case sum =sum * power never creates any problem  thats why traversing from end is better**\\n\\n\\n```\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        int n=s.size();                         \\n        long long int sum=0;\\n        long long int p=1;\\n\\t\\t// Intializing a window from end of size k \\n        for(int i=0;i<k;i++){\\n                sum=(sum+((s[n-k+i]-\\'a\\'+1)*p));         \\n                if(i!=k-1)\\n                    p=(p*power)%modulo;\\n        }\\n\\t\\t// storing the res when ever we get required answer\\n        int res=n-k;   // storing the res when ever we get required answer\\n\\t\\t// slide window to right and removing ith index element and adding (i-k)th index element \\n        for(int i=n-1;i>=k;i--)\\n\\t\\t{                                          \\n\\t\\t//removing last element from window\\n                sum-=(s[i]-\\'a\\'+1)*(p%modulo);               \\n\\t\\t\\t\\t // dividing by modulo to avoid integer overflow conditions\\n                sum=sum%modulo;                  \\n\\t\\t\\t\\t // muliplying the given string by power\\n                sum=sum*(power%modulo);            \\n\\t\\t\\t\\t // adding (i-k)th element in the window  \\n                sum+=s[i-k]-\\'a\\'+1;                 \\n\\t\\t\\t\\t // if sum < 0 then it created problem in modulus thats why making it positive\\n            while(sum%modulo<0){                              \\n                sum=sum+modulo;\\n            }\\n            if(sum%modulo==hashValue){\\n                res=i-k;                                           // storing the starting window index because we have to return the first string from starting \\n            }\\n        }\\n        return s.substr(res,k);\\n    }\\n};\\n\\'\\'\\'\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        int n=s.size();                         \\n        long long int sum=0;\\n        long long int p=1;\\n\\t\\t// Intializing a window from end of size k \\n        for(int i=0;i<k;i++){\\n                sum=(sum+((s[n-k+i]-\\'a\\'+1)*p));         \\n                if(i!=k-1)\\n                    p=(p*power)%modulo;\\n        }\\n\\t\\t// storing the res when ever we get required answer\\n        int res=n-k;   // storing the res when ever we get required answer\\n\\t\\t// slide window to right and removing ith index element and adding (i-k)th index element \\n        for(int i=n-1;i>=k;i--)\\n\\t\\t{                                          \\n\\t\\t//removing last element from window\\n                sum-=(s[i]-\\'a\\'+1)*(p%modulo);               \\n\\t\\t\\t\\t // dividing by modulo to avoid integer overflow conditions\\n                sum=sum%modulo;                  \\n\\t\\t\\t\\t // muliplying the given string by power\\n                sum=sum*(power%modulo);            \\n\\t\\t\\t\\t // adding (i-k)th element in the window  \\n                sum+=s[i-k]-\\'a\\'+1;                 \\n\\t\\t\\t\\t // if sum < 0 then it created problem in modulus thats why making it positive\\n            while(sum%modulo<0){                              \\n                sum=sum+modulo;\\n            }\\n            if(sum%modulo==hashValue){\\n                res=i-k;                                           // storing the starting window index because we have to return the first string from starting \\n            }\\n        }\\n        return s.substr(res,k);\\n    }\\n};\\n\\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731504,
                "title": "rolling-hash-intuition-with-example",
                "content": "Here is the intuition for rolling hash if someone is looking for.\\nConsider string  **xyzabc** for which we are computing hash. **Window size 3.**\\n\\n**Step 1- Compute hash for first window**\\nxyz**abc**\\n\\nIteration 1\\n```\\nhash  = c + hash * p \\nhash  = c  + 0 * p\\nhash  = c \\n```\\nIteration 2\\n```\\nhash = b + hash * p \\nhash = b + c * p\\n```\\nIteration 3\\n```\\nhash = a + hash * p \\nhash = a + (b + c * p) * p \\nhash = a + b * p + c * p^2\\n```\\nNow hash for **abc** is in form as described in the problem statement\\n```\\nhash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m.\\n```\\n**Step 2 - Now slide\\uD83D\\uDD7A**\\n\\nxy**zab**c\\n```\\nhash = [hash - c * p^2]             // Remove c from window\\nhash = [(a + b * p + c * p^2) - c * p^2]\\nhash = [a + b * p]\\nhash = [a + b * p] * p              // Shift a and b , one step to right in window\\nhash = a * p + b * p^2\\nhash = z + a * p + b * p^2       // Add z to window\\n```\\n\\nx**yza**bc\\n```\\nhash = y + [hash - b * p^2]* p\\nhash = y + [(z + a * p + b * p^2) - b * p^2]*p\\nhash = y + [z + a * p] p\\nhash = y + z * p + a * p^2\\n```\\nSimilarly can compute for entire string. Suggestions and feedbacks are welcome!! Upvote if you find this helpful!!",
                "solutionTags": [],
                "code": "```\\nhash  = c + hash * p \\nhash  = c  + 0 * p\\nhash  = c \\n```\n```\\nhash = b + hash * p \\nhash = b + c * p\\n```\n```\\nhash = a + hash * p \\nhash = a + (b + c * p) * p \\nhash = a + b * p + c * p^2\\n```\n```\\nhash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m.\\n```\n```\\nhash = [hash - c * p^2]             // Remove c from window\\nhash = [(a + b * p + c * p^2) - c * p^2]\\nhash = [a + b * p]\\nhash = [a + b * p] * p              // Shift a and b , one step to right in window\\nhash = a * p + b * p^2\\nhash = z + a * p + b * p^2       // Add z to window\\n```\n```\\nhash = y + [hash - b * p^2]* p\\nhash = y + [(z + a * p + b * p^2) - b * p^2]*p\\nhash = y + [z + a * p] p\\nhash = y + z * p + a * p^2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730100,
                "title": "java-rolling-hash-back-to-front",
                "content": "Keep a k length sliding window\\nRemove rightmost character(weighted) and add leftmost character at every step\\n```\\nclass Solution {\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n        int l = s.length() - 1;\\n        int r = s.length() - 1;\\n        long sum = 0;\\n        long weight = 1;\\n        for (int i = 0; i < k - 1; i++) {\\n            weight = (weight * power) % modulo;\\n        }\\n        String can = \"\";\\n        while (r >= 0){\\n            while (r >= 0 && l - r + 1 <= k) {\\n                char c = s.charAt(r);\\n                sum = ((sum * power) % modulo + (c - \\'a\\' + 1)) % modulo;\\n                r--;\\n            }\\n            if (sum == (long)hashValue) {\\n                can = s.substring(r + 1, l + 1);\\n            }\\n            char x = s.charAt(l);\\n            sum = (sum - (x - \\'a\\' + 1) * weight % modulo + modulo) % modulo;\\n            l--;\\n        }\\n        return can;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n        int l = s.length() - 1;\\n        int r = s.length() - 1;\\n        long sum = 0;\\n        long weight = 1;\\n        for (int i = 0; i < k - 1; i++) {\\n            weight = (weight * power) % modulo;\\n        }\\n        String can = \"\";\\n        while (r >= 0){\\n            while (r >= 0 && l - r + 1 <= k) {\\n                char c = s.charAt(r);\\n                sum = ((sum * power) % modulo + (c - \\'a\\' + 1)) % modulo;\\n                r--;\\n            }\\n            if (sum == (long)hashValue) {\\n                can = s.substring(r + 1, l + 1);\\n            }\\n            char x = s.charAt(l);\\n            sum = (sum - (x - \\'a\\' + 1) * weight % modulo + modulo) % modulo;\\n            l--;\\n        }\\n        return can;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730356,
                "title": "java-simple-solution-with-sliding-window-and-caching",
                "content": "This problem will give TLE if normal sliding window is applied.\\n\\nSince the result will always be of length k, we will need to compute power^0, power^1, power^2......., power^k everytime and this is the redundant calculation that we can avoid.\\n\\nI have created function binpow that computed (a^b)mod(n) in O(log(n)) time using [binary exponentiation.](https://cp-algorithms.com/algebra/binary-exp.html) \\n\\nSo, we can create an array of length k and store the values of powers i.e. (power^0)mod(modulo) at index 0, (power^1)mod(modulo) at index 1, and so on till k so that we can use these values later directly.\\n\\nNow starting from 0 check for every window of size k and return the substring if hashValue matches.\\n\\nJava Code:\\n```\\npublic String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n        long[] p = new long[k]; //to store all the power values beforehand to avoid redundant calculations\\n        for(int i=0;i<k;i++){\\n            p[i] = binpow(power, i, modulo);\\n        }\\n\\n        for(int j=0;j<s.length()-k+1;j++){\\n            long hash = 0;\\n            for(int i=j;i<j+k;i++){\\n                hash += (s.charAt(i)-\\'a\\'+1)*p[i-j];\\n            }\\n            hash %= modulo;\\n            if(hash==hashValue)\\n                return s.substring(j,j+k);\\n        }\\n        return \"\";\\n    }\\n    \\n    // function to calculate (a^n)mod(n) in O(log(n)) time\\n    private long binpow(long a, long b, long m) {\\n        a %= m;\\n        long res = 1;\\n        while (b > 0) {\\n            if (b%2==1)\\n                res = res * a % m;\\n            a = a * a % m;\\n            b >>= 1;\\n        }\\n        return res;\\n    }\\n\\n}\\n```\\n\\nDo upvote if you like the solution!\\nLet me know if any suggestions!\\n",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\npublic String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n        long[] p = new long[k]; //to store all the power values beforehand to avoid redundant calculations\\n        for(int i=0;i<k;i++){\\n            p[i] = binpow(power, i, modulo);\\n        }\\n\\n        for(int j=0;j<s.length()-k+1;j++){\\n            long hash = 0;\\n            for(int i=j;i<j+k;i++){\\n                hash += (s.charAt(i)-\\'a\\'+1)*p[i-j];\\n            }\\n            hash %= modulo;\\n            if(hash==hashValue)\\n                return s.substring(j,j+k);\\n        }\\n        return \"\";\\n    }\\n    \\n    // function to calculate (a^n)mod(n) in O(log(n)) time\\n    private long binpow(long a, long b, long m) {\\n        a %= m;\\n        long res = 1;\\n        while (b > 0) {\\n            if (b%2==1)\\n                res = res * a % m;\\n            a = a * a % m;\\n            b >>= 1;\\n        }\\n        return res;\\n    }\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1764923,
                "title": "c-from-right-to-left-sliding-window",
                "content": "Since we need to do division for the power value if we process `s` from left to right, we can do it from right to left and always\\n`cval += (s[i]-\\'a\\'+1) - (s[i+k]-\\'a\\'+1)*p^k`\\nNote that we + `modulo` in order to avoid `cval` to be negative.\\n\\n* time: `O(n)`\\n* space: `O(1)`\\n\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        int n = s.size();\\n        ll cval = 0, pval = 1;\\n        for (int i = n-k; i < n; ++i) {\\n            cval = (cval + ((s[i]-\\'a\\')+1)*pval) % modulo;\\n            pval = (pval*power) % modulo;\\n        }\\n        int start;\\n        if (cval == hashValue) {\\n            start = n-k;\\n        }\\n        for (int i = n-k-1; i >= 0; --i) {\\n            cval = ((cval*power+((s[i]-\\'a\\')+1))%modulo - ((s[i+k]-\\'a\\')+1)*pval%modulo + modulo) % modulo;\\n            if (cval == hashValue) {\\n                start = i;\\n            }\\n        }\\n        return s.substr(start, k);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        int n = s.size();\\n        ll cval = 0, pval = 1;\\n        for (int i = n-k; i < n; ++i) {\\n            cval = (cval + ((s[i]-\\'a\\')+1)*pval) % modulo;\\n            pval = (pval*power) % modulo;\\n        }\\n        int start;\\n        if (cval == hashValue) {\\n            start = n-k;\\n        }\\n        for (int i = n-k-1; i >= 0; --i) {\\n            cval = ((cval*power+((s[i]-\\'a\\')+1))%modulo - ((s[i+k]-\\'a\\')+1)*pval%modulo + modulo) % modulo;\\n            if (cval == hashValue) {\\n                start = i;\\n            }\\n        }\\n        return s.substr(start, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730686,
                "title": "python-o-n-time-backward-sliding-window-with-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        \\'\\'\\'\\n        Use Sliding window and rolling hash to find the first substring \\n        that has same hash value as provided `hashValue`.\\n        \\n        Time: O(n)\\n        Space: O(n)\\n        \\'\\'\\'\\n        \\n        # generate val list for each letter\\n        vals = [ord(c) - ord(\\'a\\') + 1 for c in s]\\n        \\n        # gradually build `powers` by multiply `power` instead of using `**`\\n        # which is very slow and will cause TLE.\\n        # Or use pow(x, y, z). Ref: https://docs.python.org/3/library/functions.html#pow\\n        \\n        # powers = [1] * k\\n        # for i in range(1, k):\\n        #     powers[i] = (powers[i-1] * power) % modulo\\n        powers = [pow(power, i, modulo) for i in range(k)]\\n        \\n        n = len(s)\\n        # initial hash_value for the last substring with length n\\n        hash_value = sum(vals[n - k + i] * powers[i] for i in range(k))\\n        # set idx with the beginning of the last substring with length n\\n        idx = n - k\\n        # moving backwards to calculate new hash value\\n        # because moving backwards you can just `* power`\\n        # moving forward will involve `//`, which is difficult for modulo\\n        for i in range(n-k-1, -1, -1):\\n            # update hash_value by removing the last index (i+k), \\n            # and multiply the rest by power since each remaining characters\\' indices increase by 1 for new substring\\n            # and add the newcoming vals[i] * powers[0] (which is 1 and could be omitted)\\n            hash_value = ((hash_value - vals[i+k] * powers[k-1]) * power + vals[i] ) % modulo\\n            # keep updating idx since we are moving to the left\\n            # and trying to find the first substring that has the same hash value as `hashValue`\\n            if hash_value == hashValue:\\n                idx = i\\n        return s[idx:idx+k]\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        \\'\\'\\'\\n        Use Sliding window and rolling hash to find the first substring \\n        that has same hash value as provided `hashValue`.\\n        \\n        Time: O(n)\\n        Space: O(n)\\n        \\'\\'\\'\\n        \\n        # generate val list for each letter\\n        vals = [ord(c) - ord(\\'a\\') + 1 for c in s]\\n        \\n        # gradually build `powers` by multiply `power` instead of using `**`\\n        # which is very slow and will cause TLE.\\n        # Or use pow(x, y, z). Ref: https://docs.python.org/3/library/functions.html#pow\\n        \\n        # powers = [1] * k\\n        # for i in range(1, k):\\n        #     powers[i] = (powers[i-1] * power) % modulo\\n        powers = [pow(power, i, modulo) for i in range(k)]\\n        \\n        n = len(s)\\n        # initial hash_value for the last substring with length n\\n        hash_value = sum(vals[n - k + i] * powers[i] for i in range(k))\\n        # set idx with the beginning of the last substring with length n\\n        idx = n - k\\n        # moving backwards to calculate new hash value\\n        # because moving backwards you can just `* power`\\n        # moving forward will involve `//`, which is difficult for modulo\\n        for i in range(n-k-1, -1, -1):\\n            # update hash_value by removing the last index (i+k), \\n            # and multiply the rest by power since each remaining characters\\' indices increase by 1 for new substring\\n            # and add the newcoming vals[i] * powers[0] (which is 1 and could be omitted)\\n            hash_value = ((hash_value - vals[i+k] * powers[k-1]) * power + vals[i] ) % modulo\\n            # keep updating idx since we are moving to the left\\n            # and trying to find the first substring that has the same hash value as `hashValue`\\n            if hash_value == hashValue:\\n                idx = i\\n        return s[idx:idx+k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730170,
                "title": "python-kept-hitting-tle-now-working-lol",
                "content": "I kept hitting TLE on this solution. Can you help me figure out how I can optimize this code?\\nThanks!\\n\\n```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        for i in range(len(s)-k+1):\\n            if i == 0:\\n                val = 0\\n                for j in range(k):\\n                    val += ((ord(s[j]) - 96) * (power**j))\\n            else:\\n                val -= (ord(s[i-1]) - 96)\\n                val += ((ord(s[i+k-1]) - 96) * (power**k))\\n                val //= power\\n            ans = val % modulo\\n            if ans == hashValue:\\n                return s[i:i+k]\\n```\\n\\nAfter several suggestions and changes:\\nHere\\'s what worked:\\n```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        char_mapping = {}\\n        for i in range(97, 123):\\n            char_mapping[chr(i)] = i - 96\\n        temp = 1\\n        for i in range(len(s)-k+1):\\n            if i == 0:\\n                val = 0\\n                for j in range(k):\\n                    val += (char_mapping[s[j]] * temp)\\n                    temp *= power\\n            else:\\n                val -= char_mapping[s[i-1]]\\n                val += (char_mapping[s[i+k-1]] * temp)\\n                val //= power\\n            ans = val % modulo\\n            if ans == hashValue:\\n                return s[i:i+k]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        for i in range(len(s)-k+1):\\n            if i == 0:\\n                val = 0\\n                for j in range(k):\\n                    val += ((ord(s[j]) - 96) * (power**j))\\n            else:\\n                val -= (ord(s[i-1]) - 96)\\n                val += ((ord(s[i+k-1]) - 96) * (power**k))\\n                val //= power\\n            ans = val % modulo\\n            if ans == hashValue:\\n                return s[i:i+k]\\n```\n```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        char_mapping = {}\\n        for i in range(97, 123):\\n            char_mapping[chr(i)] = i - 96\\n        temp = 1\\n        for i in range(len(s)-k+1):\\n            if i == 0:\\n                val = 0\\n                for j in range(k):\\n                    val += (char_mapping[s[j]] * temp)\\n                    temp *= power\\n            else:\\n                val -= char_mapping[s[i-1]]\\n                val += (char_mapping[s[i+k-1]] * temp)\\n                val //= power\\n            ans = val % modulo\\n            if ans == hashValue:\\n                return s[i:i+k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730196,
                "title": "c-rolling-hash-o-n",
                "content": "```\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        int n = s.size();\\n        long curhash = 0;\\n        long computed = 1;\\n        for(int i=0; i<k-1; ++i)\\n            computed = computed*power%modulo;\\n        \\n        string ret;\\n        for(int i=n-1; i>=0; --i){\\n            if(i < n-k){\\n                curhash = (curhash - (s[i+k]-\\'a\\'+1) * computed) % modulo;\\n                if(curhash < 0)\\n                    curhash += modulo;\\n            }\\n            curhash = (curhash*power + s[i]-\\'a\\'+1)%modulo;\\n            \\n            if(i<=n-k && hashValue == curhash)\\n                ret = s.substr(i, k);\\n        }\\n        return ret;   \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        int n = s.size();\\n        long curhash = 0;\\n        long computed = 1;\\n        for(int i=0; i<k-1; ++i)\\n            computed = computed*power%modulo;\\n        \\n        string ret;\\n        for(int i=n-1; i>=0; --i){\\n            if(i < n-k){\\n                curhash = (curhash - (s[i+k]-\\'a\\'+1) * computed) % modulo;\\n                if(curhash < 0)\\n                    curhash += modulo;\\n            }\\n            curhash = (curhash*power + s[i]-\\'a\\'+1)%modulo;\\n            \\n            if(i<=n-k && hashValue == curhash)\\n                ret = s.substr(i, k);\\n        }\\n        return ret;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1741682,
                "title": "c-o-n-create-simple-solution-step-by-step-from-basic-math",
                "content": "# 1. Simple solution\\nThe simple solution is the following. \\n\\n```C++\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        const int s_len = s.length();\\n        long mod = (long) modulo;\\n        long pow = long(power) % mod; \\n        vector<long> p(k,1);//all power nubmer we need(p^1~p^k)\\n        vector<long> vs(s_len+k,0); //value vector of string s \\n        for(int i=1;i<k;i++) p[i] = ( p[i-1] * pow ) % mod; //init power nubmers\\n        for(int i=0;i<s_len;i++) vs[i] = (s[i]-\\'a\\'+1) % mod;//init vector of string\\n\\t\\t\\n        pair<int, int> len_pos = solve(p, vs, s_len, pow, mod, k, hashValue);\\n        return s.substr(len_pos.first,  len_pos.second);        \\t\\n\\t}\\n\\t\\n    pair<int, int> solve(vector<long>& p, vector<long>&vs, const int s_len, long pow, long mod, int k, int hashValue) {\\n        pair<int, int> pos_len = {-1, -1};\\n        long H=0;\\n        for(int i = s_len -1; i >= 0; i--) {\\n            H = (mod + H - (vs[k+i]*p[k-1] % mod)) % mod; //remove largest item\\n            H = ((pow * H) % mod + vs[i]) % mod; //add new item\\n            if ( i<= (s_len-k)  && H == hashValue) \\n                pos_len = {i,k};\\n        }\\n        return pos_len;\\n    }\\n};\\n```\\nThen I let you know how to develop this solution step by step from zero concept.\\n# 2. Idea from math\\nThe final solution is the slide-window moving from right-most to left-most for string s.\\nIn each moving, you need to remove some factor and add some factor to get new hashValue H.\\nSo, we can try to write some math formula and observe the relationship in it.\\n\\n![image](https://assets.leetcode.com/users/images/02109700-0fbc-489a-bee4-76fa916b2d02_1643883093.683299.png)\\nIf picture is not enough clean, you can open the following google jamboard link.\\nSo you can get clearly view from this link.\\nhttps://jamboard.google.com/d/1Vx8Tqk-Aph_FftKULHNIsJxdeQCciE5OHTStAwuoiEg/viewer\\n\\nThere are only two basic math point we need to know for this problem.\\n```C++\\n(a + b) % n == ((a%n) + (b%n)) % n\\n(a * b) % n == ((a%n) * (b%n)) % n\\n```\\nI get this information from wikipedia https://en.wikipedia.org/wiki/Modulo_operation\\n\\nFrom this basic math, we can observe the  formula  more and observe the relationship \\nbetween two most closed substring.\\n\\nIn the problem description, it give you a formula to figure out hash value for substring.\\nIn this picture, **H_m** is the hash value from the substring with start index as m. \\nAnd **C_i** is the value represent to the character s[i] by figure out  **s[i]-\\'a\\'+1**. \\n**C_i is also val(s[i])** in the description too. \\n\\nBecause I have long time no use math and this picture of idea is \\nthe good draft for me to write code. \\n\\n## blue color point  in idea picture\\nIf you figure out in wrong math formula, then your code is hard to debug. \\nThere are four number of blue points in the picture. I put blue color for it\\nto mention myself when I write code.\\n\\n\\n\\n# 3. First version (no slide-window)\\nIn this first version, we want to make sure our math\\'s idea is correct. \\nThe time complexity of it is O(N^2) and of course it will get \\nTime Limit Exceeded if you submit this code.  \\n\\nAnother thing we do in this first version code is that\\nwe process everything in long type. \\n\\nRemember that there are only two basic math point we \\nneed to know for this problem.\\n```C++\\n(a + b) % n == ((a%n) + (b%n)) % n\\n(a * b) % n == ((a%n) * (b%n)) % n\\n```\\nEven we use modulo very careful but the multiplication for two maximum \\ninteger will make overflow. This is the reason of why we use **long** type here.\\nAnd I do mod operation first for all basic values, which is like values in vs vector, \\npow and every power number vector we need in this problem.  \\n\\n```\\nclass Solution {\\n\\tstring subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        const int s_len = s.length();\\n        long mod = (long)modulo;\\n        long pow = long(power) % mod;\\n        vector<long> p(k,1);\\n        for(int i=1;i<k;i++) { \\n            p[i] = ( p[i-1] * pow ) % mod; \\n            //By blue point (1) of picture explanation.\\n        }\\n        \\n        vector<long> vs(s_len);\\n        for(int i=0;i<s_len;i++) {\\n            vs[i] = (s[i]-\\'a\\'+1) % mod;\\n        }\\n        \\n        \\n        for(int idx = 0; idx < s_len-k+1; idx++) {\\n            int H = 0;\\n            for(int i=0; i<k; i++) {\\n                int pos = i + idx;\\n                int item = (vs[pos]*p[i]) % modulo;\\n\\t\\t\\t\\t//By blue point (2) of picture explanation.\\n                H = (H + item) % modulo;\\n            }\\n            \\n            if ( H == hashValue ) {\\n                return s.substr(idx,k);\\n            }\\n        }\\n\\t}\\n};\\n```\\n\\n\\n\\n# 4. Second version (with slide-window)\\nWhen I develop this code, it not always lucky to get pass because I\\'m the \\nprogrammer not familiar with slide window and not often to use too much math.\\nBut in the Idea level, we have already figure out the formula clearly.\\nWe have already know what factor we should put and remove when \\nthe slide-window move. \\n\\nWhen you develope your personal code, \\nyou may not lucky to get pass in the first time. \\nYou can put your failed test-case in your version 1 code. If version code\\nis not pass, then that\\'s mean some logic is not correct in the start.  \\nThe first version code I afford can be executed correct.  \\n\\n```\\nclass Solution {\\n\\tstring subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        const int s_len = s.length();\\n        long mod = (long)modulo;\\n        long pow = long(power) % mod;\\n        vector<long> p(k,1);\\n        for(int i=1;i<k;i++) { \\n            p[i] = ( p[i-1] * pow ) % mod; \\n            //By blue point (1) of picture explanation.\\n        }\\n        \\n        vector<long> vs(s_len);\\n        for(int i=0;i<s_len;i++) {\\n            vs[i] = (s[i]-\\'a\\'+1) % mod;\\n        }\\n        \\n        pair<int, int> pos_len = {-1, -1};\\n        long H = 0;\\n        for(int i=0;i<k;i++) {\\n            int pos = i + s_len-k;\\n            long item = (vs[pos]*p[i]) % mod; \\n            //By blue point (2) of picture explanation.\\n            H = (H + item) % mod;\\n        }\\n        if ( H == hashValue ) {\\n            pos_len = {s_len-k,k};\\n        }\\n\\t\\t\\n        for(int i = (s_len-k) -1; i >= 0; i--) {\\n            long removed_factor = vs[k+i]*p[k-1] % mod;\\n            //By blue point(3) of picture explanation.\\n            long added_factor = vs[i];\\n            //By blue point(4) of picture explanation.\\n            H = (mod + H - removed_factor) % mod;\\n            H = (pow * H) % mod;\\n            H = (H + added_factor) % mod;\\n            if (H == hashValue ) {\\n                pos_len = {i,k};\\n            }\\n        }        \\n        return s.substr(pos_len.first, pos_len.second);        \\n\\t}\\n};\\n```\\n\\n\\n\\n# 5 Keep going to improve code\\nBecause the second version is pass when I submit. \\nSo, I can start to reafctor my code.\\n##  5.1 Put some dummy to refactor \\n\\n```C++\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        const int s_len = s.length();\\n        long mod = (long) modulo;\\n        long pow = long(power) % mod;\\n        vector<long> p(k,1);\\n        for(int i=1;i<k;i++) { \\n            p[i] = ( p[i-1] * pow ) % mod; \\n        }\\n        \\n        vector<long> vs(s_len+k,0);\\n        for(int i=0;i<s_len;i++) {\\n            vs[i] = (s[i]-\\'a\\'+1) % mod;\\n        }\\n        \\n        pair<int, int> pos_len = {-1, -1};\\n        long H = 0;\\n\\n        for(int i = s_len -1; i >= 0; i--) {        \\n            long removed_factor = vs[k+i]*p[k-1] % mod;\\n            long added_factor = vs[i];\\n            H = (mod + H - removed_factor) % mod;\\n            H = (pow * H) % mod;\\n            H = (H + added_factor) % mod;\\n            if ( i<= (s_len-k)  && H == hashValue) {\\n                pos_len = {i,k};\\n            }\\n        }\\n        return s.substr(pos_len.first, pos_len.second);        \\n    }\\n\\n```\\n\\n##  5.2 Seperate core logic in another function.\\n\\n```C++\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        const int s_len = s.length();\\n        long mod = (long) modulo;\\n        long pow = long(power) % mod;\\n        vector<long> p(k,1);\\n        //tailed k elements is dummy\\n        vector<long> vs(s_len+k,0); \\n        //figure out power number in mod\\n        for(int i=1;i<k;i++) \\n            p[i] = ( p[i-1] * pow ) % mod; \\n        //set vector vs to represent string s in mod\\n        for(int i=0;i<s_len;i++) \\n            vs[i] = (s[i]-\\'a\\'+1) % mod;\\n        \\n        pair<int, int> len_pos = solve(p, vs, s_len, pow, mod, k, hashValue);\\n        return s.substr(len_pos.first,  len_pos.second);        \\n    }\\n    \\n    pair<int, int> solve(\\n\\t\\tvector<long>& p, vector<long>& vs, const int s_len, \\n\\t\\tlong pow, long mod, int k, int hashValue) \\n\\t{\\n        pair<int, int> pos_len = {-1, -1};\\n        long H=0;\\n        for(int i = s_len -1; i >= 0; i--) {\\n            //remove factor of moving slide window\\n            H = (mod + H - (vs[k+i]*p[k-1] % mod)) % mod;\\n            //add factor of moving slide window\\n            H = ((pow * H) % mod + vs[i]) % mod;\\n            // figure out result if hashValue match\\n            if ( i<= (s_len-k)  && H == hashValue) \\n                pos_len = {i,k};\\n        }\\n        return pos_len;\\n    }\\n```\\n\\nRemove the comments in above and then you can see \\nthe same simple solution in the start of this article.  \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Math",
                    "Sliding Window"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        const int s_len = s.length();\\n        long mod = (long) modulo;\\n        long pow = long(power) % mod; \\n        vector<long> p(k,1);//all power nubmer we need(p^1~p^k)\\n        vector<long> vs(s_len+k,0); //value vector of string s \\n        for(int i=1;i<k;i++) p[i] = ( p[i-1] * pow ) % mod; //init power nubmers\\n        for(int i=0;i<s_len;i++) vs[i] = (s[i]-\\'a\\'+1) % mod;//init vector of string\\n\\t\\t\\n        pair<int, int> len_pos = solve(p, vs, s_len, pow, mod, k, hashValue);\\n        return s.substr(len_pos.first,  len_pos.second);        \\t\\n\\t}\\n\\t\\n    pair<int, int> solve(vector<long>& p, vector<long>&vs, const int s_len, long pow, long mod, int k, int hashValue) {\\n        pair<int, int> pos_len = {-1, -1};\\n        long H=0;\\n        for(int i = s_len -1; i >= 0; i--) {\\n            H = (mod + H - (vs[k+i]*p[k-1] % mod)) % mod; //remove largest item\\n            H = ((pow * H) % mod + vs[i]) % mod; //add new item\\n            if ( i<= (s_len-k)  && H == hashValue) \\n                pos_len = {i,k};\\n        }\\n        return pos_len;\\n    }\\n};\\n```\n```C++\\n(a + b) % n == ((a%n) + (b%n)) % n\\n(a * b) % n == ((a%n) * (b%n)) % n\\n```\n```C++\\n(a + b) % n == ((a%n) + (b%n)) % n\\n(a * b) % n == ((a%n) * (b%n)) % n\\n```\n```\\nclass Solution {\\n\\tstring subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        const int s_len = s.length();\\n        long mod = (long)modulo;\\n        long pow = long(power) % mod;\\n        vector<long> p(k,1);\\n        for(int i=1;i<k;i++) { \\n            p[i] = ( p[i-1] * pow ) % mod; \\n            //By blue point (1) of picture explanation.\\n        }\\n        \\n        vector<long> vs(s_len);\\n        for(int i=0;i<s_len;i++) {\\n            vs[i] = (s[i]-\\'a\\'+1) % mod;\\n        }\\n        \\n        \\n        for(int idx = 0; idx < s_len-k+1; idx++) {\\n            int H = 0;\\n            for(int i=0; i<k; i++) {\\n                int pos = i + idx;\\n                int item = (vs[pos]*p[i]) % modulo;\\n\\t\\t\\t\\t//By blue point (2) of picture explanation.\\n                H = (H + item) % modulo;\\n            }\\n            \\n            if ( H == hashValue ) {\\n                return s.substr(idx,k);\\n            }\\n        }\\n\\t}\\n};\\n```\n```\\nclass Solution {\\n\\tstring subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        const int s_len = s.length();\\n        long mod = (long)modulo;\\n        long pow = long(power) % mod;\\n        vector<long> p(k,1);\\n        for(int i=1;i<k;i++) { \\n            p[i] = ( p[i-1] * pow ) % mod; \\n            //By blue point (1) of picture explanation.\\n        }\\n        \\n        vector<long> vs(s_len);\\n        for(int i=0;i<s_len;i++) {\\n            vs[i] = (s[i]-\\'a\\'+1) % mod;\\n        }\\n        \\n        pair<int, int> pos_len = {-1, -1};\\n        long H = 0;\\n        for(int i=0;i<k;i++) {\\n            int pos = i + s_len-k;\\n            long item = (vs[pos]*p[i]) % mod; \\n            //By blue point (2) of picture explanation.\\n            H = (H + item) % mod;\\n        }\\n        if ( H == hashValue ) {\\n            pos_len = {s_len-k,k};\\n        }\\n\\t\\t\\n        for(int i = (s_len-k) -1; i >= 0; i--) {\\n            long removed_factor = vs[k+i]*p[k-1] % mod;\\n            //By blue point(3) of picture explanation.\\n            long added_factor = vs[i];\\n            //By blue point(4) of picture explanation.\\n            H = (mod + H - removed_factor) % mod;\\n            H = (pow * H) % mod;\\n            H = (H + added_factor) % mod;\\n            if (H == hashValue ) {\\n                pos_len = {i,k};\\n            }\\n        }        \\n        return s.substr(pos_len.first, pos_len.second);        \\n\\t}\\n};\\n```\n```C++\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        const int s_len = s.length();\\n        long mod = (long) modulo;\\n        long pow = long(power) % mod;\\n        vector<long> p(k,1);\\n        for(int i=1;i<k;i++) { \\n            p[i] = ( p[i-1] * pow ) % mod; \\n        }\\n        \\n        vector<long> vs(s_len+k,0);\\n        for(int i=0;i<s_len;i++) {\\n            vs[i] = (s[i]-\\'a\\'+1) % mod;\\n        }\\n        \\n        pair<int, int> pos_len = {-1, -1};\\n        long H = 0;\\n\\n        for(int i = s_len -1; i >= 0; i--) {        \\n            long removed_factor = vs[k+i]*p[k-1] % mod;\\n            long added_factor = vs[i];\\n            H = (mod + H - removed_factor) % mod;\\n            H = (pow * H) % mod;\\n            H = (H + added_factor) % mod;\\n            if ( i<= (s_len-k)  && H == hashValue) {\\n                pos_len = {i,k};\\n            }\\n        }\\n        return s.substr(pos_len.first, pos_len.second);        \\n    }\\n\\n```\n```C++\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        const int s_len = s.length();\\n        long mod = (long) modulo;\\n        long pow = long(power) % mod;\\n        vector<long> p(k,1);\\n        //tailed k elements is dummy\\n        vector<long> vs(s_len+k,0); \\n        //figure out power number in mod\\n        for(int i=1;i<k;i++) \\n            p[i] = ( p[i-1] * pow ) % mod; \\n        //set vector vs to represent string s in mod\\n        for(int i=0;i<s_len;i++) \\n            vs[i] = (s[i]-\\'a\\'+1) % mod;\\n        \\n        pair<int, int> len_pos = solve(p, vs, s_len, pow, mod, k, hashValue);\\n        return s.substr(len_pos.first,  len_pos.second);        \\n    }\\n    \\n    pair<int, int> solve(\\n\\t\\tvector<long>& p, vector<long>& vs, const int s_len, \\n\\t\\tlong pow, long mod, int k, int hashValue) \\n\\t{\\n        pair<int, int> pos_len = {-1, -1};\\n        long H=0;\\n        for(int i = s_len -1; i >= 0; i--) {\\n            //remove factor of moving slide window\\n            H = (mod + H - (vs[k+i]*p[k-1] % mod)) % mod;\\n            //add factor of moving slide window\\n            H = ((pow * H) % mod + vs[i]) % mod;\\n            // figure out result if hashValue match\\n            if ( i<= (s_len-k)  && H == hashValue) \\n                pos_len = {i,k};\\n        }\\n        return pos_len;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730260,
                "title": "python-o-n-traverse-the-string-backward",
                "content": "p = power\\nm = modulo\\n\\nIt is very hard to calculate the hash code of s[i + 1: i + 1 + k] from s[i: i + k] because p does not necessarily have an inverse modulo m as we are not given this condition. But calculating the hash code of s[i: i + k] from s[i + 1: i + 1 + k] is easy because\\nHASH(s[i: i + k]) = (p * ( HASH(s[i + 1: i + 1 + k]) - s[i + k]) + s[i]) % m.\\nSo just calculate the first hash and recusively calculate the hash of the next substring using this formula going backwards:\\n\\n```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        n = len(s)\\n        val = 0\\n        ans = \"\"\\n        \\n        p_k_1 = 1\\n        for j in range(k - 1):\\n            p_k_1 = (p_k_1 * power) % modulo\\n        \\n        for i in range(n - k, -1, -1):\\n            sub = s[i:i+k]\\n            \\n            if i == n - k:\\n                val = self.hash(sub, power, modulo)\\n            else:\\n                c_val = ord(s[i + k]) - ord(\\'a\\') + 1\\n                val = (val - c_val * p_k_1 + modulo) % modulo  \\n                val = (val * power) % modulo\\n                val = (val + ord(s[i]) - ord(\\'a\\') + 1) % modulo\\n\\t\\n            if hashValue == val:\\n                ans = sub\\n\\n        return ans\\n    \\n    def hash(self, s, p, m):\\n        \\n        hash_val = 0\\n        v = 1\\n        for i in range(len(s)):\\n            val = ord(s[i]) - ord(\\'a\\') + 1\\n            hash_val = (hash_val + (val * v) % m) % m\\n            v = (v * p) % m \\n            \\n        return hash_val\\n```\\n\\nEdit: Reading other posts, I guess this is just reversed Rabin-Karp",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        n = len(s)\\n        val = 0\\n        ans = \"\"\\n        \\n        p_k_1 = 1\\n        for j in range(k - 1):\\n            p_k_1 = (p_k_1 * power) % modulo\\n        \\n        for i in range(n - k, -1, -1):\\n            sub = s[i:i+k]\\n            \\n            if i == n - k:\\n                val = self.hash(sub, power, modulo)\\n            else:\\n                c_val = ord(s[i + k]) - ord(\\'a\\') + 1\\n                val = (val - c_val * p_k_1 + modulo) % modulo  \\n                val = (val * power) % modulo\\n                val = (val + ord(s[i]) - ord(\\'a\\') + 1) % modulo\\n\\t\\n            if hashValue == val:\\n                ans = sub\\n\\n        return ans\\n    \\n    def hash(self, s, p, m):\\n        \\n        hash_val = 0\\n        v = 1\\n        for i in range(len(s)):\\n            val = ord(s[i]) - ord(\\'a\\') + 1\\n            hash_val = (hash_val + (val * v) % m) % m\\n            v = (v * p) % m \\n            \\n        return hash_val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730245,
                "title": "using-rolling-hash-o-n",
                "content": "I generated the hash from right to left to avoid wrong answer because of division.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    long long power(long long x, long long y, long long mod)\\n    {\\n        long long ans = 1;\\n\\n        x = x % mod;\\n\\n        while (y > 0)\\n        {\\n            if (y & 1)\\n                ans = ((ans % mod) * (x % mod)) % mod;\\n\\n            y = y >> 1;\\n            x = ((x % mod) * (x % mod)) % mod;\\n        }\\n        return ans;\\n    }\\n\\n    string subStrHash(string s, int tmp2, int modulo, int tmp1, int val)\\n    {\\n        long long curr = 0, M = modulo, k = tmp1, p = tmp2;\\n\\n        int n = s.length();\\n\\n        for (int i = n - 1; i > n - k; i--)\\n        {\\n            long long cnt = ((curr % M) * (p % M)) % M;\\n            long long value = (s[i] - \\'a\\' + 1);\\n\\n            curr = ((cnt % M) + (value % M)) % M;\\n        }\\n\\n        long long temp = power(p, k - 1, M);\\n        int j = n - 1, pos;\\n\\n        for (int i = n - k; i >= 0; i--)\\n        {\\n            long long cnt = ((curr % M) * (p % M)) % M;\\n            long long value = (s[i] - \\'a\\' + 1);\\n\\n            curr = ((cnt % M) + (value % M)) % M;\\n\\n            if (curr == val)\\n            {\\n                pos = i;\\n            }\\n\\n            value = (s[j] - \\'a\\' + 1);\\n            j--;\\n\\n            long long del = ((temp % M) * (value % M)) % M;\\n            curr = (curr - del + M) % M;\\n\\n        }\\n\\n        string res;\\n\\n        for (int i = pos; i < pos + k; i++)\\n        {\\n            res += s[i];\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long power(long long x, long long y, long long mod)\\n    {\\n        long long ans = 1;\\n\\n        x = x % mod;\\n\\n        while (y > 0)\\n        {\\n            if (y & 1)\\n                ans = ((ans % mod) * (x % mod)) % mod;\\n\\n            y = y >> 1;\\n            x = ((x % mod) * (x % mod)) % mod;\\n        }\\n        return ans;\\n    }\\n\\n    string subStrHash(string s, int tmp2, int modulo, int tmp1, int val)\\n    {\\n        long long curr = 0, M = modulo, k = tmp1, p = tmp2;\\n\\n        int n = s.length();\\n\\n        for (int i = n - 1; i > n - k; i--)\\n        {\\n            long long cnt = ((curr % M) * (p % M)) % M;\\n            long long value = (s[i] - \\'a\\' + 1);\\n\\n            curr = ((cnt % M) + (value % M)) % M;\\n        }\\n\\n        long long temp = power(p, k - 1, M);\\n        int j = n - 1, pos;\\n\\n        for (int i = n - k; i >= 0; i--)\\n        {\\n            long long cnt = ((curr % M) * (p % M)) % M;\\n            long long value = (s[i] - \\'a\\' + 1);\\n\\n            curr = ((cnt % M) + (value % M)) % M;\\n\\n            if (curr == val)\\n            {\\n                pos = i;\\n            }\\n\\n            value = (s[j] - \\'a\\' + 1);\\n            j--;\\n\\n            long long del = ((temp % M) * (value % M)) % M;\\n            curr = (curr - del + M) % M;\\n\\n        }\\n\\n        string res;\\n\\n        for (int i = pos; i < pos + k; i++)\\n        {\\n            res += s[i];\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730179,
                "title": "c-rolling-hash-o-n",
                "content": "**Explanation** - Let\\'s suppose you have the hash h of s[i....j]. Now, what will you need to do to calculate substring of s[i-1....j-1]?\\n\\n**Steps** - \\n1. You will need to subtract s[j]*pow(power,k-1) from h so that the contribution of jth index is removed. \\n2. **Now you will realise that the contributions of all remaining indexes should be multiplied by power since the window has been shifted to one index left.** So just mulitply h with power. \\n3. Add the contribution of ith index to h.\\nYou can do it from right to left to get the answer for all starting indexes.\\n```\\nclass Solution {\\npublic:\\n    long long int findPow(long long int powerUse, long long int index, vector<int>&dp, long long int mod){\\n        if(dp[index]!=-1)return dp[index];\\n        dp[0]=1%mod;\\n        long long int k=dp.size();\\n        for(int i=1;i<k;i++){\\n            dp[i]=(dp[i-1]*powerUse)%mod;\\n        }\\n        return dp[index];\\n    }\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        long long len=s.length();\\n        long long firstPointer=len-k;\\n        string ans=\"\";\\n        long long int mod=modulo;\\n        long long int powerUse=power%mod;\\n        vector<int>dp(k,-1);\\n        long long sum=0;\\n        for(long long i=0;i<k;i++){\\n            long long index=firstPointer+i;\\n            long long val=(s[index]-\\'a\\'+1)%mod;\\n            long long multiplier=findPow(powerUse,i,dp,mod)%mod;\\n            long long result=(val*multiplier)%mod;\\n            sum=(sum+result)%mod;\\n            if(sum==hashValue)ans=s.substr(firstPointer,k);\\n        }\\n        firstPointer--;\\n        while(firstPointer>=0){\\n            int subtract=(((s[firstPointer+k]-\\'a\\'+1)%mod)*(findPow(powerUse,k-1,dp,mod)%mod))%mod;\\n            sum=(sum-subtract+mod)%mod;\\n            sum=(sum*powerUse)%mod;\\n            int addition=((s[firstPointer]-\\'a\\'+1)%mod);\\n            sum=(sum+addition)%mod;\\n            if(sum==hashValue)ans=s.substr(firstPointer,k);\\n            firstPointer--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int findPow(long long int powerUse, long long int index, vector<int>&dp, long long int mod){\\n        if(dp[index]!=-1)return dp[index];\\n        dp[0]=1%mod;\\n        long long int k=dp.size();\\n        for(int i=1;i<k;i++){\\n            dp[i]=(dp[i-1]*powerUse)%mod;\\n        }\\n        return dp[index];\\n    }\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        long long len=s.length();\\n        long long firstPointer=len-k;\\n        string ans=\"\";\\n        long long int mod=modulo;\\n        long long int powerUse=power%mod;\\n        vector<int>dp(k,-1);\\n        long long sum=0;\\n        for(long long i=0;i<k;i++){\\n            long long index=firstPointer+i;\\n            long long val=(s[index]-\\'a\\'+1)%mod;\\n            long long multiplier=findPow(powerUse,i,dp,mod)%mod;\\n            long long result=(val*multiplier)%mod;\\n            sum=(sum+result)%mod;\\n            if(sum==hashValue)ans=s.substr(firstPointer,k);\\n        }\\n        firstPointer--;\\n        while(firstPointer>=0){\\n            int subtract=(((s[firstPointer+k]-\\'a\\'+1)%mod)*(findPow(powerUse,k-1,dp,mod)%mod))%mod;\\n            sum=(sum-subtract+mod)%mod;\\n            sum=(sum*powerUse)%mod;\\n            int addition=((s[firstPointer]-\\'a\\'+1)%mod);\\n            sum=(sum+addition)%mod;\\n            if(sum==hashValue)ans=s.substr(firstPointer,k);\\n            firstPointer--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746101,
                "title": "java-sliding-window-rolling-hash-o-n",
                "content": "**Modular Arithmetic**\\n1. ``` (a+b) % modulo = ( (a % modulo) + (b % modulo) ) % modulo; ```\\n2. ``` (a-b) % modulo = ( (a % modulo) - (b % modulo) + modulo ) % modulo; ```\\n3. ``` (a*b) % modulo = ( (a % modulo) * (b % modulo) ) % modulo; ```\\n4. ``` (a/b) % modulo = ( (a % modulo) * ( (b^-1) % modulo) ) % modulo; ```\\n\\nif you see the division for modular arithmetic (4), we need to take the multiplicative inverse of b,\\nwhich is quite complex than the actual multiplication of modular arithmetic.\\n\\nIf we go from start to end traversal, once the pre computation is done, for every slide to calculate the \\nhash, we need to divide by power, meaning should take the multiplicative inverse on every computation. that is the reason why we are going from behind and you can see the multiplication in the below code. (referred as MULTIPLICATION in code comments)\\n\\n```\\nclass Solution {\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n\\t\\t// calculate all the powers from power^0 till power^k\\n\\t\\t// utilized binary exponentiation\\n\\t\\tlong[] powers = new long[k];\\n        for (int i = 0; i < k; i++) \\n            powers[i] = binaryExponentiation(power, i, modulo);\\n        \\n\\t\\t// pre compute the initial hash from behind.\\n\\t\\t// I have explained at top you why traversing from behind is easy\\n        long currentHashValue = 0;\\n        int index = s.length() - 1;\\n        int powerIndex = k-1;\\n        while (index >= s.length() - k) {\\n\\t\\t\\t// (a+b) % modulo = ( (a % modulo) + (b % modulo) ) % modulo;\\n\\t\\t\\t// do it for k times from behind\\n            currentHashValue += ((s.charAt(index--) - \\'a\\' + 1) % modulo * powers[powerIndex--] % modulo) % modulo;\\n        }\\n        currentHashValue %= modulo;\\n        \\n        int startIndex = 0;\\n        if (currentHashValue == hashValue) {\\n            startIndex = s.length() - k;\\n        }\\n        \\n\\t\\t// I have pre computed already for k values from behind. so start from (length of S - k - 1)\\n\\t\\t// Let\\'s take an example of \"leetcode\" itself\\n\\t\\t// \"de\" is pre computed\\n\\t\\t// point is to add one character from behind and remove one from end (Sliding from back to first)\\n\\t\\t// Modular Arithmetic for (a-b) % modulo = ( (a % modulo) - (b % modulo) + modulo) % modulo;\\n\\t\\t// keep tracking of the start index if hash value matches. That\\'s it.\\n        for (int i = s.length() - k - 1; i >= 0; i--) {\\n\\t\\t\\t// below line a --> currentHashValue \\n\\t\\t\\t// below line b --> (s.charAt(i+k) - \\'a\\' + 1 * powers[k-1])\\n            currentHashValue = ((currentHashValue % modulo) - (((s.charAt(i+k) - \\'a\\' + 1) * powers[k-1]) % modulo) + modulo) % modulo;\\n\\t\\t\\t// we need to multiply a power once for all\\n\\t\\t\\t// MULTIPLICATION\\n            currentHashValue = currentHashValue * power;\\n\\t\\t\\t// Modular Arithmetic for (a+b) % modulo is below line\\n            currentHashValue = (currentHashValue % modulo + (s.charAt(i) - \\'a\\' + 1) % modulo) % modulo;\\n            \\n            if (currentHashValue == hashValue) {\\n                startIndex = i;\\n            }\\n        }\\n        return s.substring(startIndex, startIndex+k);\\n    }\\n    \\n    private long binaryExponentiation(long a, long b, long mod) {\\n        a %= mod;\\n        long result = 1;\\n        while (b > 0) {\\n            if (b % 2 == 1)\\n                result = result * a % mod;\\n            a = a * a % mod;\\n            b >>= 1;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` (a+b) % modulo = ( (a % modulo) + (b % modulo) ) % modulo; ```\n``` (a-b) % modulo = ( (a % modulo) - (b % modulo) + modulo ) % modulo; ```\n``` (a*b) % modulo = ( (a % modulo) * (b % modulo) ) % modulo; ```\n``` (a/b) % modulo = ( (a % modulo) * ( (b^-1) % modulo) ) % modulo; ```\n```\\nclass Solution {\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n\\t\\t// calculate all the powers from power^0 till power^k\\n\\t\\t// utilized binary exponentiation\\n\\t\\tlong[] powers = new long[k];\\n        for (int i = 0; i < k; i++) \\n            powers[i] = binaryExponentiation(power, i, modulo);\\n        \\n\\t\\t// pre compute the initial hash from behind.\\n\\t\\t// I have explained at top you why traversing from behind is easy\\n        long currentHashValue = 0;\\n        int index = s.length() - 1;\\n        int powerIndex = k-1;\\n        while (index >= s.length() - k) {\\n\\t\\t\\t// (a+b) % modulo = ( (a % modulo) + (b % modulo) ) % modulo;\\n\\t\\t\\t// do it for k times from behind\\n            currentHashValue += ((s.charAt(index--) - \\'a\\' + 1) % modulo * powers[powerIndex--] % modulo) % modulo;\\n        }\\n        currentHashValue %= modulo;\\n        \\n        int startIndex = 0;\\n        if (currentHashValue == hashValue) {\\n            startIndex = s.length() - k;\\n        }\\n        \\n\\t\\t// I have pre computed already for k values from behind. so start from (length of S - k - 1)\\n\\t\\t// Let\\'s take an example of \"leetcode\" itself\\n\\t\\t// \"de\" is pre computed\\n\\t\\t// point is to add one character from behind and remove one from end (Sliding from back to first)\\n\\t\\t// Modular Arithmetic for (a-b) % modulo = ( (a % modulo) - (b % modulo) + modulo) % modulo;\\n\\t\\t// keep tracking of the start index if hash value matches. That\\'s it.\\n        for (int i = s.length() - k - 1; i >= 0; i--) {\\n\\t\\t\\t// below line a --> currentHashValue \\n\\t\\t\\t// below line b --> (s.charAt(i+k) - \\'a\\' + 1 * powers[k-1])\\n            currentHashValue = ((currentHashValue % modulo) - (((s.charAt(i+k) - \\'a\\' + 1) * powers[k-1]) % modulo) + modulo) % modulo;\\n\\t\\t\\t// we need to multiply a power once for all\\n\\t\\t\\t// MULTIPLICATION\\n            currentHashValue = currentHashValue * power;\\n\\t\\t\\t// Modular Arithmetic for (a+b) % modulo is below line\\n            currentHashValue = (currentHashValue % modulo + (s.charAt(i) - \\'a\\' + 1) % modulo) % modulo;\\n            \\n            if (currentHashValue == hashValue) {\\n                startIndex = i;\\n            }\\n        }\\n        return s.substring(startIndex, startIndex+k);\\n    }\\n    \\n    private long binaryExponentiation(long a, long b, long mod) {\\n        a %= mod;\\n        long result = 1;\\n        while (b > 0) {\\n            if (b % 2 == 1)\\n                result = result * a % mod;\\n            a = a * a % mod;\\n            b >>= 1;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731864,
                "title": "c-sol-without-reversing-string",
                "content": "To avoid division during calculation of running hash from left to right,\\nI multipled with the power, and that power factor will keep on increasing.\\n\\nSuppose the string is `abcdefxsf` then, first `k=3` substring is `abc`, and let `ans` be the hash of the `k` length substring which we have to find.\\nLet us assume, `A_0` = `abc`, `A_1` = `bcd`, and `A_2` = `cde` and so on.., be the `i`th substring of `k`th length, then I do following comparisions,\\n\\n`hash(A_0) == ans` \\n`hash(A_1) * p == ans * p`\\n`hash(A_2) * p^2 == ans * p^2`\\n`hash(A_3) * p^3 == ans * p^3` \\nans so on.\\n\\nwhy multiply by power because it gives a recurrence relation, let `A_n+1` be \\n`A_n + l - m`, that is `A_n+1` is formed by removing, `m` form the front of `A_n` and adding `l` to its end, then\\n\\n`hash(A_n+1) * p^(n+1)` `=` `hash(A_n) * p^n` `-` `m*p^n` + `l*p^(n+k)`,\\n\\n>note that, we already have `hash(A_n) * p^n`, and we want to calculate\\n>`hash(A_n+1) * p^(n+1)`.\\n\\nNote after comparing `(hash(A_n) * p^n) mod m` and `(ans * p^n) mod m`,\\nif they are equal it doesn\\'t mean `hash(A_n) = ans`, because of following rule\\n`ac=bc (mod m)` implies `a=b (mod m)` iff `gcd(c, m)=1`, there we have to check \\nif `hash(A_n)` is equal to `ans` and then return that string.\\n\\n\\n```cpp\\n#define lli long long\\nclass Solution {\\npublic:\\n    vector<int> p;\\n    lli calculateHash(string s, lli power, lli m) {\\n        lli hash = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            hash = (hash + (lli)(s[i] - \\'a\\' + 1) * p[i]) % m;\\n        }\\n        return hash;\\n    }\\n    string subStrHash(string s, lli power, lli m, lli k, lli ans) {\\n        p = vector<int>(k, 1);\\n        lli hash = 0, n = s.length(), p1 = 1, newhash = 0, p2 = 1;\\n        for (int i = 0; i < k; i++) {\\n            hash = (hash + (lli)(s[i] - \\'a\\' + 1) * p1) % m;\\n            p[i] = p1;\\n            p1 = (p1 * power) % m;\\n        }\\n        if (hash == ans) return s.substr(0, k);\\n        for (int i = k; i < n; i++) {\\n            lli remove = ((lli)(s[i - k] - \\'a\\' + 1) * p2) % m;\\n            lli addVal = ((lli)(s[i] - \\'a\\' + 1) * p1) % m;\\n            hash = (hash - remove + addVal) % m;\\n            while (hash < 0) hash += m;\\n            p2 = (p2 * power) % m;\\n            if (hash == (ans * p2) % m &&\\n                calculateHash(s.substr(i - k + 1, k), power, m) == ans)\\n                return s.substr(i - k + 1, k);\\n            p1 = (p1 * power) % m;\\n        }\\n        return \"\";\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```cpp\\n#define lli long long\\nclass Solution {\\npublic:\\n    vector<int> p;\\n    lli calculateHash(string s, lli power, lli m) {\\n        lli hash = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            hash = (hash + (lli)(s[i] - \\'a\\' + 1) * p[i]) % m;\\n        }\\n        return hash;\\n    }\\n    string subStrHash(string s, lli power, lli m, lli k, lli ans) {\\n        p = vector<int>(k, 1);\\n        lli hash = 0, n = s.length(), p1 = 1, newhash = 0, p2 = 1;\\n        for (int i = 0; i < k; i++) {\\n            hash = (hash + (lli)(s[i] - \\'a\\' + 1) * p1) % m;\\n            p[i] = p1;\\n            p1 = (p1 * power) % m;\\n        }\\n        if (hash == ans) return s.substr(0, k);\\n        for (int i = k; i < n; i++) {\\n            lli remove = ((lli)(s[i - k] - \\'a\\' + 1) * p2) % m;\\n            lli addVal = ((lli)(s[i] - \\'a\\' + 1) * p1) % m;\\n            hash = (hash - remove + addVal) % m;\\n            while (hash < 0) hash += m;\\n            p2 = (p2 * power) % m;\\n            if (hash == (ans * p2) % m &&\\n                calculateHash(s.substr(i - k + 1, k), power, m) == ans)\\n                return s.substr(i - k + 1, k);\\n            p1 = (p1 * power) % m;\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731228,
                "title": "c",
                "content": "**For taking the string in forword direction we have to use inverse module but we done this question by reversing the string. After reversing the their is No use of division and got the correct answer**\\n*So first reverse the string and by using sliding window technique we just find out our answer*\\n\\n```\\nclass Solution {\\npublic:\\n    // power function for calculation of power that not contain in long long\\n    long long power(int n,int r,long long mod)\\n    {\\n        if(r==0)\\n            return 1;\\n        if(r==1)\\n        {\\n            return (n%mod);\\n        }\\n        long long ans=1;\\n        long long know=power(n,r/2,mod)%mod; // splitting in 2 part\\n        if(r%2==1)\\n        {\\n            ans=(ans*n)%mod;\\n        }\\n        return (ans*((know*know)%mod))%mod;\\n    }\\n\\t\\n    string subStrHash(string s, int p, int mod, int k, int h) {\\n     long long ans=0;\\n        reverse(s.begin(),s.end());\\n        string fans; // Final ans string\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(i<k)\\n            {\\n              ans=(ans+((s[i]-\\'a\\'+1)*power(p,k-1-i,mod))%mod)%mod;\\n                continue;\\n            }\\n            if(ans==h)\\n            {\\n                string temp=s.substr(i-k,k);\\n                reverse(temp.begin(),temp.end());\\n                fans=temp;\\n            }\\n            ans=(ans+mod-((s[i-k]-\\'a\\'+1)*power(p,k-1,mod))%mod)%mod;\\n            ans=(ans*p)%mod;\\n            ans=(ans+(s[i]-\\'a\\'+1))%mod;\\n        }\\n          if(ans==h)\\n            {\\n                string temp=s.substr(s.size()-k,k);\\n                reverse(temp.begin(),temp.end());\\n                fans=temp;\\n            }\\n        return fans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // power function for calculation of power that not contain in long long\\n    long long power(int n,int r,long long mod)\\n    {\\n        if(r==0)\\n            return 1;\\n        if(r==1)\\n        {\\n            return (n%mod);\\n        }\\n        long long ans=1;\\n        long long know=power(n,r/2,mod)%mod; // splitting in 2 part\\n        if(r%2==1)\\n        {\\n            ans=(ans*n)%mod;\\n        }\\n        return (ans*((know*know)%mod))%mod;\\n    }\\n\\t\\n    string subStrHash(string s, int p, int mod, int k, int h) {\\n     long long ans=0;\\n        reverse(s.begin(),s.end());\\n        string fans; // Final ans string\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(i<k)\\n            {\\n              ans=(ans+((s[i]-\\'a\\'+1)*power(p,k-1-i,mod))%mod)%mod;\\n                continue;\\n            }\\n            if(ans==h)\\n            {\\n                string temp=s.substr(i-k,k);\\n                reverse(temp.begin(),temp.end());\\n                fans=temp;\\n            }\\n            ans=(ans+mod-((s[i-k]-\\'a\\'+1)*power(p,k-1,mod))%mod)%mod;\\n            ans=(ans*p)%mod;\\n            ans=(ans+(s[i]-\\'a\\'+1))%mod;\\n        }\\n          if(ans==h)\\n            {\\n                string temp=s.substr(s.size()-k,k);\\n                reverse(temp.begin(),temp.end());\\n                fans=temp;\\n            }\\n        return fans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731081,
                "title": "python-o-n-solution-using-sliding-window-100-space-optimised",
                "content": "Use the sliding window approach to calculate the hashvalue ->> each time just remove the value of 1st char and add the value of the next char.\\n```\\ndef subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        n=len(s)\\n        i=0\\n        j=0\\n        res=[]\\n        result=0\\n        a=1\\n        while(j<n):\\n            res.append(s[j])\\n            if(j<k and j!=0):\\n                a=a*power\\n            result=result+(ord(s[j])-ord(\\'a\\')+1)*a\\n            if(j-i+1>=k):\\n                if(result%modulo==hashValue):\\n                    return \"\".join(res)\\n                res.pop(0)\\n                result=result-(ord(s[i])-ord(\\'a\\')+1)\\n                result=result//power\\n                i=i+1\\n            j=j+1\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\ndef subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        n=len(s)\\n        i=0\\n        j=0\\n        res=[]\\n        result=0\\n        a=1\\n        while(j<n):\\n            res.append(s[j])\\n            if(j<k and j!=0):\\n                a=a*power\\n            result=result+(ord(s[j])-ord(\\'a\\')+1)*a\\n            if(j-i+1>=k):\\n                if(result%modulo==hashValue):\\n                    return \"\".join(res)\\n                res.pop(0)\\n                result=result-(ord(s[i])-ord(\\'a\\')+1)\\n                result=result//power\\n                i=i+1\\n            j=j+1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1730861,
                "title": "c-rolling-hash-sliding-window-o-n",
                "content": "```cpp\\nclass Solution {\\npublic:\\n\\tstring subStrHash(string s, int p, int m, int K, int hx) {\\n\\t\\treverse(s.begin(), s.end());\\n\\t\\tlong long b = 1, h = 0;\\n\\t\\tint ind = -1, n = s.size();\\n\\t\\tfor (int i = 0, j = K - 1; j < n; i++, j++) {\\n\\t\\t\\tif (i == 0) {\\n\\t\\t\\t\\tfor (int k = 0; k < K; k++) {\\n\\t\\t\\t\\t\\th = (1LL * h * p + (s[k] - \\'a\\' + 1)) % m;\\n\\t\\t\\t\\t\\tb = (1LL * b * p) % m;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\th = (1LL * h * p + (s[j] - \\'a\\' + 1)) % m;\\n\\t\\t\\t\\th = (h - 1LL * b * (s[i - 1] - \\'a\\' + 1)) % m;\\n\\t\\t\\t\\tif (h < 0)h += m;\\n\\t\\t\\t}\\n\\t\\t\\tif (h == hx) {\\n\\t\\t\\t\\tind = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ts = s.substr(ind, K);\\n\\t\\treverse(s.begin(), s.end());\\n\\t\\treturn s;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n\\tstring subStrHash(string s, int p, int m, int K, int hx) {\\n\\t\\treverse(s.begin(), s.end());\\n\\t\\tlong long b = 1, h = 0;\\n\\t\\tint ind = -1, n = s.size();\\n\\t\\tfor (int i = 0, j = K - 1; j < n; i++, j++) {\\n\\t\\t\\tif (i == 0) {\\n\\t\\t\\t\\tfor (int k = 0; k < K; k++) {\\n\\t\\t\\t\\t\\th = (1LL * h * p + (s[k] - \\'a\\' + 1)) % m;\\n\\t\\t\\t\\t\\tb = (1LL * b * p) % m;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\th = (1LL * h * p + (s[j] - \\'a\\' + 1)) % m;\\n\\t\\t\\t\\th = (h - 1LL * b * (s[i - 1] - \\'a\\' + 1)) % m;\\n\\t\\t\\t\\tif (h < 0)h += m;\\n\\t\\t\\t}\\n\\t\\t\\tif (h == hx) {\\n\\t\\t\\t\\tind = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ts = s.substr(ind, K);\\n\\t\\treverse(s.begin(), s.end());\\n\\t\\treturn s;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730153,
                "title": "o-n-solution-why-didn-t-it-get-accepted-isn-t-it-o-n",
                "content": "**Isn\\'t this below approach is O(n)?\\nWhere did i go wrong?**\\n\\n```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        ns = []\\n        for i in s:\\n            ns.append(ord(i)-96)\\n        i = 0\\n        sum_ = 0\\n\\t\\t# for first k\\n        for i in range(k):\\n            sum_+=ns[i]* power**i\\n        if sum_%modulo == hashValue:\\n            return s[:k]\\n        i = 1\\n        while i+k <= len(ns):\\n\\t\\t\\t# remove i-1 th value and add i+k-1 index value as below\\n            sum_-=ns[i-1]\\n            sum_//=power\\n            sum_ += ns[i+k-1] * power**(k-1)\\n            if sum_%modulo == hashValue:\\n                return s[i:i+k]\\n            i+=1\\n        \\n        return None\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        ns = []\\n        for i in s:\\n            ns.append(ord(i)-96)\\n        i = 0\\n        sum_ = 0\\n\\t\\t# for first k\\n        for i in range(k):\\n            sum_+=ns[i]* power**i\\n        if sum_%modulo == hashValue:\\n            return s[:k]\\n        i = 1\\n        while i+k <= len(ns):\\n\\t\\t\\t# remove i-1 th value and add i+k-1 index value as below\\n            sum_-=ns[i-1]\\n            sum_//=power\\n            sum_ += ns[i+k-1] * power**(k-1)\\n            if sum_%modulo == hashValue:\\n                return s[i:i+k]\\n            i+=1\\n        \\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738558,
                "title": "simple-java-solution",
                "content": "```\\npublic String subStrHash(String s, int power, int mod, int k, int hashValue) {\\n\\t\\tlong hash = 0;\\n\\t\\tlong powerk = 1;\\n\\t\\tint n = s.length();\\n\\t\\tint res = 0;\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\thash = (hash * power + s.charAt(i) - \\'a\\' + 1) % mod;\\n\\t\\t\\tif (i + k >= n) {\\n\\t\\t\\t\\tpowerk = powerk * power % mod;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thash = (hash - (((s.charAt(i + k) - \\'a\\' + 1) * powerk) % mod) + mod) % mod;\\n\\t\\t\\t}\\n\\t\\t\\tif (hash == hashValue) {\\n\\t\\t\\t\\tres = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn s.substring(res, res + k);\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Rolling Hash"
                ],
                "code": "```\\npublic String subStrHash(String s, int power, int mod, int k, int hashValue) {\\n\\t\\tlong hash = 0;\\n\\t\\tlong powerk = 1;\\n\\t\\tint n = s.length();\\n\\t\\tint res = 0;\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\thash = (hash * power + s.charAt(i) - \\'a\\' + 1) % mod;\\n\\t\\t\\tif (i + k >= n) {\\n\\t\\t\\t\\tpowerk = powerk * power % mod;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thash = (hash - (((s.charAt(i + k) - \\'a\\' + 1) * powerk) % mod) + mod) % mod;\\n\\t\\t\\t}\\n\\t\\t\\tif (hash == hashValue) {\\n\\t\\t\\t\\tres = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn s.substring(res, res + k);\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1734568,
                "title": "o-n-solution-rolling-hash-detailed-explanation",
                "content": "I highly recommend you to understand the Rabin Karp algorithm (rolling hash functionality) before solving this problem. \\n**Prerequisite:**\\nhttps://leetcode.com/problems/longest-happy-prefix/\\n```\\nstring subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n\\t// Stores the starting index of the ans string\\n\\tint ans = 0;\\n\\t\\n\\t// Calculate the (power^(k-1)) value\\n\\t// It is used while moving the window .i.e. removing the left most character from the window\\n\\tlong powerk = 1;\\n\\tfor(int i=1; i<k; i++){\\n\\t\\tpowerk = (power*powerk)%modulo;\\n\\t}\\n\\t\\n\\t// Reversing the string, so that we can use the rolling hash approach\\n\\treverse(s.begin(), s.end());\\n\\n\\t// Note: As we reversed the string, we need to find the last possible substring \\n\\t// whose hash matches the given hashValue\\n\\t\\n\\tint start=0, end=0;\\n\\t\\n\\twhile(end < s.size()){\\n\\t\\t// Adding the character to the window \\n\\t\\thash = (hash*power + (s[end]-\\'a\\'+1))%modulo;\\n\\t\\t// Length of string is k, then check if it satisfies the hashValue or not\\n\\t\\tif(end-start+1 == k){\\n\\t\\t\\t// hash and hashValue are equal\\n\\t\\t\\tif(hashValue == hash){\\n\\t\\t\\t\\t// Storing the last index of the substring (which will be the starting index when we revert back the string)\\n\\t\\t\\t\\tans = end;\\n\\t\\t\\t}\\n\\t\\t\\t// Remove the first character, so that we can check the next possible substring\\n\\t\\t\\thash = (hash - (s[start]-\\'a\\'+1)*powerk)%modulo;\\n\\t\\t\\tif(hash <= 0){\\n\\t\\t\\t\\thash += modulo;\\n\\t\\t\\t}\\n\\t\\t\\tstart++;\\n\\t\\t}\\n\\t\\tend++;\\n\\t}\\n\\t// As the string is reversed, we also need to reverse index (subtract from string length) to get the starting index of the ans substring\\n\\tint start_ind = s.size()-ans-1; \\n\\treverse(s.begin(), s.end());\\n\\n\\treturn s.substr(start_ind, k);\\n}\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Rolling Hash"
                ],
                "code": "```\\nstring subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n\\t// Stores the starting index of the ans string\\n\\tint ans = 0;\\n\\t\\n\\t// Calculate the (power^(k-1)) value\\n\\t// It is used while moving the window .i.e. removing the left most character from the window\\n\\tlong powerk = 1;\\n\\tfor(int i=1; i<k; i++){\\n\\t\\tpowerk = (power*powerk)%modulo;\\n\\t}\\n\\t\\n\\t// Reversing the string, so that we can use the rolling hash approach\\n\\treverse(s.begin(), s.end());\\n\\n\\t// Note: As we reversed the string, we need to find the last possible substring \\n\\t// whose hash matches the given hashValue\\n\\t\\n\\tint start=0, end=0;\\n\\t\\n\\twhile(end < s.size()){\\n\\t\\t// Adding the character to the window \\n\\t\\thash = (hash*power + (s[end]-\\'a\\'+1))%modulo;\\n\\t\\t// Length of string is k, then check if it satisfies the hashValue or not\\n\\t\\tif(end-start+1 == k){\\n\\t\\t\\t// hash and hashValue are equal\\n\\t\\t\\tif(hashValue == hash){\\n\\t\\t\\t\\t// Storing the last index of the substring (which will be the starting index when we revert back the string)\\n\\t\\t\\t\\tans = end;\\n\\t\\t\\t}\\n\\t\\t\\t// Remove the first character, so that we can check the next possible substring\\n\\t\\t\\thash = (hash - (s[start]-\\'a\\'+1)*powerk)%modulo;\\n\\t\\t\\tif(hash <= 0){\\n\\t\\t\\t\\thash += modulo;\\n\\t\\t\\t}\\n\\t\\t\\tstart++;\\n\\t\\t}\\n\\t\\tend++;\\n\\t}\\n\\t// As the string is reversed, we also need to reverse index (subtract from string length) to get the starting index of the ans substring\\n\\tint start_ind = s.size()-ans-1; \\n\\treverse(s.begin(), s.end());\\n\\n\\treturn s.substr(start_ind, k);\\n}\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1732936,
                "title": "python3-rolling-hash",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/badfbf601ede2f43ba191b567d6f5c7e0d046286) for solutions of weekly 278. \\n\\n```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        pp = pow(power, k-1, modulo)\\n        hs = ii = 0 \\n        for i, ch in enumerate(reversed(s)): \\n            if i >= k: hs -= (ord(s[~(i-k)]) - 96)*pp\\n            hs = (hs * power + (ord(ch) - 96)) % modulo\\n            if i >= k-1 and hs == hashValue: ii = i \\n        return s[~ii:~ii+k or None]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        pp = pow(power, k-1, modulo)\\n        hs = ii = 0 \\n        for i, ch in enumerate(reversed(s)): \\n            if i >= k: hs -= (ord(s[~(i-k)]) - 96)*pp\\n            hs = (hs * power + (ord(ch) - 96)) % modulo\\n            if i >= k-1 and hs == hashValue: ii = i \\n        return s[~ii:~ii+k or None]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732709,
                "title": "go-sliding-window-be-careful-about-modular-arithmatic",
                "content": "Make sure you can answer the following questions:\\n- What is the behavior of taking modulo of negative numbers?\\n\\t- i.e., a % m =? when a is a negative integer\\n- Does the result change when multiplying before and after taking a modulo?\\n\\t- i.e., p*(a % m) % m ==? (p*a) % m\\n- Can we do division with modulo?\\n\\t- i.e., (p*a) % m / p ==? a % m\\n\\n```go\\nfunc subStrHash(s string, power int, m int, k int, hashValue int) string {\\n\\tn := len(s)\\n\\th := (int(s[n-1]) - 96) % m\\n\\tp := 1\\n\\tans := \"\"\\n\\tfor i := n - 1; i-k+1 >= 0; i-- {\\n\\t\\tif i == n-1 {\\n\\t\\t\\tfor j := 1; j < k; j++ {\\n\\t\\t\\t\\th = (h*power%m + int(s[i-j]) - 96) % m\\n\\t\\t\\t\\tp = p * power % m\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\th = ((h-(int(s[i+1])-96)*p%m+m)*power + int(s[i-k+1]) - 96) % m\\n\\t\\t}\\n\\t\\tif h == hashValue {\\n\\t\\t\\tans = s[i-k+1 : i+1]\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc subStrHash(s string, power int, m int, k int, hashValue int) string {\\n\\tn := len(s)\\n\\th := (int(s[n-1]) - 96) % m\\n\\tp := 1\\n\\tans := \"\"\\n\\tfor i := n - 1; i-k+1 >= 0; i-- {\\n\\t\\tif i == n-1 {\\n\\t\\t\\tfor j := 1; j < k; j++ {\\n\\t\\t\\t\\th = (h*power%m + int(s[i-j]) - 96) % m\\n\\t\\t\\t\\tp = p * power % m\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\th = ((h-(int(s[i+1])-96)*p%m+m)*power + int(s[i-k+1]) - 96) % m\\n\\t\\t}\\n\\t\\tif h == hashValue {\\n\\t\\t\\tans = s[i-k+1 : i+1]\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1731564,
                "title": "c-rolling-hash-why-we-cant-use-the-division-and-comments",
                "content": "**you cannot use division as mod might not be prime Fermats\\u2019s little theorem** \\n```\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int p, int mod, int k, int h) {\\n        int n = s.length();\\n        int cur = 0;\\n        vector<int>P(k + 1,0);\\n        int index = -1;\\n        P[0] = 1;\\n        for(int i = 1; i <= k; i++)//storing the powers\\n        {\\n            P[i] = (1ll*P[i - 1] * p)  % mod;\\n        }\\n        for(int i =  n - k; i < n; i++)// we have to start from the end as we will multiply with p not divide\\n        {\\n            cur += (1ll*(s[i] - \\'a\\' + 1) * P[i - (n - k)]) % mod;\\n            cur = cur % mod;\\n        }\\n        \\n        for(int i = n - k - 1; i >= 0; i--)\\n        {\\n            if(cur == h)\\n            {\\n                index = i + 1;//we have to get the first from the beginning\\n            }\\n            cur =   (1ll* cur * p) % mod;\\n            cur = (cur + (s[i] - \\'a\\' + 1)) % mod ;\\n            int temp = (1ll*(s[i + k] - \\'a\\' + 1) * P[k]) % mod;\\n            cur = (cur - temp + mod) % mod;\\n            \\n        }\\n        if(cur == h)\\n        {\\n           return s.substr(0,k);\\n        }\\n        return s.substr(index,k);\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int p, int mod, int k, int h) {\\n        int n = s.length();\\n        int cur = 0;\\n        vector<int>P(k + 1,0);\\n        int index = -1;\\n        P[0] = 1;\\n        for(int i = 1; i <= k; i++)//storing the powers\\n        {\\n            P[i] = (1ll*P[i - 1] * p)  % mod;\\n        }\\n        for(int i =  n - k; i < n; i++)// we have to start from the end as we will multiply with p not divide\\n        {\\n            cur += (1ll*(s[i] - \\'a\\' + 1) * P[i - (n - k)]) % mod;\\n            cur = cur % mod;\\n        }\\n        \\n        for(int i = n - k - 1; i >= 0; i--)\\n        {\\n            if(cur == h)\\n            {\\n                index = i + 1;//we have to get the first from the beginning\\n            }\\n            cur =   (1ll* cur * p) % mod;\\n            cur = (cur + (s[i] - \\'a\\' + 1)) % mod ;\\n            int temp = (1ll*(s[i + k] - \\'a\\' + 1) * P[k]) % mod;\\n            cur = (cur - temp + mod) % mod;\\n            \\n        }\\n        if(cur == h)\\n        {\\n           return s.substr(0,k);\\n        }\\n        return s.substr(index,k);\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730424,
                "title": "python-sliding-window-concept-of-rolling-hash-approach-explained-o-n",
                "content": "**Please upvote if you like this approach.  And feel free to ask any question!**\\n\\nHere is a linear solution that passes all tests. It used tghe idea of rolling hash. The idea is\\n* If you have an hash of a window of size k, to add a new item to thw window, you remove the back item and add a new one. That is you subtract the hash of back item and add the has of frotn item\\n\\n```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        def val(ch):\\n            return ord(ch) - ord(\\'a\\') + 1\\n        \\n        def build_res(start,):\\n            res = []\\n            for i in range(start, start + k):\\n                res.append(s[i])\\n            return \"\".join(res)\\n                \\n\\n        curr_hash = 0\\n        p = 1\\n        for i in range(k):\\n            curr_hash += (val(s[i]) * p)\\n            p *= power\\n\\n            \\n        b, pk = 0, pow(power, k)\\n        for i in range(k, len(s)):\\n            if curr_hash % modulo == hashValue:\\n                return build_res(b)\\n            \\n            curr_hash -= (val(s[b]))\\n            curr_hash += (val(s[i]) * pk)\\n            curr_hash //= power # remove a multiple of power\\n            b += 1\\n        \\n        return build_res(b)\\n```\\nTime: O(N)\\nSpace: O(1)",
                "solutionTags": [
                    "Python",
                    "Sliding Window",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        def val(ch):\\n            return ord(ch) - ord(\\'a\\') + 1\\n        \\n        def build_res(start,):\\n            res = []\\n            for i in range(start, start + k):\\n                res.append(s[i])\\n            return \"\".join(res)\\n                \\n\\n        curr_hash = 0\\n        p = 1\\n        for i in range(k):\\n            curr_hash += (val(s[i]) * p)\\n            p *= power\\n\\n            \\n        b, pk = 0, pow(power, k)\\n        for i in range(k, len(s)):\\n            if curr_hash % modulo == hashValue:\\n                return build_res(b)\\n            \\n            curr_hash -= (val(s[b]))\\n            curr_hash += (val(s[i]) * pk)\\n            curr_hash //= power # remove a multiple of power\\n            b += 1\\n        \\n        return build_res(b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730423,
                "title": "c-o-1-space-best-solution-well-explained-with-comments",
                "content": "Runtime: 19 ms, faster than 74.18% of C++ online submissions for Find Substring With Given Hash Value.\\nMemory Usage: 8.60 MB, less than 67.20% of C++ online submissions for Find Substring With Given Hash Value.\\n********-----------------------------------------------------------------------********\\n\\nfirst reverse the string then check compute value of h for every window\\n\\n```\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int p, int mod, int k, int target) {\\n        long h = 0, N = s.size(), pp = 1;\\n        int pos = -1;\\n        string r(rbegin(s), rend(s)); //reverse string\\n        for (int i = 0; i < N; ++i) {\\n            if (i < k) pp = pp * p % mod; //final value of p^k in pp\\n            h = (h * p + (r[i] - \\'a\\' + 1)) % mod; \\n            if (i - k >= 0) { \\n                h = (h - (r[i - k] - \\'a\\' + 1) * pp % mod + mod) % mod;\\n            }\\n            if(h == target) pos = i; //store position of last  matching target\\n        }\\n        if(pos == -1) return \"\";\\n        pos = N-pos-1;  //position in reverse string\\n        return s.substr(pos, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int p, int mod, int k, int target) {\\n        long h = 0, N = s.size(), pp = 1;\\n        int pos = -1;\\n        string r(rbegin(s), rend(s)); //reverse string\\n        for (int i = 0; i < N; ++i) {\\n            if (i < k) pp = pp * p % mod; //final value of p^k in pp\\n            h = (h * p + (r[i] - \\'a\\' + 1)) % mod; \\n            if (i - k >= 0) { \\n                h = (h - (r[i - k] - \\'a\\' + 1) * pp % mod + mod) % mod;\\n            }\\n            if(h == target) pos = i; //store position of last  matching target\\n        }\\n        if(pos == -1) return \"\";\\n        pos = N-pos-1;  //position in reverse string\\n        return s.substr(pos, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730366,
                "title": "sliding-window-from-back",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    int calcpow(int num, int k, int modulo)\\n    {\\n        long long int n = num;\\n        long long int ans = 1;\\n        while(k)\\n        {\\n            if(k%2 == 0)\\n            {\\n                k = k>>1;\\n                 n = (n*n)%modulo;\\n            }\\n            else\\n            {\\n                k--;\\n                ans = (ans*n)%modulo;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    string subStrHash(string s, int power, int modulo, int k, int hashvalue) {\\n        int windowend = s.size()-1;\\n        long long int ans = 0;\\n        int windowsize = 0;\\n        pair<int,int> coord = {0,0};\\n        \\n        for(int windowstart = s.size()-1; windowstart >= 0 ; windowstart--)\\n        {\\n            ans = (ans*power + s[windowstart] - \\'a\\' + 1)%modulo;\\n            windowsize++;\\n            \\n            while(windowsize >= k)\\n            {\\n                if(ans == hashvalue)\\n                {\\n                    coord = {windowstart, windowend};\\n                }\\n                long long int sub = ((1LL*s[windowend] - \\'a\\' + 1)*(calcpow(power, windowsize-1, modulo)))%modulo;\\n                ans = (ans - sub + modulo)%modulo;  \\n                windowend--;\\n                windowsize--;\\n            }\\n        }\\n        return s.substr(coord.first, coord.second - coord.first + 1);\\n    }\\n};\\n```\\nNotice that in the problem if we want to use sliding window technique from front to back, we need to subtract first character from the answer and then divide the whole answer by power, but the division here would be modular division which requires the modulo and power to be coprime, which is not guaranteed here. So we traverse from back and in the reverse transition we need to do multiplication which is easy to handle in modulo arithmetic.",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    int calcpow(int num, int k, int modulo)\\n    {\\n        long long int n = num;\\n        long long int ans = 1;\\n        while(k)\\n        {\\n            if(k%2 == 0)\\n            {\\n                k = k>>1;\\n                 n = (n*n)%modulo;\\n            }\\n            else\\n            {\\n                k--;\\n                ans = (ans*n)%modulo;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    string subStrHash(string s, int power, int modulo, int k, int hashvalue) {\\n        int windowend = s.size()-1;\\n        long long int ans = 0;\\n        int windowsize = 0;\\n        pair<int,int> coord = {0,0};\\n        \\n        for(int windowstart = s.size()-1; windowstart >= 0 ; windowstart--)\\n        {\\n            ans = (ans*power + s[windowstart] - \\'a\\' + 1)%modulo;\\n            windowsize++;\\n            \\n            while(windowsize >= k)\\n            {\\n                if(ans == hashvalue)\\n                {\\n                    coord = {windowstart, windowend};\\n                }\\n                long long int sub = ((1LL*s[windowend] - \\'a\\' + 1)*(calcpow(power, windowsize-1, modulo)))%modulo;\\n                ans = (ans - sub + modulo)%modulo;  \\n                windowend--;\\n                windowsize--;\\n            }\\n        }\\n        return s.substr(coord.first, coord.second - coord.first + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730258,
                "title": "solved-integer-overflow-but-got-tle-then-java",
                "content": "I solved large number bound issue by doing preprocess of input data mathematically, this can avoid hitting the upper bound:\\n(a + b) % p = (a % p + b % p) % p \\uFF081\\uFF09\\n(a - b) % p = (a % p - b % p ) % p \\uFF082\\uFF09\\n(a * b) % p = (a % p * b % p) % p \\uFF083\\uFF09\\n\\nBut then I got TLE :( Here\\'s my solution with TLE:\\n\\n```\\nclass Solution {\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n        power = power % modulo;\\n        for(int i=0; i<s.length()-k; i++){\\n            String sub = s.substring(i, i+k);\\n            if(hash(sub, power, modulo) == hashValue){\\n                return sub;\\n            }\\n        }\\n        return s;\\n    }\\n    \\n    private int hash(String s, int p, int m){\\n        int n = s.length();\\n        int sum = 0;\\n        for(int i=0; i<n; i++){\\n            int val = s.charAt(i) - \\'a\\' + 1;\\n            int pi = 1;\\n            for(int k=1; k<=i; k++){\\n                pi = (pi%m) * (p%m);\\n            }\\n            sum += ((val%m) * (pi%m)) % m;\\n        }\\n        return sum % m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n        power = power % modulo;\\n        for(int i=0; i<s.length()-k; i++){\\n            String sub = s.substring(i, i+k);\\n            if(hash(sub, power, modulo) == hashValue){\\n                return sub;\\n            }\\n        }\\n        return s;\\n    }\\n    \\n    private int hash(String s, int p, int m){\\n        int n = s.length();\\n        int sum = 0;\\n        for(int i=0; i<n; i++){\\n            int val = s.charAt(i) - \\'a\\' + 1;\\n            int pi = 1;\\n            for(int k=1; k<=i; k++){\\n                pi = (pi%m) * (p%m);\\n            }\\n            sum += ((val%m) * (pi%m)) % m;\\n        }\\n        return sum % m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871540,
                "title": "java-rapin-karp-with-super-simple-explanations",
                "content": "# Intuition\\nComputing formula from scratch for all substrings of length k would take `O(n*k)` where `n` is length of original string. Instead, we will rely on rolling hash approach. Knowing hash for first k characters, we can derive hash for the next k characters in sequence in `O(1)` time. \\n\\n\\n```\\nhash(i, mod, k) = (((hash(i - 1, m, k) - val(s[i - k - 1])) / p % mod) \\n                + val(s[i + k])) % mod\\n```\\n\\n\\n# Approach\\n\\nThe issue with forward rolling hash is that it requires modulo-based division. It is not a trivial how to compute it correctly for a given requirements. Conventional approach is to rely on inverse modulo, but it only works if given `mod` and `power_k` are co-prime. However not all tests provide co-prime input. \\n\\nTo get rid of division we can compute a backwards rolling hash. To compute backwards rolling hash for the next window in sequence of length k:\\n\\n```\\n// i starts from n-1 to 0\\nhash(i, mod, k) = (hash(i + 1 - k) - val(s[i + 1]) * p^k \\n                  + val(s[i - k])) % mod\\n```\\n\\nTo find the first occurence we will keep going backwards over all windows of size K and keep updating the result.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public String subStrHash(String ss, int p, int m, int k, int hashValue) {\\n        char[] s = ss.toCharArray();\\n        long hash = 0; // rollling hash\\n        long pk = 1; // p^k \\n        int firstOcc = ss.length() - 1;\\n        // work backwards to avoid inverse modulo\\n        for(int i = s.length - 1; i>=0; i--) {\\n            int d = s[i] - \\'a\\' + 1;\\n            hash = (hash * p + d) % m;\\n            if(i < s.length - k) {\\n                // roll-the-hash\\n                int dk = s[i + k] - \\'a\\' + 1;\\n                hash = (m + hash - ((pk * dk) % m)) % m;\\n            } else {\\n                pk = (pk * p) % m;\\n            }\\n\\n            if(hash == hashValue) {\\n                firstOcc = i;\\n            }\\n        }\\n        return ss.substring(firstOcc, firstOcc + k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nhash(i, mod, k) = (((hash(i - 1, m, k) - val(s[i - k - 1])) / p % mod) \\n                + val(s[i + k])) % mod\\n```\n```\\n// i starts from n-1 to 0\\nhash(i, mod, k) = (hash(i + 1 - k) - val(s[i + 1]) * p^k \\n                  + val(s[i - k])) % mod\\n```\n```\\nclass Solution {\\n\\n    public String subStrHash(String ss, int p, int m, int k, int hashValue) {\\n        char[] s = ss.toCharArray();\\n        long hash = 0; // rollling hash\\n        long pk = 1; // p^k \\n        int firstOcc = ss.length() - 1;\\n        // work backwards to avoid inverse modulo\\n        for(int i = s.length - 1; i>=0; i--) {\\n            int d = s[i] - \\'a\\' + 1;\\n            hash = (hash * p + d) % m;\\n            if(i < s.length - k) {\\n                // roll-the-hash\\n                int dk = s[i + k] - \\'a\\' + 1;\\n                hash = (m + hash - ((pk * dk) % m)) % m;\\n            } else {\\n                pk = (pk * p) % m;\\n            }\\n\\n            if(hash == hashValue) {\\n                firstOcc = i;\\n            }\\n        }\\n        return ss.substring(firstOcc, firstOcc + k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043039,
                "title": "c-rolling-hash",
                "content": "```\\n#define long long long\\n\\nclass Solution {\\npublic:\\n    string subStrHash(string str, int power, int mod, int k, int hashValue) {\\n        long hash = 0;\\n        long power_k = 1;\\n        \\n        for(int i = 1; i < k; i++)\\n            power_k = (power * power_k) % mod;\\n        \\n        int n = str.length();\\n        int j = n-1, inx = 0;\\n        for(int i = n-1; i >= 0; i--) {\\n            int val = str[i] - \\'a\\' + 1;\\n            hash = (power*hash + val) % mod;\\n            if(j-i+1 == k) {\\n                if(hash == hashValue) \\n                    inx = i;\\n                val = str[j] - \\'a\\' + 1;\\n                hash = (hash - (power_k*val)) % mod;\\n                hash = (hash + mod) % mod;\\n                j -= 1;\\n            }\\n        }\\n        \\n        return str.substr(inx, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Rolling Hash"
                ],
                "code": "```\\n#define long long long\\n\\nclass Solution {\\npublic:\\n    string subStrHash(string str, int power, int mod, int k, int hashValue) {\\n        long hash = 0;\\n        long power_k = 1;\\n        \\n        for(int i = 1; i < k; i++)\\n            power_k = (power * power_k) % mod;\\n        \\n        int n = str.length();\\n        int j = n-1, inx = 0;\\n        for(int i = n-1; i >= 0; i--) {\\n            int val = str[i] - \\'a\\' + 1;\\n            hash = (power*hash + val) % mod;\\n            if(j-i+1 == k) {\\n                if(hash == hashValue) \\n                    inx = i;\\n                val = str[j] - \\'a\\' + 1;\\n                hash = (hash - (power_k*val)) % mod;\\n                hash = (hash + mod) % mod;\\n                j -= 1;\\n            }\\n        }\\n        \\n        return str.substr(inx, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969196,
                "title": "solution-with-added-comments-rolling-hash",
                "content": "```\\nclass Solution {\\n    \\n        /*\\n        \\n         lets s be (s[0]  , s[1] , s[2] , s[3], . . . . s[n]) \\n         \\n         As , we are iterating from last to first , so the new value that We add\\n         will always be normal addition of val(s[i])  ; \\n         \\n         now 3 cases :\\n                1) curr_idx + (k-1) > n ==> we have not reached a length of k \\n                2) curr_idx + (k-1) == n ==> we just have reached length of k \\n                3) curr_idx + (k-1) < n ==> more than k length \\n        \\n        untill we reach case 2 we have to keep doing same thing ,\\n        that is keep taking elements , \\n        \\n        But , The new element we take is actually first element of the current considered substring\\n        So, if PREV HASH value was X , then CURR HASH value will be X + val(s[i]) * pow(power, 0) (i.e 1) ; \\n        \\n        now lets say we are at the 3rd case , \\n        it means we have already considered a case where Len(Substring) == k \\n        \\n        now for the current k + 1 th scenario , we will have to slide the cosidered K length window to           left , So, last prev Kth character will be discarded ! \\n        \\n        so CURR HASH = ((CURR HASH - val(s[i + k] + mod) % mod * pow(power, k-1) % mod) % mod ; \\n        also all the previous left sided k-1 characters power value would increase by 1 , so better \\n        to multiply to whole Hash value by P \\n        \\n        so, CURR HASH = (CURR HASH * p) % mod ; \\n        also, the new element will get added, so , CURR HASH = CURR HASH + val[s[i]] ; \\n        \\n        \\n        now check if CURR HASH == TARGET HASH of not ! :) \\n        */\\npublic:\\n    string subStrHash(string s, int p, int mod, int k, int target_hash) {\\n        \\n        long long curr_hash = 0LL ;  // current hash \\n        long long powval = 1LL ; // highest powered value of pow(P, j) where j will be upto k-1 \\n        \\n        int ans_idx = -1 ; \\n        int n = s.size() ; \\n        \\n        for(int i = n-1 ; i>=0 ; i--){\\n            \\n            // now lets check if we have already considered K elements previous\\n            if(i + k < n) {\\n               // as we have already considered K elements, just remove that Kth of the considered window\\n               curr_hash = (curr_hash - ((s[i + k] - \\'a\\' + 1)*powval)%mod + mod) % mod ; \\n            }\\n            \\n            // now its condfirmed that there are k-1 elements (as we have not added curr idx value yet)\\n            // now previous considered characters need to be multiplied by p\\n            // (why multiplied by P? get a pen and think , its easy!)\\n            curr_hash = (curr_hash * p) % mod ; \\n            \\n            // now add the curr char value \\n            curr_hash = (curr_hash + (s[i] - \\'a\\' + 1)) % mod ; // as, val(s[i]) = s[i] - \\'a\\' + 1 ;\\n            \\n            // as we have handled k + 1 case, so we have now k sized window and its hash value \\n            // so lets check if it can contribute to our solution or not ! \\n\\n            if(curr_hash == target_hash){\\n                ans_idx = i ; \\n            }\\n            \\n            // check if powval is reached to its max potential , if not then multiply by p ; \\n            // just check if (n - i) that is total considered element is < k\\n            if(n - i < k) powval = (powval * p)%mod ;\\n        }\\n        \\n        if(ans_idx != -1) return s.substr(ans_idx, k) ; \\n        return \"-1\" ; \\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n        /*\\n        \\n         lets s be (s[0]  , s[1] , s[2] , s[3], . . . . s[n]) \\n         \\n         As , we are iterating from last to first , so the new value that We add\\n         will always be normal addition of val(s[i])  ; \\n         \\n         now 3 cases :\\n                1) curr_idx + (k-1) > n ==> we have not reached a length of k \\n                2) curr_idx + (k-1) == n ==> we just have reached length of k \\n                3) curr_idx + (k-1) < n ==> more than k length \\n        \\n        untill we reach case 2 we have to keep doing same thing ,\\n        that is keep taking elements , \\n        \\n        But , The new element we take is actually first element of the current considered substring\\n        So, if PREV HASH value was X , then CURR HASH value will be X + val(s[i]) * pow(power, 0) (i.e 1) ; \\n        \\n        now lets say we are at the 3rd case , \\n        it means we have already considered a case where Len(Substring) == k \\n        \\n        now for the current k + 1 th scenario , we will have to slide the cosidered K length window to           left , So, last prev Kth character will be discarded ! \\n        \\n        so CURR HASH = ((CURR HASH - val(s[i + k] + mod) % mod * pow(power, k-1) % mod) % mod ; \\n        also all the previous left sided k-1 characters power value would increase by 1 , so better \\n        to multiply to whole Hash value by P \\n        \\n        so, CURR HASH = (CURR HASH * p) % mod ; \\n        also, the new element will get added, so , CURR HASH = CURR HASH + val[s[i]] ; \\n        \\n        \\n        now check if CURR HASH == TARGET HASH of not ! :) \\n        */\\npublic:\\n    string subStrHash(string s, int p, int mod, int k, int target_hash) {\\n        \\n        long long curr_hash = 0LL ;  // current hash \\n        long long powval = 1LL ; // highest powered value of pow(P, j) where j will be upto k-1 \\n        \\n        int ans_idx = -1 ; \\n        int n = s.size() ; \\n        \\n        for(int i = n-1 ; i>=0 ; i--){\\n            \\n            // now lets check if we have already considered K elements previous\\n            if(i + k < n) {\\n               // as we have already considered K elements, just remove that Kth of the considered window\\n               curr_hash = (curr_hash - ((s[i + k] - \\'a\\' + 1)*powval)%mod + mod) % mod ; \\n            }\\n            \\n            // now its condfirmed that there are k-1 elements (as we have not added curr idx value yet)\\n            // now previous considered characters need to be multiplied by p\\n            // (why multiplied by P? get a pen and think , its easy!)\\n            curr_hash = (curr_hash * p) % mod ; \\n            \\n            // now add the curr char value \\n            curr_hash = (curr_hash + (s[i] - \\'a\\' + 1)) % mod ; // as, val(s[i]) = s[i] - \\'a\\' + 1 ;\\n            \\n            // as we have handled k + 1 case, so we have now k sized window and its hash value \\n            // so lets check if it can contribute to our solution or not ! \\n\\n            if(curr_hash == target_hash){\\n                ans_idx = i ; \\n            }\\n            \\n            // check if powval is reached to its max potential , if not then multiply by p ; \\n            // just check if (n - i) that is total considered element is < k\\n            if(n - i < k) powval = (powval * p)%mod ;\\n        }\\n        \\n        if(ans_idx != -1) return s.substr(ans_idx, k) ; \\n        return \"-1\" ; \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772493,
                "title": "backward-hash-computing-python",
                "content": "Backward computing is done, because it is not guaranteed that `power` and `modulo` are comprime, thus inverses not necessarily exist, thus the only simple way to handle it is to compute hash backwards.\\n\\nIn fact there are test cases, when say you multiply `hashValue` by some `power` degree something which doesn\\'t work.\\n\\n```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        n, h = len(s), [0]\\n        for i, ch in enumerate(s[::-1]):\\n            val = h[-1] * power + (ord(ch) - ord(\\'a\\') + 1)\\n            h.append(val % modulo)\\n        h.reverse()\\n\\n        pw = pow(power, k, modulo)\\n        for i in range(n - k + 1):\\n            if (h[i] - h[i + k] * pw) % modulo == hashValue:\\n                return s[i:i + k]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        n, h = len(s), [0]\\n        for i, ch in enumerate(s[::-1]):\\n            val = h[-1] * power + (ord(ch) - ord(\\'a\\') + 1)\\n            h.append(val % modulo)\\n        h.reverse()\\n\\n        pw = pow(power, k, modulo)\\n        for i in range(n - k + 1):\\n            if (h[i] - h[i + k] * pw) % modulo == hashValue:\\n                return s[i:i + k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1761475,
                "title": "straightforward-rolling-hash-left-to-right",
                "content": "This is just a translation of the rolling hash:\\n* Take the first k-1 characters and compute the rolling sum of the hash\\n* For the rest of the characters, do the following:\\n\\t* multiply the rolling sum by `p^k-1` and take the modulo\\n\\t* remove the first element of the window (the one with the power 0)\\n\\t* slide to the right by dividing by `p`\\n```python\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        rolling_sum, win_start = 0, 0\\n        def sord(ch): return (ord(ch) - ord(\\'a\\') + 1)\\n        p = 1\\n\\n        for i in range(k-1):\\n            rolling_sum += sord(s[i])*p\\n            p *= power\\n\\n        for i in range(k-1, len(s)):\\n            rolling_sum += sord(s[i])*p\\n            if rolling_sum % modulo == hashValue:\\n                return s[win_start:i+1]\\n            rolling_sum -= sord(s[win_start])\\n            rolling_sum = rolling_sum // power\\n            win_start += 1\\n            \\n        return \"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        rolling_sum, win_start = 0, 0\\n        def sord(ch): return (ord(ch) - ord(\\'a\\') + 1)\\n        p = 1\\n\\n        for i in range(k-1):\\n            rolling_sum += sord(s[i])*p\\n            p *= power\\n\\n        for i in range(k-1, len(s)):\\n            rolling_sum += sord(s[i])*p\\n            if rolling_sum % modulo == hashValue:\\n                return s[win_start:i+1]\\n            rolling_sum -= sord(s[win_start])\\n            rolling_sum = rolling_sum // power\\n            win_start += 1\\n            \\n        return \"\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1760585,
                "title": "python-3-intuitive-easy-to-understand-rolling-hash",
                "content": "The idea to this problem is very simple and intuitive. What we need to do here is compute the hash of the first possible window of size k. Once we have this hash value we need to find a way so that we can exclude the first character from the window and include the next character into our window. How do we this ?\\n\\nConsider the array to be [a0, a1, a2, a3, ...., an]\\n\\nLets start off with the base case where the window starts at index 0\\n\\nHere the hash would be: (a0 * power ^ 0) + (a1 * power ^ 1) + .... (ai * power ^ i) where i < k\\n\\nI intentionally left out the modulo part since our rolling sum hash will greatly depend on the above computed value\\n\\nOnce we have computed the hash at index 0 we need to check if hash(0) modulo == target: If yes you have your answer\\n\\nIf no, then comes the tricky part, you need add a new character in your window.\\n\\nTo do this, one can see, to remove the first character we just need to subtract it from the sum. But to get rid of power values from the remaining elements, the only thing we have to do is divide the resultant by the power value.\\n\\nOnce we have this to include the new element in the hash, we need to just add the new element value times the value of power ^ k.\\n\\n```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        powSoFar = 1        \\n        total = ord(s[0]) - ord(\\'a\\') + 1\\n        for idx in range(1, k):\\n            powSoFar *= power\\n            total += ((ord(s[idx]) - ord(\\'a\\')) + 1) * (powSoFar)\\n        \\n        #print(total)\\n        if (total % modulo) == hashValue:\\n            return s[:k]\\n        \\n        for idx in range(k, len(s)):\\n            total = total - ((ord(s[idx - k]) - ord(\\'a\\')) + 1)\\n            #print(total)\\n            total = total // power\\n            #print(total)\\n            total = total + (((ord(s[idx]) - ord(\\'a\\')) + 1) * powSoFar)\\n            #print(total)\\n            \\n            if (total % modulo) == hashValue:\\n                return s[(idx - k + 1) : (idx + 1)]\\n        \\n        return \"\"\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        powSoFar = 1        \\n        total = ord(s[0]) - ord(\\'a\\') + 1\\n        for idx in range(1, k):\\n            powSoFar *= power\\n            total += ((ord(s[idx]) - ord(\\'a\\')) + 1) * (powSoFar)\\n        \\n        #print(total)\\n        if (total % modulo) == hashValue:\\n            return s[:k]\\n        \\n        for idx in range(k, len(s)):\\n            total = total - ((ord(s[idx - k]) - ord(\\'a\\')) + 1)\\n            #print(total)\\n            total = total // power\\n            #print(total)\\n            total = total + (((ord(s[idx]) - ord(\\'a\\')) + 1) * powSoFar)\\n            #print(total)\\n            \\n            if (total % modulo) == hashValue:\\n                return s[(idx - k + 1) : (idx + 1)]\\n        \\n        return \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751558,
                "title": "golang-o-n-solution",
                "content": "```go\\nfunc subStrHash(s string, power int, modulo int, k int, hashValue int) string {\\n\\tcurHash := 0\\n\\tstartIndex := 0\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tcurHash = (curHash * power + int(s[len(s)-1-i]-\\'a\\'+1)) % modulo\\n\\t}\\n\\tif curHash == hashValue {\\n\\t\\tstartIndex = len(s)-k\\n\\t}\\n\\t// magic: power^(k-1) % modulo\\n\\tmagic := 1\\n\\tfor i := 1; i <= k-1; i++ {\\n\\t\\tmagic = (magic * power) % modulo\\n\\t}\\n\\tfor i := len(s)-k-1; i >= 0; i-- {\\n\\t\\tcurHash = (curHash + modulo - (int(s[i+k]-\\'a\\'+1) * magic) % modulo) % modulo\\n\\t\\tcurHash = (curHash * power + int(s[i]-\\'a\\'+1)) % modulo\\n\\t\\tif curHash == hashValue {\\n\\t\\t\\tstartIndex = i\\n\\t\\t}\\n\\t}\\n\\treturn s[startIndex:startIndex+k]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc subStrHash(s string, power int, modulo int, k int, hashValue int) string {\\n\\tcurHash := 0\\n\\tstartIndex := 0\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tcurHash = (curHash * power + int(s[len(s)-1-i]-\\'a\\'+1)) % modulo\\n\\t}\\n\\tif curHash == hashValue {\\n\\t\\tstartIndex = len(s)-k\\n\\t}\\n\\t// magic: power^(k-1) % modulo\\n\\tmagic := 1\\n\\tfor i := 1; i <= k-1; i++ {\\n\\t\\tmagic = (magic * power) % modulo\\n\\t}\\n\\tfor i := len(s)-k-1; i >= 0; i-- {\\n\\t\\tcurHash = (curHash + modulo - (int(s[i+k]-\\'a\\'+1) * magic) % modulo) % modulo\\n\\t\\tcurHash = (curHash * power + int(s[i]-\\'a\\'+1)) % modulo\\n\\t\\tif curHash == hashValue {\\n\\t\\t\\tstartIndex = i\\n\\t\\t}\\n\\t}\\n\\treturn s[startIndex:startIndex+k]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1746786,
                "title": "a-few-solutions",
                "content": "\\uD83D\\uDC49 If we process the input array `A` from left-to-right, we can derive a naive brute-force O(N<sup>2</sup>) solution which results in TLE.\\n\\n\\uD83D\\uDC48 If we process the input array `A` from right-to-left, we can perform these same multiplications in parallel (rather than piecemeal fashion) for a linear O(N) solution via a sliding window `[i..i + k)`, ie. from `i` inclusive to `i + k` non-inclusive.\\n\\n---\\n\\n**left-to-right \\uD83D\\uDC49 O(N<sup>2</sup>) TLE**:\\n\\n*Python3*\\n```\\nclass Solution:\\n    def subStrHash(self, s: str, p: int, m: int, K: int, T: int) -> str:\\n        def f(i):\\n            t = 0\\n            j = 0\\n            while j < K:\\n                t += (ord(s[i + j]) - ord(\\'a\\') + 1) * pow(p, j) % m\\n                j += 1\\n            return t % m\\n        i = 0\\n        t = f(0)\\n        while t != T:\\n            i += 1\\n            t = f(i)\\n        return s[i:i + K]\\n```\\n\\n**right-to-left \\uD83D\\uDC48 O(N) AC**:\\n\\n*Python3*\\n```\\nclass Solution:\\n    def subStrHash(self, s: str, p: int, m: int, k: int, T: int, t = 0, first = 0) -> str:\\n        N = len(s)\\n        f = lambda c: ord(c) - ord(\\'a\\') + 1\\n        drop = p ** (k - 1)\\n        for i in range(N - 1, -1, -1):\\n            if i + k < N:\\n                x = f(s[i + k])\\n                t -= x * drop\\n            x = f(s[i])\\n            t = (t * p) % m\\n            t = (t + x) % m\\n            if t == T:\\n                first = i\\n        return s[first:first + k]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s: str, p: int, m: int, K: int, T: int) -> str:\\n        def f(i):\\n            t = 0\\n            j = 0\\n            while j < K:\\n                t += (ord(s[i + j]) - ord(\\'a\\') + 1) * pow(p, j) % m\\n                j += 1\\n            return t % m\\n        i = 0\\n        t = f(0)\\n        while t != T:\\n            i += 1\\n            t = f(i)\\n        return s[i:i + K]\\n```\n```\\nclass Solution:\\n    def subStrHash(self, s: str, p: int, m: int, k: int, T: int, t = 0, first = 0) -> str:\\n        N = len(s)\\n        f = lambda c: ord(c) - ord(\\'a\\') + 1\\n        drop = p ** (k - 1)\\n        for i in range(N - 1, -1, -1):\\n            if i + k < N:\\n                x = f(s[i + k])\\n                t -= x * drop\\n            x = f(s[i])\\n            t = (t * p) % m\\n            t = (t + x) % m\\n            if t == T:\\n                first = i\\n        return s[first:first + k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735511,
                "title": "python-simple-python-solution-using-sliding-window-and-rolling-hash",
                "content": "# If It is Useful To Understand Please UpVote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\t\\n\\tclass Solution:\\n\\t\\tdef subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n\\n\\t\\t\\tsc=0\\n\\t\\t\\ti=len(s)-1\\n\\t\\t\\ta=0\\n\\t\\t\\tm = (power**k)%modulo\\n\\n\\t\\t\\twhile i>-1:\\n\\n\\t\\t\\t\\tsc=(sc*power + ord(s[i])-97+1)%modulo\\n\\n\\t\\t\\t\\tif i+k<len(s):\\n\\t\\t\\t\\t\\tsc=(sc-((ord(s[i+k])-97+1)*m))%modulo\\n\\n\\t\\t\\t\\tif sc==hashValue:\\n\\t\\t\\t\\t\\ta=i\\n\\t\\t\\t\\ti=i-1\\n\\n\\t\\t\\treturn s[a:a+k]\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window",
                    "Rolling Hash"
                ],
                "code": "# If It is Useful To Understand Please UpVote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\t\\n\\tclass Solution:\\n\\t\\tdef subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n\\n\\t\\t\\tsc=0\\n\\t\\t\\ti=len(s)-1\\n\\t\\t\\ta=0\\n\\t\\t\\tm = (power**k)%modulo\\n\\n\\t\\t\\twhile i>-1:\\n\\n\\t\\t\\t\\tsc=(sc*power + ord(s[i])-97+1)%modulo\\n\\n\\t\\t\\t\\tif i+k<len(s):\\n\\t\\t\\t\\t\\tsc=(sc-((ord(s[i+k])-97+1)*m))%modulo\\n\\n\\t\\t\\t\\tif sc==hashValue:\\n\\t\\t\\t\\t\\ta=i\\n\\t\\t\\t\\ti=i-1\\n\\n\\t\\t\\treturn s[a:a+k]\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1734858,
                "title": "c-127ms-o-n-with-explanation",
                "content": "## 1. Naive approach (BF)\\nFor each index `i` in range `[0, n-1-k]` we calculate next `k` values of `hash` function and return the substring if we hit the hash value which equals to input parameter. Complexity `O(n*k)`, runtime ~2700ms but it\\'s accepted solution\\n```\\npublic string SubStrHash(string s, int power, int m, int k, int hashValue)\\n{\\n\\tvar arr = new int[s.Length];\\n\\tvar powers = new long[k];\\n\\tpowers[0] = 1;\\n\\tfor (int i = 1; i < k; i++)\\n\\t\\tpowers[i] = (powers[i - 1] * power) % m;\\n\\n\\tfor (int i = 0; i < s.Length; i++)\\n\\t\\tarr[i] = s[i] - \\'a\\' + 1;\\n\\n\\tfor (int i = 0; i < s.Length && i + k - 1 < s.Length; i++)\\n\\t{\\n\\t\\tlong val = arr[i] % m;\\n\\t\\tfor (int j = 1; j < k; j++)\\n\\t\\t\\tval = (val + arr[i + j] * powers[j]) % m;\\n\\n\\t\\tif (val == hashValue)\\n\\t\\t\\treturn s.Substring(i, k);\\n\\t}\\n\\n\\treturn s.Substring(0, k);\\n}\\n```\\n\\n## 2. Optimized solution\\nIn the above solution we were calculating the values for the same indexes `k` times. What if we could use the values calculated in the previous step? Let\\'s make a simple observation: if we calculate the `hash` values from backward, we first calculate the following hash value for THE LAST `k` characters of `s` - for simplicity, let\\'s set `k=4` so for index = `n-4` we have:\\n<code>\\nhash<sub>n-4</sub> = (val(s<sub>n-4</sub>)*p<sup>0</sup> + val(s<sub>n-3</sub>)*p<sup>1</sup> + val(s<sub>n-2</sub>)*p<sup>2</sup>+ val(s<sub>n-1</sub>)*p<sup>3</sup>) mod m\\n</code>\\nIn the next step we calculate the same for index = `n-5`, i.e.:\\n<code>\\nhash<sub>n-5</sub> = (val(s<sub>n-5</sub>)*p<sup>0</sup> + val(s<sub>n-4</sub>)*p<sup>1</sup> + val(s<sub>n-3</sub>)*p<sup>2</sup> + val(s<sub>n-2</sub>)*p<sup>3</sup>) mod m\\n</code>\\n\\nSo - to obtain <code>hash<sub>n-5</sub></code> equation from <code>hash<sub>n-4</sub></code> we need to:\\n1. **substract** <code>val(s<sub>n-1</sub>) * p<sup>3</sup></code> \\n2. **multiply** by `p` (to increase all powers of `p` in the first equation by `1`) and \\n3. **add** <code>val(s<sub>n-5</sub>) * p<sup>0</sup></code>\\n\\nWith this simple trick we get a complexity of `O(n)` and 20x better runtime\\n\\n![image](https://assets.leetcode.com/users/images/05b2fe44-6af6-4b68-a00e-8af9ed36f8e8_1643652000.473073.png)\\n```\\npublic string SubStrHash(string s, int power, int m, int k, int hashValue)\\n{\\n\\tvar len = s.Length;\\n\\tvar val = new int[len];\\n\\tvar startIdx = 0;\\n\\n\\tfor (int i = 0; i < len; i++)\\n\\t\\tval[i] = (s[i] - \\'a\\' + 1);\\n\\n\\tlong hash = 0;\\n\\tlong p = 1;\\n\\tfor(int i=len-k; i<len; i++)\\n\\t{\\n\\t\\thash = (hash + val[i] * p);\\n\\t\\tif(i < len-1)   //we will need the value power^(k-1) later in the code\\n\\t\\t\\tp = (p * power) % m;\\n\\t}\\n\\n\\tif(hash % m == hashValue)\\n\\t\\tstartIdx = len-k;\\n\\n\\tfor(int i=len-k-1; i>=0; i--)\\n\\t{\\n\\t\\thash = ((hash % m) - (val[i+k]*p % m) + m) * power + val[i];\\n\\t\\tif(hash % m == hashValue)\\n\\t\\t\\tstartIdx = i;   //we need to continue since we\\'re asked to return THE FIRST substring\\n\\t}\\n\\n\\treturn s.Substring(startIdx, k);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic string SubStrHash(string s, int power, int m, int k, int hashValue)\\n{\\n\\tvar arr = new int[s.Length];\\n\\tvar powers = new long[k];\\n\\tpowers[0] = 1;\\n\\tfor (int i = 1; i < k; i++)\\n\\t\\tpowers[i] = (powers[i - 1] * power) % m;\\n\\n\\tfor (int i = 0; i < s.Length; i++)\\n\\t\\tarr[i] = s[i] - \\'a\\' + 1;\\n\\n\\tfor (int i = 0; i < s.Length && i + k - 1 < s.Length; i++)\\n\\t{\\n\\t\\tlong val = arr[i] % m;\\n\\t\\tfor (int j = 1; j < k; j++)\\n\\t\\t\\tval = (val + arr[i + j] * powers[j]) % m;\\n\\n\\t\\tif (val == hashValue)\\n\\t\\t\\treturn s.Substring(i, k);\\n\\t}\\n\\n\\treturn s.Substring(0, k);\\n}\\n```\n```\\npublic string SubStrHash(string s, int power, int m, int k, int hashValue)\\n{\\n\\tvar len = s.Length;\\n\\tvar val = new int[len];\\n\\tvar startIdx = 0;\\n\\n\\tfor (int i = 0; i < len; i++)\\n\\t\\tval[i] = (s[i] - \\'a\\' + 1);\\n\\n\\tlong hash = 0;\\n\\tlong p = 1;\\n\\tfor(int i=len-k; i<len; i++)\\n\\t{\\n\\t\\thash = (hash + val[i] * p);\\n\\t\\tif(i < len-1)   //we will need the value power^(k-1) later in the code\\n\\t\\t\\tp = (p * power) % m;\\n\\t}\\n\\n\\tif(hash % m == hashValue)\\n\\t\\tstartIdx = len-k;\\n\\n\\tfor(int i=len-k-1; i>=0; i--)\\n\\t{\\n\\t\\thash = ((hash % m) - (val[i+k]*p % m) + m) * power + val[i];\\n\\t\\tif(hash % m == hashValue)\\n\\t\\t\\tstartIdx = i;   //we need to continue since we\\'re asked to return THE FIRST substring\\n\\t}\\n\\n\\treturn s.Substring(startIdx, k);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1733551,
                "title": "java-easy-solution-roll-hash-sliding-window",
                "content": "```\\nimport java.util.*;\\nimport java.math.*;\\nclass Solution {\\n     \\n\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n       long mul1=1;\\n       int times=k-1;\\n        while(times-->0) mul1=mul1*power%modulo;\\n        int index=-1;\\n        long hash=0;\\n        int end=s.length()-1;\\n        for(int i=s.length()-1;i>=0;i--){\\n            int val=s.charAt(i)-96;\\n            hash=(hash*power%modulo +val)%modulo;\\n            if(end-i+1==k){\\n                if(hash==hashValue){\\n                    index=i;\\n                }\\n                hash=(hash-(s.charAt(end)-96)*mul1%modulo + modulo )%modulo;\\n                end--;\\n            }\\n        }\\n        return s.substring(index,index+k);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\nimport java.math.*;\\nclass Solution {\\n     \\n\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n       long mul1=1;\\n       int times=k-1;\\n        while(times-->0) mul1=mul1*power%modulo;\\n        int index=-1;\\n        long hash=0;\\n        int end=s.length()-1;\\n        for(int i=s.length()-1;i>=0;i--){\\n            int val=s.charAt(i)-96;\\n            hash=(hash*power%modulo +val)%modulo;\\n            if(end-i+1==k){\\n                if(hash==hashValue){\\n                    index=i;\\n                }\\n                hash=(hash-(s.charAt(end)-96)*mul1%modulo + modulo )%modulo;\\n                end--;\\n            }\\n        }\\n        return s.substring(index,index+k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732647,
                "title": "why-javascript-needs-bigint-for-this-question",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {number} power p\\n * @param {number} modulo m\\n * @param {number} k\\n * @param {number} hashValue\\n * @return {string}\\n */\\nvar subStrHash = function(s, p, m, k, hashValue) {\\n    p = BigInt(p);\\n    m = BigInt(m);\\n    hashValue = BigInt(hashValue);\\n    let tmp = 0n, res = 0, pk = 1n, n = s.length;\\n    for (let i = n-1; i >= 0; i--) {\\n        tmp = (tmp * p + BigInt(s[i].charCodeAt() - 96)) % m;\\n        if (i + k >= n) pk = pk * p % m;\\n        else tmp = (tmp - (BigInt(s[i+k].charCodeAt() - 96) * pk % m) + m) % m;\\n        if (tmp === hashValue) res = i;\\n    }\\n    return s.slice(res, res + k);\\n};\\n```\\nthis solution only passes when all elements computed with BigInt type. But why is this needed? I don\\'t quite understand in which step usual number will overflow.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} power p\\n * @param {number} modulo m\\n * @param {number} k\\n * @param {number} hashValue\\n * @return {string}\\n */\\nvar subStrHash = function(s, p, m, k, hashValue) {\\n    p = BigInt(p);\\n    m = BigInt(m);\\n    hashValue = BigInt(hashValue);\\n    let tmp = 0n, res = 0, pk = 1n, n = s.length;\\n    for (let i = n-1; i >= 0; i--) {\\n        tmp = (tmp * p + BigInt(s[i].charCodeAt() - 96)) % m;\\n        if (i + k >= n) pk = pk * p % m;\\n        else tmp = (tmp - (BigInt(s[i+k].charCodeAt() - 96) * pk % m) + m) % m;\\n        if (tmp === hashValue) res = i;\\n    }\\n    return s.slice(res, res + k);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1731390,
                "title": "self-understandable-python-rabin-karp-algorithm",
                "content": "**This problem can be implemented on the concept of Rabin Karp Algorithm ,the only difference is that we make patterns from begining.**\\nExample : \\nlet pattern : \"abcdefgh\"  k=3 power=x\\nhash value : a*(x^0)+b*(x^1)+c*(x^2)\\n```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        p=0\\n        mul=1\\n        for i in range(k):\\n            p=p+(ord(s[i])-ord(\\'a\\')+1)*mul\\n            mul=mul*power\\n        mul=mul//power\\n        for j in range(len(s)-k+1):\\n            if p%modulo==hashValue:\\n                return s[j:j+k]\\n            if j<len(s)-k:\\n                p=(p-(ord(s[j])-ord(\\'a\\')+1))//power+(ord(s[j+k])-ord(\\'a\\')+1)*mul\\n```\\n**Note :** Same approach can be used to solve question like:\\n1316. Distinct Echo Substrings",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        p=0\\n        mul=1\\n        for i in range(k):\\n            p=p+(ord(s[i])-ord(\\'a\\')+1)*mul\\n            mul=mul*power\\n        mul=mul//power\\n        for j in range(len(s)-k+1):\\n            if p%modulo==hashValue:\\n                return s[j:j+k]\\n            if j<len(s)-k:\\n                p=(p-(ord(s[j])-ord(\\'a\\')+1))//power+(ord(s[j+k])-ord(\\'a\\')+1)*mul\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731335,
                "title": "scala-functional-solution-folding-left-right",
                "content": "```\\n  def subStrHash(s: String, power: Int, mod: Int, k: Int, targetHash: Int): String = {\\n    val value = (i: Int) => s(i) - \\'`\\'\\n    val len   = s.length\\n    val powK  = (1 to k).foldLeft(1L)((powK, _) => powK * power % mod)\\n\\n    val initHash  = (len - k until len).foldRight(0L)((i, hash) => (hash * power + value(i)) % mod)\\n    val initStart = if (initHash == targetHash) len - k else len\\n\\n    val (_, start) = (0 until len - k).foldRight(initHash, initStart) { case (i, (prevHash, start)) =>\\n      val expandedHash = (prevHash * power + value(i))      % mod\\n      val shrunkHash   = expandedHash - value(i + k) * powK % mod\\n      val newHash      = math.floorMod(shrunkHash, mod)\\n\\n      val newStart = if (newHash == targetHash) i else start\\n      (newHash, newStart)\\n    }\\n\\n    s.substring(start, start + k)\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  def subStrHash(s: String, power: Int, mod: Int, k: Int, targetHash: Int): String = {\\n    val value = (i: Int) => s(i) - \\'`\\'\\n    val len   = s.length\\n    val powK  = (1 to k).foldLeft(1L)((powK, _) => powK * power % mod)\\n\\n    val initHash  = (len - k until len).foldRight(0L)((i, hash) => (hash * power + value(i)) % mod)\\n    val initStart = if (initHash == targetHash) len - k else len\\n\\n    val (_, start) = (0 until len - k).foldRight(initHash, initStart) { case (i, (prevHash, start)) =>\\n      val expandedHash = (prevHash * power + value(i))      % mod\\n      val shrunkHash   = expandedHash - value(i + k) * powK % mod\\n      val newHash      = math.floorMod(shrunkHash, mod)\\n\\n      val newStart = if (newHash == targetHash) i else start\\n      (newHash, newStart)\\n    }\\n\\n    s.substring(start, start + k)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1730767,
                "title": "python-rolling-hash-with-diagram",
                "content": "**Rough Sketch I used to understand rollingn hash.**\\n\\n![image](https://assets.leetcode.com/users/images/7635ce15-5b9a-4fb8-ab48-a8366375c73c_1643525083.1148336.png)\\n![image](https://assets.leetcode.com/users/images/af5f3272-f5d8-4af9-b6de-cfd74763ebc3_1643525083.1977124.png)\\n\\n```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        N, hash_value, msb_power = len(s), 0, pow(power,k,modulo)\\n        # msb_power will be the constant attached with the most significant bit of the substring of length k\\n        result = len(s)\\n        \\n        # Function to get respective values of the alphabet\\n        def var(char):\\n            return ord(char)-ord(\\'a\\')+1\\n        \\n        for i in range(N-1,-1,-1):\\n            # Add the new value to the hash value after shifting it one bit to the left\\n            hash_value = (hash_value*power + var(s[i]))%modulo\\n            \\n            if i+k < N:\\n                # If the size of substring == k we pop the msb and left shift\\n                hash_value = (hash_value - var(s[i+k])*msb_power)%modulo\\n            \\n            if hash_value == hashValue:\\n                result = i\\n        \\n        return s[result:result+k]\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        N, hash_value, msb_power = len(s), 0, pow(power,k,modulo)\\n        # msb_power will be the constant attached with the most significant bit of the substring of length k\\n        result = len(s)\\n        \\n        # Function to get respective values of the alphabet\\n        def var(char):\\n            return ord(char)-ord(\\'a\\')+1\\n        \\n        for i in range(N-1,-1,-1):\\n            # Add the new value to the hash value after shifting it one bit to the left\\n            hash_value = (hash_value*power + var(s[i]))%modulo\\n            \\n            if i+k < N:\\n                # If the size of substring == k we pop the msb and left shift\\n                hash_value = (hash_value - var(s[i+k])*msb_power)%modulo\\n            \\n            if hash_value == hashValue:\\n                result = i\\n        \\n        return s[result:result+k]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730523,
                "title": "javascript-rabin-karp-387ms",
                "content": "```\\nconst ll = BigInt;\\n\\nconst subStrHash = (s, p, mod, k, hashValue) => {\\n    p = ll(p), mod = ll(mod);\\n    let n = s.length, idx = n, sum = 0n, powerTok = 1n;\\n    for (let i = 0; i < k - 1; i++) powerTok = powerTok * p % mod;\\n    for (let i = n - 1; i >= 0; i--) {\\n        let startVal = s[i].charCodeAt() - 96;\\n        sum = (sum * p + ll(startVal)) % mod;\\n        if (i + k <= n) {\\n            if (sum == hashValue) idx = i;\\n            let endVal = s[i + k - 1].charCodeAt() - 96;\\n            sum = (sum - powerTok * ll(endVal)) % mod;\\n            if (sum < 0) sum += mod;\\n        }\\n    }\\n    return s.slice(idx, idx + k);\\n};\\n```\\nhttps://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst ll = BigInt;\\n\\nconst subStrHash = (s, p, mod, k, hashValue) => {\\n    p = ll(p), mod = ll(mod);\\n    let n = s.length, idx = n, sum = 0n, powerTok = 1n;\\n    for (let i = 0; i < k - 1; i++) powerTok = powerTok * p % mod;\\n    for (let i = n - 1; i >= 0; i--) {\\n        let startVal = s[i].charCodeAt() - 96;\\n        sum = (sum * p + ll(startVal)) % mod;\\n        if (i + k <= n) {\\n            if (sum == hashValue) idx = i;\\n            let endVal = s[i + k - 1].charCodeAt() - 96;\\n            sum = (sum - powerTok * ll(endVal)) % mod;\\n            if (sum < 0) sum += mod;\\n        }\\n    }\\n    return s.slice(idx, idx + k);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730481,
                "title": "python-tle-solved-by-using-pow-x-y-z-with-modulo",
                "content": "make sure use pow(x, y, z) with modulo for python code.  I keep get tle when use pow(x,y) % z or x**Y % z\\n```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        n = len(s)\\n        if n == k: return s\\n        l = 0\\n        val = 0\\n        mapp = pow(power,k-1, modulo) \\n        s = s[::-1]\\n        for i in range(k):\\n            val+= ( (ord(s[i]) - ord(\\'a\\') + 1) * pow(power,k-1 - i, modulo)  )  % modulo\\n        val = val % modulo\\n        res = []\\n        for i in range(k, n):\\n            if i - l >= k:\\n                if val % modulo == hashValue:\\n                    res.append( (l,i))\\n                val = ( val  - ((ord(s[l])-ord(\\'a\\') + 1) * mapp) % modulo  + modulo)  % modulo\\n                val = (val*power) % modulo\\n                l+=1\\n            val+= (ord(s[i]) - ord(\\'a\\') + 1) \\n            val = val % modulo\\n        if val == hashValue:\\n            res.append( (l,n) )\\n        return s[ res[-1][0]: res[-1][1] ][::-1]\\n\\t```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        n = len(s)\\n        if n == k: return s\\n        l = 0\\n        val = 0\\n        mapp = pow(power,k-1, modulo) \\n        s = s[::-1]\\n        for i in range(k):\\n            val+= ( (ord(s[i]) - ord(\\'a\\') + 1) * pow(power,k-1 - i, modulo)  )  % modulo\\n        val = val % modulo\\n        res = []\\n        for i in range(k, n):\\n            if i - l >= k:\\n                if val % modulo == hashValue:\\n                    res.append( (l,i))\\n                val = ( val  - ((ord(s[l])-ord(\\'a\\') + 1) * mapp) % modulo  + modulo)  % modulo\\n                val = (val*power) % modulo\\n                l+=1\\n            val+= (ord(s[i]) - ord(\\'a\\') + 1) \\n            val = val % modulo\\n        if val == hashValue:\\n            res.append( (l,n) )\\n        return s[ res[-1][0]: res[-1][1] ][::-1]\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1730459,
                "title": "java-solution-time-complexity-o-n-rolling-hash-function-simple-solution",
                "content": "The idea is to traverse the string from end and keep calculating hashValue and once required size of k is achieved then check whether its equal to the given hashValue or not, **CASE 1**  if equal you need to still search because you are traversing the string backwards and you need the first index of required string.\\n**CASE 2** if not found roll your hashValue backwards by removing last character of current string **[i+k-1]** and adding last character from remaining left string **[i-1]**\\n\\'\\'\\'\\nclass Solution {\\n    public String subStrHash(String s, int p, int m, int k, int hashValue) {\\n        int n = s.length();\\n        long h = 1;\\n        for(int i=1;i<k;i++){\\n            h = h*p;\\n            h = h%m;\\n        }\\n        long t = 0;\\n        for(int i=n-1;i>n-k-1;i--){\\n            t = ((t*p)%m + (s.charAt(i)-\\'a\\'+1))%m;\\n        }\\n        int bi=n-1;\\n        for(int i=n-k;i>=0;i--){\\n            if(t == hashValue){\\n                bi=i;\\n            }\\n            if(i>0){\\n                t = (t-((s.charAt(i+k-1)-\\'a\\'+1)*h)%m)%m;\\n                if(t<0){\\n                    t = t+m;\\n                }\\n                t = ((t*p)%m + (s.charAt(i-1)-\\'a\\'+1))%m;\\n            }\\n        }\\n        return s.substring(bi,bi+k);\\n    }\\n}\\n\\'\\'\\'\\n",
                "solutionTags": [
                    "Java",
                    "Rolling Hash"
                ],
                "code": "class Solution {\\n    public String subStrHash(String s, int p, int m, int k, int hashValue) {\\n        int n = s.length();\\n        long h = 1;\\n        for(int i=1;i<k;i++){\\n            h = h*p;\\n            h = h%m;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1730289,
                "title": "whats-wrong-in-my-code",
                "content": "class Solution {\\npublic:\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        \\n        if(s.length()==k)return s;\\n        \\n        string sub;\\n        int hash=0;\\n        // if(hash==hashValue)return s.substr(0,k-1);\\n        for(int i=0 ;i<k ;i++){\\n          hash+= ((s[i]-96)* (int) pow(power,i))%modulo;\\n        }\\n        \\n      \\n        int index=0;\\n        for(int i=k ;i<s.length() ;i++){\\n             index=k;\\n            if(hash==hashValue)break;\\n            hash+= (((s[i]-s[i-k])%modulo)*(int)pow(power,k)%modulo);\\n            \\n        }\\n        \\n        \\n         return s.substr(index-k+1, index);\\n       \\n        \\n    }\\n};",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        \\n        if(s.length()==k)return s;\\n        \\n        string sub;\\n        int hash=0;\\n        // if(hash==hashValue)return s.substr(0,k-1);\\n        for(int i=0 ;i<k ;i++){\\n          hash+= ((s[i]-96)* (int) pow(power,i))%modulo;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1730286,
                "title": "java-o-n-time",
                "content": "```\\nclass Solution {\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n        long[] pk = new long[k];\\n        pk[0] = 1;\\n        for(int i = 1; i < k; i++){\\n            pk[i] = (power * pk[i - 1]) % modulo;\\n        }\\n        long val = 0;\\n        for(int i = s.length() - k; i < s.length(); i++){\\n            val += ((s.charAt(i) - \\'a\\' + 1) * pk[i - (s.length() - k)]) % modulo;\\n            val %= modulo;\\n        }\\n        String res = \"\";\\n        if((int)val == hashValue) res = s.substring(s.length() - k);\\n        for(int i = s.length() - k - 1; i >= 0; i--){\\n            val += modulo - (((s.charAt(i + k) - \\'a\\' + 1) * pk[k - 1]) % modulo);\\n            val = (val * power) % modulo;\\n            val += s.charAt(i) - \\'a\\' + 1;\\n            val %= modulo;\\n            if((int)val == hashValue) res = s.substring(i, i + k);\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n        long[] pk = new long[k];\\n        pk[0] = 1;\\n        for(int i = 1; i < k; i++){\\n            pk[i] = (power * pk[i - 1]) % modulo;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1730277,
                "title": "my-accepted-python-solution",
                "content": "```\\nclass Solution:\\n    def hashCal(self, s, p, m, k):\\n        \\n        pk1 = 1\\n        sum_k = 0\\n        \\n        for i in range(k):\\n            sum_k += (ord(s[i])-96)*pk1\\n            pk1 *= p\\n        \\n        return sum_k, pk1 // p\\n        \\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        \\n        cur, pk1 = self.hashCal(s[0:k], power, modulo, k)\\n        if cur % modulo == hashValue:\\n            return s[0:k]\\n        \\n        for i in range(1, len(s)-k+1):\\n            cur -= (ord(s[i-1])-96)\\n            cur //= power\\n            cur += (ord(s[i+k-1])-96)*pk1\\n            if cur % modulo == hashValue:\\n                return s[i:i+k]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hashCal(self, s, p, m, k):\\n        \\n        pk1 = 1\\n        sum_k = 0\\n        \\n        for i in range(k):\\n            sum_k += (ord(s[i])-96)*pk1\\n            pk1 *= p\\n        \\n        return sum_k, pk1 // p\\n        \\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        \\n        cur, pk1 = self.hashCal(s[0:k], power, modulo, k)\\n        if cur % modulo == hashValue:\\n            return s[0:k]\\n        \\n        for i in range(1, len(s)-k+1):\\n            cur -= (ord(s[i-1])-96)\\n            cur //= power\\n            cur += (ord(s[i+k-1])-96)*pk1\\n            if cur % modulo == hashValue:\\n                return s[i:i+k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730225,
                "title": "getting-wa-help-rolling-hash-front-to-back",
                "content": "```\\nclass Solution {\\npublic:\\n    long dp[1000001];\\n    long inv[1000001];\\n    long MOD;\\n\\n    long power(int a , int n)\\n    {\\n        long result = 1L;\\n\\n        while(n)\\n        {\\n            if(n & 1) result = (result * a) % MOD;\\n            n >>= 1;\\n            a = (a * a) % MOD;\\n        }\\n        return result;\\n    }\\n    \\n    long gcdExtended(long a, long b, long* x, long* y) {\\n        // Base Case\\n        if (a == 0) {\\n            *x = 0, *y = 1;\\n            return b;\\n        }\\n\\n        long x1, y1;\\n        long gcd = gcdExtended(b % a, a, &x1, &y1);\\n\\n        *x = y1 - (b / a) * x1;\\n        *y = x1;\\n\\n        return gcd;\\n    }\\n    long inverse(long a, long m) {\\n        long x, y;\\n        long g = gcdExtended(a, m, &x, &y);\\n        long res = (x % m + m) % m;\\n        return res;\\n    }\\n\\n\\n    void init(string& input_string, int& P)\\n    {\\n        long p = P;\\n        long p_power = 1L;\\n        inv[0] = inverse(p_power, MOD);\\n        dp[0] = (input_string[0] - \\'a\\' + 1);\\n\\n\\n        for(int i = 1; i < input_string.size(); i++)\\n        {\\n            char ch = input_string[i];\\n            p_power = (1L * p_power * p) % MOD;\\n            inv[i] = inverse(p_power, MOD);\\n            dp[i] = (dp[i-1] + 1L * (ch - \\'a\\' + 1) * p_power) % MOD;\\n        }\\n    }\\n    \\n    int substringHash(int L , int R)\\n    {\\n        int result = dp[R];\\n\\n        if(L > 0) result = (result - dp[L - 1] + MOD) % MOD;\\n\\n        result = (result * inv[L]) % MOD;\\n\\n        return result;\\n    }\\n    \\n    string subStrHash(string s, int power, int modulo, int k, int x) {\\n        MOD = modulo;\\n        init(s, power);\\n        int n = s.size();\\n        for(int i = k - 1; i < n; i++){\\n            if(substringHash(i - k + 1, i) == x) return s.substr(i - k + 1, k);\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long dp[1000001];\\n    long inv[1000001];\\n    long MOD;\\n\\n    long power(int a , int n)\\n    {\\n        long result = 1L;\\n\\n        while(n)\\n        {\\n            if(n & 1) result = (result * a) % MOD;\\n            n >>= 1;\\n            a = (a * a) % MOD;\\n        }\\n        return result;\\n    }\\n    \\n    long gcdExtended(long a, long b, long* x, long* y) {\\n        // Base Case\\n        if (a == 0) {\\n            *x = 0, *y = 1;\\n            return b;\\n        }\\n\\n        long x1, y1;\\n        long gcd = gcdExtended(b % a, a, &x1, &y1);\\n\\n        *x = y1 - (b / a) * x1;\\n        *y = x1;\\n\\n        return gcd;\\n    }\\n    long inverse(long a, long m) {\\n        long x, y;\\n        long g = gcdExtended(a, m, &x, &y);\\n        long res = (x % m + m) % m;\\n        return res;\\n    }\\n\\n\\n    void init(string& input_string, int& P)\\n    {\\n        long p = P;\\n        long p_power = 1L;\\n        inv[0] = inverse(p_power, MOD);\\n        dp[0] = (input_string[0] - \\'a\\' + 1);\\n\\n\\n        for(int i = 1; i < input_string.size(); i++)\\n        {\\n            char ch = input_string[i];\\n            p_power = (1L * p_power * p) % MOD;\\n            inv[i] = inverse(p_power, MOD);\\n            dp[i] = (dp[i-1] + 1L * (ch - \\'a\\' + 1) * p_power) % MOD;\\n        }\\n    }\\n    \\n    int substringHash(int L , int R)\\n    {\\n        int result = dp[R];\\n\\n        if(L > 0) result = (result - dp[L - 1] + MOD) % MOD;\\n\\n        result = (result * inv[L]) % MOD;\\n\\n        return result;\\n    }\\n    \\n    string subStrHash(string s, int power, int modulo, int k, int x) {\\n        MOD = modulo;\\n        init(s, power);\\n        int n = s.size();\\n        for(int i = k - 1; i < n; i++){\\n            if(substringHash(i - k + 1, i) == x) return s.substr(i - k + 1, k);\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730206,
                "title": "didnt-work",
                "content": "```\\nlet arrChar =\"1abcdefghijklmnopqrstuvwxyz\".split(\"\");\\nvar subStrHash = function(s, power, modulo, k, hashValue) {\\n  \\n    for(let i=0;i<s.length;i++){\\n        let subStr = s.substring(i,i+k);\\n        if(hash(subStr,power,modulo)==hashValue){\\n            return subStr;\\n        }\\n    }\\n};\\nlet hash = function(str,power,m){\\n    let result=0;\\n    for(let i=0;i<str.length;i++){\\n        result += arrChar.indexOf(str[i])*Math.pow(power,i);\\n    }\\n    return result%m;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet arrChar =\"1abcdefghijklmnopqrstuvwxyz\".split(\"\");\\nvar subStrHash = function(s, power, modulo, k, hashValue) {\\n  \\n    for(let i=0;i<s.length;i++){\\n        let subStr = s.substring(i,i+k);\\n        if(hash(subStr,power,modulo)==hashValue){\\n            return subStr;\\n        }\\n    }\\n};\\nlet hash = function(str,power,m){\\n    let result=0;\\n    for(let i=0;i<str.length;i++){\\n        result += arrChar.indexOf(str[i])*Math.pow(power,i);\\n    }\\n    return result%m;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730186,
                "title": "python-o-n-but-didnt-get-submit-dont-know-why",
                "content": "```\\nclass Solution(object):\\n    def subStrHash(self, s, p, mod, k, hval):\\n        \"\"\"\\n        :type s: str\\n        :type power: int\\n        :type modulo: int\\n        :type k: int\\n        :type hashValue: int\\n        :rtype: str\\n        \"\"\"\\n        dic = {}\\n        for i in range(1, 27):\\n            dic[chr(i + 96)] = i\\n            \\n        temphval = 0\\n        for idx in range(k):\\n            temphval += (dic[s[idx]] * p**idx)\\n\\n        orghval = int(temphval)\\n        temphval %= mod\\n\\n        if(temphval == hval):\\n            return (s[:k])\\n\\n        start = 0\\n        pkval = p ** (k-1)\\n        n = len(s)\\n        for end in range(k, n):\\n            orghval -= (dic[s[start]] * 1)\\n            orghval //= p\\n            orghval += (dic[s[end]] * pkval)\\n            temphval = int(orghval)\\n            temphval %= mod\\n            start += 1\\n            if(temphval == hval):\\n                return (s[start:end + 1])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def subStrHash(self, s, p, mod, k, hval):\\n        \"\"\"\\n        :type s: str\\n        :type power: int\\n        :type modulo: int\\n        :type k: int\\n        :type hashValue: int\\n        :rtype: str\\n        \"\"\"\\n        dic = {}\\n        for i in range(1, 27):\\n            dic[chr(i + 96)] = i\\n            \\n        temphval = 0\\n        for idx in range(k):\\n            temphval += (dic[s[idx]] * p**idx)\\n\\n        orghval = int(temphval)\\n        temphval %= mod\\n\\n        if(temphval == hval):\\n            return (s[:k])\\n\\n        start = 0\\n        pkval = p ** (k-1)\\n        n = len(s)\\n        for end in range(k, n):\\n            orghval -= (dic[s[start]] * 1)\\n            orghval //= p\\n            orghval += (dic[s[end]] * pkval)\\n            temphval = int(orghval)\\n            temphval %= mod\\n            start += 1\\n            if(temphval == hval):\\n                return (s[start:end + 1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730167,
                "title": "java-o-n-solution-rolling-hash-from-tail-to-head",
                "content": "```\\nclass Solution {\\n    \\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n        int n = s.length();\\n        long lastPower = 1;\\n        for (int i = 1; i < k; i++) {\\n            lastPower = (lastPower * power) % modulo;\\n        }\\n        \\n        long currHash = 0;\\n        for (int i = 0; i < k; i++) {\\n            int value = s.charAt(n - 1 - i) - \\'a\\' + 1;\\n            currHash = (currHash * power + value) % modulo;\\n        }\\n        \\n        int result = -1;\\n        if (currHash == hashValue) {\\n            result = n - k;\\n        }\\n        \\n        for (int i = k; n - 1- i >= 0; i++) {\\n            int tailValue = s.charAt(n - 1- i + k) - \\'a\\' + 1;\\n            currHash = ((currHash - tailValue * lastPower) % modulo + modulo) % modulo;\\n            int headValue = s.charAt(n - 1 - i) - \\'a\\' + 1;\\n            currHash = (currHash * power + headValue) % modulo;\\n            if (currHash == hashValue) {\\n                result = n - 1 - i;\\n            }\\n        }\\n        \\n        return s.substring(result, result + k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n        int n = s.length();\\n        long lastPower = 1;\\n        for (int i = 1; i < k; i++) {\\n            lastPower = (lastPower * power) % modulo;\\n        }\\n        \\n        long currHash = 0;\\n        for (int i = 0; i < k; i++) {\\n            int value = s.charAt(n - 1 - i) - \\'a\\' + 1;\\n            currHash = (currHash * power + value) % modulo;\\n        }\\n        \\n        int result = -1;\\n        if (currHash == hashValue) {\\n            result = n - k;\\n        }\\n        \\n        for (int i = k; n - 1- i >= 0; i++) {\\n            int tailValue = s.charAt(n - 1- i + k) - \\'a\\' + 1;\\n            currHash = ((currHash - tailValue * lastPower) % modulo + modulo) % modulo;\\n            int headValue = s.charAt(n - 1 - i) - \\'a\\' + 1;\\n            currHash = (currHash * power + headValue) % modulo;\\n            if (currHash == hashValue) {\\n                result = n - 1 - i;\\n            }\\n        }\\n        \\n        return s.substring(result, result + k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941129,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n    long maxPower = 1;\\n    long hash = 0;\\n    int bestLeft = -1;\\n\\n    auto val = [](char c) -> int { return c - \\'a\\' + 1; };\\n\\n    for (int i = s.length() - 1; i >= 0; --i) {\\n      hash = (hash * power + val(s[i])) % modulo;\\n      if (i + k < s.length())\\n        hash = (hash - val(s[i + k]) * maxPower % modulo + modulo) % modulo;\\n      else\\n        maxPower = maxPower * power % modulo;\\n      if (hash == hashValue)\\n        bestLeft = i;\\n    }\\n\\n    return s.substr(bestLeft, k);\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n    long maxPower = 1;\\n    long hash = 0;\\n    int bestLeft = -1;\\n\\n    auto val = [](char c) -> int { return c - \\'a\\' + 1; };\\n\\n    for (int i = s.length() - 1; i >= 0; --i) {\\n      hash = (hash * power + val(s[i])) % modulo;\\n      if (i + k < s.length())\\n        hash = (hash - val(s[i + k]) * maxPower % modulo + modulo) % modulo;\\n      else\\n        maxPower = maxPower * power % modulo;\\n      if (hash == hashValue)\\n        bestLeft = i;\\n    }\\n\\n    return s.substr(bestLeft, k);\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719692,
                "title": "rolling-hash-back-to-front-in-python3",
                "content": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        ords = [ord(l) - ord(\\'a\\') + 1 for l in s]\\n        pows = [pow(power,i,modulo) for i in range(k)]\\n        n = len(s)           \\n        hash0 = sum(pows[i]*ords[n-k+i] for i in range(k)) % (modulo)\\n        res = \\'\\'     \\n        if hash0 == hashValue:\\n            res = s[n-k:]\\n\\n        for i in range(n-2,k-2,-1):\\n            sa = ords[i+1]\\n            sb = ords[i-k+1]\\n            hash0 -= sa*pows[-1]\\n            hash0 *= power\\n            hash0 += sb*pows[0]\\n            hash0 = hash0 % modulo\\n            \\n            if hash0 == hashValue:\\n                res =  s[i-k+1:i+1]\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        ords = [ord(l) - ord(\\'a\\') + 1 for l in s]\\n        pows = [pow(power,i,modulo) for i in range(k)]\\n        n = len(s)           \\n        hash0 = sum(pows[i]*ords[n-k+i] for i in range(k)) % (modulo)\\n        res = \\'\\'     \\n        if hash0 == hashValue:\\n            res = s[n-k:]\\n\\n        for i in range(n-2,k-2,-1):\\n            sa = ords[i+1]\\n            sb = ords[i-k+1]\\n            hash0 -= sa*pows[-1]\\n            hash0 *= power\\n            hash0 += sb*pows[0]\\n            hash0 = hash0 % modulo\\n            \\n            if hash0 == hashValue:\\n                res =  s[i-k+1:i+1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568005,
                "title": "c-sliding-window-binary-exponentiation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod;\\n    long long binaryExpo(long long a,long long b)\\n    {\\n        long long res = 1;\\n        while(b)\\n        {\\n            if(b&1)\\n            {\\n                res = ((res%mod)*(a%mod))%mod;\\n            }\\n            b>>=1;\\n            a = ((a%mod)*(a%mod))%mod;\\n        }\\n        return res;\\n    }\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        mod = modulo;\\n        int n = s.size();\\n        long long h1 = 0;\\n        for(int i=n-1;i>=n-k;i--)\\n        {\\n            h1 = (h1*power+s[i]-\\'a\\'+1)%mod;\\n        }\\n        int ansidx = -1;\\n        if(h1==hashValue)\\n        {\\n            ansidx = n-k;\\n        }\\n        int idx = n-k-1;\\n        int ptr1 = n-1,ptr2 = n-k-1;\\n        while(ptr2>=0)\\n        {\\n            h1=(h1-((s[ptr1]-\\'a\\'+1)*binaryExpo((long long)power,(long long)k-1))%mod+mod)%mod;\\n            h1=(h1*power+(s[ptr2]-\\'a\\')+1)%mod;\\n            \\n            if(h1==hashValue)\\n            {\\n                ansidx = idx;  \\n            }\\n            idx--;\\n            ptr2--;\\n            ptr1--;\\n        }\\n        if(ansidx+k<=s.size())\\n        return s.substr(ansidx,k);\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod;\\n    long long binaryExpo(long long a,long long b)\\n    {\\n        long long res = 1;\\n        while(b)\\n        {\\n            if(b&1)\\n            {\\n                res = ((res%mod)*(a%mod))%mod;\\n            }\\n            b>>=1;\\n            a = ((a%mod)*(a%mod))%mod;\\n        }\\n        return res;\\n    }\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        mod = modulo;\\n        int n = s.size();\\n        long long h1 = 0;\\n        for(int i=n-1;i>=n-k;i--)\\n        {\\n            h1 = (h1*power+s[i]-\\'a\\'+1)%mod;\\n        }\\n        int ansidx = -1;\\n        if(h1==hashValue)\\n        {\\n            ansidx = n-k;\\n        }\\n        int idx = n-k-1;\\n        int ptr1 = n-1,ptr2 = n-k-1;\\n        while(ptr2>=0)\\n        {\\n            h1=(h1-((s[ptr1]-\\'a\\'+1)*binaryExpo((long long)power,(long long)k-1))%mod+mod)%mod;\\n            h1=(h1*power+(s[ptr2]-\\'a\\')+1)%mod;\\n            \\n            if(h1==hashValue)\\n            {\\n                ansidx = idx;  \\n            }\\n            idx--;\\n            ptr2--;\\n            ptr1--;\\n        }\\n        if(ansidx+k<=s.size())\\n        return s.substr(ansidx,k);\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387741,
                "title": "time-o-n-o-n-space-o-1-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n    maxPower = pow(power, k, modulo)\\n    hashed = 0\\n\\n    def val(c: chr) -> int:\\n      return ord(c) - ord(\\'a\\') + 1\\n\\n    for i, c in reversed(list(enumerate(s))):\\n      hashed = (hashed * power + val(c)) % modulo\\n      if i + k < len(s):\\n        hashed = (hashed - val(s[i + k]) * maxPower) % modulo\\n      if hashed == hashValue:\\n        bestLeft = i\\n\\n    return s[bestLeft:bestLeft + k]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n    maxPower = pow(power, k, modulo)\\n    hashed = 0\\n\\n    def val(c: chr) -> int:\\n      return ord(c) - ord(\\'a\\') + 1\\n\\n    for i, c in reversed(list(enumerate(s))):\\n      hashed = (hashed * power + val(c)) % modulo\\n      if i + k < len(s):\\n        hashed = (hashed - val(s[i + k]) * maxPower) % modulo\\n      if hashed == hashValue:\\n        bestLeft = i\\n\\n    return s[bestLeft:bestLeft + k]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254996,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn sub_str_hash(s: String, power: i32, modulo: i32, k: i32, hash_value: i32) -> String {\\n        let s = s.as_bytes();\\n        let (power, modulo, k, hash_value) = (power as i64, modulo as i64, k as i64, hash_value as i64);\\n        let (mut cur, mut res, mut pk) = (0, 0, 1);\\n        let n = s.len() as i64;\\n        let mut i = n - 1;\\n        while i >= 0 {\\n            cur = (cur * power + (s[i as usize] - b\\'a\\' + 1) as i64) % modulo;\\n            if i + k >= n {\\n                pk = pk * power % modulo;\\n            } else {\\n                cur = (cur - (s[(i + k) as usize] - b\\'a\\' + 1) as i64 * pk % modulo + modulo) % modulo;\\n            }\\n            if cur == hash_value {\\n                res = i;\\n            }\\n            i -= 1;\\n        }\\n        String::from_utf8(s[res as usize..(res + k) as usize].to_vec()).unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn sub_str_hash(s: String, power: i32, modulo: i32, k: i32, hash_value: i32) -> String {\\n        let s = s.as_bytes();\\n        let (power, modulo, k, hash_value) = (power as i64, modulo as i64, k as i64, hash_value as i64);\\n        let (mut cur, mut res, mut pk) = (0, 0, 1);\\n        let n = s.len() as i64;\\n        let mut i = n - 1;\\n        while i >= 0 {\\n            cur = (cur * power + (s[i as usize] - b\\'a\\' + 1) as i64) % modulo;\\n            if i + k >= n {\\n                pk = pk * power % modulo;\\n            } else {\\n                cur = (cur - (s[(i + k) as usize] - b\\'a\\' + 1) as i64 * pk % modulo + modulo) % modulo;\\n            }\\n            if cur == hash_value {\\n                res = i;\\n            }\\n            i -= 1;\\n        }\\n        String::from_utf8(s[res as usize..(res + k) as usize].to_vec()).unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3008921,
                "title": "rolling-hash-from-end",
                "content": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        n = len(s)\\n        val = lambda c: ord(c) - ord(\\'a\\') + 1\\n        p = 1\\n        powers = []\\n        for _ in range(k):\\n            powers.append(p)\\n            p = (p * power) % modulo\\n        curr = 0\\n        for i in range(k):\\n            curr = (curr + val(s[n - k + i]) * powers[i]) % modulo\\n        res = None\\n        for i in range(n - k - 1, -1, -1):\\n            if curr == hashValue:\\n                res = s[i + 1 : i + k + 1]\\n            curr = (power * (curr + modulo - (val(s[i + k]) * powers[k - 1]) % modulo) + val(s[i])) % modulo\\n        if curr == hashValue:\\n            res = s[:k]\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        n = len(s)\\n        val = lambda c: ord(c) - ord(\\'a\\') + 1\\n        p = 1\\n        powers = []\\n        for _ in range(k):\\n            powers.append(p)\\n            p = (p * power) % modulo\\n        curr = 0\\n        for i in range(k):\\n            curr = (curr + val(s[n - k + i]) * powers[i]) % modulo\\n        res = None\\n        for i in range(n - k - 1, -1, -1):\\n            if curr == hashValue:\\n                res = s[i + 1 : i + k + 1]\\n            curr = (power * (curr + modulo - (val(s[i + k]) * powers[k - 1]) % modulo) + val(s[i])) % modulo\\n        if curr == hashValue:\\n            res = s[:k]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975966,
                "title": "rolling-hash-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        int n = s.size();\\n        long long hash = 0, ind = -1, p_pow = 1;\\n\\n        for(int i = n-k; i<n; i++){\\n            hash = (hash + (s[i] - \\'a\\' + 1) * p_pow) % modulo;\\n            if(i != n - 1) p_pow = (p_pow * power) % modulo;\\n        }\\n        if(hash == hashValue) ind = n - k;\\n        \\n        for(int i=n-k-1; i>=0; i--){\\n            // IMP : here we subtract so it may lead hash to negative so to avoid that we add modulo  \\n            hash = (hash - (s[i + k] - \\'a\\' + 1) * p_pow % modulo + modulo) % modulo;  \\n            hash = (hash * power) % modulo;\\n            hash = (hash + s[i] - \\'a\\' + 1) % modulo;\\n            if(hash == hashValue) \\n                ind = i;\\n        }\\n        return s.substr(ind, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        int n = s.size();\\n        long long hash = 0, ind = -1, p_pow = 1;\\n\\n        for(int i = n-k; i<n; i++){\\n            hash = (hash + (s[i] - \\'a\\' + 1) * p_pow) % modulo;\\n            if(i != n - 1) p_pow = (p_pow * power) % modulo;\\n        }\\n        if(hash == hashValue) ind = n - k;\\n        \\n        for(int i=n-k-1; i>=0; i--){\\n            // IMP : here we subtract so it may lead hash to negative so to avoid that we add modulo  \\n            hash = (hash - (s[i + k] - \\'a\\' + 1) * p_pow % modulo + modulo) % modulo;  \\n            hash = (hash * power) % modulo;\\n            hash = (hash + s[i] - \\'a\\' + 1) % modulo;\\n            if(hash == hashValue) \\n                ind = i;\\n        }\\n        return s.substr(ind, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769525,
                "title": "python-solution-cache-powers",
                "content": "```\\ndef subStrHash(self, s: str, p: int, mod: int, k: int, x: int) -> str:\\n\\tdef val(c):\\n\\t\\treturn ord(c)-ord(\\'a\\')+1\\n\\ti, ans, p = len(s)-k, len(s)-k, p%mod\\n\\tpw, pk = [pow(p,i,mod) for i in range(k)], pow(p,k,mod)\\n\\tcur = sum((val(s[i+a])*pw[a]) for a in range(k))%mod\\n\\tfor i in range(len(s)-k-1, -1, -1):\\n\\t\\tcur = (cur*p-val(s[i+k])*pk + val(s[i])) % mod\\n\\t\\tif cur == x:\\n\\t\\t\\tans = i\\n\\treturn s[ans:ans+k]\\n```",
                "solutionTags": [],
                "code": "```\\ndef subStrHash(self, s: str, p: int, mod: int, k: int, x: int) -> str:\\n\\tdef val(c):\\n\\t\\treturn ord(c)-ord(\\'a\\')+1\\n\\ti, ans, p = len(s)-k, len(s)-k, p%mod\\n\\tpw, pk = [pow(p,i,mod) for i in range(k)], pow(p,k,mod)\\n\\tcur = sum((val(s[i+a])*pw[a]) for a in range(k))%mod\\n\\tfor i in range(len(s)-k-1, -1, -1):\\n\\t\\tcur = (cur*p-val(s[i+k])*pk + val(s[i])) % mod\\n\\t\\tif cur == x:\\n\\t\\t\\tans = i\\n\\treturn s[ans:ans+k]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2585876,
                "title": "c-rolling-hash-short-solution",
                "content": "```\\n    string subStrHash(string s, int p, int m, int k, int h) {\\n        long n = s.size(), res = -1, sum = 0, sub = 1;\\n        for(int i = n-1; i >= 0; i--) {\\n            if(i + k > n) sub = (sub*p)%m;\\n            if(i < n-k) sum = ((sum-(s[i+k]-\\'a\\'+1)*sub)%m+m)%m;\\n            sum = (sum*p+s[i]-\\'a\\'+1)%m;\\n            if(i <= n-k && sum == h) res = i;\\n        }\\n        return s.substr(res, k);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    string subStrHash(string s, int p, int m, int k, int h) {\\n        long n = s.size(), res = -1, sum = 0, sub = 1;\\n        for(int i = n-1; i >= 0; i--) {\\n            if(i + k > n) sub = (sub*p)%m;\\n            if(i < n-k) sum = ((sum-(s[i+k]-\\'a\\'+1)*sub)%m+m)%m;\\n            sum = (sum*p+s[i]-\\'a\\'+1)%m;\\n            if(i <= n-k && sum == h) res = i;\\n        }\\n        return s.substr(res, k);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2537915,
                "title": "8-line-python3-code-o-n",
                "content": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        \\n        d = {chr(i): i - 96 for i in range(97, 123)}\\n        sum_list = 0; p = 1\\n        for i in range(k): sum_list += (d[s[i]] * p); p *= power\\n        powerK_1 = p // power\\n        \\n        for i in range(len(s) - (k - 1)):\\n            if sum_list % modulo == hashValue: return s[i:i + k]\\n            new_sK = powerK_1 * d[s[i + k]]\\n            sum_list = ((sum_list - d[s[i]]) // power) + new_sK\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        \\n        d = {chr(i): i - 96 for i in range(97, 123)}\\n        sum_list = 0; p = 1\\n        for i in range(k): sum_list += (d[s[i]] * p); p *= power\\n        powerK_1 = p // power\\n        \\n        for i in range(len(s) - (k - 1)):\\n            if sum_list % modulo == hashValue: return s[i:i + k]\\n            new_sK = powerK_1 * d[s[i + k]]\\n            sum_list = ((sum_list - d[s[i]]) // power) + new_sK\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2537282,
                "title": "how-do-i-debug-this-off-by-one-python-error",
                "content": "https://leetcode.com/submissions/detail/792599762/\\n\\n```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        \\n        sOrd = [ord(c) - 96 for c in s]\\n        powerK_1 = power ** (k - 1)\\n        sK = [sOrd[i] * (power ** i) for i in range(k)]\\n        \\n        for i in range(len(s) - k + 1):\\n            if sum(sK) % modulo == hashValue: return s[i:i + k]\\n            new_sK = powerK_1 * sOrd[i + k - 1]\\n            sK = [sK_ // power for sK_ in sK[1:]] + [new_sK]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        \\n        sOrd = [ord(c) - 96 for c in s]\\n        powerK_1 = power ** (k - 1)\\n        sK = [sOrd[i] * (power ** i) for i in range(k)]\\n        \\n        for i in range(len(s) - k + 1):\\n            if sum(sK) % modulo == hashValue: return s[i:i + k]\\n            new_sK = powerK_1 * sOrd[i + k - 1]\\n            sK = [sK_ // power for sK_ in sK[1:]] + [new_sK]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499062,
                "title": "python3-sliding-window",
                "content": "Algorithm:\\n1.First compute cost for window of value k \\n2.Then iterate the window ahead and find cost function for each window.\\n\\nPrecompute the mapper and avoiding multiple use of pow and ** helped in avoiding the TLE .\\n\\n\\n```\\n\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        \\n        \\n        temp=power**(k-1)\\n        mapper={}\\n        for i in range(ord(\"a\"),ord(\"z\")+1):\\n            mapper[chr(i)]=i-96\\n            \\n        i=0\\n        j=0\\n        value=0 \\n        temp=1\\n        while(j<len(s)):\\n            \\n            \\n            if(j-i+1<k):\\n                value+=(mapper[s[j]])*(temp)\\n                j+=1   \\n                temp*=power\\n            \\n            else:\\n                value+=(mapper[s[j]])*temp\\n                \\n                if(value%modulo==hashValue):\\n                    return s[i:j+1]\\n                \\n                value=((value-mapper[s[i]])//power)\\n                i+=1\\n                j+=1\\n                \\n        return \"\"             \\n                \\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        \\n        \\n        temp=power**(k-1)\\n        mapper={}\\n        for i in range(ord(\"a\"),ord(\"z\")+1):\\n            mapper[chr(i)]=i-96\\n            \\n        i=0\\n        j=0\\n        value=0 \\n        temp=1\\n        while(j<len(s)):\\n            \\n            \\n            if(j-i+1<k):\\n                value+=(mapper[s[j]])*(temp)\\n                j+=1   \\n                temp*=power\\n            \\n            else:\\n                value+=(mapper[s[j]])*temp\\n                \\n                if(value%modulo==hashValue):\\n                    return s[i:j+1]\\n                \\n                value=((value-mapper[s[i]])//power)\\n                i+=1\\n                j+=1\\n                \\n        return \"\"             \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466188,
                "title": "python-o-n-log-n-with-fourier-transform",
                "content": "One way to approach this is to find ```hash(s[i:i+k], p, m)``` for all possible starting indices ```i``` of the substring, and then take the minimum index where the hash value matches. The brute force method for this would take O(nk), but we can speed it up by noticing that we are essentially taking a rolling dot product of the array ```[p^0, p^1, ... p^{k-1}]``` with the string itself. Such a rolling dot product is really just a *convolution* and can be evaluated with the Fast Fourier Transform in time O(n log n). \\n\\nFor more information on this method, see https://www.youtube.com/watch?v=iTMn0Kt18tg\\n\\n \\n ```\\nimport numpy as np\\nfrom numpy.fft import fft, ifft\\n\\ndef val(c):\\n    return ord(c) - 96\\n\\ndef fft_mult(a, b, m):\\n    length = len(a) + len(b) - 1\\n    a_f = np.pad(a,(0, length - len(a)),\\'constant\\')\\n    b_f = np.pad(b,(0, length - len(b)),\\'constant\\')\\n    c_f = [a * b for a, b in zip(fft(a_f), fft(b_f))]\\n    \\n    return [round(abs(c)) % m for c in ifft(c_f)]\\n\\ndef gen_power_arr(p, k, m):\\n    curr = 1\\n    L = []\\n    for i in range(k):\\n        L.append(curr)\\n        curr = (curr*p % m)\\n    return L[::-1]\\n\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        p_arr = gen_power_arr(power, k, modulo)\\n        str_vals = [val(c) for c in s]\\n        \\n        output = fft_mult(p_arr, str_vals, modulo)[k-1:]\\n        idx = [i for i, c in enumerate(output) if c == hashValue][0]\\n        return s[idx:idx + k]\\n        \\n```",
                "solutionTags": [],
                "code": "```hash(s[i:i+k], p, m)```\n```i```\n```[p^0, p^1, ... p^{k-1}]```\n```\\nimport numpy as np\\nfrom numpy.fft import fft, ifft\\n\\ndef val(c):\\n    return ord(c) - 96\\n\\ndef fft_mult(a, b, m):\\n    length = len(a) + len(b) - 1\\n    a_f = np.pad(a,(0, length - len(a)),\\'constant\\')\\n    b_f = np.pad(b,(0, length - len(b)),\\'constant\\')\\n    c_f = [a * b for a, b in zip(fft(a_f), fft(b_f))]\\n    \\n    return [round(abs(c)) % m for c in ifft(c_f)]\\n\\ndef gen_power_arr(p, k, m):\\n    curr = 1\\n    L = []\\n    for i in range(k):\\n        L.append(curr)\\n        curr = (curr*p % m)\\n    return L[::-1]\\n\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        p_arr = gen_power_arr(power, k, modulo)\\n        str_vals = [val(c) for c in s]\\n        \\n        output = fft_mult(p_arr, str_vals, modulo)[k-1:]\\n        idx = [i for i, c in enumerate(output) if c == hashValue][0]\\n        return s[idx:idx + k]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309320,
                "title": "0ms-1liner-100-fastest-solution-explained-o-n-time-complexity-o-n-space-complexity",
                "content": "\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 3.27MB*** (beats 99.04% / 90.42%).\\n\\n```\\n\\nclass Solution {\\n    public String nearestPalindromic(String n) {\\n        long N = Long.parseLong(n), S = previous(String.valueOf(N-1).toCharArray()), L = next(String.valueOf(N+1).toCharArray());\\n        return String.valueOf(L - N < N - S ? L : S);\\n    }\\n    private long previous(char[] s) {\\n        for(int i = 0, n = s.length; i < (n >> 1); i++) {\\n            while(s[i] != s[n - 1 - i]) {\\n                decrement(s, n - 1 - i);\\n                if(s[0] == \\'0\\') return Long.parseLong(new String(s));\\n            }\\n        }\\n        return Long.parseLong(new String(s));\\n    }\\n    private void decrement(char[] s, int i) {\\n        while(s[i] == \\'0\\') s[i--] = \\'9\\';\\n        s[i]--;\\n    }\\n    private long next(char[] s) {\\n        for(int i = 0, n = s.length; i < (n >> 1); i++) {\\n            while(s[i] != s[n - 1 - i]) {\\n                increment(s, n - 1 - i);\\n            }\\n        }\\n        return Long.parseLong(new String(s));\\n    }\\n    private void increment(char[] s, int i) {\\n        while(s[i] == \\'9\\') s[i--] = \\'0\\';\\n        s[i]++;\\n    }\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***\\n",
                "solutionTags": [],
                "code": "```\\n```\n```\\n\\nclass Solution {\\n    public String nearestPalindromic(String n) {\\n        long N = Long.parseLong(n), S = previous(String.valueOf(N-1).toCharArray()), L = next(String.valueOf(N+1).toCharArray());\\n        return String.valueOf(L - N < N - S ? L : S);\\n    }\\n    private long previous(char[] s) {\\n        for(int i = 0, n = s.length; i < (n >> 1); i++) {\\n            while(s[i] != s[n - 1 - i]) {\\n                decrement(s, n - 1 - i);\\n                if(s[0] == \\'0\\') return Long.parseLong(new String(s));\\n            }\\n        }\\n        return Long.parseLong(new String(s));\\n    }\\n    private void decrement(char[] s, int i) {\\n        while(s[i] == \\'0\\') s[i--] = \\'9\\';\\n        s[i]--;\\n    }\\n    private long next(char[] s) {\\n        for(int i = 0, n = s.length; i < (n >> 1); i++) {\\n            while(s[i] != s[n - 1 - i]) {\\n                increment(s, n - 1 - i);\\n            }\\n        }\\n        return Long.parseLong(new String(s));\\n    }\\n    private void increment(char[] s, int i) {\\n        while(s[i] == \\'9\\') s[i--] = \\'0\\';\\n        s[i]++;\\n    }\\n}\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165668,
                "title": "java-solution-with-few-test-cases-failing-need-help",
                "content": "This is my approach for a sliding window and calculating hash\\nFew TCs failing, could someone please provide some help?\\n\\n\\n```\\n\\nclass Solution {\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n        \\n        int l = 0;\\n        int r = k;\\n        \\n        double currHashValue = 0;\\n        \\n       currHashValue = getHashValue(l,r,s, power,modulo);\\n       \\n        if(currHashValue == hashValue)\\n            return s.substring(l,k);\\n        \\n        for(int i=1;i<s.length()-k;i++)\\n        {\\n            currHashValue = getHashValue(i,k,s,power,modulo);\\n            if(currHashValue == (hashValue))\\n                return s.substring(i,i+k);\\n        }\\n        \\n        return s;\\n    }\\n    \\n    private Double getHashValue(int l, int r, String s,int power,int modulo)\\n    {\\n        double currHashValue = 0;\\n        int iterVar = 0;\\n        while(iterVar < r)//for(int i=0;i<r;i++)\\n        {\\n            currHashValue = currHashValue + ((s.charAt(l)-\\'a\\'+1)%modulo * (Math.pow(power,iterVar)%modulo))%modulo;\\n                \\n            iterVar++;\\n            l++;\\n        }\\n        \\n        return currHashValue%modulo;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n\\nclass Solution {\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n        \\n        int l = 0;\\n        int r = k;\\n        \\n        double currHashValue = 0;\\n        \\n       currHashValue = getHashValue(l,r,s, power,modulo);\\n       \\n        if(currHashValue == hashValue)\\n            return s.substring(l,k);\\n        \\n        for(int i=1;i<s.length()-k;i++)\\n        {\\n            currHashValue = getHashValue(i,k,s,power,modulo);\\n            if(currHashValue == (hashValue))\\n                return s.substring(i,i+k);\\n        }\\n        \\n        return s;\\n    }\\n    \\n    private Double getHashValue(int l, int r, String s,int power,int modulo)\\n    {\\n        double currHashValue = 0;\\n        int iterVar = 0;\\n        while(iterVar < r)//for(int i=0;i<r;i++)\\n        {\\n            currHashValue = currHashValue + ((s.charAt(l)-\\'a\\'+1)%modulo * (Math.pow(power,iterVar)%modulo))%modulo;\\n                \\n            iterVar++;\\n            l++;\\n        }\\n        \\n        return currHashValue%modulo;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934660,
                "title": "rolling-hash-with-check",
                "content": "```\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int power, int mod, int k, int hashValue) {\\n        vector<int> prefixHash = {0};\\n        long long h = 0, pn = 1, pnk = 1;\\n        \\n        for(int i=0;i<s.size();i++){\\n            int v = s[i] -\\'a\\' + 1;\\n            h = (h+v*pn) % mod;\\n            if(i>=k) pnk= pnk*power % mod;;\\n            pn = pn*power % mod;\\n            prefixHash.push_back(h);\\n            if(i>=k-1){\\n                auto deltaH = (h - prefixHash[i-k+1] - hashValue*pnk) % mod;\\n                if(deltaH == 0){\\n                    int doubleCheckHash = hash(s, i, k, mod, power);\\n                    if(doubleCheckHash == hashValue) return s.substr(i-k+1, k);                    \\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n    \\n    int hash(const string& s, int i, int k, int mod, int power){\\n        long long h = 0, pn = 1;\\n        for(int j=i-k+1;j<=i;j++){\\n            int v = s[j] -\\'a\\' + 1;\\n            h += pn*v;\\n            pn = pn* power % mod;\\n        }\\n        return h % mod;\\n    }    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string subStrHash(string s, int power, int mod, int k, int hashValue) {\\n        vector<int> prefixHash = {0}",
                "codeTag": "Java"
            },
            {
                "id": 1918195,
                "title": "c-string-hashing",
                "content": "```\\n// regular string hashing, but note that here the modulo is given instead of using \\n// \"unsigned long long\" implicitly, and % works differently for unsigned type, thus\\n// need to use signed type with %.\\n\\n\\ntypedef long long ULL;\\n\\nconst int N = 20010;\\n\\nclass Solution {\\n    int n, m, P;\\n    ULL p[N] = {}, h[N] = {};\\n    \\n    void init(string& s)\\n    {\\n        p[0] = 1;\\n        for (int i = n - 1, j = 1; i >= 0; -- i, ++ j)\\n        {\\n            p[j] = (p[j - 1] * P) % m;\\n            h[i] = (h[i + 1] * P + s[i] - \\'a\\' + 1) % m;\\n        }\\n    }\\n    \\n    ULL get(int l, int r)\\n    {\\n        return ((h[l] - h[r + 1] * p[r - l + 1]) % m + m) % m;\\n    }\\n    \\npublic:\\n    string subStrHash(string s, int _P, int _m, int k, int hashValue) {\\n        n = s.size(), m = _m, P = _P;\\n\\n        init(s);\\n        \\n        unordered_map<ULL, int> S;\\n        for (int i = 0; i + k - 1 < n; ++ i)\\n        {\\n            int j = i + k - 1;\\n            ULL v = get(i, j);\\n            if (v == hashValue) return s.substr(i, k);\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// regular string hashing, but note that here the modulo is given instead of using \\n// \"unsigned long long\" implicitly, and % works differently for unsigned type, thus\\n// need to use signed type with %.\\n\\n\\ntypedef long long ULL;\\n\\nconst int N = 20010;\\n\\nclass Solution {\\n    int n, m, P;\\n    ULL p[N] = {}, h[N] = {};\\n    \\n    void init(string& s)\\n    {\\n        p[0] = 1;\\n        for (int i = n - 1, j = 1; i >= 0; -- i, ++ j)\\n        {\\n            p[j] = (p[j - 1] * P) % m;\\n            h[i] = (h[i + 1] * P + s[i] - \\'a\\' + 1) % m;\\n        }\\n    }\\n    \\n    ULL get(int l, int r)\\n    {\\n        return ((h[l] - h[r + 1] * p[r - l + 1]) % m + m) % m;\\n    }\\n    \\npublic:\\n    string subStrHash(string s, int _P, int _m, int k, int hashValue) {\\n        n = s.size(), m = _m, P = _P;\\n\\n        init(s);\\n        \\n        unordered_map<ULL, int> S;\\n        for (int i = 0; i + k - 1 < n; ++ i)\\n        {\\n            int j = i + k - 1;\\n            ULL v = get(i, j);\\n            if (v == hashValue) return s.substr(i, k);\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745602,
                "title": "golang-o-n-sliding-window-rev-order",
                "content": "```go\\nfunc subStrHash(s string, power int, modulo int, k int, hashValue int) string {\\n    n := len(s)\\n    \\n    p, current := 1, 0\\n    for i := n - k; i < n; i++ {\\n        current += (int(s[i] - \\'a\\' + 1) * p) % modulo\\n        if current >= modulo {\\n            current -= modulo\\n        }\\n       \\n        if i < n - 1 {\\n            p = (p * power) % modulo\\n        }\\n    }\\n    \\n    var last int\\n    \\n    if current == hashValue {\\n        last = n - k \\n    }\\n   \\n    for i := n - k - 1; i >= 0; i-- {\\n        // remove i + k\\n        current -= (p * int(s[i + k] - \\'a\\' + 1)) % modulo\\n        if current < 0 {\\n            current += modulo\\n        }\\n        \\n        // add i\\n        current = (current * power + int(s[i] - \\'a\\' + 1)) % modulo\\n        \\n        if current == hashValue {\\n            last = i\\n        }\\n    }\\n    \\n    return s[last:last+k]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc subStrHash(s string, power int, modulo int, k int, hashValue int) string {\\n    n := len(s)\\n    \\n    p, current := 1, 0\\n    for i := n - k; i < n; i++ {\\n        current += (int(s[i] - \\'a\\' + 1) * p) % modulo\\n        if current >= modulo {\\n            current -= modulo\\n        }\\n       \\n        if i < n - 1 {\\n            p = (p * power) % modulo\\n        }\\n    }\\n    \\n    var last int\\n    \\n    if current == hashValue {\\n        last = n - k \\n    }\\n   \\n    for i := n - k - 1; i >= 0; i-- {\\n        // remove i + k\\n        current -= (p * int(s[i + k] - \\'a\\' + 1)) % modulo\\n        if current < 0 {\\n            current += modulo\\n        }\\n        \\n        // add i\\n        current = (current * power + int(s[i] - \\'a\\' + 1)) % modulo\\n        \\n        if current == hashValue {\\n            last = i\\n        }\\n    }\\n    \\n    return s[last:last+k]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1743340,
                "title": "c-rolling-hash",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll poww(ll a, ll b, ll mod) {\\n        ll res = 1;\\n        \\n        while(b > 0) {\\n            if( b % 2 ) {\\n                res = (res * a) % mod;\\n            }\\n            a = (a * a) % mod;\\n            b >>= 1;\\n        }\\n        return res;\\n    }\\n    ll val(char c) {\\n        return c - \\'a\\' + 1;\\n    }\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        \\n        string original_s = s;\\n        ll mod = modulo, cur = 0, n = s.size(), l = 0, r = k - 1, min_l = n, pk1;\\n        \\n        reverse(s.begin(), s.end());\\n        for(int i = 0; i < k; ++i) {\\n            cur += val(s[i]) * poww( power, k - 1 - i, mod);\\n            cur %= mod;\\n        }\\n        if (cur == hashValue ) min_l = min(min_l, n - 1 - r) ;\\n        l++, r++;\\n        \\n        pk1 = poww(power, k - 1, mod);\\n        for(; r < n; ++l, ++r) {\\n            cur = ( cur + mod - (val(s[l - 1]) * pk1) % mod ) % mod;\\n            cur = ( (cur * power) % mod + val(s[r]) ) % mod;\\n            if (cur == hashValue ) min_l = min(min_l, n - 1 - r); \\n        }   \\n        \\n        return original_s.substr(min_l, k);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll poww(ll a, ll b, ll mod) {\\n        ll res = 1;\\n        \\n        while(b > 0) {\\n            if( b % 2 ) {\\n                res = (res * a) % mod;\\n            }\\n            a = (a * a) % mod;\\n            b >>= 1;\\n        }\\n        return res;\\n    }\\n    ll val(char c) {\\n        return c - \\'a\\' + 1;\\n    }\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        \\n        string original_s = s;\\n        ll mod = modulo, cur = 0, n = s.size(), l = 0, r = k - 1, min_l = n, pk1;\\n        \\n        reverse(s.begin(), s.end());\\n        for(int i = 0; i < k; ++i) {\\n            cur += val(s[i]) * poww( power, k - 1 - i, mod);\\n            cur %= mod;\\n        }\\n        if (cur == hashValue ) min_l = min(min_l, n - 1 - r) ;\\n        l++, r++;\\n        \\n        pk1 = poww(power, k - 1, mod);\\n        for(; r < n; ++l, ++r) {\\n            cur = ( cur + mod - (val(s[l - 1]) * pk1) % mod ) % mod;\\n            cur = ( (cur * power) % mod + val(s[r]) ) % mod;\\n            if (cur == hashValue ) min_l = min(min_l, n - 1 - r); \\n        }   \\n        \\n        return original_s.substr(min_l, k);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741836,
                "title": "python-faster-than-99-25",
                "content": "```\\n        alf = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        alf_dct = {alf[i]: i+1 for i in range(len(alf))}\\n\\n        curr = 0\\n        p = 1\\n\\n        for i in range(k-1):\\n            p = (p * power) % modulo\\n\\n        for i in reversed(range(len(s)-k, len(s))):\\n            curr = (curr * power + alf_dct[s[i]]) % modulo\\n            if curr == hashValue:\\n                result = i\\n                \\n        for i in reversed(range(len(s)-k)):\\n            curr = ((curr - (alf_dct[s[i + k]] * p) % modulo) * power + alf_dct[s[i]]) % modulo\\n            if curr == hashValue:\\n                result = i\\n        return s[result:(result+k)]\\n```",
                "solutionTags": [
                    "Python",
                    "Rolling Hash"
                ],
                "code": "```\\n        alf = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        alf_dct = {alf[i]: i+1 for i in range(len(alf))}\\n\\n        curr = 0\\n        p = 1\\n\\n        for i in range(k-1):\\n            p = (p * power) % modulo\\n\\n        for i in reversed(range(len(s)-k, len(s))):\\n            curr = (curr * power + alf_dct[s[i]]) % modulo\\n            if curr == hashValue:\\n                result = i\\n                \\n        for i in reversed(range(len(s)-k)):\\n            curr = ((curr - (alf_dct[s[i + k]] * p) % modulo) * power + alf_dct[s[i]]) % modulo\\n            if curr == hashValue:\\n                result = i\\n        return s[result:(result+k)]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1737320,
                "title": "detailed-explanation-of-sliding-window-java-solution",
                "content": "The algorithm goes like:\\n\\nStart traversing from the end of the string.\\nUntill we have our sliding window of the size k just keep adding to our existing hash value and keep multiplying the pr with power.\\nwe are storing pr to use it later when we need to subtract the hash value of the last character of a substring.\\n```\\n hash = ((hash*power)%modulo + (s.charAt(i)-\\'a\\'+1))%modulo;\\n    if(i+k>=s.length()){\\n                            pr = (pr*power)%modulo;\\n            }\\n\\t\\t\\n ```\\n         \\n\\t\\t\\nOnce our sliding window is of size == k , we will now remove the hash value of the last character in the substring when a new character is added to the start.\\n\\n\\n```\\nelse{              \\n                hash = (hash - (s.charAt(i+k)-\\'a\\'+1)*pr%modulo+modulo)%modulo;\\n                }\\n```\\nif hash == hashValue we store that index and continue to find if we can still get any index i such that the condition of hash == hashValue holds.(It is because we want the first substring that satisfies this condition).\\n\\nThe final code:\\n```\\nclass Solution {\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n     \\n long hash=0;\\n        long pr = 1;\\n        int idx=0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            \\n            hash = ((hash*power)%modulo + (s.charAt(i)-\\'a\\'+1))%modulo;\\n            \\n            if(i+k>=s.length()){\\n                    pr = (pr*power)%modulo;\\n            }else{              \\n                hash = (hash - (s.charAt(i+k)-\\'a\\'+1)*pr%modulo+modulo)%modulo;\\n                }\\n            \\n            if(hash == (long)hashValue)idx=i;\\n            \\n        }\\n        \\n    return  s.substring(idx,idx+k);\\n\\t```\\n\\tThis solution took me two days to understand and implement ;)) Do upvote if you find it helpful.",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n hash = ((hash*power)%modulo + (s.charAt(i)-\\'a\\'+1))%modulo;\\n    if(i+k>=s.length()){\\n                            pr = (pr*power)%modulo;\\n            }\\n\\t\\t\\n ```\n```\\nelse{              \\n                hash = (hash - (s.charAt(i+k)-\\'a\\'+1)*pr%modulo+modulo)%modulo;\\n                }\\n```\n```\\nclass Solution {\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n     \\n long hash=0;\\n        long pr = 1;\\n        int idx=0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            \\n            hash = ((hash*power)%modulo + (s.charAt(i)-\\'a\\'+1))%modulo;\\n            \\n            if(i+k>=s.length()){\\n                    pr = (pr*power)%modulo;\\n            }else{              \\n                hash = (hash - (s.charAt(i+k)-\\'a\\'+1)*pr%modulo+modulo)%modulo;\\n                }\\n            \\n            if(hash == (long)hashValue)idx=i;\\n            \\n        }\\n        \\n    return  s.substring(idx,idx+k);\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1736871,
                "title": "find-substring-with-given-hash-value",
                "content": "```\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        \\n        int len=s.size();\\n        long p=1;\\n        long hash=0;\\n        int startIdx=-1;\\n        \\n        // Initial calculation of hash for s[len-k -----len-1];\\n        for(int i=len-k;i<len;i++){\\n            hash=(hash+(s[i]-\\'a\\'+1)*p)%modulo;\\n            // if condition as we need power for the last element or power^k-1\\n            // so we calculate in this loop only\\n            if(i<len-1){\\n                p=(p*power)%modulo;\\n            }\\n        }\\n\\n        // check if initial string is the answer or not\\n        if(hash%modulo==hashValue){\\n            startIdx=len-k;\\n        }\\n        \\n        // processing the string from s[len-k-1 ---> 0]\\n        for(int i=len-k-1;i>=0;i--){\\n            //sliding the window while removing last elements calcuation of previous window\\n           // and adding the calculation for new window to avoid recalculation \\n           hash=((hash%modulo)-(((s[i+k]-\\'a\\'+1)*p)%modulo)+modulo)*power+(s[i]-\\'a\\'+1);\\n            // continuing as first hashvalue is required\\n            if(hash%modulo==hashValue){\\n                startIdx=i;\\n            }      \\n        }\\n\\n        return s.substr(startIdx,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        \\n        int len=s.size();\\n        long p=1;\\n        long hash=0;\\n        int startIdx=-1;\\n        \\n        // Initial calculation of hash for s[len-k -----len-1];\\n        for(int i=len-k;i<len;i++){\\n            hash=(hash+(s[i]-\\'a\\'+1)*p)%modulo;\\n            // if condition as we need power for the last element or power^k-1\\n            // so we calculate in this loop only\\n            if(i<len-1){\\n                p=(p*power)%modulo;\\n            }\\n        }\\n\\n        // check if initial string is the answer or not\\n        if(hash%modulo==hashValue){\\n            startIdx=len-k;\\n        }\\n        \\n        // processing the string from s[len-k-1 ---> 0]\\n        for(int i=len-k-1;i>=0;i--){\\n            //sliding the window while removing last elements calcuation of previous window\\n           // and adding the calculation for new window to avoid recalculation \\n           hash=((hash%modulo)-(((s[i+k]-\\'a\\'+1)*p)%modulo)+modulo)*power+(s[i]-\\'a\\'+1);\\n            // continuing as first hashvalue is required\\n            if(hash%modulo==hashValue){\\n                startIdx=i;\\n            }      \\n        }\\n\\n        return s.substr(startIdx,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736287,
                "title": "c-25ms-89-sliding-window-math-with-comments",
                "content": "\\nRuntime: 25 ms, faster than 88.52% of C++ online submissions for Find Substring With Given Hash Value.\\nMemory Usage: 10.2 MB, less than 91.66% of C++ online submissions for Find Substring With Given Hash Value.\\n\\nImagine that we have sequence of numbers **a, b, c, d, ...** and so etc and we want to calculate hash with length 3 with rule of this task : \\nfor first hash we will have **(a * p^0  + b * p^1 + c * p^2) % modulo**  and  check with **hashValue** \\nif we want check **hashValue** with next hash we need to construct our hash again , but insteed we do a bit math: we delete first component **a * p^0** and add next with next power : we will have : \\n **(b * p^1 + c * p^2 + d * p^3) % modulo** . But how we can check it with **hashValue** ??? A bit math again : transform our expression like this :  **p * (b * p^0 + c * p^1 + d * p^2) % modulo** and we understand that we can check it with **hashValue * p % modulo** .\\n **Conclution :** we can calculate hash only one time and after it we will use sliding window and do 3 operation: \\n 1. subtruct from hash first component (multiply with **first_power**)\\n 2. add to hash last component (multiply with **last_power**)\\n 3. update **hashValue** , **first_power**, **last_power**\\n 4. check **hash** and **hashValue** and (**IMPORTANT  !!!**) sometime we will have false alarm , becouse in condition of task we not use prime numbers. and for each actuation we need to consider it separately.\\n\\n```\\nclass Solution {\\npublic:\\n  string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n    long hash = 0, first_power = 1, last_power = 1, hashV = hashValue;\\n    \\n    for(int i = 0; i != k; i++){                   //construct first hash\\n      hash += (s[i] - \\'`\\') * last_power;\\n      \\n      last_power *= power;\\n      last_power %= modulo;\\n    } \\n      \\n    hash %= modulo; \\n    \\n    for(int i = 0, j = k; ; i++, j++){\\n      if(hash == hashV){                              //for false alarm\\n        long h = 0, p = 1; \\n        \\n        for(int id = i, lim = id + k; id != lim; id++){\\n          h += (s[id] - \\'`\\') * p;\\n          p *= power;\\n          p %= modulo;\\n        }\\n        h %= modulo; \\n        \\n        if(h == hashValue) return s.substr(i,k);\\n      } \\n      \\n      hash       -= ((s[i] - \\'`\\')*first_power)%modulo;   //update hash\\n      hash       += ((s[j] - \\'`\\')*last_power )%modulo; \\n      hash       += modulo;                            \\n      hash       %= modulo;\\n                                      \\n      first_power = (first_power*power)%modulo;          //update all parameters                   \\n      last_power  = (last_power *power)%modulo;\\n      hashV       = (hashV      *power)%modulo;\\n    }\\n      \\n    return \"\";\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n    long hash = 0, first_power = 1, last_power = 1, hashV = hashValue;\\n    \\n    for(int i = 0; i != k; i++){                   //construct first hash\\n      hash += (s[i] - \\'`\\') * last_power;\\n      \\n      last_power *= power;\\n      last_power %= modulo;\\n    } \\n      \\n    hash %= modulo; \\n    \\n    for(int i = 0, j = k; ; i++, j++){\\n      if(hash == hashV){                              //for false alarm\\n        long h = 0, p = 1; \\n        \\n        for(int id = i, lim = id + k; id != lim; id++){\\n          h += (s[id] - \\'`\\') * p;\\n          p *= power;\\n          p %= modulo;\\n        }\\n        h %= modulo; \\n        \\n        if(h == hashValue) return s.substr(i,k);\\n      } \\n      \\n      hash       -= ((s[i] - \\'`\\')*first_power)%modulo;   //update hash\\n      hash       += ((s[j] - \\'`\\')*last_power )%modulo; \\n      hash       += modulo;                            \\n      hash       %= modulo;\\n                                      \\n      first_power = (first_power*power)%modulo;          //update all parameters                   \\n      last_power  = (last_power *power)%modulo;\\n      hashV       = (hashV      *power)%modulo;\\n    }\\n      \\n    return \"\";\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736007,
                "title": "c-rolling-hash",
                "content": "Check for the hash collison if any match is found.\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    \\n    ll fun(string s,ll p,ll mod)\\n    {\\n         int n=s.size();\\n        vector<ll> hash(n);\\n       ll cur=0;\\n        ll cp=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            ll v=s[i]-\\'a\\'+1;\\n            hash[i] = (cur%mod + (v*cp)%mod)%mod;\\n            cp*=p;\\n            cp%=mod;\\n            cur=hash[i];\\n        }\\n        return hash[n-1];\\n    }\\n\\n    string subStrHash(string s, int p, int mod, int k, int hashValue) {\\n     \\n        int n=s.size();\\n        vector<ll> hash(n);\\n       ll cur=0;\\n        ll cp=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            ll v=s[i]-\\'a\\'+1;\\n            hash[i] = (cur%mod + (v*cp)%mod)%mod;\\n            cp*=p;\\n            cp%=mod;\\n            cur=hash[i];\\n        }\\n        hashValue%=mod;\\n        if(hashValue==hash[k-1])\\n            return s.substr(0,k);\\n        \\n        cp=p;\\n        for(int i=k;i<n;i++)\\n        {\\n            ll tmp = ((hashValue*cp)%mod + hash[i-k]%mod)%mod;\\n            cp*=p;\\n            cp%=mod;\\n            if(tmp==hash[i] && fun(s.substr(i-k+1,k),p,mod)==hashValue%mod)\\n                return s.substr(i-k+1,k);\\n        }\\n        \\n        \\n        \\n        \\n        return \"ashish\";\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    \\n    ll fun(string s,ll p,ll mod)\\n    {\\n         int n=s.size();\\n        vector<ll> hash(n);\\n       ll cur=0;\\n        ll cp=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            ll v=s[i]-\\'a\\'+1;\\n            hash[i] = (cur%mod + (v*cp)%mod)%mod;\\n            cp*=p;\\n            cp%=mod;\\n            cur=hash[i];\\n        }\\n        return hash[n-1];\\n    }\\n\\n    string subStrHash(string s, int p, int mod, int k, int hashValue) {\\n     \\n        int n=s.size();\\n        vector<ll> hash(n);\\n       ll cur=0;\\n        ll cp=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            ll v=s[i]-\\'a\\'+1;\\n            hash[i] = (cur%mod + (v*cp)%mod)%mod;\\n            cp*=p;\\n            cp%=mod;\\n            cur=hash[i];\\n        }\\n        hashValue%=mod;\\n        if(hashValue==hash[k-1])\\n            return s.substr(0,k);\\n        \\n        cp=p;\\n        for(int i=k;i<n;i++)\\n        {\\n            ll tmp = ((hashValue*cp)%mod + hash[i-k]%mod)%mod;\\n            cp*=p;\\n            cp%=mod;\\n            if(tmp==hash[i] && fun(s.substr(i-k+1,k),p,mod)==hashValue%mod)\\n                return s.substr(i-k+1,k);\\n        }\\n        \\n        \\n        \\n        \\n        return \"ashish\";\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735751,
                "title": "reverse-approach-still-not-working-hint",
                "content": "```\\n#define VAL(temp) (long long)temp-\\'a\\'+1\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        long long computedHash = 0;\\n        int result = -1;\\n        if ( k < 1) {\\n            return \"\";\\n        }\\n        for (int i = s.length() - 1, j = k - 1; i >= s.length() - k; i--, j--) {\\n            computedHash += ((VAL(s[i]) * (long long)pow(power, j)) % modulo);     \\n        }\\n        if (computedHash % modulo == hashValue) {\\n            result = s.length() - k;\\n        }\\n        for (int i = s.length() - k - 1; i >= 0; i--) {\\n            //remove the value of i + k\\n            computedHash -= ((VAL(s[i+k]) * (long long)pow(power, k-1)) % modulo) ;\\n            \\n            computedHash = computedHash * (power % modulo);\\n            \\n            // add the value of i\\n            computedHash += (VAL(s[i]) % modulo);\\n                \\n            if (computedHash % modulo == hashValue) {\\n                result = i;\\n            }\\n        }\\n        \\n        return result == -1 ? \"\" : s.substr(result, k);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#define VAL(temp) (long long)temp-\\'a\\'+1\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        long long computedHash = 0;\\n        int result = -1;\\n        if ( k < 1) {\\n            return \"\";\\n        }\\n        for (int i = s.length() - 1, j = k - 1; i >= s.length() - k; i--, j--) {\\n            computedHash += ((VAL(s[i]) * (long long)pow(power, j)) % modulo);     \\n        }\\n        if (computedHash % modulo == hashValue) {\\n            result = s.length() - k;\\n        }\\n        for (int i = s.length() - k - 1; i >= 0; i--) {\\n            //remove the value of i + k\\n            computedHash -= ((VAL(s[i+k]) * (long long)pow(power, k-1)) % modulo) ;\\n            \\n            computedHash = computedHash * (power % modulo);\\n            \\n            // add the value of i\\n            computedHash += (VAL(s[i]) % modulo);\\n                \\n            if (computedHash % modulo == hashValue) {\\n                result = i;\\n            }\\n        }\\n        \\n        return result == -1 ? \"\" : s.substr(result, k);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735488,
                "title": "c-rabin-karp-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        \\n        int len = s.size(), startIdx = 0;\\n        \\n        long long int prime = 1, hash = 0;\\n        \\n        // we need to traverse from right to left\\n        // because, if we traverse from left to right, we may need to take divison modulo, that might return wrong answer, so we need to traverse from right to left\\n        \\n        for(int i = len-1; i >= 0; i--)\\n        {\\n            // calculate hash value for current character\\n            hash = (hash * power + (s[i] - \\'a\\' + 1)) % modulo;\\n            \\n            // i+k < len means we are outside of the window of size k\\n            // so we need to remove the i+k th character\\n            if(i+k < len)\\n            {\\n                hash = (hash - (s[i+k] - \\'a\\' + 1) * prime % modulo + modulo) % modulo;\\n            }\\n            \\n            // else, we are inside current window, so calculate prime of current window\\n            else{\\n                prime = (prime * power) % modulo;\\n            }\\n            \\n            // at any index, we reach same hashvalue, then mark the current index\\n            if(hash == hashValue)\\n                startIdx = i;\\n        }\\n        \\n        return s.substr(startIdx, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        \\n        int len = s.size(), startIdx = 0;\\n        \\n        long long int prime = 1, hash = 0;\\n        \\n        // we need to traverse from right to left\\n        // because, if we traverse from left to right, we may need to take divison modulo, that might return wrong answer, so we need to traverse from right to left\\n        \\n        for(int i = len-1; i >= 0; i--)\\n        {\\n            // calculate hash value for current character\\n            hash = (hash * power + (s[i] - \\'a\\' + 1)) % modulo;\\n            \\n            // i+k < len means we are outside of the window of size k\\n            // so we need to remove the i+k th character\\n            if(i+k < len)\\n            {\\n                hash = (hash - (s[i+k] - \\'a\\' + 1) * prime % modulo + modulo) % modulo;\\n            }\\n            \\n            // else, we are inside current window, so calculate prime of current window\\n            else{\\n                prime = (prime * power) % modulo;\\n            }\\n            \\n            // at any index, we reach same hashvalue, then mark the current index\\n            if(hash == hashValue)\\n                startIdx = i;\\n        }\\n        \\n        return s.substr(startIdx, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733549,
                "title": "c-solution-hash-table-approach-faster-one-traversal-only",
                "content": "class Solution {\\npublic:\\n\\n    unordered_map<char, int> x;\\n\\t\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n     char y=\\'a\\';\\n        for(int i=1; i<=26; i++) {\\n          x[y]=i;\\n          y++;\\n    }\\n         long long int res=0, prod=1, n=s.length();\\n       for(int i=n-k; i<n; i++) {\\n           res=res+x[s[i]]*(prod);\\n           if(i!=n-1)\\n           prod=(prod*power)%modulo;\\n       }\\n      int ans=n-k;\\n        \\n        for(int i=n-k-1; i>=0; i--) {\\n            long long int sub=x[s[i+k]]*(prod%modulo);\\n            res-=sub;\\n            res%=modulo;\\n            res=res*(power%modulo);\\n            res=res+x[s[i]];\\n            while(res%modulo<0)\\n                res+=modulo;\\n            if(hashValue==res%modulo)\\n                ans=i;\\n        }\\n     return s.substr(ans,k);\\n   }\\n       \\n};",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "class Solution {\\npublic:\\n\\n    unordered_map<char, int> x;\\n\\t\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n     char y=\\'a\\';\\n        for(int i=1; i<=26; i++) {\\n          x[y]=i;\\n          y++;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1733420,
                "title": "easy-rolling-hashing-solution",
                "content": "```\\n\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB Friend\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that motivates me to create a better post like this \\u270D\\uFE0F\\n```\\n\\n```\\nit\\'s pretty confusing to understand. it\\'s collision sometime so, to overcome the collision we have to recheck the hash value which we have got so far. \\n\\nBTW it\\'s a simple hashing problem though. \\n\\nHappy coding.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int inline add(int a, int b, int M){\\n        a += b;\\n        a %= M;\\n        return a;\\n    }\\n    int inline mul(int a, int b, int M){\\n        long long z = (long long)(1LL*a*b);\\n        z %= M;\\n        return z;\\n    }\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        \\n        int n = s.size();\\n        vector<int>h(n+1 , 0);\\n        vector<int>p(n+1 , 0);\\n        auto make_hash = [&]()->void {\\n            p[0] = 1;\\n            for(int i=1;i<=n;i++){\\n                h[i] = add(h[i-1] , mul(s[i-1]-\\'a\\'+1 , p[i-1] , modulo) , modulo);\\n                p[i] = mul(p[i-1] , power , modulo);\\n            }\\n        };\\n        \\n        make_hash();\\n        \\n        auto  hash_cnt = [&](int  l , int r)->int{\\n             int res = h[r];\\n            if(l)res = ((res - h[l]+modulo)%modulo);\\n            return res;\\n        }; \\n        \\n        auto  hash_cnt1 = [&](string a)->int{\\n            int p = 1;\\n            int hash_val = 0;\\n            for(int i=0;i<a.size();i++){\\n                hash_val = add(hash_val , mul(a[i]-\\'a\\'+1 , p , modulo), modulo);\\n                p = mul(p , power , modulo);\\n            }\\n            return hash_val;\\n        };\\n        for(int i=0;i<=n-k;i++){\\n            int hash = hash_cnt(i,i+k);\\n            if(mul(hashValue , p[i],modulo) == hash){\\n                string tem = s.substr(i,k);\\n                if(hash_cnt1(tem) == hashValue)return tem;\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "Rolling Hash"
                ],
                "code": "```\\n\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB Friend\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that motivates me to create a better post like this \\u270D\\uFE0F\\n```\n```\\nit\\'s pretty confusing to understand. it\\'s collision sometime so, to overcome the collision we have to recheck the hash value which we have got so far. \\n\\nBTW it\\'s a simple hashing problem though. \\n\\nHappy coding.\\n```\n```\\nclass Solution {\\npublic:\\n    int inline add(int a, int b, int M){\\n        a += b;\\n        a %= M;\\n        return a;\\n    }\\n    int inline mul(int a, int b, int M){\\n        long long z = (long long)(1LL*a*b);\\n        z %= M;\\n        return z;\\n    }\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        \\n        int n = s.size();\\n        vector<int>h(n+1 , 0);\\n        vector<int>p(n+1 , 0);\\n        auto make_hash = [&]()->void {\\n            p[0] = 1;\\n            for(int i=1;i<=n;i++){\\n                h[i] = add(h[i-1] , mul(s[i-1]-\\'a\\'+1 , p[i-1] , modulo) , modulo);\\n                p[i] = mul(p[i-1] , power , modulo);\\n            }\\n        };\\n        \\n        make_hash();\\n        \\n        auto  hash_cnt = [&](int  l , int r)->int{\\n             int res = h[r];\\n            if(l)res = ((res - h[l]+modulo)%modulo);\\n            return res;\\n        }; \\n        \\n        auto  hash_cnt1 = [&](string a)->int{\\n            int p = 1;\\n            int hash_val = 0;\\n            for(int i=0;i<a.size();i++){\\n                hash_val = add(hash_val , mul(a[i]-\\'a\\'+1 , p , modulo), modulo);\\n                p = mul(p , power , modulo);\\n            }\\n            return hash_val;\\n        };\\n        for(int i=0;i<=n-k;i++){\\n            int hash = hash_cnt(i,i+k);\\n            if(mul(hashValue , p[i],modulo) == hash){\\n                string tem = s.substr(i,k);\\n                if(hash_cnt1(tem) == hashValue)return tem;\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733235,
                "title": "hash",
                "content": "//Upvote this Solution\\n\\nTaking long long because when we multiply 10^9 * 10^9 we get 10^18\\n\\nclass Solution {\\npublic:\\n\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n       long long hash =0;\\n        int n = s.size();\\n        int ind = n;\\n        long long pr = 1;\\n        for(int i =n-1; i>=0; i--){\\n            hash = ((hash*power)%modulo + (s[i]-\\'a\\'+1))%modulo;\\n            \\n            if(i+k>=n)\\n                pr = (pr*power)%modulo;\\n            else {\\n                hash = (hash - ((s[i+k]-\\'a\\'+1)*pr)%modulo +modulo)%modulo;\\n            }\\n            \\n            if(hash==hashValue)\\n                ind = i;\\n        }\\n        return s.substr(ind,k);\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n       long long hash =0;\\n        int n = s.size();\\n        int ind = n;\\n        long long pr = 1;\\n        for(int i =n-1; i>=0; i--){\\n            hash = ((hash*power)%modulo + (s[i]-\\'a\\'+1))%modulo;\\n            \\n            if(i+k>=n)\\n                pr = (pr*power)%modulo;\\n            else {\\n                hash = (hash - ((s[i+k]-\\'a\\'+1)*pr)%modulo +modulo)%modulo;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1732871,
                "title": "c-o-n-solution",
                "content": "```\\npublic string SubStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        // Store numbers to subtract for later when we start sliding the window backwards\\n        long[] sub = new long[s.Length];\\n        long powval = 1;\\n        for(int i = 1; i <= k - 1; i++){\\n            powval = ((powval % modulo) * (power % modulo)) % modulo;\\n        }\\n        for(int i = 0; i < sub.Length; i++){\\n            sub[i] = (((s[i] - \\'a\\' + 1) % modulo) * (powval % modulo)) % modulo;\\n        }\\n        \\n        // First get the last substring\\n        string output = s;\\n        string curr = s.Substring(s.Length - k, k);\\n        long sum = 0;\\n        for(int i = k - 1; i >= 0; i--){\\n            long temp1 = ((power % modulo) * (sum % modulo)) % modulo;\\n            sum = (((curr[i] - \\'a\\' + 1) % modulo) + (temp1 % modulo)) % modulo;\\n        }\\n        if(sum == hashValue){\\n            output = curr;\\n        }\\n        \\n        // Then check the rest of the substrings by traversing s backwards\\n        for(int i = s.Length - k - 1; i >= 0; i--){\\n            sum = sum - sub[i + k];\\n            if(sum < 0){\\n                sum = sum + modulo;\\n            }\\n            long temp1 = ((power % modulo) * (sum % modulo)) % modulo;\\n            sum = (((s[i] - \\'a\\' + 1) % modulo) + (temp1 % modulo)) % modulo;\\n            if(sum == hashValue){\\n                output = s.Substring(i, k);\\n            }\\n        }\\n        \\n        return output;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic string SubStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        // Store numbers to subtract for later when we start sliding the window backwards\\n        long[] sub = new long[s.Length];\\n        long powval = 1;\\n        for(int i = 1; i <= k - 1; i++){\\n            powval = ((powval % modulo) * (power % modulo)) % modulo;\\n        }\\n        for(int i = 0; i < sub.Length; i++){\\n            sub[i] = (((s[i] - \\'a\\' + 1) % modulo) * (powval % modulo)) % modulo;\\n        }\\n        \\n        // First get the last substring\\n        string output = s;\\n        string curr = s.Substring(s.Length - k, k);\\n        long sum = 0;\\n        for(int i = k - 1; i >= 0; i--){\\n            long temp1 = ((power % modulo) * (sum % modulo)) % modulo;\\n            sum = (((curr[i] - \\'a\\' + 1) % modulo) + (temp1 % modulo)) % modulo;\\n        }\\n        if(sum == hashValue){\\n            output = curr;\\n        }\\n        \\n        // Then check the rest of the substrings by traversing s backwards\\n        for(int i = s.Length - k - 1; i >= 0; i--){\\n            sum = sum - sub[i + k];\\n            if(sum < 0){\\n                sum = sum + modulo;\\n            }\\n            long temp1 = ((power % modulo) * (sum % modulo)) % modulo;\\n            sum = (((s[i] - \\'a\\' + 1) % modulo) + (temp1 % modulo)) % modulo;\\n            if(sum == hashValue){\\n                output = s.Substring(i, k);\\n            }\\n        }\\n        \\n        return output;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1732870,
                "title": "rabin-karp-from-right-to-left-c-solution",
                "content": "\\n    string subStrHash(string s, int power, int m, int k, int hv) {\\n        \\n         int n=s.size();\\n            \\n            int res=n-k;\\n            long long sum=0;\\n            long long p=1;\\n           \\n            for(int i=0;i<k;i++)\\n            {\\n                sum +=(s[n-k+i]-\\'a\\'+1)*(p%m);\\n                    if(i!=k-1)\\n                    {\\n                            p=(p*power)%m;\\n                    }\\n            }\\n           \\n           for(int i=n-1;i>=k;i-- )\\n           {\\n                   sum-=(s[i]-\\'a\\'+1)*(p%m);\\n                   sum=sum%m;\\n                   sum=sum*(power%m);\\n                   sum=sum%m;\\n                   sum+=(s[i-k]-\\'a\\' +1);\\n                   while(sum<0)\\n                   {\\n                           sum+=m;\\n                   }\\n                   if(sum%m==hv)\\n                   {\\n                           res=i-k;\\n                   }\\n                   \\n           }\\n            return s.substr(res,k);\\n            \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n    string subStrHash(string s, int power, int m, int k, int hv) {\\n        \\n         int n=s.size();\\n            \\n            int res=n-k;\\n            long long sum=0;\\n            long long p=1;\\n           \\n            for(int i=0;i<k;i++)\\n            {\\n                sum +=(s[n-k+i]-\\'a\\'+1)*(p%m);\\n                    if(i!=k-1)\\n                    {\\n                            p=(p*power)%m;\\n                    }\\n            }\\n           \\n           for(int i=n-1;i>=k;i-- )\\n           {\\n                   sum-=(s[i]-\\'a\\'+1)*(p%m);\\n                   sum=sum%m;\\n                   sum=sum*(power%m);\\n                   sum=sum%m;\\n                   sum+=(s[i-k]-\\'a\\' +1);\\n                   while(sum<0)\\n                   {\\n                           sum+=m;\\n                   }\\n                   if(sum%m==hv)\\n                   {\\n                           res=i-k;\\n                   }\\n                   \\n           }\\n            return s.substr(res,k);\\n            \\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1732828,
                "title": "java-c-go-python3-rolling-hash-solution",
                "content": "Go\\n```\\nfunc getHash(hash []int64, pow[] int64, left int, right int, mod int64) int64 {\\n    if left == 0 {\\n        return hash[right]\\n    }\\n    res := (hash[right] - ((hash[left - 1] * pow[right - left + 1])) % mod)\\n    res += mod\\n    return res % mod\\n}\\n\\nfunc subStrHash(s string, power int, modulo int, k int, hashValue int) string {\\n    base := int64(power)\\n    mod := int64(modulo)\\n    \\n    n := len(s)\\n    pow := make([]int64, n + 1)\\n    hash := make([]int64, n)  \\n   \\n    pow[0] = 1\\n    for i := 1; i < len(pow); i++ {\\n        pow[i] = pow[i - 1] * base\\n        pow[i] %= mod\\n    }\\n    \\n    h := int64(0)\\n    for i := 0; i < n; i++ {\\n        h = h * base + (int64)(s[n - i - 1] - \\'a\\' + 1)\\n        h %= mod\\n        hash[i] = h\\n    }\\n    \\n    index := -1\\n    for i := 0; i < n; i++ {\\n        if i + 1 < k {\\n            continue\\n        }\\n        subHash := getHash(hash, pow, i - k + 1, i, mod)\\n        if subHash == int64(hashValue) {\\n            index = n - i - 1\\n        }\\n    }\\n    \\n    return s[index : index + k]\\n}\\n```\\n\\nJava \\n```\\nclass Solution {\\n    public String subStrHash(String s, int base, int mod, int k, int hashValue) {\\n        int n = s.length();\\n        String rev = reverse(s);//reverse our string\\n        \\n        long pow[] = new long[n + 1];\\n        long hash[] = new long[n];\\n        pow[0] = 1;\\n        for(int i = 1; i < pow.length; i++) {\\n            pow[i] = pow[i - 1] * base;\\n            pow[i] %= mod;\\n        }\\n\\n        long h = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            h = h * base + (rev.charAt(i) - \\'a\\' + 1);\\n            h %= mod;\\n            hash[i] = h;\\n        }\\n        \\n        int index = -1;\\n        for(int i = 0; i < n; i++) {\\n            if(i + 1 < k) continue;\\n            long subHash = gethash(hash, pow, i - k + 1, i, mod);\\n            if(subHash == hashValue) {\\n                index = n - i - 1;\\n            }\\n        }\\n        return s.substring(index, index + k);\\n    }\\n    \\n    public String reverse(String s) {\\n        StringBuilder str = new StringBuilder(s);\\n        return str.reverse().toString();\\n    }\\n    \\n    public long gethash(long hash[],long pow[], int left,int right, int mod) {\\n        if(left == 0) {\\n            return hash[right];\\n        }\\n        long res = (hash[right] - (hash[left - 1] * pow[right - left + 1] % mod) + mod) % mod;\\n        if(res < 0)res += mod;\\n        return res % mod;\\n    } \\n}\\n```\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int base, int mod, int k, int hashValue) {\\n        string rev = reverse(s);\\n        int n = s.size();\\n        vector<long long> pow(n);\\n        vector<long long> hash(n);\\n        \\n        pow[0] = 1;\\n        for(int i = 1; i < n; i++) {\\n            pow[i] = pow[i - 1] * base;\\n            pow[i] %= mod;\\n        }\\n        \\n        long long h = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            h = h * base + (rev[i] - \\'a\\' + 1);\\n            h %= mod;\\n            hash[i] = h;\\n        }\\n        \\n        int index = -1;\\n        for(int i = 0; i < n; i++) {\\n            if(i + 1 < k) continue;\\n            long long subHash = gethash(hash, pow, i - k + 1, i, mod);\\n            if(subHash == hashValue) {\\n                index = n - i - 1;\\n            }\\n        }\\n        return s.substr(index, k);\\n    }\\n    \\n    string reverse(string& s) {\\n        string rev = \"\";\\n        for(int i = s.size() - 1; i >= 0; i--) {\\n            rev += s[i];\\n        }\\n        return rev;\\n    }\\n    \\n    long long gethash(vector<long long>& hash,vector<long long>& pow, int left,int right, int mod) {\\n        if(left == 0) {\\n            return hash[right];\\n        }\\n        long long res = (hash[right] - (hash[left - 1] * pow[right - left + 1]% mod) + mod) % mod;\\n        if(res < 0)res += mod;\\n        return res % mod;\\n    }\\n};\\n```\\n\\nPython\\n```\\nclass Solution:\\n    def subStrHash(self, s: str, base: int, mod: int, k: int, hashValue: int) -> str:\\n        n = len(s)\\n        p = [0] * n\\n        ha = [0] * n\\n        \\n        p[0] = 1\\n        for i in range(1, n):\\n            p[i] = p[i - 1] * base\\n            p[i] %= mod\\n        \\n        h = 0\\n        for i in range(n):\\n            h = h * base + int(ord(s[n - i - 1])) - 97 + 1\\n            h %= mod\\n            ha[i] = h\\n        \\n        index = -1\\n        for i in range(n):\\n            if i + 1 < k:\\n                continue\\n            subHash = self.gethash(ha, p, i - k + 1, i, mod)\\n            if subHash == hashValue:\\n                index = n - i - 1\\n        return s[index : index + k]\\n    \\n    def gethash(self, ha, p, l, r, mod):\\n        if l == 0:\\n            return ha[r]\\n        res = ha[r] - (ha[l - 1] * p[r - l + 1]) % mod\\n        res += mod\\n        return res % mod\\n```",
                "solutionTags": [],
                "code": "```\\nfunc getHash(hash []int64, pow[] int64, left int, right int, mod int64) int64 {\\n    if left == 0 {\\n        return hash[right]\\n    }\\n    res := (hash[right] - ((hash[left - 1] * pow[right - left + 1])) % mod)\\n    res += mod\\n    return res % mod\\n}\\n\\nfunc subStrHash(s string, power int, modulo int, k int, hashValue int) string {\\n    base := int64(power)\\n    mod := int64(modulo)\\n    \\n    n := len(s)\\n    pow := make([]int64, n + 1)\\n    hash := make([]int64, n)  \\n   \\n    pow[0] = 1\\n    for i := 1; i < len(pow); i++ {\\n        pow[i] = pow[i - 1] * base\\n        pow[i] %= mod\\n    }\\n    \\n    h := int64(0)\\n    for i := 0; i < n; i++ {\\n        h = h * base + (int64)(s[n - i - 1] - \\'a\\' + 1)\\n        h %= mod\\n        hash[i] = h\\n    }\\n    \\n    index := -1\\n    for i := 0; i < n; i++ {\\n        if i + 1 < k {\\n            continue\\n        }\\n        subHash := getHash(hash, pow, i - k + 1, i, mod)\\n        if subHash == int64(hashValue) {\\n            index = n - i - 1\\n        }\\n    }\\n    \\n    return s[index : index + k]\\n}\\n```\n```\\nclass Solution {\\n    public String subStrHash(String s, int base, int mod, int k, int hashValue) {\\n        int n = s.length();\\n        String rev = reverse(s);//reverse our string\\n        \\n        long pow[] = new long[n + 1];\\n        long hash[] = new long[n];\\n        pow[0] = 1;\\n        for(int i = 1; i < pow.length; i++) {\\n            pow[i] = pow[i - 1] * base;\\n            pow[i] %= mod;\\n        }\\n\\n        long h = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            h = h * base + (rev.charAt(i) - \\'a\\' + 1);\\n            h %= mod;\\n            hash[i] = h;\\n        }\\n        \\n        int index = -1;\\n        for(int i = 0; i < n; i++) {\\n            if(i + 1 < k) continue;\\n            long subHash = gethash(hash, pow, i - k + 1, i, mod);\\n            if(subHash == hashValue) {\\n                index = n - i - 1;\\n            }\\n        }\\n        return s.substring(index, index + k);\\n    }\\n    \\n    public String reverse(String s) {\\n        StringBuilder str = new StringBuilder(s);\\n        return str.reverse().toString();\\n    }\\n    \\n    public long gethash(long hash[],long pow[], int left,int right, int mod) {\\n        if(left == 0) {\\n            return hash[right];\\n        }\\n        long res = (hash[right] - (hash[left - 1] * pow[right - left + 1] % mod) + mod) % mod;\\n        if(res < 0)res += mod;\\n        return res % mod;\\n    } \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int base, int mod, int k, int hashValue) {\\n        string rev = reverse(s);\\n        int n = s.size();\\n        vector<long long> pow(n);\\n        vector<long long> hash(n);\\n        \\n        pow[0] = 1;\\n        for(int i = 1; i < n; i++) {\\n            pow[i] = pow[i - 1] * base;\\n            pow[i] %= mod;\\n        }\\n        \\n        long long h = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            h = h * base + (rev[i] - \\'a\\' + 1);\\n            h %= mod;\\n            hash[i] = h;\\n        }\\n        \\n        int index = -1;\\n        for(int i = 0; i < n; i++) {\\n            if(i + 1 < k) continue;\\n            long long subHash = gethash(hash, pow, i - k + 1, i, mod);\\n            if(subHash == hashValue) {\\n                index = n - i - 1;\\n            }\\n        }\\n        return s.substr(index, k);\\n    }\\n    \\n    string reverse(string& s) {\\n        string rev = \"\";\\n        for(int i = s.size() - 1; i >= 0; i--) {\\n            rev += s[i];\\n        }\\n        return rev;\\n    }\\n    \\n    long long gethash(vector<long long>& hash,vector<long long>& pow, int left,int right, int mod) {\\n        if(left == 0) {\\n            return hash[right];\\n        }\\n        long long res = (hash[right] - (hash[left - 1] * pow[right - left + 1]% mod) + mod) % mod;\\n        if(res < 0)res += mod;\\n        return res % mod;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def subStrHash(self, s: str, base: int, mod: int, k: int, hashValue: int) -> str:\\n        n = len(s)\\n        p = [0] * n\\n        ha = [0] * n\\n        \\n        p[0] = 1\\n        for i in range(1, n):\\n            p[i] = p[i - 1] * base\\n            p[i] %= mod\\n        \\n        h = 0\\n        for i in range(n):\\n            h = h * base + int(ord(s[n - i - 1])) - 97 + 1\\n            h %= mod\\n            ha[i] = h\\n        \\n        index = -1\\n        for i in range(n):\\n            if i + 1 < k:\\n                continue\\n            subHash = self.gethash(ha, p, i - k + 1, i, mod)\\n            if subHash == hashValue:\\n                index = n - i - 1\\n        return s[index : index + k]\\n    \\n    def gethash(self, ha, p, l, r, mod):\\n        if l == 0:\\n            return ha[r]\\n        res = ha[r] - (ha[l - 1] * p[r - l + 1]) % mod\\n        res += mod\\n        return res % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732756,
                "title": "java-please-could-any-one-explain-why-this-solution-is-not-working",
                "content": "Hi, my solution is not working with this test case:\\n\\n```\\n@Test\\nvoid should_return_correctly_for_test_case4() {\\n\\tassertThat(solution.subStrHash(\"xqgfatvtlwnnkxipmipcpqwbxihxblaplpfckvxtihonijhtezdnkjmmk\", 22, 51, 41, 9))\\n\\t\\t\\t.isEqualTo(\"xqgfatvtlwnnkxipmipcpqwbxihxblaplpfckvxti\");\\n}\\n```\\n\\nand this is my solution:\\n\\n```\\npublic String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n\\tint[] pows = new int[k];\\n\\tfor (int i = 0; i < k; i++){\\n\\t\\tpows[i] = (int) (Math.pow(power, i) % modulo);\\n\\t}\\n\\n\\tfor (int i = 0, length = s.length() - k + 1; i < length; i++) {\\n\\t\\tString substring = s.substring(i, i + k);\\n\\n\\t\\tint subStringHash = 0;\\n\\t\\tfor (int j = 0; j < k; j++) {\\n\\t\\t\\tsubStringHash += (substring.charAt(j) - \\'a\\' + 1) * pows[j] % modulo;\\n\\t\\t}\\n\\n\\t\\tif(subStringHash % modulo == hashValue){\\n\\t\\t\\treturn substring;\\n\\t\\t}\\n\\t}\\n\\treturn null;\\n}\\n```\\n\\nI can not undestand why it is no working with that case, thanks in advance.",
                "solutionTags": [],
                "code": "```\\n@Test\\nvoid should_return_correctly_for_test_case4() {\\n\\tassertThat(solution.subStrHash(\"xqgfatvtlwnnkxipmipcpqwbxihxblaplpfckvxtihonijhtezdnkjmmk\", 22, 51, 41, 9))\\n\\t\\t\\t.isEqualTo(\"xqgfatvtlwnnkxipmipcpqwbxihxblaplpfckvxti\");\\n}\\n```\n```\\npublic String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n\\tint[] pows = new int[k];\\n\\tfor (int i = 0; i < k; i++){\\n\\t\\tpows[i] = (int) (Math.pow(power, i) % modulo);\\n\\t}\\n\\n\\tfor (int i = 0, length = s.length() - k + 1; i < length; i++) {\\n\\t\\tString substring = s.substring(i, i + k);\\n\\n\\t\\tint subStringHash = 0;\\n\\t\\tfor (int j = 0; j < k; j++) {\\n\\t\\t\\tsubStringHash += (substring.charAt(j) - \\'a\\' + 1) * pows[j] % modulo;\\n\\t\\t}\\n\\n\\t\\tif(subStringHash % modulo == hashValue){\\n\\t\\t\\treturn substring;\\n\\t\\t}\\n\\t}\\n\\treturn null;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1732738,
                "title": "can-someone-help-me-figure-out-why-this-javascript-code-fails-but-this-python-code-works",
                "content": "This problem wrecked me in the contest and I still don\\'t know what went wrong. Does anyone have a working javascript code?\\n\\n**Python**\\n```python\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        \\n        mod = modulo\\n        def val(c):\\n            return ord(c) - 96\\n        \\n        def fmod(n):\\n            return (n + mod) % mod\\n        \\n        cache = {}\\n        def pow(n):\\n            if n == 0:\\n                return 1\\n            if n in cache:\\n                return cache[n]\\n            res = (power * pow(n - 1)) % mod\\n            cache[n] = res\\n            return res\\n        \\n        hash = 0\\n        p = 0\\n\\n        for i in range(len(s) - k, len(s)):\\n            hash = hash + val(s[i]) * pow(p)\\n            p += 1\\n            hash = hash % mod;\\n            # print(hash)\\n            \\n        res = 0\\n        \\n        if hash == hashValue:\\n            res = len(s) - k\\n            \\n            \\n        for i in range(len(s) - k - 1, -1, -1):\\n            sub = val(s[i + k]) * pow(k - 1)\\n            hash -= fmod(sub)\\n            hash = fmod(hash) * power\\n            hash += val(s[i])\\n            hash = fmod(hash)\\n            if (hash == hashValue):\\n                res = i\\n                \\n        return s[res:res + k]\\n```\\n\\n**Javascript**\\n```js\\nvar subStrHash = function(s, power, modulo, k, hashValue) {\\n\\n    power = BigInt(power)\\n    modulo = BigInt(modulo)\\n    hashValue = BigInt(hashValue)\\n    let mod = modulo\\n\\n    function val(c) {\\n        return BigInt(c.charCodeAt(0) - 96);\\n    }\\n    \\n    function fmod(n) {\\n        return (n + mod) % mod\\n    } \\n    \\n    const cache = {}\\n    function pow(n) {\\n        if (n === 0) return BigInt(1);\\n        if (n in cache) return cache[n]\\n        const res = (power * pow(n - 1)) % mod\\n        cache[n] = res\\n        return res;\\n    }\\n    \\n    let hash = BigInt(0)\\n    let p = 0\\n    for (let i = s.length - k; i < s.length; i++) {\\n        hash = hash + val(s[i]) * pow(p)\\n        p++\\n        hash %= mod;\\n    }\\n\\n    let res = 0\\n    \\n    if (hash === hashValue) {\\n        res = s.length - k;\\n    }\\n    \\n    for (let i = s.length - k - 1; i >= 0; i--) {\\n        const sub = val(s[i + k]) * pow(k - 1)\\n        hash -= fmod(sub);\\n        hash = hash * power\\n        hash += val(s[i])\\n        hash %= mod;\\n\\n        if (hash === hashValue) {\\n            res = i\\n        }\\n    }\\n    return s.substring(res, res + k)\\n};\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        \\n        mod = modulo\\n        def val(c):\\n            return ord(c) - 96\\n        \\n        def fmod(n):\\n            return (n + mod) % mod\\n        \\n        cache = {}\\n        def pow(n):\\n            if n == 0:\\n                return 1\\n            if n in cache:\\n                return cache[n]\\n            res = (power * pow(n - 1)) % mod\\n            cache[n] = res\\n            return res\\n        \\n        hash = 0\\n        p = 0\\n\\n        for i in range(len(s) - k, len(s)):\\n            hash = hash + val(s[i]) * pow(p)\\n            p += 1\\n            hash = hash % mod;\\n            # print(hash)\\n            \\n        res = 0\\n        \\n        if hash == hashValue:\\n            res = len(s) - k\\n            \\n            \\n        for i in range(len(s) - k - 1, -1, -1):\\n            sub = val(s[i + k]) * pow(k - 1)\\n            hash -= fmod(sub)\\n            hash = fmod(hash) * power\\n            hash += val(s[i])\\n            hash = fmod(hash)\\n            if (hash == hashValue):\\n                res = i\\n                \\n        return s[res:res + k]\\n```\n```js\\nvar subStrHash = function(s, power, modulo, k, hashValue) {\\n\\n    power = BigInt(power)\\n    modulo = BigInt(modulo)\\n    hashValue = BigInt(hashValue)\\n    let mod = modulo\\n\\n    function val(c) {\\n        return BigInt(c.charCodeAt(0) - 96);\\n    }\\n    \\n    function fmod(n) {\\n        return (n + mod) % mod\\n    } \\n    \\n    const cache = {}\\n    function pow(n) {\\n        if (n === 0) return BigInt(1);\\n        if (n in cache) return cache[n]\\n        const res = (power * pow(n - 1)) % mod\\n        cache[n] = res\\n        return res;\\n    }\\n    \\n    let hash = BigInt(0)\\n    let p = 0\\n    for (let i = s.length - k; i < s.length; i++) {\\n        hash = hash + val(s[i]) * pow(p)\\n        p++\\n        hash %= mod;\\n    }\\n\\n    let res = 0\\n    \\n    if (hash === hashValue) {\\n        res = s.length - k;\\n    }\\n    \\n    for (let i = s.length - k - 1; i >= 0; i--) {\\n        const sub = val(s[i + k]) * pow(k - 1)\\n        hash -= fmod(sub);\\n        hash = hash * power\\n        hash += val(s[i])\\n        hash %= mod;\\n\\n        if (hash === hashValue) {\\n            res = i\\n        }\\n    }\\n    return s.substring(res, res + k)\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732641,
                "title": "java-o-n-rolling-hash",
                "content": "\\n```\\nclass Solution {\\n    String s;\\n    int power;\\n    int modulo;\\n    int k;\\n    int hashValue;\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n        this.s = s;\\n        this.power = power;\\n        this.modulo = modulo;\\n        this.k = k;\\n        this.hashValue = hashValue;\\n        int n = s.length();\\n            \\n        long rollhash = 0, pk = 1;\\n        int rslt = -1;\\n        \\n        for(int i = n-1; i >= 0; i--){\\n            char chq = s.charAt(i);\\n            rollhash = (rollhash*power + (chq - \\'a\\' + 1)) % modulo;\\n            \\n            if (i + k >= n){\\n                pk = (pk * power) % modulo;\\n            } else {\\n                char rollChq = s.charAt(i+k);\\n                rollhash = (rollhash - (rollChq - \\'a\\' + 1)*pk%modulo + modulo) % modulo;\\n            }\\n            \\n            if (rollhash == hashValue)\\n                rslt = i;\\n        }\\n                            \\n        return s.substring(rslt, rslt+k);    \\n            \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    String s;\\n    int power;\\n    int modulo;\\n    int k;\\n    int hashValue;\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n        this.s = s;\\n        this.power = power;\\n        this.modulo = modulo;\\n        this.k = k;\\n        this.hashValue = hashValue;\\n        int n = s.length();\\n            \\n        long rollhash = 0, pk = 1;\\n        int rslt = -1;\\n        \\n        for(int i = n-1; i >= 0; i--){\\n            char chq = s.charAt(i);\\n            rollhash = (rollhash*power + (chq - \\'a\\' + 1)) % modulo;\\n            \\n            if (i + k >= n){\\n                pk = (pk * power) % modulo;\\n            } else {\\n                char rollChq = s.charAt(i+k);\\n                rollhash = (rollhash - (rollChq - \\'a\\' + 1)*pk%modulo + modulo) % modulo;\\n            }\\n            \\n            if (rollhash == hashValue)\\n                rslt = i;\\n        }\\n                            \\n        return s.substring(rslt, rslt+k);    \\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732548,
                "title": "what-am-i-doing-wrong",
                "content": "Here is my solution using the revered rabin karp algorithm. However I am getting Time Limit Exceeding error. Where can I make improvement?\\n\\n```class Solution(object):\\n    def computeHash(self, s, p, m):\\n        res = 0\\n        for ind, ele in enumerate(s):\\n            pos = ord(ele)-96\\n            res += ((pos* (p**ind))%m)\\n            res = res % m\\n        return res\\n    def subStrHash(self, s, power, modulo, k, hashValue):\\n        \"\"\"\\n        :type s: str\\n        :type power: int\\n        :type modulo: int\\n        :type k: int\\n        :type hashValue: int\\n        :rtype: str\\n        \"\"\"\\n        res = \"\"\\n        cmp = 0\\n        for ind in range(len(s)-k, -1, -1):\\n            tmp = s[ind:ind+k]\\n\\n            if ind == len(s)-k:\\n                cmp = self.computeHash(tmp, power, modulo)\\n            else:\\n                cmp -= (((ord(s[ind+k]) - 96) * (power ** (k-1))) % modulo)\\n                cmp = cmp % modulo\\n                cmp *= power\\n                cmp = cmp % modulo\\n                cmp += (ord(s[ind]) - 96)\\n                cmp = cmp % modulo\\n            if  cmp == hashValue:\\n                res = tmp\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "Here is my solution using the revered rabin karp algorithm. However I am getting Time Limit Exceeding error. Where can I make improvement?\\n\\n```class Solution(object):\\n    def computeHash(self, s, p, m):\\n        res = 0\\n        for ind, ele in enumerate(s):\\n            pos = ord(ele)-96\\n            res += ((pos* (p**ind))%m)\\n            res = res % m\\n        return res\\n    def subStrHash(self, s, power, modulo, k, hashValue):\\n        \"\"\"\\n        :type s: str\\n        :type power: int\\n        :type modulo: int\\n        :type k: int\\n        :type hashValue: int\\n        :rtype: str\\n        \"\"\"\\n        res = \"\"\\n        cmp = 0\\n        for ind in range(len(s)-k, -1, -1):\\n            tmp = s[ind:ind+k]\\n\\n            if ind == len(s)-k:\\n                cmp = self.computeHash(tmp, power, modulo)\\n            else:\\n                cmp -= (((ord(s[ind+k]) - 96) * (power ** (k-1))) % modulo)\\n                cmp = cmp % modulo\\n                cmp *= power\\n                cmp = cmp % modulo\\n                cmp += (ord(s[ind]) - 96)\\n                cmp = cmp % modulo\\n            if  cmp == hashValue:\\n                res = tmp\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1732503,
                "title": "intuitive-o-n-sliding-window-no-knowledge-of-rolling-hash-required",
                "content": "I was able to come up with this intuitive approach based on the info given in the problem. Coincidentally, this is happens to be an implementation of the rolling hash algorithm but you don\\'t need to know what the rolling hash is to understand it. What is needed is a good understanding of modulo arithmetic **especially with divisions**. I initialy made the mistake of trying to divide and apply modulo but that did not work which I found out that it is not stated that  `p` and `mod`  are **[coprime](https://en.wikipedia.org/wiki/Modulo_operation#Properties_(identities))**.\\n\\nNow to the appoach:\\n**Trying to move from left to right**\\nFor every `i>k`, hash at `i` is `h(i) = ((h(i-1) - val(s[i-k])) / p) + (val(s[i]) * p^(k-1)) % mod`\\n\\nThe formular follows from the fact that the current hash, `h(i)` can be calcuated by subtracting the value of the letter at the first index, `val(s[i-k])` that contributed to the previous hash from the previous hash. i.e. `h(i-1)-val(s[i-k])`. This value is then divided by `p` in order to **reduce** the power multplier of each value by 1 so that the first additive in `h(i-1)` will have a power of `p^0` and last additive in will also have a power of `p^(k-2)`\\n\\nThe reason this approach fails is because of the division by `p` in the modulo.\\n\\n**Moving from right to left**\\nIn moving from right to left he will make `h(i-1)` the subject of the equation. \\nThis gives us: `h(i-1) = ((h(i) - (val(s[i]) * p^(k-1))) * p) + val(s[i-k])) % mod`\\n\\nApplying modulo works here because this time we are multiplying by `p` and there are no retrictions for multiplying in modulo.\\n\\n**The Code**\\nI used an array to store the powers so I don\\'t have to calcuate each time. Also a condition to handle calculating the hash before we reach a string length of `k`\\n\\n```\\nvar subStrHash = function(s, pow, m, k, hashValue) {\\n    let n = s.length\\n    let hash = 0n\\n    let powers = [1n]\\n    let j=0\\n    let p = BigInt(pow)\\n    let mod = BigInt(m)\\n    let res =  BigInt(hashValue)\\n    \\n    for(let i=1; i<k; i++){\\n        powers.push(powers[i-1] * p % mod)\\n    }\\n    \\n    for(i=n-1; i>=0; i--){\\n        let curr = BigInt(s[i].charCodeAt(0)-96)\\n        if(n-i <= k){\\n            hash = (hash + (curr * powers[k-(n-i)])) % mod\\n        } else {\\n            let prev = (BigInt(s[i+k].charCodeAt(0)-96) * powers[k-1]) % mod\\n            hash = (((mod + hash - prev) * p) + curr) % mod\\n        }\\n        if(hash == res) j = i\\n    }\\n    \\n    return s.substring(j,j+k)\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nvar subStrHash = function(s, pow, m, k, hashValue) {\\n    let n = s.length\\n    let hash = 0n\\n    let powers = [1n]\\n    let j=0\\n    let p = BigInt(pow)\\n    let mod = BigInt(m)\\n    let res =  BigInt(hashValue)\\n    \\n    for(let i=1; i<k; i++){\\n        powers.push(powers[i-1] * p % mod)\\n    }\\n    \\n    for(i=n-1; i>=0; i--){\\n        let curr = BigInt(s[i].charCodeAt(0)-96)\\n        if(n-i <= k){\\n            hash = (hash + (curr * powers[k-(n-i)])) % mod\\n        } else {\\n            let prev = (BigInt(s[i+k].charCodeAt(0)-96) * powers[k-1]) % mod\\n            hash = (((mod + hash - prev) * p) + curr) % mod\\n        }\\n        if(hash == res) j = i\\n    }\\n    \\n    return s.substring(j,j+k)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1732468,
                "title": "java-dp-solution-tle-26-tc-passed",
                "content": "Disclaimer : Below solution only passes 26 TCs but I am just happy that I was able to come up with this solution in the first place. \\nAlso, I realised that with constraints as huge as this Q, we cannot apply DP.\\n\\n```\\nimport java.math.*;\\n\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap();\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n        int[][] dp = new int[s.length()][s.length()];\\n\\n        \\n        //diagonal\\n        for(int i=0;i<dp.length;i++){\\n            dp[i][i] = getHashValue(s.charAt(i), power, modulo, 0);\\n            if(dp[i][i]==hashValue && k==1){\\n                    return s.substring(i,i+1);\\n            }\\n            if(dp.length-i<k) break;\\n            \\n        }\\n        \\n        \\n        for(int i=0;i<dp.length;i++){\\n            for(int j=i+1;j<dp[0].length;j++){\\n                if(j-i+1>k) break;\\n                int length = j-i+1;\\n                char c = s.charAt(j);\\n                dp[i][j]=(dp[i][j-1]%modulo+getHashValue(c, power, modulo, j-i))%modulo;\\n                if(dp[i][j]==hashValue && length==k){\\n                    return s.substring(i,j+1);\\n                }\\n            }\\n        }\\n        \\n        return s.substring(0,k);\\n    }\\n    \\n    public int getHashValue(char c, int power, int mod, int length){\\n        int a = ((c-\\'a\\')+1)%mod;\\n        return (a*getPower(power, length, mod))%mod;\\n    }\\n    \\n    public int getPower(int a, int b, int mod){\\n        if(map.containsKey(b))\\n            return map.get(b);\\n        if(b==0) return 1;\\n        BigInteger b4 = new BigInteger(String.valueOf(mod));\\n        BigInteger big = new BigInteger(String.valueOf(a));\\n        BigInteger b2 = big.pow(b);\\n        BigInteger b3 = b2.mod(b4);\\n        map.put(b, b3.intValue());\\n        return b3.intValue();\\n    }\\n\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nimport java.math.*;\\n\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap();\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n        int[][] dp = new int[s.length()][s.length()];\\n\\n        \\n        //diagonal\\n        for(int i=0;i<dp.length;i++){\\n            dp[i][i] = getHashValue(s.charAt(i), power, modulo, 0);\\n            if(dp[i][i]==hashValue && k==1){\\n                    return s.substring(i,i+1);\\n            }\\n            if(dp.length-i<k) break;\\n            \\n        }\\n        \\n        \\n        for(int i=0;i<dp.length;i++){\\n            for(int j=i+1;j<dp[0].length;j++){\\n                if(j-i+1>k) break;\\n                int length = j-i+1;\\n                char c = s.charAt(j);\\n                dp[i][j]=(dp[i][j-1]%modulo+getHashValue(c, power, modulo, j-i))%modulo;\\n                if(dp[i][j]==hashValue && length==k){\\n                    return s.substring(i,j+1);\\n                }\\n            }\\n        }\\n        \\n        return s.substring(0,k);\\n    }\\n    \\n    public int getHashValue(char c, int power, int mod, int length){\\n        int a = ((c-\\'a\\')+1)%mod;\\n        return (a*getPower(power, length, mod))%mod;\\n    }\\n    \\n    public int getPower(int a, int b, int mod){\\n        if(map.containsKey(b))\\n            return map.get(b);\\n        if(b==0) return 1;\\n        BigInteger b4 = new BigInteger(String.valueOf(mod));\\n        BigInteger big = new BigInteger(String.valueOf(a));\\n        BigInteger b2 = big.pow(b);\\n        BigInteger b3 = b2.mod(b4);\\n        map.put(b, b3.intValue());\\n        return b3.intValue();\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732241,
                "title": "c-window-sliding-easy-understandable",
                "content": "1.modulo doesnot work with division thats why we traverse reversely. so we need to multiply power \\n\\n        \\n         long long int p(int a,int b,int m){\\n        long long int ans=1;\\n        while(b>0){\\n            if(b&1){\\n                ans=(ans*1LL*a)%m;\\n            }\\n            a=(a*1LL*a)%m;\\n            b>>=1;\\n        }\\n        return ans;\\n    }\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n\\t\\tint n=s.length();\\n        \\n        reverse(s.begin(),s.end());\\n        string ans=\"\";\\n        \\n        long long int i=0,j=0,po=k-1;\\n        long long int sum=0,y=p(power,k-1,modulo);\\n        \\n        while(j<n)\\n        {\\n            \\n            if(j-i+1<k)\\n            {\\n                \\n               long long int x=p(power,po,modulo);\\n                \\n                sum=(sum+((s[j]-\\'a\\'+1)*x)%modulo)%modulo;\\n                po--;\\n                // cout<<\"sum= \"<<sum<<endl;\\n            }\\n            else\\n            { \\n                \\n                \\n               sum=(sum+((s[j]-\\'a\\'+1)*1)%modulo)%modulo;\\n                \\n                  if(hashValue==sum)\\n                   {\\n                       \\n                       ans=s.substr(i,j-i+1);\\n                      \\n                   }\\n                \\n                   sum=(sum+modulo-((s[i]-\\'a\\'+1)*y)%modulo)%modulo;\\n                 \\n                   sum=sum*power%modulo;\\n                  i++;\\n                \\n            }\\n            j++;\\n            \\n        }\\n        \\n                \\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n\\n         \\n        \\n    }",
                "solutionTags": [],
                "code": "1.modulo doesnot work with division thats why we traverse reversely. so we need to multiply power \\n\\n        \\n         long long int p(int a,int b,int m){\\n        long long int ans=1;\\n        while(b>0){\\n            if(b&1){\\n                ans=(ans*1LL*a)%m;\\n            }\\n            a=(a*1LL*a)%m;\\n            b>>=1;\\n        }\\n        return ans;\\n    }\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n\\t\\tint n=s.length();\\n        \\n        reverse(s.begin(),s.end());\\n        string ans=\"\";\\n        \\n        long long int i=0,j=0,po=k-1;\\n        long long int sum=0,y=p(power,k-1,modulo);\\n        \\n        while(j<n)\\n        {\\n            \\n            if(j-i+1<k)\\n            {\\n                \\n               long long int x=p(power,po,modulo);\\n                \\n                sum=(sum+((s[j]-\\'a\\'+1)*x)%modulo)%modulo;\\n                po--;\\n                // cout<<\"sum= \"<<sum<<endl;\\n            }\\n            else\\n            { \\n                \\n                \\n               sum=(sum+((s[j]-\\'a\\'+1)*1)%modulo)%modulo;\\n                \\n                  if(hashValue==sum)\\n                   {\\n                       \\n                       ans=s.substr(i,j-i+1);\\n                      \\n                   }\\n                \\n                   sum=(sum+modulo-((s[i]-\\'a\\'+1)*y)%modulo)%modulo;\\n                 \\n                   sum=sum*power%modulo;\\n                  i++;\\n                \\n            }\\n            j++;\\n            \\n        }\\n        \\n                \\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n\\n         \\n        \\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1732194,
                "title": "idea-flow-that-can-work-c-solution",
                "content": "Given length k -- Okayy !! Fixed length sliding window \\nJust find the hash and every point and take modulo afterwards..\\nNot work due to constraints... Just find Modulo at each and every point using mod formulae -- \\n(a+b)%m = (a%m +b %m)%m and others....\\nBut in that case we have to divide by power on each iteration -- (Why??)\\n(a/b)%m doesn\\'t follow that pattern   ---(Euler extended GCD is required)\\nSo we can try to form the hash from right in that case it would be multiplication and hash formation \\n```\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int p, int m, int k, int hash) {\\n        int n = s.size();\\n        long long val = 0;\\n        long long  po = 1;\\n        for(int i=n-k;i<n;i++)         // very first window \\n        {\\n            val=(val+(((s[i]-\\'a\\'+1)%m)*po)%m)%m;\\n            po= (po*(p%m))%m;\\n        }\\n        po = 1;\\n        for(int i=0;i<k-1;i++)\\n            po = (po * (p%m))%m;\\n        string ans = \"\";\\n        if(val == hash)\\n            ans =  s.substr(n-k,k);\\n        for(int i=n-k-1;i>=0;i--)           // all windows in reverse\\n        {\\n            val= (val-(((s[i+k]-\\'a\\'+1)*po)%m)+m)%m;\\n            val= (val*p)%m;\\n            val= (val + ((s[i]-\\'a\\'+1))%m)%m;\\n            if(val == hash)\\n                ans =  s.substr(i,k);\\n            \\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int p, int m, int k, int hash) {\\n        int n = s.size();\\n        long long val = 0;\\n        long long  po = 1;\\n        for(int i=n-k;i<n;i++)         // very first window \\n        {\\n            val=(val+(((s[i]-\\'a\\'+1)%m)*po)%m)%m;\\n            po= (po*(p%m))%m;\\n        }\\n        po = 1;\\n        for(int i=0;i<k-1;i++)\\n            po = (po * (p%m))%m;\\n        string ans = \"\";\\n        if(val == hash)\\n            ans =  s.substr(n-k,k);\\n        for(int i=n-k-1;i>=0;i--)           // all windows in reverse\\n        {\\n            val= (val-(((s[i+k]-\\'a\\'+1)*po)%m)+m)%m;\\n            val= (val*p)%m;\\n            val= (val + ((s[i]-\\'a\\'+1))%m)%m;\\n            if(val == hash)\\n                ans =  s.substr(i,k);\\n            \\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731953,
                "title": "c-rolling-hash-easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) \\n    {\\n        reverse(s.begin(),s.end());\\n       long long int p = 1;\\n        vector<long long int>vv(k);\\n        for(int i=0;i<=k-1;i++)\\n        {\\n            vv[i] = p;\\n            p = (p*power)%modulo;     \\n        }\\n        int i = 0;\\n        int j  = 0;\\n        int len = s.length();\\n       long long int sum = 0;\\n        while(j<k)\\n        {\\n            sum += (((s[j]-\\'a\\'+1)*vv[k-1-j])%modulo);\\n            sum %= modulo;\\n            j++;\\n        }\\n        string ans = \"\";\\n        if(sum==hashValue)\\n        {\\n          ans= s.substr(i,j);\\n        }\\n        while(j<len)\\n        {\\n            sum  +=  modulo;\\n            sum  -= ((s[i]-\\'a\\'+1)*vv[k-1])%modulo;\\n            sum %= modulo;\\n            sum *= (power)%modulo;\\n            sum += ((s[j]-\\'a\\'+1))%modulo;\\n            sum %= modulo;\\n            i++;\\n            j++;\\n            if(sum==hashValue)\\n            {\\n                ans= s.substr(i,j-i);\\n            }\\n           \\n        }\\n        reverse(ans.begin(),ans.end());\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) \\n    {\\n        reverse(s.begin(),s.end());\\n       long long int p = 1;\\n        vector<long long int>vv(k);\\n        for(int i=0;i<=k-1;i++)\\n        {\\n            vv[i] = p;\\n            p = (p*power)%modulo;     \\n        }\\n        int i = 0;\\n        int j  = 0;\\n        int len = s.length();\\n       long long int sum = 0;\\n        while(j<k)\\n        {\\n            sum += (((s[j]-\\'a\\'+1)*vv[k-1-j])%modulo);\\n            sum %= modulo;\\n            j++;\\n        }\\n        string ans = \"\";\\n        if(sum==hashValue)\\n        {\\n          ans= s.substr(i,j);\\n        }\\n        while(j<len)\\n        {\\n            sum  +=  modulo;\\n            sum  -= ((s[i]-\\'a\\'+1)*vv[k-1])%modulo;\\n            sum %= modulo;\\n            sum *= (power)%modulo;\\n            sum += ((s[j]-\\'a\\'+1))%modulo;\\n            sum %= modulo;\\n            i++;\\n            j++;\\n            if(sum==hashValue)\\n            {\\n                ans= s.substr(i,j-i);\\n            }\\n           \\n        }\\n        reverse(ans.begin(),ans.end());\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731556,
                "title": "naive-solution-kotlin",
                "content": "```\\n\\nclass Solution {\\n    fun subStrHash(s: String, power: Int, modulo: Int, k: Int, hashValue: Int): String {\\n        var p : Long = 1\\n        var arr = LongArray(k){1}\\n\\t\\t// find and store power values in array separately to reuse & reduce time.\\n        for(i in 0 until k) {\\n            arr[i] = p\\n            p = (p * power) % modulo\\n        }\\n        \\n\\t\\t// run sliding window for(i=0; i<=(s.length-k); i++)\\n        for(i in 0..(s.length-k)) {\\n            val sub = s.substring(i,i+k)\\n            if(find(sub, power, modulo, arr) == hashValue) {\\n                return sub\\n            }\\n        }\\n        return s\\n    }\\n    \\n    fun find(s: String, power: Int, modulo: Int, arr:LongArray) : Int {\\n        var x :Long = 0\\n        for(i in 0 until s.length) {\\n            x = x + ((s[i].toInt() - \\'a\\'.toInt() + 1) * arr[i]) % modulo\\n        }\\n        return (x%modulo).toInt()\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rolling Hash"
                ],
                "code": "```\\n\\nclass Solution {\\n    fun subStrHash(s: String, power: Int, modulo: Int, k: Int, hashValue: Int): String {\\n        var p : Long = 1\\n        var arr = LongArray(k){1}\\n\\t\\t// find and store power values in array separately to reuse & reduce time.\\n        for(i in 0 until k) {\\n            arr[i] = p\\n            p = (p * power) % modulo\\n        }\\n        \\n\\t\\t// run sliding window for(i=0; i<=(s.length-k); i++)\\n        for(i in 0..(s.length-k)) {\\n            val sub = s.substring(i,i+k)\\n            if(find(sub, power, modulo, arr) == hashValue) {\\n                return sub\\n            }\\n        }\\n        return s\\n    }\\n    \\n    fun find(s: String, power: Int, modulo: Int, arr:LongArray) : Int {\\n        var x :Long = 0\\n        for(i in 0 until s.length) {\\n            x = x + ((s[i].toInt() - \\'a\\'.toInt() + 1) * arr[i]) % modulo\\n        }\\n        return (x%modulo).toInt()\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731416,
                "title": "2-approaches-naive-to-efficient-window-sliding-technique-easy-c",
                "content": "Implementation\\n\\n**Naive Approach\\nGive TLE\\nTime Complexity = O(N * K * LogN)\\nSpace Complexity = O(LogN), bcz of the recursion call stack of power function**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // find the power of numbers in efficient way\\n    // using this way bcz of overflow issue\\n    // in this approach, everytime we are doing modulo, so it will never overflow\\n    // in pow directly we can\\'t do modulo\\n\\t// it will give the result into O(logN) time and will take O(logN) for the space\\n    unsigned long long int findPower(int power, int jtr, int modulo){\\n        if(jtr == 0) return 1;\\n        if(jtr == 1) return power%modulo;\\n        \\n        unsigned long long int ans = 1;\\n        unsigned long long int temp = findPower(power, jtr/2, modulo) % modulo;\\n        \\n        // if jtr is odd\\n        if(jtr % 2){\\n            ans = (ans * power) % modulo;            \\n        }\\n        \\n        return (ans * (temp * temp) % modulo) % modulo;\\n    }\\n    \\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {        \\n        for(int itr = 0; itr <= s.size()-k; itr++){\\n            \\n            string str = s.substr(itr, k);\\n            unsigned long long int ans = 0;\\n            \\n            for(int jtr = 0; jtr < str.size(); jtr++){\\n                unsigned long long int val = str[jtr] - int(\\'a\\') + 1;                \\n                // unsigned long long int powVal = pow(power, jtr);\\n                unsigned long long int powVal = findPower(power, jtr, modulo);\\n                ans =  ans + (val * powVal);\\n                ans = ans % modulo;\\n            }\\n            \\n            if(ans == hashValue){\\n                return str;\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```\\n\\n\\n\\n**Efficient Approach\\nUsing sliding window technique and finding the power of numbers efficiently\\nTime Complexity = O(N * LogN)\\nSpace Complexity = O(LogN), bcz of the recursion call stack of power function**\\n```\\nclass Solution {\\npublic:\\n    \\n    // find the power of numbers in efficient way\\n    // using this way bcz of overflow issue\\n    // in this approach, everytime we are doing modulo, so it will never overflow\\n    // in pow directly we can\\'t do modulo\\n    // it will give the result into O(logN) time and will take O(logN) for the space\\n    long long findPower(int power, int jtr, int modulo){\\n        if(jtr == 0) return 1;\\n        if(jtr == 1) return (power%modulo);\\n        \\n        long long ans = 1;\\n        long long temp = findPower(power, jtr/2, modulo) % modulo;\\n        \\n        // if jtr is odd\\n        if(jtr % 2){\\n            ans = (ans * power) % modulo;            \\n        }\\n        \\n        return (ans * ((temp * temp) % modulo)) % modulo;\\n    }\\n    \\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {        \\n        reverse(s.begin(), s.end());\\n        long long ans = 0;\\n        string result;\\n        \\n        // traversing over the string\\n        for(int itr = 0; itr < s.size(); itr++){\\n            \\n            // we will run this, until & unless we reach to k window\\n            if(itr < k){                \\n                long long val = s[itr] - \\'a\\' + 1;\\n                long long powVal = (findPower(power, k-1-itr, modulo)) % modulo;\\n                ans = (ans + ((val * powVal) % modulo)) % modulo;\\n                continue;\\n            }\\n            \\n            // if we got the ans \\n            if(ans == hashValue){\\n                string ansStr = s.substr(itr-k, k);\\n                result = ansStr;\\n            }\\n            \\n            // not got the result yet, so remove the char from the window            \\n            long long val = s[itr-k] - \\'a\\' + 1;\\n            long long powVal = (findPower(power, k-1, modulo)) % modulo;\\n            ans = (ans + modulo - ((val * powVal) % modulo)) % modulo;\\n            \\n            // add the new char into the window now, that\\'s why directly multiplying ans by power\\n            ans = (ans * power) % modulo;\\n            ans = (ans + (s[itr] - \\'a\\' + 1)) % modulo;\\n        }\\n        \\n        // if we got the ans in the last index \\n        if(ans == hashValue){\\n            string ansStr = s.substr(s.size()-k, k);\\n            result = ansStr;\\n        }\\n        \\n        // reversing the result, bcz in the starting we reversed the original string(s)\\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // find the power of numbers in efficient way\\n    // using this way bcz of overflow issue\\n    // in this approach, everytime we are doing modulo, so it will never overflow\\n    // in pow directly we can\\'t do modulo\\n\\t// it will give the result into O(logN) time and will take O(logN) for the space\\n    unsigned long long int findPower(int power, int jtr, int modulo){\\n        if(jtr == 0) return 1;\\n        if(jtr == 1) return power%modulo;\\n        \\n        unsigned long long int ans = 1;\\n        unsigned long long int temp = findPower(power, jtr/2, modulo) % modulo;\\n        \\n        // if jtr is odd\\n        if(jtr % 2){\\n            ans = (ans * power) % modulo;            \\n        }\\n        \\n        return (ans * (temp * temp) % modulo) % modulo;\\n    }\\n    \\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {        \\n        for(int itr = 0; itr <= s.size()-k; itr++){\\n            \\n            string str = s.substr(itr, k);\\n            unsigned long long int ans = 0;\\n            \\n            for(int jtr = 0; jtr < str.size(); jtr++){\\n                unsigned long long int val = str[jtr] - int(\\'a\\') + 1;                \\n                // unsigned long long int powVal = pow(power, jtr);\\n                unsigned long long int powVal = findPower(power, jtr, modulo);\\n                ans =  ans + (val * powVal);\\n                ans = ans % modulo;\\n            }\\n            \\n            if(ans == hashValue){\\n                return str;\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // find the power of numbers in efficient way\\n    // using this way bcz of overflow issue\\n    // in this approach, everytime we are doing modulo, so it will never overflow\\n    // in pow directly we can\\'t do modulo\\n    // it will give the result into O(logN) time and will take O(logN) for the space\\n    long long findPower(int power, int jtr, int modulo){\\n        if(jtr == 0) return 1;\\n        if(jtr == 1) return (power%modulo);\\n        \\n        long long ans = 1;\\n        long long temp = findPower(power, jtr/2, modulo) % modulo;\\n        \\n        // if jtr is odd\\n        if(jtr % 2){\\n            ans = (ans * power) % modulo;            \\n        }\\n        \\n        return (ans * ((temp * temp) % modulo)) % modulo;\\n    }\\n    \\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {        \\n        reverse(s.begin(), s.end());\\n        long long ans = 0;\\n        string result;\\n        \\n        // traversing over the string\\n        for(int itr = 0; itr < s.size(); itr++){\\n            \\n            // we will run this, until & unless we reach to k window\\n            if(itr < k){                \\n                long long val = s[itr] - \\'a\\' + 1;\\n                long long powVal = (findPower(power, k-1-itr, modulo)) % modulo;\\n                ans = (ans + ((val * powVal) % modulo)) % modulo;\\n                continue;\\n            }\\n            \\n            // if we got the ans \\n            if(ans == hashValue){\\n                string ansStr = s.substr(itr-k, k);\\n                result = ansStr;\\n            }\\n            \\n            // not got the result yet, so remove the char from the window            \\n            long long val = s[itr-k] - \\'a\\' + 1;\\n            long long powVal = (findPower(power, k-1, modulo)) % modulo;\\n            ans = (ans + modulo - ((val * powVal) % modulo)) % modulo;\\n            \\n            // add the new char into the window now, that\\'s why directly multiplying ans by power\\n            ans = (ans * power) % modulo;\\n            ans = (ans + (s[itr] - \\'a\\' + 1)) % modulo;\\n        }\\n        \\n        // if we got the ans in the last index \\n        if(ans == hashValue){\\n            string ansStr = s.substr(s.size()-k, k);\\n            result = ansStr;\\n        }\\n        \\n        // reversing the result, bcz in the starting we reversed the original string(s)\\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731353,
                "title": "c-rolling-hash-o-n-with-mod-arithmetic-explanation",
                "content": "The solution below applies a rolling hash with modular arithmetic. The key is to perform the calculations in reverse as it is easier to apply multiplication than division.\\n\\nThe hash for the last k values are initially calculated, following by a rolling hash in reverse order -> see solution below.\\n\\nTo understand the calculations for the rolling hash, here is a quick summary of the key mod properties:\\n(1) `(a+b) mod c = (a mod c + b mod c) mod c`\\n(2) `(a-b) mod c = (a mod c - b mod c) mod c`\\n(3) `(a*b) mod c = (a mod c * b mod c) mod c`\\n\\nThere is also the exponentiation property: `a^b mod c = (a mod c)^b) mod c`. However, this still relies on a power of `b`, which in our case with `p`,  can be `10^9` which leads to overflow. \\n\\nInstead we use (3) to calculate the power values to `p^(k-1)` as `pk` in the initial `k` pass. \\n\\n## C++\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int p, int m, int k, int hashValue) {\\n        int n = s.size();\\n\\t\\tp = p % m; // not necessary but can make a bit faster\\n\\t\\tint start; \\n        long long hash = 0, pk = 1;\\n        \\n\\t\\t// Initial hash calculated from the last k values of the string\\n        for (int i = 0; i < k; i++) {\\n\\t\\t\\t// Calculate power values using mod properties to prevent overflow\\n            if (i > 0) \\n                pk = pk * p % m;\\n            hash = (hash + (s[n-k+i]-\\'a\\'+1) * pk) % m;\\n        }\\n        if (hash == hashValue)\\n            start = n-k;\\n        \\n\\t\\t// Rolling hash in reverse order\\n        for (int i = n-k-1; i >= 0; i--) {\\n\\t\\t\\t// Subtract previous last character value s[i+k]*p(k-1) \\n            hash = (hash - (s[i+k]-\\'a\\'+1)%m * pk ) % m ;\\n\\t\\t\\t\\n\\t\\t\\t// Above line can result in negative result, thus we add m to ensure positivity\\n\\t\\t\\t// Reminder that 3 \\u2261 -2 mod 5\\n            if (hash < 0) \\n                hash += m; \\n\\t\\t\\t\\t\\n\\t\\t\\t// Multiple previous hash by p (and mod due to (3))\\n\\t\\t\\t// And the starting s[i] value and again mod\\n            hash = ( (hash * p) % m + (s[i]-\\'a\\'+1)%m ) % m;\\n            if (hash == hashValue)\\n                start = i;\\n        }\\n        return s.substr(start, k);\\n    }\\n};\\n```\\n\\nComplexity: `O(n)`\\nSpace: `O(1)`\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Rolling Hash"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string subStrHash(string s, int p, int m, int k, int hashValue) {\\n        int n = s.size();\\n\\t\\tp = p % m; // not necessary but can make a bit faster\\n\\t\\tint start; \\n        long long hash = 0, pk = 1;\\n        \\n\\t\\t// Initial hash calculated from the last k values of the string\\n        for (int i = 0; i < k; i++) {\\n\\t\\t\\t// Calculate power values using mod properties to prevent overflow\\n            if (i > 0) \\n                pk = pk * p % m;\\n            hash = (hash + (s[n-k+i]-\\'a\\'+1) * pk) % m;\\n        }\\n        if (hash == hashValue)\\n            start = n-k;\\n        \\n\\t\\t// Rolling hash in reverse order\\n        for (int i = n-k-1; i >= 0; i--) {\\n\\t\\t\\t// Subtract previous last character value s[i+k]*p(k-1) \\n            hash = (hash - (s[i+k]-\\'a\\'+1)%m * pk ) % m ;\\n\\t\\t\\t\\n\\t\\t\\t// Above line can result in negative result, thus we add m to ensure positivity\\n\\t\\t\\t// Reminder that 3 \\u2261 -2 mod 5\\n            if (hash < 0) \\n                hash += m; \\n\\t\\t\\t\\t\\n\\t\\t\\t// Multiple previous hash by p (and mod due to (3))\\n\\t\\t\\t// And the starting s[i] value and again mod\\n            hash = ( (hash * p) % m + (s[i]-\\'a\\'+1)%m ) % m;\\n            if (hash == hashValue)\\n                start = i;\\n        }\\n        return s.substr(start, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731090,
                "title": "kindly-help-me-to-find-out-error-in-the-program-i-use-sliding-window",
                "content": "Help\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n\\t\\t\\tlong int comHash=0, p=1;\\n\\t\\t\\t//Find Hash Value till k-2th position\\n\\t\\t\\tfor(int i=0; i<k-1; i++) {\\n\\t\\t\\t\\tif(comHash > INT_MAX-(s[i]-\\'a\\'+1)*p) {\\n\\t\\t\\t\\t\\tcomHash = comHash%modulo;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcomHash += (s[i]-\\'a\\'+1)*p;\\n\\t\\t\\t\\tp = p*power;\\n\\t\\t\\t\\tif(p>INT_MAX) {\\n\\t\\t\\t\\t\\tp = p%modulo;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t//Use sliding window\\n\\t\\t\\tfor(int i=0; i+k-1<s.length(); i++) {\\n\\t\\t\\t\\tif(comHash > INT_MAX-(s[i+k-1]-\\'a\\'+1)*p) {\\n\\t\\t\\t\\t\\tcomHash = comHash%modulo;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcomHash += (s[i+k-1]-\\'a\\'+1)*p;\\n\\t\\t\\t\\tif(comHash%modulo==hashValue) {\\n\\t\\t\\t\\t\\treturn s.substr(i,k);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcomHash -= (s[i]-\\'a\\'+1);\\n\\t\\t\\t\\tcomHash = comHash/power;\\n\\t\\t\\t}\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t};\\n\\n43 out of 90 test casses passed. Error in the below test case.\\nInput:\\n\"cbmzzngpnfyzoexfnzxhhyvzxibaijgfvaleowaqjllkgoercyiptkugzgcxobn\"\\n83\\n56\\n27\\n23\\nOutput: \"zngpnfyzoexfnzxhhyvzxibaijg\"\\nExpected: \"hyvzxibaijgfvaleowaqjllkgoe\"",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n\\t\\t\\tlong int comHash=0, p=1;\\n\\t\\t\\t//Find Hash Value till k-2th position\\n\\t\\t\\tfor(int i=0; i<k-1; i++) {\\n\\t\\t\\t\\tif(comHash > INT_MAX-(s[i]-\\'a\\'+1)*p) {\\n\\t\\t\\t\\t\\tcomHash = comHash%modulo;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1731022,
                "title": "runtime-error-integer-overflow-help",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring subStrHash(string s, int power, int modulo, int k, int hashvalue) {\\n\\t\\t\\t\\tlong long hash=0;\\n\\t\\t\\t\\tlong long p=1,start=0,i;\\n\\n\\t\\t\\t   for(i=0;i<k;i++){\\n\\t\\t\\t\\t   hash+=((s[i]-\\'a\\'+1)*p);\\n\\t\\t\\t\\t   p=p*power;\\n\\t\\t\\t   }\\n\\t\\t\\t  if((hash%modulo)==hashvalue)\\n\\t\\t\\t\\t   return s.substr(start,i-start);\\n\\n\\t\\t\\t  p=p/power;\\n\\t\\t\\t  for(long long j=i;j<s.length();j++){\\n\\t\\t\\t\\t  hash-=(s[start]-\\'a\\'+1);\\n\\t\\t\\t\\t  start++;\\n\\t\\t\\t\\t  hash/=power;\\n\\t\\t\\t\\t  hash+=(s[j]-\\'a\\'+1)*p;\\n\\t\\t\\t\\t   if((hash%modulo)==hashvalue) return s.substr(start,j-start+1);\\n\\t\\t\\t  }\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Rolling Hash"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring subStrHash(string s, int power, int modulo, int k, int hashvalue) {\\n\\t\\t\\t\\tlong long hash=0;\\n\\t\\t\\t\\tlong long p=1,start=0,i;\\n\\n\\t\\t\\t   for(i=0;i<k;i++){\\n\\t\\t\\t\\t   hash+=((s[i]-\\'a\\'+1)*p);\\n\\t\\t\\t\\t   p=p*power;\\n\\t\\t\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 1730876,
                "title": "my-python-solution-beats-50-of-python-solutions",
                "content": "I explained my idea in this medium article: https://shadek07.medium.com/leetcode-a-rolling-hash-coding-problem-ec43d415c72c\\n",
                "solutionTags": [
                    "Rolling Hash"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1730822,
                "title": "can-someone-help-me-with-tle",
                "content": "```\\nclass Solution {\\npublic:\\n   #define ll long long int  \\nll exponentMod(ll A, ll B, ll C)\\n{\\n    // Base cases\\n    if (A == 0)\\n        return 0;\\n    if (B == 0)\\n        return 1;\\n \\n    // If B is even\\n    ll y;\\n    if (B % 2 == 0) {\\n        y = exponentMod(A, B / 2, C);\\n        y = (y * y) % C;\\n    }\\n \\n    // If B is odd\\n    else {\\n        y = A % C;\\n        y = (y * exponentMod(A, B - 1, C) % C) % C;\\n    }\\n \\n    return (ll)((y + C) % C);\\n}\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n          int i=0;\\n          int j=0;\\n          int n = s.length();\\n        \\n          ll count=0;\\n          ll hash = (s[0]-\\'a\\'+1)*exponentMod(power,0,modulo);\\n        string sub=\"\";\\n        sub+=s[0];\\n          while(i<n&&j<n){\\n              cout<<hash<<\" \";\\n              if(j-i+1==k){\\n                 \\n                  if((hash%modulo)==hashValue){\\n                      return sub;\\n                  }\\n                  hash= (hash%modulo-(((sub[i]-\\'a\\'+1)*((ll)exponentMod(power,0,modulo)))%modulo))%modulo; \\n                  hash = hash*power;\\n                  sub.erase(0,1);\\n                  i++;\\n                  j++;\\n                  \\n                 \\n     hash=(hash%modulo+(((sub[j]-\\'a\\'+1)*((ll)exponentMod(power,j,modulo)))%modulo))%modulo; \\n                  \\n                  cout<<sub<<\" \"<<hash<<\"\\\\n\";\\n                 \\n              }\\n              else{\\n                 \\n                  j++;\\n                  count++;\\n                   hash = (hash%modulo+(((s[j]-\\'a\\'+1)*((ll)exponentMod(power,count,modulo)))%modulo))%modulo;\\n                  sub+=s[j];\\n              }\\n          }\\n        return sub;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   #define ll long long int  \\nll exponentMod(ll A, ll B, ll C)\\n{\\n    // Base cases\\n    if (A == 0)\\n        return 0;\\n    if (B == 0)\\n        return 1;\\n \\n    // If B is even\\n    ll y;\\n    if (B % 2 == 0) {\\n        y = exponentMod(A, B / 2, C);\\n        y = (y * y) % C;\\n    }\\n \\n    // If B is odd\\n    else {\\n        y = A % C;\\n        y = (y * exponentMod(A, B - 1, C) % C) % C;\\n    }\\n \\n    return (ll)((y + C) % C);\\n}\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n          int i=0;\\n          int j=0;\\n          int n = s.length();\\n        \\n          ll count=0;\\n          ll hash = (s[0]-\\'a\\'+1)*exponentMod(power,0,modulo);\\n        string sub=\"\";\\n        sub+=s[0];\\n          while(i<n&&j<n){\\n              cout<<hash<<\" \";\\n              if(j-i+1==k){\\n                 \\n                  if((hash%modulo)==hashValue){\\n                      return sub;\\n                  }\\n                  hash= (hash%modulo-(((sub[i]-\\'a\\'+1)*((ll)exponentMod(power,0,modulo)))%modulo))%modulo; \\n                  hash = hash*power;\\n                  sub.erase(0,1);\\n                  i++;\\n                  j++;\\n                  \\n                 \\n     hash=(hash%modulo+(((sub[j]-\\'a\\'+1)*((ll)exponentMod(power,j,modulo)))%modulo))%modulo; \\n                  \\n                  cout<<sub<<\" \"<<hash<<\"\\\\n\";\\n                 \\n              }\\n              else{\\n                 \\n                  j++;\\n                  count++;\\n                   hash = (hash%modulo+(((s[j]-\\'a\\'+1)*((ll)exponentMod(power,count,modulo)))%modulo))%modulo;\\n                  sub+=s[j];\\n              }\\n          }\\n        return sub;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1730743,
                "title": "golang-solution",
                "content": "*Runtime: 2004 ms\\nMemory Usage: 6.8 MB*\\n\\n**Modulo properties**\\n```\\n(a + b) mod n = [(a mod n) + (b mod n)] mod n\\nab mod n = [(a mod n)(b mod n)] mod n\\n```\\n\\n**Calculate p^k mod m**\\nThen `p^k mod m` is\\n```\\np^k mod m = ((p mod m) * (p mod m) * ... * (p mod m)) mod m\\n```\\nto speed up `p^k mod m`, we write to the array `arrPP[k]`\\n\\n**Calculate hash**\\n\\nTo simplify write `val(s[i])` as `v`\\n```\\nhash = (v*p^0 + v*p^1 + ... + v*p^k) mod m \\n```\\nis equal\\n```\\nsum = v mod m\\n\\t\\t+ (((v mod m)*arrP[1]) mod m)\\n\\t\\t+ (((v mod m)*arrP[2]) mod m)\\n\\t\\t+ ... \\n\\t\\t+ (((v mod m)*arrP[k]) mod m)\\nhash = sum mod m\\n```\\n\\n**Solution code**\\n```\\nfunc subStrHash(s string, power int, modulo int, k int, hashValue int) string {\\n    length := len(s)\\n\\t\\n    //caching p^k mod m to array\\n    arrPP := []int{0}\\n    pp := 1\\n    for j:=1; j<=k; j++ {\\n        pp *= power % modulo\\n        pp = pp % modulo\\n        arrPP = append(arrPP, pp)\\n    }\\n\\t\\n    //caching val(s[i]) mod m to array\\n    arrV := make([]int, length)\\n    for i, letter := range s {\\n        arrV[i] = int(letter-\\'a\\'+1) % modulo\\n    }\\n    \\n    //Moving the substring by one letter\\n    for i, _ := range s[:length-k] {\\n        hash := calcSub(arrV[i:i+k], power, modulo, &arrPP)\\n        if hash == hashValue {\\n            return s[i:i+k]\\n        }\\n    }\\n    \\n    return s[length-k:]\\n}\\n\\nfunc calcSub(sub []int, p int, m int, arrPP *[]int) int {\\n    arrPP2 := *arrPP\\n    sum := 0\\n    for i, v := range sub {\\n        if (i == 0) {\\n            sum += v\\n        } else {\\n            sum += (v * arrPP2[i]) % m    \\n        }\\n    }\\n    return sum % m\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n(a + b) mod n = [(a mod n) + (b mod n)] mod n\\nab mod n = [(a mod n)(b mod n)] mod n\\n```\n```\\np^k mod m = ((p mod m) * (p mod m) * ... * (p mod m)) mod m\\n```\n```\\nhash = (v*p^0 + v*p^1 + ... + v*p^k) mod m \\n```\n```\\nsum = v mod m\\n\\t\\t+ (((v mod m)*arrP[1]) mod m)\\n\\t\\t+ (((v mod m)*arrP[2]) mod m)\\n\\t\\t+ ... \\n\\t\\t+ (((v mod m)*arrP[k]) mod m)\\nhash = sum mod m\\n```\n```\\nfunc subStrHash(s string, power int, modulo int, k int, hashValue int) string {\\n    length := len(s)\\n\\t\\n    //caching p^k mod m to array\\n    arrPP := []int{0}\\n    pp := 1\\n    for j:=1; j<=k; j++ {\\n        pp *= power % modulo\\n        pp = pp % modulo\\n        arrPP = append(arrPP, pp)\\n    }\\n\\t\\n    //caching val(s[i]) mod m to array\\n    arrV := make([]int, length)\\n    for i, letter := range s {\\n        arrV[i] = int(letter-\\'a\\'+1) % modulo\\n    }\\n    \\n    //Moving the substring by one letter\\n    for i, _ := range s[:length-k] {\\n        hash := calcSub(arrV[i:i+k], power, modulo, &arrPP)\\n        if hash == hashValue {\\n            return s[i:i+k]\\n        }\\n    }\\n    \\n    return s[length-k:]\\n}\\n\\nfunc calcSub(sub []int, p int, m int, arrPP *[]int) int {\\n    arrPP2 := *arrPP\\n    sum := 0\\n    for i, v := range sub {\\n        if (i == 0) {\\n            sum += v\\n        } else {\\n            sum += (v * arrPP2[i]) % m    \\n        }\\n    }\\n    return sum % m\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730683,
                "title": "any-suggestions-for-improving-my-code-time-limit-exceeded",
                "content": "class Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n\\t\\n        count = 0\\n        for i in range(len(s)-(k-1)):\\n            for j in range(k):\\n                count += (ord(s[i:i+k][j]) - 96) * (power ** j)\\n            if count % modulo == hashValue:\\n                return s[i:i+k]\\n            else:\\n                count = 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n\\t\\n        count = 0\\n        for i in range(len(s)-(k-1)):\\n            for j in range(k):\\n                count += (ord(s[i:i+k][j]) - 96) * (power ** j)\\n            if count % modulo == hashValue:\\n                return s[i:i+k]\\n            else:\\n                count = 0",
                "codeTag": "Java"
            },
            {
                "id": 1730650,
                "title": "python-3-rolling-hash-backward-or-forward",
                "content": "Rolling from the end to the front, easier to implement compared to rolling forward.\\n\\n```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        def func(ss):\\n            h = 0\\n            p = 1\\n            for c in ss:\\n                h = (h + dc[c] * p) % modulo\\n                p = (p * power) % modulo\\n            return h\\n        \\n        orda = ord(\\'a\\')\\n        dc = {}\\n        for i in range(26):\\n            dc[chr(orda + i)] = i + 1 \\n            \\n        N = len(s)    \\n        ans = s[N-k:]\\n        h = func(s[N-k:])\\n        p = pow(power, k - 1, modulo)\\n        for i in range(N-k-1, -1, -1):\\n            h -= dc[s[i+k]] * p\\n            h = (h * power + dc[s[i]]) % modulo\\n            if h == hashValue:\\n                ans = s[i:i+k]\\n        return ans\\n```\\n\\n\\nRolling front to end, need to modify hashValue to find a match, and once a match found, need to compute the original hash to avoid clash.\\n\\n```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        def func(ss):\\n            h = 0\\n            for c in reversed(ss):\\n                h = (h * power + dc[c]) % modulo\\n            return h\\n        \\n        orda = ord(\\'a\\')\\n        dc = {}\\n        for i in range(26):\\n            dc[chr(orda + i)] = i + 1\\n        \\n        hashCopy = hashValue\\n        N = len(s)\\n        h = func(s[:k])\\n        if h == hashValue:\\n            return s[:k]\\n        for i in range(1, N - k + 1):\\n            hashValue = (hashValue * power) % modulo\\n            h -= dc[s[i-1]] * pow(power, i - 1, modulo)\\n            h += dc[s[i+k-1]] * pow(power, i + k - 1, modulo)\\n            h %= modulo\\n            if h == hashValue and hashCopy == func(s[i:i+k]): # Need to double check against the original hash to avoid clash\\n                return s[i:i+k]\\n```",
                "solutionTags": [
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        def func(ss):\\n            h = 0\\n            p = 1\\n            for c in ss:\\n                h = (h + dc[c] * p) % modulo\\n                p = (p * power) % modulo\\n            return h\\n        \\n        orda = ord(\\'a\\')\\n        dc = {}\\n        for i in range(26):\\n            dc[chr(orda + i)] = i + 1 \\n            \\n        N = len(s)    \\n        ans = s[N-k:]\\n        h = func(s[N-k:])\\n        p = pow(power, k - 1, modulo)\\n        for i in range(N-k-1, -1, -1):\\n            h -= dc[s[i+k]] * p\\n            h = (h * power + dc[s[i]]) % modulo\\n            if h == hashValue:\\n                ans = s[i:i+k]\\n        return ans\\n```\n```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        def func(ss):\\n            h = 0\\n            for c in reversed(ss):\\n                h = (h * power + dc[c]) % modulo\\n            return h\\n        \\n        orda = ord(\\'a\\')\\n        dc = {}\\n        for i in range(26):\\n            dc[chr(orda + i)] = i + 1\\n        \\n        hashCopy = hashValue\\n        N = len(s)\\n        h = func(s[:k])\\n        if h == hashValue:\\n            return s[:k]\\n        for i in range(1, N - k + 1):\\n            hashValue = (hashValue * power) % modulo\\n            h -= dc[s[i-1]] * pow(power, i - 1, modulo)\\n            h += dc[s[i+k-1]] * pow(power, i + k - 1, modulo)\\n            h %= modulo\\n            if h == hashValue and hashCopy == func(s[i:i+k]): # Need to double check against the original hash to avoid clash\\n                return s[i:i+k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730643,
                "title": "python-sliding-window",
                "content": "I tried the same solution during the contest, but failed. In my case, what I did was, for the power I used double start ( ** ) for power calculation, I guess that made it fail (time complexity). \\n\\nThis is not the best solution though, I feel it can be improved by using dictionary to store value at an index, and then taking index value using it, rather than calculating again.\\n\\nHope it helps :)\\n\\n\\n```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        end = 0\\n        start = 0\\n        total = 0\\n        powr = 1\\n        for i in range(k):\\n            \\n            total = total + ((ord(s[end]) - ord(\\'a\\') + 1)) * powr\\n            powr = powr * power\\n            end +=1\\n            \\n            \\n        res = total % modulo\\n        \\n        if res == hashValue:\\n            return s[start:end]\\n        \\n        \\n        start = 1\\n        end = k\\n        powr = powr // power \\n        while end < len(s):\\n            \\n            total = total - ((ord(s[start-1]) - ord(\\'a\\') +1))\\n            total //=power\\n            \\n            total = total + ((ord(s[end]) - ord(\\'a\\') +1) * powr)\\n\\n            if total % modulo == hashValue:\\n                return s[start:end+1]\\n                \\n                \\n            end +=1\\n            start +=1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        end = 0\\n        start = 0\\n        total = 0\\n        powr = 1\\n        for i in range(k):\\n            \\n            total = total + ((ord(s[end]) - ord(\\'a\\') + 1)) * powr\\n            powr = powr * power\\n            end +=1\\n            \\n            \\n        res = total % modulo\\n        \\n        if res == hashValue:\\n            return s[start:end]\\n        \\n        \\n        start = 1\\n        end = k\\n        powr = powr // power \\n        while end < len(s):\\n            \\n            total = total - ((ord(s[start-1]) - ord(\\'a\\') +1))\\n            total //=power\\n            \\n            total = total + ((ord(s[end]) - ord(\\'a\\') +1) * powr)\\n\\n            if total % modulo == hashValue:\\n                return s[start:end+1]\\n                \\n                \\n            end +=1\\n            start +=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730582,
                "title": "rabinkarp-hashing-java",
                "content": "```\\nclass Solution {\\n    class RabinKarpHashing {\\n        long[] h, p;\\n        // h[i]: [0, i) \\n        // h[i, j) = h[0, j) - h[0, i)\\n        int modulo;\\n        int n;\\n        // power = 131\\n        // modulo = 1_000_000_007\\n        RabinKarpHashing(String s, int power, int modulo) {\\n            this.n = s.length();\\n            this.modulo = modulo;\\n            h = new long[n + 1]; p = new long[n + 1];\\n            p[0] = 1;\\n            for (int i = 1; i <= s.length(); i++) {\\n                h[i] = ((h[i - 1] * power) % modulo + (s.charAt(i - 1) - \\'a\\' + 1)) % modulo;\\n                p[i] = (p[i - 1] * power) % modulo;\\n            }\\n\\n        }\\n        private long getHashKey(int i, int j) {\\n            // [i, j)\\n            return ((h[j] - (h[i] * p[j - i]) % modulo + modulo)) % modulo;\\n        }\\n    }\\n\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n        StringBuilder builder = new StringBuilder(s);\\n        s = builder.reverse().toString();\\n        RabinKarpHashing hash = new RabinKarpHashing(s, power, modulo);\\n        for(int i = s.length() - 1; i - k + 1 >= 0; i--) {\\n            if((int) hash.getHashKey(i - k + 1, i + 1) == hashValue) {\\n                StringBuilder temp = new StringBuilder(s.substring(i - k + 1, i + 1));\\n                return temp.reverse().toString();\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class RabinKarpHashing {\\n        long[] h, p;\\n        // h[i]: [0, i) \\n        // h[i, j) = h[0, j) - h[0, i)\\n        int modulo;\\n        int n;\\n        // power = 131\\n        // modulo = 1_000_000_007\\n        RabinKarpHashing(String s, int power, int modulo) {\\n            this.n = s.length();\\n            this.modulo = modulo;\\n            h = new long[n + 1]; p = new long[n + 1];\\n            p[0] = 1;\\n            for (int i = 1; i <= s.length(); i++) {\\n                h[i] = ((h[i - 1] * power) % modulo + (s.charAt(i - 1) - \\'a\\' + 1)) % modulo;\\n                p[i] = (p[i - 1] * power) % modulo;\\n            }\\n\\n        }\\n        private long getHashKey(int i, int j) {\\n            // [i, j)\\n            return ((h[j] - (h[i] * p[j - i]) % modulo + modulo)) % modulo;\\n        }\\n    }\\n\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n        StringBuilder builder = new StringBuilder(s);\\n        s = builder.reverse().toString();\\n        RabinKarpHashing hash = new RabinKarpHashing(s, power, modulo);\\n        for(int i = s.length() - 1; i - k + 1 >= 0; i--) {\\n            if((int) hash.getHashKey(i - k + 1, i + 1) == hashValue) {\\n                StringBuilder temp = new StringBuilder(s.substring(i - k + 1, i + 1));\\n                return temp.reverse().toString();\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730561,
                "title": "why-this-is-not-working-plz-explain",
                "content": "```\\nclass Solution {\\npublic:\\n    long long binpow(long long a, long long b, long long m) {\\n    a %= m;\\n    long long res = 1;\\n    while (b > 0) {\\n        if (b & 1)\\n            res = res * a % m;\\n        a = a * a % m;\\n        b >>= 1;\\n    }\\n    return res;\\n}\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        //string ans=\"\";\\n        vector<long long int> v;\\n        long long int temp=0;\\n        for(int i=0;i<s.size();i++){\\n            temp+=((s[i]-96)%modulo)*(binpow(power,i,modulo));\\n            v.push_back(temp%modulo);\\n            cout<<v[i]<<\" \";\\n        }\\n        string ans=\"\";int j;\\n        for(int i=0;i<s.size();i++){\\n            \\n            if(s.size()-i<k)break;\\n            long long int temp=0;\\n            if(i!=0)\\n            temp=(v[i+k-1]-v[i-1])%modulo;\\n            else temp=(v[i+k-1])%modulo;\\n            temp/=((binpow(power,i,modulo)));\\n            temp%=modulo;\\n            cout<<temp<<\" \";\\n            if(temp==hashValue){\\n                j=i;break;\\n            }\\n        }\\n        ans=s.substr(j,k);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long binpow(long long a, long long b, long long m) {\\n    a %= m;\\n    long long res = 1;\\n    while (b > 0) {\\n        if (b & 1)\\n            res = res * a % m;\\n        a = a * a % m;\\n        b >>= 1;\\n    }\\n    return res;\\n}\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        //string ans=\"\";\\n        vector<long long int> v;\\n        long long int temp=0;\\n        for(int i=0;i<s.size();i++){\\n            temp+=((s[i]-96)%modulo)*(binpow(power,i,modulo));\\n            v.push_back(temp%modulo);\\n            cout<<v[i]<<\" \";\\n        }\\n        string ans=\"\";int j;\\n        for(int i=0;i<s.size();i++){\\n            \\n            if(s.size()-i<k)break;\\n            long long int temp=0;\\n            if(i!=0)\\n            temp=(v[i+k-1]-v[i-1])%modulo;\\n            else temp=(v[i+k-1])%modulo;\\n            temp/=((binpow(power,i,modulo)));\\n            temp%=modulo;\\n            cout<<temp<<\" \";\\n            if(temp==hashValue){\\n                j=i;break;\\n            }\\n        }\\n        ans=s.substr(j,k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1730529,
                "title": "please-help-in-debugging",
                "content": "\\nHey could you please look into below code and tell what\\'s wrong that it\\'s not giving right answer and not even throwing TLE error although it\\'s passing sample test cases\\n\\n```\\nclass Solution {\\npublic:\\n    int hashVal(string &s,int &p,int &mod,int i,int j)\\n    {\\n        double val = 0;\\n        int power = -1;\\n        \\n        for(int ind = i;ind<=j;ind++)\\n        {\\n            val += ((double)(s[ind] - \\'a\\' + 1))*pow(p,++power);\\n        }\\n        //cout<<\"\\\\nHash for => \"<<s.substr(i,j-i+1)<<\" = \"<<(int)fmod(val,mod);\\n        return (int)fmod(val,mod);\\n    }\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        \\n        //cout<<endl<<\"Input: power = \"<<power<<\",\\\\tmodulo = \"<<modulo<<\"\\\\tk = \"<<k<<\"\\\\thashValue = \"<<hashValue<<endl;\\n        int totLen = s.length();\\n       \\n        int len = k;\\n        for(int i=0;(i+len-1)<totLen;i++)//last index of string starting at i of length = len is (i+len-1)\\n        {\\n            if(hashVal(s,power,modulo,i,i+len-1)==hashValue)\\n                return s.substr(i,len);\\n        }\\n        return s.substr(0,len);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hashVal(string &s,int &p,int &mod,int i,int j)\\n    {\\n        double val = 0;\\n        int power = -1;\\n        \\n        for(int ind = i;ind<=j;ind++)\\n        {\\n            val += ((double)(s[ind] - \\'a\\' + 1))*pow(p,++power);\\n        }\\n        //cout<<\"\\\\nHash for => \"<<s.substr(i,j-i+1)<<\" = \"<<(int)fmod(val,mod);\\n        return (int)fmod(val,mod);\\n    }\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        \\n        //cout<<endl<<\"Input: power = \"<<power<<\",\\\\tmodulo = \"<<modulo<<\"\\\\tk = \"<<k<<\"\\\\thashValue = \"<<hashValue<<endl;\\n        int totLen = s.length();\\n       \\n        int len = k;\\n        for(int i=0;(i+len-1)<totLen;i++)//last index of string starting at i of length = len is (i+len-1)\\n        {\\n            if(hashVal(s,power,modulo,i,i+len-1)==hashValue)\\n                return s.substr(i,len);\\n        }\\n        return s.substr(0,len);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1730520,
                "title": "help-help",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        int sol = 0;\\n        long long int powr = 1;\\n        \\n        for (int j = 0; j < k; j++) {\\n                sol += ((s[j] - \\'a\\' + 1) * (powr)) % modulo;\\n                powr = (powr * power) % modulo;\\n        }\\n        if (sol % modulo == hashValue) {\\n            return s.substr(0, k);\\n        }\\n        \\n        powr = 1;\\n        for (int i = 0; i < k - 1; i++) {\\n            powr = (powr * power) % modulo;\\n        }\\n        \\n        for (int i = 1; i < s.size() - k + 1; i++) {\\n            sol = (((sol - (s[i - 1] - \\'a\\' + 1)) / power) + ((s[i + k - 1] - \\'a\\' + 1) * powr)) % modulo;\\n            if (sol == hashValue) {\\n                return s.substr(i, k);\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n};\\n```\\n\\n**I know there is something wrong in type conversion and modulo operator, but unable to figure out. Please provide some help and suggestion**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        int sol = 0;\\n        long long int powr = 1;\\n        \\n        for (int j = 0; j < k; j++) {\\n                sol += ((s[j] - \\'a\\' + 1) * (powr)) % modulo;\\n                powr = (powr * power) % modulo;\\n        }\\n        if (sol % modulo == hashValue) {\\n            return s.substr(0, k);\\n        }\\n        \\n        powr = 1;\\n        for (int i = 0; i < k - 1; i++) {\\n            powr = (powr * power) % modulo;\\n        }\\n        \\n        for (int i = 1; i < s.size() - k + 1; i++) {\\n            sol = (((sol - (s[i - 1] - \\'a\\' + 1)) / power) + ((s[i + k - 1] - \\'a\\' + 1) * powr)) % modulo;\\n            if (sol == hashValue) {\\n                return s.substr(i, k);\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730514,
                "title": "python-sliding-window-o-n",
                "content": "```\\nclass Solution:\\n    def subStrHash(self, s, power, modulo, k, hashValue):\\n        \"\"\"\\n        :type s: str\\n        :type power: int\\n        :type modulo: int\\n        :type k: int\\n        :type hashValue: int\\n        :rtype: str\\n        \\n        \"\"\"\\n        char_mapping = {}\\n        for i in range(97, 123):\\n            char_mapping[chr(i)] = i - 96\\n        \\n        \\n        left, right = 0, k - 1\\n        ans = deque()\\n        temp_sum = 0\\n        temp = 1\\n        for i in range(left, right+1):\\n            temp_sum += char_mapping[s[i]]*temp\\n            temp *= power\\n            ans.append(s[i])\\n        \\n        temp //= power\\n        if temp_sum % modulo == hashValue:\\n            return \\'\\'.join(ans)\\n        \\n        print(ans)\\n        \\n        while right < len(s):\\n              temp_sum -= char_mapping[s[left]]\\n              ans.popleft()\\n              temp_sum //= power\\n              left, right = left + 1, right + 1\\n              if right >= len(s):\\n                    break\\n              temp_sum += char_mapping[s[right]]*temp\\n              ans.append(s[right])\\n              if temp_sum % modulo  == hashValue:\\n                  return \\'\\'.join(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s, power, modulo, k, hashValue):\\n        \"\"\"\\n        :type s: str\\n        :type power: int\\n        :type modulo: int\\n        :type k: int\\n        :type hashValue: int\\n        :rtype: str\\n        \\n        \"\"\"\\n        char_mapping = {}\\n        for i in range(97, 123):\\n            char_mapping[chr(i)] = i - 96\\n        \\n        \\n        left, right = 0, k - 1\\n        ans = deque()\\n        temp_sum = 0\\n        temp = 1\\n        for i in range(left, right+1):\\n            temp_sum += char_mapping[s[i]]*temp\\n            temp *= power\\n            ans.append(s[i])\\n        \\n        temp //= power\\n        if temp_sum % modulo == hashValue:\\n            return \\'\\'.join(ans)\\n        \\n        print(ans)\\n        \\n        while right < len(s):\\n              temp_sum -= char_mapping[s[left]]\\n              ans.popleft()\\n              temp_sum //= power\\n              left, right = left + 1, right + 1\\n              if right >= len(s):\\n                    break\\n              temp_sum += char_mapping[s[right]]*temp\\n              ans.append(s[right])\\n              if temp_sum % modulo  == hashValue:\\n                  return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730431,
                "title": "swift-sliding-window-solution",
                "content": "```swift\\nclass Solution {\\n    func subStrHash(_ s: String, _ power: Int, _ modulo: Int, _ k: Int, _ hashValue: Int) -> String {\\n        let s = Array(s)\\n        \\n        var first = 0\\n        var hash = 0\\n        var offset = modPower(base: power, exponent: k, modulo: modulo)\\n        for i in (0 ..< s.count).reversed() {            \\n            hash *= power\\n            \\n            hash += alphabetValue(of: s[i])\\n            hash %= modulo\\n            \\n            if i + k < s.count {\\n                hash -= alphabetValue(of: s[i + k]) * offset\\n                \\n                while hash < 0 {\\n                    hash += modulo\\n                }\\n                \\n                hash %= modulo\\n            }\\n            \\n            // print(s[i ..< min(s.count, i + k)], hash)\\n            if hash == hashValue, i + k <= s.count {\\n                first = i\\n            }\\n        }\\n        \\n        return String(s[first ..< first + k])\\n    }\\n    \\n    private func modPower(base: Int, exponent: Int, modulo: Int) -> Int {\\n        var result = 1\\n        \\n        for i in 0 ..< exponent {\\n            result *= base % modulo\\n            result %= modulo\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func alphabetValue(of character: Character) -> Int {\\n        return Int(character.asciiValue!) - Int(Character(\"a\").asciiValue!) + 1\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func subStrHash(_ s: String, _ power: Int, _ modulo: Int, _ k: Int, _ hashValue: Int) -> String {\\n        let s = Array(s)\\n        \\n        var first = 0\\n        var hash = 0\\n        var offset = modPower(base: power, exponent: k, modulo: modulo)\\n        for i in (0 ..< s.count).reversed() {            \\n            hash *= power\\n            \\n            hash += alphabetValue(of: s[i])\\n            hash %= modulo\\n            \\n            if i + k < s.count {\\n                hash -= alphabetValue(of: s[i + k]) * offset\\n                \\n                while hash < 0 {\\n                    hash += modulo\\n                }\\n                \\n                hash %= modulo\\n            }\\n            \\n            // print(s[i ..< min(s.count, i + k)], hash)\\n            if hash == hashValue, i + k <= s.count {\\n                first = i\\n            }\\n        }\\n        \\n        return String(s[first ..< first + k])\\n    }\\n    \\n    private func modPower(base: Int, exponent: Int, modulo: Int) -> Int {\\n        var result = 1\\n        \\n        for i in 0 ..< exponent {\\n            result *= base % modulo\\n            result %= modulo\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func alphabetValue(of character: Character) -> Int {\\n        return Int(character.asciiValue!) - Int(Character(\"a\").asciiValue!) + 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730384,
                "title": "python-o-n-sliding-window-approach-but-got-tle",
                "content": "Approach: \\n1. First for-loop: I applied the sum function (without calculating modular) for the first k element (start index: 0, end index: k-1)\\n2. Second for-loop: for each time the window moves, I calculated the new sum using the formular:\\n`sum = (sumVal - val(s[i-1])) // power + val(s[endIdx])*(power**(endIdx-i))`\\n\\nExplain:\\nSum with startIdx = 0, endIdx = k-1 for `sum(s,p,startIdx,endIdx)`\\n\\n`sum(s, p, 0, k-1) = (val(s[0]) * p**0 + val(s[1]) * p**1 + ... + val(s[k-1]) *p**(k-1))`\\nSum with startIdx = 1, endIdx = k\\n`sum(s, p,1,k) = (   sum(s,p,0,k-1)-val(s[0]   ) //p    +     val(s[k])*p**k`\\n\\n\\n3. If the modular of the calculated sum is equal to the hashValue, returns the substring.\\n\\n\\n\\n```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        \\n        @lru_cache(None)\\n        def val(char):\\n            return ord(char) - ord(\\'a\\') + 1\\n        \\n        sumVal = 0\\n        tempPower = 1\\n        for i in range(k):\\n            sumVal += val(s[i]) * tempPower\\n            tempPower *= power\\n\\n        n = len(s)\\n        for i in range(0, n-k+1):\\n            if i != 0:\\n                endIdx = i+k-1\\n                sumVal = (sumVal - val(s[i-1])) // power + val(s[endIdx])*(power**(endIdx-i))\\n                \\n            if sumVal % modulo == hashValue:\\n                return s[i:i+k]\\n        \\n        return \"\"\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        \\n        @lru_cache(None)\\n        def val(char):\\n            return ord(char) - ord(\\'a\\') + 1\\n        \\n        sumVal = 0\\n        tempPower = 1\\n        for i in range(k):\\n            sumVal += val(s[i]) * tempPower\\n            tempPower *= power\\n\\n        n = len(s)\\n        for i in range(0, n-k+1):\\n            if i != 0:\\n                endIdx = i+k-1\\n                sumVal = (sumVal - val(s[i-1])) // power + val(s[endIdx])*(power**(endIdx-i))\\n                \\n            if sumVal % modulo == hashValue:\\n                return s[i:i+k]\\n        \\n        return \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730379,
                "title": "sliding-window-o-n",
                "content": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        def indexLetter(letter):\\n            return ord(letter) - ord(\\'a\\') + 1\\n        \\n        l = len(s)-k\\n        p_k = pow(power,k,modulo)\\n        cur = 0\\n        \\n        for i in range(k):\\n            cur = (cur + indexLetter(s[l+i])* pow(power,i,modulo) ) % modulo\\n\\n        if cur == hashValue:\\n            res=l\\n        while l>0:\\n            cur = (cur*power - indexLetter(s[l+k-1])*p_k + indexLetter(s[l-1])) % modulo\\n            \\n            l-=1\\n            if cur == hashValue:\\n                res=l\\n        \\n        return s[res:res+k]\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        def indexLetter(letter):\\n            return ord(letter) - ord(\\'a\\') + 1\\n        \\n        l = len(s)-k\\n        p_k = pow(power,k,modulo)\\n        cur = 0\\n        \\n        for i in range(k):\\n            cur = (cur + indexLetter(s[l+i])* pow(power,i,modulo) ) % modulo\\n\\n        if cur == hashValue:\\n            res=l\\n        while l>0:\\n            cur = (cur*power - indexLetter(s[l+k-1])*p_k + indexLetter(s[l-1])) % modulo\\n            \\n            l-=1\\n            if cur == hashValue:\\n                res=l\\n        \\n        return s[res:res+k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730360,
                "title": "don-t-use-python3-use-python-got-acccepted",
                "content": "Very ordinary O(n) solution. I didn\\'t pass in python3, but after I changed to python it was accepted. Apprarently the time limit for python3 should be adjusted.\\n```\\nclass Solution(object):\\n    def subStrHash(self, s, power, modulo, k, hashValue):\\n        \"\"\"\\n        :type s: str\\n        :type power: int\\n        :type modulo: int\\n        :type k: int\\n        :type hashValue: int\\n        :rtype: str\\n        \"\"\"\\n        val = {chr(i): i-96 for i in range(97, 123)}\\n\\n        from collections import deque\\n        q = deque(maxlen=k)\\n        window_sum = 0\\n        power_base = 1\\n        for i in range(k):\\n            new_letter = s[i]\\n            q.append(new_letter)            \\n            window_sum += val[new_letter] * power_base\\n            power_base *= power\\n\\n        modulo_result = window_sum % modulo\\n        if modulo_result == hashValue:\\n            return s[:k]            \\n                \\n        new_multiplier = power ** (k-1) \\n        for i in range(k, len(s)):\\n            new_letter = s[i]\\n            old_val = val[q.popleft()]\\n            new_val = val[new_letter] * new_multiplier\\n            window_sum = (window_sum - old_val)//power + new_val\\n            q.append(new_letter)\\n            \\n            if window_sum % modulo == hashValue:\\n                break\\n\\n        result = \\'\\'.join(list(q))\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def subStrHash(self, s, power, modulo, k, hashValue):\\n        \"\"\"\\n        :type s: str\\n        :type power: int\\n        :type modulo: int\\n        :type k: int\\n        :type hashValue: int\\n        :rtype: str\\n        \"\"\"\\n        val = {chr(i): i-96 for i in range(97, 123)}\\n\\n        from collections import deque\\n        q = deque(maxlen=k)\\n        window_sum = 0\\n        power_base = 1\\n        for i in range(k):\\n            new_letter = s[i]\\n            q.append(new_letter)            \\n            window_sum += val[new_letter] * power_base\\n            power_base *= power\\n\\n        modulo_result = window_sum % modulo\\n        if modulo_result == hashValue:\\n            return s[:k]            \\n                \\n        new_multiplier = power ** (k-1) \\n        for i in range(k, len(s)):\\n            new_letter = s[i]\\n            old_val = val[q.popleft()]\\n            new_val = val[new_letter] * new_multiplier\\n            window_sum = (window_sum - old_val)//power + new_val\\n            q.append(new_letter)\\n            \\n            if window_sum % modulo == hashValue:\\n                break\\n\\n        result = \\'\\'.join(list(q))\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730330,
                "title": "tried-o-n-solution-why-does-this-fail",
                "content": "What I tried to do is compute the current substring\\'s hash by removing the last substring\\'s first character, dividing the previous hash (before modulo) by the power, and then adding the last part of the new hash.\\n\\nIt worked for the given test cases, but failed on submission. I couldn\\'t figure out what the problem was. Could it be an overflow issue?\\n\\n```class Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        vals = list()\\n        for char in s:\\n            vals.append(ord(char) - 96)\\n        \\n        i = 0\\n        total = None\\n        while True:\\n            if i == 0:\\n                total = 0\\n                for j in range(k):\\n                    total += (vals[j] * pow(power, j))\\n            else:\\n                total -= vals[i-1]\\n                total /= power\\n                total += vals[i + k - 1] * pow(power, k - 1)\\n            \\n            print(total)\\n            if total % modulo == hashValue:\\n                return s[i:i+k]\\n            \\n            i += 1\\n```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        vals = list()\\n        for char in s:\\n            vals.append(ord(char) - 96)\\n        \\n        i = 0\\n        total = None\\n        while True:\\n            if i == 0:\\n                total = 0\\n                for j in range(k):\\n                    total += (vals[j] * pow(power, j))\\n            else:\\n                total -= vals[i-1]\\n                total /= power\\n                total += vals[i + k - 1] * pow(power, k - 1)\\n            \\n            print(total)\\n            if total % modulo == hashValue:\\n                return s[i:i+k]\\n            \\n            i += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730325,
                "title": "sliding-window-python-simple-solution",
                "content": "# Approach\\n```\\nH[0] = hash(s[:k], p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) \\n```\\n```\\nH[1] = hash(s[1:1+k], p, m) = (val(s[1]) * p0 + val(s[2]) * p1 + ... + val(s[1+k-1]) * pk-1) \\n```\\n```\\nH[2] = hash(s[2:2+k], p, m) = (val(s[2]) * p0 + val(s[3]) * p1 + ... + val(s[2+k-1]) * pk-1) \\n```\\n```\\nH[i] = hash(s[i:i+k], p, m) = (val(s[i]) * p0 + val(s[i+1]) * p1 + ... + val(s[i+k-1]) * pk-1) \\n```\\n```\\nH[i+1] = hash(s[i+1:i+1+k], p, m) = (H[i] - (val(s[i]) * p0))/power + (val(s[i+k]) * pk-1)\\n```\\n\\n\\n\\n# CODE\\n```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        sol = 0\\n        powr = 1\\n        \\n        for i in range(0, k, 1):\\n            sol += (ord(s[i]) - ord(\\'a\\') + 1) * powr\\n            powr = powr * power\\n        if sol % modulo == hashValue: \\n            return s[:k]\\n        \\n        powr = powr // power\\n        for i in range(1, len(s) - k + 1, 1):\\n            sol = ((sol - (ord(s[i - 1]) - ord(\\'a\\') + 1)) // power) + ((ord(s[i + k - 1]) - ord(\\'a\\') + 1) * powr)\\n            if (sol % modulo == hashValue):\\n                return s[i:i + k]\\n            \\n        return \"\"\\n            \\n```\\n\\n**Unable to solve in C++ with same approach** :( \\n\\nFeel free to ask doubts.\\nAnd please share some suggestions.\\nHappy coding :)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nH[0] = hash(s[:k], p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) \\n```\n```\\nH[1] = hash(s[1:1+k], p, m) = (val(s[1]) * p0 + val(s[2]) * p1 + ... + val(s[1+k-1]) * pk-1) \\n```\n```\\nH[2] = hash(s[2:2+k], p, m) = (val(s[2]) * p0 + val(s[3]) * p1 + ... + val(s[2+k-1]) * pk-1) \\n```\n```\\nH[i] = hash(s[i:i+k], p, m) = (val(s[i]) * p0 + val(s[i+1]) * p1 + ... + val(s[i+k-1]) * pk-1) \\n```\n```\\nH[i+1] = hash(s[i+1:i+1+k], p, m) = (H[i] - (val(s[i]) * p0))/power + (val(s[i+k]) * pk-1)\\n```\n```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        sol = 0\\n        powr = 1\\n        \\n        for i in range(0, k, 1):\\n            sol += (ord(s[i]) - ord(\\'a\\') + 1) * powr\\n            powr = powr * power\\n        if sol % modulo == hashValue: \\n            return s[:k]\\n        \\n        powr = powr // power\\n        for i in range(1, len(s) - k + 1, 1):\\n            sol = ((sol - (ord(s[i - 1]) - ord(\\'a\\') + 1)) // power) + ((ord(s[i + k - 1]) - ord(\\'a\\') + 1) * powr)\\n            if (sol % modulo == hashValue):\\n                return s[i:i + k]\\n            \\n        return \"\"\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730322,
                "title": "easy-python-solution-but-suffers-tle-issues",
                "content": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        for i in range(len(s)):\\n            substring = s[i:i+k]\\n            hash_val = 0\\n            for j in range(k):\\n                hash_val += (ord(substring[j]) - ord(\\'a\\') + 1) * power**j\\n            while hash_val > modulo:\\n                hash_val %= modulo\\n            if hash_val == hashValue:\\n                return substring\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n        for i in range(len(s)):\\n            substring = s[i:i+k]\\n            hash_val = 0\\n            for j in range(k):\\n                hash_val += (ord(substring[j]) - ord(\\'a\\') + 1) * power**j\\n            while hash_val > modulo:\\n                hash_val %= modulo\\n            if hash_val == hashValue:\\n                return substring\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730306,
                "title": "c-store-hash-value-of-each-character-but-fail",
                "content": "I tried to store power of each character first and then multiply each character with that.\\nAnd then use sliding window to solve this quesition, but I failed :(.\\nCould anyone point our my failure?\\n```\\nclass Solution {\\nprivate:\\n    int val(char c){\\n        return c-\\'a\\'+1;\\n    }\\npublic:\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        vector<long long> mods(s.length());\\n        mods[0] = 1;\\n        for(int i=1; i<s.length(); i++){\\n            mods[i] = (mods[i-1]*power)%modulo;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            mods[i] = (mods[i]*val(s[i]))%modulo;\\n        }\\n        long long sum = 0;\\n        // First k chars of s\\n        for(int i=0; i<k; i++){\\n            sum = (mods[i]+sum)%modulo;\\n        }\\n        if(sum == hashValue)\\n            return s.substr(0, k);\\n        // Sliding Window\\n        for(int i=k; i<s.length(); i++){\\n            sum -= mods[i-k];\\n            if(sum < 0)\\n                sum += modulo;\\n            sum = (mods[i]+sum)%modulo;\\n            if(sum == hashValue)\\n                return s.substr(i-k+1, k);\\n        }\\n        return string();\\n    }\\n};\\n```\\n\\nFail at\\n\"xxterzixjqrghqyeketqeynekvqhc\"\\n15\\n94\\n4\\n16\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int val(char c){\\n        return c-\\'a\\'+1;\\n    }\\npublic:\\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\\n        vector<long long> mods(s.length());\\n        mods[0] = 1;\\n        for(int i=1; i<s.length(); i++){\\n            mods[i] = (mods[i-1]*power)%modulo;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            mods[i] = (mods[i]*val(s[i]))%modulo;\\n        }\\n        long long sum = 0;\\n        // First k chars of s\\n        for(int i=0; i<k; i++){\\n            sum = (mods[i]+sum)%modulo;\\n        }\\n        if(sum == hashValue)\\n            return s.substr(0, k);\\n        // Sliding Window\\n        for(int i=k; i<s.length(); i++){\\n            sum -= mods[i-k];\\n            if(sum < 0)\\n                sum += modulo;\\n            sum = (mods[i]+sum)%modulo;\\n            if(sum == hashValue)\\n                return s.substr(i-k+1, k);\\n        }\\n        return string();\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567727,
                "content": [
                    {
                        "username": "about_anuj",
                        "content": "i was optimising solution in sliding window but got integer overflow every time :("
                    },
                    {
                        "username": "NathanRLiu",
                        "content": "I wasn\\'t able to solve this problem because I kept hitting the upper bound for Integer values. I\\'m curious to know what your guys\\' solutions were to combat this, so please let me know!"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid hitting the upper bound for integer values in your subStrHash function, first, pre-compute the ordinal values of characters in s and store them in the ord_values list, avoiding repeated recalculations of ord(ch) - ord(\\'a\\') + 1. Second, consistently use the modulo operator (% mod) after every mathematical operation, ensuring that hash_val remains within typical integer limits and preventing overflow. Lastly, by storing the position res when the hash matches hashValue, you can effortlessly extract and return the corresponding substring from s."
                    },
                    {
                        "username": "zz0913",
                        "content": "1. (a*b)%m = (a%m*b%m)%m\\n2. (a+b)%m = (a%m+b%m)%m\\n"
                    },
                    {
                        "username": "jinyang_deng",
                        "content": "![image](https://assets.leetcode.com/users/images/4f9bb389-2f9a-433c-aecd-280116b213b2_1644576029.5060549.jpeg)\\n"
                    },
                    {
                        "username": "hanbangze",
                        "content": "I need help...\nTLE. I think the runtime of the hash() function is too long. But how can I improve it to O(n)?\n Helping would be appreciated!\n ```cpp\n\nclass Solution {\npublic:\n    string subStrHash(string s, long long power, long long modulo, long long k, int hashValue) {\n        //cout<<hash(\"ode\",7,20,8)<<endl;\n        string ans;\n        for(long long i=0;i<s.size()-k+1;i++)\n        {\n            string tmp=\"\";\n            for(long long j=0;j<k;j++)\n            {\n                tmp+=s[i+j];\n            }\n            if(hash(tmp,power,modulo,k)==hashValue)\n            {\n                return tmp;\n            }\n        }\n        return ans;\n    }\n    long long hash(string s,int p,int m,int k)\n    {\n        long long ans=0;\n        for(long long i=0;i<k;i++)\n        {\n            //cout<<s[i]-'a'<<' '<<pow(p,i)<<' '<<(s[i]-'a')*pow(p,i)<<endl;\n            ans=(long long)(ans+(s[i]-'a'+1)*qpow(p,i,m))%m;\n        }\n        return ans;\n    }\n    long long qpow(int p,int exp,int m)\n    {\n        long long ans=1;\n        for(int i=0;i<exp;i++)\n        {\n            ans*=p;\n            ans%=m;\n        }\n        return ans;\n    }\n};\n```\nTime Limit Exceeded\nLast Executed Input\n23 / 90 testcases passed\n"
                    },
                    {
                        "username": "janis__",
                        "content": "To resolve the time limit exceeded error, implement a rolling hash technique, wherein you compute the hash value of the first k characters and for each subsequent character, you efficiently update the hash value in constant time (O(1)), eliminating the need for recomputing the entire hash. This shift to a rolling hash approach will transform the overall runtime of your hashing mechanism to O(n) from the current O(n*k)."
                    },
                    {
                        "username": "reassurance",
                        "content": "Your TC: O(N^2)\\nGiven this is a Hard Problem, it is quite obvious that your solution might TLE on smaller test cases as well"
                    }
                ]
            },
            {
                "id": 1568719,
                "content": [
                    {
                        "username": "about_anuj",
                        "content": "i was optimising solution in sliding window but got integer overflow every time :("
                    },
                    {
                        "username": "NathanRLiu",
                        "content": "I wasn\\'t able to solve this problem because I kept hitting the upper bound for Integer values. I\\'m curious to know what your guys\\' solutions were to combat this, so please let me know!"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid hitting the upper bound for integer values in your subStrHash function, first, pre-compute the ordinal values of characters in s and store them in the ord_values list, avoiding repeated recalculations of ord(ch) - ord(\\'a\\') + 1. Second, consistently use the modulo operator (% mod) after every mathematical operation, ensuring that hash_val remains within typical integer limits and preventing overflow. Lastly, by storing the position res when the hash matches hashValue, you can effortlessly extract and return the corresponding substring from s."
                    },
                    {
                        "username": "zz0913",
                        "content": "1. (a*b)%m = (a%m*b%m)%m\\n2. (a+b)%m = (a%m+b%m)%m\\n"
                    },
                    {
                        "username": "jinyang_deng",
                        "content": "![image](https://assets.leetcode.com/users/images/4f9bb389-2f9a-433c-aecd-280116b213b2_1644576029.5060549.jpeg)\\n"
                    },
                    {
                        "username": "hanbangze",
                        "content": "I need help...\nTLE. I think the runtime of the hash() function is too long. But how can I improve it to O(n)?\n Helping would be appreciated!\n ```cpp\n\nclass Solution {\npublic:\n    string subStrHash(string s, long long power, long long modulo, long long k, int hashValue) {\n        //cout<<hash(\"ode\",7,20,8)<<endl;\n        string ans;\n        for(long long i=0;i<s.size()-k+1;i++)\n        {\n            string tmp=\"\";\n            for(long long j=0;j<k;j++)\n            {\n                tmp+=s[i+j];\n            }\n            if(hash(tmp,power,modulo,k)==hashValue)\n            {\n                return tmp;\n            }\n        }\n        return ans;\n    }\n    long long hash(string s,int p,int m,int k)\n    {\n        long long ans=0;\n        for(long long i=0;i<k;i++)\n        {\n            //cout<<s[i]-'a'<<' '<<pow(p,i)<<' '<<(s[i]-'a')*pow(p,i)<<endl;\n            ans=(long long)(ans+(s[i]-'a'+1)*qpow(p,i,m))%m;\n        }\n        return ans;\n    }\n    long long qpow(int p,int exp,int m)\n    {\n        long long ans=1;\n        for(int i=0;i<exp;i++)\n        {\n            ans*=p;\n            ans%=m;\n        }\n        return ans;\n    }\n};\n```\nTime Limit Exceeded\nLast Executed Input\n23 / 90 testcases passed\n"
                    },
                    {
                        "username": "janis__",
                        "content": "To resolve the time limit exceeded error, implement a rolling hash technique, wherein you compute the hash value of the first k characters and for each subsequent character, you efficiently update the hash value in constant time (O(1)), eliminating the need for recomputing the entire hash. This shift to a rolling hash approach will transform the overall runtime of your hashing mechanism to O(n) from the current O(n*k)."
                    },
                    {
                        "username": "reassurance",
                        "content": "Your TC: O(N^2)\\nGiven this is a Hard Problem, it is quite obvious that your solution might TLE on smaller test cases as well"
                    }
                ]
            },
            {
                "id": 1570776,
                "content": [
                    {
                        "username": "about_anuj",
                        "content": "i was optimising solution in sliding window but got integer overflow every time :("
                    },
                    {
                        "username": "NathanRLiu",
                        "content": "I wasn\\'t able to solve this problem because I kept hitting the upper bound for Integer values. I\\'m curious to know what your guys\\' solutions were to combat this, so please let me know!"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid hitting the upper bound for integer values in your subStrHash function, first, pre-compute the ordinal values of characters in s and store them in the ord_values list, avoiding repeated recalculations of ord(ch) - ord(\\'a\\') + 1. Second, consistently use the modulo operator (% mod) after every mathematical operation, ensuring that hash_val remains within typical integer limits and preventing overflow. Lastly, by storing the position res when the hash matches hashValue, you can effortlessly extract and return the corresponding substring from s."
                    },
                    {
                        "username": "zz0913",
                        "content": "1. (a*b)%m = (a%m*b%m)%m\\n2. (a+b)%m = (a%m+b%m)%m\\n"
                    },
                    {
                        "username": "jinyang_deng",
                        "content": "![image](https://assets.leetcode.com/users/images/4f9bb389-2f9a-433c-aecd-280116b213b2_1644576029.5060549.jpeg)\\n"
                    },
                    {
                        "username": "hanbangze",
                        "content": "I need help...\nTLE. I think the runtime of the hash() function is too long. But how can I improve it to O(n)?\n Helping would be appreciated!\n ```cpp\n\nclass Solution {\npublic:\n    string subStrHash(string s, long long power, long long modulo, long long k, int hashValue) {\n        //cout<<hash(\"ode\",7,20,8)<<endl;\n        string ans;\n        for(long long i=0;i<s.size()-k+1;i++)\n        {\n            string tmp=\"\";\n            for(long long j=0;j<k;j++)\n            {\n                tmp+=s[i+j];\n            }\n            if(hash(tmp,power,modulo,k)==hashValue)\n            {\n                return tmp;\n            }\n        }\n        return ans;\n    }\n    long long hash(string s,int p,int m,int k)\n    {\n        long long ans=0;\n        for(long long i=0;i<k;i++)\n        {\n            //cout<<s[i]-'a'<<' '<<pow(p,i)<<' '<<(s[i]-'a')*pow(p,i)<<endl;\n            ans=(long long)(ans+(s[i]-'a'+1)*qpow(p,i,m))%m;\n        }\n        return ans;\n    }\n    long long qpow(int p,int exp,int m)\n    {\n        long long ans=1;\n        for(int i=0;i<exp;i++)\n        {\n            ans*=p;\n            ans%=m;\n        }\n        return ans;\n    }\n};\n```\nTime Limit Exceeded\nLast Executed Input\n23 / 90 testcases passed\n"
                    },
                    {
                        "username": "janis__",
                        "content": "To resolve the time limit exceeded error, implement a rolling hash technique, wherein you compute the hash value of the first k characters and for each subsequent character, you efficiently update the hash value in constant time (O(1)), eliminating the need for recomputing the entire hash. This shift to a rolling hash approach will transform the overall runtime of your hashing mechanism to O(n) from the current O(n*k)."
                    },
                    {
                        "username": "reassurance",
                        "content": "Your TC: O(N^2)\\nGiven this is a Hard Problem, it is quite obvious that your solution might TLE on smaller test cases as well"
                    }
                ]
            },
            {
                "id": 1576365,
                "content": [
                    {
                        "username": "about_anuj",
                        "content": "i was optimising solution in sliding window but got integer overflow every time :("
                    },
                    {
                        "username": "NathanRLiu",
                        "content": "I wasn\\'t able to solve this problem because I kept hitting the upper bound for Integer values. I\\'m curious to know what your guys\\' solutions were to combat this, so please let me know!"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid hitting the upper bound for integer values in your subStrHash function, first, pre-compute the ordinal values of characters in s and store them in the ord_values list, avoiding repeated recalculations of ord(ch) - ord(\\'a\\') + 1. Second, consistently use the modulo operator (% mod) after every mathematical operation, ensuring that hash_val remains within typical integer limits and preventing overflow. Lastly, by storing the position res when the hash matches hashValue, you can effortlessly extract and return the corresponding substring from s."
                    },
                    {
                        "username": "zz0913",
                        "content": "1. (a*b)%m = (a%m*b%m)%m\\n2. (a+b)%m = (a%m+b%m)%m\\n"
                    },
                    {
                        "username": "jinyang_deng",
                        "content": "![image](https://assets.leetcode.com/users/images/4f9bb389-2f9a-433c-aecd-280116b213b2_1644576029.5060549.jpeg)\\n"
                    },
                    {
                        "username": "hanbangze",
                        "content": "I need help...\nTLE. I think the runtime of the hash() function is too long. But how can I improve it to O(n)?\n Helping would be appreciated!\n ```cpp\n\nclass Solution {\npublic:\n    string subStrHash(string s, long long power, long long modulo, long long k, int hashValue) {\n        //cout<<hash(\"ode\",7,20,8)<<endl;\n        string ans;\n        for(long long i=0;i<s.size()-k+1;i++)\n        {\n            string tmp=\"\";\n            for(long long j=0;j<k;j++)\n            {\n                tmp+=s[i+j];\n            }\n            if(hash(tmp,power,modulo,k)==hashValue)\n            {\n                return tmp;\n            }\n        }\n        return ans;\n    }\n    long long hash(string s,int p,int m,int k)\n    {\n        long long ans=0;\n        for(long long i=0;i<k;i++)\n        {\n            //cout<<s[i]-'a'<<' '<<pow(p,i)<<' '<<(s[i]-'a')*pow(p,i)<<endl;\n            ans=(long long)(ans+(s[i]-'a'+1)*qpow(p,i,m))%m;\n        }\n        return ans;\n    }\n    long long qpow(int p,int exp,int m)\n    {\n        long long ans=1;\n        for(int i=0;i<exp;i++)\n        {\n            ans*=p;\n            ans%=m;\n        }\n        return ans;\n    }\n};\n```\nTime Limit Exceeded\nLast Executed Input\n23 / 90 testcases passed\n"
                    },
                    {
                        "username": "janis__",
                        "content": "To resolve the time limit exceeded error, implement a rolling hash technique, wherein you compute the hash value of the first k characters and for each subsequent character, you efficiently update the hash value in constant time (O(1)), eliminating the need for recomputing the entire hash. This shift to a rolling hash approach will transform the overall runtime of your hashing mechanism to O(n) from the current O(n*k)."
                    },
                    {
                        "username": "reassurance",
                        "content": "Your TC: O(N^2)\\nGiven this is a Hard Problem, it is quite obvious that your solution might TLE on smaller test cases as well"
                    }
                ]
            },
            {
                "id": 1751098,
                "content": [
                    {
                        "username": "about_anuj",
                        "content": "i was optimising solution in sliding window but got integer overflow every time :("
                    },
                    {
                        "username": "NathanRLiu",
                        "content": "I wasn\\'t able to solve this problem because I kept hitting the upper bound for Integer values. I\\'m curious to know what your guys\\' solutions were to combat this, so please let me know!"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid hitting the upper bound for integer values in your subStrHash function, first, pre-compute the ordinal values of characters in s and store them in the ord_values list, avoiding repeated recalculations of ord(ch) - ord(\\'a\\') + 1. Second, consistently use the modulo operator (% mod) after every mathematical operation, ensuring that hash_val remains within typical integer limits and preventing overflow. Lastly, by storing the position res when the hash matches hashValue, you can effortlessly extract and return the corresponding substring from s."
                    },
                    {
                        "username": "zz0913",
                        "content": "1. (a*b)%m = (a%m*b%m)%m\\n2. (a+b)%m = (a%m+b%m)%m\\n"
                    },
                    {
                        "username": "jinyang_deng",
                        "content": "![image](https://assets.leetcode.com/users/images/4f9bb389-2f9a-433c-aecd-280116b213b2_1644576029.5060549.jpeg)\\n"
                    },
                    {
                        "username": "hanbangze",
                        "content": "I need help...\nTLE. I think the runtime of the hash() function is too long. But how can I improve it to O(n)?\n Helping would be appreciated!\n ```cpp\n\nclass Solution {\npublic:\n    string subStrHash(string s, long long power, long long modulo, long long k, int hashValue) {\n        //cout<<hash(\"ode\",7,20,8)<<endl;\n        string ans;\n        for(long long i=0;i<s.size()-k+1;i++)\n        {\n            string tmp=\"\";\n            for(long long j=0;j<k;j++)\n            {\n                tmp+=s[i+j];\n            }\n            if(hash(tmp,power,modulo,k)==hashValue)\n            {\n                return tmp;\n            }\n        }\n        return ans;\n    }\n    long long hash(string s,int p,int m,int k)\n    {\n        long long ans=0;\n        for(long long i=0;i<k;i++)\n        {\n            //cout<<s[i]-'a'<<' '<<pow(p,i)<<' '<<(s[i]-'a')*pow(p,i)<<endl;\n            ans=(long long)(ans+(s[i]-'a'+1)*qpow(p,i,m))%m;\n        }\n        return ans;\n    }\n    long long qpow(int p,int exp,int m)\n    {\n        long long ans=1;\n        for(int i=0;i<exp;i++)\n        {\n            ans*=p;\n            ans%=m;\n        }\n        return ans;\n    }\n};\n```\nTime Limit Exceeded\nLast Executed Input\n23 / 90 testcases passed\n"
                    },
                    {
                        "username": "janis__",
                        "content": "To resolve the time limit exceeded error, implement a rolling hash technique, wherein you compute the hash value of the first k characters and for each subsequent character, you efficiently update the hash value in constant time (O(1)), eliminating the need for recomputing the entire hash. This shift to a rolling hash approach will transform the overall runtime of your hashing mechanism to O(n) from the current O(n*k)."
                    },
                    {
                        "username": "reassurance",
                        "content": "Your TC: O(N^2)\\nGiven this is a Hard Problem, it is quite obvious that your solution might TLE on smaller test cases as well"
                    }
                ]
            }
        ]
    }
]